stdout of test 'MAL-signatures` in directory 'clients` itself:


# 21:44:50 >  
# 21:44:50 >  "mserver5" "--debug=10" "--set" "gdk_nr_threads=0" "--set" "mapi_open=true" "--set" "mapi_port=33053" "--set" "mapi_usock=/var/tmp/mtest-13793/.s.monetdb.33053" "--set" "monet_prompt=" "--forcemito" "--set" "mal_listing=2" "--dbpath=/home/sjoerd/Monet-devel/var/MonetDB/mTests_clients" "--set" "mal_listing=2" "--set" "embedded_r=yes"
# 21:44:50 >  

# MonetDB 5 server v11.20.0
# This is an unreleased version
# Serving database 'mTests_clients', using 8 threads
# Compiled for x86_64-unknown-linux-gnu/64bit with 128bit integers
# Found 15.386 GiB available main-memory.
# Copyright (c) 1993 - July 2008 CWI.
# Copyright (c) August 2008 - 2018 MonetDB B.V., all rights reserved
# Visit https://www.monetdb.org/ for further information
# Listening for connection requests on mapi:monetdb://xps13:39285/
# Listening for UNIX domain connection requests on mapi:monetdb:///var/tmp/mtest-1158/.s.monetdb.39285
# MonetDB/GIS module loaded
# SQL catalog created, loading sql scripts once
# loading sql script: 09_like.sql
# loading sql script: 10_math.sql
# loading sql script: 11_times.sql
# loading sql script: 12_url.sql
# loading sql script: 13_date.sql
# loading sql script: 14_inet.sql
# loading sql script: 15_querylog.sql
# loading sql script: 16_tracelog.sql
# loading sql script: 17_temporal.sql
# loading sql script: 18_index.sql
# loading sql script: 20_vacuum.sql
# loading sql script: 21_dependency_functions.sql
# loading sql script: 22_clients.sql
# loading sql script: 23_skyserver.sql
# loading sql script: 24_zorder.sql
# loading sql script: 25_debug.sql
# loading sql script: 26_sysmon.sql
# loading sql script: 27_rejects.sql
# loading sql script: 39_analytics.sql
# loading sql script: 39_analytics_hge.sql
# loading sql script: 40_geom.sql
# loading sql script: 40_json.sql
# loading sql script: 40_json_hge.sql
# loading sql script: 41_md5sum.sql
# loading sql script: 45_uuid.sql
# loading sql script: 46_gsl.sql
# loading sql script: 46_profiler.sql
# loading sql script: 51_sys_schema_extension.sql
# loading sql script: 72_fits.sql
# loading sql script: 74_netcdf.sql
# loading sql script: 75_shp.sql
# loading sql script: 75_storagemodel.sql
# loading sql script: 80_statistics.sql
# loading sql script: 80_udf.sql
# loading sql script: 80_udf_hge.sql
# loading sql script: 85_bam.sql
# loading sql script: 90_generator.sql
# loading sql script: 90_generator_hge.sql
# loading sql script: 99_system.sql
# MonetDB/SQL module loaded
# MonetDB/Python2 module loaded
# MonetDB/R   module loaded

# 16:10:29 >  
# 16:10:29 >  "mclient" "-lsql" "-ftest" "-tnone" "-Eutf-8" "-i" "-e" "--host=/var/tmp/mtest-29643" "--port=32888"
# 16:10:29 >  

#select * from sys.malfunctions() order by module, "function", address, signature, comment;
% .%1,	.%1,	.%1,	.%1,	.%1 # table_name
% module,	function,	signature,	address,	comment # name
% clob,	clob,	clob,	clob,	clob # type
% 12,	28,	364,	38,	874 # length
[ "aggr",	"allnotequal",	"command aggr.allnotequal(l:bat[:any_1], r:bat[:any_1]):bit ",	"SQLallnotequal;",	"if all values in r are not equal to l return true, else if r has nil nil else false"	]
[ "aggr",	"anyequal",	"pattern aggr.anyequal(l:any_1, r:any_1):bit ",	"CMDvarEQ;",	""	]
[ "aggr",	"anyequal",	"command aggr.anyequal(l:bat[:any_1], r:bat[:any_1]):bit ",	"SQLanyequal;",	"if any value in r is equal to l return true, else if r has nil nil else false"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on bte"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on dbl"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on flt"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:hge], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on hge"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on int"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on lng"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on sht"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] ",	"AGGRavg14_dbl;",	"Grouped tail average on bte"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] ",	"AGGRavg14_dbl;",	"Grouped tail average on dbl"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] ",	"AGGRavg14_dbl;",	"Grouped tail average on flt"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:int], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] ",	"AGGRavg14_dbl;",	"Grouped tail average on int"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] ",	"AGGRavg14_dbl;",	"Grouped tail average on lng"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] ",	"AGGRavg14_dbl;",	"Grouped tail average on sht"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:bte], g:bat[:oid], e:bat[:any_1]) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on bte, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on dbl, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:flt], g:bat[:oid], e:bat[:any_1]) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on flt, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:hge], g:bat[:oid], e:bat[:any_1]) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on hge, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:int], g:bat[:oid], e:bat[:any_1]) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on int, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:lng], g:bat[:oid], e:bat[:any_1]) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on lng, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:sht], g:bat[:oid], e:bat[:any_1]) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on sht, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg24_dbl;",	"Grouped tail average on bte, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg24_dbl;",	"Grouped tail average on dbl, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg24_dbl;",	"Grouped tail average on flt, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:int], g:bat[:oid], e:bat[:any_1], scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg24_dbl;",	"Grouped tail average on int, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg24_dbl;",	"Grouped tail average on lng, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRavg24_dbl;",	"Grouped tail average on sht, also returns count"	]
[ "aggr",	"avg",	"pattern aggr.avg(b:bat[:any_2]):dbl ",	"CMDcalcavg;",	"Gives the avg of all tail values"	]
[ "aggr",	"avg",	"pattern aggr.avg(b:bat[:any_2], scale:int):dbl ",	"CMDcalcavg;",	"Gives the avg of all tail values"	]
[ "aggr",	"cardinality",	"command aggr.cardinality(b:bat[:any_2]):lng ",	"ALGcard;",	"Return the cardinality of the BAT tail values."	]
[ "aggr",	"corr",	"command aggr.corr(b1:bat[:bte], b2:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcorr;",	"Correlation aggregate"	]
[ "aggr",	"corr",	"command aggr.corr(b1:bat[:dbl], b2:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcorr;",	"Correlation aggregate"	]
[ "aggr",	"corr",	"command aggr.corr(b1:bat[:flt], b2:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcorr;",	"Correlation aggregate"	]
[ "aggr",	"corr",	"command aggr.corr(b1:bat[:hge], b2:bat[:hge], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcorr;",	"Correlation aggregate"	]
[ "aggr",	"corr",	"command aggr.corr(b1:bat[:int], b2:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcorr;",	"Correlation aggregate"	]
[ "aggr",	"corr",	"command aggr.corr(b1:bat[:lng], b2:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcorr;",	"Correlation aggregate"	]
[ "aggr",	"corr",	"command aggr.corr(b1:bat[:sht], b2:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcorr;",	"Correlation aggregate"	]
[ "aggr",	"corr",	"command aggr.corr(b1:bat[:any_2], b2:bat[:any_2]):dbl ",	"ALGcorr;",	"Gives the correlation of all tail values"	]
[ "aggr",	"count",	"command aggr.count(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], ignorenils:bit):bat[:lng] ",	"AGGRcount3;",	""	]
[ "aggr",	"count",	"command aggr.count(b:bat[:any_1], g:bat[:oid], e:bat[:any_2]):bat[:lng] ",	"AGGRcount3nils;",	"Grouped count"	]
[ "aggr",	"count",	"command aggr.count(b:bat[:any], cnd:bat[:oid]):lng ",	"ALGcountCND_bat;",	"Return the current size (in number of elements) in a BAT."	]
[ "aggr",	"count",	"command aggr.count(b:bat[:any], cnd:bat[:oid], ignore_nils:bit):lng ",	"ALGcountCND_nil;",	"Return the number of elements currently in a BAT ignores\n\t\tBUNs with nil-tail iff ignore_nils==TRUE."	]
[ "aggr",	"count",	"command aggr.count(b:bat[:any]):lng ",	"ALGcount_bat;",	"Return the current size (in number of elements) in a BAT."	]
[ "aggr",	"count",	"command aggr.count(b:bat[:any], ignore_nils:bit):lng ",	"ALGcount_nil;",	"Return the number of elements currently in a BAT ignores\n\t\tBUNs with nil-tail iff ignore_nils==TRUE."	]
[ "aggr",	"count_no_nil",	"command aggr.count_no_nil(b:bat[:any_1], g:bat[:oid], e:bat[:any_2]):bat[:lng] ",	"AGGRcount3nonils;",	""	]
[ "aggr",	"count_no_nil",	"command aggr.count_no_nil(b:bat[:any_2], cnd:bat[:oid]):lng ",	"ALGcountCND_no_nil;",	"Return the number of elements currently\n\tin a BAT ignoring BUNs with nil-tail"	]
[ "aggr",	"count_no_nil",	"command aggr.count_no_nil(b:bat[:any_2]):lng ",	"ALGcount_no_nil;",	"Return the number of elements currently\n\tin a BAT ignoring BUNs with nil-tail"	]
[ "aggr",	"covariance",	"command aggr.covariance(b1:bat[:bte], b2:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariance;",	"Covariance sample aggregate"	]
[ "aggr",	"covariance",	"command aggr.covariance(b1:bat[:dbl], b2:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariance;",	"Covariance sample aggregate"	]
[ "aggr",	"covariance",	"command aggr.covariance(b1:bat[:flt], b2:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariance;",	"Covariance sample aggregate"	]
[ "aggr",	"covariance",	"command aggr.covariance(b1:bat[:hge], b2:bat[:hge], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariance;",	"Covariance sample aggregate"	]
[ "aggr",	"covariance",	"command aggr.covariance(b1:bat[:int], b2:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariance;",	"Covariance sample aggregate"	]
[ "aggr",	"covariance",	"command aggr.covariance(b1:bat[:lng], b2:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariance;",	"Covariance sample aggregate"	]
[ "aggr",	"covariance",	"command aggr.covariance(b1:bat[:sht], b2:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariance;",	"Covariance sample aggregate"	]
[ "aggr",	"covariance",	"command aggr.covariance(b1:bat[:any_2], b2:bat[:any_2]):dbl ",	"ALGcovariance;",	"Gives the covariance of all tail values"	]
[ "aggr",	"covariancep",	"command aggr.covariancep(b1:bat[:bte], b2:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariancep;",	"Covariance population aggregate"	]
[ "aggr",	"covariancep",	"command aggr.covariancep(b1:bat[:dbl], b2:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariancep;",	"Covariance population aggregate"	]
[ "aggr",	"covariancep",	"command aggr.covariancep(b1:bat[:flt], b2:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariancep;",	"Covariance population aggregate"	]
[ "aggr",	"covariancep",	"command aggr.covariancep(b1:bat[:hge], b2:bat[:hge], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariancep;",	"Covariance population aggregate"	]
[ "aggr",	"covariancep",	"command aggr.covariancep(b1:bat[:int], b2:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariancep;",	"Covariance population aggregate"	]
[ "aggr",	"covariancep",	"command aggr.covariancep(b1:bat[:lng], b2:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariancep;",	"Covariance population aggregate"	]
[ "aggr",	"covariancep",	"command aggr.covariancep(b1:bat[:sht], b2:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRcovariancep;",	"Covariance population aggregate"	]
[ "aggr",	"covariancep",	"command aggr.covariancep(b1:bat[:any_2], b2:bat[:any_2]):dbl ",	"ALGcovariancep;",	"Gives the covariance of all tail values"	]
[ "aggr",	"exist",	"command aggr.exist(b:bat[:any_2], h:any_1):bit ",	"ALGexist;",	""	]
[ "aggr",	"exist",	"command aggr.exist(b:bat[:any_2]):bit ",	"SQLexist;",	""	]
[ "aggr",	"exist",	"pattern aggr.exist(v:any_2):bit ",	"SQLexist_val;",	""	]
[ "aggr",	"jsonaggr",	"command aggr.jsonaggr(val:bat[:dbl]):str ",	"JSONgroupStr;",	"Aggregate the double values to array."	]
[ "aggr",	"jsonaggr",	"command aggr.jsonaggr(val:bat[:str]):str ",	"JSONgroupStr;",	"Aggregate the string values to array."	]
[ "aggr",	"max",	"command aggr.max(b:bat[:any_1], g:bat[:oid], e:bat[:any_2]):bat[:any_1] ",	"AGGRmax3;",	""	]
[ "aggr",	"max",	"command aggr.max(b:bat[:any_2]):any_2 ",	"ALGmaxany;",	"Return the highest tail value or nil."	]
[ "aggr",	"max",	"command aggr.max(b:bat[:any_2], skipnil:bit):any_2 ",	"ALGmaxany_skipnil;",	"Return the highest tail value or nil."	]
[ "aggr",	"median",	"command aggr.median(b:bat[:any_1]):any_1 ",	"AGGRmedian;",	"Median aggregate"	]
[ "aggr",	"median_avg",	"command aggr.median_avg(b:bat[:any_1]):dbl ",	"AGGRmedian_avg;",	"Median aggregate"	]
[ "aggr",	"min",	"command aggr.min(b:bat[:any_1], g:bat[:oid], e:bat[:any_2]):bat[:any_1] ",	"AGGRmin3;",	""	]
[ "aggr",	"min",	"command aggr.min(b:bat[:any_2]):any_2 ",	"ALGminany;",	"Return the lowest tail value or nil."	]
[ "aggr",	"min",	"command aggr.min(b:bat[:any_2], skipnil:bit):any_2 ",	"ALGminany_skipnil;",	"Return the lowest tail value or nil."	]
[ "aggr",	"not_anyequal",	"pattern aggr.not_anyequal(l:any_1, r:any_1):bit ",	"CMDvarNE;",	""	]
[ "aggr",	"not_exist",	"command aggr.not_exist(b:bat[:any_2]):bit ",	"SQLnot_exist;",	""	]
[ "aggr",	"not_exist",	"pattern aggr.not_exist(v:any_2):bit ",	"SQLnot_exist_val;",	""	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:bte] ",	"AGGRprod3_bte;",	"Grouped tail product on bte"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRprod3_dbl;",	"Grouped tail product on dbl"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRprod3_dbl;",	"Grouped tail product on flt"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:flt] ",	"AGGRprod3_flt;",	"Grouped tail product on flt"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:hge] ",	"AGGRprod3_hge;",	"Grouped tail product on bte"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:hge], g:bat[:oid], e:bat[:any_1]):bat[:hge] ",	"AGGRprod3_hge;",	"Grouped tail product on hge"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:hge] ",	"AGGRprod3_hge;",	"Grouped tail product on int"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:hge] ",	"AGGRprod3_hge;",	"Grouped tail product on lng"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:hge] ",	"AGGRprod3_hge;",	"Grouped tail product on sht"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:int] ",	"AGGRprod3_int;",	"Grouped tail product on bte"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:int] ",	"AGGRprod3_int;",	"Grouped tail product on int"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:int] ",	"AGGRprod3_int;",	"Grouped tail product on sht"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:lng] ",	"AGGRprod3_lng;",	"Grouped tail product on bte"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:lng] ",	"AGGRprod3_lng;",	"Grouped tail product on int"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:lng] ",	"AGGRprod3_lng;",	"Grouped tail product on lng"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:lng] ",	"AGGRprod3_lng;",	"Grouped tail product on sht"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:sht] ",	"AGGRprod3_sht;",	"Grouped tail product on bte"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:sht] ",	"AGGRprod3_sht;",	"Grouped tail product on sht"	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):bte ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):sht ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], nil_if_empty:bit):bte ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], nil_if_empty:bit):sht ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid]):bte ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid]):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid]):sht ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):bte ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):sht ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:dbl]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:dbl], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:dbl], s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:dbl], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt]):flt ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt], nil_if_empty:bit):flt ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt], s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt], s:bat[:oid]):flt ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt], s:bat[:oid], nil_if_empty:bit):flt ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge], nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge], s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge], s:bat[:oid]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge], s:bat[:oid], nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int]):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], s:bat[:oid]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], s:bat[:oid]):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], s:bat[:oid]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], s:bat[:oid], nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], s:bat[:oid], nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int], s:bat[:oid], nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng], nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng], nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng], s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng], s:bat[:oid]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng], s:bat[:oid]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng], s:bat[:oid], nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng], s:bat[:oid], nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht]):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht]):sht ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], nil_if_empty:bit):sht ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], s:bat[:oid]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], s:bat[:oid]):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], s:bat[:oid]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], s:bat[:oid]):sht ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], s:bat[:oid], nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], s:bat[:oid], nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], s:bat[:oid], nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht], s:bat[:oid], nil_if_empty:bit):sht ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"quantile",	"command aggr.quantile(b:bat[:any_1], q:bat[:dbl]):any_1 ",	"AGGRquantile;",	"Quantile aggregate"	]
[ "aggr",	"quantile_avg",	"command aggr.quantile_avg(b:bat[:any_1], q:bat[:dbl]):dbl ",	"AGGRquantile_avg;",	"Quantile aggregate"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on bte"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on dbl"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on flt"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:hge], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on hge"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on int"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on lng"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on sht"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:any_2]):dbl ",	"ALGstdev;",	"Gives the standard deviation of all tail values"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on bte"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on dbl"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on flt"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:hge], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on hge"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on int"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on lng"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on sht"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:any_2]):dbl ",	"ALGstdevp;",	"Gives the standard deviation of all tail values"	]
[ "aggr",	"str_group_concat",	"command aggr.str_group_concat(b:bat[:str], g:bat[:oid], e:bat[:any_1]):bat[:str] ",	"AGGRstr_group_concat;",	"Grouped string tail concat"	]
[ "aggr",	"str_group_concat",	"command aggr.str_group_concat(b:bat[:str], sep:bat[:str], g:bat[:oid], e:bat[:any_1]):bat[:str] ",	"AGGRstr_group_concat_sep;",	"Grouped string tail concat with custom separator"	]
[ "aggr",	"str_group_concat",	"pattern aggr.str_group_concat(b:bat[:str]):str ",	"CMDBATstr_group_concat;",	"Calculate aggregate string concatenate of B."	]
[ "aggr",	"str_group_concat",	"pattern aggr.str_group_concat(b:bat[:str], nil_if_empty:bit):str ",	"CMDBATstr_group_concat;",	"Calculate aggregate string concatenate of B."	]
[ "aggr",	"str_group_concat",	"pattern aggr.str_group_concat(b:bat[:str], s:bat[:oid]):str ",	"CMDBATstr_group_concat;",	"Calculate aggregate string concatenate of B with candidate list."	]
[ "aggr",	"str_group_concat",	"pattern aggr.str_group_concat(b:bat[:str], s:bat[:oid], nil_if_empty:bit):str ",	"CMDBATstr_group_concat;",	"Calculate aggregate string concatenate of B with candidate list."	]
[ "aggr",	"str_group_concat",	"pattern aggr.str_group_concat(b:bat[:str], sep:bat[:str]):str ",	"CMDBATstr_group_concat;",	"Calculate aggregate string concatenate of B with separator SEP."	]
[ "aggr",	"str_group_concat",	"pattern aggr.str_group_concat(b:bat[:str], sep:bat[:str], nil_if_empty:bit):str ",	"CMDBATstr_group_concat;",	"Calculate aggregate string concatenate of B with separator SEP."	]
[ "aggr",	"str_group_concat",	"pattern aggr.str_group_concat(b:bat[:str], sep:bat[:str], s:bat[:oid]):str ",	"CMDBATstr_group_concat;",	"Calculate aggregate string concatenate of B with candidate list and separator SEP."	]
[ "aggr",	"str_group_concat",	"pattern aggr.str_group_concat(b:bat[:str], sep:bat[:str], s:bat[:oid], nil_if_empty:bit):str ",	"CMDBATstr_group_concat;",	"Calculate aggregate string concatenate of B with candidate list and separator SEP."	]
[ "aggr",	"suballnotequal",	"command aggr.suballnotequal(l:bat[:any_1], r:bat[:any_1], rid:bat[:oid], gp:bat[:oid], gpe:bat[:oid], no_nil:bit):bat[:bit] ",	"SQLallnotequal_grp2;",	"if all values in r are not equal to l return true, else if r has nil nil else false, except if rid is nil (ie empty) then true"	]
[ "aggr",	"suballnotequal",	"command aggr.suballnotequal(l:bat[:any_1], r:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit):bat[:bit] ",	"SQLallnotequal_grp;",	"if all values in r are not equal to l return true, else if r has nil nil else false"	]
[ "aggr",	"subanyequal",	"command aggr.subanyequal(l:bat[:any_1], r:bat[:any_1], rid:bat[:oid], gp:bat[:oid], gpe:bat[:oid], no_nil:bit):bat[:bit] ",	"SQLanyequal_grp2;",	"if any value in r is equal to l return true, else if r has nil nil else false, except if rid is nil (ie empty) then false"	]
[ "aggr",	"subanyequal",	"command aggr.subanyequal(l:bat[:any_1], r:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit):bat[:bit] ",	"SQLanyequal_grp;",	"if any value in r is equal to l return true, else if r has nil nil else false"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1s_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1s_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1s_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1s_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1s_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1s_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1scand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1scand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1scand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1scand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1scand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int):bat[:dbl] ",	"AGGRsubavg1scand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2s_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2s_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2s_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2s_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2s_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2s_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2scand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2scand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2scand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2scand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2scand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit, scale:int) (X_0:bat[:dbl], X_1:bat[:lng]) ",	"AGGRsubavg2scand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:bte], b2:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorr;",	"Grouped correlation aggregate"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:dbl], b2:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorr;",	"Grouped correlation aggregate"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:flt], b2:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorr;",	"Grouped correlation aggregate"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:hge], b2:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorr;",	"Grouped correlation aggregate"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:int], b2:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorr;",	"Grouped correlation aggregate"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:lng], b2:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorr;",	"Grouped correlation aggregate"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:sht], b2:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorr;",	"Grouped correlation aggregate"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:bte], b2:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorrcand;",	"Grouped correlation aggregate with candidate list"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:dbl], b2:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorrcand;",	"Grouped correlation aggregate with candidate list"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:flt], b2:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorrcand;",	"Grouped correlation aggregate with candidate list"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:hge], b2:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorrcand;",	"Grouped correlation aggregate with candidate list"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:int], b2:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorrcand;",	"Grouped correlation aggregate with candidate list"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:lng], b2:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorrcand;",	"Grouped correlation aggregate with candidate list"	]
[ "aggr",	"subcorr",	"command aggr.subcorr(b1:bat[:sht], b2:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcorrcand;",	"Grouped correlation aggregate with candidate list"	]
[ "aggr",	"subcount",	"command aggr.subcount(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], skip_nils:bit):bat[:lng] ",	"AGGRsubcount;",	"Grouped count aggregate"	]
[ "aggr",	"subcount",	"command aggr.subcount(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], s:bat[:oid], skip_nils:bit):bat[:lng] ",	"AGGRsubcountcand;",	"Grouped count aggregate with candidates list"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:bte], b2:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariance;",	"Grouped covariance sample aggregate"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:dbl], b2:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariance;",	"Grouped covariance sample aggregate"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:flt], b2:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariance;",	"Grouped covariance sample aggregate"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:hge], b2:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariance;",	"Grouped covariance sample aggregate"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:int], b2:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariance;",	"Grouped covariance sample aggregate"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:lng], b2:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariance;",	"Grouped covariance sample aggregate"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:sht], b2:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariance;",	"Grouped covariance sample aggregate"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:bte], b2:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancecand;",	"Grouped covariance sample aggregate with candidate list"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:dbl], b2:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancecand;",	"Grouped covariance sample aggregate with candidate list"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:flt], b2:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancecand;",	"Grouped covariance sample aggregate with candidate list"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:hge], b2:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancecand;",	"Grouped covariance sample aggregate with candidate list"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:int], b2:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancecand;",	"Grouped covariance sample aggregate with candidate list"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:lng], b2:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancecand;",	"Grouped covariance sample aggregate with candidate list"	]
[ "aggr",	"subcovariance",	"command aggr.subcovariance(b1:bat[:sht], b2:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancecand;",	"Grouped covariance sample aggregate with candidate list"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:bte], b2:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancep;",	"Grouped covariance population aggregate"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:dbl], b2:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancep;",	"Grouped covariance population aggregate"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:flt], b2:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancep;",	"Grouped covariance population aggregate"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:hge], b2:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancep;",	"Grouped covariance population aggregate"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:int], b2:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancep;",	"Grouped covariance population aggregate"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:lng], b2:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancep;",	"Grouped covariance population aggregate"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:sht], b2:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancep;",	"Grouped covariance population aggregate"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:bte], b2:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancepcand;",	"Grouped covariance population aggregate with candidate list"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:dbl], b2:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancepcand;",	"Grouped covariance population aggregate with candidate list"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:flt], b2:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancepcand;",	"Grouped covariance population aggregate with candidate list"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:hge], b2:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancepcand;",	"Grouped covariance population aggregate with candidate list"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:int], b2:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancepcand;",	"Grouped covariance population aggregate with candidate list"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:lng], b2:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancepcand;",	"Grouped covariance population aggregate with candidate list"	]
[ "aggr",	"subcovariancep",	"command aggr.subcovariancep(b1:bat[:sht], b2:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubcovariancepcand;",	"Grouped covariance population aggregate with candidate list"	]
[ "aggr",	"subexist",	"command aggr.subexist(b:bat[:any_2], g:bat[:oid], e:bat[:oid], no_nil:bit):bat[:bit] ",	"SQLsubexist;",	""	]
[ "aggr",	"subjsonaggr",	"command aggr.subjsonaggr(val:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit):bat[:str] ",	"JSONsubjson;",	"Grouped aggregation of values."	]
[ "aggr",	"subjsonaggr",	"command aggr.subjsonaggr(val:bat[:str], g:bat[:oid], e:bat[:any_1], skip_nils:bit):bat[:str] ",	"JSONsubjson;",	"Grouped aggregation of values."	]
[ "aggr",	"subjsonaggr",	"command aggr.subjsonaggr(val:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit):bat[:str] ",	"JSONsubjsoncand;",	"Grouped aggregation of values with candidates list."	]
[ "aggr",	"subjsonaggr",	"command aggr.subjsonaggr(val:bat[:str], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit):bat[:str] ",	"JSONsubjsoncand;",	"Grouped aggregation of values with candidates list."	]
[ "aggr",	"submax",	"command aggr.submax(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], skip_nils:bit):bat[:oid] ",	"AGGRsubmax;",	"Grouped maximum aggregate"	]
[ "aggr",	"submax",	"command aggr.submax(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], skip_nils:bit):bat[:any_1] ",	"AGGRsubmax_val;",	"Grouped maximum aggregate"	]
[ "aggr",	"submax",	"command aggr.submax(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], s:bat[:oid], skip_nils:bit):bat[:oid] ",	"AGGRsubmaxcand;",	"Grouped maximum aggregate with candidates list"	]
[ "aggr",	"submax",	"command aggr.submax(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], s:bat[:oid], skip_nils:bit):bat[:any_1] ",	"AGGRsubmaxcand_val;",	"Grouped maximum aggregate with candidates list"	]
[ "aggr",	"submedian",	"command aggr.submedian(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], skip_nils:bit):bat[:any_1] ",	"AGGRsubmedian;",	"Grouped median aggregate"	]
[ "aggr",	"submedian",	"command aggr.submedian(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], s:bat[:oid], skip_nils:bit):bat[:any_1] ",	"AGGRsubmediancand;",	"Grouped median aggregate with candidate list"	]
[ "aggr",	"submedian_avg",	"command aggr.submedian_avg(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], skip_nils:bit):bat[:dbl] ",	"AGGRsubmedian_avg;",	"Grouped median aggregate"	]
[ "aggr",	"submedian_avg",	"command aggr.submedian_avg(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], s:bat[:oid], skip_nils:bit):bat[:dbl] ",	"AGGRsubmediancand_avg;",	"Grouped median aggregate with candidate list"	]
[ "aggr",	"submin",	"command aggr.submin(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], skip_nils:bit):bat[:oid] ",	"AGGRsubmin;",	"Grouped minimum aggregate"	]
[ "aggr",	"submin",	"command aggr.submin(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], skip_nils:bit):bat[:any_1] ",	"AGGRsubmin_val;",	"Grouped minimum aggregate"	]
[ "aggr",	"submin",	"command aggr.submin(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], s:bat[:oid], skip_nils:bit):bat[:oid] ",	"AGGRsubmincand;",	"Grouped minimum aggregate with candidates list"	]
[ "aggr",	"submin",	"command aggr.submin(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], s:bat[:oid], skip_nils:bit):bat[:any_1] ",	"AGGRsubmincand_val;",	"Grouped minimum aggregate with candidates list"	]
[ "aggr",	"subnot_exist",	"command aggr.subnot_exist(b:bat[:any_2], g:bat[:oid], e:bat[:oid], no_nil:bit):bat[:bit] ",	"SQLsubnot_exist;",	""	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:bte] ",	"AGGRsubprod_bte;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubprod_dbl;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubprod_dbl;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:flt] ",	"AGGRsubprod_flt;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubprod_hge;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubprod_hge;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubprod_hge;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubprod_hge;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubprod_hge;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubprod_int;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubprod_int;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubprod_int;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubprod_lng;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubprod_lng;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubprod_lng;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubprod_lng;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:sht] ",	"AGGRsubprod_sht;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:sht] ",	"AGGRsubprod_sht;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:bte] ",	"AGGRsubprodcand_bte;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubprodcand_dbl;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubprodcand_dbl;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:flt] ",	"AGGRsubprodcand_flt;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubprodcand_hge;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubprodcand_hge;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubprodcand_hge;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubprodcand_hge;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubprodcand_hge;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubprodcand_int;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubprodcand_int;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubprodcand_int;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubprodcand_lng;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubprodcand_lng;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubprodcand_lng;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubprodcand_lng;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:sht] ",	"AGGRsubprodcand_sht;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:sht] ",	"AGGRsubprodcand_sht;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subquantile",	"command aggr.subquantile(b:bat[:any_1], q:bat[:dbl], g:bat[:oid], e:bat[:any_2], skip_nils:bit):bat[:any_1] ",	"AGGRsubquantile;",	"Grouped quantile aggregate"	]
[ "aggr",	"subquantile",	"command aggr.subquantile(b:bat[:any_1], q:bat[:dbl], g:bat[:oid], e:bat[:any_2], s:bat[:oid], skip_nils:bit):bat[:any_1] ",	"AGGRsubquantilecand;",	"Grouped quantile aggregate with candidate list"	]
[ "aggr",	"subquantile_avg",	"command aggr.subquantile_avg(b:bat[:any_1], q:bat[:dbl], g:bat[:oid], e:bat[:any_2], skip_nils:bit):bat[:dbl] ",	"AGGRsubquantile_avg;",	"Grouped quantile aggregate"	]
[ "aggr",	"subquantile_avg",	"command aggr.subquantile_avg(b:bat[:any_1], q:bat[:dbl], g:bat[:oid], e:bat[:any_2], s:bat[:oid], skip_nils:bit):bat[:dbl] ",	"AGGRsubquantilecand_avg;",	"Grouped quantile aggregate with candidate list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substr_group_concat",	"command aggr.substr_group_concat(b:bat[:str], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:str] ",	"AGGRsubstr_group_concat;",	"Grouped string concat"	]
[ "aggr",	"substr_group_concat",	"command aggr.substr_group_concat(b:bat[:str], sep:bat[:str], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:str] ",	"AGGRsubstr_group_concat_sep;",	"Grouped string concat with custom separator"	]
[ "aggr",	"substr_group_concat",	"command aggr.substr_group_concat(b:bat[:str], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:str] ",	"AGGRsubstr_group_concatcand;",	"Grouped string concat with candidates list"	]
[ "aggr",	"substr_group_concat",	"command aggr.substr_group_concat(b:bat[:str], sep:bat[:str], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:str] ",	"AGGRsubstr_group_concatcand_sep;",	"Grouped string concat with candidates list with custom separator"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:bte] ",	"AGGRsubsum_bte;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubsum_dbl;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubsum_dbl;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:flt] ",	"AGGRsubsum_flt;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubsum_hge;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubsum_hge;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubsum_hge;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubsum_hge;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubsum_hge;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubsum_int;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubsum_int;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubsum_int;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubsum_lng;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubsum_lng;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubsum_lng;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubsum_lng;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:sht] ",	"AGGRsubsum_sht;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:sht] ",	"AGGRsubsum_sht;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:bte] ",	"AGGRsubsumcand_bte;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubsumcand_dbl;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubsumcand_dbl;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:flt] ",	"AGGRsubsumcand_flt;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubsumcand_hge;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubsumcand_hge;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubsumcand_hge;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubsumcand_hge;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:hge] ",	"AGGRsubsumcand_hge;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubsumcand_int;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubsumcand_int;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:int] ",	"AGGRsubsumcand_int;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubsumcand_lng;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubsumcand_lng;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubsumcand_lng;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:lng] ",	"AGGRsubsumcand_lng;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:sht] ",	"AGGRsubsumcand_sht;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:sht] ",	"AGGRsubsumcand_sht;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:bte], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:flt], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:hge], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:int], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:lng], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:sht], g:bat[:oid], e:bat[:any_1], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:bte], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:flt], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:hge], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:int], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:lng], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:sht], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit, abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:bte] ",	"AGGRsum3_bte;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on dbl"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on flt"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on int"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on lng"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on sht"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:flt] ",	"AGGRsum3_flt;",	"Grouped tail sum on flt"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:hge] ",	"AGGRsum3_hge;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:hge], g:bat[:oid], e:bat[:any_1]):bat[:hge] ",	"AGGRsum3_hge;",	"Grouped tail sum on hge"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:hge] ",	"AGGRsum3_hge;",	"Grouped tail sum on int"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:hge] ",	"AGGRsum3_hge;",	"Grouped tail sum on lng"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:hge] ",	"AGGRsum3_hge;",	"Grouped tail sum on sht"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:int] ",	"AGGRsum3_int;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:int] ",	"AGGRsum3_int;",	"Grouped tail sum on int"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:int] ",	"AGGRsum3_int;",	"Grouped tail sum on sht"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:lng] ",	"AGGRsum3_lng;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:lng] ",	"AGGRsum3_lng;",	"Grouped tail sum on int"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:lng] ",	"AGGRsum3_lng;",	"Grouped tail sum on lng"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:lng] ",	"AGGRsum3_lng;",	"Grouped tail sum on sht"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:sht] ",	"AGGRsum3_sht;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:sht] ",	"AGGRsum3_sht;",	"Grouped tail sum on sht"	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):bte ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], nil_if_empty:bit):bte ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], nil_if_empty:bit):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid]):bte ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid]):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):bte ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte], s:bat[:oid], nil_if_empty:bit):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:dbl]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:dbl], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:dbl], s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:dbl], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt]):flt ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt], nil_if_empty:bit):flt ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt], s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt], s:bat[:oid]):flt ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt], s:bat[:oid], nil_if_empty:bit):flt ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge], nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge], s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge], s:bat[:oid]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge], s:bat[:oid], nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], s:bat[:oid]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], s:bat[:oid]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], s:bat[:oid]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], s:bat[:oid], nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], s:bat[:oid], nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int], s:bat[:oid], nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng], nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng], nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng], s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng], s:bat[:oid]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng], s:bat[:oid]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng], s:bat[:oid], nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng], s:bat[:oid], nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht]):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], nil_if_empty:bit):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], s:bat[:oid]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], s:bat[:oid]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], s:bat[:oid]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], s:bat[:oid]):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], s:bat[:oid], nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], s:bat[:oid], nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], s:bat[:oid], nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], s:bat[:oid], nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht], s:bat[:oid], nil_if_empty:bit):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on bte"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on dbl"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on flt"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:hge], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on hge"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on int"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on lng"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on sht"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:any_2]):dbl ",	"ALGvariance;",	"Gives the variance of all tail values"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on bte"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on dbl"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on flt"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:hge], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on hge"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on int"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on lng"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on sht"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:any_2]):dbl ",	"ALGvariancep;",	"Gives the variance of all tail values"	]
[ "alarm",	"ctime",	"unsafe command alarm.ctime():str ",	"ALARMctime;",	"Return the current time as a C-time string."	]
[ "alarm",	"epoch",	"unsafe command alarm.epoch():int ",	"ALARMepoch;",	"Return time since Jan 1, 1970 in seconds."	]
[ "alarm",	"sleep",	"unsafe pattern alarm.sleep(msecs:any_1):any_1 ",	"ALARMsleep;",	"Sleep a few milliseconds and return the slept value"	]
[ "alarm",	"sleep",	"unsafe pattern alarm.sleep(msecs:any_1):void ",	"ALARMsleep;",	"Sleep a few milliseconds"	]
[ "alarm",	"sleep",	"unsafe pattern alarm.sleep(msecs:bat[:any_1]):bat[:any_1] ",	"ALARMsleep;",	"Sleep a few milliseconds and return the slept value"	]
[ "alarm",	"time",	"unsafe command alarm.time():int ",	"ALARMtime;",	"Return time since program start in milliseconds."	]
[ "alarm",	"usec",	"unsafe command alarm.usec():lng ",	"ALARMusec;",	"Return time since Jan 1, 1970 in microseconds."	]
[ "algebra",	"antijoin",	"function algebra.antijoin(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]);",	"",	""	]
[ "algebra",	"bandjoin",	"command algebra.bandjoin(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], c1:any_1, c2:any_1, li:bit, hi:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ALGbandjoin;",	"Band join: values in l and r match if r - c1 <[=] l <[=] r + c2"	]
[ "algebra",	"copy",	"command algebra.copy(b:bat[:any_1]):bat[:any_1] ",	"ALGcopy;",	"Returns physical copy of a BAT."	]
[ "algebra",	"crossproduct",	"command algebra.crossproduct(left:bat[:any_1], right:bat[:any_2], max_one:bit) (l:bat[:oid], r:bat[:oid]) ",	"ALGcrossproduct2;",	"Returns 2 columns with all BUNs, consisting of the head-oids\n\t  from 'left' and 'right' for which there are BUNs in 'left'\n\t  and 'right' with equal tails"	]
[ "algebra",	"difference",	"command algebra.difference(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, nil_clears:bit, estimate:lng):bat[:oid] ",	"ALGdifference;",	"Difference of l and r with candidate lists"	]
[ "algebra",	"exist",	"command algebra.exist(b:bat[:any_1], val:any_1):bit ",	"ALGexist;",	"Returns whether 'val' occurs in b."	]
[ "algebra",	"fetch",	"command algebra.fetch(b:bat[:any_1], x:oid):any_1 ",	"ALGfetchoid;",	"Returns the value of the BUN at x-th position with 0 <= x < b.count"	]
[ "algebra",	"find",	"command algebra.find(b:bat[:any_1], t:any_1):oid ",	"ALGfind;",	"Returns the index position of a value.  If no such BUN exists return OID-nil."	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any], n:lng, asc:bit, nilslast:bit, distinct:bit) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ALGfirstn;",	"Calculate first N values of B"	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any], n:lng, asc:bit, nilslast:bit, distinct:bit):bat[:oid] ",	"ALGfirstn;",	"Calculate first N values of B"	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any], s:bat[:oid], g:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ALGfirstn;",	"Calculate first N values of B with candidate list S"	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any], s:bat[:oid], g:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit):bat[:oid] ",	"ALGfirstn;",	"Calculate first N values of B with candidate list S"	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any], s:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ALGfirstn;",	"Calculate first N values of B with candidate list S"	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any], s:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit):bat[:oid] ",	"ALGfirstn;",	"Calculate first N values of B with candidate list S"	]
[ "algebra",	"groupby",	"command algebra.groupby(gids:bat[:oid], cnts:bat[:lng]):bat[:oid] ",	"ALGgroupby;",	"Produces a new BAT with groups identified by the head column. The result contains tail times the head value, ie the tail contains the result group sizes."	]
[ "algebra",	"ilike",	"command algebra.ilike(s:str, pat:str):bit ",	"PCREilike2;",	""	]
[ "algebra",	"ilike",	"command algebra.ilike(s:str, pat:str, esc:str):bit ",	"PCREilike3;",	""	]
[ "algebra",	"ilikejoin",	"command algebra.ilikejoin(l:bat[:str], r:bat[:str], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ILIKEjoin1;",	""	]
[ "algebra",	"ilikejoin",	"command algebra.ilikejoin(l:bat[:str], r:bat[:str], esc:str, sl:bat[:oid], sr:bat[:oid], nil_matches:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ILIKEjoin;",	"Join the string bat L with the pattern bat R\nwith optional candidate lists SL and SR using pattern escape string ESC\nand doing a case insensitive match.\nThe result is two aligned bats with oids of matching rows."	]
[ "algebra",	"ilikeselect",	"command algebra.ilikeselect(b:bat[:str], cand:bat[:oid], pat:str, esc:str, anti:bit):bat[:oid] ",	"PCRElikeselect1;",	""	]
[ "algebra",	"ilikeselect",	"command algebra.ilikeselect(b:bat[:str], cand:bat[:oid], pat:str, anti:bit):bat[:oid] ",	"PCRElikeselect4;",	""	]
[ "algebra",	"intersect",	"command algebra.intersect(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, max_one:bit, estimate:lng):bat[:oid] ",	"ALGintersect;",	"Intersection of l and r with candidate lists (i.e. half of semi-join)"	]
[ "algebra",	"join",	"command algebra.join(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, estimate:lng):bat[:oid] ",	"ALGjoin1;",	"Join; only produce left output"	]
[ "algebra",	"join",	"command algebra.join(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ALGjoin;",	"Join"	]
[ "algebra",	"leftjoin",	"command algebra.leftjoin(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, estimate:lng):bat[:oid] ",	"ALGleftjoin1;",	"Left join with candidate lists; only produce left output"	]
[ "algebra",	"leftjoin",	"command algebra.leftjoin(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ALGleftjoin;",	"Left join with candidate lists"	]
[ "algebra",	"like",	"command algebra.like(s:str, pat:str):bit ",	"PCRElike2;",	""	]
[ "algebra",	"like",	"command algebra.like(s:str, pat:str, esc:str):bit ",	"PCRElike3;",	""	]
[ "algebra",	"likejoin",	"command algebra.likejoin(l:bat[:str], r:bat[:str], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"LIKEjoin1;",	""	]
[ "algebra",	"likejoin",	"command algebra.likejoin(l:bat[:str], r:bat[:str], esc:str, sl:bat[:oid], sr:bat[:oid], nil_matches:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"LIKEjoin;",	"Join the string bat L with the pattern bat R\nwith optional candidate lists SL and SR using pattern escape string ESC\nand doing a case sensitive match.\nThe result is two aligned bats with oids of matching rows."	]
[ "algebra",	"likeselect",	"command algebra.likeselect(b:bat[:str], s:bat[:oid], pat:str, esc:str, caseignore:bit, anti:bit):bat[:oid] ",	"PCRElikeselect2;",	"Select all head values of the first input BAT for which the\n\ttail value is \"like\" the given (SQL-style) pattern and for\n\twhich the head value occurs in the tail of the second input\n\tBAT.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the\n\trelationship holds.  The output BAT is sorted on the tail value."	]
[ "algebra",	"likeselect",	"command algebra.likeselect(b:bat[:str], cand:bat[:oid], pat:str, esc:str, anti:bit):bat[:oid] ",	"PCRElikeselect3;",	""	]
[ "algebra",	"likeselect",	"command algebra.likeselect(b:bat[:str], cand:bat[:oid], pat:str, anti:bit):bat[:oid] ",	"PCRElikeselect5;",	""	]
[ "algebra",	"not_ilike",	"command algebra.not_ilike(s:str, pat:str):bit ",	"PCREnotilike2;",	""	]
[ "algebra",	"not_ilike",	"command algebra.not_ilike(s:str, pat:str, esc:str):bit ",	"PCREnotilike3;",	""	]
[ "algebra",	"not_like",	"command algebra.not_like(s:str, pat:str):bit ",	"PCREnotlike2;",	""	]
[ "algebra",	"not_like",	"command algebra.not_like(s:str, pat:str, esc:str):bit ",	"PCREnotlike3;",	""	]
[ "algebra",	"orderidx",	"command algebra.orderidx(bv:bat[:any_1], stable:bit):bat[:any_1] ",	"OIDXorderidx;",	"Create an order index"	]
[ "algebra",	"outerjoin",	"command algebra.outerjoin(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ALGouterjoin;",	"Left outer join with candidate lists"	]
[ "algebra",	"project",	"pattern algebra.project(b:bat[:any_1], v:any_3):bat[:any_3] ",	"ALGprojecttail;",	"Fill the tail with a constant"	]
[ "algebra",	"projection",	"command algebra.projection(left:bat[:oid], right:bat[:any_3]):bat[:any_3] ",	"ALGprojection;",	"Project left input onto right input."	]
[ "algebra",	"projection2",	"command algebra.projection2(left:bat[:oid], right1:bat[:any_3], right2:bat[:any_3]):bat[:any_3] ",	"ALGprojection2;",	"Project left input onto right inputs which should be consecutive."	]
[ "algebra",	"projectionpath",	"pattern algebra.projectionpath(l:bat[:any]...):bat[:any] ",	"ALGprojectionpath;",	"Routine to handle join paths.  The type analysis is rather tricky."	]
[ "algebra",	"rangejoin",	"command algebra.rangejoin(l:bat[:any_1], r1:bat[:any_1], r2:bat[:any_1], sl:bat[:oid], sr:bat[:oid], li:bit, hi:bit, anti:bit, symmetric:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ALGrangejoin;",	"Range join: values in l and r1/r2 match if r1 <[=] l <[=] r2"	]
[ "algebra",	"reuse",	"command algebra.reuse(b:bat[:any_1]):bat[:any_1] ",	"ALGreuse;",	"Reuse a temporary BAT if you can. Otherwise,\n\tallocate enough storage to accept result of an\n \toperation (not involving the heap)"	]
[ "algebra",	"select",	"command algebra.select(b:bat[:any_1], low:any_1, high:any_1, li:bit, hi:bit, anti:bit):bat[:oid] ",	"ALGselect1;",	"Select all head values for which the tail value is in range.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the tail value\n\tis between the values low and high (inclusive if li respectively\n\thi is set).  The output BAT is sorted on the tail value.  If low\n\tor high is nil, the boundary is not considered (effectively - and\n\t+ infinity).  If anti is set, the result is the complement.  Nil\n\tvalues in the tail are never matched, unless low=nil, high=nil,\n\tli=1, hi=1, anti=0.  All non-nil values are returned if low=nil,\n\thigh=nil, and li, hi are not both 1, or anti=1.\n\tNote that the output is suitable as second input for the other\n\tversion of this function."	]
[ "algebra",	"select",	"command algebra.select(b:bat[:any_1], low:any_1, high:any_1, li:bit, hi:bit, anti:bit, unknown:bit):bat[:oid] ",	"ALGselect1nil;",	"With unknown set, each nil != nil"	]
[ "algebra",	"select",	"command algebra.select(b:bat[:any_1], s:bat[:oid], low:any_1, high:any_1, li:bit, hi:bit, anti:bit):bat[:oid] ",	"ALGselect2;",	"Select all head values of the first input BAT for which the tail value\n\tis in range and for which the head value occurs in the tail of the\n\tsecond input BAT.\n\tThe first input is a dense-headed BAT, the second input is a\n\tdense-headed BAT with sorted tail, output is a dense-headed BAT\n\twith in the tail the head value of the input BAT for which the\n\ttail value is between the values low and high (inclusive if li\n\trespectively hi is set).  The output BAT is sorted on the tail\n\tvalue.  If low or high is nil, the boundary is not considered\n\t(effectively - and + infinity).  If anti is set, the result is the\n\tcomplement.  Nil values in the tail are never matched, unless\n\tlow=nil, high=nil, li=1, hi=1, anti=0.  All non-nil values are\n\treturned if low=nil, high=nil, and li, hi are not both 1, or anti=1.\n\tNote that the output is suitable as second input for this\n\tfunction."	]
[ "algebra",	"select",	"command algebra.select(b:bat[:any_1], s:bat[:oid], low:any_1, high:any_1, li:bit, hi:bit, anti:bit, unknown:bit):bat[:oid] ",	"ALGselect2nil;",	"With unknown set, each nil != nil"	]
[ "algebra",	"selectNotNil",	"command algebra.selectNotNil(b:bat[:any_2]):bat[:any_2] ",	"ALGselectNotNil;",	"Select all not-nil values"	]
[ "algebra",	"semijoin",	"command algebra.semijoin(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], nil_matches:bit, max_one:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ALGsemijoin;",	"Semi join with candidate lists"	]
[ "algebra",	"slice",	"command algebra.slice(b:bat[:any_1], x:lng, y:lng):bat[:any_1] ",	"ALGslice;",	"Return the slice with the BUNs at position x till y."	]
[ "algebra",	"slice",	"command algebra.slice(b:bat[:any_1], x:int, y:int):bat[:any_1] ",	"ALGslice_int;",	"Return the slice with the BUNs at position x till y."	]
[ "algebra",	"slice",	"command algebra.slice(b:bat[:any_1], x:lng, y:lng):bat[:any_1] ",	"ALGslice_lng;",	"Return the slice with the BUNs at position x till y."	]
[ "algebra",	"slice",	"command algebra.slice(b:bat[:any_1], x:oid, y:oid):bat[:any_1] ",	"ALGslice_oid;",	"Return the slice based on head oid x till y (exclusive)."	]
[ "algebra",	"sort",	"command algebra.sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit):bat[:any_1] ",	"ALGsort11;",	"Returns a copy of the BAT sorted on tail values.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"sort",	"command algebra.sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) (X_0:bat[:any_1], X_1:bat[:oid]) ",	"ALGsort12;",	"Returns a copy of the BAT sorted on tail values and a BAT that\n         specifies how the input was reordered.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"sort",	"command algebra.sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) (X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid]) ",	"ALGsort13;",	"Returns a copy of the BAT sorted on tail values, a BAT that specifies\n         how the input was reordered, and a BAT with group information.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"sort",	"command algebra.sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit):bat[:any_1] ",	"ALGsort21;",	"Returns a copy of the BAT sorted on tail values.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"sort",	"command algebra.sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (X_0:bat[:any_1], X_1:bat[:oid]) ",	"ALGsort22;",	"Returns a copy of the BAT sorted on tail values and a BAT that\n         specifies how the input was reordered.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"sort",	"command algebra.sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid]) ",	"ALGsort23;",	"Returns a copy of the BAT sorted on tail values, a BAT that specifies\n         how the input was reordered, and a BAT with group information.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"sort",	"command algebra.sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit):bat[:any_1] ",	"ALGsort31;",	"Returns a copy of the BAT sorted on tail values.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"sort",	"command algebra.sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (X_0:bat[:any_1], X_1:bat[:oid]) ",	"ALGsort32;",	"Returns a copy of the BAT sorted on tail values and a BAT that\n         specifies how the input was reordered.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"sort",	"command algebra.sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid]) ",	"ALGsort33;",	"Returns a copy of the BAT sorted on tail values, a BAT that specifies\n         how the input was reordered, and a BAT with group information.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"subslice",	"command algebra.subslice(b:bat[:any_1], x:lng, y:lng):bat[:oid] ",	"ALGsubslice_lng;",	"Return the oids of the slice with the BUNs at position x till y."	]
[ "algebra",	"thetajoin",	"command algebra.thetajoin(l:bat[:any_1], r:bat[:any_1], sl:bat[:oid], sr:bat[:oid], op:int, nil_matches:bit, estimate:lng) (X_0:bat[:oid], X_1:bat[:oid]) ",	"ALGthetajoin;",	"Theta join with candidate lists"	]
[ "algebra",	"thetaselect",	"command algebra.thetaselect(b:bat[:any_1], val:any_1, op:str):bat[:oid] ",	"ALGthetaselect1;",	"Select all head values for which the tail value obeys the relation\n\tvalue OP VAL.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the\n\trelationship holds.  The output BAT is sorted on the tail value."	]
[ "algebra",	"thetaselect",	"command algebra.thetaselect(b:bat[:any_1], s:bat[:oid], val:any_1, op:str):bat[:oid] ",	"ALGthetaselect2;",	"Select all head values of the first input BAT for which the tail value\n\tobeys the relation value OP VAL and for which the head value occurs in\n\tthe tail of the second input BAT.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the\n\trelationship holds.  The output BAT is sorted on the tail value."	]
[ "algebra",	"unique",	"command algebra.unique(b:bat[:any_1]):bat[:oid] ",	"ALGunique1;",	"Select all unique values from the tail of the input.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with\n\tin the tail the head value of the input BAT that was selected.\n\tThe output BAT is sorted on the tail value."	]
[ "algebra",	"unique",	"command algebra.unique(b:bat[:any_1], s:bat[:oid]):bat[:oid] ",	"ALGunique2;",	"Select all unique values from the tail of the first input.\n\tInput is a dense-headed BAT, the second input is a\n\tdense-headed BAT with sorted tail, output is a dense-headed\n\tBAT with in the tail the head value of the input BAT that was\n\tselected.  The output BAT is sorted on the tail value.  The\n\tsecond input BAT is a list of candidates."	]
[ "bat",	"append",	"command bat.append(i:bat[:any_1], u:bat[:any_1], s:bat[:oid], force:bit):bat[:any_1] ",	"BKCappend_cand_force_wrap;",	"append the content of u with candidate list s to i"	]
[ "bat",	"append",	"command bat.append(i:bat[:any_1], u:bat[:any_1], s:bat[:oid]):bat[:any_1] ",	"BKCappend_cand_wrap;",	"append the content of u with candidate list s to i"	]
[ "bat",	"append",	"command bat.append(i:bat[:any_1], u:bat[:any_1], force:bit):bat[:any_1] ",	"BKCappend_force_wrap;",	"append the content of u to i"	]
[ "bat",	"append",	"command bat.append(i:bat[:any_1], u:any_1, force:bit):bat[:any_1] ",	"BKCappend_val_force_wrap;",	"append the value u to i"	]
[ "bat",	"append",	"command bat.append(i:bat[:any_1], u:any_1):bat[:any_1] ",	"BKCappend_val_wrap;",	"append the value u to i"	]
[ "bat",	"append",	"command bat.append(i:bat[:any_1], u:bat[:any_1]):bat[:any_1] ",	"BKCappend_wrap;",	"append the content of u to i"	]
[ "bat",	"attach",	"command bat.attach(tt:int, heapfile:str):bat[:any_1] ",	"BKCattach;",	"Returns a new BAT with dense head and tail of the given type and uses\n        the given file to initialize the tail. The file will be owned by the\n        server."	]
[ "bat",	"delete",	"command bat.delete(b:bat[:any_1], h:oid):bat[:any_1] ",	"BKCdelete;",	"Delete BUN indicated by head value, exchanging with last BUN"	]
[ "bat",	"delete",	"command bat.delete(b:bat[:any_1]):bat[:any_1] ",	"BKCdelete_all;",	"Delete all entries."	]
[ "bat",	"delete",	"command bat.delete(b:bat[:any_1], d:bat[:oid]):bat[:any_1] ",	"BKCdelete_multi;",	"Delete multiple BUN, shifting BUNs up"	]
[ "bat",	"densebat",	"command bat.densebat(sz:lng):bat[:oid] ",	"BKCdensebat;",	"Creates a new [void,void] BAT of size 'sz'."	]
[ "bat",	"diffcand",	"command bat.diffcand(a:bat[:oid], b:bat[:oid]):bat[:oid] ",	"BKCdiffcand;",	"Calculate difference of two candidate lists"	]
[ "bat",	"getAccess",	"command bat.getAccess(b:bat[:any_1]):str ",	"BKCgetAccess;",	"Return the access mode attached to this BAT as a character."	]
[ "bat",	"getCapacity",	"command bat.getCapacity(b:bat[:any_1]):lng ",	"BKCgetCapacity;",	"Returns the current allocation size (in max number of elements) of a BAT."	]
[ "bat",	"getColumnType",	"command bat.getColumnType(b:bat[:any_1]):str ",	"BKCgetColumnType;",	"Returns the type of the tail column of a BAT, as an integer type number."	]
[ "bat",	"getName",	"command bat.getName(b:bat[:any_1]):str ",	"BKCgetBBPname;",	"Gives back the logical name of a BAT."	]
[ "bat",	"getRole",	"command bat.getRole(bid:bat[:any_1]):str ",	"BKCgetRole;",	"Returns the rolename of the head column of a BAT."	]
[ "bat",	"getSequenceBase",	"command bat.getSequenceBase(b:bat[:any_1]):oid ",	"BKCgetSequenceBase;",	"Get the sequence base for the void column of a BAT."	]
[ "bat",	"getSize",	"command bat.getSize(b:bat[:any_1]):lng ",	"BKCgetSize;",	"Calculate the actual size of the BAT descriptor, heaps, hashes and imprint indices in bytes\n         rounded to the memory page size (see bbp.getPageSize())."	]
[ "bat",	"getorderidx",	"pattern bat.getorderidx(bv:bat[:any_1]):bat[:oid] ",	"OIDXgetorderidx;",	"Return the order index if it exists"	]
[ "bat",	"hasorderidx",	"pattern bat.hasorderidx(bv:bat[:any_1]):bit ",	"OIDXhasorderidx;",	"Return true if order index exists"	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:bte]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:dbl]):void ",	"CMDBATimprints;",	"Check for existence or create an imprint index on the BAT."	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:flt]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:hge]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:int]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:lng]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:sht]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:bte]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:dbl]):lng ",	"CMDBATimprintsize;",	"Return the storage size of the imprints index structure."	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:flt]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:hge]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:int]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:lng]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:sht]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"info",	"command bat.info(b:bat[:any_1]) (X_0:bat[:str], X_1:bat[:str]) ",	"BKCinfo;",	"Produce a table containing information about a BAT in [attribute,value] format. \n        It contains all properties of the BAT record. "	]
[ "bat",	"intersectcand",	"command bat.intersectcand(a:bat[:oid], b:bat[:oid]):bat[:oid] ",	"BKCintersectcand;",	"Intersect two candidate lists into one"	]
[ "bat",	"isPersistent",	"command bat.isPersistent(b:bat[:any_1]):bit ",	"BKCisPersistent;",	""	]
[ "bat",	"isSorted",	"command bat.isSorted(b:bat[:any_1]):bit ",	"BKCisSorted;",	"Returns true if BAT values are ordered."	]
[ "bat",	"isSortedReverse",	"command bat.isSortedReverse(b:bat[:any_1]):bit ",	"BKCisSortedReverse;",	"Returns true if BAT values are reversely ordered."	]
[ "bat",	"isSynced",	"command bat.isSynced(b1:bat[:any_1], b2:bat[:any_2]):bit ",	"BKCisSynced;",	"Tests whether two BATs are synced or not. "	]
[ "bat",	"isTransient",	"command bat.isTransient(b:bat[:any_1]):bit ",	"BKCisTransient;",	""	]
[ "bat",	"isaKey",	"command bat.isaKey(b:bat[:any_1]):bit ",	"BKCgetKey;",	"Return whether the column tail values are unique (key)."	]
[ "bat",	"mergecand",	"command bat.mergecand(a:bat[:oid], b:bat[:oid]):bat[:oid] ",	"BKCmergecand;",	"Merge two candidate lists into one"	]
[ "bat",	"mirror",	"command bat.mirror(b:bat[:any_2]):bat[:oid] ",	"BKCmirror;",	"Returns the head-mirror image of a BAT (two head columns)."	]
[ "bat",	"new",	"pattern bat.new(tt:any_1):bat[:any_1] ",	"CMDBATnew;",	""	]
[ "bat",	"new",	"pattern bat.new(tt:any_1, size:int):bat[:any_1] ",	"CMDBATnew;",	""	]
[ "bat",	"new",	"pattern bat.new(tt:any_1, size:int, persist:bit):bat[:any_1] ",	"CMDBATnew;",	""	]
[ "bat",	"new",	"pattern bat.new(tt:any_1, size:lng):bat[:any_1] ",	"CMDBATnew;",	"Creates a new empty transient BAT, with tail-types as indicated."	]
[ "bat",	"new",	"pattern bat.new(tt:any_1, size:lng, persist:bit):bat[:any_1] ",	"CMDBATnew;",	""	]
[ "bat",	"orderidx",	"pattern bat.orderidx(bv:bat[:any_1]):void ",	"OIDXcreate;",	"Introduces the OID index arrangement of ordered values"	]
[ "bat",	"orderidx",	"pattern bat.orderidx(bv:bat[:any_1], pieces:int):void ",	"OIDXcreate;",	"Introduces the OID index arrangement of ordered values"	]
[ "bat",	"orderidx",	"pattern bat.orderidx(bv:bat[:any_1], l:bat[:any_1]...):void ",	"OIDXmerge;",	"Consolidates the OID index arrangement"	]
[ "bat",	"pack",	"pattern bat.pack(X_0:any_2...):bat[:any_2] ",	"MATpackValues;",	"Materialize the values into a BAT. Avoiding a clash with mat.pack() in mergetable"	]
[ "bat",	"partition",	"pattern bat.partition(b:bat[:any_1], pieces:int, n:int):bat[:any_1] ",	"CMDBATpartition2;",	"Create the n-th slice over the BAT broken into several pieces."	]
[ "bat",	"partition",	"pattern bat.partition(b:bat[:any_1]):bat[:any_1]... ",	"CMDBATpartition;",	"Create a serie of slices over the BAT argument. The BUNs are distributed evenly."	]
[ "bat",	"replace",	"command bat.replace(b:bat[:any_1], rid:bat[:oid], val:bat[:any_1]):bat[:any_1] ",	"BKCbat_inplace;",	"Perform replace for all BUNs of the second BAT into the first."	]
[ "bat",	"replace",	"command bat.replace(b:bat[:any_1], rid:bat[:oid], val:bat[:any_1], force:bit):bat[:any_1] ",	"BKCbat_inplace_force;",	"Perform replace for all BUNs of the second BAT into the first."	]
[ "bat",	"replace",	"command bat.replace(b:bat[:any_1], h:oid, t:any_1):bat[:any_1] ",	"BKCbun_inplace;",	"Replace the tail value of one BUN that has some head value."	]
[ "bat",	"replace",	"command bat.replace(b:bat[:any_1], h:oid, t:any_1, force:bit):bat[:any_1] ",	"BKCbun_inplace_force;",	"Replace the tail value of one BUN that has some head value."	]
[ "bat",	"reuse",	"command bat.reuse(b:bat[:any_1], del:bat[:oid]):bat[:any_1] ",	"BKCreuseBAT;",	"Shuffle the values around to restore a dense representation of buns."	]
[ "bat",	"reuseMap",	"command bat.reuseMap(b:bat[:any_1], del:bat[:oid]):bat[:oid] ",	"BKCreuseBATmap;",	"Derive the oid mapping for reuse BAT based on list of to-be-deleted"	]
[ "bat",	"save",	"command bat.save(nme:bat[:any_1]):void ",	"BKCsave2;",	""	]
[ "bat",	"save",	"command bat.save(nme:str):bit ",	"BKCsave;",	"Save a BAT to storage, if it was loaded and dirty.  \n        Returns whether IO was necessary.  Please realize that \n\tcalling this function violates the atomic commit protocol!!"	]
[ "bat",	"setAccess",	"command bat.setAccess(b:bat[:any_1], mode:str):bat[:any_1] ",	"BKCsetAccess;",	"Try to change the update access priviliges \n\tto this BAT. Mode:\n\t r[ead-only]      - allow only read access.\n\t a[append-only]   - allow reads and update.\n\t w[riteable]      - allow all operations.\n\t BATs are updatable by default. On making a BAT read-only, \n     all subsequent updates fail with an error message.\n\t Returns the BAT itself."	]
[ "bat",	"setColumn",	"command bat.setColumn(b:bat[:any_1], t:str):void ",	"BKCsetColumn;",	"Give a logical name to the tail column of a BAT."	]
[ "bat",	"setHash",	"command bat.setHash(b:bat[:any_1]):bit ",	"BKCsetHash;",	"Create a hash structure on the column"	]
[ "bat",	"setImprints",	"command bat.setImprints(b:bat[:any_1]):bit ",	"BKCsetImprints;",	"Create an imprints structure on the column"	]
[ "bat",	"setName",	"command bat.setName(b:bat[:any_1], s:str):void ",	"BKCsetName;",	"Give a logical name to a BAT. "	]
[ "bat",	"setPersistent",	"command bat.setPersistent(b:bat[:any_1]):void ",	"BKCsetPersistent;",	"Make the BAT persistent."	]
[ "bat",	"setTransient",	"command bat.setTransient(b:bat[:any_1]):void ",	"BKCsetTransient;",	"Make the BAT transient.  Returns \n\tboolean which indicates if the\nBAT administration has indeed changed."	]
[ "bat",	"single",	"pattern bat.single(val:any_1):bat[:any_1] ",	"CMDBATsingle;",	"Create a BAT with a single elemenet"	]
[ "batalgebra",	"ilike",	"command batalgebra.ilike(s:bat[:str], pat:str):bat[:bit] ",	"BATPCREilike2;",	""	]
[ "batalgebra",	"ilike",	"command batalgebra.ilike(s:bat[:str], pat:str, esc:str):bat[:bit] ",	"BATPCREilike;",	""	]
[ "batalgebra",	"like",	"command batalgebra.like(s:bat[:str], pat:str):bat[:bit] ",	"BATPCRElike2;",	""	]
[ "batalgebra",	"like",	"command batalgebra.like(s:bat[:str], pat:str, esc:str):bat[:bit] ",	"BATPCRElike;",	""	]
[ "batalgebra",	"not_ilike",	"command batalgebra.not_ilike(s:bat[:str], pat:str):bat[:bit] ",	"BATPCREnotilike2;",	""	]
[ "batalgebra",	"not_ilike",	"command batalgebra.not_ilike(s:bat[:str], pat:str, esc:str):bat[:bit] ",	"BATPCREnotilike;",	""	]
[ "batalgebra",	"not_like",	"command batalgebra.not_like(s:bat[:str], pat:str):bat[:bit] ",	"BATPCREnotlike2;",	""	]
[ "batalgebra",	"not_like",	"command batalgebra.not_like(s:bat[:str], pat:str, esc:str):bat[:bit] ",	"BATPCREnotlike;",	""	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:any_1], b2:bat[:any_1]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:any_1], b2:bat[:any_1], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:date], b2:bat[:date]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:date], b2:bat[:date], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:date], b2:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:date], b2:bat[:date], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:daytime], b2:bat[:daytime]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:daytime], b2:bat[:daytime], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:daytime], b2:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:daytime], b2:bat[:daytime], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:json], b2:bat[:json]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:json], b2:bat[:json], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:timestamp], b2:bat[:timestamp]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:timestamp], b2:bat[:timestamp], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:timestamp], b2:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:timestamp], b2:bat[:timestamp], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:uuid], b2:bat[:uuid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:uuid], b2:bat[:uuid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:any_1], v:any_1):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:any_1], v:any_1, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:any_1], v:any_1, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:any_1], v:any_1, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:any_1], v:any_1, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:any_1], v:any_1, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:date], v:date):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:date], v:date, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:date], v:date, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:date], v:date, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:daytime], v:daytime):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:daytime], v:daytime, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:daytime], v:daytime, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:daytime], v:daytime, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:timestamp], v:timestamp):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:timestamp], v:timestamp, nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:timestamp], v:timestamp, s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:timestamp], v:timestamp, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:any_1, b:bat[:any_1]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:any_1, b:bat[:any_1], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:any_1, b:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:any_1, b:bat[:any_1], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:any_1, b:bat[:any_1], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:any_1, b:bat[:any_1], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:date, b:bat[:date]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:date, b:bat[:date], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:date, b:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:date, b:bat[:date], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:daytime, b:bat[:daytime]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:daytime, b:bat[:daytime], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:daytime, b:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:daytime, b:bat[:daytime], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:timestamp, b:bat[:timestamp]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:timestamp, b:bat[:timestamp], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:timestamp, b:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:timestamp, b:bat[:timestamp], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:str], b2:bat[:str], s1:bat[:oid], s2:bat[:oid]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of B1 and B2 with candidates list"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:str], b2:bat[:str], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of B1 and B2 with candidates list"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:str], v:str, s:bat[:oid]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of B and V with candidates list"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:str], v:str, s:bat[:oid], r:bat[:bit]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of B and V with candidates list"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:str, b:bat[:str], s:bat[:oid]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of V and B with candidates list"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:str, b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of V and B with candidates list"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:bte]):bat[:bte] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:dbl]):bat[:dbl] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:flt]):bat[:flt] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:hge]):bat[:hge] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:int]):bat[:int] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:lng]):bat[:lng] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:sht]):bat[:sht] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte]):bat[:bte] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl]):bat[:dbl] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt]):bat[:flt] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge]):bat[:hge] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int]):bat[:int] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng]):bat[:lng] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht]):bat[:sht] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:bte]):bat[:bte] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:dbl]):bat[:dbl] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:flt]):bat[:flt] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:hge]):bat[:hge] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:int]):bat[:int] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:lng]):bat[:lng] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:sht]):bat[:sht] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:flt, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:dbl, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:dbl, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:dbl, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:flt, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:flt, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:flt, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:flt, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:flt, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:dbl], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:dbl], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:flt], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:flt], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:flt], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:any_1], b2:bat[:any_1]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:date], b2:bat[:date]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:date], b2:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:daytime], b2:bat[:daytime]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:daytime], b2:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:json], b2:bat[:json]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:timestamp], b2:bat[:timestamp]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:timestamp], b2:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:uuid], b2:bat[:uuid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:any_1], v:any_1):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:any_1], v:any_1, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:any_1], v:any_1, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:date], v:date):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:date], v:date, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:daytime], v:daytime):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:daytime], v:daytime, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:timestamp], v:timestamp):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:timestamp], v:timestamp, s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:any_1, b:bat[:any_1]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:any_1, b:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:any_1, b:bat[:any_1], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:date, b:bat[:date]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:date, b:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:daytime, b:bat[:daytime]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:daytime, b:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:timestamp, b:bat[:timestamp]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:timestamp, b:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:bte]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:hge]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:int]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:lng]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:sht]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:bte]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:hge]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:int]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:lng]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:sht]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:bte]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:hge]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:int]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:lng]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:sht]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:bte]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:hge]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:int]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:lng]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:sht]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:bte]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:hge]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:int]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:lng]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:sht]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:bte):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:hge):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:int):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:lng):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:sht):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:bte):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:bte, r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:hge):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:hge, r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:int):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:int, r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:lng):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:lng, r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:sht):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:sht, r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:bte):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:bte, r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:hge):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:hge, r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:int):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:int, r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:lng):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:lng, r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:sht):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:sht, r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:bte):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:bte, r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:hge):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:hge, r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:int):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:int, r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:lng):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:lng, r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:sht):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:sht, r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:bte):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:bte, r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:hge):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:hge, r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:int):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:int, r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:lng):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:lng, r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:sht):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:sht, r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:bte]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:hge]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:int]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:lng]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:sht]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:bte]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:bte], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:hge]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:int]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:int], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:lng]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:lng], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:sht]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:sht], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:bte]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:bte], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:hge]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:hge], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:int]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:lng]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:lng], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:sht]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:sht], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:bte]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:bte], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:hge]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:hge], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:int]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:int], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:lng]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:sht]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:sht], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:bte]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:bte], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:hge]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:hge], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:int]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:int], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:lng]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:lng], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:sht]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:any_1], b2:bat[:any_1]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:date], b2:bat[:date]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:date], b2:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:daytime], b2:bat[:daytime]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:daytime], b2:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:json], b2:bat[:json]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:timestamp], b2:bat[:timestamp]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:timestamp], b2:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:uuid], b2:bat[:uuid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:any_1], v:any_1):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:any_1], v:any_1, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:any_1], v:any_1, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:date], v:date):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:date], v:date, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:daytime], v:daytime):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:daytime], v:daytime, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:timestamp], v:timestamp):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:timestamp], v:timestamp, s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:any_1, b:bat[:any_1]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:any_1, b:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:any_1, b:bat[:any_1], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:date, b:bat[:date]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:date, b:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:daytime, b:bat[:daytime]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:daytime, b:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:timestamp, b:bat[:timestamp]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:timestamp, b:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:any_1], b2:bat[:any_1]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:any_1], b2:bat[:any_1], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:date], b2:bat[:date]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:date], b2:bat[:date], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:date], b2:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:date], b2:bat[:date], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:daytime], b2:bat[:daytime]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:daytime], b2:bat[:daytime], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:daytime], b2:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:daytime], b2:bat[:daytime], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:json], b2:bat[:json]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:json], b2:bat[:json], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:timestamp], b2:bat[:timestamp]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:timestamp], b2:bat[:timestamp], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:timestamp], b2:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:timestamp], b2:bat[:timestamp], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:uuid], b2:bat[:uuid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:uuid], b2:bat[:uuid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:any_1], v:any_1):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:any_1], v:any_1, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:any_1], v:any_1, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:any_1], v:any_1, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:any_1], v:any_1, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:any_1], v:any_1, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:date], v:date):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:date], v:date, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:date], v:date, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:date], v:date, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:daytime], v:daytime):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:daytime], v:daytime, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:daytime], v:daytime, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:daytime], v:daytime, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:sht, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:sht, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:sht, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:bte, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:bte, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:bte, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:dbl, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:dbl, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:dbl, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:flt, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:flt, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:flt, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:hge, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:hge, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:hge, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:int, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:int, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:int, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:lng, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:lng, r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:lng, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:timestamp], v:timestamp):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:timestamp], v:timestamp, nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:timestamp], v:timestamp, s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:timestamp], v:timestamp, s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:any_1, b:bat[:any_1]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:any_1, b:bat[:any_1], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:any_1, b:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:any_1, b:bat[:any_1], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:any_1, b:bat[:any_1], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:any_1, b:bat[:any_1], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:date, b:bat[:date]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:date, b:bat[:date], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:date, b:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:date, b:bat[:date], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:daytime, b:bat[:daytime]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:daytime, b:bat[:daytime], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:daytime, b:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:daytime, b:bat[:daytime], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:sht], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:sht], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:sht], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:bte], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:bte], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:bte], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:dbl], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:dbl], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:dbl], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:flt], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:flt], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:flt], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:hge], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:hge], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:hge], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:int], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:int], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:int], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:lng], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:lng], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:lng], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:timestamp, b:bat[:timestamp]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:timestamp, b:bat[:timestamp], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:timestamp, b:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:timestamp, b:bat[:timestamp], s:bat[:oid], nil_matches:bit):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:any_1], b2:bat[:any_1]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:date], b2:bat[:date]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:date], b2:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:daytime], b2:bat[:daytime]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:daytime], b2:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:json], b2:bat[:json]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:timestamp], b2:bat[:timestamp]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:timestamp], b2:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:uuid], b2:bat[:uuid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:any_1], v:any_1):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:any_1], v:any_1, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:any_1], v:any_1, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:date], v:date):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:date], v:date, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:daytime], v:daytime):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:daytime], v:daytime, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:timestamp], v:timestamp):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:timestamp], v:timestamp, s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:any_1, b:bat[:any_1]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:any_1, b:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:any_1, b:bat[:any_1], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:date, b:bat[:date]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:date, b:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:daytime, b:bat[:daytime]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:daytime, b:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:timestamp, b:bat[:timestamp]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:timestamp, b:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:any_1], b2:bat[:any_1]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:date], b2:bat[:date]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:date], b2:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:daytime], b2:bat[:daytime]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:daytime], b2:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:json], b2:bat[:json]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:timestamp], b2:bat[:timestamp]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:timestamp], b2:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:uuid], b2:bat[:uuid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:any_1], v:any_1):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:any_1], v:any_1, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:any_1], v:any_1, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:date], v:date):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:date], v:date, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:daytime], v:daytime):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:daytime], v:daytime, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:sht, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:sht, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:bte, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:bte, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:dbl, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:flt, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:flt, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:hge, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:hge, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:int, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:int, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:lng, r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:lng, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:timestamp], v:timestamp):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:timestamp], v:timestamp, s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:any_1, b:bat[:any_1]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:any_1, b:bat[:any_1], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:any_1, b:bat[:any_1], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:date, b:bat[:date]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:date, b:bat[:date], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:daytime, b:bat[:daytime]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:daytime, b:bat[:daytime], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:timestamp, b:bat[:timestamp]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:timestamp, b:bat[:timestamp], s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:bte]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:hge]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:int]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:lng]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:sht]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:bte]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:hge]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:int]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:lng]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:sht]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:bte]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:hge]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:int]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:lng]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:sht]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:bte]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:hge]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:int]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:lng]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:sht]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:bte]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:hge]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:int]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:lng]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:sht]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:bte):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:hge):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:int):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:lng):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:sht):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:bte):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:bte, r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:hge):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:hge, r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:int):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:int, r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:lng):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:lng, r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:sht):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:sht, r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:bte):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:bte, r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:hge):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:hge, r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:int):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:int, r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:lng):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:lng, r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:sht):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:sht, r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:bte):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:bte, r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:hge):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:hge, r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:int):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:int, r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:lng):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:lng, r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:sht):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:sht, r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:bte):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:bte, r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:hge):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:hge, r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:int):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:int, r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:lng):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:lng, r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:sht):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:sht, r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:bte]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:hge]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:int]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:lng]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:sht]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:bte]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:bte], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:hge]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:int]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:int], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:lng]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:lng], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:sht]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:sht], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:bte]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:bte], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:hge]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:hge], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:int]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:lng]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:lng], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:sht]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:sht], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:bte]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:bte], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:hge]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:hge], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:int]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:int], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:lng]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:sht]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:sht], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:bte]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:bte], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:hge]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:hge], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:int]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:int], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:lng]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:lng], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:sht]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:bte]):bat[:bte] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:dbl]):bat[:dbl] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:flt]):bat[:flt] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:hge]):bat[:hge] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:int]):bat[:int] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:lng]):bat[:lng] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:sht]):bat[:sht] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bit], b2:bat[:bit]):bat[:bit] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bit], b2:bat[:bit], r:bat[:bit]):bat[:bit] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bit], b2:bat[:bit], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bit], b2:bat[:bit], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bte], b2:bat[:bte]):bat[:bte] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bte], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:hge], b2:bat[:hge]):bat[:hge] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:int], b2:bat[:int]):bat[:int] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:int], b2:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:lng], b2:bat[:lng]):bat[:lng] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:lng], b2:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:sht], b2:bat[:sht]):bat[:sht] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:sht], b2:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bit], v:bit):bat[:bit] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bit], v:bit, r:bat[:bit]):bat[:bit] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bit], v:bit, s:bat[:oid]):bat[:bit] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bit], v:bit, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bte], v:bte):bat[:bte] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bte], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:hge], v:hge):bat[:hge] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:hge], v:hge, r:bat[:bit]):bat[:hge] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:int], v:int):bat[:int] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:int], v:int, r:bat[:bit]):bat[:int] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:lng], v:lng):bat[:lng] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:lng], v:lng, r:bat[:bit]):bat[:lng] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:sht], v:sht):bat[:sht] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:sht], v:sht, r:bat[:bit]):bat[:sht] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bit, b:bat[:bit]):bat[:bit] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bit, b:bat[:bit], r:bat[:bit]):bat[:bit] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bit, b:bat[:bit], s:bat[:oid]):bat[:bit] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bit, b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bte, b:bat[:bte]):bat[:bte] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bte, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:hge, b:bat[:hge]):bat[:hge] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:hge, b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:int, b:bat[:int]):bat[:int] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:int, b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:lng, b:bat[:lng]):bat[:lng] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:lng, b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:sht, b:bat[:sht]):bat[:sht] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:sht, b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte], s:bat[:oid]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte], s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte], s:bat[:oid], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte], s:bat[:oid], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl], s:bat[:oid]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl], s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl], s:bat[:oid], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl], s:bat[:oid], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt], s:bat[:oid]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt], s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt], s:bat[:oid], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt], s:bat[:oid], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-r:bat[:bit],nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge]):dbl ",	"CMDcalcavg;",	"average of non-r:bat[:bit],nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], s:bat[:oid]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], s:bat[:oid]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-r:bat[:bit],nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-r:bat[:bit],nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], s:bat[:oid], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], s:bat[:oid], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-r:bat[:bit],nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], s:bat[:oid], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], s:bat[:oid], scale:int):dbl ",	"CMDcalcavg;",	"average of non-r:bat[:bit],nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-r:bat[:bit],nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge], scale:int):dbl ",	"CMDcalcavg;",	"average of non-r:bat[:bit],nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int], s:bat[:oid]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int], s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int], s:bat[:oid], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int], s:bat[:oid], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng], s:bat[:oid]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng], s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng], s:bat[:oid], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng], s:bat[:oid], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht], s:bat[:oid]) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht], s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht], s:bat[:oid], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht], s:bat[:oid], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht], scale:int) (X_0:dbl, X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht], scale:int):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:any_1, v2:any_1, r:bat[:bit], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with conditional execution bat"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:any_1, v2:any_1, s:bat[:oid], r:bat[:bit], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with candidate list and conditional execution bat"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:any_1, v2:any_1, s:bat[:oid], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with candidate list"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:any_1, v2:any_1, sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa)"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:any_1, v2:bat[:any_1], r:bat[:bit], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with conditional execution bat"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:any_1, v2:bat[:any_1], s:bat[:oid], s2:bat[:oid], r:bat[:bit], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with candidate list and conditional execution bat"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:any_1, v2:bat[:any_1], s:bat[:oid], s2:bat[:oid], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with candidate list"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:any_1, v2:bat[:any_1], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa)"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:bat[:any_1], v2:any_1, r:bat[:bit], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with conditional execution bat"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:bat[:any_1], v2:any_1, s:bat[:oid], s1:bat[:oid], r:bat[:bit], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with candidate list and conditional execution bat"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:bat[:any_1], v2:any_1, s:bat[:oid], s1:bat[:oid], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with candidate list"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:bat[:any_1], v2:any_1, sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa)"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:bat[:any_1], v2:bat[:any_1], r:bat[:bit], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with conditional execution bat"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:bat[:any_1], v2:bat[:any_1], s:bat[:oid], s1:bat[:oid], s2:bat[:oid], r:bat[:bit], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with candidate list and conditional execution bat"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:bat[:any_1], v2:bat[:any_1], s:bat[:oid], s1:bat[:oid], s2:bat[:oid], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa) with candidate list"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1], v1:bat[:any_1], v2:bat[:any_1], sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bat[:bit] ",	"CMDbatBETWEEN;",	"B between V1 and V2 (or vice versa)"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bit to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bit], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bit to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bit], s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bit to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bit to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bte]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bte to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bte to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bte to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bte to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:dbl]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from dbl to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from dbl to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from dbl to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from dbl to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:flt]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from flt to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from flt to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from flt to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from flt to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:hge]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from hge to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from hge to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from hge to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from hge to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:int]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from int to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from int to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from int to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from int to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:lng]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from lng to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from lng to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from lng to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from lng to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from oid to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from oid to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:oid], s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from oid to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from oid to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:sht]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from sht to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from sht to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from sht to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from sht to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:str]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from str to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:str], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from str to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:str], s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from str to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from str to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bit to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bit], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bit to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bit], s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bit to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bit to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bte]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bte to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bte to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bte to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bte to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:dbl]):bat[:bit] ",	"CMDconvert_bit;",	"cast from dbl to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from dbl to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from dbl to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from dbl to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:flt]):bat[:bit] ",	"CMDconvert_bit;",	"cast from flt to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from flt to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from flt to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from flt to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:hge]):bat[:bit] ",	"CMDconvert_bit;",	"cast from hge to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from hge to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from hge to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from hge to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:int]):bat[:bit] ",	"CMDconvert_bit;",	"cast from int to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from int to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from int to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from int to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:lng]):bat[:bit] ",	"CMDconvert_bit;",	"cast from lng to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from lng to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from lng to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from lng to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from oid to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from oid to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:oid], s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from oid to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from oid to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:sht]):bat[:bit] ",	"CMDconvert_bit;",	"cast from sht to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from sht to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from sht to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from sht to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:str]):bat[:bit] ",	"CMDconvert_bit;",	"cast from str to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:str], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from str to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:str], s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from str to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from str to bit with candidates list"	]
[ "batcalc",	"blob",	"command batcalc.blob(v:bat[:str]):bat[:blob] ",	"batstr_2_blob;",	"cast to blob"	]
[ "batcalc",	"blob",	"command batcalc.blob(v:bat[:str], r:bat[:bit]):bat[:blob] ",	"batstr_ce_2_blob;",	"cast to blob"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bit to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bit], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bit to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bit], s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bit to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bit to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bte]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bte to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bte to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bte to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bte to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:dbl]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from dbl to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from dbl to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from dbl to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from dbl to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:flt]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from flt to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from flt to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from flt to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from flt to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:hge]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from hge to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from hge to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from hge to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from hge to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:int]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from int to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from int to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from int to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from int to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:lng]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from lng to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from lng to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from lng to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from lng to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from oid to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from oid to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:oid], s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from oid to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from oid to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:sht]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from sht to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from sht to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from sht to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from sht to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:str]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from str to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:str], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from str to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:str], s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from str to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from str to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:bte], r:bat[:bit]):bat[:bte] ",	"batbte_ce_dec2_bte;",	"cast decimal(bte) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:bte], d2:int, s2:int, r:bat[:bit]):bat[:bte] ",	"batbte_ce_dec2dec_bte;",	"cast decimal(bte) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:bte], digits:int, scale:int, r:bat[:bit]):bat[:bte] ",	"batbte_ce_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:bte]):bat[:bte] ",	"batbte_dec2_bte;",	"cast decimal(bte) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:bte], d2:int, s2:int):bat[:bte] ",	"batbte_dec2dec_bte;",	"cast decimal(bte) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:bte], digits:int, scale:int):bat[:bte] ",	"batbte_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:dbl], digits:int, scale:int, r:bat[:bit]):bat[:bte] ",	"batdbl_ce_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:dbl], digits:int, scale:int):bat[:bte] ",	"batdbl_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:flt], digits:int, scale:int, r:bat[:bit]):bat[:bte] ",	"batflt_ce_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:flt], digits:int, scale:int):bat[:bte] ",	"batflt_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:hge], r:bat[:bit]):bat[:bte] ",	"bathge_ce_dec2_bte;",	"cast decimal(hge) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:hge], d2:int, s2:int, r:bat[:bit]):bat[:bte] ",	"bathge_ce_dec2dec_bte;",	"cast decimal(hge) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:hge]):bat[:bte] ",	"bathge_dec2_bte;",	"cast decimal(hge) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:hge], d2:int, s2:int):bat[:bte] ",	"bathge_dec2dec_bte;",	"cast decimal(hge) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:hge], digits:int, scale:int):bat[:bte] ",	"bathge_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:hge], digits:int, scale:int):bat[:bte] ",	"bathge_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:int], r:bat[:bit]):bat[:bte] ",	"batint_ce_dec2_bte;",	"cast decimal(int) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:int], d2:int, s2:int, r:bat[:bit]):bat[:bte] ",	"batint_ce_dec2dec_bte;",	"cast decimal(int) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:int], digits:int, scale:int, r:bat[:bit]):bat[:bte] ",	"batint_ce_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:int]):bat[:bte] ",	"batint_dec2_bte;",	"cast decimal(int) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:int], d2:int, s2:int):bat[:bte] ",	"batint_dec2dec_bte;",	"cast decimal(int) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:int], digits:int, scale:int):bat[:bte] ",	"batint_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:lng], r:bat[:bit]):bat[:bte] ",	"batlng_ce_dec2_bte;",	"cast decimal(lng) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:lng], d2:int, s2:int, r:bat[:bit]):bat[:bte] ",	"batlng_ce_dec2dec_bte;",	"cast decimal(lng) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:lng], digits:int, scale:int, r:bat[:bit]):bat[:bte] ",	"batlng_ce_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:lng]):bat[:bte] ",	"batlng_dec2_bte;",	"cast decimal(lng) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:lng], d2:int, s2:int):bat[:bte] ",	"batlng_dec2dec_bte;",	"cast decimal(lng) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:lng], digits:int, scale:int):bat[:bte] ",	"batlng_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:oid], digits:int, scale:int):bat[:bte] ",	"batnil_2dec_bte;",	"cast to dec(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:oid], digits:int, scale:int, r:bat[:bit]):bat[:bte] ",	"batnil_ce_2dec_bte;",	"cast to dec(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:sht], r:bat[:bit]):bat[:bte] ",	"batsht_ce_dec2_bte;",	"cast decimal(sht) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:sht], d2:int, s2:int, r:bat[:bit]):bat[:bte] ",	"batsht_ce_dec2dec_bte;",	"cast decimal(sht) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:sht], digits:int, scale:int, r:bat[:bit]):bat[:bte] ",	"batsht_ce_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:sht]):bat[:bte] ",	"batsht_dec2_bte;",	"cast decimal(sht) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int, v:bat[:sht], d2:int, s2:int):bat[:bte] ",	"batsht_dec2dec_bte;",	"cast decimal(sht) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:sht], digits:int, scale:int):bat[:bte] ",	"batsht_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:str], digits:int, scale:int):bat[:bte] ",	"batstr_2dec_bte;",	"cast to dec(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:str], digits:int, scale:int, r:bat[:bit]):bat[:bte] ",	"batstr_ce_2dec_bte;",	"cast to dec(bte) and check for overflow"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bit to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bit], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bit to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bit], s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bit to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bit to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bte]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bte to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bte to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bte to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bte to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:dbl]):bat[:bte] ",	"CMDconvert_bte;",	"cast from dbl to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from dbl to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from dbl to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from dbl to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:flt]):bat[:bte] ",	"CMDconvert_bte;",	"cast from flt to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from flt to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from flt to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from flt to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:hge]):bat[:bte] ",	"CMDconvert_bte;",	"cast from hge to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from hge to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from hge to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from hge to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:int]):bat[:bte] ",	"CMDconvert_bte;",	"cast from int to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from int to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from int to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from int to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:lng]):bat[:bte] ",	"CMDconvert_bte;",	"cast from lng to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from lng to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from lng to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from lng to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from oid to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from oid to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:oid], s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from oid to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from oid to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:sht]):bat[:bte] ",	"CMDconvert_bte;",	"cast from sht to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from sht to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from sht to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from sht to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:str]):bat[:bte] ",	"CMDconvert_bte;",	"cast from str to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:str], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from str to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:str], s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from str to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from str to bte with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bit], b2:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bit], b2:bat[:bit], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bit], b2:bat[:bit], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bit], b2:bat[:bit], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:oid], b2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:oid], b2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:oid], b2:bat[:oid], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:oid], b2:bat[:oid], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:str], b2:bat[:str]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:str], b2:bat[:str], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:str], b2:bat[:str], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:str], b2:bat[:str], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bit], v:bit):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bit], v:bit, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bit], v:bit, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bit], v:bit, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:dbl, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:flt, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:flt, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:dbl, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:flt, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:dbl, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:flt, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:flt, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:dbl, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:flt, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:flt, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:dbl, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:dbl, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:flt, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:flt, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:dbl, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:flt, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:flt, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:oid], v:oid):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:oid], v:oid, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:oid], v:oid, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:oid], v:oid, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:dbl, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:flt, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:flt, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:str], v:str):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:str], v:str, r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:str], v:str, s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:str], v:str, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bit, b:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bit, b:bat[:bit], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bit, b:bat[:bit], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bit, b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:oid, b:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:oid, b:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:oid, b:bat[:oid], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:oid, b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:str, b:bat[:str]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:str, b:bat[:str], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:str, b:bat[:str], s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:str, b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"date",	"command batcalc.date(t:bat[:timestamp]):bat[:date] ",	"MTIMEtimestamp_extract_date_bulk;",	""	]
[ "batcalc",	"date",	"command batcalc.date(v:bat[:oid]):bat[:date] ",	"batnil_2_date;",	"cast to date"	]
[ "batcalc",	"date",	"command batcalc.date(v:bat[:oid], r:bat[:bit]):bat[:date] ",	"batnil_ce_2_date;",	"cast to date"	]
[ "batcalc",	"date",	"command batcalc.date(v:bat[:str]):bat[:date] ",	"batstr_2_date;",	"cast to date"	]
[ "batcalc",	"date",	"command batcalc.date(v:bat[:str], r:bat[:bit]):bat[:date] ",	"batstr_ce_2_date;",	"cast to date"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(s:bat[:lng]):bat[:daytime] ",	"MTIMEdaytime_fromseconds_bulk;",	""	]
[ "batcalc",	"daytime",	"command batcalc.daytime(t:bat[:timestamp]):bat[:daytime] ",	"MTIMEtimestamp_extract_daytime_bulk;",	""	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:daytime], digits:int):bat[:daytime] ",	"batdaytime_2time_daytime;",	"cast daytime to daytime and check for overflow"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:oid], digits:int):bat[:daytime] ",	"batnil_2time_daytime;",	"cast to daytime and check for overflow"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:oid], digits:int, r:bat[:bit]):bat[:daytime] ",	"batnil_ce_2time_daytime;",	"cast to daytime and check for overflow"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:str], digits:int):bat[:daytime] ",	"batstr_2time_daytime;",	"cast to daytime and check for overflow"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:str], digits:int, has_tz:int):bat[:daytime] ",	"batstr_2time_daytimetz;",	"cast to daytime and check for overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bit to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bit], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bit to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bit], s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bit to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bit to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bte]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bte to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bte], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bte to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bte to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bte to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:dbl]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from dbl to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from dbl to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from dbl to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from dbl to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:flt]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from flt to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:flt], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from flt to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from flt to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from flt to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:hge]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from hge to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:hge], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from hge to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from hge to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from hge to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:int]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from int to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:int], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from int to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from int to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from int to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:lng]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from lng to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:lng], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from lng to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from lng to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from lng to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from oid to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from oid to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:oid], s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from oid to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from oid to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:sht]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from sht to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:sht], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from sht to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from sht to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from sht to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:str]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from str to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:str], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from str to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:str], s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from str to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from str to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:bte], r:bat[:bit]):bat[:dbl] ",	"batbte_ce_dec2_dbl;",	"cast decimal(bte) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:bte], d2:int, s2:int, r:bat[:bit]):bat[:dbl] ",	"batbte_ce_dec2dec_dbl;",	"cast decimal(bte) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:bte], digits:int, scale:int, r:bat[:bit]):bat[:dbl] ",	"batbte_ce_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:bte]):bat[:dbl] ",	"batbte_dec2_dbl;",	"cast decimal(bte) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:bte], d2:int, s2:int):bat[:dbl] ",	"batbte_dec2dec_dbl;",	"cast decimal(bte) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:bte], digits:int, scale:int):bat[:dbl] ",	"batbte_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:hge], r:bat[:bit]):bat[:dbl] ",	"bathge_ce_dec2_dbl;",	"cast decimal(hge) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:hge], d2:int, s2:int, r:bat[:bit]):bat[:dbl] ",	"bathge_ce_dec2dec_dbl;",	"cast decimal(hge) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:hge]):bat[:dbl] ",	"bathge_dec2_dbl;",	"cast decimal(hge) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:hge], d2:int, s2:int):bat[:dbl] ",	"bathge_dec2dec_dbl;",	"cast decimal(hge) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:hge], digits:int, scale:int):bat[:dbl] ",	"bathge_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:hge], digits:int, scale:int):bat[:dbl] ",	"bathge_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:int], r:bat[:bit]):bat[:dbl] ",	"batint_ce_dec2_dbl;",	"cast decimal(int) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:int], d2:int, s2:int, r:bat[:bit]):bat[:dbl] ",	"batint_ce_dec2dec_dbl;",	"cast decimal(int) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:int], digits:int, scale:int, r:bat[:bit]):bat[:dbl] ",	"batint_ce_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:int]):bat[:dbl] ",	"batint_dec2_dbl;",	"cast decimal(int) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:int], d2:int, s2:int):bat[:dbl] ",	"batint_dec2dec_dbl;",	"cast decimal(int) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:int], digits:int, scale:int):bat[:dbl] ",	"batint_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:lng], r:bat[:bit]):bat[:dbl] ",	"batlng_ce_dec2_dbl;",	"cast decimal(lng) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:lng], d2:int, s2:int, r:bat[:bit]):bat[:dbl] ",	"batlng_ce_dec2dec_dbl;",	"cast decimal(lng) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:lng], digits:int, scale:int, r:bat[:bit]):bat[:dbl] ",	"batlng_ce_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:lng]):bat[:dbl] ",	"batlng_dec2_dbl;",	"cast decimal(lng) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:lng], d2:int, s2:int):bat[:dbl] ",	"batlng_dec2dec_dbl;",	"cast decimal(lng) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:lng], digits:int, scale:int):bat[:dbl] ",	"batlng_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:sht], r:bat[:bit]):bat[:dbl] ",	"batsht_ce_dec2_dbl;",	"cast decimal(sht) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:sht], d2:int, s2:int, r:bat[:bit]):bat[:dbl] ",	"batsht_ce_dec2dec_dbl;",	"cast decimal(sht) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:sht], digits:int, scale:int, r:bat[:bit]):bat[:dbl] ",	"batsht_ce_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:sht]):bat[:dbl] ",	"batsht_dec2_dbl;",	"cast decimal(sht) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int, v:bat[:sht], d2:int, s2:int):bat[:dbl] ",	"batsht_dec2dec_dbl;",	"cast decimal(sht) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:sht], digits:int, scale:int):bat[:dbl] ",	"batsht_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bit to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bit], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bit to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bit], s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bit to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bit to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bte]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bte to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bte], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bte to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bte to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bte to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:dbl]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from dbl to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from dbl to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from dbl to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from dbl to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:flt]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from flt to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:flt], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from flt to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from flt to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from flt to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:hge]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from hge to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:hge], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from hge to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from hge to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from hge to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:int]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from int to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:int], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from int to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from int to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from int to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:lng]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from lng to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:lng], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from lng to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from lng to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from lng to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from oid to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from oid to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:oid], s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from oid to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from oid to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:sht]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from sht to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:sht], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from sht to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from sht to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from sht to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:str]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from str to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:str], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from str to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:str], s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from str to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from str to dbl with candidates list"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:flt, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:dbl, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:dbl, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:dbl, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:flt, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:flt, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:flt, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:flt, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:flt, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:dbl], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:dbl], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:flt], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:flt], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:flt], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bit to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bit], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bit to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bit], s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bit to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bit to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bte]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bte to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bte], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bte to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bte to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bte to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:dbl]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from dbl to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:dbl], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from dbl to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from dbl to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from dbl to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:flt]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from flt to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from flt to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from flt to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from flt to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:hge]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from hge to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:hge], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from hge to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from hge to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from hge to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:int]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from int to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:int], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from int to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from int to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from int to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:lng]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from lng to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:lng], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from lng to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from lng to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from lng to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from oid to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from oid to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:oid], s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from oid to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from oid to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:sht]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from sht to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:sht], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from sht to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from sht to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from sht to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:str]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from str to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:str], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from str to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:str], s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from str to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from str to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:bte], r:bat[:bit]):bat[:flt] ",	"batbte_ce_dec2_flt;",	"cast decimal(bte) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:bte], d2:int, s2:int, r:bat[:bit]):bat[:flt] ",	"batbte_ce_dec2dec_flt;",	"cast decimal(bte) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:bte], digits:int, scale:int, r:bat[:bit]):bat[:flt] ",	"batbte_ce_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:bte]):bat[:flt] ",	"batbte_dec2_flt;",	"cast decimal(bte) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:bte], d2:int, s2:int):bat[:flt] ",	"batbte_dec2dec_flt;",	"cast decimal(bte) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:bte], digits:int, scale:int):bat[:flt] ",	"batbte_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:hge], r:bat[:bit]):bat[:flt] ",	"bathge_ce_dec2_flt;",	"cast decimal(hge) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:hge], d2:int, s2:int, r:bat[:bit]):bat[:flt] ",	"bathge_ce_dec2dec_flt;",	"cast decimal(hge) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:hge]):bat[:flt] ",	"bathge_dec2_flt;",	"cast decimal(hge) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:hge], d2:int, s2:int):bat[:flt] ",	"bathge_dec2dec_flt;",	"cast decimal(hge) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:hge], digits:int, scale:int):bat[:flt] ",	"bathge_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:hge], digits:int, scale:int):bat[:flt] ",	"bathge_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:int], r:bat[:bit]):bat[:flt] ",	"batint_ce_dec2_flt;",	"cast decimal(int) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:int], d2:int, s2:int, r:bat[:bit]):bat[:flt] ",	"batint_ce_dec2dec_flt;",	"cast decimal(int) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:int], digits:int, scale:int, r:bat[:bit]):bat[:flt] ",	"batint_ce_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:int]):bat[:flt] ",	"batint_dec2_flt;",	"cast decimal(int) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:int], d2:int, s2:int):bat[:flt] ",	"batint_dec2dec_flt;",	"cast decimal(int) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:int], digits:int, scale:int):bat[:flt] ",	"batint_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:lng], r:bat[:bit]):bat[:flt] ",	"batlng_ce_dec2_flt;",	"cast decimal(lng) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:lng], d2:int, s2:int, r:bat[:bit]):bat[:flt] ",	"batlng_ce_dec2dec_flt;",	"cast decimal(lng) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:lng], digits:int, scale:int, r:bat[:bit]):bat[:flt] ",	"batlng_ce_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:lng]):bat[:flt] ",	"batlng_dec2_flt;",	"cast decimal(lng) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:lng], d2:int, s2:int):bat[:flt] ",	"batlng_dec2dec_flt;",	"cast decimal(lng) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:lng], digits:int, scale:int):bat[:flt] ",	"batlng_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:sht], r:bat[:bit]):bat[:flt] ",	"batsht_ce_dec2_flt;",	"cast decimal(sht) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:sht], d2:int, s2:int, r:bat[:bit]):bat[:flt] ",	"batsht_ce_dec2dec_flt;",	"cast decimal(sht) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:sht], digits:int, scale:int, r:bat[:bit]):bat[:flt] ",	"batsht_ce_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:sht]):bat[:flt] ",	"batsht_dec2_flt;",	"cast decimal(sht) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int, v:bat[:sht], d2:int, s2:int):bat[:flt] ",	"batsht_dec2dec_flt;",	"cast decimal(sht) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:sht], digits:int, scale:int):bat[:flt] ",	"batsht_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bit to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bit], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bit to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bit], s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bit to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bit to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bte]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bte to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bte], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bte to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bte to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bte to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:dbl]):bat[:flt] ",	"CMDconvert_flt;",	"cast from dbl to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:dbl], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from dbl to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:dbl], s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from dbl to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from dbl to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:flt]):bat[:flt] ",	"CMDconvert_flt;",	"cast from flt to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from flt to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from flt to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from flt to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:hge]):bat[:flt] ",	"CMDconvert_flt;",	"cast from hge to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:hge], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from hge to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from hge to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from hge to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:int]):bat[:flt] ",	"CMDconvert_flt;",	"cast from int to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:int], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from int to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from int to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from int to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:lng]):bat[:flt] ",	"CMDconvert_flt;",	"cast from lng to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:lng], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from lng to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from lng to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from lng to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from oid to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from oid to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:oid], s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from oid to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from oid to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:sht]):bat[:flt] ",	"CMDconvert_flt;",	"cast from sht to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:sht], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from sht to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from sht to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from sht to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:str]):bat[:flt] ",	"CMDconvert_flt;",	"cast from str to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:str], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from str to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:str], s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from str to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from str to flt with candidates list"	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:any_1]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:bte]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:dbl]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:flt]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:hge]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:int]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:lng]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:lng]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:oid]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:sht]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bit to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bit], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bit to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bit], s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bit to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bit to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bte]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bte to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bte], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bte to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bte to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bte to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:dbl]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from dbl to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:dbl], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from dbl to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from dbl to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from dbl to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:flt]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from flt to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:flt], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from flt to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from flt to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from flt to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:hge]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from hge to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from hge to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from hge to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from hge to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:int]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from int to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:int], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from int to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from int to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from int to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:lng]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from lng to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:lng], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from lng to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from lng to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from lng to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from oid to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from oid to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:oid], s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from oid to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from oid to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:sht]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from sht to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:sht], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from sht to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from sht to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from sht to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:str]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from str to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:str], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from str to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:str], s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from str to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from str to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:bte], r:bat[:bit]):bat[:hge] ",	"batbte_ce_dec2_hge;",	"cast decimal(bte) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:bte], d2:int, s2:int, r:bat[:bit]):bat[:hge] ",	"batbte_ce_dec2dec_hge;",	"cast decimal(bte) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:bte], digits:int, scale:int, r:bat[:bit]):bat[:hge] ",	"batbte_ce_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:bte]):bat[:hge] ",	"batbte_dec2_hge;",	"cast decimal(bte) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:bte], d2:int, s2:int):bat[:hge] ",	"batbte_dec2dec_hge;",	"cast decimal(bte) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:bte], digits:int, scale:int):bat[:hge] ",	"batbte_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:dbl], digits:int, scale:int, r:bat[:bit]):bat[:hge] ",	"batdbl_ce_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:dbl], digits:int, scale:int):bat[:hge] ",	"batdbl_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:flt], digits:int, scale:int, r:bat[:bit]):bat[:hge] ",	"batflt_ce_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:flt], digits:int, scale:int):bat[:hge] ",	"batflt_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:hge], r:bat[:bit]):bat[:hge] ",	"bathge_ce_dec2_hge;",	"cast decimal(hge) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:hge], d2:int, s2:int, r:bat[:bit]):bat[:hge] ",	"bathge_ce_dec2dec_hge;",	"cast decimal(hge) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:hge], digits:int, scale:int, r:bat[:bit]):bat[:hge] ",	"bathge_ce_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:hge]):bat[:hge] ",	"bathge_dec2_hge;",	"cast decimal(hge) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:hge], d2:int, s2:int):bat[:hge] ",	"bathge_dec2dec_hge;",	"cast decimal(hge) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:hge], digits:int, scale:int):bat[:hge] ",	"bathge_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:int], r:bat[:bit]):bat[:hge] ",	"batint_ce_dec2_hge;",	"cast decimal(int) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:int], d2:int, s2:int, r:bat[:bit]):bat[:hge] ",	"batint_ce_dec2dec_hge;",	"cast decimal(int) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:int], digits:int, scale:int, r:bat[:bit]):bat[:hge] ",	"batint_ce_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:int]):bat[:hge] ",	"batint_dec2_hge;",	"cast decimal(int) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:int], d2:int, s2:int):bat[:hge] ",	"batint_dec2dec_hge;",	"cast decimal(int) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:int], digits:int, scale:int):bat[:hge] ",	"batint_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:lng], r:bat[:bit]):bat[:hge] ",	"batlng_ce_dec2_hge;",	"cast decimal(lng) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:lng], d2:int, s2:int, r:bat[:bit]):bat[:hge] ",	"batlng_ce_dec2dec_hge;",	"cast decimal(lng) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:lng], digits:int, scale:int, r:bat[:bit]):bat[:hge] ",	"batlng_ce_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:lng]):bat[:hge] ",	"batlng_dec2_hge;",	"cast decimal(lng) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:lng], d2:int, s2:int):bat[:hge] ",	"batlng_dec2dec_hge;",	"cast decimal(lng) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:lng], digits:int, scale:int):bat[:hge] ",	"batlng_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:void], digits:int, scale:int):bat[:hge] ",	"batnil_2dec_hge;",	"cast to dec(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:void], digits:int, scale:int, r:bat[:bit]):bat[:hge] ",	"batnil_ce_2dec_hge;",	"cast to dec(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:sht], r:bat[:bit]):bat[:hge] ",	"batsht_ce_dec2_hge;",	"cast decimal(sht) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:sht], d2:int, s2:int, r:bat[:bit]):bat[:hge] ",	"batsht_ce_dec2dec_hge;",	"cast decimal(sht) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:sht], digits:int, scale:int, r:bat[:bit]):bat[:hge] ",	"batsht_ce_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:sht]):bat[:hge] ",	"batsht_dec2_hge;",	"cast decimal(sht) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int, v:bat[:sht], d2:int, s2:int):bat[:hge] ",	"batsht_dec2dec_hge;",	"cast decimal(sht) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:sht], digits:int, scale:int):bat[:hge] ",	"batsht_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:str], digits:int, scale:int):bat[:hge] ",	"batstr_2dec_hge;",	"cast to dec(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:str], digits:int, scale:int, r:bat[:bit]):bat[:hge] ",	"batstr_ce_2dec_hge;",	"cast to dec(hge) and check for overflow"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bit to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bit], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bit to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bit], s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bit to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bit to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bte]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bte to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bte], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bte to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bte to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bte to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:dbl]):bat[:hge] ",	"CMDconvert_hge;",	"cast from dbl to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:dbl], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from dbl to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:dbl], s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from dbl to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from dbl to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:flt]):bat[:hge] ",	"CMDconvert_hge;",	"cast from flt to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:flt], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from flt to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:flt], s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from flt to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from flt to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:hge]):bat[:hge] ",	"CMDconvert_hge;",	"cast from hge to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from hge to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from hge to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from hge to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:int]):bat[:hge] ",	"CMDconvert_hge;",	"cast from int to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:int], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from int to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from int to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from int to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:lng]):bat[:hge] ",	"CMDconvert_hge;",	"cast from lng to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:lng], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from lng to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from lng to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from lng to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from oid to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from oid to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:oid], s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from oid to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from oid to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:sht]):bat[:hge] ",	"CMDconvert_hge;",	"cast from sht to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:sht], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from sht to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from sht to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from sht to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:str]):bat[:hge] ",	"CMDconvert_hge;",	"cast from str to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:str], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from str to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:str], s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from str to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from str to hge with candidates list"	]
[ "batcalc",	"identity",	"command batcalc.identity(b:bat[:any_2]):bat[:oid] ",	"BATSQLidentity;",	"Returns the unique row identitfiers."	]
[ "batcalc",	"identity",	"pattern batcalc.identity(b:bat[:any_2], s:oid) (resb:bat[:oid], ns:oid) ",	"PBATSQLidentity;",	"Returns the unique row identitfiers."	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(b:bat[:bit], b1:bat[:any_1], b2:bat[:any_1]):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(b:bat[:bit], b1:bat[:any_1], v2:any_1):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(b:bat[:bit], v1:any_1, b2:bat[:any_1]):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(b:bat[:bit], v1:any_1, v2:any_1):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(v:bit, b1:bat[:any_1], b2:bat[:any_1]):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(v:bit, b1:bat[:any_1], v2:any_1):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(v:bit, v1:any_1, b2:bat[:any_1]):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"index",	"command batcalc.index(v:bat[:str], u:bit):bat[:bte] ",	"BATSTRindex_bte;",	"Return the offsets as an index bat"	]
[ "batcalc",	"index",	"command batcalc.index(v:bat[:str], u:bit):bat[:int] ",	"BATSTRindex_int;",	"Return the offsets as an index bat"	]
[ "batcalc",	"index",	"command batcalc.index(v:bat[:str], u:bit):bat[:sht] ",	"BATSTRindex_sht;",	"Return the offsets as an index bat"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bit to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bit], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bit to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bit], s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bit to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bit to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bte]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bte to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bte], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bte to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bte to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bte to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:dbl]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from dbl to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:dbl], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from dbl to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:dbl], s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from dbl to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from dbl to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:flt]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from flt to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:flt], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from flt to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:flt], s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from flt to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from flt to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:hge]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from hge to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:hge], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from hge to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from hge to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from hge to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:int]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from int to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from int to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from int to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from int to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:lng]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from lng to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:lng], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from lng to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from lng to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from lng to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from oid to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from oid to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:oid], s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from oid to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from oid to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:sht]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from sht to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:sht], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from sht to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from sht to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from sht to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:str]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from str to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:str], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from str to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:str], s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from str to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from str to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:bte], r:bat[:bit]):bat[:int] ",	"batbte_ce_dec2_int;",	"cast decimal(bte) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:bte], d2:int, s2:int, r:bat[:bit]):bat[:int] ",	"batbte_ce_dec2dec_int;",	"cast decimal(bte) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:bte], digits:int, scale:int, r:bat[:bit]):bat[:int] ",	"batbte_ce_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:bte]):bat[:int] ",	"batbte_dec2_int;",	"cast decimal(bte) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:bte], d2:int, s2:int):bat[:int] ",	"batbte_dec2dec_int;",	"cast decimal(bte) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:bte], digits:int, scale:int):bat[:int] ",	"batbte_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:dbl], digits:int, scale:int, r:bat[:bit]):bat[:int] ",	"batdbl_ce_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:dbl], digits:int, scale:int):bat[:int] ",	"batdbl_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:flt], digits:int, scale:int, r:bat[:bit]):bat[:int] ",	"batflt_ce_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:flt], digits:int, scale:int):bat[:int] ",	"batflt_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:hge], r:bat[:bit]):bat[:int] ",	"bathge_ce_dec2_int;",	"cast decimal(hge) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:hge], d2:int, s2:int, r:bat[:bit]):bat[:int] ",	"bathge_ce_dec2dec_int;",	"cast decimal(hge) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:hge]):bat[:int] ",	"bathge_dec2_int;",	"cast decimal(hge) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:hge], d2:int, s2:int):bat[:int] ",	"bathge_dec2dec_int;",	"cast decimal(hge) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:hge], digits:int, scale:int):bat[:int] ",	"bathge_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:hge], digits:int, scale:int):bat[:int] ",	"bathge_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:int], r:bat[:bit]):bat[:int] ",	"batint_ce_dec2_int;",	"cast decimal(int) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:int], d2:int, s2:int, r:bat[:bit]):bat[:int] ",	"batint_ce_dec2dec_int;",	"cast decimal(int) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:int], digits:int, scale:int, r:bat[:bit]):bat[:int] ",	"batint_ce_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:int]):bat[:int] ",	"batint_dec2_int;",	"cast decimal(int) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:int], d2:int, s2:int):bat[:int] ",	"batint_dec2dec_int;",	"cast decimal(int) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:int], digits:int, scale:int):bat[:int] ",	"batint_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:lng], r:bat[:bit]):bat[:int] ",	"batlng_ce_dec2_int;",	"cast decimal(lng) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:lng], d2:int, s2:int, r:bat[:bit]):bat[:int] ",	"batlng_ce_dec2dec_int;",	"cast decimal(lng) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:lng], digits:int, scale:int, r:bat[:bit]):bat[:int] ",	"batlng_ce_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:lng]):bat[:int] ",	"batlng_dec2_int;",	"cast decimal(lng) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:lng], d2:int, s2:int):bat[:int] ",	"batlng_dec2dec_int;",	"cast decimal(lng) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:lng], digits:int, scale:int):bat[:int] ",	"batlng_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:oid], digits:int, scale:int):bat[:int] ",	"batnil_2dec_int;",	"cast to dec(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:oid], digits:int, scale:int, r:bat[:bit]):bat[:int] ",	"batnil_ce_2dec_int;",	"cast to dec(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:sht], r:bat[:bit]):bat[:int] ",	"batsht_ce_dec2_int;",	"cast decimal(sht) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:sht], d2:int, s2:int, r:bat[:bit]):bat[:int] ",	"batsht_ce_dec2dec_int;",	"cast decimal(sht) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:sht], digits:int, scale:int, r:bat[:bit]):bat[:int] ",	"batsht_ce_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:sht]):bat[:int] ",	"batsht_dec2_int;",	"cast decimal(sht) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int, v:bat[:sht], d2:int, s2:int):bat[:int] ",	"batsht_dec2dec_int;",	"cast decimal(sht) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:sht], digits:int, scale:int):bat[:int] ",	"batsht_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:str], digits:int, scale:int):bat[:int] ",	"batstr_2dec_int;",	"cast to dec(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:str], digits:int, scale:int, r:bat[:bit]):bat[:int] ",	"batstr_ce_2dec_int;",	"cast to dec(int) and check for overflow"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from bit to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bit], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from bit to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bit], s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from bit to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from bit to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bte]):bat[:int] ",	"CMDconvert_int;",	"cast from bte to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bte], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from bte to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from bte to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from bte to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:dbl]):bat[:int] ",	"CMDconvert_int;",	"cast from dbl to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:dbl], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from dbl to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:dbl], s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from dbl to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from dbl to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:flt]):bat[:int] ",	"CMDconvert_int;",	"cast from flt to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:flt], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from flt to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:flt], s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from flt to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from flt to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:hge]):bat[:int] ",	"CMDconvert_int;",	"cast from hge to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:hge], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from hge to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from hge to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from hge to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:int]):bat[:int] ",	"CMDconvert_int;",	"cast from int to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from int to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from int to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from int to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:lng]):bat[:int] ",	"CMDconvert_int;",	"cast from lng to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:lng], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from lng to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from lng to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from lng to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from oid to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from oid to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:oid], s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from oid to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from oid to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:sht]):bat[:int] ",	"CMDconvert_int;",	"cast from sht to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:sht], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from sht to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from sht to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from sht to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:str]):bat[:int] ",	"CMDconvert_int;",	"cast from str to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:str], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from str to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:str], s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from str to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from str to int with candidates list"	]
[ "batcalc",	"isnil",	"pattern batcalc.isnil(b:bat[:any]):bat[:bit] ",	"CMDbatISNIL;",	"Unary check for nil over the tail of the bat"	]
[ "batcalc",	"isnil",	"pattern batcalc.isnil(b:bat[:any], r:bat[:bit]):bat[:bit] ",	"CMDbatISNIL;",	"Unary check for nil over the tail of the bat"	]
[ "batcalc",	"isnil",	"pattern batcalc.isnil(b:bat[:any], s:bat[:oid]):bat[:bit] ",	"CMDbatISNIL;",	"Unary check for nil over the tail of the bat with candidates list"	]
[ "batcalc",	"isnil",	"pattern batcalc.isnil(b:bat[:any], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatISNIL;",	"Unary check for nil over the tail of the bat with candidates list"	]
[ "batcalc",	"isnotnil",	"pattern batcalc.isnotnil(b:bat[:any]):bat[:bit] ",	"CMDbatISNOTNIL;",	"Unary check for notnil over the tail of the bat"	]
[ "batcalc",	"isnotnil",	"pattern batcalc.isnotnil(b:bat[:any], r:bat[:bit]):bat[:bit] ",	"CMDbatISNOTNIL;",	"Unary check for notnil over the tail of the bat"	]
[ "batcalc",	"isnotnil",	"pattern batcalc.isnotnil(b:bat[:any], s:bat[:oid]):bat[:bit] ",	"CMDbatISNOTNIL;",	"Unary check for notnil over the tail of the bat with candidates list"	]
[ "batcalc",	"isnotnil",	"pattern batcalc.isnotnil(b:bat[:any], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatISNOTNIL;",	"Unary check for notnil over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:bte]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:bte], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:bte], s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:dbl]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:dbl], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:dbl], s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:flt]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:flt], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:flt], s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:hge]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:hge], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:hge], s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:int]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:int], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:int], s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:lng]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:lng], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:lng], s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:sht]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:sht], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:sht], s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bit to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bit], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bit to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bit], s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bit to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bit to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bte]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bte to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bte], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bte to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bte to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bte to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:dbl]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from dbl to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:dbl], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from dbl to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:dbl], s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from dbl to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from dbl to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:flt]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from flt to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:flt], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from flt to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:flt], s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from flt to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from flt to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:hge]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from hge to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:hge], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from hge to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from hge to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from hge to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:int]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from int to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:int], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from int to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from int to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from int to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:lng]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from lng to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from lng to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from lng to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from lng to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from oid to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from oid to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:oid], s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from oid to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from oid to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:sht]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from sht to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:sht], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from sht to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from sht to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from sht to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:str]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from str to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:str], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from str to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:str], s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from str to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from str to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:bte], r:bat[:bit]):bat[:lng] ",	"batbte_ce_dec2_lng;",	"cast decimal(bte) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:bte], d2:int, s2:int, r:bat[:bit]):bat[:lng] ",	"batbte_ce_dec2dec_lng;",	"cast decimal(bte) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:bte], digits:int, scale:int, r:bat[:bit]):bat[:lng] ",	"batbte_ce_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:bte]):bat[:lng] ",	"batbte_dec2_lng;",	"cast decimal(bte) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:bte], d2:int, s2:int):bat[:lng] ",	"batbte_dec2dec_lng;",	"cast decimal(bte) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:bte], digits:int, scale:int):bat[:lng] ",	"batbte_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:dbl], digits:int, scale:int, r:bat[:bit]):bat[:lng] ",	"batdbl_ce_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:dbl], digits:int, scale:int):bat[:lng] ",	"batdbl_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:flt], digits:int, scale:int, r:bat[:bit]):bat[:lng] ",	"batflt_ce_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:flt], digits:int, scale:int):bat[:lng] ",	"batflt_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:hge], r:bat[:bit]):bat[:lng] ",	"bathge_ce_dec2_lng;",	"cast decimal(hge) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:hge], d2:int, s2:int, r:bat[:bit]):bat[:lng] ",	"bathge_ce_dec2dec_lng;",	"cast decimal(hge) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:hge]):bat[:lng] ",	"bathge_dec2_lng;",	"cast decimal(hge) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:hge], d2:int, s2:int):bat[:lng] ",	"bathge_dec2dec_lng;",	"cast decimal(hge) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:hge], digits:int, scale:int):bat[:lng] ",	"bathge_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:hge], digits:int, scale:int):bat[:lng] ",	"bathge_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:int], r:bat[:bit]):bat[:lng] ",	"batint_ce_dec2_lng;",	"cast decimal(int) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:int], d2:int, s2:int, r:bat[:bit]):bat[:lng] ",	"batint_ce_dec2dec_lng;",	"cast decimal(int) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:int], digits:int, scale:int, r:bat[:bit]):bat[:lng] ",	"batint_ce_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:int]):bat[:lng] ",	"batint_dec2_lng;",	"cast decimal(int) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:int], d2:int, s2:int):bat[:lng] ",	"batint_dec2dec_lng;",	"cast decimal(int) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:int], digits:int, scale:int):bat[:lng] ",	"batint_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:lng], r:bat[:bit]):bat[:lng] ",	"batlng_ce_dec2_lng;",	"cast decimal(lng) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:lng], d2:int, s2:int, r:bat[:bit]):bat[:lng] ",	"batlng_ce_dec2dec_lng;",	"cast decimal(lng) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:lng], digits:int, scale:int, r:bat[:bit]):bat[:lng] ",	"batlng_ce_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:lng]):bat[:lng] ",	"batlng_dec2_lng;",	"cast decimal(lng) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:lng], d2:int, s2:int):bat[:lng] ",	"batlng_dec2dec_lng;",	"cast decimal(lng) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:lng], digits:int, scale:int):bat[:lng] ",	"batlng_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:oid], digits:int, scale:int):bat[:lng] ",	"batnil_2dec_lng;",	"cast to dec(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:oid], digits:int, scale:int, r:bat[:bit]):bat[:lng] ",	"batnil_ce_2dec_lng;",	"cast to dec(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:sht], r:bat[:bit]):bat[:lng] ",	"batsht_ce_dec2_lng;",	"cast decimal(sht) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:sht], d2:int, s2:int, r:bat[:bit]):bat[:lng] ",	"batsht_ce_dec2dec_lng;",	"cast decimal(sht) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:sht], digits:int, scale:int, r:bat[:bit]):bat[:lng] ",	"batsht_ce_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:sht]):bat[:lng] ",	"batsht_dec2_lng;",	"cast decimal(sht) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int, v:bat[:sht], d2:int, s2:int):bat[:lng] ",	"batsht_dec2dec_lng;",	"cast decimal(sht) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:sht], digits:int, scale:int):bat[:lng] ",	"batsht_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:str], digits:int, scale:int):bat[:lng] ",	"batstr_2dec_lng;",	"cast to dec(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:str], digits:int, scale:int, r:bat[:bit]):bat[:lng] ",	"batstr_ce_2dec_lng;",	"cast to dec(lng) and check for overflow"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bit to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bit], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bit to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bit], s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bit to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bit to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bte]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bte to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bte], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bte to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bte to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bte to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:dbl]):bat[:lng] ",	"CMDconvert_lng;",	"cast from dbl to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:dbl], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from dbl to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:dbl], s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from dbl to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from dbl to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:flt]):bat[:lng] ",	"CMDconvert_lng;",	"cast from flt to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:flt], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from flt to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:flt], s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from flt to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from flt to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:hge]):bat[:lng] ",	"CMDconvert_lng;",	"cast from hge to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:hge], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from hge to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from hge to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from hge to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:int]):bat[:lng] ",	"CMDconvert_lng;",	"cast from int to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:int], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from int to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from int to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from int to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:lng]):bat[:lng] ",	"CMDconvert_lng;",	"cast from lng to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from lng to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from lng to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from lng to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from oid to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from oid to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:oid], s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from oid to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from oid to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:sht]):bat[:lng] ",	"CMDconvert_lng;",	"cast from sht to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:sht], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from sht to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from sht to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from sht to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:str]):bat[:lng] ",	"CMDconvert_lng;",	"cast from str to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:str], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from str to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:str], s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from str to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from str to lng with candidates list"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:bte]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:hge]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:int]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:lng]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:sht]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:bte]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:hge]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:int]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:lng]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:sht]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:bte]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:hge]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:int]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:lng]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:sht]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:bte]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:hge]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:int]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:lng]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:sht]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:bte]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:hge]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:int]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:lng]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:sht]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:bte):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:hge):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:int):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:lng):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:sht):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:bte):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:bte, r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:hge):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:hge, r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:int):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:int, r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:lng):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:lng, r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:sht):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:sht, r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:bte):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:bte, r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:hge):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:hge, r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:int):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:int, r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:lng):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:lng, r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:sht):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:sht, r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:bte):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:bte, r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:hge):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:hge, r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:int):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:int, r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:lng):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:lng, r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:sht):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:sht, r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:bte):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:bte, r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:hge):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:hge, r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:int):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:int, r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:lng):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:lng, r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:sht):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:sht, r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:bte]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:hge]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:int]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:lng]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:sht]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:bte]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:bte], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:hge]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:int]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:int], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:lng]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:lng], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:sht]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:sht], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:bte]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:bte], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:hge]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:hge], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:int]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:lng]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:lng], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:sht]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:sht], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:bte]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:bte], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:hge]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:hge], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:int]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:int], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:lng]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:sht]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:sht], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:bte]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:bte], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:hge]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:hge], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:int]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:int], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:lng]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:lng], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:sht]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"max",	"pattern batcalc.max(b1:bat[:any_1], b2:bat[:any_1]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(b:bat[:any_1], v:any_1):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(b:bat[:any_1], v:any_1, r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(b:bat[:any_1], v:any_1, s:bat[:oid]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(v:any_1, b:bat[:any_1]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(v:any_1, b:bat[:any_1], r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(v:any_1, b:bat[:any_1], s:bat[:oid]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b1:bat[:any_1], b2:bat[:any_1]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b:bat[:any_1], v:any_1):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b:bat[:any_1], v:any_1, r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b:bat[:any_1], v:any_1, s:bat[:oid]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(v:any_1, b:bat[:any_1]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(v:any_1, b:bat[:any_1], r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(v:any_1, b:bat[:any_1], s:bat[:oid]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min",	"pattern batcalc.min(b1:bat[:any_1], b2:bat[:any_1]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(b:bat[:any_1], v:any_1):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(b:bat[:any_1], v:any_1, r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(b:bat[:any_1], v:any_1, s:bat[:oid]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(v:any_1, b:bat[:any_1]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(v:any_1, b:bat[:any_1], r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(v:any_1, b:bat[:any_1], s:bat[:oid]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b1:bat[:any_1], b2:bat[:any_1]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b1:bat[:any_1], b2:bat[:any_1], r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b1:bat[:any_1], b2:bat[:any_1], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b:bat[:any_1], v:any_1):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b:bat[:any_1], v:any_1, r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b:bat[:any_1], v:any_1, s:bat[:oid]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b:bat[:any_1], v:any_1, s:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(v:any_1, b:bat[:any_1]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(v:any_1, b:bat[:any_1], r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(v:any_1, b:bat[:any_1], s:bat[:oid]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(v:any_1, b:bat[:any_1], s:bat[:oid], r:bat[:bit]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bit]):bat[:bit] ",	"CMDbatNOT;",	"Return the Boolean inverse"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bit], r:bat[:bit]):bat[:bit] ",	"CMDbatNOT;",	"Return the Boolean inverse"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bit], s:bat[:oid]):bat[:bit] ",	"CMDbatNOT;",	"Return the Boolean inverse with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatNOT;",	"Return the Boolean inverse with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bte]):bat[:bte] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:hge]):bat[:hge] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:int]):bat[:int] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:lng]):bat[:lng] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:sht]):bat[:sht] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bit to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bit], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bit to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bit], s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bit to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bit to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bte]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bte to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bte], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bte to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bte], s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bte to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bte to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:dbl]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from dbl to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:dbl], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from dbl to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:dbl], s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from dbl to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from dbl to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:flt]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from flt to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:flt], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from flt to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:flt], s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from flt to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from flt to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:hge]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from hge to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:hge], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from hge to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:hge], s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from hge to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from hge to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:int]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from int to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:int], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from int to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:int], s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from int to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from int to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:lng]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from lng to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:lng], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from lng to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:lng], s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from lng to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from lng to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from oid to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from oid to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:oid], s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from oid to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from oid to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:sht]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from sht to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:sht], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from sht to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:sht], s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from sht to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from sht to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:str]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from str to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:str], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from str to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:str], s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from str to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from str to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bit to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bit], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bit to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bit], s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bit to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bit to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bte]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bte to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bte], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bte to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bte], s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bte to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bte to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:dbl]):bat[:oid] ",	"CMDconvert_oid;",	"cast from dbl to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:dbl], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from dbl to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:dbl], s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from dbl to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from dbl to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:flt]):bat[:oid] ",	"CMDconvert_oid;",	"cast from flt to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:flt], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from flt to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:flt], s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from flt to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from flt to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:hge]):bat[:oid] ",	"CMDconvert_oid;",	"cast from hge to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:hge], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from hge to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:hge], s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from hge to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from hge to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:int]):bat[:oid] ",	"CMDconvert_oid;",	"cast from int to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:int], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from int to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:int], s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from int to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from int to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:lng]):bat[:oid] ",	"CMDconvert_oid;",	"cast from lng to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:lng], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from lng to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:lng], s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from lng to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from lng to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from oid to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from oid to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:oid], s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from oid to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from oid to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:sht]):bat[:oid] ",	"CMDconvert_oid;",	"cast from sht to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:sht], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from sht to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:sht], s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from sht to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from sht to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:str]):bat[:oid] ",	"CMDconvert_oid;",	"cast from str to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:str], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from str to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:str], s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from str to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from str to oid with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bit], b2:bat[:bit]):bat[:bit] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bit], b2:bat[:bit], r:bat[:bit]):bat[:bit] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bit], b2:bat[:bit], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bit], b2:bat[:bit], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bte], b2:bat[:bte]):bat[:bte] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bte], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:hge], b2:bat[:hge]):bat[:hge] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:int], b2:bat[:int]):bat[:int] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:int], b2:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:lng], b2:bat[:lng]):bat[:lng] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:lng], b2:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:sht], b2:bat[:sht]):bat[:sht] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:sht], b2:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bit], v:bit):bat[:bit] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bit], v:bit, r:bat[:bit]):bat[:bit] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bit], v:bit, s:bat[:oid]):bat[:bit] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bit], v:bit, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bte], v:bte):bat[:bte] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bte], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:hge], v:hge):bat[:hge] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:hge], v:hge, r:bat[:bit]):bat[:hge] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:int], v:int):bat[:int] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:int], v:int, r:bat[:bit]):bat[:int] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:lng], v:lng):bat[:lng] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:lng], v:lng, r:bat[:bit]):bat[:lng] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:sht], v:sht):bat[:sht] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:sht], v:sht, r:bat[:bit]):bat[:sht] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bit, b:bat[:bit]):bat[:bit] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bit, b:bat[:bit], r:bat[:bit]):bat[:bit] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bit, b:bat[:bit], s:bat[:oid]):bat[:bit] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bit, b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bte, b:bat[:bte]):bat[:bte] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bte, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:hge, b:bat[:hge]):bat[:hge] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:hge, b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:int, b:bat[:int]):bat[:int] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:int, b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:lng, b:bat[:lng]):bat[:lng] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:lng, b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:sht, b:bat[:sht]):bat[:sht] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:sht, b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"rotate_xor_hash",	"command batcalc.rotate_xor_hash(h:bat[:lng], nbits:int, b:bat[:any_1]):bat[:int] ",	"MKEYbulk_rotate_xor_hash;",	""	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:bte]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:hge]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:int]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:lng]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:sht]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:bte]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:bte], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:hge]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:int]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:int], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:lng]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:lng], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:sht]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:sht], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:bte]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:bte], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:hge]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:hge], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:int]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:lng]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:lng], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:sht]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:sht], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:bte]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:bte], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:hge]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:hge], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:int]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:int], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:lng]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:sht]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:sht], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:bte]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:bte], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:hge]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:hge], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:int]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:int], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:lng]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:lng], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:sht]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:bte):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:hge):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:hge, r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:int):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:int, r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:lng):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:lng, r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:sht):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:sht, r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:bte):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:bte, r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:hge):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:hge, r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:int):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:int, r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:lng):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:lng, r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:sht):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:sht, r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:bte):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:bte, r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:hge):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:hge, r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:int):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:int, r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:lng):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:lng, r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:sht):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:sht, r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:bte):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:bte, r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:hge):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:hge, r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:int):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:int, r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:lng):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:lng, r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:sht):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:sht, r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:bte):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:bte, r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:hge):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:hge, r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:int):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:int, r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:lng):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:lng, r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:sht):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:sht, r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:bte]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:hge]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:int]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:lng]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:sht]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:bte]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:bte], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:hge]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:int]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:int], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:lng]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:lng], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:sht]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:sht], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:bte]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:bte], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:hge]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:hge], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:int]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:lng]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:lng], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:sht]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:sht], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:bte]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:bte], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:hge]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:hge], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:int]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:int], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:lng]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:sht]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:sht], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:bte]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:bte], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:hge]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:hge], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:int]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:int], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:lng]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:lng], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:sht]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bit to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bit], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bit to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bit], s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bit to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bit to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bte]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bte to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bte], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bte to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bte to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bte to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:dbl]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from dbl to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:dbl], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from dbl to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:dbl], s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from dbl to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from dbl to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:flt]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from flt to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:flt], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from flt to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:flt], s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from flt to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from flt to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:hge]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from hge to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:hge], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from hge to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from hge to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from hge to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:int]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from int to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:int], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from int to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from int to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from int to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:lng]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from lng to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:lng], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from lng to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from lng to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from lng to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from oid to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from oid to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:oid], s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from oid to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from oid to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:sht]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from sht to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from sht to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from sht to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from sht to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:str]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from str to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:str], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from str to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:str], s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from str to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from str to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:bte], r:bat[:bit]):bat[:sht] ",	"batbte_ce_dec2_sht;",	"cast decimal(bte) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:bte], d2:int, s2:int, r:bat[:bit]):bat[:sht] ",	"batbte_ce_dec2dec_sht;",	"cast decimal(bte) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:bte], digits:int, scale:int, r:bat[:bit]):bat[:sht] ",	"batbte_ce_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:bte]):bat[:sht] ",	"batbte_dec2_sht;",	"cast decimal(bte) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:bte], d2:int, s2:int):bat[:sht] ",	"batbte_dec2dec_sht;",	"cast decimal(bte) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:bte], digits:int, scale:int):bat[:sht] ",	"batbte_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:dbl], digits:int, scale:int, r:bat[:bit]):bat[:sht] ",	"batdbl_ce_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:dbl], digits:int, scale:int):bat[:sht] ",	"batdbl_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:flt], digits:int, scale:int, r:bat[:bit]):bat[:sht] ",	"batflt_ce_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:flt], digits:int, scale:int):bat[:sht] ",	"batflt_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:hge], r:bat[:bit]):bat[:sht] ",	"bathge_ce_dec2_sht;",	"cast decimal(hge) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:hge], d2:int, s2:int, r:bat[:bit]):bat[:sht] ",	"bathge_ce_dec2dec_sht;",	"cast decimal(hge) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:hge]):bat[:sht] ",	"bathge_dec2_sht;",	"cast decimal(hge) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:hge], d2:int, s2:int):bat[:sht] ",	"bathge_dec2dec_sht;",	"cast decimal(hge) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:hge], digits:int, scale:int):bat[:sht] ",	"bathge_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:hge], digits:int, scale:int):bat[:sht] ",	"bathge_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:int], r:bat[:bit]):bat[:sht] ",	"batint_ce_dec2_sht;",	"cast decimal(int) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:int], d2:int, s2:int, r:bat[:bit]):bat[:sht] ",	"batint_ce_dec2dec_sht;",	"cast decimal(int) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:int], digits:int, scale:int, r:bat[:bit]):bat[:sht] ",	"batint_ce_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:int]):bat[:sht] ",	"batint_dec2_sht;",	"cast decimal(int) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:int], d2:int, s2:int):bat[:sht] ",	"batint_dec2dec_sht;",	"cast decimal(int) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:int], digits:int, scale:int):bat[:sht] ",	"batint_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:lng], r:bat[:bit]):bat[:sht] ",	"batlng_ce_dec2_sht;",	"cast decimal(lng) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:lng], d2:int, s2:int, r:bat[:bit]):bat[:sht] ",	"batlng_ce_dec2dec_sht;",	"cast decimal(lng) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:lng], digits:int, scale:int, r:bat[:bit]):bat[:sht] ",	"batlng_ce_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:lng]):bat[:sht] ",	"batlng_dec2_sht;",	"cast decimal(lng) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:lng], d2:int, s2:int):bat[:sht] ",	"batlng_dec2dec_sht;",	"cast decimal(lng) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:lng], digits:int, scale:int):bat[:sht] ",	"batlng_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:oid], digits:int, scale:int):bat[:sht] ",	"batnil_2dec_sht;",	"cast to dec(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:oid], digits:int, scale:int, r:bat[:bit]):bat[:sht] ",	"batnil_ce_2dec_sht;",	"cast to dec(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:sht], r:bat[:bit]):bat[:sht] ",	"batsht_ce_dec2_sht;",	"cast decimal(sht) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:sht], d2:int, s2:int, r:bat[:bit]):bat[:sht] ",	"batsht_ce_dec2dec_sht;",	"cast decimal(sht) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:sht], digits:int, scale:int, r:bat[:bit]):bat[:sht] ",	"batsht_ce_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:sht]):bat[:sht] ",	"batsht_dec2_sht;",	"cast decimal(sht) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int, v:bat[:sht], d2:int, s2:int):bat[:sht] ",	"batsht_dec2dec_sht;",	"cast decimal(sht) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:sht], digits:int, scale:int):bat[:sht] ",	"batsht_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:str], digits:int, scale:int):bat[:sht] ",	"batstr_2dec_sht;",	"cast to dec(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:str], digits:int, scale:int, r:bat[:bit]):bat[:sht] ",	"batstr_ce_2dec_sht;",	"cast to dec(sht) and check for overflow"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bit to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bit], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bit to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bit], s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bit to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bit to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bte]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bte to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bte], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bte to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bte to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bte to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:dbl]):bat[:sht] ",	"CMDconvert_sht;",	"cast from dbl to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:dbl], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from dbl to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:dbl], s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from dbl to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from dbl to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:flt]):bat[:sht] ",	"CMDconvert_sht;",	"cast from flt to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:flt], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from flt to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:flt], s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from flt to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from flt to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:hge]):bat[:sht] ",	"CMDconvert_sht;",	"cast from hge to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:hge], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from hge to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:hge], s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from hge to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from hge to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:int]):bat[:sht] ",	"CMDconvert_sht;",	"cast from int to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:int], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from int to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:int], s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from int to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from int to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:lng]):bat[:sht] ",	"CMDconvert_sht;",	"cast from lng to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:lng], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from lng to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:lng], s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from lng to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from lng to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from oid to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from oid to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:oid], s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from oid to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:oid], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from oid to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:sht]):bat[:sht] ",	"CMDconvert_sht;",	"cast from sht to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from sht to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from sht to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from sht to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:str]):bat[:sht] ",	"CMDconvert_sht;",	"cast from str to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:str], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from str to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:str], s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from str to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:str], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from str to sht with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:bte]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:dbl]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:dbl], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:dbl], s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:flt]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:flt], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:flt], s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:hge]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:hge], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1,r:bat[:bit]) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:hge], s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1,r:bat[:bit]) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:int]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:int], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:int], s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:lng]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:lng], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:lng], s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:sht]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:sht], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:sht], s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"str",	"pattern batcalc.str(b:bat[:any]):bat[:str] ",	"CMDconvertsignal_str;",	"cast from any to str, signal error on overflow"	]
[ "batcalc",	"str",	"pattern batcalc.str(b:bat[:any], r:bat[:bit]):bat[:str] ",	"CMDconvertsignal_str;",	"cast from any to str, signal error on overflow"	]
[ "batcalc",	"str",	"pattern batcalc.str(b:bat[:any], s:bat[:oid]):bat[:str] ",	"CMDconvertsignal_str;",	"cast from any to str with candidates list, signal error on overflow"	]
[ "batcalc",	"str",	"pattern batcalc.str(b:bat[:any], s:bat[:oid], r:bat[:bit]):bat[:str] ",	"CMDconvertsignal_str;",	"cast from any to str with candidates list, signal error on overflow"	]
[ "batcalc",	"str",	"pattern batcalc.str(eclass:int, d1:int, s1:int, has_tz:int, v:bat[:any_1], digits:int):bat[:str] ",	"SQLbatstr_cast;",	"cast to string and check for overflow"	]
[ "batcalc",	"str",	"pattern batcalc.str(eclass:int, d1:int, s1:int, has_tz:int, v:bat[:any_1], digits:int, r:bat[:bit]):bat[:str] ",	"SQLbatstr_cast;",	"cast to string and check for overflow"	]
[ "batcalc",	"str_noerror",	"pattern batcalc.str_noerror(b:bat[:any]):bat[:str] ",	"CMDconvert_str;",	"cast from any to str"	]
[ "batcalc",	"str_noerror",	"pattern batcalc.str_noerror(b:bat[:any], r:bat[:bit]):bat[:str] ",	"CMDconvert_str;",	"cast from any to str"	]
[ "batcalc",	"str_noerror",	"pattern batcalc.str_noerror(b:bat[:any], s:bat[:oid]):bat[:str] ",	"CMDconvert_str;",	"cast from any to str with candidates list"	]
[ "batcalc",	"str_noerror",	"pattern batcalc.str_noerror(b:bat[:any], s:bat[:oid], r:bat[:bit]):bat[:str] ",	"CMDconvert_str;",	"cast from any to str with candidates list"	]
[ "batcalc",	"strings",	"command batcalc.strings(v:bat[:str]):bat[:str] ",	"BATSTRstrings;",	"Return the strings"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:dbl], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:flt], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:bte, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:bte, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:flt, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:flt, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:hge, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:hge, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:int, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:int, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:lng, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:lng, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:sht, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl], v:sht, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:bte, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:bte, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:hge, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:hge, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:int, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:int, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:lng, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:lng, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:sht, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt], v:sht, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:bte, s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:bte, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:int, s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:int, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:lng, s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:lng, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:sht, s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge], v:sht, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:bte, s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:bte, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:sht, s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int], v:sht, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:bte, s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:bte, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:int, s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:int, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:sht, s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng], v:sht, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:bte, s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:bte, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:bte], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:flt], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:hge], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:int], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:lng], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:sht], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:bte], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:hge], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:int], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:lng], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:sht], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:bte], s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:int], s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:lng], s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:sht], s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:bte], s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:sht], s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:bte], s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:int], s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:sht], s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:bte], s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(d:bat[:date]):bat[:timestamp] ",	"MTIMEtimestamp_fromdate_bulk;",	""	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(msecs:bat[:lng]):bat[:timestamp] ",	"MTIMEtimestamp_frommsec_bulk;",	""	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(secs:bat[:int]):bat[:timestamp] ",	"MTIMEtimestamp_fromsecond_bulk;",	""	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:oid], digits:int):bat[:timestamp] ",	"batnil_2time_timestamp;",	"cast to timestamp and check for overflow"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:oid], digits:int, r:bat[:BAT]):bat[:timestamp] ",	"batnil_ce_2time_timestamp;",	"cast to timestamp and check for overflow"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:str], digits:int):bat[:timestamp] ",	"batstr_2time_timestamp;",	"cast to timestamp and check for overflow"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:str], digits:int, has_tz:int):bat[:timestamp] ",	"batstr_2time_timestamptz;",	"cast to timestamp and check for overflow"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:timestamp], digits:int):bat[:timestamp] ",	"battimestamp_2time_timestamp;",	"cast timestamp to timestamp and check for overflow"	]
[ "batcalc",	"uuid",	"function batcalc.uuid(u:bat[:uuid]):bat[:uuid];",	"",	""	]
[ "batcalc",	"wkb",	"command batcalc.wkb(geo:bat[:wkb], columnType:int, columnSRID:int):bat[:wkb] ",	"geom_2_geom_bat;",	"Called when inserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition"	]
[ "batcalc",	"xml",	"command batcalc.xml(src:bat[:str]):bat[:xml] ",	"BATXMLstr2xml;",	""	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bit], b2:bat[:bit]):bat[:bit] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bit], b2:bat[:bit], r:bat[:bit]):bat[:bit] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bit], b2:bat[:bit], s1:bat[:oid], s2:bat[:oid]):bat[:bit] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bit], b2:bat[:bit], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bte], b2:bat[:bte]):bat[:bte] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bte], b2:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid]):bat[:bte] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bte], b2:bat[:bte], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:hge], b2:bat[:hge]):bat[:hge] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:hge], b2:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid]):bat[:hge] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:hge], b2:bat[:hge], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:int], b2:bat[:int]):bat[:int] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:int], b2:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid]):bat[:int] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:int], b2:bat[:int], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:lng], b2:bat[:lng]):bat[:lng] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:lng], b2:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid]):bat[:lng] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:lng], b2:bat[:lng], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:sht], b2:bat[:sht]):bat[:sht] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:sht], b2:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid]):bat[:sht] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:sht], b2:bat[:sht], s1:bat[:oid], s2:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bit], v:bit):bat[:bit] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bit], v:bit, r:bat[:bit]):bat[:bit] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bit], v:bit, s:bat[:oid]):bat[:bit] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bit], v:bit, s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bte], v:bte):bat[:bte] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bte], v:bte, r:bat[:bit]):bat[:bte] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bte], v:bte, s:bat[:oid]):bat[:bte] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bte], v:bte, s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:hge], v:hge):bat[:hge] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:hge], v:hge, r:bat[:bit]):bat[:hge] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:hge], v:hge, s:bat[:oid]):bat[:hge] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:hge], v:hge, s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:int], v:int):bat[:int] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:int], v:int, r:bat[:bit]):bat[:int] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:int], v:int, s:bat[:oid]):bat[:int] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:int], v:int, s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:lng], v:lng):bat[:lng] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:lng], v:lng, r:bat[:bit]):bat[:lng] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:lng], v:lng, s:bat[:oid]):bat[:lng] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:lng], v:lng, s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:sht], v:sht):bat[:sht] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:sht], v:sht, r:bat[:bit]):bat[:sht] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:sht], v:sht, s:bat[:oid]):bat[:sht] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:sht], v:sht, s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bit, b:bat[:bit]):bat[:bit] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bit, b:bat[:bit], r:bat[:bit]):bat[:bit] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bit, b:bat[:bit], s:bat[:oid]):bat[:bit] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bit, b:bat[:bit], s:bat[:oid], r:bat[:bit]):bat[:bit] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bte, b:bat[:bte]):bat[:bte] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bte, b:bat[:bte], r:bat[:bit]):bat[:bte] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bte, b:bat[:bte], s:bat[:oid]):bat[:bte] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bte, b:bat[:bte], s:bat[:oid], r:bat[:bit]):bat[:bte] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:hge, b:bat[:hge]):bat[:hge] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:hge, b:bat[:hge], r:bat[:bit]):bat[:hge] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:hge, b:bat[:hge], s:bat[:oid]):bat[:hge] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:hge, b:bat[:hge], s:bat[:oid], r:bat[:bit]):bat[:hge] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:int, b:bat[:int]):bat[:int] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:int, b:bat[:int], r:bat[:bit]):bat[:int] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:int, b:bat[:int], s:bat[:oid]):bat[:int] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:int, b:bat[:int], s:bat[:oid], r:bat[:bit]):bat[:int] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:lng, b:bat[:lng]):bat[:lng] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:lng, b:bat[:lng], r:bat[:bit]):bat[:lng] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:lng, b:bat[:lng], s:bat[:oid]):bat[:lng] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:lng, b:bat[:lng], s:bat[:oid], r:bat[:bit]):bat[:lng] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:sht, b:bat[:sht]):bat[:sht] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:sht, b:bat[:sht], r:bat[:bit]):bat[:sht] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:sht, b:bat[:sht], s:bat[:oid]):bat[:sht] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:sht, b:bat[:sht], s:bat[:oid], r:bat[:bit]):bat[:sht] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcapi",	"eval",	"pattern batcapi.eval(fptr:ptr, cpp:bit, expr:str, arg:any...):any... ",	"CUDFevalStd;",	"Execute a simple CUDF script value"	]
[ "batcapi",	"eval_aggr",	"pattern batcapi.eval_aggr(fptr:ptr, cpp:bit, expr:str, arg:any...):any... ",	"CUDFevalAggr;",	"grouped aggregates through CUDF"	]
[ "batcapi",	"subeval_aggr",	"pattern batcapi.subeval_aggr(fptr:ptr, cpp:bit, expr:str, arg:any...):any... ",	"CUDFevalAggr;",	"grouped aggregates through CUDF"	]
[ "batcolor",	"blue",	"command batcolor.blue(c:bat[:color]):bat[:int] ",	"CLRbatBlue;",	"Extracts blue component from a color atom"	]
[ "batcolor",	"cb",	"command batcolor.cb(c:bat[:color]):bat[:int] ",	"CLRbatCb;",	"Extracts Cb(blue color) component from a color atom"	]
[ "batcolor",	"color",	"command batcolor.color(s:bat[:str]):bat[:color] ",	"CLRbatColor;",	"Converts string to color"	]
[ "batcolor",	"cr",	"command batcolor.cr(c:bat[:color]):bat[:int] ",	"CLRbatCr;",	"Extracts Cr(red color) component from a color atom"	]
[ "batcolor",	"green",	"command batcolor.green(c:bat[:color]):bat[:int] ",	"CLRbatGreen;",	"Extracts green component from a color atom"	]
[ "batcolor",	"hsv",	"command batcolor.hsv(h:bat[:flt], s:bat[:flt], v:bat[:flt]):bat[:color] ",	"CLRbatHsv;",	"Converts an HSV triplets to a color atom"	]
[ "batcolor",	"hue",	"command batcolor.hue(c:bat[:color]):bat[:flt] ",	"CLRbatHue;",	"Extracts hue component from a color atom"	]
[ "batcolor",	"hue",	"command batcolor.hue(c:bat[:color]):bat[:int] ",	"CLRbatHueInt;",	"Extracts hue component from a color atom"	]
[ "batcolor",	"luminance",	"command batcolor.luminance(c:bat[:color]):bat[:int] ",	"CLRbatLuminance;",	"Extracts Y(luminance) component from a color atom"	]
[ "batcolor",	"red",	"command batcolor.red(c:bat[:color]):bat[:int] ",	"CLRbatRed;",	"Extracts red component from a color atom"	]
[ "batcolor",	"rgb",	"command batcolor.rgb(r:bat[:int], g:bat[:int], b:bat[:int]):bat[:color] ",	"CLRbatRgb;",	"Converts an RGB triplets to a color atom"	]
[ "batcolor",	"saturation",	"command batcolor.saturation(c:bat[:color]):bat[:flt] ",	"CLRbatSaturation;",	"Extracts saturation component from a color atom"	]
[ "batcolor",	"saturation",	"command batcolor.saturation(c:bat[:color]):bat[:int] ",	"CLRbatSaturationInt;",	"Extracts saturation component from a color atom"	]
[ "batcolor",	"str",	"command batcolor.str(b:bat[:color]):bat[:str] ",	"CLRbatStr;",	"Identity mapping for string bats"	]
[ "batcolor",	"value",	"command batcolor.value(c:bat[:color]):bat[:flt] ",	"CLRbatValue;",	"Extracts value component from a color atom"	]
[ "batcolor",	"value",	"command batcolor.value(c:bat[:color]):bat[:int] ",	"CLRbatValueInt;",	"Extracts value component from a color atom"	]
[ "batcolor",	"ycc",	"command batcolor.ycc(y:bat[:flt], cr:bat[:flt], cb:bat[:flt]):bat[:color] ",	"CLRbatycc;",	"Converts an YCC triplets to a color atom"	]
[ "batgeom",	"AsEWKT",	"function batgeom.AsEWKT(w:bat[:wkb]):bat[:str];",	"",	""	]
[ "batgeom",	"AsText",	"function batgeom.AsText(w:bat[:wkb]):bat[:str];",	"",	""	]
[ "batgeom",	"Boundary",	"command batgeom.Boundary(w:bat[:wkb]):bat[:wkb] ",	"wkbBoundary_bat;",	""	]
[ "batgeom",	"Contains",	"command batgeom.Contains(a:bat[:wkb], b:bat[:wkb]):bat[:bit] ",	"wkbContains_bat;",	""	]
[ "batgeom",	"Contains",	"command batgeom.Contains(a:bat[:wkb], b:wkb):bat[:bit] ",	"wkbContains_bat_geom;",	""	]
[ "batgeom",	"Contains",	"command batgeom.Contains(a:wkb, b:bat[:wkb]):bat[:bit] ",	"wkbContains_geom_bat;",	""	]
[ "batgeom",	"Dimension",	"command batgeom.Dimension(w:bat[:wkb]):bat[:int] ",	"wkbDimension_bat;",	""	]
[ "batgeom",	"Distance",	"command batgeom.Distance(a:bat[:wkb], b:bat[:wkb]):bat[:dbl] ",	"wkbDistance_bat;",	""	]
[ "batgeom",	"Distance",	"command batgeom.Distance(a:bat[:wkb], b:wkb):bat[:dbl] ",	"wkbDistance_bat_geom;",	""	]
[ "batgeom",	"Distance",	"command batgeom.Distance(a:wkb, b:bat[:wkb]):bat[:dbl] ",	"wkbDistance_geom_bat;",	""	]
[ "batgeom",	"Filter",	"command batgeom.Filter(a:bat[:wkb], b:wkb):bat[:wkb] ",	"wkbFilter_bat_geom;",	""	]
[ "batgeom",	"Filter",	"command batgeom.Filter(a:wkb, b:bat[:wkb]):bat[:wkb] ",	"wkbFilter_geom_bat;",	"Filters the points in the bats according to the MBR of the other bat."	]
[ "batgeom",	"FromText",	"command batgeom.FromText(wkt:bat[:str], srid:int, type:int):bat[:wkb] ",	"wkbFromText_bat;",	""	]
[ "batgeom",	"GeomCollFromText",	"function batgeom.GeomCollFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"GeomCollFromText",	"function batgeom.GeomCollFromText(wkt:bat[:str], srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"GeomFromText",	"function batgeom.GeomFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"GeomFromText",	"function batgeom.GeomFromText(wkt:bat[:str], srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"GeometryN",	"command batgeom.GeometryN(w:bat[:wkb], n:int):bat[:wkb] ",	"wkbGeometryN_bat;",	"Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON. Otherwise, return NULL"	]
[ "batgeom",	"GeometryType",	"command batgeom.GeometryType(w:bat[:wkb], flag:int):bat[:str] ",	"wkbGeometryType_bat;",	""	]
[ "batgeom",	"GeometryType1",	"function batgeom.GeometryType1(w:bat[:wkb]):bat[:str];",	"",	""	]
[ "batgeom",	"GeometryType2",	"function batgeom.GeometryType2(w:bat[:wkb]):bat[:str];",	"",	""	]
[ "batgeom",	"GetCoordinate",	"command batgeom.GetCoordinate(w:bat[:wkb], idx:int):bat[:dbl] ",	"wkbGetCoordinate_bat;",	"Returns the coordinate at position idx of a point, or NULL if not available. idx=0 -> X, idx=1 -> Y, idx=2 -> Z. Input must be point"	]
[ "batgeom",	"IsClosed",	"command batgeom.IsClosed(w:bat[:wkb]):bat[:bit] ",	"wkbIsClosed_bat;",	""	]
[ "batgeom",	"IsEmpty",	"command batgeom.IsEmpty(w:bat[:wkb]):bat[:bit] ",	"wkbIsEmpty_bat;",	""	]
[ "batgeom",	"IsRing",	"command batgeom.IsRing(w:bat[:wkb]):bat[:bit] ",	"wkbIsRing_bat;",	""	]
[ "batgeom",	"IsSimple",	"command batgeom.IsSimple(w:bat[:wkb]):bat[:bit] ",	"wkbIsSimple_bat;",	""	]
[ "batgeom",	"IsValid",	"command batgeom.IsValid(w:bat[:wkb]):bat[:bit] ",	"wkbIsValid_bat;",	""	]
[ "batgeom",	"LineFromText",	"function batgeom.LineFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"LineFromText",	"function batgeom.LineFromText(wkt:bat[:str], srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"MLineFromText",	"function batgeom.MLineFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MLineFromText",	"function batgeom.MLineFromText(wkt:bat[:str], srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"MPointFromText",	"function batgeom.MPointFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MPointFromText",	"function batgeom.MPointFromText(wkt:bat[:str], srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"MPolyFromText",	"function batgeom.MPolyFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MPolyFromText",	"function batgeom.MPolyFromText(wkt:bat[:str], srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"MakeBox2D",	"command batgeom.MakeBox2D(p1:bat[:wkb], p2:bat[:wkb]):bat[:mbr] ",	"wkbBox2D_bat;",	""	]
[ "batgeom",	"MakeLine",	"command batgeom.MakeLine(a:bat[:wkb], b:bat[:wkb]):bat[:wkb] ",	"wkbMakeLine_bat;",	"Gets two BATS of point or linestring geometries and returns a bat with linestring geometries"	]
[ "batgeom",	"MakePoint",	"function batgeom.MakePoint(x:bat[:dbl], y:bat[:dbl]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MakePoint",	"function batgeom.MakePoint(x:bat[:dbl], y:bat[:dbl], z:bat[:dbl]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MakePoint",	"function batgeom.MakePoint(x:bat[:dbl], y:bat[:dbl], z:bat[:dbl], m:bat[:dbl]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MakePointM",	"function batgeom.MakePointM(x:bat[:dbl], y:bat[:dbl], m:bat[:dbl]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MakePointXYZM",	"command batgeom.MakePointXYZM(x:bat[:dbl], y:bat[:dbl], z:bat[:dbl], m:bat[:dbl], zmFlag:int):bat[:wkb] ",	"wkbMakePoint_bat;",	"creates a point using the coordinates"	]
[ "batgeom",	"NPoints",	"function batgeom.NPoints(w:bat[:wkb]):bat[:int];",	"",	""	]
[ "batgeom",	"NRings",	"function batgeom.NRings(w:bat[:wkb]):bat[:int];",	"",	""	]
[ "batgeom",	"NumGeometries",	"command batgeom.NumGeometries(w:bat[:wkb]):bat[:int] ",	"wkbNumGeometries_bat;",	"Returns the number of geometries"	]
[ "batgeom",	"NumInteriorRings",	"function batgeom.NumInteriorRings(w:bat[:wkb]):bat[:int];",	"",	""	]
[ "batgeom",	"NumPoints",	"function batgeom.NumPoints(w:bat[:wkb]):bat[:int];",	"",	""	]
[ "batgeom",	"NumRings",	"command batgeom.NumRings(w:bat[:wkb], exterior:int):bat[:int] ",	"wkbNumRings_bat;",	"Returns the number of interior rings+exterior on the first polygon of the geometry"	]
[ "batgeom",	"PointFromText",	"function batgeom.PointFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"PointFromText",	"function batgeom.PointFromText(wkt:bat[:str], srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"PointsNum",	"command batgeom.PointsNum(w:bat[:wkb], check:int):bat[:int] ",	"wkbNumPoints_bat;",	"The number of points in the Geometry. If check=1, the geometry should be a linestring"	]
[ "batgeom",	"PolygonFromText",	"function batgeom.PolygonFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"PolygonFromText",	"function batgeom.PolygonFromText(wkt:bat[:str], srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"ToText",	"command batgeom.ToText(w:bat[:wkb], withSRID:int):bat[:str] ",	"wkbAsText_bat;",	""	]
[ "batgeom",	"Union",	"command batgeom.Union(a:bat[:wkb], b:bat[:wkb]):bat[:wkb] ",	"wkbUnion_bat;",	"Gets two BATS of geometries and returns the pairwise unions"	]
[ "batgeom",	"X",	"function batgeom.X(w:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"XMaxFromMBR",	"function batgeom.XMaxFromMBR(b:bat[:mbr]):bat[:dbl];",	"",	""	]
[ "batgeom",	"XMaxFromWKB",	"function batgeom.XMaxFromWKB(g:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"XMinFromMBR",	"function batgeom.XMinFromMBR(b:bat[:mbr]):bat[:dbl];",	"",	""	]
[ "batgeom",	"XMinFromWKB",	"function batgeom.XMinFromWKB(g:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"Y",	"function batgeom.Y(w:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"YMaxFromMBR",	"function batgeom.YMaxFromMBR(b:bat[:mbr]):bat[:dbl];",	"",	""	]
[ "batgeom",	"YMaxFromWKB",	"function batgeom.YMaxFromWKB(g:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"YMinFromMBR",	"function batgeom.YMinFromMBR(b:bat[:mbr]):bat[:dbl];",	"",	""	]
[ "batgeom",	"YMinFromWKB",	"function batgeom.YMinFromWKB(g:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"Z",	"function batgeom.Z(w:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"coordinateFromMBR",	"command batgeom.coordinateFromMBR(X_0:bat[:mbr], X_1:int):bat[:dbl] ",	"wkbCoordinateFromMBR_bat;",	"returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided mbr"	]
[ "batgeom",	"coordinateFromWKB",	"command batgeom.coordinateFromWKB(X_0:bat[:wkb], X_1:int):bat[:dbl] ",	"wkbCoordinateFromWKB_bat;",	"returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided geometry"	]
[ "batgeom",	"mbr",	"command batgeom.mbr(X_0:bat[:wkb]):bat[:mbr] ",	"wkbMBR_bat;",	"Creates the mbr for the given wkb."	]
[ "batgeom",	"setSRID",	"command batgeom.setSRID(w:bat[:wkb], srid:int):bat[:wkb] ",	"wkbSetSRID_bat;",	"Sets the Reference System ID for this Geometry."	]
[ "batmal",	"multiplex",	"pattern batmal.multiplex(mod:str, fcn:str, a:any...):any... ",	"MANIFOLDremapMultiplex;",	""	]
[ "batmkey",	"hash",	"command batmkey.hash(b:bat[:any_1]):bat[:lng] ",	"MKEYbathash;",	"calculate a hash value"	]
[ "batmmath",	"acos",	"pattern batmmath.acos(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_acos;",	""	]
[ "batmmath",	"acos",	"pattern batmmath.acos(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_acos;",	""	]
[ "batmmath",	"acos",	"pattern batmmath.acos(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_acos;",	""	]
[ "batmmath",	"acos",	"pattern batmmath.acos(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_acos;",	""	]
[ "batmmath",	"acos",	"pattern batmmath.acos(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_acos;",	""	]
[ "batmmath",	"acos",	"pattern batmmath.acos(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_acos;",	""	]
[ "batmmath",	"acos",	"pattern batmmath.acos(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_acos;",	""	]
[ "batmmath",	"acos",	"pattern batmmath.acos(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_acos;",	""	]
[ "batmmath",	"asin",	"pattern batmmath.asin(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_asin;",	""	]
[ "batmmath",	"asin",	"pattern batmmath.asin(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_asin;",	""	]
[ "batmmath",	"asin",	"pattern batmmath.asin(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_asin;",	""	]
[ "batmmath",	"asin",	"pattern batmmath.asin(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_asin;",	""	]
[ "batmmath",	"asin",	"pattern batmmath.asin(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_asin;",	""	]
[ "batmmath",	"asin",	"pattern batmmath.asin(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_asin;",	""	]
[ "batmmath",	"asin",	"pattern batmmath.asin(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_asin;",	""	]
[ "batmmath",	"asin",	"pattern batmmath.asin(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_asin;",	""	]
[ "batmmath",	"atan",	"pattern batmmath.atan(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_atan;",	""	]
[ "batmmath",	"atan",	"pattern batmmath.atan(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_atan;",	""	]
[ "batmmath",	"atan",	"pattern batmmath.atan(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_atan;",	""	]
[ "batmmath",	"atan",	"pattern batmmath.atan(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_atan;",	""	]
[ "batmmath",	"atan",	"pattern batmmath.atan(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_atan;",	""	]
[ "batmmath",	"atan",	"pattern batmmath.atan(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_atan;",	""	]
[ "batmmath",	"atan",	"pattern batmmath.atan(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_atan;",	""	]
[ "batmmath",	"atan",	"pattern batmmath.atan(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_atan;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:bat[:dbl], y:dbl):bat[:dbl] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:bat[:dbl], y:dbl, r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:bat[:dbl], y:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:bat[:dbl], y:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:bat[:flt], y:flt):bat[:flt] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:bat[:flt], y:flt, r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:bat[:flt], y:flt, s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:bat[:flt], y:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:dbl, y:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:dbl, y:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:dbl, y:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:dbl, y:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:flt, y:bat[:flt]):bat[:flt] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:flt, y:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:flt, y:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"atan2",	"pattern batmmath.atan2(x:flt, y:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_atan2;",	""	]
[ "batmmath",	"cbrt",	"pattern batmmath.cbrt(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_cbrt;",	""	]
[ "batmmath",	"cbrt",	"pattern batmmath.cbrt(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_cbrt;",	""	]
[ "batmmath",	"cbrt",	"pattern batmmath.cbrt(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_cbrt;",	""	]
[ "batmmath",	"cbrt",	"pattern batmmath.cbrt(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_cbrt;",	""	]
[ "batmmath",	"cbrt",	"pattern batmmath.cbrt(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_cbrt;",	""	]
[ "batmmath",	"cbrt",	"pattern batmmath.cbrt(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_cbrt;",	""	]
[ "batmmath",	"cbrt",	"pattern batmmath.cbrt(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_cbrt;",	""	]
[ "batmmath",	"cbrt",	"pattern batmmath.cbrt(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_cbrt;",	""	]
[ "batmmath",	"ceil",	"pattern batmmath.ceil(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_ceil;",	""	]
[ "batmmath",	"ceil",	"pattern batmmath.ceil(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_ceil;",	""	]
[ "batmmath",	"ceil",	"pattern batmmath.ceil(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_ceil;",	""	]
[ "batmmath",	"ceil",	"pattern batmmath.ceil(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_ceil;",	""	]
[ "batmmath",	"ceil",	"pattern batmmath.ceil(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_ceil;",	""	]
[ "batmmath",	"ceil",	"pattern batmmath.ceil(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_ceil;",	""	]
[ "batmmath",	"ceil",	"pattern batmmath.ceil(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_ceil;",	""	]
[ "batmmath",	"ceil",	"pattern batmmath.ceil(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_ceil;",	""	]
[ "batmmath",	"cos",	"pattern batmmath.cos(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_cos;",	""	]
[ "batmmath",	"cos",	"pattern batmmath.cos(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_cos;",	""	]
[ "batmmath",	"cos",	"pattern batmmath.cos(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_cos;",	""	]
[ "batmmath",	"cos",	"pattern batmmath.cos(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_cos;",	""	]
[ "batmmath",	"cos",	"pattern batmmath.cos(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_cos;",	""	]
[ "batmmath",	"cos",	"pattern batmmath.cos(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_cos;",	""	]
[ "batmmath",	"cos",	"pattern batmmath.cos(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_cos;",	""	]
[ "batmmath",	"cos",	"pattern batmmath.cos(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_cos;",	""	]
[ "batmmath",	"cosh",	"pattern batmmath.cosh(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_cosh;",	""	]
[ "batmmath",	"cosh",	"pattern batmmath.cosh(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_cosh;",	""	]
[ "batmmath",	"cosh",	"pattern batmmath.cosh(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_cosh;",	""	]
[ "batmmath",	"cosh",	"pattern batmmath.cosh(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_cosh;",	""	]
[ "batmmath",	"cosh",	"pattern batmmath.cosh(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_cosh;",	""	]
[ "batmmath",	"cosh",	"pattern batmmath.cosh(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_cosh;",	""	]
[ "batmmath",	"cosh",	"pattern batmmath.cosh(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_cosh;",	""	]
[ "batmmath",	"cosh",	"pattern batmmath.cosh(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_cosh;",	""	]
[ "batmmath",	"degrees",	"pattern batmmath.degrees(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_degrees;",	""	]
[ "batmmath",	"degrees",	"pattern batmmath.degrees(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_degrees;",	""	]
[ "batmmath",	"degrees",	"pattern batmmath.degrees(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_degrees;",	""	]
[ "batmmath",	"degrees",	"pattern batmmath.degrees(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_degrees;",	""	]
[ "batmmath",	"degrees",	"pattern batmmath.degrees(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_degrees;",	""	]
[ "batmmath",	"degrees",	"pattern batmmath.degrees(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_degrees;",	""	]
[ "batmmath",	"degrees",	"pattern batmmath.degrees(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_degrees;",	""	]
[ "batmmath",	"degrees",	"pattern batmmath.degrees(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_degrees;",	""	]
[ "batmmath",	"exp",	"pattern batmmath.exp(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_exp;",	""	]
[ "batmmath",	"exp",	"pattern batmmath.exp(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_exp;",	""	]
[ "batmmath",	"exp",	"pattern batmmath.exp(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_exp;",	""	]
[ "batmmath",	"exp",	"pattern batmmath.exp(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_exp;",	""	]
[ "batmmath",	"exp",	"pattern batmmath.exp(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_exp;",	""	]
[ "batmmath",	"exp",	"pattern batmmath.exp(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_exp;",	""	]
[ "batmmath",	"exp",	"pattern batmmath.exp(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_exp;",	""	]
[ "batmmath",	"exp",	"pattern batmmath.exp(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_exp;",	""	]
[ "batmmath",	"fabs",	"pattern batmmath.fabs(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_fabs;",	""	]
[ "batmmath",	"fabs",	"pattern batmmath.fabs(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_fabs;",	""	]
[ "batmmath",	"fabs",	"pattern batmmath.fabs(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_fabs;",	""	]
[ "batmmath",	"fabs",	"pattern batmmath.fabs(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_fabs;",	""	]
[ "batmmath",	"fabs",	"pattern batmmath.fabs(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_fabs;",	""	]
[ "batmmath",	"fabs",	"pattern batmmath.fabs(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_fabs;",	""	]
[ "batmmath",	"fabs",	"pattern batmmath.fabs(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_fabs;",	""	]
[ "batmmath",	"fabs",	"pattern batmmath.fabs(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_fabs;",	""	]
[ "batmmath",	"floor",	"pattern batmmath.floor(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_floor;",	""	]
[ "batmmath",	"floor",	"pattern batmmath.floor(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_floor;",	""	]
[ "batmmath",	"floor",	"pattern batmmath.floor(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_floor;",	""	]
[ "batmmath",	"floor",	"pattern batmmath.floor(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_floor;",	""	]
[ "batmmath",	"floor",	"pattern batmmath.floor(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_floor;",	""	]
[ "batmmath",	"floor",	"pattern batmmath.floor(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_floor;",	""	]
[ "batmmath",	"floor",	"pattern batmmath.floor(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_floor;",	""	]
[ "batmmath",	"floor",	"pattern batmmath.floor(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_floor;",	""	]
[ "batmmath",	"fmod",	"pattern batmmath.fmod(x:bat[:dbl], y:dbl):bat[:dbl] ",	"CMDbatMODsignal;",	""	]
[ "batmmath",	"fmod",	"pattern batmmath.fmod(x:bat[:dbl], y:dbl, r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	""	]
[ "batmmath",	"fmod",	"pattern batmmath.fmod(x:bat[:dbl], y:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	""	]
[ "batmmath",	"fmod",	"pattern batmmath.fmod(x:bat[:dbl], y:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDbatMODsignal;",	""	]
[ "batmmath",	"fmod",	"pattern batmmath.fmod(x:bat[:flt], y:flt):bat[:flt] ",	"CMDbatMODsignal;",	""	]
[ "batmmath",	"fmod",	"pattern batmmath.fmod(x:bat[:flt], y:flt, r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	""	]
[ "batmmath",	"fmod",	"pattern batmmath.fmod(x:bat[:flt], y:flt, s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	""	]
[ "batmmath",	"fmod",	"pattern batmmath.fmod(x:bat[:flt], y:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDbatMODsignal;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_log;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_log;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_log;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_log;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_log;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_log;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_log;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_log;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:dbl], y:dbl):bat[:dbl] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:dbl], y:dbl, r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:dbl], y:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:dbl], y:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:flt], y:flt):bat[:flt] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:flt], y:flt, r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:flt], y:flt, s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:bat[:flt], y:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:dbl, y:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:dbl, y:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:dbl, y:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:dbl, y:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:flt, y:bat[:flt]):bat[:flt] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:flt, y:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:flt, y:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log",	"pattern batmmath.log(x:flt, y:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_logbs;",	""	]
[ "batmmath",	"log10",	"pattern batmmath.log10(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_log10;",	""	]
[ "batmmath",	"log10",	"pattern batmmath.log10(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_log10;",	""	]
[ "batmmath",	"log10",	"pattern batmmath.log10(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_log10;",	""	]
[ "batmmath",	"log10",	"pattern batmmath.log10(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_log10;",	""	]
[ "batmmath",	"log10",	"pattern batmmath.log10(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_log10;",	""	]
[ "batmmath",	"log10",	"pattern batmmath.log10(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_log10;",	""	]
[ "batmmath",	"log10",	"pattern batmmath.log10(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_log10;",	""	]
[ "batmmath",	"log10",	"pattern batmmath.log10(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_log10;",	""	]
[ "batmmath",	"log2",	"pattern batmmath.log2(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_log2;",	""	]
[ "batmmath",	"log2",	"pattern batmmath.log2(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_log2;",	""	]
[ "batmmath",	"log2",	"pattern batmmath.log2(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_log2;",	""	]
[ "batmmath",	"log2",	"pattern batmmath.log2(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_log2;",	""	]
[ "batmmath",	"log2",	"pattern batmmath.log2(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_log2;",	""	]
[ "batmmath",	"log2",	"pattern batmmath.log2(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_log2;",	""	]
[ "batmmath",	"log2",	"pattern batmmath.log2(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_log2;",	""	]
[ "batmmath",	"log2",	"pattern batmmath.log2(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_log2;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:bat[:dbl], y:dbl):bat[:dbl] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:bat[:dbl], y:dbl, r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:bat[:dbl], y:dbl, s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:bat[:dbl], y:dbl, s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:bat[:flt], y:flt):bat[:flt] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:bat[:flt], y:flt, r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:bat[:flt], y:flt, s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:bat[:flt], y:flt, s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:dbl, y:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:dbl, y:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:dbl, y:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:dbl, y:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:flt, y:bat[:flt]):bat[:flt] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:flt, y:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:flt, y:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"pow",	"pattern batmmath.pow(x:flt, y:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_pow;",	""	]
[ "batmmath",	"radians",	"pattern batmmath.radians(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_radians;",	""	]
[ "batmmath",	"radians",	"pattern batmmath.radians(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_radians;",	""	]
[ "batmmath",	"radians",	"pattern batmmath.radians(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_radians;",	""	]
[ "batmmath",	"radians",	"pattern batmmath.radians(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_radians;",	""	]
[ "batmmath",	"radians",	"pattern batmmath.radians(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_radians;",	""	]
[ "batmmath",	"radians",	"pattern batmmath.radians(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_radians;",	""	]
[ "batmmath",	"radians",	"pattern batmmath.radians(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_radians;",	""	]
[ "batmmath",	"radians",	"pattern batmmath.radians(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_radians;",	""	]
[ "batmmath",	"sin",	"pattern batmmath.sin(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_sin;",	""	]
[ "batmmath",	"sin",	"pattern batmmath.sin(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_sin;",	""	]
[ "batmmath",	"sin",	"pattern batmmath.sin(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_sin;",	""	]
[ "batmmath",	"sin",	"pattern batmmath.sin(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_sin;",	""	]
[ "batmmath",	"sin",	"pattern batmmath.sin(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_sin;",	""	]
[ "batmmath",	"sin",	"pattern batmmath.sin(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_sin;",	""	]
[ "batmmath",	"sin",	"pattern batmmath.sin(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_sin;",	""	]
[ "batmmath",	"sin",	"pattern batmmath.sin(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_sin;",	""	]
[ "batmmath",	"sinh",	"pattern batmmath.sinh(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_sinh;",	""	]
[ "batmmath",	"sinh",	"pattern batmmath.sinh(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_sinh;",	""	]
[ "batmmath",	"sinh",	"pattern batmmath.sinh(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_sinh;",	""	]
[ "batmmath",	"sinh",	"pattern batmmath.sinh(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_sinh;",	""	]
[ "batmmath",	"sinh",	"pattern batmmath.sinh(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_sinh;",	""	]
[ "batmmath",	"sinh",	"pattern batmmath.sinh(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_sinh;",	""	]
[ "batmmath",	"sinh",	"pattern batmmath.sinh(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_sinh;",	""	]
[ "batmmath",	"sinh",	"pattern batmmath.sinh(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_sinh;",	""	]
[ "batmmath",	"sqrt",	"pattern batmmath.sqrt(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_sqrt;",	""	]
[ "batmmath",	"sqrt",	"pattern batmmath.sqrt(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_sqrt;",	""	]
[ "batmmath",	"sqrt",	"pattern batmmath.sqrt(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_sqrt;",	""	]
[ "batmmath",	"sqrt",	"pattern batmmath.sqrt(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_sqrt;",	""	]
[ "batmmath",	"sqrt",	"pattern batmmath.sqrt(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_sqrt;",	""	]
[ "batmmath",	"sqrt",	"pattern batmmath.sqrt(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_sqrt;",	""	]
[ "batmmath",	"sqrt",	"pattern batmmath.sqrt(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_sqrt;",	""	]
[ "batmmath",	"sqrt",	"pattern batmmath.sqrt(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_sqrt;",	""	]
[ "batmmath",	"tan",	"pattern batmmath.tan(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_tan;",	""	]
[ "batmmath",	"tan",	"pattern batmmath.tan(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_tan;",	""	]
[ "batmmath",	"tan",	"pattern batmmath.tan(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_tan;",	""	]
[ "batmmath",	"tan",	"pattern batmmath.tan(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_tan;",	""	]
[ "batmmath",	"tan",	"pattern batmmath.tan(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_tan;",	""	]
[ "batmmath",	"tan",	"pattern batmmath.tan(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_tan;",	""	]
[ "batmmath",	"tan",	"pattern batmmath.tan(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_tan;",	""	]
[ "batmmath",	"tan",	"pattern batmmath.tan(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_tan;",	""	]
[ "batmmath",	"tanh",	"pattern batmmath.tanh(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_tanh;",	""	]
[ "batmmath",	"tanh",	"pattern batmmath.tanh(x:bat[:dbl], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_tanh;",	""	]
[ "batmmath",	"tanh",	"pattern batmmath.tanh(x:bat[:dbl], s:bat[:oid]):bat[:dbl] ",	"CMDscience_bat_tanh;",	""	]
[ "batmmath",	"tanh",	"pattern batmmath.tanh(x:bat[:dbl], s:bat[:oid], r:bat[:bit]):bat[:dbl] ",	"CMDscience_bat_tanh;",	""	]
[ "batmmath",	"tanh",	"pattern batmmath.tanh(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_tanh;",	""	]
[ "batmmath",	"tanh",	"pattern batmmath.tanh(x:bat[:flt], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_tanh;",	""	]
[ "batmmath",	"tanh",	"pattern batmmath.tanh(x:bat[:flt], s:bat[:oid]):bat[:flt] ",	"CMDscience_bat_tanh;",	""	]
[ "batmmath",	"tanh",	"pattern batmmath.tanh(x:bat[:flt], s:bat[:oid], r:bat[:bit]):bat[:flt] ",	"CMDscience_bat_tanh;",	""	]
[ "batmtime",	"century",	"command batmtime.century(d:bat[:date]):bat[:int] ",	"MTIMEdate_extract_century_bulk;",	""	]
[ "batmtime",	"day",	"command batmtime.day(d:bat[:date]):bat[:int] ",	"MTIMEdate_extract_day_bulk;",	""	]
[ "batmtime",	"decade",	"command batmtime.decade(d:bat[:date]):bat[:int] ",	"MTIMEdate_extract_decade_bulk;",	""	]
[ "batmtime",	"diff",	"command batmtime.diff(b1:bat[:date], b2:bat[:date]):bat[:int] ",	"MTIMEdate_diff_bulk;",	"Difference of two sets of date."	]
[ "batmtime",	"diff",	"command batmtime.diff(b1:bat[:timestamp], b2:bat[:timestamp]):bat[:lng] ",	"MTIMEtimestamp_diff_msec_bulk;",	"Difference of two sets of timestamp."	]
[ "batmtime",	"hours",	"command batmtime.hours(d:bat[:daytime]):bat[:int] ",	"MTIMEdaytime_extract_hours_bulk;",	""	]
[ "batmtime",	"minutes",	"command batmtime.minutes(d:bat[:daytime]):bat[:int] ",	"MTIMEdaytime_extract_minutes_bulk;",	""	]
[ "batmtime",	"month",	"command batmtime.month(d:bat[:date]):bat[:int] ",	"MTIMEdate_extract_month_bulk;",	""	]
[ "batmtime",	"quarter",	"command batmtime.quarter(d:bat[:date]):bat[:int] ",	"MTIMEdate_extract_quarter_bulk;",	""	]
[ "batmtime",	"sql_seconds",	"command batmtime.sql_seconds(d:bat[:daytime]):bat[:int] ",	"MTIMEdaytime_extract_sql_seconds_bulk;",	""	]
[ "batmtime",	"sql_seconds",	"command batmtime.sql_seconds(d:bat[:timestamp]):bat[:int] ",	"MTIMEtimestamp_sql_seconds_bulk;",	""	]
[ "batmtime",	"timestamp_add_msec_interval",	"command batmtime.timestamp_add_msec_interval(t:bat[:timestamp], ms:bat[:lng]):bat[:timestamp] ",	"MTIMEtimestamp_add_msec_interval_bulk;",	""	]
[ "batmtime",	"timestamp_sub_msec_interval",	"command batmtime.timestamp_sub_msec_interval(t:bat[:timestamp], ms:bat[:lng]):bat[:timestamp] ",	"MTIMEtimestamp_sub_msec_interval_bulk;",	""	]
[ "batmtime",	"year",	"command batmtime.year(d:bat[:date]):bat[:int] ",	"MTIMEdate_extract_year_bulk;",	""	]
[ "batpcre",	"replace",	"command batpcre.replace(orig:bat[:str], pat:str, repl:str, flag:str):bat[:str] ",	"PCREreplace_bat_wrap;",	""	]
[ "batpcre",	"replace_first",	"command batpcre.replace_first(orig:bat[:str], pat:str, repl:str, flag:str):bat[:str] ",	"PCREreplacefirst_bat_wrap;",	""	]
[ "batpyapi3",	"eval",	"unsafe pattern batpyapi3.eval(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalStd;",	"Execute a simple Python script value"	]
[ "batpyapi3",	"eval_aggr",	"unsafe pattern batpyapi3.eval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalAggr;",	"grouped aggregates through Python"	]
[ "batpyapi3",	"eval_loader",	"unsafe pattern batpyapi3.eval_loader(fptr:ptr, expr:str):any... ",	"PYAPI3PyAPIevalLoader;",	"loader functions through Python"	]
[ "batpyapi3",	"eval_loader",	"unsafe pattern batpyapi3.eval_loader(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalLoader;",	"loader functions through Python"	]
[ "batpyapi3",	"subeval_aggr",	"unsafe pattern batpyapi3.subeval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalAggr;",	"grouped aggregates through Python"	]
[ "batpyapi3map",	"eval",	"pattern batpyapi3map.eval(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalStdMap;",	"Execute a simple Python script value"	]
[ "batpyapi3map",	"eval_aggr",	"pattern batpyapi3map.eval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalAggrMap;",	"grouped aggregates through Python"	]
[ "batpyapi3map",	"subeval_aggr",	"pattern batpyapi3map.subeval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalAggrMap;",	"grouped aggregates through Python"	]
[ "batrapi",	"eval",	"pattern batrapi.eval(fptr:ptr, expr:str, arg:any...):any... ",	"RAPIevalStd;",	"Execute a simple R script value"	]
[ "batrapi",	"eval_aggr",	"pattern batrapi.eval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"RAPIevalAggr;",	"grouped aggregates through R"	]
[ "batrapi",	"subeval_aggr",	"pattern batrapi.subeval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"RAPIevalAggr;",	"grouped aggregates through R"	]
[ "batsql",	"alpha",	"command batsql.alpha(dec:bat[:dbl], theta:dbl):bat[:dbl] ",	"SQLbat_alpha_cst;",	"BAT implementation of astronomy alpha function"	]
[ "batsql",	"alpha",	"command batsql.alpha(dec:dbl, theta:bat[:dbl]):bat[:dbl] ",	"SQLcst_alpha_bat;",	"BAT implementation of astronomy alpha function"	]
[ "batsql",	"avg",	"pattern batsql.avg(b:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLavg;",	"return the average of groups"	]
[ "batsql",	"avg",	"pattern batsql.avg(b:bat[:dbl], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLavg;",	"return the average of groups"	]
[ "batsql",	"avg",	"pattern batsql.avg(b:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLavg;",	"return the average of groups"	]
[ "batsql",	"avg",	"pattern batsql.avg(b:bat[:hge], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLavg;",	"return the average of groups"	]
[ "batsql",	"avg",	"pattern batsql.avg(b:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLavg;",	"return the average of groups"	]
[ "batsql",	"avg",	"pattern batsql.avg(b:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLavg;",	"return the average of groups"	]
[ "batsql",	"avg",	"pattern batsql.avg(b:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLavg;",	"return the average of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:bte], c:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:bte], c:bte, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:dbl], c:bat[:dbl], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:dbl], c:dbl, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:flt], c:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:flt], c:flt, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:hge], c:bat[:hge], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:hge], c:hge, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:int], c:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:int], c:int, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:lng], c:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:lng], c:lng, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:sht], c:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bat[:sht], c:sht, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:bte, c:bat[:bte], s:lng, e:lng):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:dbl, c:bat[:dbl], s:lng, e:lng):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:flt, c:bat[:flt], s:lng, e:lng):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:hge, c:bat[:hge], s:lng, e:lng):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:int, c:bat[:int], s:lng, e:lng):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:lng, c:bat[:lng], s:lng, e:lng):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"corr",	"pattern batsql.corr(b:sht, c:bat[:sht], s:lng, e:lng):bat[:dbl] ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "batsql",	"count",	"pattern batsql.count(b:bat[:any_1], ignils:bit, s:bat[:lng], e:bat[:lng]):bat[:lng] ",	"SQLcount;",	"return count of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:bte], c:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:bte], c:bte, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:dbl], c:bat[:dbl], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:dbl], c:dbl, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:flt], c:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:flt], c:flt, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:hge], c:bat[:hge], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:hge], c:hge, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:int], c:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:int], c:int, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:lng], c:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:lng], c:lng, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:sht], c:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bat[:sht], c:sht, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:bte, c:bat[:bte], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:dbl, c:bat[:dbl], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:flt, c:bat[:flt], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:hge, c:bat[:hge], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:int, c:bat[:int], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:lng, c:bat[:lng], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariance",	"pattern batsql.covariance(b:sht, c:bat[:sht], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:bte], c:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:bte], c:bte, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:dbl], c:bat[:dbl], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:dbl], c:dbl, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:flt], c:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:flt], c:flt, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:hge], c:bat[:hge], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:hge], c:hge, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:int], c:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:int], c:int, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:lng], c:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:lng], c:lng, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:sht], c:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bat[:sht], c:sht, s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:bte, c:bat[:bte], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:dbl, c:bat[:dbl], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:flt, c:bat[:flt], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:hge, c:bat[:hge], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:int, c:bat[:int], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:lng, c:bat[:lng], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"covariancep",	"pattern batsql.covariancep(b:sht, c:bat[:sht], s:lng, e:lng):bat[:dbl] ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "batsql",	"cume_dist",	"pattern batsql.cume_dist(b:bat[:any_1], p:any_2, o:any_3):bat[:dbl] ",	"SQLcume_dist;",	"return the accumulated distribution of the number of rows per group to the total number of partition rows"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:bte], r:bte):bat[:bte] ",	"bte_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:dbl], r:dbl):bat[:dbl] ",	"dbl_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:flt], r:flt):bat[:flt] ",	"flt_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:hge], r:hge):bat[:hge] ",	"hge_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:int], r:int):bat[:int] ",	"int_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:lng], r:lng):bat[:lng] ",	"lng_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:sht], r:sht):bat[:sht] ",	"sht_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dense_rank",	"pattern batsql.dense_rank(b:bat[:any_1], p:any_2, o:any_3):bat[:int] ",	"SQLdense_rank;",	"return the densely ranked groups"	]
[ "batsql",	"diff",	"pattern batsql.diff(b:bat[:any_1]):bat[:bit] ",	"SQLdiff;",	"return true if cur != prev row"	]
[ "batsql",	"diff",	"pattern batsql.diff(p:bat[:bit], b:any_1):bat[:bit] ",	"SQLdiff;",	"return true if cur != prev row"	]
[ "batsql",	"diff",	"pattern batsql.diff(p:bat[:bit], b:bat[:any_1]):bat[:bit] ",	"SQLdiff;",	"return true if cur != prev row"	]
[ "batsql",	"diff",	"pattern batsql.diff(p:bit, b:bat[:any_1]):bat[:bit] ",	"SQLdiff;",	"return true if cur != prev row"	]
[ "batsql",	"first_value",	"pattern batsql.first_value(b:bat[:any_1], s:bat[:lng], e:bat[:lng]):bat[:any_1] ",	"SQLfirst_value;",	"return the first value of groups"	]
[ "batsql",	"get_value",	"pattern batsql.get_value(sname:bat[:str], sequence:bat[:str]):bat[:lng] ",	"mvc_bat_get_value;",	"return the current value of sequences"	]
[ "batsql",	"get_value",	"pattern batsql.get_value(sname:bat[:str], sequence:str):bat[:lng] ",	"mvc_bat_get_value;",	"return the current value of the sequence"	]
[ "batsql",	"get_value",	"pattern batsql.get_value(sname:str, sequence:bat[:str]):bat[:lng] ",	"mvc_bat_get_value;",	"return the current value of sequences"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:any_1, l:any_2, d:bat[:any_1], p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:any_1, l:bat[:any_2], d:any_1, p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:any_1, l:bat[:any_2], d:bat[:any_1], p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:any_1, l:bat[:any_2], p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or NULL if non existent"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:bat[:any_1], l:any_2, d:any_1, p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:bat[:any_1], l:any_2, d:bat[:any_1], p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:bat[:any_1], l:any_2, p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or NULL if non existent"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:bat[:any_1], l:bat[:any_2], d:any_1, p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:bat[:any_1], l:bat[:any_2], d:bat[:any_1], p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:bat[:any_1], l:bat[:any_2], p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or NULL if non existent"	]
[ "batsql",	"lag",	"pattern batsql.lag(b:bat[:any_1], p:any_3, o:any_4):bat[:any_1] ",	"SQLlag;",	"return the value in the previous row in the partition or NULL if non existent"	]
[ "batsql",	"last_value",	"pattern batsql.last_value(b:bat[:any_1], s:bat[:lng], e:bat[:lng]):bat[:any_1] ",	"SQLlast_value;",	"return the last value of groups"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:any_1, l:any_2, d:bat[:any_1], p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:any_1, l:bat[:any_2], d:any_1, p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:any_1, l:bat[:any_2], d:bat[:any_1], p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:any_1, l:bat[:any_2], p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next 'l' row in the partition or NULL if non existent"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:bat[:any_1], l:any_2, d:any_1, p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:bat[:any_1], l:any_2, d:bat[:any_1], p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:bat[:any_1], l:any_2, p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next 'l' row in the partition or NULL if non existent"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:bat[:any_1], l:bat[:any_2], d:any_1, p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:bat[:any_1], l:bat[:any_2], d:bat[:any_1], p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next 'l' row in the partition or 'd' if non existent"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:bat[:any_1], l:bat[:any_2], p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next 'l' row in the partition or NULL if non existent"	]
[ "batsql",	"lead",	"pattern batsql.lead(b:bat[:any_1], p:any_3, o:any_4):bat[:any_1] ",	"SQLlead;",	"return the value in the next row in the partition or NULL if non existent"	]
[ "batsql",	"max",	"pattern batsql.max(b:bat[:any_1], s:bat[:lng], e:bat[:lng]):bat[:any_1] ",	"SQLmax;",	"return the maximum of groups"	]
[ "batsql",	"min",	"pattern batsql.min(b:bat[:any_1], s:bat[:lng], e:bat[:lng]):bat[:any_1] ",	"SQLmin;",	"return the minimum of groups"	]
[ "batsql",	"next_value",	"unsafe pattern batsql.next_value(sname:bat[:str], sequence:bat[:str]):bat[:lng] ",	"mvc_bat_next_value;",	"return the next value of sequences"	]
[ "batsql",	"next_value",	"unsafe pattern batsql.next_value(sname:bat[:str], sequence:str):bat[:lng] ",	"mvc_bat_next_value;",	"return the next value of the sequence"	]
[ "batsql",	"next_value",	"unsafe pattern batsql.next_value(sname:str, sequence:bat[:str]):bat[:lng] ",	"mvc_bat_next_value;",	"return the next value of sequences"	]
[ "batsql",	"nth_value",	"pattern batsql.nth_value(b:any_1, n:bat[:any_2], s:lng, e:lng):bat[:any_1] ",	"SQLnth_value;",	"return the nth value of each group"	]
[ "batsql",	"nth_value",	"pattern batsql.nth_value(b:bat[:any_1], n:any_2, s:bat[:lng], e:bat[:lng]):bat[:any_1] ",	"SQLnth_value;",	"return the nth value of each group"	]
[ "batsql",	"nth_value",	"pattern batsql.nth_value(b:bat[:any_1], n:bat[:any_2], s:bat[:lng], e:bat[:lng]):bat[:any_1] ",	"SQLnth_value;",	"return the nth value of each group"	]
[ "batsql",	"ntile",	"pattern batsql.ntile(b:any_1, n:bat[:any_2], p:any_3, o:any_4):bat[:any_2] ",	"SQLntile;",	"return the groups divided as equally as possible"	]
[ "batsql",	"ntile",	"pattern batsql.ntile(b:bat[:any_1], n:any_2, p:any_3, o:any_4):bat[:any_2] ",	"SQLntile;",	"return the groups divided as equally as possible"	]
[ "batsql",	"ntile",	"pattern batsql.ntile(b:bat[:any_1], n:bat[:any_2], p:any_3, o:any_4):bat[:any_2] ",	"SQLntile;",	"return the groups divided as equally as possible"	]
[ "batsql",	"password",	"pattern batsql.password(user:bat[:str]):bat[:str] ",	"db_password_wrap;",	"Return password hash of user"	]
[ "batsql",	"percent_rank",	"pattern batsql.percent_rank(b:bat[:any_1], p:any_2, o:any_3):bat[:dbl] ",	"SQLpercent_rank;",	"return the percentage into the total number of groups for each row"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:hge] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:lng] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:dbl], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:flt] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:hge], s:bat[:lng], e:bat[:lng]):bat[:hge] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:hge] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:lng] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:hge] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:lng] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:hge] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"prod",	"pattern batsql.prod(b:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:lng] ",	"SQLprod;",	"return the product of groups"	]
[ "batsql",	"rank",	"pattern batsql.rank(b:bat[:any_1], p:any_2, o:any_3):bat[:int] ",	"SQLrank;",	"return the ranked groups"	]
[ "batsql",	"restart",	"unsafe pattern batsql.restart(sname:bat[:str], sequence:bat[:str], start:bat[:lng]):bat[:lng] ",	"mvc_bat_restart_seq;",	"restart the sequence with value start"	]
[ "batsql",	"restart",	"unsafe pattern batsql.restart(sname:bat[:str], sequence:bat[:str], start:lng):bat[:lng] ",	"mvc_bat_restart_seq;",	"restart the sequence with value start"	]
[ "batsql",	"restart",	"unsafe pattern batsql.restart(sname:bat[:str], sequence:str, start:bat[:lng]):bat[:lng] ",	"mvc_bat_restart_seq;",	"restart the sequence with value start"	]
[ "batsql",	"restart",	"unsafe pattern batsql.restart(sname:bat[:str], sequence:str, start:lng):bat[:lng] ",	"mvc_bat_restart_seq;",	"restart the sequence with value start"	]
[ "batsql",	"restart",	"unsafe pattern batsql.restart(sname:str, sequence:bat[:str], start:bat[:lng]):bat[:lng] ",	"mvc_bat_restart_seq;",	"restart the sequence with value start"	]
[ "batsql",	"restart",	"unsafe pattern batsql.restart(sname:str, sequence:bat[:str], start:lng):bat[:lng] ",	"mvc_bat_restart_seq;",	"restart the sequence with value start"	]
[ "batsql",	"restart",	"unsafe pattern batsql.restart(sname:str, sequence:str, start:bat[:lng]):bat[:lng] ",	"mvc_bat_restart_seq;",	"restart the sequence with value start"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:bte], d:int, s:int, r:bte):bat[:bte] ",	"bte_bat_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:dbl], r:bte):bat[:dbl] ",	"dbl_bat_round_wrap;",	"round off the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:flt], r:bte):bat[:flt] ",	"flt_bat_round_wrap;",	"round off the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:hge], d:int, s:int, r:bte):bat[:hge] ",	"hge_bat_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:int], d:int, s:int, r:bte):bat[:int] ",	"int_bat_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:lng], d:int, s:int, r:bte):bat[:lng] ",	"lng_bat_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:sht], d:int, s:int, r:bte):bat[:sht] ",	"sht_bat_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"row_number",	"pattern batsql.row_number(b:bat[:any_1], p:any_2, o:any_3):bat[:int] ",	"SQLrow_number;",	"return the row_numer-ed groups"	]
[ "batsql",	"stdev",	"pattern batsql.stdev(b:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "batsql",	"stdev",	"pattern batsql.stdev(b:bat[:dbl], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "batsql",	"stdev",	"pattern batsql.stdev(b:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "batsql",	"stdev",	"pattern batsql.stdev(b:bat[:hge], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_samp;",	"return the standard deviation of groups"	]
[ "batsql",	"stdev",	"pattern batsql.stdev(b:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "batsql",	"stdev",	"pattern batsql.stdev(b:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "batsql",	"stdev",	"pattern batsql.stdev(b:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "batsql",	"stdevp",	"pattern batsql.stdevp(b:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "batsql",	"stdevp",	"pattern batsql.stdevp(b:bat[:dbl], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "batsql",	"stdevp",	"pattern batsql.stdevp(b:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "batsql",	"stdevp",	"pattern batsql.stdevp(b:bat[:hge], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_pop;",	"return the standard deviation of groups"	]
[ "batsql",	"stdevp",	"pattern batsql.stdevp(b:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "batsql",	"stdevp",	"pattern batsql.stdevp(b:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "batsql",	"stdevp",	"pattern batsql.stdevp(b:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "batsql",	"str_group_concat",	"pattern batsql.str_group_concat(b:bat[:str], s:bat[:lng], e:bat[:lng]):bat[:str] ",	"SQLstrgroup_concat;",	"return the string concatenation of groups"	]
[ "batsql",	"str_group_concat",	"pattern batsql.str_group_concat(b:bat[:str], sep:bat[:str], s:bat[:lng], e:bat[:lng]):bat[:str] ",	"SQLstrgroup_concat;",	"return the string concatenation of groups with a custom separator"	]
[ "batsql",	"str_group_concat",	"pattern batsql.str_group_concat(b:bat[:str], sep:str, s:bat[:lng], e:bat[:lng]):bat[:str] ",	"SQLstrgroup_concat;",	"return the string concatenation of groups with a custom separator"	]
[ "batsql",	"str_group_concat",	"pattern batsql.str_group_concat(b:str, sep:bat[:str], s:lng, e:lng):bat[:str] ",	"SQLstrgroup_concat;",	"return the string concatenation of groups with a custom separator"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:hge] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:lng] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:dbl], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:flt] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:hge], s:bat[:lng], e:bat[:lng]):bat[:hge] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:hge] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:lng] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:hge] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:lng] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:hge] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"sum",	"pattern batsql.sum(b:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:lng] ",	"SQLsum;",	"return the sum of groups"	]
[ "batsql",	"variance",	"pattern batsql.variance(b:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "batsql",	"variance",	"pattern batsql.variance(b:bat[:dbl], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "batsql",	"variance",	"pattern batsql.variance(b:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "batsql",	"variance",	"pattern batsql.variance(b:bat[:hge], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_samp;",	"return the variance of groups"	]
[ "batsql",	"variance",	"pattern batsql.variance(b:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "batsql",	"variance",	"pattern batsql.variance(b:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "batsql",	"variance",	"pattern batsql.variance(b:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "batsql",	"variancep",	"pattern batsql.variancep(b:bat[:bte], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "batsql",	"variancep",	"pattern batsql.variancep(b:bat[:dbl], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "batsql",	"variancep",	"pattern batsql.variancep(b:bat[:flt], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "batsql",	"variancep",	"pattern batsql.variancep(b:bat[:hge], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_pop;",	"return the variance of groups"	]
[ "batsql",	"variancep",	"pattern batsql.variancep(b:bat[:int], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "batsql",	"variancep",	"pattern batsql.variancep(b:bat[:lng], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "batsql",	"variancep",	"pattern batsql.variancep(b:bat[:sht], s:bat[:lng], e:bat[:lng]):bat[:dbl] ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:bte]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:dbl]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:flt]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:int]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:lng]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:sht]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:bte):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:dbl):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:flt):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:int):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:lng):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, limit:sht):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, start:bat[:hge]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(b:bat[:any_1], unit:int, bound:int, excl:int, start:hge):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:bte]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:dbl]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:flt]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:int]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:lng]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:bat[:sht]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:bte):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:dbl):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:flt):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:int):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:lng):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, limit:sht):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, start:bat[:hge]):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batsql",	"window_bound",	"pattern batsql.window_bound(p:bat[:bit], b:bat[:any_1], unit:int, bound:int, excl:int, start:hge):bat[:lng] ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "batstr",	"endsWith",	"command batstr.endsWith(s:bat[:str], suffix:bat[:str]):bat[:bit] ",	"STRbatSuffix;",	"Suffix check."	]
[ "batstr",	"endsWith",	"command batstr.endsWith(s:bat[:str], suffix:str):bat[:bit] ",	"STRbatSuffixcst;",	"Suffix check."	]
[ "batstr",	"length",	"command batstr.length(s:bat[:str]):bat[:int] ",	"STRbatLength;",	"Return the length of a string."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str], n:bat[:int], s2:bat[:str]):bat[:str] ",	"STRbatLpad2_bat_bat;",	"Prepend the second strings to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str], n:bat[:int], s2:str):bat[:str] ",	"STRbatLpad2_bat_const;",	"Prepend the second string to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str], n:int, s2:bat[:str]):bat[:str] ",	"STRbatLpad2_const_bat;",	"Prepend the second strings to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str], n:int, s2:str):bat[:str] ",	"STRbatLpad2_const_const;",	"Prepend the second string to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str], n:bat[:int]):bat[:str] ",	"STRbatLpad_bat;",	"Prepend whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str], n:int):bat[:str] ",	"STRbatLpad_const;",	"Prepend whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"ltrim",	"command batstr.ltrim(s:bat[:str], s2:bat[:str]):bat[:str] ",	"STRbatLtrim2_bat;",	"Strip characters in the second strings from start of the first strings."	]
[ "batstr",	"ltrim",	"command batstr.ltrim(s:bat[:str], s2:str):bat[:str] ",	"STRbatLtrim2_const;",	"Strip characters in the second string from start of the first strings."	]
[ "batstr",	"ltrim",	"command batstr.ltrim(s:bat[:str]):bat[:str] ",	"STRbatLtrim;",	"Strip whitespaces from start of a string."	]
[ "batstr",	"nbytes",	"command batstr.nbytes(s:bat[:str]):bat[:int] ",	"STRbatBytes;",	"Return the string length in bytes."	]
[ "batstr",	"r_search",	"command batstr.r_search(s:bat[:str], c:bat[:str]):bat[:int] ",	"STRbatRstrSearch;",	"Reverse search for a substring. Returns position, -1 if not found."	]
[ "batstr",	"r_search",	"command batstr.r_search(s:bat[:str], c:str):bat[:int] ",	"STRbatRstrSearchcst;",	"Reverse search for a substring. Returns position, -1 if not found."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str], n:bat[:int], s2:bat[:str]):bat[:str] ",	"STRbatRpad2_bat_bat;",	"Append the second strings to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str], n:bat[:int], s2:str):bat[:str] ",	"STRbatRpad2_bat_const;",	"Append the second string to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str], n:int, s2:bat[:str]):bat[:str] ",	"STRbatRpad2_const_bat;",	"Append the second strings to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str], n:int, s2:str):bat[:str] ",	"STRbatRpad2_const_const;",	"Append the second string to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str], n:bat[:int]):bat[:str] ",	"STRbatRpad_bat;",	"Append whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str], n:int):bat[:str] ",	"STRbatRpad_const;",	"Append whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"rtrim",	"command batstr.rtrim(s:bat[:str], s2:bat[:str]):bat[:str] ",	"STRbatRtrim2_bat;",	"Strip characters in the second strings from end of the first strings."	]
[ "batstr",	"rtrim",	"command batstr.rtrim(s:bat[:str], s2:str):bat[:str] ",	"STRbatRtrim2_const;",	"Strip characters in the second string from end of the first strings."	]
[ "batstr",	"rtrim",	"command batstr.rtrim(s:bat[:str]):bat[:str] ",	"STRbatRtrim;",	"Strip whitespaces from end of a string."	]
[ "batstr",	"search",	"command batstr.search(s:bat[:str], c:bat[:str]):bat[:int] ",	"STRbatstrSearch;",	"Search for a substring. Returns position, -1 if not found."	]
[ "batstr",	"search",	"command batstr.search(s:bat[:str], c:str):bat[:int] ",	"STRbatstrSearchcst;",	"Search for a substring. Returns position, -1 if not found."	]
[ "batstr",	"startsWith",	"command batstr.startsWith(s:bat[:str], prefix:bat[:str]):bat[:bit] ",	"STRbatPrefix;",	"Prefix check."	]
[ "batstr",	"startsWith",	"command batstr.startsWith(s:bat[:str], prefix:str):bat[:bit] ",	"STRbatPrefixcst;",	"Prefix check."	]
[ "batstr",	"string",	"command batstr.string(b:bat[:str], offset:bat[:int]):bat[:str] ",	"STRbatTail;",	"Return the tail s[offset..n] of a string s[0..n]."	]
[ "batstr",	"string",	"command batstr.string(b:bat[:str], offset:int):bat[:str] ",	"STRbatTailcst;",	"Return the tail s[offset..n] of a string s[0..n]."	]
[ "batstr",	"substitute",	"command batstr.substitute(s:bat[:str], src:str, dst:str, rep:bit):bat[:str] ",	"STRbatSubstitutecst;",	"Substitute first occurrence of 'src' by\n\t'dst'.  Iff repeated = true this is\n\trepeated while 'src' can be found in the\n\tresult string. In order to prevent\n\trecursion and result strings of unlimited\n\tsize, repeating is only done iff src is\n\tnot a substring of dst."	]
[ "batstr",	"substring",	"command batstr.substring(s:bat[:str], start:bat[:int], index:bat[:int]):bat[:str] ",	"STRbatsubstring;",	"Substring extraction using [start,start+length]"	]
[ "batstr",	"substring",	"command batstr.substring(s:bat[:str], start:int, index:int):bat[:str] ",	"STRbatsubstringcst;",	"Substring extraction using [start,start+length]"	]
[ "batstr",	"toLower",	"command batstr.toLower(s:bat[:str]):bat[:str] ",	"STRbatLower;",	"Convert a string to lower case."	]
[ "batstr",	"toUpper",	"command batstr.toUpper(s:bat[:str]):bat[:str] ",	"STRbatUpper;",	"Convert a string to upper case."	]
[ "batstr",	"trim",	"command batstr.trim(s:bat[:str], s2:bat[:str]):bat[:str] ",	"STRbatStrip2_bat;",	"Strip characters in the second strings around the first strings."	]
[ "batstr",	"trim",	"command batstr.trim(s:bat[:str], s2:str):bat[:str] ",	"STRbatStrip2_const;",	"Strip characters in the second string around the first strings."	]
[ "batstr",	"trim",	"command batstr.trim(s:bat[:str]):bat[:str] ",	"STRbatStrip;",	"Strip whitespaces around a string."	]
[ "batstr",	"unicodeAt",	"command batstr.unicodeAt(s:bat[:str], index:bat[:int]):bat[:int] ",	"STRbatWChrAt;",	"get a unicode character (as an int) from a string position."	]
[ "batstr",	"unicodeAt",	"command batstr.unicodeAt(s:bat[:str], index:int):bat[:int] ",	"STRbatWChrAtcst;",	"get a unicode character (as an int) from a string position."	]
[ "batudf",	"fuse",	"command batudf.fuse(one:bat[:bte], two:bat[:bte]):bat[:sht] ",	"UDFBATfuse;",	"fuse two (1-byte) bte values into one (2-byte) sht value"	]
[ "batudf",	"fuse",	"command batudf.fuse(one:bat[:int], two:bat[:int]):bat[:lng] ",	"UDFBATfuse;",	"fuse two (4-byte) int values into one (8-byte) lng value"	]
[ "batudf",	"fuse",	"command batudf.fuse(one:bat[:lng], two:bat[:lng]):bat[:hge] ",	"UDFBATfuse;",	"fuse two (8-byte) lng values into one (16-byte) hge value"	]
[ "batudf",	"fuse",	"command batudf.fuse(one:bat[:sht], two:bat[:sht]):bat[:int] ",	"UDFBATfuse;",	"fuse two (2-byte) sht values into one (4-byte) int value"	]
[ "batudf",	"reverse",	"command batudf.reverse(b:bat[:str]):bat[:str] ",	"UDFBATreverse;",	"Reverse a BAT of strings"	]
[ "batxml",	"attribute",	"command batxml.attribute(name:str, val:bat[:str]):bat[:xml] ",	"BATXMLattribute;",	"Construct an attribute value pair."	]
[ "batxml",	"comment",	"command batxml.comment(val:bat[:str]):bat[:xml] ",	"BATXMLcomment;",	"Create an XML comment element."	]
[ "batxml",	"concat",	"command batxml.concat(left:bat[:xml], right:bat[:xml]):bat[:xml] ",	"BATXMLconcat;",	"Concatenate the XML values."	]
[ "batxml",	"content",	"command batxml.content(src:bat[:str]):bat[:xml] ",	"BATXMLcontent;",	"Parse the string as XML element content."	]
[ "batxml",	"document",	"command batxml.document(src:bat[:str]):bat[:xml] ",	"BATXMLdocument;",	"Parse the string as an XML document."	]
[ "batxml",	"element",	"command batxml.element(name:str, ns:xml, attr:xml, s:bat[:xml]):bat[:xml] ",	"BATXMLelement;",	"The basic building block for XML elements are namespaces, attributes and a sequence of XML elements. The name space and the attributes may be left unspecified(=nil)."	]
[ "batxml",	"element",	"command batxml.element(name:str, s:bat[:xml]):bat[:xml] ",	"BATXMLelementSmall;",	"The basic building block for XML elements are namespaces, attributes and a sequence of XML elements. The name space and the attributes may be left unspecified."	]
[ "batxml",	"forest",	"pattern batxml.forest(val:bat[:xml]...):bat[:xml] ",	"BATXMLforest;",	"Construct an element list."	]
[ "batxml",	"isdocument",	"command batxml.isdocument(val:bat[:str]):bat[:bit] ",	"BATXMLisdocument;",	"Validate the string as a XML document."	]
[ "batxml",	"options",	"command batxml.options(tag:str, option:str, left:bat[:xml]):bat[:xml] ",	"BATXMLoptions;",	"Create the components including NULL conversions."	]
[ "batxml",	"parse",	"command batxml.parse(doccont:str, val:bat[:str], option:str):bat[:xml] ",	"BATXMLparse;",	"Parse the XML document or element string values."	]
[ "batxml",	"pi",	"command batxml.pi(target:str, val:bat[:xml]):bat[:xml] ",	"BATXMLpi;",	"Construct a processing instruction."	]
[ "batxml",	"root",	"command batxml.root(val:bat[:xml], version:str, standalone:str):bat[:xml] ",	"BATXMLroot;",	"Contruct the root nodes."	]
[ "batxml",	"serialize",	"command batxml.serialize(val:bat[:xml]):bat[:str] ",	"BATXMLxml2str;",	"Serialize the XML object to a string."	]
[ "batxml",	"str",	"command batxml.str(src:bat[:xml]):bat[:str] ",	"BATXMLxml2str;",	"Cast the xml to a string."	]
[ "batxml",	"text",	"command batxml.text(val:bat[:xml]):bat[:str] ",	"BATXMLxmltext;",	"Serialize the XML object to a string."	]
[ "batxml",	"xml",	"command batxml.xml(src:bat[:str]):bat[:xml] ",	"BATXMLstr2xml;",	"Cast the string to an xml compliant string."	]
[ "batxml",	"xquery",	"command batxml.xquery(val:bat[:str], expr:str):bat[:xml] ",	"BATXMLxquery;",	"Execute the XQuery against the elements."	]
[ "bbp",	"bind",	"pattern bbp.bind(name:str):bat[:any_2] ",	"CMDbbpbind;",	"Locate the BAT using its logical name"	]
[ "bbp",	"get",	"command bbp.get() (id:bat[:int], ns:bat[:str], tt:bat[:str], cnt:bat[:lng], refcnt:bat[:int], lrefcnt:bat[:int], location:bat[:str], heat:bat[:int], dirty:bat[:str], status:bat[:str], kind:bat[:str]) ",	"CMDbbp;",	"bpp"	]
[ "bbp",	"getCount",	"command bbp.getCount():bat[:lng] ",	"CMDbbpCount;",	"Create a BAT with the cardinalities of all known BATs"	]
[ "bbp",	"getDirty",	"command bbp.getDirty():bat[:str] ",	"CMDbbpDirty;",	"Create a BAT with the dirty/ diffs/clean status"	]
[ "bbp",	"getDiskSpace",	"command bbp.getDiskSpace():lng ",	"CMDbbpDiskSpace;",	"Estimate the amount of disk space occupied by dbpath"	]
[ "bbp",	"getIndex",	"command bbp.getIndex(b:bat[:any_2]):int ",	"CMDbbpgetIndex;",	"Retrieve the index in the BBP"	]
[ "bbp",	"getKind",	"command bbp.getKind():bat[:str] ",	"CMDbbpKind;",	"Create a BAT with the persistency status"	]
[ "bbp",	"getLRefCount",	"command bbp.getLRefCount():bat[:int] ",	"CMDbbpLRefCount;",	"Create a BAT with the logical reference counts"	]
[ "bbp",	"getLRefCount",	"command bbp.getLRefCount(b:bat[:any_1]):int ",	"CMDgetBATlrefcnt;",	"Utility for debugging MAL interpreter"	]
[ "bbp",	"getLocation",	"command bbp.getLocation():bat[:str] ",	"CMDbbpLocation;",	"Create a BAT with their disk locations"	]
[ "bbp",	"getName",	"command bbp.getName(b:bat[:any_1]):str ",	"CMDbbpName;",	"Map a BAT into its internal name"	]
[ "bbp",	"getNames",	"command bbp.getNames():bat[:str] ",	"CMDbbpNames;",	"Map BAT into its bbp name"	]
[ "bbp",	"getPageSize",	"command bbp.getPageSize():int ",	"CMDgetPageSize;",	"Obtain the memory page size"	]
[ "bbp",	"getRefCount",	"command bbp.getRefCount():bat[:int] ",	"CMDbbpRefCount;",	"Create a BAT with the (hard) reference counts"	]
[ "bbp",	"getRefCount",	"command bbp.getRefCount(b:bat[:any_1]):int ",	"CMDgetBATrefcnt;",	"Utility for debugging MAL interpreter"	]
[ "bbp",	"getStatus",	"command bbp.getStatus():bat[:str] ",	"CMDbbpStatus;",	"Create a BAT with the disk/load status"	]
[ "bbp",	"setName",	"command bbp.setName(b:bat[:any_1], n:str):str ",	"CMDsetName;",	"Rename a BAT"	]
[ "blob",	"#cmp",	"command blob.#cmp():void ",	"BLOBcmp;",	""	]
[ "blob",	"#del",	"command blob.#del():void ",	"BLOBdel;",	""	]
[ "blob",	"#fromstr",	"command blob.#fromstr():void ",	"BLOBfromstr;",	""	]
[ "blob",	"#hash",	"command blob.#hash():void ",	"BLOBhash;",	""	]
[ "blob",	"#heap",	"command blob.#heap():void ",	"BLOBheap;",	""	]
[ "blob",	"#length",	"command blob.#length():void ",	"BLOBlength;",	""	]
[ "blob",	"#null",	"command blob.#null():void ",	"BLOBnull;",	""	]
[ "blob",	"#put",	"command blob.#put():void ",	"BLOBput;",	""	]
[ "blob",	"#read",	"command blob.#read():void ",	"BLOBread;",	""	]
[ "blob",	"#tostr",	"command blob.#tostr():void ",	"BLOBtostr;",	""	]
[ "blob",	"#write",	"command blob.#write():void ",	"BLOBwrite;",	""	]
[ "blob",	"blob",	"command blob.blob(s:blob):blob ",	"BLOBblob_blob;",	"Noop routine."	]
[ "blob",	"blob",	"command blob.blob(s:str):blob ",	"BLOBblob_fromstr;",	""	]
[ "blob",	"nitems",	"command blob.nitems(b:blob):int ",	"BLOBnitems;",	"get the number of bytes in this blob."	]
[ "blob",	"prelude",	"command blob.prelude():void ",	"BLOBprelude;",	""	]
[ "blob",	"toblob",	"command blob.toblob(v:str):blob ",	"BLOBtoblob;",	"store a string as a blob."	]
[ "bstream",	"create",	"unsafe command bstream.create(s:streams, bufsize:int):bstream ",	"bstream_create_wrapwrap;",	"create a buffered stream"	]
[ "bstream",	"destroy",	"unsafe command bstream.destroy(s:bstream):void ",	"bstream_destroy_wrapwrap;",	"destroy bstream"	]
[ "bstream",	"read",	"unsafe command bstream.read(s:bstream, size:int):int ",	"bstream_read_wrapwrap;",	"read at least size bytes into the buffer of s"	]
[ "calc",	"!=",	"pattern calc.!=(l:json, r:json):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(l:json, r:json, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(l:uuid, r:uuid):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(l:uuid, r:uuid, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bit, v2:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bit, v2:bit, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:blob, v2:blob):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:blob, v2:blob, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:bte, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:dbl, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:flt, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:hge, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:int, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:lng, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte, v2:sht, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:bte, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:dbl, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:flt, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:hge, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:int, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:lng, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl, v2:sht, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:bte, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:dbl, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:flt, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:hge, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:int, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:lng, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt, v2:sht, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:bte, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:dbl, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:flt, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:hge, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:int, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:lng, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge, v2:sht, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:bte, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:dbl, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:flt, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:hge, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:int, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:lng, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int, v2:sht, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:bte, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:dbl, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:flt, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:hge, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:int, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:lng, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng, v2:sht, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:oid, v2:oid):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:oid, v2:oid, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:bte, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:dbl, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:flt, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:hge, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:int, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:lng, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht, v2:sht, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:str, v2:str):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:str, v2:str, nil_matches:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v:date, w:date):bit ",	"CMDvarNE;",	"Equality of two dates"	]
[ "calc",	"!=",	"pattern calc.!=(v:date, w:date, nil_matches:bit):bit ",	"CMDvarNE;",	"Equality of two dates"	]
[ "calc",	"!=",	"pattern calc.!=(v:daytime, w:daytime):bit ",	"CMDvarNE;",	"Equality of two daytimes"	]
[ "calc",	"!=",	"pattern calc.!=(v:daytime, w:daytime, nil_matches:bit):bit ",	"CMDvarNE;",	"Equality of two daytimes"	]
[ "calc",	"!=",	"pattern calc.!=(v:timestamp, w:timestamp):bit ",	"CMDvarNE;",	"Equality of two timestamps"	]
[ "calc",	"!=",	"pattern calc.!=(v:timestamp, w:timestamp, nil_matches:bit):bit ",	"CMDvarNE;",	"Equality of two timestamps"	]
[ "calc",	"!=",	"command calc.!=(v:inet, w:inet):bit ",	"INET_comp_NEQ;",	"Inequality of two inets"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:bte):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:bte):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:bte):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:bte):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:bte):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:hge):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:hge):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:hge):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:hge):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:hge):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:int):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:int):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:int):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:int):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:int):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:lng):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:lng):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:lng):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:lng):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:lng):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:sht):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:sht):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:sht):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:sht):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte, v2:sht):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl, v2:bte):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl, v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl, v2:flt):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl, v2:hge):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl, v2:int):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl, v2:lng):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl, v2:sht):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt, v2:bte):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt, v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt, v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt, v2:hge):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt, v2:int):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt, v2:lng):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt, v2:sht):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:bte):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:bte):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:bte):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:bte):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:bte):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:hge):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:int):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:int):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:int):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:lng):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:lng):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:sht):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:sht):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:sht):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge, v2:sht):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:bte):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:bte):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:bte):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:bte):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:bte):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:hge):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:hge):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:hge):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:int):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:int):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:int):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:lng):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:lng):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:lng):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:sht):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:sht):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:sht):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int, v2:sht):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:bte):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:bte):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:bte):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:bte):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:bte):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:hge):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:hge):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:int):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:int):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:int):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:lng):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:lng):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:sht):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:sht):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:sht):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng, v2:sht):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:bte):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:bte):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:bte):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:bte):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:bte):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:hge):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:hge):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:hge):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:hge):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:int):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:int):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:int):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:int):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:lng):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:lng):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:lng):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:lng):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:sht):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:sht):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:sht):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht, v2:sht):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:bte):bte ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:bte):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:bte):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:bte):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:bte):int ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:bte):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:bte):sht ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:hge):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:hge):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:hge):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:int):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:int):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:int):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:int):int ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:int):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:lng):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:lng):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:lng):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:lng):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:sht):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:sht):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:sht):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:sht):int ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:sht):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte, v2:sht):sht ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl, v2:bte):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl, v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl, v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl, v2:hge):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl, v2:int):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl, v2:lng):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl, v2:sht):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:bte):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:bte):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:hge):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:hge):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:int):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:int):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:lng):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:lng):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:sht):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt, v2:sht):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:bte):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:bte):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:bte):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:hge):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:hge):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:hge):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:int):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:int):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:int):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:lng):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:lng):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:lng):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:sht):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:sht):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge, v2:sht):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:bte):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:bte):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:bte):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:bte):int ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:bte):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:hge):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:hge):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:hge):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:int):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:int):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:int):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:int):int ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:int):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:lng):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:lng):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:lng):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:lng):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:sht):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:sht):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:sht):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:sht):int ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int, v2:sht):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:bte):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:bte):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:bte):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:bte):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:hge):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:hge):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:hge):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:int):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:int):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:int):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:int):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:lng):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:lng):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:lng):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:lng):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:sht):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:sht):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:sht):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng, v2:sht):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:bte):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:bte):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:bte):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:bte):int ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:bte):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:bte):sht ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:hge):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:hge):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:hge):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:int):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:int):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:int):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:int):int ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:int):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:lng):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:lng):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:lng):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:lng):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:sht):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:sht):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:sht):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:sht):int ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:sht):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht, v2:sht):sht ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:bte):bte ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:bte):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:bte):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:bte):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:bte):int ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:bte):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:bte):sht ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:hge):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:hge):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:hge):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:int):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:int):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:int):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:int):int ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:int):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:lng):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:lng):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:lng):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:lng):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:sht):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:sht):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:sht):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:sht):int ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:sht):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte, v2:sht):sht ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl, v2:bte):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl, v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl, v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl, v2:hge):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl, v2:int):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl, v2:lng):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl, v2:sht):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:bte):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:bte):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:hge):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:hge):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:int):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:int):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:lng):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:lng):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:sht):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt, v2:sht):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:bte):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:bte):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:bte):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:hge):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:hge):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:hge):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:int):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:int):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:int):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:lng):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:lng):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:lng):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:sht):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:sht):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge, v2:sht):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:bte):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:bte):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:bte):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:bte):int ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:bte):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:hge):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:hge):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:hge):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:int):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:int):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:int):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:int):int ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:int):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:lng):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:lng):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:lng):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:lng):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:sht):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:sht):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:sht):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:sht):int ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int, v2:sht):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:bte):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:bte):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:bte):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:bte):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:hge):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:hge):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:hge):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:int):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:int):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:int):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:int):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:lng):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:lng):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:lng):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:lng):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:sht):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:sht):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:sht):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng, v2:sht):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:bte):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:bte):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:bte):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:bte):int ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:bte):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:bte):sht ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:hge):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:hge):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:hge):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:int):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:int):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:int):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:int):int ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:int):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:lng):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:lng):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:lng):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:lng):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:sht):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:sht):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:sht):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:sht):int ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:sht):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht, v2:sht):sht ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"command calc.+(v1:str, v2:str):str ",	"CMDvarADDstr;",	"Concatenate LEFT and RIGHT"	]
[ "calc",	"+",	"command calc.+(v1:str, i:int):str ",	"CMDvarADDstrint;",	"Concatenate LEFT and string representation of RIGHT"	]
[ "calc",	"++",	"pattern calc.++(v:bte):bte ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:dbl):dbl ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:flt):flt ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:hge):hge ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:int):int ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:lng):lng ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:sht):sht ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"-",	"pattern calc.-(v:bte):bte ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:dbl):dbl ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:flt):flt ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:hge):hge ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:int):int ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:lng):lng ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:sht):sht ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:bte):bte ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:bte):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:bte):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:bte):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:bte):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:bte):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:bte):sht ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:hge):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:hge):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:hge):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:int):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:int):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:int):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:int):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:int):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:lng):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:lng):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:lng):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:lng):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:sht):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:sht):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:sht):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:sht):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:sht):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte, v2:sht):sht ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl, v2:bte):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl, v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl, v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl, v2:hge):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl, v2:int):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl, v2:lng):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl, v2:sht):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:bte):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:bte):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:hge):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:hge):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:int):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:int):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:lng):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:lng):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:sht):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt, v2:sht):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:bte):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:bte):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:bte):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:hge):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:hge):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:hge):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:int):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:int):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:int):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:lng):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:lng):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:lng):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:sht):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:sht):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge, v2:sht):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:bte):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:bte):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:bte):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:bte):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:bte):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:hge):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:hge):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:hge):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:int):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:int):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:int):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:int):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:int):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:lng):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:lng):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:lng):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:lng):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:sht):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:sht):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:sht):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:sht):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int, v2:sht):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:bte):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:bte):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:bte):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:bte):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:hge):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:hge):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:hge):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:int):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:int):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:int):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:int):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:lng):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:lng):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:lng):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:lng):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:sht):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:sht):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:sht):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng, v2:sht):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:bte):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:bte):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:bte):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:bte):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:bte):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:bte):sht ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:hge):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:hge):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:hge):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:int):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:int):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:int):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:int):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:int):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:lng):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:lng):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:lng):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:lng):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:sht):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:sht):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:sht):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:sht):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:sht):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht, v2:sht):sht ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"--",	"pattern calc.--(v:bte):bte ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:dbl):dbl ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:flt):flt ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:hge):hge ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:int):int ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:lng):lng ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:sht):sht ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:bte):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:bte):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:bte):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:bte):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:bte):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:dbl):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:dbl):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:dbl):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:dbl):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:dbl):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:dbl):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:flt):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:flt):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:flt):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:flt):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:flt):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:hge):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:hge):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:hge):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:hge):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:hge):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:int):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:int):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:int):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:int):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:int):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:lng):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:lng):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:lng):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:lng):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:lng):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:sht):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:sht):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:sht):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:sht):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:bte, v2:sht):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:dbl, v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:dbl, v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:dbl, v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:dbl, v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:dbl, v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:dbl, v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:dbl, v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:dbl):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:flt, v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:bte):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:dbl):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:dbl):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:flt):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:hge):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:int):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:lng):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:hge, v2:sht):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:bte):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:bte):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:bte):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:dbl):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:dbl):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:dbl):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:dbl):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:flt):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:flt):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:flt):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:hge):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:hge):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:hge):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:int):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:int):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:int):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:lng):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:lng):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:lng):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:sht):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:sht):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:int, v2:sht):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:bte):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:bte):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:dbl):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:dbl):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:dbl):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:flt):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:flt):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:hge):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:hge):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:int):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:int):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:lng):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:lng):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:sht):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:lng, v2:sht):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:bte):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:bte):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:bte):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:bte):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:dbl):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:dbl):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:dbl):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:dbl):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:dbl):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:flt):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:flt):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:flt):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:flt):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:hge):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:hge):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:hge):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:hge):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:int):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:int):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:int):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:int):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:lng):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:lng):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:lng):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:lng):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:sht):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:sht):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:sht):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"/",	"pattern calc./(v1:sht, v2:sht):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on divide by zero"	]
[ "calc",	"<",	"pattern calc.<(l:json, r:json):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(l:uuid, r:uuid):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bit, v2:bit):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:blob, v2:blob):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte, v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte, v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte, v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte, v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte, v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte, v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte, v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl, v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl, v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl, v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl, v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl, v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl, v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl, v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt, v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt, v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt, v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt, v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt, v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt, v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt, v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge, v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge, v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge, v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge, v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge, v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge, v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge, v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int, v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int, v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int, v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int, v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int, v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int, v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int, v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng, v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng, v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng, v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng, v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng, v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng, v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng, v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:oid, v2:oid):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht, v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht, v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht, v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht, v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht, v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht, v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht, v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:str, v2:str):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v:date, w:date):bit ",	"CMDvarLT;",	"Equality of two dates"	]
[ "calc",	"<",	"pattern calc.<(v:daytime, w:daytime):bit ",	"CMDvarLT;",	"Equality of two daytimes"	]
[ "calc",	"<",	"pattern calc.<(v:timestamp, w:timestamp):bit ",	"CMDvarLT;",	"Equality of two timestamps"	]
[ "calc",	"<",	"command calc.<(v:inet, w:inet):bit ",	"INET_comp_LT;",	"Whether v is less than w"	]
[ "calc",	"<<",	"pattern calc.<<(v1:bte, v2:bte):bte ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:bte, v2:hge):bte ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:bte, v2:int):bte ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:bte, v2:lng):bte ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:bte, v2:sht):bte ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:hge, v2:bte):hge ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:hge, v2:hge):hge ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:hge, v2:int):hge ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:hge, v2:lng):hge ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:hge, v2:sht):hge ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:int, v2:bte):int ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:int, v2:hge):int ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:int, v2:int):int ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:int, v2:lng):int ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:int, v2:sht):int ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:lng, v2:bte):lng ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:lng, v2:hge):lng ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:lng, v2:int):lng ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:lng, v2:lng):lng ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:lng, v2:sht):lng ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:sht, v2:bte):sht ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:sht, v2:hge):sht ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:sht, v2:int):sht ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:sht, v2:lng):sht ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:sht, v2:sht):sht ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<=",	"pattern calc.<=(l:json, r:json):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(l:uuid, r:uuid):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bit, v2:bit):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:blob, v2:blob):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte, v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte, v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte, v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte, v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte, v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte, v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte, v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl, v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl, v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl, v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl, v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl, v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl, v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl, v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt, v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt, v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt, v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt, v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt, v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt, v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt, v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge, v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge, v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge, v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge, v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge, v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge, v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge, v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int, v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int, v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int, v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int, v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int, v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int, v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int, v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng, v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng, v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng, v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng, v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng, v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng, v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng, v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:oid, v2:oid):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht, v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht, v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht, v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht, v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht, v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht, v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht, v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:str, v2:str):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v:date, w:date):bit ",	"CMDvarLE;",	"Equality of two dates"	]
[ "calc",	"<=",	"pattern calc.<=(v:daytime, w:daytime):bit ",	"CMDvarLE;",	"Equality of two daytimes"	]
[ "calc",	"<=",	"pattern calc.<=(v:timestamp, w:timestamp):bit ",	"CMDvarLE;",	"Equality of two timestamps"	]
[ "calc",	"<=",	"command calc.<=(v:inet, w:inet):bit ",	"INET_comp_LE;",	"Whether v is less than or equal to w"	]
[ "calc",	"==",	"pattern calc.==(l:json, r:json):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(l:json, r:json, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(l:uuid, r:uuid):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(l:uuid, r:uuid, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bit, v2:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bit, v2:bit, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:blob, v2:blob):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:blob, v2:blob, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:bte, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:dbl, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:flt, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:hge, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:int, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:lng, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte, v2:sht, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:bte, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:dbl, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:flt, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:hge, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:int, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:lng, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl, v2:sht, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:bte, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:dbl, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:flt, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:hge, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:int, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:lng, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt, v2:sht, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:bte, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:dbl, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:flt, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:hge, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:int, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:lng, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge, v2:sht, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:bte, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:dbl, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:flt, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:hge, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:int, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:lng, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int, v2:sht, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:bte, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:dbl, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:flt, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:hge, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:int, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:lng, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng, v2:sht, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:oid, v2:oid):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:oid, v2:oid, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:bte, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:dbl, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:flt, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:hge, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:int, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:lng, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht, v2:sht, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:str, v2:str):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:str, v2:str, nil_matches:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v:date, w:date):bit ",	"CMDvarEQ;",	"Equality of two dates"	]
[ "calc",	"==",	"pattern calc.==(v:date, w:date, nil_matches:bit):bit ",	"CMDvarEQ;",	"Equality of two dates"	]
[ "calc",	"==",	"pattern calc.==(v:daytime, w:daytime):bit ",	"CMDvarEQ;",	"Equality of two daytimes"	]
[ "calc",	"==",	"pattern calc.==(v:daytime, w:daytime, nil_matches:bit):bit ",	"CMDvarEQ;",	"Equality of two daytimes"	]
[ "calc",	"==",	"pattern calc.==(v:timestamp, w:timestamp):bit ",	"CMDvarEQ;",	"Equality of two timestamps"	]
[ "calc",	"==",	"pattern calc.==(v:timestamp, w:timestamp, nil_matches:bit):bit ",	"CMDvarEQ;",	"Equality of two timestamps"	]
[ "calc",	"==",	"command calc.==(v:inet, w:inet):bit ",	"INET_comp_EQ;",	"Equality of two inets"	]
[ "calc",	">",	"pattern calc.>(l:json, r:json):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(l:uuid, r:uuid):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bit, v2:bit):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:blob, v2:blob):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte, v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte, v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte, v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte, v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte, v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte, v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte, v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl, v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl, v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl, v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl, v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl, v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl, v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl, v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt, v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt, v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt, v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt, v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt, v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt, v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt, v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge, v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge, v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge, v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge, v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge, v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge, v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge, v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int, v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int, v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int, v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int, v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int, v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int, v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int, v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng, v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng, v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng, v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng, v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng, v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng, v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng, v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:oid, v2:oid):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht, v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht, v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht, v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht, v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht, v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht, v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht, v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:str, v2:str):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v:date, w:date):bit ",	"CMDvarGT;",	"Equality of two dates"	]
[ "calc",	">",	"pattern calc.>(v:daytime, w:daytime):bit ",	"CMDvarGT;",	"Equality of two daytimes"	]
[ "calc",	">",	"pattern calc.>(v:timestamp, w:timestamp):bit ",	"CMDvarGT;",	"Equality of two timestamps"	]
[ "calc",	">",	"command calc.>(v:inet, w:inet):bit ",	"INET_comp_GT;",	"Whether v is greater than w"	]
[ "calc",	">=",	"pattern calc.>=(l:json, r:json):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(l:uuid, r:uuid):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bit, v2:bit):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:blob, v2:blob):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte, v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte, v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte, v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte, v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte, v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte, v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte, v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl, v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl, v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl, v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl, v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl, v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl, v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl, v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt, v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt, v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt, v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt, v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt, v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt, v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt, v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge, v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge, v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge, v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge, v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge, v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge, v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge, v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int, v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int, v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int, v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int, v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int, v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int, v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int, v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng, v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng, v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng, v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng, v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng, v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng, v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng, v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:oid, v2:oid):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht, v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht, v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht, v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht, v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht, v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht, v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht, v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:str, v2:str):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v:date, w:date):bit ",	"CMDvarGE;",	"Equality of two dates"	]
[ "calc",	">=",	"pattern calc.>=(v:daytime, w:daytime):bit ",	"CMDvarGE;",	"Equality of two daytimes"	]
[ "calc",	">=",	"pattern calc.>=(v:timestamp, w:timestamp):bit ",	"CMDvarGE;",	"Equality of two timestamps"	]
[ "calc",	">=",	"command calc.>=(v:inet, w:inet):bit ",	"INET_comp_GE;",	"Whether v is equal to or greater than w"	]
[ "calc",	">>",	"pattern calc.>>(v1:bte, v2:bte):bte ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:bte, v2:hge):bte ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:bte, v2:int):bte ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:bte, v2:lng):bte ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:bte, v2:sht):bte ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:hge, v2:bte):hge ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:hge, v2:hge):hge ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:hge, v2:int):hge ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:hge, v2:lng):hge ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:hge, v2:sht):hge ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:int, v2:bte):int ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:int, v2:hge):int ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:int, v2:int):int ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:int, v2:lng):int ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:int, v2:sht):int ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:lng, v2:bte):lng ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:lng, v2:hge):lng ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:lng, v2:int):lng ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:lng, v2:lng):lng ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:lng, v2:sht):lng ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:sht, v2:bte):sht ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:sht, v2:hge):sht ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:sht, v2:int):sht ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:sht, v2:lng):sht ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:sht, v2:sht):sht ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	"abs",	"pattern calc.abs(v:bte):bte ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:dbl):dbl ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:flt):flt ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:hge):hge ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:int):int ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:lng):lng ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:sht):sht ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte, v2:bte):bte ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte, v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte, v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte, v2:hge):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte, v2:int):int ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte, v2:lng):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte, v2:sht):sht ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl, v2:bte):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl, v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl, v2:flt):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl, v2:hge):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl, v2:int):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl, v2:lng):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl, v2:sht):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt, v2:bte):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt, v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt, v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt, v2:hge):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt, v2:int):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt, v2:lng):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt, v2:sht):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge, v2:bte):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge, v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge, v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge, v2:hge):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge, v2:int):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge, v2:lng):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge, v2:sht):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int, v2:bte):int ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int, v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int, v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int, v2:hge):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int, v2:int):int ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int, v2:lng):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int, v2:sht):int ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng, v2:bte):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng, v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng, v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng, v2:hge):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng, v2:int):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng, v2:lng):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng, v2:sht):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht, v2:bte):sht ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht, v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht, v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht, v2:hge):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht, v2:int):int ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht, v2:lng):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht, v2:sht):sht ",	"CMDvarADD;",	"Return V1 + V2, overflow results in NIL value"	]
[ "calc",	"and",	"pattern calc.and(v1:bit, v2:bit):bit ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"and",	"pattern calc.and(v1:bte, v2:bte):bte ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"and",	"pattern calc.and(v1:hge, v2:hge):hge ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"and",	"pattern calc.and(v1:int, v2:int):int ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"and",	"pattern calc.and(v1:lng, v2:lng):lng ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"and",	"pattern calc.and(v1:sht, v2:sht):sht ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"between",	"pattern calc.between(b:any_1, lo:any_1, hi:any_1, sym:bit, linc:bit, hinc:bit, nils_false:bit, anti:bit):bit ",	"CMDvarBETWEEN;",	"B between LO and HI inclusive"	]
[ "calc",	"bit",	"pattern calc.bit(v:bit):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:bte):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:dbl):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:flt):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:hge):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:int):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:lng):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:oid):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:sht):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:str):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:void):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"blob",	"command calc.blob(b:blob):blob ",	"BLOBblob_blob;",	""	]
[ "calc",	"blob",	"command calc.blob(s:str):blob ",	"BLOBblob_fromstr;",	""	]
[ "calc",	"blob",	"command calc.blob(v:str):blob ",	"str_2_blob;",	"cast to blob"	]
[ "calc",	"bte",	"pattern calc.bte(v:bit):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:bte):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:dbl):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:flt):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:hge):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:int):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:lng):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:oid):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:sht):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:str):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:void):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"command calc.bte(s1:int, v:bte):bte ",	"bte_dec2_bte;",	"cast decimal(bte) to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int, v:bte, d2:int, s2:int):bte ",	"bte_dec2dec_bte;",	"cast decimal(bte) to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:bte, digits:int, scale:int):bte ",	"bte_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:dbl, digits:int, scale:int):bte ",	"dbl_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:flt, digits:int, scale:int):bte ",	"flt_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int, v:hge):bte ",	"hge_dec2_bte;",	"cast decimal(hge) to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int, v:hge, d2:int, s2:int):bte ",	"hge_dec2dec_bte;",	"cast decimal(hge) to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:hge, digits:int, scale:int):bte ",	"hge_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int, v:int):bte ",	"int_dec2_bte;",	"cast decimal(int) to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int, v:int, d2:int, s2:int):bte ",	"int_dec2dec_bte;",	"cast decimal(int) to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:int, digits:int, scale:int):bte ",	"int_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int, v:lng):bte ",	"lng_dec2_bte;",	"cast decimal(lng) to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int, v:lng, d2:int, s2:int):bte ",	"lng_dec2dec_bte;",	"cast decimal(lng) to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:lng, digits:int, scale:int):bte ",	"lng_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:void, digits:int, scale:int):bte ",	"nil_2dec_bte;",	"cast to dec(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int, v:sht):bte ",	"sht_dec2_bte;",	"cast decimal(sht) to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int, v:sht, d2:int, s2:int):bte ",	"sht_dec2dec_bte;",	"cast decimal(sht) to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:sht, digits:int, scale:int):bte ",	"sht_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:str, digits:int, scale:int):bte ",	"str_2dec_bte;",	"cast to dec(bte) and check for overflow"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bit, v2:bit):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte, v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte, v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte, v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte, v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte, v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte, v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte, v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl, v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl, v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl, v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl, v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl, v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl, v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl, v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt, v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt, v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt, v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt, v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt, v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt, v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt, v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge, v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge, v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge, v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge, v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge, v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge, v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge, v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int, v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int, v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int, v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int, v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int, v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int, v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int, v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng, v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng, v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng, v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng, v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng, v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng, v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng, v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:oid, v2:oid):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht, v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht, v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht, v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht, v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht, v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht, v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht, v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:str, v2:str):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"date",	"command calc.date(d:date):date ",	"MTIMEdate_date;",	""	]
[ "calc",	"date",	"command calc.date(s:str):date ",	"MTIMEdate_fromstr;",	""	]
[ "calc",	"date",	"command calc.date(t:timestamp):date ",	"MTIMEtimestamp_extract_date;",	""	]
[ "calc",	"date",	"command calc.date(v:void):date ",	"nil_2_date;",	"cast to date"	]
[ "calc",	"date",	"command calc.date(v:str):date ",	"str_2_date;",	"cast to date"	]
[ "calc",	"daytime",	"command calc.daytime(d:daytime):daytime ",	"MTIMEdaytime_daytime;",	""	]
[ "calc",	"daytime",	"command calc.daytime(s:lng):daytime ",	"MTIMEdaytime_fromseconds;",	""	]
[ "calc",	"daytime",	"command calc.daytime(s:str):daytime ",	"MTIMEdaytime_fromstr;",	""	]
[ "calc",	"daytime",	"command calc.daytime(t:timestamp):daytime ",	"MTIMEtimestamp_extract_daytime;",	""	]
[ "calc",	"daytime",	"command calc.daytime(v:daytime, digits:int):daytime ",	"daytime_2time_daytime;",	"cast daytime to daytime and check for overflow"	]
[ "calc",	"daytime",	"command calc.daytime(v:void, digits:int):daytime ",	"nil_2time_daytime;",	"cast to daytime and check for overflow"	]
[ "calc",	"daytime",	"command calc.daytime(v:lng, d:int):daytime ",	"second_interval_2_daytime;",	"cast second_interval to a daytime and check for overflow"	]
[ "calc",	"daytime",	"command calc.daytime(v:str, digits:int):daytime ",	"str_2time_daytime;",	"cast to daytime and check for overflow"	]
[ "calc",	"daytime",	"command calc.daytime(v:str, digits:int, has_tz:int):daytime ",	"str_2time_daytimetz;",	"cast to daytime and check for overflow"	]
[ "calc",	"daytime",	"command calc.daytime(v:timestamp, d:int):daytime ",	"timestamp_2_daytime;",	"cast timestamp to a daytime and check for overflow"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:bit):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:bte):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:dbl):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:flt):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:hge):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:int):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:lng):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:oid):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:sht):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:str):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:void):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int, v:bte):dbl ",	"bte_dec2_dbl;",	"cast decimal(bte) to dbl and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int, v:bte, d2:int, s2:int):dbl ",	"bte_dec2dec_dbl;",	"cast decimal(bte) to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(v:bte, digits:int, scale:int):dbl ",	"bte_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int, v:hge):dbl ",	"hge_dec2_dbl;",	"cast decimal(hge) to dbl and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int, v:hge, d2:int, s2:int):dbl ",	"hge_dec2dec_dbl;",	"cast decimal(hge) to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(v:hge, digits:int, scale:int):dbl ",	"hge_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int, v:int):dbl ",	"int_dec2_dbl;",	"cast decimal(int) to dbl and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int, v:int, d2:int, s2:int):dbl ",	"int_dec2dec_dbl;",	"cast decimal(int) to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(v:int, digits:int, scale:int):dbl ",	"int_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int, v:lng):dbl ",	"lng_dec2_dbl;",	"cast decimal(lng) to dbl and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int, v:lng, d2:int, s2:int):dbl ",	"lng_dec2dec_dbl;",	"cast decimal(lng) to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(v:lng, digits:int, scale:int):dbl ",	"lng_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int, v:sht):dbl ",	"sht_dec2_dbl;",	"cast decimal(sht) to dbl and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int, v:sht, d2:int, s2:int):dbl ",	"sht_dec2dec_dbl;",	"cast decimal(sht) to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(v:sht, digits:int, scale:int):dbl ",	"sht_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:bte):bte ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:bte):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:bte):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:bte):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:bte):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:bte):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:bte):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:dbl):bte ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:dbl):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:dbl):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:dbl):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:dbl):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:dbl):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:flt):bte ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:flt):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:flt):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:flt):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:flt):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:flt):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:hge):bte ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:hge):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:hge):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:hge):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:hge):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:hge):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:hge):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:int):bte ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:int):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:int):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:int):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:int):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:int):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:int):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:lng):bte ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:lng):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:lng):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:lng):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:lng):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:lng):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:lng):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:sht):bte ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:sht):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:sht):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:sht):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:sht):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:sht):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte, v2:sht):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl, v2:bte):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl, v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl, v2:flt):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl, v2:hge):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl, v2:int):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl, v2:lng):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl, v2:sht):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:bte):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:bte):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:dbl):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:flt):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:hge):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:hge):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:int):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:int):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:lng):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:lng):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:sht):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt, v2:sht):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:bte):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:bte):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:bte):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:dbl):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:dbl):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:flt):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:flt):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:hge):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:hge):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:hge):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:int):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:int):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:int):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:lng):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:lng):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:lng):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:sht):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:sht):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge, v2:sht):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:bte):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:bte):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:bte):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:bte):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:bte):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:dbl):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:dbl):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:dbl):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:dbl):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:flt):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:flt):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:flt):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:flt):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:hge):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:hge):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:hge):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:hge):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:hge):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:int):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:int):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:int):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:int):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:int):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:lng):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:lng):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:lng):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:lng):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:lng):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:sht):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:sht):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:sht):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:sht):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int, v2:sht):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:bte):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:bte):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:bte):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:bte):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:dbl):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:dbl):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:dbl):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:flt):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:flt):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:flt):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:hge):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:hge):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:hge):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:hge):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:int):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:int):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:int):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:int):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:lng):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:lng):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:lng):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:lng):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:sht):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:sht):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:sht):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng, v2:sht):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:bte):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:bte):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:bte):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:bte):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:bte):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:bte):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:dbl):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:dbl):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:dbl):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:dbl):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:dbl):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:flt):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:flt):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:flt):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:flt):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:flt):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:hge):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:hge):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:hge):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:hge):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:hge):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:hge):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:int):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:int):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:int):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:int):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:int):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:int):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:lng):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:lng):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:lng):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:lng):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:lng):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:lng):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:sht):dbl ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:sht):flt ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:sht):hge ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:sht):int ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:sht):lng ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht, v2:sht):sht ",	"CMDvarDIV;",	"Return V1 / V2, divide by zero results in NIL value"	]
[ "calc",	"flt",	"pattern calc.flt(v:bit):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:bte):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:dbl):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:flt):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:hge):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:int):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:lng):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:oid):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:sht):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:str):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:void):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"command calc.flt(s1:int, v:bte):flt ",	"bte_dec2_flt;",	"cast decimal(bte) to flt and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int, v:bte, d2:int, s2:int):flt ",	"bte_dec2dec_flt;",	"cast decimal(bte) to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(v:bte, digits:int, scale:int):flt ",	"bte_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int, v:hge):flt ",	"hge_dec2_flt;",	"cast decimal(hge) to flt and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int, v:hge, d2:int, s2:int):flt ",	"hge_dec2dec_flt;",	"cast decimal(hge) to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(v:hge, digits:int, scale:int):flt ",	"hge_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int, v:int):flt ",	"int_dec2_flt;",	"cast decimal(int) to flt and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int, v:int, d2:int, s2:int):flt ",	"int_dec2dec_flt;",	"cast decimal(int) to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(v:int, digits:int, scale:int):flt ",	"int_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int, v:lng):flt ",	"lng_dec2_flt;",	"cast decimal(lng) to flt and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int, v:lng, d2:int, s2:int):flt ",	"lng_dec2dec_flt;",	"cast decimal(lng) to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(v:lng, digits:int, scale:int):flt ",	"lng_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int, v:sht):flt ",	"sht_dec2_flt;",	"cast decimal(sht) to flt and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int, v:sht, d2:int, s2:int):flt ",	"sht_dec2dec_flt;",	"cast decimal(sht) to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(v:sht, digits:int, scale:int):flt ",	"sht_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "calc",	"hash",	"pattern calc.hash(v:any):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:bte):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:dbl):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:flt):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:hge):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:int):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:lng):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:lng):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:oid):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:sht):lng ",	"MKEYhash;",	""	]
[ "calc",	"hge",	"pattern calc.hge(v:bit):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:bte):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:dbl):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:flt):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:hge):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:int):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:lng):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:oid):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:sht):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:str):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:void):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"command calc.hge(s1:int, v:bte):hge ",	"bte_dec2_hge;",	"cast decimal(bte) to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int, v:bte, d2:int, s2:int):hge ",	"bte_dec2dec_hge;",	"cast decimal(bte) to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:bte, digits:int, scale:int):hge ",	"bte_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:dbl, digits:int, scale:int):hge ",	"dbl_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:flt, digits:int, scale:int):hge ",	"flt_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int, v:hge):hge ",	"hge_dec2_hge;",	"cast decimal(hge) to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int, v:hge, d2:int, s2:int):hge ",	"hge_dec2dec_hge;",	"cast decimal(hge) to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:hge, digits:int, scale:int):hge ",	"hge_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int, v:int):hge ",	"int_dec2_hge;",	"cast decimal(int) to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int, v:int, d2:int, s2:int):hge ",	"int_dec2dec_hge;",	"cast decimal(int) to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:int, digits:int, scale:int):hge ",	"int_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int, v:lng):hge ",	"lng_dec2_hge;",	"cast decimal(lng) to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int, v:lng, d2:int, s2:int):hge ",	"lng_dec2dec_hge;",	"cast decimal(lng) to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:lng, digits:int, scale:int):hge ",	"lng_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:void, digits:int, scale:int):hge ",	"nil_2dec_hge;",	"cast to dec(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int, v:sht):hge ",	"sht_dec2_hge;",	"cast decimal(sht) to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int, v:sht, d2:int, s2:int):hge ",	"sht_dec2dec_hge;",	"cast decimal(sht) to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:sht, digits:int, scale:int):hge ",	"sht_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:str, digits:int, scale:int):hge ",	"str_2dec_hge;",	"cast to dec(hge) and check for overflow"	]
[ "calc",	"identity",	"command calc.identity(X_0:any_2):oid ",	"SQLidentity;",	"Returns a unique row identitfier."	]
[ "calc",	"ifthenelse",	"pattern calc.ifthenelse(b:bit, t:any_1, f:any_1):any_1 ",	"CALCswitchbit;",	"If VALUE is true return MIDDLE else RIGHT"	]
[ "calc",	"index",	"command calc.index(v:str, u:bit):bte ",	"STRindex_bte;",	"Return the offsets as an index bat"	]
[ "calc",	"index",	"command calc.index(v:str, u:bit):int ",	"STRindex_int;",	"Return the offsets as an index bat"	]
[ "calc",	"index",	"command calc.index(v:str, u:bit):sht ",	"STRindex_sht;",	"Return the offsets as an index bat"	]
[ "calc",	"inet",	"command calc.inet(s:str):inet ",	"INET_fromstr;",	"Convert a string to an inet"	]
[ "calc",	"inet",	"command calc.inet(s:inet):inet ",	"INET_inet;",	"Convert a inet to an inet"	]
[ "calc",	"int",	"pattern calc.int(v:bit):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:bte):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:dbl):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:flt):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:hge):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:int):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:lng):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:oid):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:sht):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:str):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:void):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"command calc.int(s1:int, v:bte):int ",	"bte_dec2_int;",	"cast decimal(bte) to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int, v:bte, d2:int, s2:int):int ",	"bte_dec2dec_int;",	"cast decimal(bte) to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:bte, digits:int, scale:int):int ",	"bte_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:dbl, digits:int, scale:int):int ",	"dbl_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:flt, digits:int, scale:int):int ",	"flt_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int, v:hge):int ",	"hge_dec2_int;",	"cast decimal(hge) to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int, v:hge, d2:int, s2:int):int ",	"hge_dec2dec_int;",	"cast decimal(hge) to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:hge, digits:int, scale:int):int ",	"hge_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int, v:int):int ",	"int_dec2_int;",	"cast decimal(int) to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int, v:int, d2:int, s2:int):int ",	"int_dec2dec_int;",	"cast decimal(int) to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:int, digits:int, scale:int):int ",	"int_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int, v:lng):int ",	"lng_dec2_int;",	"cast decimal(lng) to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int, v:lng, d2:int, s2:int):int ",	"lng_dec2dec_int;",	"cast decimal(lng) to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:lng, digits:int, scale:int):int ",	"lng_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:void, digits:int, scale:int):int ",	"nil_2dec_int;",	"cast to dec(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int, v:sht):int ",	"sht_dec2_int;",	"cast decimal(sht) to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int, v:sht, d2:int, s2:int):int ",	"sht_dec2dec_int;",	"cast decimal(sht) to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:sht, digits:int, scale:int):int ",	"sht_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:str, digits:int, scale:int):int ",	"str_2dec_int;",	"cast to dec(int) and check for overflow"	]
[ "calc",	"isnil",	"pattern calc.isnil(v:any):bit ",	"CMDvarISNIL;",	"Unary check for nil of V"	]
[ "calc",	"isnotnil",	"pattern calc.isnotnil(v:any):bit ",	"CMDvarISNOTNIL;",	"Unary check for notnil of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:bte):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:dbl):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:flt):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:hge):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:int):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:lng):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:sht):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"json",	"command calc.json(j:json):json ",	"JSONstr2json;",	"Convert JSON to JSON. Dealing with escape characters"	]
[ "calc",	"json",	"command calc.json(j:str):json ",	"JSONstr2json;",	"Convert string to its JSON. Dealing with escape characters"	]
[ "calc",	"length",	"command calc.length(s:str):int ",	"CMDstrlength;",	"Length of STRING"	]
[ "calc",	"lng",	"pattern calc.lng(v:bit):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:bte):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:dbl):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:flt):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:hge):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:int):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:lng):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:oid):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:sht):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:str):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:void):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"command calc.lng(s1:int, v:bte):lng ",	"bte_dec2_lng;",	"cast decimal(bte) to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int, v:bte, d2:int, s2:int):lng ",	"bte_dec2dec_lng;",	"cast decimal(bte) to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:bte, digits:int, scale:int):lng ",	"bte_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:dbl, digits:int, scale:int):lng ",	"dbl_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:flt, digits:int, scale:int):lng ",	"flt_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int, v:hge):lng ",	"hge_dec2_lng;",	"cast decimal(hge) to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int, v:hge, d2:int, s2:int):lng ",	"hge_dec2dec_lng;",	"cast decimal(hge) to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:hge, digits:int, scale:int):lng ",	"hge_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int, v:int):lng ",	"int_dec2_lng;",	"cast decimal(int) to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int, v:int, d2:int, s2:int):lng ",	"int_dec2dec_lng;",	"cast decimal(int) to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:int, digits:int, scale:int):lng ",	"int_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int, v:lng):lng ",	"lng_dec2_lng;",	"cast decimal(lng) to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int, v:lng, d2:int, s2:int):lng ",	"lng_dec2dec_lng;",	"cast decimal(lng) to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:lng, digits:int, scale:int):lng ",	"lng_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:void, digits:int, scale:int):lng ",	"nil_2dec_lng;",	"cast to dec(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int, v:sht):lng ",	"sht_dec2_lng;",	"cast decimal(sht) to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int, v:sht, d2:int, s2:int):lng ",	"sht_dec2dec_lng;",	"cast decimal(sht) to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:sht, digits:int, scale:int):lng ",	"sht_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:str, digits:int, scale:int):lng ",	"str_2dec_lng;",	"cast to dec(lng) and check for overflow"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:bte, v2:bte):bte ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:bte, v2:hge):bte ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:bte, v2:int):bte ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:bte, v2:lng):bte ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:bte, v2:sht):bte ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:hge, v2:bte):hge ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:hge, v2:hge):hge ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:hge, v2:int):hge ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:hge, v2:lng):hge ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:hge, v2:sht):hge ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:int, v2:bte):int ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:int, v2:hge):int ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:int, v2:int):int ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:int, v2:lng):int ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:int, v2:sht):int ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:lng, v2:bte):lng ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:lng, v2:hge):lng ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:lng, v2:int):lng ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:lng, v2:lng):lng ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:lng, v2:sht):lng ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:sht, v2:bte):sht ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:sht, v2:hge):sht ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:sht, v2:int):sht ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:sht, v2:lng):sht ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:sht, v2:sht):sht ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand results in NIL value"	]
[ "calc",	"max",	"pattern calc.max(v1:any_1, v2:any_1):any_1 ",	"CALCmax;",	"Return max of V1 and V2"	]
[ "calc",	"max_no_nil",	"pattern calc.max_no_nil(v1:any_1, v2:any_1):any_1 ",	"CALCmax_no_nil;",	"Return max of V1 and V2, ignoring nil values"	]
[ "calc",	"mbr",	"command calc.mbr(v:mbr):mbr ",	"mbrFromMBR;",	""	]
[ "calc",	"mbr",	"command calc.mbr(v:str):mbr ",	"mbrFromString;",	""	]
[ "calc",	"min",	"pattern calc.min(v1:any_1, v2:any_1):any_1 ",	"CALCmin;",	"Return min of V1 and V2"	]
[ "calc",	"min_no_nil",	"pattern calc.min_no_nil(v1:any_1, v2:any_1):any_1 ",	"CALCmin_no_nil;",	"Return min of V1 and V2, ignoring nil values"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:bte):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:bte):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:bte):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:bte):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:bte):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:hge):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:hge):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:hge):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:hge):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:hge):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:int):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:int):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:int):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:int):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:int):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:lng):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:lng):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:lng):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:lng):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:lng):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:sht):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:sht):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:sht):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:sht):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte, v2:sht):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl, v2:bte):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl, v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl, v2:flt):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl, v2:hge):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl, v2:int):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl, v2:lng):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl, v2:sht):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt, v2:bte):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt, v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt, v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt, v2:hge):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt, v2:int):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt, v2:lng):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt, v2:sht):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:bte):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:bte):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:bte):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:bte):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:bte):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:hge):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:int):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:int):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:int):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:lng):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:lng):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:sht):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:sht):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:sht):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge, v2:sht):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:bte):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:bte):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:bte):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:bte):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:bte):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:hge):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:hge):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:hge):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:int):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:int):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:int):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:lng):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:lng):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:lng):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:sht):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:sht):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:sht):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int, v2:sht):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:bte):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:bte):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:bte):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:bte):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:bte):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:hge):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:hge):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:int):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:int):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:int):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:lng):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:lng):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:sht):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:sht):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:sht):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng, v2:sht):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:bte):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:bte):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:bte):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:bte):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:bte):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:hge):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:hge):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:hge):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:hge):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:int):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:int):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:int):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:int):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:lng):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:lng):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:lng):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:lng):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:sht):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:sht):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:sht):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht, v2:sht):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero results in NIL value"	]
[ "calc",	"month_interval",	"pattern calc.month_interval(v:bte, ek:int, sk:int):int ",	"month_interval;",	"cast bte to a month_interval and check for overflow"	]
[ "calc",	"month_interval",	"pattern calc.month_interval(v:hge, ek:int, sk:int):int ",	"month_interval;",	"cast hge to a month_interval and check for overflow"	]
[ "calc",	"month_interval",	"pattern calc.month_interval(v:int, ek:int, sk:int):int ",	"month_interval;",	"cast int to a month_interval and check for overflow"	]
[ "calc",	"month_interval",	"pattern calc.month_interval(v:lng, ek:int, sk:int):int ",	"month_interval;",	"cast lng to a month_interval and check for overflow"	]
[ "calc",	"month_interval",	"pattern calc.month_interval(v:sht, ek:int, sk:int):int ",	"month_interval;",	"cast sht to a month_interval and check for overflow"	]
[ "calc",	"month_interval",	"command calc.month_interval(v:str, ek:int, sk:int):int ",	"month_interval_str;",	"cast str to a month_interval and check for overflow"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte, v2:bte):bte ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte, v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte, v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte, v2:hge):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte, v2:int):int ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte, v2:lng):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte, v2:sht):sht ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl, v2:bte):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl, v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl, v2:flt):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl, v2:hge):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl, v2:int):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl, v2:lng):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl, v2:sht):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt, v2:bte):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt, v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt, v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt, v2:hge):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt, v2:int):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt, v2:lng):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt, v2:sht):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge, v2:bte):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge, v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge, v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge, v2:hge):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge, v2:int):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge, v2:lng):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge, v2:sht):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int, v2:bte):int ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int, v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int, v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int, v2:hge):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int, v2:int):int ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int, v2:lng):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int, v2:sht):int ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng, v2:bte):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng, v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng, v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng, v2:hge):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng, v2:int):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng, v2:lng):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng, v2:sht):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht, v2:bte):sht ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht, v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht, v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht, v2:hge):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht, v2:int):int ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht, v2:lng):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht, v2:sht):sht ",	"CMDvarMUL;",	"Return V1 * V2, overflow results in NIL value"	]
[ "calc",	"not",	"pattern calc.not(v:bit):bit ",	"CMDvarNOT;",	"Return the Boolean inverse"	]
[ "calc",	"not",	"pattern calc.not(v:bte):bte ",	"CMDvarNOT;",	"Unary bitwise not of V"	]
[ "calc",	"not",	"pattern calc.not(v:hge):hge ",	"CMDvarNOT;",	"Unary bitwise not of V"	]
[ "calc",	"not",	"pattern calc.not(v:int):int ",	"CMDvarNOT;",	"Unary bitwise not of V"	]
[ "calc",	"not",	"pattern calc.not(v:lng):lng ",	"CMDvarNOT;",	"Unary bitwise not of V"	]
[ "calc",	"not",	"pattern calc.not(v:sht):sht ",	"CMDvarNOT;",	"Unary bitwise not of V"	]
[ "calc",	"oid",	"pattern calc.oid(v:bit):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:bte):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:dbl):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:flt):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:hge):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:int):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:lng):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:oid):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:sht):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:str):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:void):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"or",	"pattern calc.or(v1:bit, v2:bit):bit ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"or",	"pattern calc.or(v1:bte, v2:bte):bte ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"or",	"pattern calc.or(v1:hge, v2:hge):hge ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"or",	"pattern calc.or(v1:int, v2:int):int ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"or",	"pattern calc.or(v1:lng, v2:lng):lng ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"or",	"pattern calc.or(v1:sht, v2:sht):sht ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"ptr",	"command calc.ptr(v:ptr):ptr ",	"CMDvarCONVERTptr;",	"Cast VALUE to ptr"	]
[ "calc",	"rotate_xor_hash",	"pattern calc.rotate_xor_hash(h:lng, nbits:int, v:any_1):lng ",	"MKEYrotate_xor_hash;",	""	]
[ "calc",	"rowid",	"pattern calc.rowid(v:any_1, schema:str, table:str):oid ",	"sql_rowid;",	"return the next rowid"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:bte, v2:bte):bte ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:bte, v2:hge):bte ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:bte, v2:int):bte ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:bte, v2:lng):bte ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:bte, v2:sht):bte ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:hge, v2:bte):hge ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:hge, v2:hge):hge ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:hge, v2:int):hge ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:hge, v2:lng):hge ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:hge, v2:sht):hge ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:int, v2:bte):int ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:int, v2:hge):int ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:int, v2:int):int ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:int, v2:lng):int ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:int, v2:sht):int ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:lng, v2:bte):lng ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:lng, v2:hge):lng ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:lng, v2:int):lng ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:lng, v2:lng):lng ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:lng, v2:sht):lng ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:sht, v2:bte):sht ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:sht, v2:hge):sht ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:sht, v2:int):sht ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:sht, v2:lng):sht ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:sht, v2:sht):sht ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand results in NIL value"	]
[ "calc",	"second_interval",	"command calc.second_interval(sc:int, v:bte, ek:int, sk:int):lng ",	"bte_dec2second_interval;",	"cast bte decimal to a second_interval"	]
[ "calc",	"second_interval",	"command calc.second_interval(sc:int, v:hge, ek:int, sk:int):lng ",	"hge_dec2second_interval;",	"cast hge decimal to a second_interval"	]
[ "calc",	"second_interval",	"command calc.second_interval(sc:int, v:int, ek:int, sk:int):lng ",	"int_dec2second_interval;",	"cast int decimal to a second_interval"	]
[ "calc",	"second_interval",	"command calc.second_interval(sc:int, v:lng, ek:int, sk:int):lng ",	"lng_dec2second_interval;",	"cast lng decimal to a second_interval"	]
[ "calc",	"second_interval",	"pattern calc.second_interval(v:bte, ek:int, sk:int):lng ",	"second_interval;",	"cast bte to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"pattern calc.second_interval(v:hge, ek:int, sk:int):lng ",	"second_interval;",	"cast hge to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"pattern calc.second_interval(v:int, ek:int, sk:int):lng ",	"second_interval;",	"cast int to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"pattern calc.second_interval(v:lng, ek:int, sk:int):lng ",	"second_interval;",	"cast lng to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"pattern calc.second_interval(v:sht, ek:int, sk:int):lng ",	"second_interval;",	"cast sht to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"command calc.second_interval(v:daytime, ek:int, sk:int):lng ",	"second_interval_daytime;",	"cast daytime to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"command calc.second_interval(v:str, ek:int, sk:int):lng ",	"second_interval_str;",	"cast str to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"command calc.second_interval(sc:int, v:sht, ek:int, sk:int):lng ",	"sht_dec2second_interval;",	"cast sht decimal to a second_interval"	]
[ "calc",	"sht",	"pattern calc.sht(v:bit):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:bte):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:dbl):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:flt):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:hge):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:int):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:lng):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:oid):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:sht):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:str):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:void):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"command calc.sht(s1:int, v:bte):sht ",	"bte_dec2_sht;",	"cast decimal(bte) to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int, v:bte, d2:int, s2:int):sht ",	"bte_dec2dec_sht;",	"cast decimal(bte) to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:bte, digits:int, scale:int):sht ",	"bte_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:dbl, digits:int, scale:int):sht ",	"dbl_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:flt, digits:int, scale:int):sht ",	"flt_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int, v:hge):sht ",	"hge_dec2_sht;",	"cast decimal(hge) to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int, v:hge, d2:int, s2:int):sht ",	"hge_dec2dec_sht;",	"cast decimal(hge) to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:hge, digits:int, scale:int):sht ",	"hge_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int, v:int):sht ",	"int_dec2_sht;",	"cast decimal(int) to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int, v:int, d2:int, s2:int):sht ",	"int_dec2dec_sht;",	"cast decimal(int) to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:int, digits:int, scale:int):sht ",	"int_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int, v:lng):sht ",	"lng_dec2_sht;",	"cast decimal(lng) to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int, v:lng, d2:int, s2:int):sht ",	"lng_dec2dec_sht;",	"cast decimal(lng) to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:lng, digits:int, scale:int):sht ",	"lng_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:void, digits:int, scale:int):sht ",	"nil_2dec_sht;",	"cast to dec(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int, v:sht):sht ",	"sht_dec2_sht;",	"cast decimal(sht) to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int, v:sht, d2:int, s2:int):sht ",	"sht_dec2dec_sht;",	"cast decimal(sht) to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:sht, digits:int, scale:int):sht ",	"sht_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:str, digits:int, scale:int):sht ",	"str_2dec_sht;",	"cast to dec(sht) and check for overflow"	]
[ "calc",	"sign",	"pattern calc.sign(v:bte):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:dbl):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:flt):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:hge):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:int):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:lng):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:sht):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"str",	"pattern calc.str(v:any):str ",	"CMDvarCONVERT;",	"Cast VALUE to str"	]
[ "calc",	"str",	"command calc.str(v:blob):str ",	"SQLblob_2_str;",	"cast blob to str"	]
[ "calc",	"str",	"command calc.str(v:date):str ",	"SQLdate_2_str;",	"cast date to str"	]
[ "calc",	"str",	"pattern calc.str(eclass:int, d1:int, s1:int, has_tz:int, v:any_1, digits:int):str ",	"SQLstr_cast;",	"cast to string and check for overflow"	]
[ "calc",	"str",	"command calc.str(s:uuid):str ",	"UUIDuuid2str;",	"Coerce a uuid to a string type"	]
[ "calc",	"strings",	"command calc.strings(v:str):str ",	"STRstrings;",	"Return the strings"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte, v2:bte):bte ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte, v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte, v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte, v2:hge):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte, v2:int):int ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte, v2:lng):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte, v2:sht):sht ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl, v2:bte):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl, v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl, v2:flt):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl, v2:hge):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl, v2:int):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl, v2:lng):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl, v2:sht):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt, v2:bte):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt, v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt, v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt, v2:hge):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt, v2:int):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt, v2:lng):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt, v2:sht):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge, v2:bte):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge, v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge, v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge, v2:hge):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge, v2:int):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge, v2:lng):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge, v2:sht):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int, v2:bte):int ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int, v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int, v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int, v2:hge):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int, v2:int):int ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int, v2:lng):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int, v2:sht):int ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng, v2:bte):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng, v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng, v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng, v2:hge):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng, v2:int):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng, v2:lng):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng, v2:sht):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht, v2:bte):sht ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht, v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht, v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht, v2:hge):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht, v2:int):int ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht, v2:lng):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht, v2:sht):sht ",	"CMDvarSUB;",	"Return V1 - V2, overflow results in NIL value"	]
[ "calc",	"substring",	"command calc.substring(s:str, offset:int, count:int):str ",	"STRsubstring;",	""	]
[ "calc",	"substring",	"command calc.substring(s:str, offset:int):str ",	"STRsubstringTail;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(d:date):timestamp ",	"MTIMEtimestamp_fromdate;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(msecs:lng):timestamp ",	"MTIMEtimestamp_frommsec;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(secs:int):timestamp ",	"MTIMEtimestamp_fromsecond;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(s:str):timestamp ",	"MTIMEtimestamp_fromstr;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(t:timestamp):timestamp ",	"MTIMEtimestamp_timestamp;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(v:date, d:int):timestamp ",	"date_2_timestamp;",	"cast date to a timestamp and check for overflow"	]
[ "calc",	"timestamp",	"command calc.timestamp(v:void, digits:int):timestamp ",	"nil_2time_timestamp;",	"cast to timestamp and check for overflow"	]
[ "calc",	"timestamp",	"command calc.timestamp(v:str, digits:int):timestamp ",	"str_2time_timestamp;",	"cast to timestamp and check for overflow"	]
[ "calc",	"timestamp",	"command calc.timestamp(v:str, digits:int, has_tz:int):timestamp ",	"str_2time_timestamptz;",	"cast to timestamp and check for overflow"	]
[ "calc",	"timestamp",	"command calc.timestamp(v:timestamp, digits:int):timestamp ",	"timestamp_2time_timestamp;",	"cast timestamp to timestamp and check for overflow"	]
[ "calc",	"url",	"command calc.url(s:str):url ",	"URLnew;",	"Create an URL from a string literal"	]
[ "calc",	"url",	"command calc.url(s:url):url ",	"URLnoop;",	"Create an URL from a string literal"	]
[ "calc",	"uuid",	"function calc.uuid(u:uuid):uuid;",	"",	""	]
[ "calc",	"uuid",	"command calc.uuid(s:str):uuid ",	"UUIDstr2uuid;",	"Coerce a string to a uuid, validating its format"	]
[ "calc",	"void",	"pattern calc.void(v:bit):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:bte):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:dbl):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:flt):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:hge):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:int):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:lng):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:oid):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:sht):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:str):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:void):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"wkb",	"function calc.wkb(wkt:str, srid:int, type:int):wkb;",	"",	""	]
[ "calc",	"wkb",	"command calc.wkb(geo:wkb, columnType:int, columnSRID:int):wkb ",	"geom_2_geom;",	"Called when inserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition"	]
[ "calc",	"wkb",	"command calc.wkb(v:wkb):wkb ",	"wkbFromWKB;",	"It is called when adding a new geometry column to an existing table"	]
[ "calc",	"xml",	"command calc.xml(src:str):xml ",	"XMLstr2xml;",	""	]
[ "calc",	"xml",	"command calc.xml(src:xml):xml ",	"XMLxml2xml;",	""	]
[ "calc",	"xor",	"pattern calc.xor(v1:bit, v2:bit):bit ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "calc",	"xor",	"pattern calc.xor(v1:bte, v2:bte):bte ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "calc",	"xor",	"pattern calc.xor(v1:hge, v2:hge):hge ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "calc",	"xor",	"pattern calc.xor(v1:int, v2:int):int ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "calc",	"xor",	"pattern calc.xor(v1:lng, v2:lng):lng ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "calc",	"xor",	"pattern calc.xor(v1:sht, v2:sht):sht ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "capi",	"eval",	"pattern capi.eval(fptr:ptr, cpp:bit, expr:str):any ",	"CUDFevalStd;",	"Execute a simple CUDF script returning a single value"	]
[ "capi",	"eval",	"pattern capi.eval(fptr:ptr, cpp:bit, expr:str, arg:any...):any... ",	"CUDFevalStd;",	"Execute a simple CUDF script value"	]
[ "capi",	"eval_aggr",	"pattern capi.eval_aggr(fptr:ptr, cpp:bit, expr:str, arg:any...):any... ",	"CUDFevalAggr;",	"grouped aggregates through CUDF"	]
[ "capi",	"prelude",	"command capi.prelude():void ",	"CUDFprelude;",	""	]
[ "capi",	"subeval_aggr",	"pattern capi.subeval_aggr(fptr:ptr, cpp:bit, expr:str, arg:any...):any... ",	"CUDFevalAggr;",	"grouped aggregates through CUDF"	]
[ "clients",	"addUser",	"pattern clients.addUser(nme:str, pw:str):oid ",	"CLTaddUser;",	"Allow user with password access to the given scenarios"	]
[ "clients",	"backendsum",	"command clients.backendsum(pw:str):str ",	"CLTbackendsum;",	"Return hex string representation of the currently used hash of the given string"	]
[ "clients",	"changePassword",	"pattern clients.changePassword(old:str, new:str):void ",	"CLTchangePassword;",	"Change the password for the current user"	]
[ "clients",	"changeUsername",	"pattern clients.changeUsername(old:str, new:str):void ",	"CLTchangeUsername;",	"Change the username of the user into the new string"	]
[ "clients",	"checkPermission",	"pattern clients.checkPermission(usr:str, pw:str):void ",	"CLTcheckPermission;",	"Check permission for a user, requires hashed password (backendsum)"	]
[ "clients",	"getId",	"pattern clients.getId():int ",	"CLTgetClientId;",	"Return a number that uniquely represents the current client."	]
[ "clients",	"getInfo",	"pattern clients.getInfo() (X_0:bat[:str], X_1:bat[:str]) ",	"CLTInfo;",	"Pseudo bat with client attributes."	]
[ "clients",	"getLogins",	"command clients.getLogins() (user:bat[:oid], start:bat[:str]) ",	"CLTLogin;",	"Pseudo bat of client id and login time."	]
[ "clients",	"getPasswordHash",	"pattern clients.getPasswordHash(user:str):str ",	"CLTgetPasswordHash;",	"Return the password hash of the given user"	]
[ "clients",	"getScenario",	"pattern clients.getScenario():str ",	"CLTgetScenario;",	"Retrieve current scenario name."	]
[ "clients",	"getUsername",	"pattern clients.getUsername():str ",	"CLTgetUsername;",	"Return the username of the currently logged in user"	]
[ "clients",	"getUsers",	"pattern clients.getUsers() (X_0:bat[:oid], X_1:bat[:str]) ",	"CLTgetUsers;",	"return a BAT with user id and one with name available in the system"	]
[ "clients",	"getprofile",	"pattern clients.getprofile() (opt:str, q:int, s:int, w:int, m:int) ",	"CLTgetProfile;",	"Retrieve the profile settings for a client"	]
[ "clients",	"md5sum",	"command clients.md5sum(pw:str):str ",	"CLTmd5sum;",	"Return hex string representation of the MD5 hash of the given string"	]
[ "clients",	"quit",	"pattern clients.quit():void ",	"CLTquit;",	"Terminate the client session."	]
[ "clients",	"quit",	"pattern clients.quit(idx:int):void ",	"CLTquit;",	"Terminate the session for a single client using a soft error.\nIt is the privilige of the console user."	]
[ "clients",	"removeUser",	"pattern clients.removeUser(nme:str):void ",	"CLTremoveUser;",	"Remove the given user from the system"	]
[ "clients",	"ripemd160sum",	"command clients.ripemd160sum(pw:str):str ",	"CLTripemd160sum;",	"Return hex string representation of the RIPEMD160 hash of the given string"	]
[ "clients",	"setListing",	"pattern clients.setListing(flag:int):int ",	"CLTsetListing;",	"Turn on/off echo of MAL instructions:\n\t1 - echo input,\n\t2 - show mal instruction,\n\t4 - show details of type resolutoin, \n\t8 - show binding information."	]
[ "clients",	"setPassword",	"pattern clients.setPassword(user:str, pass:str):void ",	"CLTsetPassword;",	"Set the password for the given user"	]
[ "clients",	"setScenario",	"pattern clients.setScenario(msg:str):str ",	"CLTsetScenario;",	"Switch to other scenario handler, return previous one."	]
[ "clients",	"setmemorylimit",	"pattern clients.setmemorylimit(n:int):void ",	"CLTsetmemorylimit;",	""	]
[ "clients",	"setmemorylimit",	"pattern clients.setmemorylimit(sid:int, n:int):void ",	"CLTsetmemorylimit;",	"Limit the memory claim in MB per query"	]
[ "clients",	"setoptimizer",	"pattern clients.setoptimizer(opt:str):void ",	"CLTsetoptimizer;",	""	]
[ "clients",	"setoptimizer",	"pattern clients.setoptimizer(sid:int, opt:str):void ",	"CLTsetoptimizer;",	"Set the session optimizer"	]
[ "clients",	"setprinttimeout",	"command clients.setprinttimeout(n:int):void ",	"CLTsetPrintTimeout;",	"Print running query every so many seconds."	]
[ "clients",	"setquerytimeout",	"pattern clients.setquerytimeout(n:int):void ",	"CLTqueryTimeout;",	""	]
[ "clients",	"setquerytimeout",	"pattern clients.setquerytimeout(sid:bte, n:int):void ",	"CLTqueryTimeout;",	""	]
[ "clients",	"setquerytimeout",	"pattern clients.setquerytimeout(sid:int, n:int):void ",	"CLTqueryTimeout;",	"A query is aborted after q seconds (q=0 means run undisturbed)."	]
[ "clients",	"setquerytimeout",	"pattern clients.setquerytimeout(sid:sht, n:int):void ",	"CLTqueryTimeout;",	""	]
[ "clients",	"setsession",	"pattern clients.setsession(n:lng):void ",	"CLTsetSessionTimeout;",	"Abort a session after  n seconds."	]
[ "clients",	"setsessiontimeout",	"pattern clients.setsessiontimeout(n:int):void ",	"CLTsessionTimeout;",	""	]
[ "clients",	"setsessiontimeout",	"pattern clients.setsessiontimeout(sid:bte, n:int):void ",	"CLTsessionTimeout;",	""	]
[ "clients",	"setsessiontimeout",	"pattern clients.setsessiontimeout(sid:int, n:int):void ",	"CLTsessionTimeout;",	"Set the session timeout for a particulat session id"	]
[ "clients",	"setsessiontimeout",	"pattern clients.setsessiontimeout(sid:sht, n:int):void ",	"CLTsessionTimeout;",	""	]
[ "clients",	"settimeout",	"pattern clients.settimeout(n:lng):void ",	"CLTsetTimeout;",	"Abort a query after  n seconds."	]
[ "clients",	"settimeout",	"pattern clients.settimeout(q:lng, s:lng):void ",	"CLTsetTimeout;",	"Abort a query after q seconds (q=0 means run undisturbed).\nThe session timeout aborts the connection after spending too\nmany seconds on query processing."	]
[ "clients",	"setworkerlimit",	"pattern clients.setworkerlimit(n:int):void ",	"CLTsetworkerlimit;",	""	]
[ "clients",	"setworkerlimit",	"pattern clients.setworkerlimit(sid:int, n:int):void ",	"CLTsetworkerlimit;",	"Limit the number of worker threads per query"	]
[ "clients",	"sha1sum",	"command clients.sha1sum(pw:str):str ",	"CLTsha1sum;",	"Return hex string representation of the SHA-1 hash of the given string"	]
[ "clients",	"sha2sum",	"command clients.sha2sum(pw:str, bits:int):str ",	"CLTsha2sum;",	"Return hex string representation of the SHA-2 hash with bits of the given string"	]
[ "clients",	"shutdown",	"pattern clients.shutdown(delay:int):str ",	"CLTshutdown;",	""	]
[ "clients",	"shutdown",	"pattern clients.shutdown(delay:int, forced:bit):str ",	"CLTshutdown;",	"Close all other client connections. Return if it succeeds.\nIf forced is set then always stop the system the hard way"	]
[ "clients",	"stop",	"pattern clients.stop(id:int):void ",	"CLTstop;",	"Stop the query execution at the next eligble statement."	]
[ "clients",	"stopsession",	"pattern clients.stopsession(sid:bte):void ",	"CLTstopSession;",	""	]
[ "clients",	"stopsession",	"pattern clients.stopsession(sid:int):void ",	"CLTstopSession;",	"Stop a particular session"	]
[ "clients",	"stopsession",	"pattern clients.stopsession(sid:sht):void ",	"CLTstopSession;",	""	]
[ "clients",	"suspend",	"pattern clients.suspend(id:int):void ",	"CLTsuspend;",	"Put a client process to sleep for some time.\nIt will simple sleep for a second at a time, until\nthe awake bit has been set in its descriptor"	]
[ "clients",	"wakeup",	"pattern clients.wakeup(id:int):void ",	"CLTwakeup;",	"Wakeup a client process"	]
[ "color",	"#fromstr",	"command color.#fromstr():void ",	"color_fromstr;",	""	]
[ "color",	"#tostr",	"command color.#tostr():void ",	"color_tostr;",	""	]
[ "color",	"blue",	"command color.blue(c:color):int ",	"CLRblue;",	"Extracts blue component from a color atom"	]
[ "color",	"cb",	"command color.cb(c:color):int ",	"CLRcb;",	"Extracts Cb(blue color) component from a color atom"	]
[ "color",	"color",	"command color.color(s:str):color ",	"CLRcolor;",	"Converts string to color"	]
[ "color",	"cr",	"command color.cr(c:color):int ",	"CLRcr;",	"Extracts Cr(red color) component from a color atom"	]
[ "color",	"green",	"command color.green(c:color):int ",	"CLRgreen;",	"Extracts green component from a color atom"	]
[ "color",	"hsv",	"command color.hsv(h:flt, s:flt, v:flt):color ",	"CLRhsv;",	"Converts an HSV triplets to a color atom"	]
[ "color",	"hue",	"command color.hue(c:color):flt ",	"CLRhue;",	"Extracts hue component from a color atom"	]
[ "color",	"hue",	"command color.hue(c:color):int ",	"CLRhueInt;",	"Extracts hue component from a color atom"	]
[ "color",	"luminance",	"command color.luminance(c:color):int ",	"CLRluminance;",	"Extracts Y(luminance) component from a color atom"	]
[ "color",	"red",	"command color.red(c:color):int ",	"CLRred;",	"Extracts red component from a color atom"	]
[ "color",	"rgb",	"command color.rgb(r:int, g:int, b:int):color ",	"CLRrgb;",	"Converts an RGB triplets to a color atom"	]
[ "color",	"saturation",	"command color.saturation(c:color):flt ",	"CLRsaturation;",	"Extracts saturation component from a color atom"	]
[ "color",	"saturation",	"command color.saturation(c:color):int ",	"CLRsaturationInt;",	"Extracts saturation component from a color atom"	]
[ "color",	"str",	"command color.str(s:color):str ",	"CLRstr;",	"Converts color to string "	]
[ "color",	"value",	"command color.value(c:color):flt ",	"CLRvalue;",	"Extracts value component from a color atom"	]
[ "color",	"value",	"command color.value(c:color):int ",	"CLRvalueInt;",	"Extracts value component from a color atom"	]
[ "color",	"ycc",	"command color.ycc(y:int, cr:int, cb:int):color ",	"CLRycc;",	"Converts an YCC triplets to a color atom"	]
[ "factories",	"getArrival",	"command factories.getArrival():bat[:timestamp] ",	"FCTgetArrival;",	"Retrieve the time stamp the last call was made."	]
[ "factories",	"getCaller",	"command factories.getCaller():int ",	"FCTgetCaller;",	"Retrieve the unique identity of the factory caller."	]
[ "factories",	"getDeparture",	"command factories.getDeparture():bat[:timestamp] ",	"FCTgetDeparture;",	"Retrieve the time stamp the last answer was returned."	]
[ "factories",	"getOwners",	"command factories.getOwners():bat[:str] ",	"FCTgetOwners;",	"Retrieve the factory owners table."	]
[ "factories",	"getPlants",	"command factories.getPlants() (mod:bat[:str], fcn:bat[:str]) ",	"FCTgetPlants;",	"Retrieve the names for all active factories."	]
[ "factories",	"shutdown",	"pattern factories.shutdown(m:str, f:str):void ",	"FCTshutdown;",	"Close a factory."	]
[ "fits",	"attach",	"pattern fits.attach(fname:str):void ",	"FITSattach;",	"Open a FITS file and return catalog of the table HDUs"	]
[ "fits",	"export",	"pattern fits.export(tablename:str):void ",	"FITSexportTable;",	"Export a table to a FITS file"	]
[ "fits",	"fitstest",	"command fits.fitstest(filename:str):int ",	"FITStest;",	"Returns the type of first extension in the FITS file filename"	]
[ "fits",	"listdir",	"pattern fits.listdir(dirname:str):void ",	"FITSdir;",	"Attach all FITS files in the directory"	]
[ "fits",	"listdirpattern",	"pattern fits.listdirpattern(dirname:str, pattern:str):void ",	"FITSdirpat;",	"Attach all FITS file in the directory, giving a pattern"	]
[ "fits",	"load",	"pattern fits.load(tablename:str):void ",	"FITSloadTable;",	"Load a FITS table from an attached file"	]
[ "generator",	"join",	"pattern generator.join(b:bat[:bte], gen:bat[:bte]) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_join;",	""	]
[ "generator",	"join",	"pattern generator.join(b:bat[:dbl], gen:bat[:dbl]) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_join;",	"Overloaded join operation"	]
[ "generator",	"join",	"pattern generator.join(b:bat[:flt], gen:bat[:flt]) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_join;",	""	]
[ "generator",	"join",	"pattern generator.join(b:bat[:hge], gen:bat[:hge]) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_join;",	"Overloaded join operation"	]
[ "generator",	"join",	"pattern generator.join(b:bat[:int], gen:bat[:int]) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_join;",	""	]
[ "generator",	"join",	"pattern generator.join(b:bat[:lng], gen:bat[:lng]) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_join;",	""	]
[ "generator",	"join",	"pattern generator.join(b:bat[:sht], gen:bat[:sht]) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_join;",	""	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:bte], low:bat[:bte], hgh:bat[:bte], li:bit, ri:bit) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	""	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:dbl], low:bat[:dbl], hgh:bat[:dbl], li:bit, ri:bit) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	"Overloaded range join operation"	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:flt], low:bat[:flt], hgh:bat[:flt], li:bit, ri:bit) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	""	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:int], low:bat[:int], hgh:bat[:int], li:bit, ri:bit) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	""	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:lng], low:bat[:lng], hgh:bat[:lng], li:bit, ri:bit) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	""	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:sht], low:bat[:sht], hgh:bat[:sht], li:bit, ri:bit) (l:bat[:oid], r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:bte, limit:bte):bat[:bte] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:bte, limit:bte, step:bte):bat[:bte] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:dbl, limit:dbl):bat[:dbl] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:dbl, limit:dbl, step:dbl):bat[:dbl] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:flt, limit:flt):bat[:flt] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:flt, limit:flt, step:flt):bat[:flt] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:hge, limit:hge):bat[:hge] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:hge, limit:hge, step:hge):bat[:hge] ",	"VLTgenerator_noop;",	"Retain the table definition, but don't materialize"	]
[ "generator",	"parameters",	"pattern generator.parameters(first:int, limit:int):bat[:int] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:int, limit:int, step:int):bat[:int] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:lng, limit:lng):bat[:lng] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:lng, limit:lng, step:lng):bat[:lng] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:sht, limit:sht):bat[:sht] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:sht, limit:sht, step:sht):bat[:sht] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:timestamp, limit:timestamp, step:lng):bat[:timestamp] ",	"VLTgenerator_noop;",	"Retain the table definition, but don't materialize"	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid], cand:bat[:bte]):bat[:bte] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid], cand:bat[:dbl]):bat[:dbl] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid], cand:bat[:flt]):bat[:flt] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid], cand:bat[:hge]):bat[:hge] ",	"VLTgenerator_projection;",	"Overloaded projection operation"	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid], cand:bat[:int]):bat[:int] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid], cand:bat[:lng]):bat[:lng] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid], cand:bat[:sht]):bat[:sht] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid], cand:bat[:timestamp]):bat[:timestamp] ",	"VLTgenerator_projection;",	"Overloaded projection operation"	]
[ "generator",	"select",	"pattern generator.select(b:bat[:bte], cand:bat[:oid], low:bte, high:bte, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:bte], low:bte, high:bte, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:dbl], cand:bat[:oid], low:dbl, high:dbl, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:dbl], low:dbl, high:dbl, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:flt], cand:bat[:oid], low:flt, high:flt, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:flt], low:flt, high:flt, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:hge], cand:bat[:oid], low:hge, high:hge, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	"Overloaded selection routine"	]
[ "generator",	"select",	"pattern generator.select(b:bat[:hge], low:hge, high:hge, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	"Overloaded selection routine"	]
[ "generator",	"select",	"pattern generator.select(b:bat[:int], cand:bat[:oid], low:int, high:int, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:int], low:int, high:int, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:lng], cand:bat[:oid], low:lng, high:lng, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:lng], low:lng, high:lng, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:sht], cand:bat[:oid], low:sht, high:sht, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:sht], low:sht, high:sht, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"select",	"pattern generator.select(b:bat[:timestamp], cand:bat[:oid], low:timestamp, high:timestamp, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	"Overloaded selection routine"	]
[ "generator",	"select",	"pattern generator.select(b:bat[:timestamp], low:timestamp, high:timestamp, li:bit, hi:bit, anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	"Overloaded selection routine"	]
[ "generator",	"series",	"pattern generator.series(first:bte, limit:bte):bat[:bte] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:bte, limit:bte, step:bte):bat[:bte] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:dbl, limit:dbl):bat[:dbl] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:dbl, limit:dbl, step:dbl):bat[:dbl] ",	"VLTgenerator_table;",	"Create and materialize a generator table"	]
[ "generator",	"series",	"pattern generator.series(first:flt, limit:flt):bat[:flt] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:flt, limit:flt, step:flt):bat[:flt] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:hge, limit:hge):bat[:hge] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:hge, limit:hge, step:hge):bat[:hge] ",	"VLTgenerator_table;",	"Create and materialize a generator table"	]
[ "generator",	"series",	"pattern generator.series(first:int, limit:int):bat[:int] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:int, limit:int, step:int):bat[:int] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:lng, limit:lng):bat[:lng] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:lng, limit:lng, step:lng):bat[:lng] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:sht, limit:sht):bat[:sht] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:sht, limit:sht, step:sht):bat[:sht] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:timestamp, limit:timestamp, step:lng):bat[:timestamp] ",	"VLTgenerator_table;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:bte], cnd:bat[:oid], low:bte, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:bte], low:bte, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:dbl], cnd:bat[:oid], low:dbl, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:dbl], low:dbl, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:flt], cnd:bat[:oid], low:flt, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:flt], low:flt, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:hge], cnd:bat[:oid], low:hge, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	"Overloaded selection routine"	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:hge], low:hge, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	"Overloaded selection routine"	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:int], cnd:bat[:oid], low:int, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:int], low:int, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:lng], cnd:bat[:oid], low:lng, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:lng], low:lng, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:sht], cnd:bat[:oid], low:sht, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:sht], low:sht, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:timestamp], cnd:bat[:oid], low:timestamp, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	"Overloaded selection routine"	]
[ "generator",	"thetaselect",	"pattern generator.thetaselect(b:bat[:timestamp], low:timestamp, oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	"Overloaded selection routine"	]
[ "geom",	"Area",	"command geom.Area(w:wkb):dbl ",	"wkbArea;",	"Returns the area of the surface if it is a polygon or multi-polygon"	]
[ "geom",	"AsBinary",	"command geom.AsBinary(w:wkb):str ",	"wkbAsBinary;",	"Returns the wkb representation into HEX format"	]
[ "geom",	"AsEWKT",	"function geom.AsEWKT(w:wkb):str;",	"",	""	]
[ "geom",	"AsText",	"function geom.AsText(w:wkb):str;",	"",	""	]
[ "geom",	"BdMPolyFromText",	"function geom.BdMPolyFromText(wkt:str, srid:int):wkb;",	"",	""	]
[ "geom",	"BdPolyFromText",	"function geom.BdPolyFromText(wkt:str, srid:int):wkb;",	"",	""	]
[ "geom",	"Boundary",	"command geom.Boundary(w:wkb):wkb ",	"wkbBoundary;",	"Returns the closure of the combinatorial boundary of the Geometry."	]
[ "geom",	"Buffer",	"command geom.Buffer(a:wkb, distance:dbl):wkb ",	"wkbBuffer;",	"Returns a geometry that represents all points whose distance from this geometry is less than or equal to distance. Calculations are in the Spatial Reference System of this Geometry."	]
[ "geom",	"Centroid",	"command geom.Centroid(w:wkb):wkb ",	"wkbCentroid;",	"Computes the geometric center of a geometry, or equivalently, the center of mass of the geometry as a POINT."	]
[ "geom",	"Contains",	"command geom.Contains(a:wkb, b:wkb):bit ",	"wkbContains;",	"Returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A."	]
[ "geom",	"Contains",	"command geom.Contains(a:wkb, x:dbl, y:dbl):bit ",	"wkbContains_point;",	"Returns true if the Geometry a 'spatially contains' Geometry b"	]
[ "geom",	"Contains",	"command geom.Contains(a:wkb, px:bat[:dbl], py:bat[:dbl]):bat[:bit] ",	"wkbContains_point_bat;",	"Returns true if the Geometry-BAT a 'spatially contains' Geometry-B b"	]
[ "geom",	"ConvexHull",	"command geom.ConvexHull(w:wkb):wkb ",	"wkbConvexHull;",	"Returns a geometry that represents the convex hull of this geometry. The convex hull of a geometry represents the minimum convex geometry that encloses all geometries within the set."	]
[ "geom",	"CoordDim",	"command geom.CoordDim(w:wkb):int ",	"wkbCoordDim;",	" Return the coordinate dimension of the geometry"	]
[ "geom",	"CoveredBy",	"command geom.CoveredBy(a:wkb, b:wkb):bit ",	"wkbCoveredBy;",	"Returns TRUE if no point of geometry A is outside geometry B"	]
[ "geom",	"Covers",	"command geom.Covers(a:wkb, b:wkb):bit ",	"wkbCovers;",	"Returns TRUE if no point of geometry B is outside geometry A"	]
[ "geom",	"Crosses",	"command geom.Crosses(a:wkb, b:wkb):bit ",	"wkbCrosses;",	"Returns TRUE if the supplied geometries have some, but not all, interior points in common."	]
[ "geom",	"DWithin",	"command geom.DWithin(a:wkb, b:wkb, dst:dbl):bit ",	"wkbDWithin;",	"Returns true if the two geometries are within the specifies distance from each other"	]
[ "geom",	"DelaunayTriangles",	"command geom.DelaunayTriangles(a:wkb, tolerance:dbl, flag:int):wkb ",	"wkbDelaunayTriangles;",	"Returns a Delaunay triangulation, flag=0 => collection of polygons, flag=1 => multilinestring"	]
[ "geom",	"Difference",	"command geom.Difference(a:wkb, b:wkb):wkb ",	"wkbDifference;",	"Returns a geometry that represents that part of geometry A that does not intersect with geometry B"	]
[ "geom",	"Dimension",	"command geom.Dimension(w:wkb):int ",	"wkbDimension;",	"The inherent dimension of this Geometry object, which must be less than or equal to the coordinate dimension."	]
[ "geom",	"Disjoint",	"command geom.Disjoint(a:wkb, b:wkb):bit ",	"wkbDisjoint;",	"Returns true if these Geometries are 'spatially disjoint'"	]
[ "geom",	"Distance",	"command geom.Distance(a:wkb, b:wkb):dbl ",	"wkbDistance;",	"Returns the 2-dimensional minimum cartesian distance between the two geometries in projected units (spatial ref units."	]
[ "geom",	"Dump",	"command geom.Dump(a:wkb) (id:bat[:str], geom:bat[:wkb]) ",	"wkbDump;",	"Gets a MultiPolygon and returns the Polygons in it"	]
[ "geom",	"DumpPoints",	"command geom.DumpPoints(a:wkb) (id:bat[:str], geom:bat[:wkb]) ",	"wkbDumpPoints;",	"Gets a Geometry and returns the Points in it"	]
[ "geom",	"EndPoint",	"command geom.EndPoint(w:wkb):wkb ",	"wkbEndPoint;",	"Returns the last point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING."	]
[ "geom",	"Envelope",	"command geom.Envelope(w:wkb):wkb ",	"wkbEnvelope;",	"The minimum bounding box for this Geometry, returned as a Geometry. The polygon is defined by the corner points of the bounding box ((MINX,MINY),(MAXX,MINY),(MAXX,MAXY),(MINX,MAXY))."	]
[ "geom",	"EnvelopeFromCoordinates",	"command geom.EnvelopeFromCoordinates(X_0:dbl, X_1:dbl, X_2:dbl, X_3:dbl, X_4:int):wkb ",	"wkbEnvelopeFromCoordinates;",	"A polygon created by the provided coordinates"	]
[ "geom",	"Equals",	"command geom.Equals(a:wkb, b:wkb):bit ",	"wkbEquals;",	"Returns true if the given geometries represent the same geometry. Directionality is ignored."	]
[ "geom",	"ExteriorRing",	"command geom.ExteriorRing(w:wkb):wkb ",	"wkbExteriorRing;",	"Returns a line string representing the exterior ring of the POLYGON geometry. Return NULL if the geometry is not a polygon."	]
[ "geom",	"Force2D",	"function geom.Force2D(g:wkb):wkb;",	"",	""	]
[ "geom",	"Force3D",	"function geom.Force3D(g:wkb):wkb;",	"",	""	]
[ "geom",	"ForceDimensions",	"command geom.ForceDimensions(g:wkb, d:int):wkb ",	"wkbForceDim;",	"Removes or Adds additional coordinates in the geometry to make it d dimensions"	]
[ "geom",	"FromBinary",	"command geom.FromBinary(w:str):wkb ",	"wkbFromBinary;",	"Creates a wkb using the HEX representation"	]
[ "geom",	"FromText",	"command geom.FromText(wkt:str, srid:int, type:int):wkb ",	"wkbFromText;",	""	]
[ "geom",	"GeomCollFromText",	"function geom.GeomCollFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"GeomCollFromText",	"function geom.GeomCollFromText(wkt:str, srid:int):wkb;",	"",	""	]
[ "geom",	"GeomFromText",	"function geom.GeomFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"GeomFromText",	"function geom.GeomFromText(wkt:str, srid:int):wkb;",	"",	""	]
[ "geom",	"GeometryN",	"command geom.GeometryN(g:wkb, n:int):wkb ",	"wkbGeometryN;",	"Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON. Otherwise, return NULL"	]
[ "geom",	"GeometryType",	"command geom.GeometryType(w:wkb, flag:int):str ",	"wkbGeometryType;",	""	]
[ "geom",	"GeometryType1",	"function geom.GeometryType1(w:wkb):str;",	"",	""	]
[ "geom",	"GeometryType2",	"function geom.GeometryType2(w:wkb):str;",	"",	""	]
[ "geom",	"GetCoordinate",	"command geom.GetCoordinate(w:wkb, idx:int):dbl ",	"wkbGetCoordinate;",	"Returns the coordinate at position idx of a point, or NULL if not available. idx=0 -> X, idx=1 -> Y, idx=2 -> Z. Input must be point"	]
[ "geom",	"InteriorRingN",	"command geom.InteriorRingN(w:wkb, n:int):wkb ",	"wkbInteriorRingN;",	"Return the Nth interior linestring ring of the polygon geometry. Return NULL if the geometry is not a polygon or the given N is out of range."	]
[ "geom",	"InteriorRings",	"command geom.InteriorRings(w:wkb):wkba ",	"wkbInteriorRings;",	"Returns an 'array' with all the interior rings of the polygon"	]
[ "geom",	"Intersection",	"command geom.Intersection(a:wkb, b:wkb):wkb ",	"wkbIntersection;",	"Returns a geometry that represents the point set intersection of the Geometries a, b"	]
[ "geom",	"Intersects",	"command geom.Intersects(a:wkb, b:wkb):bit ",	"wkbIntersects;",	"Returns true if these Geometries 'spatially intersect in 2D'"	]
[ "geom",	"IsClosed",	"command geom.IsClosed(w:wkb):bit ",	"wkbIsClosed;",	"Returns TRUE if the LINESTRING's start and end points are coincident."	]
[ "geom",	"IsEmpty",	"command geom.IsEmpty(w:wkb):bit ",	"wkbIsEmpty;",	"Returns true if this Geometry is an empty geometry."	]
[ "geom",	"IsRing",	"command geom.IsRing(w:wkb):bit ",	"wkbIsRing;",	"Returns TRUE if this LINESTRING is both closed and simple."	]
[ "geom",	"IsSimple",	"command geom.IsSimple(w:wkb):bit ",	"wkbIsSimple;",	"Returns (TRUE) if this Geometry has no anomalous geometric points, such as self intersection or self tangency."	]
[ "geom",	"IsValid",	"command geom.IsValid(w:wkb):bit ",	"wkbIsValid;",	"Returns true if the ST_Geometry is well formed."	]
[ "geom",	"IsValidDetail",	"command geom.IsValidDetail(w:wkb):str ",	"wkbIsValidDetail;",	"Returns a valid_detail (valid,reason,location) row stating if a geometry is valid or not and if not valid, a reason why and a location where."	]
[ "geom",	"IsValidReason",	"command geom.IsValidReason(w:wkb):str ",	"wkbIsValidReason;",	"Returns text stating if a geometry is valid or not and if not valid, a reason why."	]
[ "geom",	"Length",	"command geom.Length(w:wkb):dbl ",	"wkbLength;",	"Returns the cartesian 2D length of the geometry if it is a linestrin or multilinestring"	]
[ "geom",	"LineFromText",	"function geom.LineFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"LineFromText",	"function geom.LineFromText(wkt:str, srid:int):wkb;",	"",	""	]
[ "geom",	"MLineFromText",	"function geom.MLineFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"MLineFromText",	"function geom.MLineFromText(wkt:str, srid:int):wkb;",	"",	""	]
[ "geom",	"MLineStringToPolygon",	"command geom.MLineStringToPolygon(wkt:str, srid:int, flag:int):wkb ",	"wkbMLineStringToPolygon;",	"Creates polygons using the MultiLineString provided as WKT. Depending on the flag creates one (flag=0) or multiple (flag=1) polygons"	]
[ "geom",	"MPointFromText",	"function geom.MPointFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"MPointFromText",	"function geom.MPointFromText(wkt:str, srid:int):wkb;",	"",	""	]
[ "geom",	"MPolyFromText",	"function geom.MPolyFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"MPolyFromText",	"function geom.MPolyFromText(wkt:str, srid:int):wkb;",	"",	""	]
[ "geom",	"MakeBox2D",	"command geom.MakeBox2D(X_0:wkb, X_1:wkb):mbr ",	"wkbBox2D;",	"Creates an mbr from the two 2D points"	]
[ "geom",	"MakeEnvelope",	"function geom.MakeEnvelope(xmin:dbl, ymin:dbl, xmax:dbl, ymax:dbl):wkb;",	"",	""	]
[ "geom",	"MakeEnvelope",	"function geom.MakeEnvelope(xmin:dbl, ymin:dbl, xmax:dbl, ymax:dbl, srid:int):wkb;",	"",	""	]
[ "geom",	"MakeLine",	"command geom.MakeLine(a:wkb, b:wkb):wkb ",	"wkbMakeLine;",	"Gets two point or linestring geometries and returns a linestring geometry"	]
[ "geom",	"MakeLine",	"command geom.MakeLine(a:bat[:wkb]):wkb ",	"wkbMakeLineAggr;",	"Gets a BAT with point or linestring geometries and returns a single linestring geometry"	]
[ "geom",	"MakePoint",	"function geom.MakePoint(x:dbl, y:dbl):wkb;",	"",	""	]
[ "geom",	"MakePoint",	"function geom.MakePoint(x:dbl, y:dbl, z:dbl):wkb;",	"",	""	]
[ "geom",	"MakePoint",	"function geom.MakePoint(x:dbl, y:dbl, z:dbl, m:dbl):wkb;",	"",	""	]
[ "geom",	"MakePointM",	"function geom.MakePointM(x:dbl, y:dbl, m:dbl):wkb;",	"",	""	]
[ "geom",	"MakePointXYZM",	"command geom.MakePointXYZM(x:dbl, y:dbl, z:dbl, m:dbl, zmFlag:int):wkb ",	"wkbMakePoint;",	"creates a point using the coordinates"	]
[ "geom",	"MakePolygon",	"function geom.MakePolygon(external:wkb):wkb;",	"",	""	]
[ "geom",	"MakePolygon",	"function geom.MakePolygon(external:wkb, srid:int):wkb;",	"",	""	]
[ "geom",	"NPoints",	"function geom.NPoints(w:wkb):int;",	"",	""	]
[ "geom",	"NRings",	"function geom.NRings(w:wkb):int;",	"",	""	]
[ "geom",	"NumGeometries",	"command geom.NumGeometries(g:wkb):int ",	"wkbNumGeometries;",	"Returns the number of geometries"	]
[ "geom",	"NumInteriorRings",	"function geom.NumInteriorRings(w:wkb):int;",	"",	""	]
[ "geom",	"NumPoints",	"function geom.NumPoints(w:wkb):int;",	"",	""	]
[ "geom",	"NumRings",	"command geom.NumRings(w:wkb, exterior:int):int ",	"wkbNumRings;",	"Returns the number of interior rings+exterior on the first polygon of the geometry"	]
[ "geom",	"Overlaps",	"command geom.Overlaps(a:wkb, b:wkb):bit ",	"wkbOverlaps;",	" Returns TRUE if the Geometries intersect but are not completely contained by each other."	]
[ "geom",	"PointFromText",	"function geom.PointFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"PointFromText",	"function geom.PointFromText(wkt:str, srid:int):wkb;",	"",	""	]
[ "geom",	"PointN",	"command geom.PointN(w:wkb, n:int):wkb ",	"wkbPointN;",	"Returns the n-th point of the Geometry. Argument w should be Linestring."	]
[ "geom",	"PointOnSurface",	"command geom.PointOnSurface(w:wkb):wkb ",	"wkbPointOnSurface;",	"Returns a point guaranteed to lie on the surface. Similar to postGIS it works for points and lines in addition to surfaces and for 3d geometries."	]
[ "geom",	"PointsNum",	"command geom.PointsNum(w:wkb, check:int):int ",	"wkbNumPoints;",	"The number of points in the Geometry. If check=1, the geometry should be a linestring"	]
[ "geom",	"Polygon",	"command geom.Polygon(X_0:wkb, X_1:bat[:wkb], X_2:int):wkb ",	"wkbMakePolygon;",	"Returns a Polygon created from the provided LineStrings"	]
[ "geom",	"PolygonFromText",	"function geom.PolygonFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"PolygonFromText",	"function geom.PolygonFromText(wkt:str, srid:int):wkb;",	"",	""	]
[ "geom",	"Relate",	"command geom.Relate(a:wkb, b:wkb, intersection_matrix_pattern:str):bit ",	"wkbRelate;",	"Returns true if the Geometry a 'spatially related' to Geometry b, by testing for intersection between the Interior, Boundary and Exterior of the two geometries as specified by the values in the intersectionPatternMatrix."	]
[ "geom",	"Segmentize",	"command geom.Segmentize(g:wkb, sz:dbl):wkb ",	"wkbSegmentize;",	"It creates a new geometry with all segments on it smaller or equal to sz"	]
[ "geom",	"StartPoint",	"command geom.StartPoint(w:wkb):wkb ",	"wkbStartPoint;",	"Returns the first point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING"	]
[ "geom",	"SymDifference",	"command geom.SymDifference(a:wkb, b:wkb):wkb ",	"wkbSymDifference;",	"Returns a geometry that represents the portions of A and B that do not intersect"	]
[ "geom",	"ToText",	"command geom.ToText(w:wkb, withSRID:int):str ",	"wkbAsText;",	""	]
[ "geom",	"Touches",	"command geom.Touches(a:wkb, b:wkb):bit ",	"wkbTouches;",	"Returns TRUE if the geometries have at least one point in common, but their interiors do not intersect."	]
[ "geom",	"Transform",	"command geom.Transform(g:wkb, srid_src:int, srid_dst:int, proj_src:str, proj_dest:str):wkb ",	"wkbTransform;",	"Transforms a geometry from one srid to another"	]
[ "geom",	"Translate",	"function geom.Translate(g:wkb, dx:dbl, dy:dbl):wkb;",	"",	""	]
[ "geom",	"Translate",	"function geom.Translate(g:wkb, dx:dbl, dy:dbl, dz:dbl):wkb;",	"",	""	]
[ "geom",	"Translate3D",	"command geom.Translate3D(g:wkb, dx:dbl, dy:dbl, dz:dbl):wkb ",	"wkbTranslate;",	"Moves all points of the geometry by dx, dy, dz"	]
[ "geom",	"Union",	"command geom.Union(a:wkb, b:wkb):wkb ",	"wkbUnion;",	"Returns a geometry that represents the point set union of the Geometries a, b"	]
[ "geom",	"Union",	"command geom.Union(a:bat[:wkb]):wkb ",	"wkbUnionAggr;",	"Gets a BAT with geometries and returns their union"	]
[ "geom",	"Within",	"command geom.Within(a:wkb, b:wkb):bit ",	"wkbWithin;",	"Returns TRUE if the geometry A is completely inside geometry B"	]
[ "geom",	"X",	"function geom.X(w:wkb):dbl;",	"",	""	]
[ "geom",	"XMaxFromMBR",	"function geom.XMaxFromMBR(b:mbr):dbl;",	"",	""	]
[ "geom",	"XMaxFromWKB",	"function geom.XMaxFromWKB(g:wkb):dbl;",	"",	""	]
[ "geom",	"XMinFromMBR",	"function geom.XMinFromMBR(b:mbr):dbl;",	"",	""	]
[ "geom",	"XMinFromWKB",	"function geom.XMinFromWKB(g:wkb):dbl;",	"",	""	]
[ "geom",	"Y",	"function geom.Y(w:wkb):dbl;",	"",	""	]
[ "geom",	"YMaxFromMBR",	"function geom.YMaxFromMBR(b:mbr):dbl;",	"",	""	]
[ "geom",	"YMaxFromWKB",	"function geom.YMaxFromWKB(g:wkb):dbl;",	"",	""	]
[ "geom",	"YMinFromMBR",	"function geom.YMinFromMBR(b:mbr):dbl;",	"",	""	]
[ "geom",	"YMinFromWKB",	"function geom.YMinFromWKB(g:wkb):dbl;",	"",	""	]
[ "geom",	"Z",	"function geom.Z(w:wkb):dbl;",	"",	""	]
[ "geom",	"coordinateFromMBR",	"command geom.coordinateFromMBR(X_0:mbr, X_1:int):dbl ",	"wkbCoordinateFromMBR;",	"returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided mbr"	]
[ "geom",	"coordinateFromWKB",	"command geom.coordinateFromWKB(X_0:wkb, X_1:int):dbl ",	"wkbCoordinateFromWKB;",	"returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided geometry"	]
[ "geom",	"epilogue",	"command geom.epilogue():void ",	"geom_epilogue;",	""	]
[ "geom",	"getSRID",	"command geom.getSRID(w:wkb):int ",	"wkbGetSRID;",	"Returns the Spatial Reference System ID for this Geometry."	]
[ "geom",	"getType",	"command geom.getType(flags:int, format:int):str ",	"geoGetType;",	"returns the str representation of the geometry type"	]
[ "geom",	"hasM",	"command geom.hasM(flags:int):int ",	"geoHasM;",	"returns 1 if the geometry has m coordinate"	]
[ "geom",	"hasZ",	"command geom.hasZ(flags:int):int ",	"geoHasZ;",	"returns 1 if the geometry has z coordinate"	]
[ "geom",	"mbr",	"command geom.mbr(X_0:wkb):mbr ",	"wkbMBR;",	"Creates the mbr for the given wkb."	]
[ "geom",	"mbrAbove",	"command geom.mbrAbove(box1:mbr, box2:mbr):bit ",	"mbrAbove;",	"Returns true if box1 is above box2"	]
[ "geom",	"mbrAbove",	"command geom.mbrAbove(geom1:wkb, geom2:wkb):bit ",	"mbrAbove_wkb;",	"Returns true if the mbr of geom1 is above the mbr of geom2"	]
[ "geom",	"mbrBelow",	"command geom.mbrBelow(box1:mbr, box2:mbr):bit ",	"mbrBelow;",	"Returns true if box1 is below box2"	]
[ "geom",	"mbrBelow",	"command geom.mbrBelow(geom1:wkb, geom2:wkb):bit ",	"mbrBelow_wkb;",	"Returns true if the mbr of geom1 is below the mbr of geom2"	]
[ "geom",	"mbrContained",	"command geom.mbrContained(box1:mbr, box2:mbr):bit ",	"mbrContained;",	"Returns true if box1 is contained by box2"	]
[ "geom",	"mbrContained",	"command geom.mbrContained(geom1:wkb, geom2:wkb):bit ",	"mbrContained_wkb;",	"Returns true if the mbr of geom1 is contained by the mbr of geom2"	]
[ "geom",	"mbrContains",	"command geom.mbrContains(box1:mbr, box2:mbr):bit ",	"mbrContains;",	"Returns true if box1 contains box2"	]
[ "geom",	"mbrContains",	"command geom.mbrContains(geom1:wkb, geom2:wkb):bit ",	"mbrContains_wkb;",	"Returns true if the mbr of geom1 contains the mbr of geom2"	]
[ "geom",	"mbrDistance",	"command geom.mbrDistance(box1:mbr, box2:mbr):dbl ",	"mbrDistance;",	"Returns the distance of the centroids of the two boxes"	]
[ "geom",	"mbrDistance",	"command geom.mbrDistance(geom1:wkb, geom2:wkb):dbl ",	"mbrDistance_wkb;",	"Returns the distance of the centroids of the mbrs of the two geometries"	]
[ "geom",	"mbrEqual",	"command geom.mbrEqual(box1:mbr, box2:mbr):bit ",	"mbrEqual;",	"Returns true if box1 is the same as box2"	]
[ "geom",	"mbrEqual",	"command geom.mbrEqual(geom1:wkb, geom2:wkb):bit ",	"mbrEqual_wkb;",	"Returns true if the mbr of geom1 is the same as the mbr of geom2"	]
[ "geom",	"mbrLeft",	"command geom.mbrLeft(box1:mbr, box2:mbr):bit ",	"mbrLeft;",	"Returns true if box1 is left of box2"	]
[ "geom",	"mbrLeft",	"command geom.mbrLeft(geom1:wkb, geom2:wkb):bit ",	"mbrLeft_wkb;",	"Returns true if the mbr of geom1 is left of the mbr of geom2"	]
[ "geom",	"mbrOverlapOrAbove",	"command geom.mbrOverlapOrAbove(box1:mbr, box2:mbr):bit ",	"mbrOverlapOrAbove;",	"Returns true if box1 overlaps or is above box2"	]
[ "geom",	"mbrOverlapOrAbove",	"command geom.mbrOverlapOrAbove(geom1:wkb, geom2:wkb):bit ",	"mbrOverlapOrAbove_wkb;",	"Returns true if the mbr of geom1 overlaps or is above the mbr of geom2"	]
[ "geom",	"mbrOverlapOrBelow",	"command geom.mbrOverlapOrBelow(box1:mbr, box2:mbr):bit ",	"mbrOverlapOrBelow;",	"Returns true if box1 overlaps or is below box2"	]
[ "geom",	"mbrOverlapOrBelow",	"command geom.mbrOverlapOrBelow(geom1:wkb, geom2:wkb):bit ",	"mbrOverlapOrBelow_wkb;",	"Returns true if the mbr of geom1 overlaps or is below the mbr of geom2"	]
[ "geom",	"mbrOverlapOrLeft",	"command geom.mbrOverlapOrLeft(box1:mbr, box2:mbr):bit ",	"mbrOverlapOrLeft;",	"Returns true if box1 overlaps or is to the left of box2"	]
[ "geom",	"mbrOverlapOrLeft",	"command geom.mbrOverlapOrLeft(geom1:wkb, geom2:wkb):bit ",	"mbrOverlapOrLeft_wkb;",	"Returns true if the mbr of geom1 overlaps or is to the left of thr mbr of geom2"	]
[ "geom",	"mbrOverlapOrRight",	"command geom.mbrOverlapOrRight(box1:mbr, box2:mbr):bit ",	"mbrOverlapOrRight;",	"Returns true if box1 overlalps or is right of box2"	]
[ "geom",	"mbrOverlapOrRight",	"command geom.mbrOverlapOrRight(geom1:wkb, geom2:wkb):bit ",	"mbrOverlapOrRight_wkb;",	"Returns true if the mbr of geom1 overlalps or is right of the mbr of geom2"	]
[ "geom",	"mbrOverlaps",	"command geom.mbrOverlaps(box1:mbr, box2:mbr):bit ",	"mbrOverlaps;",	"Returns true if box1 overlaps box2"	]
[ "geom",	"mbrOverlaps",	"command geom.mbrOverlaps(geom1:wkb, geom2:wkb):bit ",	"mbrOverlaps_wkb;",	"Returns true if the mbr of geom1 overlaps the mbr of geom2"	]
[ "geom",	"mbrRight",	"command geom.mbrRight(box1:mbr, box2:mbr):bit ",	"mbrRight;",	"Returns true if box1 is right of box2"	]
[ "geom",	"mbrRight",	"command geom.mbrRight(geom1:wkb, geom2:wkb):bit ",	"mbrRight_wkb;",	"Returns true if the mbr of geom1 is right of the mbr of geom2"	]
[ "geom",	"prelude",	"command geom.prelude():void ",	"geom_prelude;",	""	]
[ "geom",	"setSRID",	"command geom.setSRID(w:wkb, srid:int):wkb ",	"wkbSetSRID;",	"Sets the Reference System ID for this Geometry."	]
[ "group",	"group",	"command group.group(b:bat[:any_1]):bat[:oid] ",	"GRPgroup11;",	""	]
[ "group",	"group",	"command group.group(b:bat[:any_1]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPgroup1;",	""	]
[ "group",	"group",	"command group.group(b:bat[:any_1], s:bat[:oid]):bat[:oid] ",	"GRPgroup21;",	""	]
[ "group",	"group",	"command group.group(b:bat[:any_1], s:bat[:oid]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPgroup2;",	""	]
[ "group",	"group",	"command group.group(b:bat[:any_1]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPgroup3;",	""	]
[ "group",	"group",	"command group.group(b:bat[:any_1], s:bat[:oid]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPgroup4;",	""	]
[ "group",	"groupdone",	"command group.groupdone(b:bat[:any_1]):bat[:oid] ",	"GRPgroup11;",	""	]
[ "group",	"groupdone",	"command group.groupdone(b:bat[:any_1]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPgroup1;",	""	]
[ "group",	"groupdone",	"command group.groupdone(b:bat[:any_1], s:bat[:oid]):bat[:oid] ",	"GRPgroup21;",	""	]
[ "group",	"groupdone",	"command group.groupdone(b:bat[:any_1], s:bat[:oid]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPgroup2;",	""	]
[ "group",	"groupdone",	"command group.groupdone(b:bat[:any_1]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPgroup3;",	""	]
[ "group",	"groupdone",	"command group.groupdone(b:bat[:any_1], s:bat[:oid]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPgroup4;",	""	]
[ "group",	"multicolumn",	"pattern group.multicolumn(b:bat[:any]...) (ref:bat[:oid], grp:bat[:oid], hist:bat[:any]) ",	"GROUPmulticolumngroup;",	"Derivation of a group index over multiple columns."	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], g:bat[:oid]):bat[:oid] ",	"GRPsubgroup21;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], g:bat[:oid]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPsubgroup2;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], s:bat[:oid], g:bat[:oid]):bat[:oid] ",	"GRPsubgroup31;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], s:bat[:oid], g:bat[:oid]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPsubgroup3;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], g:bat[:oid], e:bat[:oid], h:bat[:lng]):bat[:oid] ",	"GRPsubgroup41;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], g:bat[:oid], e:bat[:oid], h:bat[:lng]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPsubgroup4;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], s:bat[:oid], g:bat[:oid], e:bat[:oid], h:bat[:lng]):bat[:oid] ",	"GRPsubgroup51;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], s:bat[:oid], g:bat[:oid], e:bat[:oid], h:bat[:lng]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPsubgroup5;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], g:bat[:oid]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPsubgroup6;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], s:bat[:oid], g:bat[:oid]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPsubgroup7;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], g:bat[:oid], e:bat[:oid], h:bat[:lng]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPsubgroup8;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1], s:bat[:oid], g:bat[:oid], e:bat[:oid], h:bat[:lng]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPsubgroup9;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], g:bat[:oid]):bat[:oid] ",	"GRPsubgroup21;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], g:bat[:oid]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPsubgroup2;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], s:bat[:oid], g:bat[:oid]):bat[:oid] ",	"GRPsubgroup31;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], s:bat[:oid], g:bat[:oid]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPsubgroup3;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], g:bat[:oid], e:bat[:oid], h:bat[:lng]):bat[:oid] ",	"GRPsubgroup41;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], g:bat[:oid], e:bat[:oid], h:bat[:lng]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPsubgroup4;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], s:bat[:oid], g:bat[:oid], e:bat[:oid], h:bat[:lng]):bat[:oid] ",	"GRPsubgroup51;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], s:bat[:oid], g:bat[:oid], e:bat[:oid], h:bat[:lng]) (groups:bat[:oid], extents:bat[:oid], histo:bat[:lng]) ",	"GRPsubgroup5;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], g:bat[:oid]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPsubgroup6;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], s:bat[:oid], g:bat[:oid]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPsubgroup7;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], g:bat[:oid], e:bat[:oid], h:bat[:lng]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPsubgroup8;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1], s:bat[:oid], g:bat[:oid], e:bat[:oid], h:bat[:lng]) (groups:bat[:oid], extents:bat[:oid]) ",	"GRPsubgroup9;",	""	]
[ "identifier",	"#fromstr",	"command identifier.#fromstr():void ",	"IDfromString;",	"Convert a string to an identifier without any check"	]
[ "identifier",	"#tostr",	"command identifier.#tostr():void ",	"IDtoString;",	"Convert identifier to string equivalent"	]
[ "identifier",	"identifier",	"command identifier.identifier(s:str):identifier ",	"IDentifier;",	"Cast a string to an identifer "	]
[ "identifier",	"prelude",	"command identifier.prelude():void ",	"IDprelude;",	"Initialize the module"	]
[ "inet",	"!=",	"command inet.!=(v:inet, w:inet):bit ",	"INET_comp_NEQ;",	"Inequality of two inets"	]
[ "inet",	"#cmp",	"command inet.#cmp():void ",	"INETcompare;",	""	]
[ "inet",	"#fromstr",	"command inet.#fromstr():void ",	"INETfromString;",	"Convert a string to an inet"	]
[ "inet",	"#null",	"command inet.#null():void ",	"INETnull;",	""	]
[ "inet",	"#tostr",	"command inet.#tostr():void ",	"INETtoString;",	"Convert inet to string equivalent"	]
[ "inet",	"<",	"command inet.<(v:inet, w:inet):bit ",	"INET_comp_LT;",	"Whether v is less than w"	]
[ "inet",	"<<",	"command inet.<<(v:inet, w:inet):bit ",	"INET_comp_CW;",	"Whether v is contained within w"	]
[ "inet",	"<<=",	"command inet.<<=(v:inet, w:inet):bit ",	"INET_comp_CWE;",	"Whether v is contained within or is equal to w"	]
[ "inet",	"<=",	"command inet.<=(v:inet, w:inet):bit ",	"INET_comp_LE;",	"Whether v is less than or equal to w"	]
[ "inet",	"=",	"command inet.=(v:inet, w:inet):bit ",	"INET_comp_EQ;",	"Equality of two inets"	]
[ "inet",	">",	"command inet.>(v:inet, w:inet):bit ",	"INET_comp_GT;",	"Whether v is greater than w"	]
[ "inet",	">=",	"command inet.>=(v:inet, w:inet):bit ",	"INET_comp_GE;",	"Whether v is equal to or greater than w"	]
[ "inet",	">>",	"command inet.>>(v:inet, w:inet):bit ",	"INET_comp_CS;",	"Whether v contains w"	]
[ "inet",	">>=",	"command inet.>>=(v:inet, w:inet):bit ",	"INET_comp_CSE;",	"Whether v contains or is equal to w"	]
[ "inet",	"abbrev",	"command inet.abbrev(X_0:inet):str ",	"INETabbrev;",	"Abbreviated display format as text"	]
[ "inet",	"broadcast",	"command inet.broadcast(X_0:inet):inet ",	"INETbroadcast;",	"Returns the broadcast address for network"	]
[ "inet",	"host",	"command inet.host(X_0:inet):str ",	"INEThost;",	"Extract IP address as text"	]
[ "inet",	"hostmask",	"command inet.hostmask(X_0:inet):inet ",	"INEThostmask;",	"Construct host mask for network"	]
[ "inet",	"isnil",	"command inet.isnil(v:inet):bit ",	"INET_isnil;",	"Nil test for inet value"	]
[ "inet",	"masklen",	"command inet.masklen(X_0:inet):int ",	"INETmasklen;",	"Extract netmask length"	]
[ "inet",	"netmask",	"command inet.netmask(X_0:inet):inet ",	"INETnetmask;",	"Construct netmask for network"	]
[ "inet",	"network",	"command inet.network(X_0:inet):inet ",	"INETnetwork;",	"Extract network part of address"	]
[ "inet",	"new",	"command inet.new(s:str):inet ",	"INETnew;",	"Create an inet from a string literal"	]
[ "inet",	"setmasklen",	"command inet.setmasklen(X_0:inet, X_1:int):inet ",	"INETsetmasklen;",	"Set netmask length for inet value"	]
[ "inet",	"text",	"command inet.text(X_0:inet):str ",	"INETtext;",	"Extract IP address and netmask length as text"	]
[ "inspect",	"equalType",	"pattern inspect.equalType(l:any, r:any):bit ",	"INSPECTequalType;",	"Return true if both operands are of the same type"	]
[ "inspect",	"getAddress",	"pattern inspect.getAddress(mod:str, fcn:str):bat[:str] ",	"INSPECTgetAddress;",	"Returns the function signature(s)."	]
[ "inspect",	"getAddresses",	"pattern inspect.getAddresses():bat[:str] ",	"INSPECTgetAllAddresses;",	"Obtain the function address."	]
[ "inspect",	"getAtomNames",	"command inspect.getAtomNames():bat[:str] ",	"INSPECTatom_names;",	"Collect a BAT with the atom names."	]
[ "inspect",	"getAtomSizes",	"command inspect.getAtomSizes():bat[:int] ",	"INSPECTatom_sizes;",	"Collect a BAT with the atom sizes."	]
[ "inspect",	"getAtomSuper",	"command inspect.getAtomSuper():bat[:str] ",	"INSPECTatom_sup_names;",	"Collect a BAT with the atom names."	]
[ "inspect",	"getComment",	"pattern inspect.getComment(mod:str, fcn:str):bat[:str] ",	"INSPECTgetComment;",	"Returns the function help information."	]
[ "inspect",	"getDefinition",	"pattern inspect.getDefinition(mod:str, fcn:str):bat[:str] ",	"INSPECTgetDefinition;",	"Returns a string representation of a specific function."	]
[ "inspect",	"getEnvironment",	"command inspect.getEnvironment() (k:bat[:str], v:bat[:str]) ",	"INSPECTgetEnvironment;",	"Collect the environment variables."	]
[ "inspect",	"getEnvironment",	"command inspect.getEnvironment(k:str):str ",	"INSPECTgetEnvironmentKey;",	"Get the value of an environemnt variable"	]
[ "inspect",	"getFunction",	"pattern inspect.getFunction():bat[:str] ",	"INSPECTgetAllFunctions;",	"Obtain the function name."	]
[ "inspect",	"getKind",	"pattern inspect.getKind():bat[:str] ",	"INSPECTgetkind;",	"Obtain the instruction kind."	]
[ "inspect",	"getModule",	"pattern inspect.getModule():bat[:str] ",	"INSPECTgetAllModules;",	"Obtain the function name."	]
[ "inspect",	"getSignature",	"pattern inspect.getSignature(mod:str, fcn:str):bat[:str] ",	"INSPECTgetSignature;",	"Returns the function signature(s)."	]
[ "inspect",	"getSignatures",	"pattern inspect.getSignatures():bat[:str] ",	"INSPECTgetAllSignatures;",	"Obtain the function signatures."	]
[ "inspect",	"getSize",	"pattern inspect.getSize(mod:str, fcn:str):lng ",	"INSPECTgetFunctionSize;",	"Return the storage size for a function (in bytes)."	]
[ "inspect",	"getSize",	"pattern inspect.getSize():lng ",	"INSPECTgetSize;",	"Return the storage size for the current function (in bytes)."	]
[ "inspect",	"getSource",	"pattern inspect.getSource(mod:str, fcn:str):str ",	"INSPECTgetSource;",	"Return the original input for a function."	]
[ "inspect",	"getType",	"pattern inspect.getType(v:any_1):str ",	"INSPECTtypeName;",	"Return the concrete type of a variable (expression)."	]
[ "inspect",	"optimizer_stats",	"pattern inspect.optimizer_stats() (X_0:bat[:str], X_1:bat[:int], X_2:bat[:lng]) ",	"OPTstatistics;",	"Get optimizer use statistics, i.e. calls and total time"	]
[ "io",	"export",	"command io.export(b:bat[:any_2], filepath:str):void ",	"IOexport;",	"Export a BAT as ASCII to a file. If the 'filepath' is not absolute, it\n is put into the $DBPATH directory. Success of failure is indicated."	]
[ "io",	"import",	"command io.import(b:bat[:any_2], filepath:str):void ",	"IOimport;",	"Import a BAT from an ASCII dump. The tuples are appended to the\n first argument. Its signature must match the dump,\n else parsing errors will occur as an exception."	]
[ "io",	"print",	"pattern io.print(val:any_1):void ",	"IOprint_val;",	"Print a MAL value."	]
[ "io",	"print",	"pattern io.print(val:any_1, lst:any...):void ",	"IOprint_val;",	"Print a MAL value tuple ."	]
[ "io",	"print",	"pattern io.print(val:bat[:any_1]):void ",	"IOprint_val;",	"Print a MAL value column ."	]
[ "io",	"print",	"pattern io.print(b1:bat[:any]...):void ",	"IOtable;",	"BATs are printed with '#' for legend \n\tlines, and the BUNs on seperate lines \n\tbetween brackets, containing each to \n\tcomma separated values (head and tail). \n\tIf multiple BATs are passed for printing, \n\tprint() performs an implicit natural \n\tjoin on the void head, producing a multi attribute table."	]
[ "io",	"printf",	"pattern io.printf(fmt:str):void ",	"IOprintf;",	"Select default format "	]
[ "io",	"printf",	"pattern io.printf(fmt:str, val:any...):void ",	"IOprintf;",	"Select default format "	]
[ "io",	"printf",	"pattern io.printf(filep:streams, fmt:str):void ",	"IOprintfStream;",	"Select default format "	]
[ "io",	"printf",	"pattern io.printf(filep:streams, fmt:str, val:any...):void ",	"IOprintfStream;",	"Select default format "	]
[ "io",	"setmallocsuccesscount",	"command io.setmallocsuccesscount(count:lng):void ",	"IOsetmallocsuccesscount;",	"Set number of mallocs that are allowed to succeed."	]
[ "io",	"stdin",	"pattern io.stdin():bstream ",	"io_stdin;",	"return the input stream to the database client"	]
[ "io",	"stdout",	"pattern io.stdout():streams ",	"io_stdout;",	"return the output stream for the database client"	]
[ "iterator",	"new",	"pattern iterator.new(b:bat[:any_2]) (h:oid, t:any_2) ",	"ITRbunIterator;",	"Process the buns one by one extracted from a void table."	]
[ "iterator",	"new",	"command iterator.new(b:bat[:any_2], size:lng) (X_0:lng, X_1:bat[:any_2]) ",	"ITRnewChunk;",	"Create an iterator with fixed granule size.\n\t  The result is a view."	]
[ "iterator",	"next",	"pattern iterator.next(b:bat[:any_2]) (h:oid, t:any_2) ",	"ITRbunNext;",	"Produce the next bun for processing."	]
[ "iterator",	"next",	"command iterator.next(b:bat[:any_2], size:lng) (X_0:lng, X_1:bat[:any_2]) ",	"ITRnextChunk;",	"Produce the next chunk for processing."	]
[ "iterator",	"next",	"command iterator.next(step:dbl, last:dbl):dbl ",	"ITRnext_dbl;",	"Advances the iterator with a fixed value"	]
[ "iterator",	"next",	"command iterator.next(step:flt, last:flt):flt ",	"ITRnext_flt;",	""	]
[ "iterator",	"next",	"command iterator.next(step:hge, last:hge):hge ",	"ITRnext_hge;",	""	]
[ "iterator",	"next",	"command iterator.next(step:int, last:int):int ",	"ITRnext_int;",	""	]
[ "iterator",	"next",	"command iterator.next(step:lng, last:lng):lng ",	"ITRnext_lng;",	""	]
[ "iterator",	"next",	"command iterator.next(step:oid, last:oid):oid ",	"ITRnext_oid;",	""	]
[ "iterator",	"next",	"command iterator.next(step:sht, last:sht):sht ",	"ITRnext_sht;",	""	]
[ "json",	"#fromstr",	"command json.#fromstr():void ",	"JSONfromString;",	"Validate a string to be JSON compliant. A NOOP if valid json, NULL otherwise."	]
[ "json",	"#tostr",	"command json.#tostr():void ",	"JSONtoString;",	"Convert JSON to its string equivalent. Dealing with escape characters"	]
[ "json",	"dump",	"pattern json.dump(j:json):void ",	"JSONdump;",	""	]
[ "json",	"filter",	"command json.filter(name:json, pathexpr:str):json ",	"JSONfilter;",	"Filter all members of an object by a path expression, returning an array.\nNon-matching elements are skipped."	]
[ "json",	"filter",	"command json.filter(name:json, idx:bte, other:str):json ",	"JSONfilterArrayDefault_bte;",	""	]
[ "json",	"filter",	"command json.filter(name:json, idx:hge, other:str):json ",	"JSONfilterArrayDefault_hge;",	""	]
[ "json",	"filter",	"command json.filter(name:json, idx:int, other:str):json ",	"JSONfilterArrayDefault_int;",	""	]
[ "json",	"filter",	"command json.filter(name:json, idx:lng, other:str):json ",	"JSONfilterArrayDefault_lng;",	"Extract a single array element"	]
[ "json",	"filter",	"command json.filter(name:json, idx:sht, other:str):json ",	"JSONfilterArrayDefault_sht;",	""	]
[ "json",	"filter",	"command json.filter(name:json, idx:bte):json ",	"JSONfilterArray_bte;",	""	]
[ "json",	"filter",	"command json.filter(name:json, idx:hge):json ",	"JSONfilterArray_hge;",	""	]
[ "json",	"filter",	"command json.filter(name:json, idx:int):json ",	"JSONfilterArray_int;",	""	]
[ "json",	"filter",	"command json.filter(name:json, idx:lng):json ",	"JSONfilterArray_lng;",	""	]
[ "json",	"filter",	"command json.filter(name:json, idx:sht):json ",	"JSONfilterArray_sht;",	""	]
[ "json",	"fold",	"pattern json.fold(k:bat[:str], v:bat[:any]):json ",	"JSONfold;",	"Combine the key-value pairs into a single json object list."	]
[ "json",	"fold",	"pattern json.fold(o:bat[:oid], k:bat[:str], v:bat[:any]):json ",	"JSONfold;",	"Combine the key-value pairs into a single json object list."	]
[ "json",	"fold",	"pattern json.fold(v:bat[:any]):json ",	"JSONfold;",	"Combine the value list into a single json array object."	]
[ "json",	"integer",	"command json.integer(j:json):lng ",	"JSONjson2integer;",	"Convert simple JSON values to an integer, return nil upon error."	]
[ "json",	"isarray",	"command json.isarray(val:json):bit ",	"JSONisarray;",	"Validate the string as a valid JSON array"	]
[ "json",	"isarray",	"command json.isarray(val:str):bit ",	"JSONisarray;",	"Validate the string as a valid JSON array"	]
[ "json",	"isobject",	"command json.isobject(val:json):bit ",	"JSONisobject;",	"Validate the string as a valid JSON object"	]
[ "json",	"isobject",	"command json.isobject(val:str):bit ",	"JSONisobject;",	"Validate the string as a valid JSON object"	]
[ "json",	"isvalid",	"command json.isvalid(val:json):bit ",	"JSONisvalid;",	"Validate the string as a valid JSON document"	]
[ "json",	"isvalid",	"command json.isvalid(val:str):bit ",	"JSONisvalid;",	"Validate the string as a valid JSON document"	]
[ "json",	"keyarray",	"command json.keyarray(val:json):json ",	"JSONkeyArray;",	"Expands the outermost JSON object keys into a JSON value array."	]
[ "json",	"keys",	"command json.keys(val:json):bat[:str] ",	"JSONkeyTable;",	"Expands the outermost JSON object names."	]
[ "json",	"length",	"command json.length(val:json):int ",	"JSONlength;",	"Returns the number of elements in the outermost JSON object."	]
[ "json",	"new",	"command json.new(j:str):json ",	"JSONstr2json;",	"Convert string to its JSON. Dealing with escape characters"	]
[ "json",	"number",	"command json.number(j:json):dbl ",	"JSONjson2number;",	"Convert simple JSON values to a double, return nil upon error."	]
[ "json",	"output",	"command json.output(b:bat[:any_1]):str ",	"JSONtextString;",	"Pack the values into a single json structure"	]
[ "json",	"prelude",	"command json.prelude():void ",	"JSONprelude;",	""	]
[ "json",	"renderarray",	"pattern json.renderarray(val:any...):json ",	"JSONrenderarray;",	""	]
[ "json",	"renderobject",	"pattern json.renderobject(val:any...):json ",	"JSONrenderobject;",	""	]
[ "json",	"resultSet",	"command json.resultSet(u:bat[:uuid], rev:bat[:lng], js:bat[:json]):json ",	"JSONresultSet;",	"Converts the json store into a single json string:"	]
[ "json",	"str",	"command json.str(j:json):str ",	"JSONjson2str;",	"Convert JSON to its string equivalent. Dealing with escape characters"	]
[ "json",	"suboutput",	"command json.suboutput(b:bat[:any_1], gid:bat[:oid], ext:bat[:lng], flg:bit):bat[:str] ",	"JSONtextGrouped;",	"Pack the values into a json structure"	]
[ "json",	"text",	"command json.text(j:json):str ",	"JSONjson2text;",	"Convert JSON values to their plain string equivalent."	]
[ "json",	"text",	"command json.text(j:json, s:str):str ",	"JSONjson2textSeparator;",	"Convert JSON values to their plain string equivalent, injecting a separator."	]
[ "json",	"unfold",	"pattern json.unfold(val:json) (k:bat[:str], v:bat[:json]) ",	"JSONunfold;",	"Expands the outermost JSON object into key-value pairs."	]
[ "json",	"unfold",	"pattern json.unfold(val:json) (o:bat[:oid], k:bat[:str], v:bat[:json]) ",	"JSONunfold;",	"Expands the outermost JSON object into key-value pairs."	]
[ "json",	"valuearray",	"command json.valuearray(val:json):json ",	"JSONvalueArray;",	"Expands the outermost JSON object values into a JSON value array."	]
[ "json",	"values",	"command json.values(val:json):bat[:json] ",	"JSONvalueTable;",	"Expands the outermost JSON values."	]
[ "language",	"assert",	"unsafe command language.assert(v:bit, term:str):void ",	"MALassertBit;",	""	]
[ "language",	"assert",	"unsafe command language.assert(v:hge, term:str):void ",	"MALassertHge;",	""	]
[ "language",	"assert",	"unsafe command language.assert(v:int, term:str):void ",	"MALassertInt;",	""	]
[ "language",	"assert",	"unsafe command language.assert(v:lng, term:str):void ",	"MALassertLng;",	""	]
[ "language",	"assert",	"unsafe command language.assert(v:oid, term:str):void ",	"MALassertOid;",	""	]
[ "language",	"assert",	"unsafe command language.assert(v:sht, term:str):void ",	"MALassertSht;",	""	]
[ "language",	"assert",	"unsafe command language.assert(v:str, term:str):void ",	"MALassertStr;",	""	]
[ "language",	"assert",	"unsafe pattern language.assert(v:any_1, pname:str, oper:str, val:any_2):void ",	"MALassertTriple;",	"Assertion test."	]
[ "language",	"block",	"pattern language.block(v:int, w:any...):int ",	"deblockdataflow;",	"Block on availability of all variables w, and then pass on v"	]
[ "language",	"call",	"pattern language.call(s:bat[:str]):void ",	"CMDcallBAT;",	"Evaluate a program stored in a BAT."	]
[ "language",	"call",	"pattern language.call(m:str, f:str):void ",	"CMDcallFunction;",	""	]
[ "language",	"call",	"pattern language.call(s:str):void ",	"CMDcallString;",	"Evaluate a MAL string program."	]
[ "language",	"dataflow",	"pattern language.dataflow():bit ",	"MALstartDataflow;",	"The current guarded block is executed using dataflow control. "	]
[ "language",	"pass",	"pattern language.pass(v:any_1):void ",	"MALpass;",	"Cheap instruction to disgard storage while retaining the dataflow dependency"	]
[ "language",	"raise",	"unsafe command language.raise(msg:str):str ",	"CMDraise;",	"Raise an exception labeled \n\twith a specific message."	]
[ "language",	"register",	"pattern language.register(m:str, f:str, code:str, help:str):void ",	"CMDregisterFunction;",	"Compile the code string to MAL and register it as a function."	]
[ "language",	"sink",	"pattern language.sink(v:any...):void ",	"MALgarbagesink;",	"Variables to be considered together when triggering garbage collection.\nUsed in the dataflow blocks to avoid early release of values."	]
[ "language",	"source",	"pattern language.source(f:str):void ",	"CMDevalFile;",	"Merge the instructions stored in the file with the current program."	]
[ "lidar",	"attach",	"pattern lidar.attach(fname:str):void ",	"LIDARattach;",	"Open a LIDAR file and return catalog of the table HDUs"	]
[ "lidar",	"export",	"pattern lidar.export(tablename:str, fname:str, type:str):void ",	"LIDARexportTable;",	"Exporta LIDAR table to a LAS/LAZ file"	]
[ "lidar",	"load",	"pattern lidar.load(tablename:str):void ",	"LIDARloadTable;",	"Load a LIDAR table from an attached file"	]
[ "logging",	"compinfo",	"pattern logging.compinfo() (id:bat[:int], component:bat[:str], log_level:bat[:str]) ",	"TRACERcomp_info;",	"Returns in the form of a SQL result-set all the components along with their ID\nand the their current logging level being set"	]
[ "logging",	"flush",	"command logging.flush():void ",	"TRACERflush_buffer;",	"Flush the buffer"	]
[ "logging",	"resetadapter",	"command logging.resetadapter():void ",	"TRACERreset_adapter;",	"Resets the adapter back to the default"	]
[ "logging",	"resetcomplevel",	"command logging.resetcomplevel(comp:str):void ",	"TRACERreset_component_level;",	"Resets the log level for a specific component back to the default"	]
[ "logging",	"resetflushlevel",	"command logging.resetflushlevel():void ",	"TRACERreset_flush_level;",	"Resets the flush level back to the default"	]
[ "logging",	"resetlayerlevel",	"command logging.resetlayerlevel(layer:str):void ",	"TRACERreset_layer_level;",	"Resets the log level for a specific layer back to the default"	]
[ "logging",	"setadapter",	"command logging.setadapter(adapter:str):void ",	"TRACERset_adapter;",	"Sets the adapter"	]
[ "logging",	"setcomplevel",	"command logging.setcomplevel(comp:str, lvl:str):void ",	"TRACERset_component_level;",	"Sets the log level for a specific component"	]
[ "logging",	"setflushlevel",	"command logging.setflushlevel(lvl:str):void ",	"TRACERset_flush_level;",	"Sets the flush level"	]
[ "logging",	"setlayerlevel",	"command logging.setlayerlevel(layer:str, lvl:str):void ",	"TRACERset_layer_level;",	"Sets the log level for a specific layer"	]
[ "mal",	"manifold",	"pattern mal.manifold(mod:str, fcn:str, a:any...):bat[:any] ",	"MANIFOLDevaluate;",	""	]
[ "mal",	"multiplex",	"pattern mal.multiplex(mod:str, fcn:str, a:any...):any... ",	"MANIFOLDremapMultiplex;",	""	]
[ "manual",	"functions",	"pattern manual.functions() (mod:bat[:str], fcn:bat[:str], sig:bat[:str], adr:bat[:str], com:bat[:str]) ",	"MANUALcreateOverview;",	"Produces a table with all MAL functions known"	]
[ "mapi",	"bind",	"pattern mapi.bind(key:int, remoteName:str):bat[:any_2] ",	"SERVERbindBAT;",	"Bind a remote variable to a local one."	]
[ "mapi",	"bind",	"pattern mapi.bind(key:int, rschema:str, rtable:str, i:int):bat[:any_2] ",	"SERVERbindBAT;",	"Bind a remote variable to a local one."	]
[ "mapi",	"bind",	"pattern mapi.bind(key:int, rschema:str, rtable:str, rcolumn:str, i:int):bat[:any_2] ",	"SERVERbindBAT;",	"Bind a remote variable to a local one."	]
[ "mapi",	"connect",	"pattern mapi.connect(host:str, port:int, usr:str, passwd:str, lang:str):int ",	"SERVERconnect;",	"Establish connection with a remote mserver."	]
[ "mapi",	"destroy",	"command mapi.destroy(mid:int):void ",	"SERVERdestroy;",	"Destroy the handle for an Mserver."	]
[ "mapi",	"disconnect",	"command mapi.disconnect(mid:int):void ",	"SERVERdisconnect;",	"Terminate the session."	]
[ "mapi",	"disconnect",	"command mapi.disconnect():int ",	"SERVERdisconnectALL;",	"Close connections with all remote Mserver."	]
[ "mapi",	"disconnect",	"command mapi.disconnect(dbalias:str):int ",	"SERVERdisconnectWithAlias;",	"Close connection with a remote Mserver."	]
[ "mapi",	"error",	"command mapi.error(mid:int):int ",	"SERVERerror;",	"Check for an error in the communication."	]
[ "mapi",	"explain",	"command mapi.explain(mid:int):str ",	"SERVERexplain;",	"Turn the error seen into a string."	]
[ "mapi",	"fetch_all_rows",	"command mapi.fetch_all_rows(hdl:int):lng ",	"SERVERfetch_all_rows;",	"Retrieve all rows into the cache."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int, fnr:int):bte ",	"SERVERfetch_field_bte;",	"Retrieve a single bte field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int, fnr:int):hge ",	"SERVERfetch_field_hge;",	"Retrieve a single hge field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int, fnr:int):int ",	"SERVERfetch_field_int;",	"Retrieve a single int field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int, fnr:int):lng ",	"SERVERfetch_field_lng;",	"Retrieve a single lng field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int, fnr:int):oid ",	"SERVERfetch_field_oid;",	"Retrieve a single void field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int, fnr:int):sht ",	"SERVERfetch_field_sht;",	"Retrieve a single sht field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int, fnr:int):str ",	"SERVERfetch_field_str;",	"Retrieve a single field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int, fnr:int):void ",	"SERVERfetch_field_void;",	"Retrieve a single void field."	]
[ "mapi",	"fetch_field_array",	"command mapi.fetch_field_array(hdl:int):bat[:str] ",	"SERVERfetch_field_bat;",	"Retrieve all fields for a row."	]
[ "mapi",	"fetch_line",	"command mapi.fetch_line(hdl:int):str ",	"SERVERfetch_line;",	"Retrieve a complete line."	]
[ "mapi",	"fetch_reset",	"command mapi.fetch_reset(hdl:int):int ",	"SERVERfetch_reset;",	"Reset the cache read line."	]
[ "mapi",	"fetch_row",	"command mapi.fetch_row(hdl:int):int ",	"SERVERfetch_row;",	"Retrieve the next row for analysis."	]
[ "mapi",	"finish",	"command mapi.finish(hdl:int):int ",	"SERVERfinish;",	"Remove all remaining answers."	]
[ "mapi",	"getError",	"command mapi.getError(mid:int):str ",	"SERVERgetError;",	"Get error message."	]
[ "mapi",	"get_field_count",	"command mapi.get_field_count(hdl:int):int ",	"SERVERget_field_count;",	"Return number of fields."	]
[ "mapi",	"get_row_count",	"command mapi.get_row_count(hdl:int):lng ",	"SERVERget_row_count;",	"Return number of rows."	]
[ "mapi",	"listen",	"command mapi.listen():int ",	"SERVERlisten_default;",	"Start a Mapi server with the default settings."	]
[ "mapi",	"listen",	"command mapi.listen(port:int):int ",	"SERVERlisten_port;",	"Start a Mapi listener on the port given."	]
[ "mapi",	"listen",	"command mapi.listen(unixsocket:str):int ",	"SERVERlisten_usock;",	"Start a Mapi listener on the unix socket file given."	]
[ "mapi",	"lookup",	"command mapi.lookup(dbalias:str):int ",	"SERVERlookup;",	"Retrieve the connection identifier."	]
[ "mapi",	"malclient",	"command mapi.malclient(in:streams, out:streams):void ",	"SERVERclient;",	"Start a Mapi client for a particular stream pair."	]
[ "mapi",	"next_result",	"command mapi.next_result(hdl:int):int ",	"SERVERnext_result;",	"Go to next result set."	]
[ "mapi",	"ping",	"command mapi.ping(mid:int):int ",	"SERVERping;",	"Test availability of an Mserver."	]
[ "mapi",	"prepare",	"command mapi.prepare(mid:int, qry:str):int ",	"SERVERprepare;",	"Prepare a query for execution."	]
[ "mapi",	"put",	"pattern mapi.put(mid:int, nme:str, val:any_1):void ",	"SERVERput;",	"Send a value to a remote site."	]
[ "mapi",	"put",	"pattern mapi.put(nme:str, val:any_1):str ",	"SERVERputLocal;",	"Prepare sending a value to a remote site."	]
[ "mapi",	"query",	"command mapi.query(mid:int, qry:str):int ",	"SERVERquery;",	"Send the query for execution"	]
[ "mapi",	"query_array",	"pattern mapi.query_array(mid:int, qry:str, arg:str...):int ",	"SERVERquery_array;",	"Send the query for execution replacing '?' by arguments."	]
[ "mapi",	"query_handle",	"command mapi.query_handle(mid:int, qry:str):int ",	"SERVERquery_handle;",	"Send the query for execution."	]
[ "mapi",	"reconnect",	"command mapi.reconnect(mid:int):void ",	"SERVERreconnect;",	"Re-establish a connection."	]
[ "mapi",	"reconnect",	"pattern mapi.reconnect(host:str, port:int, db_alias:str, usr:str, passwd:str, lang:str):int ",	"SERVERreconnectAlias;",	"Re-establish connection with a remote mserver."	]
[ "mapi",	"reconnect",	"pattern mapi.reconnect(host:str, port:int, usr:str, passwd:str, lang:str):int ",	"SERVERreconnectWithoutAlias;",	"Re-establish connection with a remote mserver."	]
[ "mapi",	"resume",	"command mapi.resume():void ",	"SERVERresume;",	"Resume connection listeners."	]
[ "mapi",	"rows_affected",	"command mapi.rows_affected(hdl:int):lng ",	"SERVERrows_affected;",	"Return number of affected rows."	]
[ "mapi",	"rpc",	"pattern mapi.rpc(key:int, qry:str):bat[:any_2] ",	"SERVERmapi_rpc_bat;",	""	]
[ "mapi",	"rpc",	"pattern mapi.rpc(key:int, qry:str...):any ",	"SERVERmapi_rpc_single_row;",	"Send a simple query for execution and fetch result."	]
[ "mapi",	"rpc",	"command mapi.rpc(key:int, qry:str):int ",	"SERVERquery;",	"Send a simple query for execution."	]
[ "mapi",	"setAlias",	"command mapi.setAlias(key:int, dbalias:str):void ",	"SERVERsetAlias;",	"Give the channel a logical name."	]
[ "mapi",	"stop",	"command mapi.stop():void ",	"SERVERstop;",	"Terminate connection listeners."	]
[ "mapi",	"suspend",	"command mapi.suspend():void ",	"SERVERsuspend;",	"Suspend accepting connections."	]
[ "mapi",	"trace",	"command mapi.trace(mid:int, flag:int):void ",	"SERVERtrace;",	"Toggle the Mapi library debug tracer."	]
[ "mat",	"new",	"pattern mat.new(b:bat[:any_2]...):bat[:any_2] ",	"MATpack;",	"Define a Merge Association Table (MAT). Fall back to the pack operation\nwhen this is called "	]
[ "mat",	"pack",	"pattern mat.pack(b:bat[:any_2]...):bat[:any_2] ",	"MATpack;",	"Materialize the MAT into a BAT"	]
[ "mat",	"pack",	"pattern mat.pack(X_0:any_2...):bat[:any_2] ",	"MATpackValues;",	"Materialize the MAT (of values) into a BAT"	]
[ "mat",	"packIncrement",	"pattern mat.packIncrement(b:bat[:any_2], c:bat[:any_2]):bat[:any_2] ",	"MATpackIncrement;",	"Prepare incremental mat pack"	]
[ "mat",	"packIncrement",	"pattern mat.packIncrement(b:bat[:any_2], pieces:int):bat[:any_2] ",	"MATpackIncrement;",	"Prepare incremental mat pack"	]
[ "mbr",	"#cmp",	"command mbr.#cmp():void ",	"mbrCOMP;",	""	]
[ "mbr",	"#fromstr",	"command mbr.#fromstr():void ",	"mbrFROMSTR;",	""	]
[ "mbr",	"#hash",	"command mbr.#hash():void ",	"mbrHASH;",	""	]
[ "mbr",	"#null",	"command mbr.#null():void ",	"mbrNULL;",	""	]
[ "mbr",	"#read",	"command mbr.#read():void ",	"mbrREAD;",	""	]
[ "mbr",	"#tostr",	"command mbr.#tostr():void ",	"mbrTOSTR;",	""	]
[ "mbr",	"#write",	"command mbr.#write():void ",	"mbrWRITE;",	""	]
[ "mdb",	"List",	"pattern mdb.List(M:str, F:str):void ",	"MDBlist3Detail;",	"Dump the routine M.F on standard out."	]
[ "mdb",	"List",	"pattern mdb.List():void ",	"MDBlistDetail;",	"Dump the current routine on standard out."	]
[ "mdb",	"dump",	"pattern mdb.dump():void ",	"MDBdump;",	"Dump instruction, stacktrace, and stack"	]
[ "mdb",	"getContext",	"command mdb.getContext(s:str):str ",	"MDBgetExceptionContext;",	"Extract the context string from the exception message"	]
[ "mdb",	"getDebug",	"pattern mdb.getDebug():int ",	"MDBgetDebug;",	"Get the kernel debugging bit-set.\nSee the MonetDB configuration file for details"	]
[ "mdb",	"getDebugFlags",	"pattern mdb.getDebugFlags() (flg:bat[:str], val:bat[:bit]) ",	"MDBgetDebugFlags;",	"Get the kernel debugging flags bit-set"	]
[ "mdb",	"getDefinition",	"pattern mdb.getDefinition():bat[:str] ",	"MDBgetDefinition;",	"Returns a string representation of the current function \n\twith typing information attached"	]
[ "mdb",	"getException",	"command mdb.getException(s:str):str ",	"MDBgetExceptionVariable;",	"Extract the variable name from the exception message"	]
[ "mdb",	"getReason",	"command mdb.getReason(s:str):str ",	"MDBgetExceptionReason;",	"Extract the reason from the exception message"	]
[ "mdb",	"getStackDepth",	"pattern mdb.getStackDepth():int ",	"MDBStkDepth;",	"Return the depth of the calling stack."	]
[ "mdb",	"getStackFrame",	"pattern mdb.getStackFrame() (X_0:bat[:str], X_1:bat[:str]) ",	"MDBgetStackFrame;",	"Collect variable binding of current (n-th) stack frame."	]
[ "mdb",	"getStackFrame",	"pattern mdb.getStackFrame(i:int) (X_0:bat[:str], X_1:bat[:str]) ",	"MDBgetStackFrameN;",	""	]
[ "mdb",	"getStackTrace",	"pattern mdb.getStackTrace() (X_0:bat[:int], X_1:bat[:str]) ",	"MDBStkTrace;",	""	]
[ "mdb",	"getVMsize",	"pattern mdb.getVMsize():lng ",	"MDBgetVMsize;",	"Retrieve the max VM size"	]
[ "mdb",	"inspect",	"pattern mdb.inspect(mod:str, fcn:str):void ",	"MDBinspect;",	"Run the debugger on a specific function"	]
[ "mdb",	"list",	"pattern mdb.list(M:str, F:str):void ",	"MDBlist3;",	"Dump the routine M.F on standard out."	]
[ "mdb",	"list",	"pattern mdb.list():void ",	"MDBlist;",	"Dump the current routine on standard out."	]
[ "mdb",	"listMapi",	"pattern mdb.listMapi():void ",	"MDBlistMapi;",	"Dump the current routine on standard out with Mapi prefix."	]
[ "mdb",	"modules",	"command mdb.modules():bat[:str] ",	"CMDmodules;",	"List available modules"	]
[ "mdb",	"setCatch",	"pattern mdb.setCatch(b:bit):void ",	"MDBsetCatch;",	"Turn on/off catching exceptions"	]
[ "mdb",	"setDebug",	"pattern mdb.setDebug(flg:int):int ",	"MDBsetDebug;",	"Set the kernel debugging bit-set and return its previous value."	]
[ "mdb",	"setDebug",	"pattern mdb.setDebug(flg:str):int ",	"MDBsetDebugStr;",	"Set the kernel debugging bit-set and return its previous value.\nThe recognized options are: threads, memory, properties,\nio, transactions, modules, algorithms, estimates."	]
[ "mdb",	"setTrace",	"pattern mdb.setTrace(b:bit):void ",	"MDBsetTrace;",	"Turn on/off tracing of current routine"	]
[ "mdb",	"setTrace",	"pattern mdb.setTrace(b:str):void ",	"MDBsetVarTrace;",	"Turn on/off tracing of a variable "	]
[ "mdb",	"setVMsize",	"pattern mdb.setVMsize(l:lng):lng ",	"MDBsetVMsize;",	"Manipulate the VM max size in MBs"	]
[ "mdb",	"start",	"pattern mdb.start():void ",	"MDBstart;",	"Start interactive debugger"	]
[ "mdb",	"start",	"pattern mdb.start(clientid:int):void ",	"MDBstart;",	"Start interactive debugger on a client"	]
[ "mdb",	"start",	"pattern mdb.start(mod:str, fcn:str):void ",	"MDBstartFactory;",	"Start interactive debugger on a running factory"	]
[ "mdb",	"stop",	"pattern mdb.stop():void ",	"MDBstop;",	"Stop the interactive debugger"	]
[ "mdb",	"var",	"pattern mdb.var(M:str, F:str):void ",	"MDBvar3;",	"Dump the symboltable of routine M.F on standard out."	]
[ "mdb",	"var",	"pattern mdb.var():void ",	"MDBvar;",	"Dump the symboltable of current routine on standard out."	]
[ "mkey",	"bulk_rotate_xor_hash",	"command mkey.bulk_rotate_xor_hash(h:bat[:lng], nbits:int, b:bat[:any_1]):bat[:lng] ",	"MKEYbulk_rotate_xor_hash;",	"pre:  h and b should be synced on head\n         post: [:xor=]([:rotate=](h, nbits), [hash](b))"	]
[ "mkey",	"bulk_rotate_xor_hash",	"pattern mkey.bulk_rotate_xor_hash(h:bat[:lng], nbits:int, v:any):bat[:lng] ",	"MKEYbulkconst_rotate_xor_hash;",	"pre:  h and b should be synced on head\n         post: [:xor=]([:rotate=](h, nbits), [hash](b))"	]
[ "mkey",	"bulk_rotate_xor_hash",	"command mkey.bulk_rotate_xor_hash(h:lng, nbits:int, b:bat[:any_1]):bat[:lng] ",	"MKEYconstbulk_rotate_xor_hash;",	"pre:  h and b should be synced on head\n         post: [:xor=]([:rotate=](h, nbits), [hash](b))"	]
[ "mkey",	"bulk_rotate_xor_hash",	"pattern mkey.bulk_rotate_xor_hash(h:lng, nbits:int, v:any):lng ",	"MKEYrotate_xor_hash;",	"post: [:xor=]([:rotate=](h, nbits), [hash](b))"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:any):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:bit):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:bte):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:dbl):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:flt):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:hge):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:int):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:lng):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:sht):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:str):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"rotate",	"command mkey.rotate(v:lng, nbits:int):lng ",	"MKEYrotate;",	"left-rotate an int by nbits"	]
[ "mmath",	"acos",	"command mmath.acos(x:dbl):dbl ",	"MATHunary_ACOSdbl;",	"The acos(x) function calculates the arc cosine of x, that is the \n\tvalue whose cosine is x. The value is returned in radians and is \n\tmathematically defined to be between 0 and PI (inclusive)."	]
[ "mmath",	"acos",	"command mmath.acos(x:flt):flt ",	"MATHunary_ACOSflt;",	""	]
[ "mmath",	"asin",	"command mmath.asin(x:dbl):dbl ",	"MATHunary_ASINdbl;",	"The asin(x) function calculates the arc sine of x, that is the value \n\twhose sine is x. The value is returned in radians and is mathematically \n\tdefined to be between -PI/20 and -PI/2 (inclusive)."	]
[ "mmath",	"asin",	"command mmath.asin(x:flt):flt ",	"MATHunary_ASINflt;",	""	]
[ "mmath",	"atan",	"command mmath.atan(x:dbl):dbl ",	"MATHunary_ATANdbl;",	"The atan(x) function calculates the arc tangent of x, that is the value \n\twhose tangent is x. The value is returned in radians and is mathematically \n\tdefined to be between -PI/2 and PI/2 (inclusive)."	]
[ "mmath",	"atan",	"command mmath.atan(x:flt):flt ",	"MATHunary_ATANflt;",	""	]
[ "mmath",	"atan2",	"command mmath.atan2(x:dbl, y:dbl):dbl ",	"MATHbinary_ATAN2dbl;",	"The atan2(x,y) function calculates the arc tangent of the two \n        variables x and y.  It is similar to calculating the arc\n\ttangent of y / x, except that the signs of both arguments are \n        used to determine the quadrant of the result.  The value is \n\treturned in radians and is mathematically defined to be between \n        -PI/2 and PI/2 (inclusive)."	]
[ "mmath",	"atan2",	"command mmath.atan2(x:flt, y:flt):flt ",	"MATHbinary_ATAN2flt;",	""	]
[ "mmath",	"cbrt",	"command mmath.cbrt(y:dbl):dbl ",	"MATHunary_CBRTdbl;",	"The cbrt(x) function returns the cube root of x."	]
[ "mmath",	"cbrt",	"command mmath.cbrt(y:flt):flt ",	"MATHunary_CBRTflt;",	""	]
[ "mmath",	"ceil",	"command mmath.ceil(y:dbl):dbl ",	"MATHunary_CEILdbl;",	"The ceil(x) function rounds x upwards to the nearest integer."	]
[ "mmath",	"ceil",	"command mmath.ceil(y:flt):flt ",	"MATHunary_CEILflt;",	""	]
[ "mmath",	"cos",	"command mmath.cos(x:dbl):dbl ",	"MATHunary_COSdbl;",	"The cos(x) function returns the cosine of x, where x is given in \n        radians. The return value is between -1 and 1."	]
[ "mmath",	"cos",	"command mmath.cos(x:flt):flt ",	"MATHunary_COSflt;",	""	]
[ "mmath",	"cosh",	"command mmath.cosh(x:dbl):dbl ",	"MATHunary_COSHdbl;",	"The cosh() function  returns the hyperbolic cosine of x, which is \n\tdefined mathematically as (exp(x) + exp(-x)) / 2."	]
[ "mmath",	"cosh",	"command mmath.cosh(x:flt):flt ",	"MATHunary_COSHflt;",	""	]
[ "mmath",	"cot",	"command mmath.cot(x:dbl):dbl ",	"MATHunary_COTdbl;",	"The cot(x) function returns the Cotangent of x,\n        where x is given in radians"	]
[ "mmath",	"cot",	"command mmath.cot(x:flt):flt ",	"MATHunary_COTflt;",	""	]
[ "mmath",	"degrees",	"command mmath.degrees(x:dbl):dbl ",	"MATHunary_DEGREESdbl;",	"The degrees() function converts radians into degrees"	]
[ "mmath",	"degrees",	"command mmath.degrees(x:flt):flt ",	"MATHunary_DEGREESflt;",	""	]
[ "mmath",	"exp",	"command mmath.exp(x:dbl):dbl ",	"MATHunary_EXPdbl;",	"The exp(x) function returns the value of e (the base of \n        natural logarithms) raised to the power of x."	]
[ "mmath",	"exp",	"command mmath.exp(x:flt):flt ",	"MATHunary_EXPflt;",	""	]
[ "mmath",	"fabs",	"command mmath.fabs(y:dbl):dbl ",	"MATHunary_FABSdbl;",	"The fabs(x) function  returns  the  absolute value of the \n        floating-point number x."	]
[ "mmath",	"finite",	"command mmath.finite(d:dbl):bit ",	"MATHunary_FINITE;",	"The finite(x) function returns true if x is neither infinite \n        nor a 'not-a-number' (NaN) value, and false otherwise."	]
[ "mmath",	"floor",	"command mmath.floor(y:dbl):dbl ",	"MATHunary_FLOORdbl;",	"The floor(x) function rounds x downwards to the nearest integer."	]
[ "mmath",	"floor",	"command mmath.floor(y:flt):flt ",	"MATHunary_FLOORflt;",	""	]
[ "mmath",	"fmod",	"pattern mmath.fmod(y:dbl, x:dbl):dbl ",	"CMDvarMODsignal;",	"The fmod(x,y) function computes the remainder of dividing x by y.\n\tThe return value is x - n * y, where n is the quotient of x / y,\n\trounded towards zero to an integer."	]
[ "mmath",	"fmod",	"pattern mmath.fmod(y:flt, x:flt):flt ",	"CMDvarMODsignal;",	""	]
[ "mmath",	"isinf",	"command mmath.isinf(d:dbl):int ",	"MATHunary_ISINF;",	"The isinf(x) function returns -1 if x represents negative \n        infinity, 1 if x represents positive infinity, and 0 otherwise."	]
[ "mmath",	"isnan",	"command mmath.isnan(d:dbl):bit ",	"MATHunary_ISNAN;",	"The isnan(x) function returns true if x is 'not-a-number' \n        (NaN), and false otherwise."	]
[ "mmath",	"log",	"command mmath.log(x:dbl, base:dbl):dbl ",	"MATHbinary_LOGdbl;",	"The log(x) function returns the logarithm of x in the given base."	]
[ "mmath",	"log",	"command mmath.log(x:flt, base:flt):flt ",	"MATHbinary_LOGflt;",	"The log(x) function returns the logarithm of x in the given base."	]
[ "mmath",	"log",	"command mmath.log(x:dbl):dbl ",	"MATHunary_LOGdbl;",	"The log(x) function returns the natural logarithm of x."	]
[ "mmath",	"log",	"command mmath.log(x:flt):flt ",	"MATHunary_LOGflt;",	""	]
[ "mmath",	"log10",	"command mmath.log10(x:dbl):dbl ",	"MATHunary_LOG10dbl;",	"The log10(x) function returns the base-10 logarithm of x."	]
[ "mmath",	"log10",	"command mmath.log10(x:flt):flt ",	"MATHunary_LOG10flt;",	""	]
[ "mmath",	"log2",	"command mmath.log2(x:dbl):dbl ",	"MATHunary_LOG2dbl;",	"The log2(x) function returns the base-2 logarithm of x."	]
[ "mmath",	"log2",	"command mmath.log2(x:flt):flt ",	"MATHunary_LOG2flt;",	""	]
[ "mmath",	"pi",	"command mmath.pi():dbl ",	"MATHpi;",	"return an important mathematical value"	]
[ "mmath",	"pow",	"command mmath.pow(x:dbl, y:dbl):dbl ",	"MATHbinary_POWdbl;",	"The pow(x,y) function  returns the value of x raised to the power of y."	]
[ "mmath",	"pow",	"command mmath.pow(x:flt, y:flt):flt ",	"MATHbinary_POWflt;",	""	]
[ "mmath",	"prelude",	"command mmath.prelude():void ",	"MATHprelude;",	"initilize mmath module"	]
[ "mmath",	"radians",	"command mmath.radians(x:dbl):dbl ",	"MATHunary_RADIANSdbl;",	"The radians() function converts degrees into radians"	]
[ "mmath",	"radians",	"command mmath.radians(x:flt):flt ",	"MATHunary_RADIANSflt;",	""	]
[ "mmath",	"rand",	"unsafe command mmath.rand():int ",	"MATHrandint;",	"return a random number"	]
[ "mmath",	"rand",	"unsafe command mmath.rand(v:int):int ",	"MATHrandintarg;",	"return a random number"	]
[ "mmath",	"round",	"command mmath.round(x:dbl, y:int):dbl ",	"MATHbinary_ROUNDdbl;",	"The round(n, m) returns n rounded to m places to the right \n        of the decimal point; if m is omitted, to 0 places. m can be \n\tnegative to round off digits left of the decimal point. \n        m must be an integer."	]
[ "mmath",	"round",	"command mmath.round(x:flt, y:int):flt ",	"MATHbinary_ROUNDflt;",	""	]
[ "mmath",	"sin",	"command mmath.sin(x:dbl):dbl ",	"MATHunary_SINdbl;",	"The sin(x) function returns the cosine of x, where x is given in \n        radians. The return value is between -1 and 1."	]
[ "mmath",	"sin",	"command mmath.sin(x:flt):flt ",	"MATHunary_SINflt;",	""	]
[ "mmath",	"sinh",	"command mmath.sinh(x:dbl):dbl ",	"MATHunary_SINHdbl;",	"The sinh() function  returns  the  hyperbolic sine of x, which \n        is defined mathematically as (exp(x) - exp(-x)) / 2."	]
[ "mmath",	"sinh",	"command mmath.sinh(x:flt):flt ",	"MATHunary_SINHflt;",	""	]
[ "mmath",	"sqlrand",	"command mmath.sqlrand(seed:int):int ",	"MATHsqlrandint;",	"initialize the rand() function with a seed and call rand()"	]
[ "mmath",	"sqrt",	"command mmath.sqrt(y:dbl):dbl ",	"MATHunary_SQRTdbl;",	"The sqrt(x) function returns the non-negative root of x."	]
[ "mmath",	"sqrt",	"command mmath.sqrt(y:flt):flt ",	"MATHunary_SQRTflt;",	""	]
[ "mmath",	"srand",	"command mmath.srand(seed:int):void ",	"MATHsrandint;",	"initialize the rand() function with a seed"	]
[ "mmath",	"tan",	"command mmath.tan(x:dbl):dbl ",	"MATHunary_TANdbl;",	"The tan(x) function returns the tangent of x,\n        where x is given in radians"	]
[ "mmath",	"tan",	"command mmath.tan(x:flt):flt ",	"MATHunary_TANflt;",	""	]
[ "mmath",	"tanh",	"command mmath.tanh(x:dbl):dbl ",	"MATHunary_TANHdbl;",	"The tanh() function returns the hyperbolic tangent of x, which is \n\tdefined mathematically as sinh(x) / cosh(x)."	]
[ "mmath",	"tanh",	"command mmath.tanh(x:flt):flt ",	"MATHunary_TANHflt;",	""	]
[ "mtime",	"addmonths",	"command mtime.addmonths(value:date, months:int):date ",	"MTIMEdate_addmonths;",	"returns the date after a number of\n\tmonths (possibly negative)."	]
[ "mtime",	"century",	"command mtime.century(d:date):int ",	"MTIMEdate_extract_century;",	"extracts century from date."	]
[ "mtime",	"century",	"command mtime.century(t:timestamp):int ",	"MTIMEtimestamp_century;",	""	]
[ "mtime",	"current_date",	"command mtime.current_date():date ",	"MTIMEcurrent_date;",	""	]
[ "mtime",	"current_time",	"command mtime.current_time():daytime ",	"MTIMEcurrent_time;",	""	]
[ "mtime",	"current_timestamp",	"command mtime.current_timestamp():timestamp ",	"MTIMEcurrent_timestamp;",	""	]
[ "mtime",	"date_add_msec_interval",	"command mtime.date_add_msec_interval(t:date, ms:lng):date ",	"MTIMEdate_add_msec_interval;",	""	]
[ "mtime",	"date_sub_month_interval",	"command mtime.date_sub_month_interval(t:date, s:int):date ",	"MTIMEdate_submonths;",	"Subtract months from a date"	]
[ "mtime",	"date_sub_msec_interval",	"command mtime.date_sub_msec_interval(t:date, ms:lng):date ",	"MTIMEdate_sub_msec_interval;",	""	]
[ "mtime",	"date_to_str",	"command mtime.date_to_str(d:date, format:str):str ",	"MTIMEdate_to_str;",	"create a string from the date, using the specified format (see man strftime)"	]
[ "mtime",	"day",	"command mtime.day(d:date):int ",	"MTIMEdate_extract_day;",	"extracts day from date "	]
[ "mtime",	"day",	"command mtime.day(msecs:lng):lng ",	"MTIMEsql_day;",	""	]
[ "mtime",	"day",	"command mtime.day(t:timestamp):int ",	"MTIMEtimestamp_day;",	""	]
[ "mtime",	"dayofweek",	"command mtime.dayofweek(d:date):int ",	"MTIMEdate_extract_dayofweek;",	"Returns the current day of the week\n\twhere 1=monday, .., 7=sunday"	]
[ "mtime",	"dayofyear",	"command mtime.dayofyear(d:date):int ",	"MTIMEdate_extract_dayofyear;",	"Returns N where d is the Nth day\n\tof the year (january 1 returns 1)"	]
[ "mtime",	"decade",	"command mtime.decade(d:date):int ",	"MTIMEdate_extract_decade;",	"extracts decade from date."	]
[ "mtime",	"decade",	"command mtime.decade(t:timestamp):int ",	"MTIMEtimestamp_decade;",	""	]
[ "mtime",	"diff",	"command mtime.diff(val1:date, val2:date):int ",	"MTIMEdate_diff;",	"returns the number of days\n\tbetween 'val1' and 'val2'."	]
[ "mtime",	"diff",	"command mtime.diff(val1:daytime, val2:daytime):lng ",	"MTIMEdaytime_diff_msec;",	"returns the number of msec between 'val1' and 'val2'."	]
[ "mtime",	"diff",	"command mtime.diff(val1:timestamp, val2:timestamp):lng ",	"MTIMEtimestamp_diff_msec;",	"returns the number of milliseconds\n\tbetween 'val1' and 'val2'."	]
[ "mtime",	"epoch",	"command mtime.epoch(t:timestamp):int ",	"MTIMEseconds_since_epoch;",	"unix-time (epoch) support: seconds since epoch"	]
[ "mtime",	"epoch",	"command mtime.epoch(t:lng):timestamp ",	"MTIMEtimestamp_frommsec;",	"convert milli seconds since epoch into a timestamp"	]
[ "mtime",	"epoch",	"command mtime.epoch(t:int):timestamp ",	"MTIMEtimestamp_fromsecond;",	"convert seconds since epoch into a timestamp"	]
[ "mtime",	"hours",	"command mtime.hours(h:daytime):int ",	"MTIMEdaytime_extract_hours;",	"extracts hour from daytime"	]
[ "mtime",	"hours",	"command mtime.hours(msecs:lng):int ",	"MTIMEsql_hours;",	""	]
[ "mtime",	"hours",	"command mtime.hours(t:timestamp):int ",	"MTIMEtimestamp_hours;",	""	]
[ "mtime",	"local_timezone",	"command mtime.local_timezone():lng ",	"MTIMElocal_timezone_msec;",	"get the local timezone in seconds"	]
[ "mtime",	"minutes",	"command mtime.minutes(d:daytime):int ",	"MTIMEdaytime_extract_minutes;",	"extracts minutes from daytime"	]
[ "mtime",	"minutes",	"command mtime.minutes(msecs:lng):int ",	"MTIMEsql_minutes;",	""	]
[ "mtime",	"minutes",	"command mtime.minutes(t:timestamp):int ",	"MTIMEtimestamp_minutes;",	""	]
[ "mtime",	"month",	"command mtime.month(d:date):int ",	"MTIMEdate_extract_month;",	"extracts month from date"	]
[ "mtime",	"month",	"command mtime.month(months:int):int ",	"MTIMEsql_month;",	""	]
[ "mtime",	"month",	"command mtime.month(t:timestamp):int ",	"MTIMEtimestamp_month;",	""	]
[ "mtime",	"quarter",	"command mtime.quarter(d:date):int ",	"MTIMEdate_extract_quarter;",	"extracts quarter from date"	]
[ "mtime",	"quarter",	"command mtime.quarter(t:timestamp):int ",	"MTIMEtimestamp_quarter;",	""	]
[ "mtime",	"seconds",	"command mtime.seconds(msecs:lng):int ",	"MTIMEsql_seconds;",	""	]
[ "mtime",	"sql_seconds",	"command mtime.sql_seconds(d:daytime):int ",	"MTIMEdaytime_extract_sql_seconds;",	"extracts seconds (with fractional milliseconds) from daytime"	]
[ "mtime",	"sql_seconds",	"command mtime.sql_seconds(t:timestamp):int ",	"MTIMEtimestamp_sql_seconds;",	""	]
[ "mtime",	"str_to_date",	"command mtime.str_to_date(s:str, format:str):date ",	"MTIMEstr_to_date;",	"create a date from the string, using the specified format (see man strptime)"	]
[ "mtime",	"str_to_time",	"command mtime.str_to_time(s:str, format:str):daytime ",	"MTIMEstr_to_time;",	"create a time from the string, using the specified format (see man strptime)"	]
[ "mtime",	"str_to_timestamp",	"command mtime.str_to_timestamp(s:str, format:str):timestamp ",	"MTIMEstr_to_timestamp;",	"create a timestamp from the string, using the specified format (see man strptime)"	]
[ "mtime",	"time_add_msec_interval",	"command mtime.time_add_msec_interval(t:daytime, ms:lng):daytime ",	"MTIMEtime_add_msec_interval;",	"Add seconds to a time"	]
[ "mtime",	"time_sub_msec_interval",	"command mtime.time_sub_msec_interval(t:daytime, ms:lng):daytime ",	"MTIMEtime_sub_msec_interval;",	"Subtract seconds from a time"	]
[ "mtime",	"time_to_str",	"command mtime.time_to_str(d:daytime, format:str):str ",	"MTIMEtime_to_str;",	"create a string from the time, using the specified format (see man strftime)"	]
[ "mtime",	"timestamp_add_month_interval",	"command mtime.timestamp_add_month_interval(t:timestamp, s:int):timestamp ",	"MTIMEtimestamp_add_month_interval;",	"Add months to a timestamp"	]
[ "mtime",	"timestamp_add_msec_interval",	"command mtime.timestamp_add_msec_interval(t:timestamp, ms:lng):timestamp ",	"MTIMEtimestamp_add_msec_interval;",	""	]
[ "mtime",	"timestamp_sub_month_interval",	"command mtime.timestamp_sub_month_interval(t:timestamp, s:int):timestamp ",	"MTIMEtimestamp_sub_month_interval;",	"Subtract months from a timestamp"	]
[ "mtime",	"timestamp_sub_msec_interval",	"command mtime.timestamp_sub_msec_interval(t:timestamp, ms:lng):timestamp ",	"MTIMEtimestamp_sub_msec_interval;",	""	]
[ "mtime",	"timestamp_to_str",	"command mtime.timestamp_to_str(d:timestamp, format:str):str ",	"MTIMEtimestamp_to_str;",	"create a string from the time, using the specified format (see man strftime)"	]
[ "mtime",	"weekofyear",	"command mtime.weekofyear(d:date):int ",	"MTIMEdate_extract_weekofyear;",	"Returns the week number in the year."	]
[ "mtime",	"year",	"command mtime.year(d:date):int ",	"MTIMEdate_extract_year;",	"extracts year from date."	]
[ "mtime",	"year",	"command mtime.year(months:int):int ",	"MTIMEsql_year;",	""	]
[ "mtime",	"year",	"command mtime.year(t:timestamp):int ",	"MTIMEtimestamp_year;",	""	]
[ "netcdf",	"attach",	"pattern netcdf.attach(filename:str):void ",	"NCDFattach;",	"Register a NetCDF file in the vault"	]
[ "netcdf",	"importvar",	"command netcdf.importvar(filename:str, varid:int):str ",	"NCDFimportVarStmt;",	"Import variable: compose create array string"	]
[ "netcdf",	"importvariable",	"pattern netcdf.importvariable(fileid:int, varname:str):void ",	"NCDFimportVariable;",	"Import variable: create array and load data from variable varname of file fileid"	]
[ "netcdf",	"test",	"command netcdf.test(filename:str):int ",	"NCDFtest;",	"Returns number of variables in a given NetCDF dataset (file)"	]
[ "oltp",	"disable",	"unsafe pattern oltp.disable():void ",	"OLTPdisable;",	"Disable the OLTP delay monitor"	]
[ "oltp",	"enable",	"unsafe pattern oltp.enable():void ",	"OLTPenable;",	"Enable the OLTP delay monitor"	]
[ "oltp",	"init",	"unsafe pattern oltp.init():void ",	"OLTPinit;",	"Initialize the lock table"	]
[ "oltp",	"isenabled",	"unsafe command oltp.isenabled():int ",	"OLTPis_enabled;",	"Query the OLTP state"	]
[ "oltp",	"lock",	"unsafe pattern oltp.lock(lck:int...):void ",	"OLTPlock;",	"Wait for all write locks needed"	]
[ "oltp",	"release",	"unsafe pattern oltp.release(lck:int...):void ",	"OLTPrelease;",	"Release for all write locks needed"	]
[ "oltp",	"reset",	"unsafe pattern oltp.reset():void ",	"OLTPreset;",	"Reset the OLTP lock table"	]
[ "oltp",	"table",	"unsafe pattern oltp.table() (start:bat[:timestamp], usr:bat[:str], unit:bat[:int], cnt:bat[:int]) ",	"OLTPtable;",	"Show status of lock table"	]
[ "optimizer",	"aliases",	"pattern optimizer.aliases():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"aliases",	"pattern optimizer.aliases(mod:str, fcn:str):str ",	"OPTwrapper;",	"Alias removal optimizer"	]
[ "optimizer",	"candidates",	"pattern optimizer.candidates():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"candidates",	"pattern optimizer.candidates(mod:str, fcn:str):str ",	"OPTwrapper;",	"Mark candidate list variables"	]
[ "optimizer",	"coercions",	"pattern optimizer.coercions():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"coercions",	"pattern optimizer.coercions(mod:str, fcn:str):str ",	"OPTwrapper;",	"Handle simple type coercions"	]
[ "optimizer",	"commonTerms",	"pattern optimizer.commonTerms():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"commonTerms",	"pattern optimizer.commonTerms(mod:any_1, fcn:any_2):str ",	"OPTwrapper;",	"Common sub-expression optimizer"	]
[ "optimizer",	"constants",	"pattern optimizer.constants():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"constants",	"pattern optimizer.constants(mod:str, fcn:str):str ",	"OPTwrapper;",	"Duplicate constant removal optimizer"	]
[ "optimizer",	"costModel",	"pattern optimizer.costModel():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"costModel",	"pattern optimizer.costModel(mod:str, fcn:str):str ",	"OPTwrapper;",	"Estimate the cost of a relational expression"	]
[ "optimizer",	"dataflow",	"pattern optimizer.dataflow():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"dataflow",	"pattern optimizer.dataflow(mod:str, fcn:str):str ",	"OPTwrapper;",	"Dataflow bracket code injection"	]
[ "optimizer",	"deadcode",	"pattern optimizer.deadcode():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"deadcode",	"pattern optimizer.deadcode(mod:str, fcn:str):str ",	"OPTwrapper;",	"Dead code optimizer"	]
[ "optimizer",	"default_pipe",	"function optimizer.default_pipe():void;",	"",	""	]
[ "optimizer",	"emptybind",	"pattern optimizer.emptybind():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"emptybind",	"pattern optimizer.emptybind(mod:str, fcn:str):str ",	"OPTwrapper;",	"Evaluate empty set expressions."	]
[ "optimizer",	"epilogue",	"command optimizer.epilogue():void ",	"optimizer_epilogue;",	"release the resources held by the optimizer module"	]
[ "optimizer",	"evaluate",	"pattern optimizer.evaluate():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"evaluate",	"pattern optimizer.evaluate(mod:str, fcn:str):str ",	"OPTwrapper;",	"Evaluate constant expressions once."	]
[ "optimizer",	"garbageCollector",	"pattern optimizer.garbageCollector():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"garbageCollector",	"pattern optimizer.garbageCollector(mod:str, fcn:str):str ",	"OPTwrapper;",	"Garbage collector optimizer"	]
[ "optimizer",	"generator",	"pattern optimizer.generator():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"generator",	"pattern optimizer.generator(mod:str, fcn:str):str ",	"OPTwrapper;",	"Sequence generator optimizer"	]
[ "optimizer",	"inline",	"pattern optimizer.inline():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"inline",	"pattern optimizer.inline(mod:str, fcn:str):str ",	"OPTwrapper;",	"Expand inline functions"	]
[ "optimizer",	"jit",	"pattern optimizer.jit():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"jit",	"pattern optimizer.jit(mod:str, fcn:str):str ",	"OPTwrapper;",	"Propagate candidate lists in just-in-time optimization"	]
[ "optimizer",	"json",	"pattern optimizer.json():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"json",	"pattern optimizer.json(mod:str, fcn:str):str ",	"OPTwrapper;",	"Unroll the mat.pack operation"	]
[ "optimizer",	"macro",	"pattern optimizer.macro(mod:str, fcn:str, targetmod:str, targetfcn:str):void ",	"OPTmacro;",	"Inline a target function used in a specific function."	]
[ "optimizer",	"macro",	"pattern optimizer.macro(targetmod:str, targetfcn:str):void ",	"OPTmacro;",	"Inline the code of the target function."	]
[ "optimizer",	"matpack",	"pattern optimizer.matpack():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"matpack",	"pattern optimizer.matpack(mod:str, fcn:str):str ",	"OPTwrapper;",	"Unroll the mat.pack operation"	]
[ "optimizer",	"mergetable",	"pattern optimizer.mergetable():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"mergetable",	"pattern optimizer.mergetable(mod:str, fcn:str):str ",	"OPTwrapper;",	"Resolve the multi-table definitions"	]
[ "optimizer",	"minimal_pipe",	"function optimizer.minimal_pipe():void;",	"",	""	]
[ "optimizer",	"mitosis",	"pattern optimizer.mitosis():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"mitosis",	"pattern optimizer.mitosis(mod:str, fcn:str):str ",	"OPTwrapper;",	"Modify the plan to exploit parallel processing on multiple cores"	]
[ "optimizer",	"multiplex",	"pattern optimizer.multiplex():void ",	"OPTwrapper;",	"Compiler for multiplexed instructions."	]
[ "optimizer",	"multiplex",	"pattern optimizer.multiplex(mod:str, fcn:str):void ",	"OPTwrapper;",	"Compiler for multiplexed instructions."	]
[ "optimizer",	"no_mitosis_pipe",	"function optimizer.no_mitosis_pipe():void;",	"",	""	]
[ "optimizer",	"oltp",	"pattern optimizer.oltp():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"oltp",	"pattern optimizer.oltp(mod:str, fcn:str):str ",	"OPTwrapper;",	"Inject the OLTP locking primitives."	]
[ "optimizer",	"oltp_pipe",	"function optimizer.oltp_pipe():void;",	"",	""	]
[ "optimizer",	"optimize",	"pattern optimizer.optimize(mod:str, fcn:str):void ",	"QOToptimize;",	"Optimize a specific operation"	]
[ "optimizer",	"orcam",	"pattern optimizer.orcam(mod:str, fcn:str, targetmod:str, targetfcn:str):void ",	"OPTorcam;",	"Inverse macro, find pattern and replace with a function call."	]
[ "optimizer",	"orcam",	"pattern optimizer.orcam(targetmod:str, targetfcn:str):void ",	"OPTorcam;",	"Inverse macro processor for current function"	]
[ "optimizer",	"postfix",	"pattern optimizer.postfix():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"postfix",	"pattern optimizer.postfix(mod:str, fcn:str):str ",	"OPTwrapper;",	"Postfix the plan,e.g. pushing projections"	]
[ "optimizer",	"prelude",	"pattern optimizer.prelude():void ",	"optimizer_prelude;",	"Initialize the optimizer"	]
[ "optimizer",	"profiler",	"pattern optimizer.profiler():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"profiler",	"pattern optimizer.profiler(mod:str, fcn:str):str ",	"OPTwrapper;",	"Collect properties for the profiler"	]
[ "optimizer",	"projectionpath",	"pattern optimizer.projectionpath():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"projectionpath",	"pattern optimizer.projectionpath(mod:str, fcn:str):str ",	"OPTwrapper;",	"Join path constructor"	]
[ "optimizer",	"pushselect",	"pattern optimizer.pushselect():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"pushselect",	"pattern optimizer.pushselect(mod:str, fcn:str):str ",	"OPTwrapper;",	"Push selects down projections"	]
[ "optimizer",	"querylog",	"pattern optimizer.querylog():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"querylog",	"pattern optimizer.querylog(mod:str, fcn:str):str ",	"OPTwrapper;",	"Collect SQL query statistics"	]
[ "optimizer",	"reduce",	"pattern optimizer.reduce():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"reduce",	"pattern optimizer.reduce(mod:str, fcn:str):str ",	"OPTwrapper;",	"Reduce the stack space claims"	]
[ "optimizer",	"remap",	"pattern optimizer.remap():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"remap",	"pattern optimizer.remap(mod:str, fcn:str):str ",	"OPTwrapper;",	"Remapping function calls to a their multiplex variant"	]
[ "optimizer",	"remoteQueries",	"pattern optimizer.remoteQueries():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"remoteQueries",	"pattern optimizer.remoteQueries(mod:str, fcn:str):str ",	"OPTwrapper;",	"Resolve the multi-table definitions"	]
[ "optimizer",	"reorder",	"pattern optimizer.reorder():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"reorder",	"pattern optimizer.reorder(mod:str, fcn:str):str ",	"OPTwrapper;",	"Reorder by dataflow dependencies"	]
[ "optimizer",	"sequential_pipe",	"function optimizer.sequential_pipe():void;",	"",	""	]
[ "optimizer",	"sql_append",	"pattern optimizer.sql_append():str ",	"OPTsql_append;",	"Avoid extra BAT copy with sql.append() whenever possible."	]
[ "optimizer",	"sql_append",	"pattern optimizer.sql_append(mod:str, fcn:str):str ",	"OPTsql_append;",	"Avoid extra BAT copy with sql.append() whenever possible."	]
[ "optimizer",	"volcano",	"pattern optimizer.volcano():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"volcano",	"pattern optimizer.volcano(mod:str, fcn:str):str ",	"OPTwrapper;",	"Simulate volcano style execution"	]
[ "optimizer",	"volcano_pipe",	"function optimizer.volcano_pipe():void;",	"",	""	]
[ "optimizer",	"wlc",	"pattern optimizer.wlc():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"wlc",	"pattern optimizer.wlc(mod:str, fcn:str):str ",	"OPTwrapper;",	"Inject the workload capture-replay primitives."	]
[ "pcre",	"imatch",	"command pcre.imatch(s:str, pat:str):bit ",	"PCREimatch;",	"Caseless Perl Compatible Regular Expression pattern matching against a string"	]
[ "pcre",	"index",	"command pcre.index(pat:pcre, s:str):int ",	"PCREindex;",	"match a pattern, return matched position (or 0 when not found)"	]
[ "pcre",	"match",	"command pcre.match(s:str, pat:str):bit ",	"PCREmatch;",	"Perl Compatible Regular Expression pattern matching against a string"	]
[ "pcre",	"patindex",	"command pcre.patindex(pat:str, s:str):int ",	"PCREpatindex;",	"Location of the first POSIX pattern matching against a string"	]
[ "pcre",	"pcre_quote",	"command pcre.pcre_quote(s:str):str ",	"PCREquote;",	"Return a PCRE pattern string that matches the argument exactly."	]
[ "pcre",	"prelude",	"command pcre.prelude():void ",	"pcre_init;",	"Initialize pcre"	]
[ "pcre",	"replace",	"command pcre.replace(origin:str, pat:str, repl:str, flags:str):str ",	"PCREreplace_wrap;",	"Replace _all_ matches of \"pattern\" in \"origin_str\" with \"replacement\".\n\t Parameter \"flags\" accept these flags: 'i', 'm', 's', and 'x'.\n\t   'e': if present, an empty string is considered to be a valid match\n\t   'i': if present, the match operates in case-insensitive mode.\n\t\tOtherwise, in case-sensitive mode.\n\t   'm': if present, the match operates in multi-line mode.\n\t   's': if present, the match operates in \"dot-all\"\n\t   The specifications of the flags can be found in \"man pcreapi\"\n\t   The flag letters may be repeated.\n\t   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \"flags\".\n\t   Returns the replaced string, or if no matches found, the original string."	]
[ "pcre",	"replace_first",	"command pcre.replace_first(origin:str, pat:str, repl:str, flags:str):str ",	"PCREreplace_wrap;",	"Replace _the first_ match of \"pattern\" in \"origin_str\" with \"replacement\".\n\t Parameter \"flags\" accept these flags: 'i', 'm', 's', and 'x'.\n\t   'e': if present, an empty string is considered to be a valid match\n\t   'i': if present, the match operates in case-insensitive mode.\n\t\tOtherwise, in case-sensitive mode.\n\t   'm': if present, the match operates in multi-line mode.\n\t   's': if present, the match operates in \"dot-all\"\n\t   The specifications of the flags can be found in \"man pcreapi\"\n\t   The flag letters may be repeated.\n\t   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \"flags\".\n\t   Returns the replaced string, or if no matches found, the original string."	]
[ "pcre",	"sql2pcre",	"command pcre.sql2pcre(pat:str, esc:str):str ",	"PCREsql2pcre;",	"Convert a SQL like pattern with the given escape character into a PCRE pattern."	]
[ "profiler",	"cleanup",	"pattern profiler.cleanup():void ",	"CMDcleanupTraces;",	"Remove the temporary tables for profiling"	]
[ "profiler",	"closestream",	"pattern profiler.closestream():void ",	"CMDcloseProfilerStream;",	"Stop offline proviling"	]
[ "profiler",	"cpuload",	"command profiler.cpuload(user:lng, nice:lng, sys:lng, idle:lng, iowait:lng) (cycles:int, io:int) ",	"CMDcpuloadPercentage;",	"Calculate the average cpu load percentage and io waiting times"	]
[ "profiler",	"cpustats",	"command profiler.cpustats() (user:lng, nice:lng, sys:lng, idle:lng, iowait:lng) ",	"CMDcpustats;",	"Extract cpu statistics from the kernel"	]
[ "profiler",	"getDiskReads",	"command profiler.getDiskReads():lng ",	"CMDgetDiskReads;",	"Obtain the number of physical reads"	]
[ "profiler",	"getDiskWrites",	"command profiler.getDiskWrites():lng ",	"CMDgetDiskWrites;",	"Obtain the number of physical reads"	]
[ "profiler",	"getSystemTime",	"command profiler.getSystemTime():lng ",	"CMDgetSystemTime;",	"Obtain the user timing information."	]
[ "profiler",	"getTrace",	"pattern profiler.getTrace(e:str):bat[:any_1] ",	"CMDgetTrace;",	"Get the trace details of a specific event"	]
[ "profiler",	"getUserTime",	"command profiler.getUserTime():lng ",	"CMDgetUserTime;",	"Obtain the user timing information."	]
[ "profiler",	"getlimit",	"command profiler.getlimit():int ",	"CMDgetprofilerlimit;",	"Set profiler limit"	]
[ "profiler",	"noop",	"command profiler.noop():void ",	"CMDnoopProfiler;",	"Fetch any pending performance events"	]
[ "profiler",	"openstream",	"pattern profiler.openstream():void ",	"CMDopenProfilerStream;",	"Start profiling the events, send to output stream"	]
[ "profiler",	"setheartbeat",	"command profiler.setheartbeat(b:int):void ",	"CMDsetHeartbeat;",	"Set heart beat performance tracing"	]
[ "profiler",	"setlimit",	"command profiler.setlimit(l:int):void ",	"CMDsetprofilerlimit;",	"Get profiler limit"	]
[ "profiler",	"start",	"pattern profiler.start():void ",	"CMDstartProfiler;",	"Start offline performance profiling"	]
[ "profiler",	"starttrace",	"pattern profiler.starttrace():void ",	"CMDstartTrace;",	"Start collecting trace information"	]
[ "profiler",	"stop",	"pattern profiler.stop():void ",	"CMDstopProfiler;",	"Stop offline performance profiling"	]
[ "profiler",	"stoptrace",	"pattern profiler.stoptrace():void ",	"CMDstopTrace;",	"Stop collecting trace information"	]
[ "pyapi3",	"eval",	"unsafe pattern pyapi3.eval(fptr:ptr, expr:str):any ",	"PYAPI3PyAPIevalStd;",	"Execute a simple Python script returning a single value"	]
[ "pyapi3",	"eval",	"unsafe pattern pyapi3.eval(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalStd;",	"Execute a simple Python script value"	]
[ "pyapi3",	"eval_aggr",	"unsafe pattern pyapi3.eval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalAggr;",	"grouped aggregates through Python"	]
[ "pyapi3",	"eval_loader",	"unsafe pattern pyapi3.eval_loader(fptr:ptr, expr:str):any... ",	"PYAPI3PyAPIevalLoader;",	"loader functions through Python"	]
[ "pyapi3",	"eval_loader",	"unsafe pattern pyapi3.eval_loader(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalLoader;",	"loader functions through Python"	]
[ "pyapi3",	"prelude",	"command pyapi3.prelude():void ",	"PYAPI3PyAPIprelude;",	""	]
[ "pyapi3",	"subeval_aggr",	"unsafe pattern pyapi3.subeval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalAggr;",	"grouped aggregates through Python"	]
[ "pyapi3map",	"eval",	"pattern pyapi3map.eval(fptr:ptr, expr:str):any ",	"PYAPI3PyAPIevalStdMap;",	"Execute a simple Python script returning a single value"	]
[ "pyapi3map",	"eval",	"pattern pyapi3map.eval(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalStdMap;",	"Execute a simple Python script value"	]
[ "pyapi3map",	"eval_aggr",	"pattern pyapi3map.eval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalAggrMap;",	"grouped aggregates through Python"	]
[ "pyapi3map",	"subeval_aggr",	"pattern pyapi3map.subeval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"PYAPI3PyAPIevalAggrMap;",	"grouped aggregates through Python"	]
[ "querylog",	"append",	"pattern querylog.append(q:str, pipe:str, usr:str, tick:timestamp):void ",	"QLOGappend;",	"Add a new query call to the query log"	]
[ "querylog",	"call",	"pattern querylog.call(tick1:timestamp, tick2:timestamp, arg:str, tuples:lng, xtime:lng, rtime:lng, cpu:int, iowait:int):void ",	"QLOGcall;",	"Add a new query call to the query log"	]
[ "querylog",	"context",	"command querylog.context(release:str, version:str, revision:str, uri:str):void ",	"QLOGcontextNaive;",	"Noop operation, just marking the query"	]
[ "querylog",	"define",	"command querylog.define(q:str, pipe:str, size:int):void ",	"QLOGdefineNaive;",	"Noop operation, just marking the query"	]
[ "querylog",	"disable",	"command querylog.disable():void ",	"QLOGdisable;",	"Turn off the query logger"	]
[ "querylog",	"empty",	"command querylog.empty():void ",	"QLOGempty;",	"Clear the query log tables"	]
[ "querylog",	"enable",	"command querylog.enable():void ",	"QLOGenable;",	"Turn on the query logger"	]
[ "querylog",	"enable",	"command querylog.enable(threshold:int):void ",	"QLOGenableThreshold;",	"Turn on the query logger"	]
[ "querylog",	"isset",	"command querylog.isset():int ",	"QLOGissetFcn;",	"Return status of query logger"	]
[ "rapi",	"eval",	"pattern rapi.eval(fptr:ptr, expr:str):any ",	"RAPIevalStd;",	"Execute a simple R script returning a single value"	]
[ "rapi",	"eval",	"pattern rapi.eval(fptr:ptr, expr:str, arg:any...):any... ",	"RAPIevalStd;",	"Execute a simple R script value"	]
[ "rapi",	"eval_aggr",	"pattern rapi.eval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"RAPIevalAggr;",	"grouped aggregates through R"	]
[ "rapi",	"prelude",	"command rapi.prelude():void ",	"RAPIprelude;",	""	]
[ "rapi",	"subeval_aggr",	"pattern rapi.subeval_aggr(fptr:ptr, expr:str, arg:any...):any... ",	"RAPIevalAggr;",	"grouped aggregates through R"	]
[ "remote",	"batbincopy",	"pattern remote.batbincopy():bat[:any] ",	"RMTbincopyfrom;",	"store the binary BAT data in the BBP and return as BAT"	]
[ "remote",	"batbincopy",	"pattern remote.batbincopy(b:bat[:any]):void ",	"RMTbincopyto;",	"dump BAT b in binary form to the stream"	]
[ "remote",	"batload",	"pattern remote.batload(tt:any_1, size:int):bat[:any_1] ",	"RMTbatload;",	"create a BAT of the given type and size, and load values from the input stream"	]
[ "remote",	"bintype",	"pattern remote.bintype():void ",	"RMTbintype;",	"print the binary type of this mserver5"	]
[ "remote",	"connect",	"command remote.connect(uri:str, user:str, passwd:str):str ",	"RMTconnect;",	"returns a newly created connection for uri, using user name and password"	]
[ "remote",	"connect",	"command remote.connect(uri:str, user:str, passwd:str, scen:str):str ",	"RMTconnectScen;",	"returns a newly created connection for uri, using user name, password and scenario"	]
[ "remote",	"connect",	"pattern remote.connect(table:str, schen:str):str ",	"RMTconnectTable;",	"return a newly created connection for a table. username and password should be in the vault"	]
[ "remote",	"disconnect",	"command remote.disconnect(conn:str):void ",	"RMTdisconnect;",	"disconnects the connection pointed to by handle (received from a call to connect()"	]
[ "remote",	"epilogue",	"command remote.epilogue():void ",	"RMTepilogue;",	"release the resources held by the remote module"	]
[ "remote",	"exec",	"pattern remote.exec(conn:str, mod:str, func:str):str ",	"RMTexec;",	"remotely executes <mod>.<func> and returns the handle to its result"	]
[ "remote",	"exec",	"pattern remote.exec(conn:str, mod:str, func:str):str... ",	"RMTexec;",	"remotely executes <mod>.<func> and returns the handle to its result"	]
[ "remote",	"exec",	"pattern remote.exec(conn:str, mod:str, func:str, X_0:str...):str ",	"RMTexec;",	"remotely executes <mod>.<func> using the argument list of remote objects and returns the handle to its result"	]
[ "remote",	"exec",	"pattern remote.exec(conn:str, mod:str, func:str, X_0:str...):str... ",	"RMTexec;",	"remotely executes <mod>.<func> using the argument list of remote objects and returns the handle to its result"	]
[ "remote",	"get",	"pattern remote.get(conn:str, ident:str):any ",	"RMTget;",	"retrieves a copy of remote object ident"	]
[ "remote",	"isalive",	"command remote.isalive(conn:str):int ",	"RMTisalive;",	"check if conn is still valid and connected"	]
[ "remote",	"prelude",	"command remote.prelude():void ",	"RMTprelude;",	"initialise the remote module"	]
[ "remote",	"put",	"pattern remote.put(conn:str, object:any):str ",	"RMTput;",	"copies object to the remote site and returns its identifier"	]
[ "remote",	"register",	"pattern remote.register(conn:str, mod:str, fcn:str):void ",	"RMTregister;",	"register <mod>.<fcn> at the remote site"	]
[ "remote",	"register_supervisor",	"command remote.register_supervisor(sup_uuid:str, query_uuid:str):int ",	"RMTregisterSupervisor;",	"Register the supervisor uuid at a remote site"	]
[ "remote",	"resolve",	"command remote.resolve(pattern:str):bat[:str] ",	"RMTresolve;",	"resolve a pattern against Merovingian and return the URIs"	]
[ "sample",	"subuniform",	"pattern sample.subuniform(b:bat[:any], p:dbl):bat[:oid] ",	"SAMPLEuniform;",	"Returns the oids of a uniform sample of size = (p x count(b)), where 0 <= p <= 1.0"	]
[ "sample",	"subuniform",	"pattern sample.subuniform(b:bat[:any], p:dbl, sample_seed:int):bat[:oid] ",	"SAMPLEuniform;",	"Returns the oids of a uniform sample of size = (p x count(b)), where 0 <= p <= 1.0 and where the prg is seeded with sample_seed"	]
[ "sample",	"subuniform",	"pattern sample.subuniform(b:bat[:any], sample_size:lng):bat[:oid] ",	"SAMPLEuniform;",	"Returns the oids of a uniform sample of size s"	]
[ "sample",	"subuniform",	"pattern sample.subuniform(b:bat[:any], sample_size:lng, sample_seed:int):bat[:oid] ",	"SAMPLEuniform;",	"Returns the oids of a uniform sample of size s and where the prg is seeded with sample_seed"	]
[ "shp",	"attach",	"pattern shp.attach(filename:str):void ",	"SHPattach;",	"Register an ESRI Shapefile in the vault catalog"	]
[ "shp",	"import",	"pattern shp.import(fileid:int):void ",	"SHPimport;",	"Import an ESRI Shapefile with given id into the vault"	]
[ "shp",	"import",	"pattern shp.import(fileid:int, po:wkb):void ",	"SHPpartialimport;",	"Partially import an ESRI Shapefile with given id into the vault"	]
[ "sql",	"abort",	"unsafe pattern sql.abort():void ",	"SQLabort;",	"Trigger the abort operation for a MAL block"	]
[ "sql",	"affectedRows",	"unsafe pattern sql.affectedRows(mvc:int, nr:lng):int ",	"mvc_affected_rows_wrap;",	"export the number of affected rows by the current query"	]
[ "sql",	"all",	"inline function sql.all(b:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit):bat[:any_1];",	"",	""	]
[ "sql",	"all",	"command sql.all(col:bat[:any_1]):any_1 ",	"SQLall;",	"if all values in col are equal return this, else nil"	]
[ "sql",	"all",	"command sql.all(cmp:bit, nl:bit, nr:bit):bit ",	"SQLall_cmp;",	"if !cmp then false, (nl or nr) then nil, else true"	]
[ "sql",	"alpha",	"command sql.alpha(dec:dbl, theta:dbl):dbl ",	"SQLcst_alpha_cst;",	"Implementation of astronomy alpha function: expands the radius theta depending on the declination"	]
[ "sql",	"analyze",	"unsafe pattern sql.analyze(minmax:int, sample:lng):void ",	"sql_analyze;",	""	]
[ "sql",	"analyze",	"unsafe pattern sql.analyze(minmax:int, sample:lng, sch:str):void ",	"sql_analyze;",	""	]
[ "sql",	"analyze",	"unsafe pattern sql.analyze(minmax:int, sample:lng, sch:str, tbl:str):void ",	"sql_analyze;",	""	]
[ "sql",	"analyze",	"unsafe pattern sql.analyze(minmax:int, sample:lng, sch:str, tbl:str, col:str):void ",	"sql_analyze;",	"Update the database statistics table"	]
[ "sql",	"any",	"command sql.any(cmp:bit, nl:bit, nr:bit):bit ",	"SQLany_cmp;",	"if cmp then true, (nl or nr) nil then nil, else false"	]
[ "sql",	"append",	"pattern sql.append(mvc:int, sname:str, tname:str, cname:str, ins:any):int ",	"mvc_append_wrap;",	"Append to the column tname.cname (possibly optimized to replace the insert bat of tname.cname. Returns sequence number for order dependence."	]
[ "sql",	"argRecord",	"pattern sql.argRecord():str ",	"SQLargRecord;",	"Glue together the calling sequence"	]
[ "sql",	"argRecord",	"pattern sql.argRecord(a:any...):str ",	"SQLargRecord;",	"Glue together the calling sequence"	]
[ "sql",	"assert",	"pattern sql.assert(b:bit, msg:str):void ",	"SQLassert;",	"Generate an exception when b==true"	]
[ "sql",	"assert",	"pattern sql.assert(b:int, msg:str):void ",	"SQLassertInt;",	"Generate an exception when b!=0"	]
[ "sql",	"assert",	"pattern sql.assert(b:lng, msg:str):void ",	"SQLassertLng;",	"Generate an exception when b!=0"	]
[ "sql",	"avg",	"pattern sql.avg(b:bte, s:lng, e:lng):dbl ",	"SQLavg;",	"return the average of groups"	]
[ "sql",	"avg",	"pattern sql.avg(b:dbl, s:lng, e:lng):dbl ",	"SQLavg;",	"return the average of groups"	]
[ "sql",	"avg",	"pattern sql.avg(b:flt, s:lng, e:lng):dbl ",	"SQLavg;",	"return the average of groups"	]
[ "sql",	"avg",	"pattern sql.avg(b:hge, s:lng, e:lng):dbl ",	"SQLavg;",	"return the average of groups"	]
[ "sql",	"avg",	"pattern sql.avg(b:int, s:lng, e:lng):dbl ",	"SQLavg;",	"return the average of groups"	]
[ "sql",	"avg",	"pattern sql.avg(b:lng, s:lng, e:lng):dbl ",	"SQLavg;",	"return the average of groups"	]
[ "sql",	"avg",	"pattern sql.avg(b:sht, s:lng, e:lng):dbl ",	"SQLavg;",	"return the average of groups"	]
[ "sql",	"bind",	"pattern sql.bind(mvc:int, schema:str, table:str, column:str, access:int) (uid:bat[:oid], uval:bat[:any_1]) ",	"mvc_bind_wrap;",	"Bind the 'schema.table.column' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind",	"pattern sql.bind(mvc:int, schema:str, table:str, column:str, access:int):bat[:any_1] ",	"mvc_bind_wrap;",	"Bind the 'schema.table.column' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind",	"pattern sql.bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int) (uid:bat[:oid], uval:bat[:any_1]) ",	"mvc_bind_wrap;",	"Bind the 'schema.table.column' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind",	"pattern sql.bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int):bat[:any_1] ",	"mvc_bind_wrap;",	"Bind the 'schema.table.column' BAT partition with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind_idxbat",	"pattern sql.bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int) (uid:bat[:oid], uval:bat[:any_1]) ",	"mvc_bind_idxbat_wrap;",	"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind_idxbat",	"pattern sql.bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int):bat[:any_1] ",	"mvc_bind_idxbat_wrap;",	"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind_idxbat",	"pattern sql.bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int) (uid:bat[:oid], uval:bat[:any_1]) ",	"mvc_bind_idxbat_wrap;",	"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind_idxbat",	"pattern sql.bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int):bat[:any_1] ",	"mvc_bind_idxbat_wrap;",	"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"clear_table",	"unsafe pattern sql.clear_table(sname:str, tname:str):lng ",	"mvc_clear_table_wrap;",	"Clear the table sname.tname."	]
[ "sql",	"commit",	"unsafe pattern sql.commit():void ",	"SQLcommit;",	"Trigger the commit operation for a MAL block"	]
[ "sql",	"copy_from",	"unsafe pattern sql.copy_from(t:ptr, sep:str, rsep:str, ssep:str, ns:str, fname:str, nr:lng, offset:lng, locked:int, best:int, fwf:str, onclient:int):bat[:any]... ",	"mvc_import_table_wrap;",	"Import a table from bstream s with the \n\tgiven tuple and seperators (sep/rsep)"	]
[ "sql",	"copy_rejects",	"pattern sql.copy_rejects() (rowid:bat[:lng], fldid:bat[:int], msg:bat[:str], inp:bat[:str]) ",	"COPYrejects;",	""	]
[ "sql",	"copy_rejects_clear",	"unsafe pattern sql.copy_rejects_clear():void ",	"COPYrejects_clear;",	""	]
[ "sql",	"corr",	"pattern sql.corr(b:bte, c:bte, s:lng, e:lng):dbl ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "sql",	"corr",	"pattern sql.corr(b:dbl, c:dbl, s:lng, e:lng):dbl ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "sql",	"corr",	"pattern sql.corr(b:flt, c:flt, s:lng, e:lng):dbl ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "sql",	"corr",	"pattern sql.corr(b:hge, c:hge, s:lng, e:lng):dbl ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "sql",	"corr",	"pattern sql.corr(b:int, c:int, s:lng, e:lng):dbl ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "sql",	"corr",	"pattern sql.corr(b:lng, c:lng, s:lng, e:lng):dbl ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "sql",	"corr",	"pattern sql.corr(b:sht, c:sht, s:lng, e:lng):dbl ",	"SQLcorr;",	"return the correlation value of groups"	]
[ "sql",	"count",	"pattern sql.count(b:any_1, ignils:bit, s:lng, e:lng):lng ",	"SQLcount;",	"return count of groups"	]
[ "sql",	"covariance",	"pattern sql.covariance(b:bte, c:bte, s:lng, e:lng):dbl ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "sql",	"covariance",	"pattern sql.covariance(b:dbl, c:dbl, s:lng, e:lng):dbl ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "sql",	"covariance",	"pattern sql.covariance(b:flt, c:flt, s:lng, e:lng):dbl ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "sql",	"covariance",	"pattern sql.covariance(b:hge, c:hge, s:lng, e:lng):dbl ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "sql",	"covariance",	"pattern sql.covariance(b:int, c:int, s:lng, e:lng):dbl ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "sql",	"covariance",	"pattern sql.covariance(b:lng, c:lng, s:lng, e:lng):dbl ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "sql",	"covariance",	"pattern sql.covariance(b:sht, c:sht, s:lng, e:lng):dbl ",	"SQLcovar_samp;",	"return the covariance sample value of groups"	]
[ "sql",	"covariancep",	"pattern sql.covariancep(b:bte, c:bte, s:lng, e:lng):dbl ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "sql",	"covariancep",	"pattern sql.covariancep(b:dbl, c:dbl, s:lng, e:lng):dbl ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "sql",	"covariancep",	"pattern sql.covariancep(b:flt, c:flt, s:lng, e:lng):dbl ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "sql",	"covariancep",	"pattern sql.covariancep(b:hge, c:hge, s:lng, e:lng):dbl ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "sql",	"covariancep",	"pattern sql.covariancep(b:int, c:int, s:lng, e:lng):dbl ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "sql",	"covariancep",	"pattern sql.covariancep(b:lng, c:lng, s:lng, e:lng):dbl ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "sql",	"covariancep",	"pattern sql.covariancep(b:sht, c:sht, s:lng, e:lng):dbl ",	"SQLcovar_pop;",	"return the covariance population value of groups"	]
[ "sql",	"createorderindex",	"unsafe pattern sql.createorderindex(sch:str, tbl:str, col:str):void ",	"sql_createorderindex;",	"Instantiate the order index on a column"	]
[ "sql",	"cume_dist",	"pattern sql.cume_dist(b:any_1, p:bit, o:bit):dbl ",	"SQLcume_dist;",	"return the accumulated distribution of the number of rows per group to the total number of partition rows"	]
[ "sql",	"current_time",	"pattern sql.current_time():daytime ",	"SQLcurrent_daytime;",	"Get the clients current daytime"	]
[ "sql",	"current_timestamp",	"pattern sql.current_timestamp():timestamp ",	"SQLcurrent_timestamp;",	"Get the clients current timestamp"	]
[ "sql",	"date_trunc",	"command sql.date_trunc(scale:str, v:bat[:timestamp]):bat[:timestamp] ",	"bat_date_trunc;",	"Truncate a timestamp to (millennium, century,decade,year,quarter,month,week,day,hour,minute,second, milliseconds,microseconds)"	]
[ "sql",	"date_trunc",	"command sql.date_trunc(scale:str, v:timestamp):timestamp ",	"date_trunc;",	"Truncate a timestamp to (millennium, century,decade,year,quarter,month,week,day,hour,minute,second, milliseconds,microseconds)"	]
[ "sql",	"db_users",	"pattern sql.db_users():bat[:str] ",	"db_users_wrap;",	"return table of users with sql scenario"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:bte, r:bte):bte ",	"bte_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:dbl, r:dbl):dbl ",	"dbl_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:flt, r:flt):flt ",	"flt_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:hge, r:hge):hge ",	"hge_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:int, r:int):int ",	"int_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:lng, r:lng):lng ",	"lng_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:sht, r:sht):sht ",	"sht_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"delete",	"unsafe pattern sql.delete(mvc:int, sname:str, tname:str, b:any):int ",	"mvc_delete_wrap;",	"Delete a row from a table. Returns sequence number for order dependence."	]
[ "sql",	"delta",	"command sql.delta(col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3]):bat[:any_3] ",	"DELTAbat2;",	"Return column bat with delta's applied."	]
[ "sql",	"delta",	"command sql.delta(col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3], ins:bat[:any_3]):bat[:any_3] ",	"DELTAbat;",	"Return column bat with delta's applied."	]
[ "sql",	"deltas",	"pattern sql.deltas(schema:str) (ids:bat[:int], cleared:bat[:bit], readonly:bat[:lng], inserted:bat[:lng], updated:bat[:lng], deleted:bat[:lng], tr_level:bat[:int]) ",	"mvc_delta_values;",	"Return the delta values sizes of all columns of the schema's tables, plus the current transaction level"	]
[ "sql",	"deltas",	"pattern sql.deltas(schema:str, table:str) (ids:bat[:int], cleared:bat[:bit], readonly:bat[:lng], inserted:bat[:lng], updated:bat[:lng], deleted:bat[:lng], tr_level:bat[:int]) ",	"mvc_delta_values;",	"Return the delta values sizes from the table's columns, plus the current transaction level"	]
[ "sql",	"deltas",	"pattern sql.deltas(schema:str, table:str, column:str) (ids:bat[:int], cleared:bat[:bit], readonly:bat[:lng], inserted:bat[:lng], updated:bat[:lng], deleted:bat[:lng], tr_level:bat[:int]) ",	"mvc_delta_values;",	"Return the delta values sizes of a column, plus the current transaction level"	]
[ "sql",	"dense_rank",	"pattern sql.dense_rank(b:any_1, p:bit, o:bit):int ",	"SQLdense_rank;",	"return the densely ranked groups"	]
[ "sql",	"diff",	"pattern sql.diff(b:any_1):bit ",	"SQLdiff;",	"return true if cur != prev row"	]
[ "sql",	"diff",	"pattern sql.diff(p:bit, b:any_1):bit ",	"SQLdiff;",	"return true if cur != prev row"	]
[ "sql",	"drop_hash",	"unsafe pattern sql.drop_hash(sch:str, tbl:str):void ",	"SQLdrop_hash;",	"Drop hash indices for the given table"	]
[ "sql",	"droporderindex",	"unsafe pattern sql.droporderindex(sch:str, tbl:str, col:str):void ",	"sql_droporderindex;",	"Drop the order index on a column"	]
[ "sql",	"dump_cache",	"pattern sql.dump_cache() (query:bat[:str], count:bat[:int]) ",	"dump_cache;",	"dump the content of the query cache"	]
[ "sql",	"dump_opt_stats",	"pattern sql.dump_opt_stats() (rewrite:bat[:str], count:bat[:int]) ",	"dump_opt_stats;",	"dump the optimizer rewrite statistics"	]
[ "sql",	"dump_trace",	"pattern sql.dump_trace() (ticks:bat[:lng], stmt:bat[:str]) ",	"dump_trace;",	"dump the trace statistics"	]
[ "sql",	"emptybind",	"pattern sql.emptybind(mvc:int, schema:str, table:str, column:str, access:int) (uid:bat[:oid], uval:bat[:any_1]) ",	"mvc_bind_wrap;",	""	]
[ "sql",	"emptybind",	"pattern sql.emptybind(mvc:int, schema:str, table:str, column:str, access:int):bat[:any_1] ",	"mvc_bind_wrap;",	""	]
[ "sql",	"emptybind",	"pattern sql.emptybind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int) (uid:bat[:oid], uval:bat[:any_1]) ",	"mvc_bind_wrap;",	""	]
[ "sql",	"emptybind",	"pattern sql.emptybind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int):bat[:any_1] ",	"mvc_bind_wrap;",	""	]
[ "sql",	"emptybindidx",	"pattern sql.emptybindidx(mvc:int, schema:str, table:str, index:str, access:int) (uid:bat[:oid], uval:bat[:any_1]) ",	"mvc_bind_idxbat_wrap;",	""	]
[ "sql",	"emptybindidx",	"pattern sql.emptybindidx(mvc:int, schema:str, table:str, index:str, access:int):bat[:any_1] ",	"mvc_bind_idxbat_wrap;",	""	]
[ "sql",	"emptybindidx",	"pattern sql.emptybindidx(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int) (uid:bat[:oid], uval:bat[:any_1]) ",	"mvc_bind_idxbat_wrap;",	""	]
[ "sql",	"emptybindidx",	"pattern sql.emptybindidx(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int):bat[:any_1] ",	"mvc_bind_idxbat_wrap;",	""	]
[ "sql",	"epilogue",	"command sql.epilogue():void ",	"SQLepilogue;",	""	]
[ "sql",	"eval",	"pattern sql.eval(cmd:str):void ",	"SQLstatement;",	"Compile and execute a single sql statement"	]
[ "sql",	"eval",	"pattern sql.eval(cmd:str, output:bit):void ",	"SQLstatement;",	"Compile and execute a single sql statement (and optionaly send output on the output stream)"	]
[ "sql",	"evalAlgebra",	"pattern sql.evalAlgebra(cmd:str, optimize:bit):void ",	"RAstatement;",	"Compile and execute a single 'relational algebra' statement"	]
[ "sql",	"exportChunk",	"unsafe pattern sql.exportChunk(s:streams, res_id:int):void ",	"mvc_export_chunk_wrap;",	"Export a chunk of the result set (in order) to stream s"	]
[ "sql",	"exportChunk",	"unsafe pattern sql.exportChunk(s:streams, res_id:int, offset:int, nr:int):void ",	"mvc_export_chunk_wrap;",	"Export a chunk of the result set (in order) to stream s"	]
[ "sql",	"exportHead",	"unsafe pattern sql.exportHead(s:streams, res_id:int):void ",	"mvc_export_head_wrap;",	"Export a result (in order) to stream s"	]
[ "sql",	"exportOperation",	"unsafe pattern sql.exportOperation():void ",	"mvc_export_operation_wrap;",	"Export result of schema/transaction queries"	]
[ "sql",	"exportResult",	"unsafe pattern sql.exportResult(s:streams, res_id:int):void ",	"mvc_export_result_wrap;",	"Export a result (in order) to stream s"	]
[ "sql",	"export_table",	"unsafe pattern sql.export_table(fname:str, fmt:str, colsep:str, recsep:str, qout:str, nullrep:str, onclient:int, tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int], scale:bat[:int], cols:any...):int ",	"mvc_export_row_wrap;",	"Prepare a table result set for the COPY INTO stream"	]
[ "sql",	"export_table",	"unsafe pattern sql.export_table(fname:str, fmt:str, colsep:str, recsep:str, qout:str, nullrep:str, onclient:int, tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int], scale:bat[:int], cols:bat[:any]...):int ",	"mvc_export_table_wrap;",	"Prepare a table result set for the COPY INTO stream"	]
[ "sql",	"first_value",	"pattern sql.first_value(b:any_1, s:lng, e:lng):any_1 ",	"SQLfirst_value;",	"return the first value of groups"	]
[ "sql",	"flush_log",	"unsafe command sql.flush_log():void ",	"SQLflush_log;",	"start flushing the write ahead log"	]
[ "sql",	"getVariable",	"pattern sql.getVariable(mvc:int, varname:str):any_1 ",	"getVariable;",	"Get the value of a session variable"	]
[ "sql",	"getVersion",	"command sql.getVersion(clientid:int):lng ",	"mvc_getVersion;",	"Return the database version identifier for a client."	]
[ "sql",	"get_value",	"pattern sql.get_value(sname:str, sequence:str):lng ",	"mvc_get_value;",	"return the current value of the sequence"	]
[ "sql",	"grow",	"pattern sql.grow(tid:bat[:oid], X_0:any_1):int ",	"mvc_grow_wrap;",	"Resize the tid column of a declared table."	]
[ "sql",	"hot_snapshot",	"unsafe command sql.hot_snapshot(tarfile:str):void ",	"SQLhot_snapshot;",	"Write db snapshot to the given tar(.gz) file"	]
[ "sql",	"importTable",	"unsafe pattern sql.importTable(sname:str, tname:str, onclient:int, fname:str...):bat[:any]... ",	"mvc_bin_import_table_wrap;",	"Import a table from the files (fname)"	]
[ "sql",	"include",	"pattern sql.include(fname:str):void ",	"SQLinclude;",	"Compile and execute a sql statements on the file"	]
[ "sql",	"lag",	"pattern sql.lag(b:any_1, l:any_2, d:any_1, p:any_3, o:any_4):any_1 ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or 'd' if non existent"	]
[ "sql",	"lag",	"pattern sql.lag(b:any_1, l:any_2, p:any_3, o:any_4):any_1 ",	"SQLlag;",	"return the value in the previous 'l' row in the partition or NULL if non existent"	]
[ "sql",	"lag",	"pattern sql.lag(b:any_1, p:any_3, o:any_4):any_1 ",	"SQLlag;",	"return the value in the previous row in the partition or NULL if non existent"	]
[ "sql",	"last_value",	"pattern sql.last_value(b:any_1, s:lng, e:lng):any_1 ",	"SQLlast_value;",	"return the last value of groups"	]
[ "sql",	"lead",	"pattern sql.lead(b:any_1, l:any_2, d:any_1, p:any_3, o:any_4):any_1 ",	"SQLlead;",	"return the value in the next 'l' row in the partition or 'd' if non existent"	]
[ "sql",	"lead",	"pattern sql.lead(b:any_1, l:any_2, p:any_3, o:any_4):any_1 ",	"SQLlead;",	"return the value in the next 'l' row in the partition or NULL if non existent"	]
[ "sql",	"lead",	"pattern sql.lead(b:any_1, p:any_3, o:any_4):any_1 ",	"SQLlead;",	"return the value in the next row in the partition or NULL if non existent"	]
[ "sql",	"logfile",	"unsafe pattern sql.logfile(filename:str):void ",	"mvc_logfile;",	"Enable/disable saving the sql statement traces"	]
[ "sql",	"max",	"pattern sql.max(b:any_1, s:lng, e:lng):any_1 ",	"SQLmax;",	"return the maximum of groups"	]
[ "sql",	"min",	"pattern sql.min(b:any_1, s:lng, e:lng):any_1 ",	"SQLmin;",	"return the minimum of groups"	]
[ "sql",	"ms_trunc",	"command sql.ms_trunc(v:dbl, r:int):dbl ",	"dbl_trunc_wrap;",	"truncate the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"ms_trunc",	"command sql.ms_trunc(v:flt, r:int):flt ",	"flt_trunc_wrap;",	"truncate the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"mvc",	"pattern sql.mvc():int ",	"SQLmvc;",	"Get the multiversion catalog context. \nNeeded for correct statement dependencies\n(ie sql.update, should be after sql.bind in concurrent execution)"	]
[ "sql",	"next_value",	"unsafe pattern sql.next_value(sname:str, sequence:str):lng ",	"mvc_next_value;",	"return the next value of the sequence"	]
[ "sql",	"not_unique",	"command sql.not_unique(b:bat[:oid]):bit ",	"not_unique;",	"check if the tail sorted bat b doesn't have unique tail values"	]
[ "sql",	"nth_value",	"pattern sql.nth_value(b:any_1, n:any_2, s:lng, e:lng):any_1 ",	"SQLnth_value;",	"return the nth value of each group"	]
[ "sql",	"ntile",	"pattern sql.ntile(b:any_1, n:any_2, p:any_3, o:any_4):any_2 ",	"SQLntile;",	"return the groups divided as equally as possible"	]
[ "sql",	"null",	"command sql.null(b:bat[:any_1]):bit ",	"SQLnil;",	"if b has a nil return true, else false"	]
[ "sql",	"optimizer_updates",	"pattern sql.optimizer_updates():void ",	"SQLoptimizersUpdate;",	""	]
[ "sql",	"optimizers",	"command sql.optimizers() (X_0:bat[:str], X_1:bat[:str], X_2:bat[:str]) ",	"getPipeCatalog;",	""	]
[ "sql",	"password",	"pattern sql.password(user:str):str ",	"db_password_wrap;",	"Return password hash of user"	]
[ "sql",	"percent_rank",	"pattern sql.percent_rank(b:any_1, p:bit, o:bit):dbl ",	"SQLpercent_rank;",	"return the percentage into the total number of groups for each row"	]
[ "sql",	"prelude",	"pattern sql.prelude():void ",	"SQLprelude;",	""	]
[ "sql",	"prepared_statements",	"pattern sql.prepared_statements() (sessionid:bat[:int], user:bat[:str], statementid:bat[:int], statement:bat[:str], created:bat[:timestamp]) ",	"SQLsession_prepared_statements;",	"Available prepared statements in the current session"	]
[ "sql",	"prepared_statements_args",	"pattern sql.prepared_statements_args() (statementid:bat[:int], type:bat[:str], digits:bat[:int], scale:bat[:int], inout:bat[:bte], number:bat[:int], schema:bat[:str], table:bat[:str], column:bat[:str]) ",	"SQLsession_prepared_statements_args;",	"Available prepared statements' arguments in the current session"	]
[ "sql",	"prod",	"pattern sql.prod(b:bte, s:lng, e:lng):hge ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:bte, s:lng, e:lng):lng ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:dbl, s:lng, e:lng):dbl ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:flt, s:lng, e:lng):dbl ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:flt, s:lng, e:lng):flt ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:hge, s:lng, e:lng):hge ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:int, s:lng, e:lng):hge ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:int, s:lng, e:lng):lng ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:lng, s:lng, e:lng):hge ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:lng, s:lng, e:lng):lng ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:sht, s:lng, e:lng):hge ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"prod",	"pattern sql.prod(b:sht, s:lng, e:lng):lng ",	"SQLprod;",	"return the product of groups"	]
[ "sql",	"project",	"command sql.project(col:bat[:oid], l:bat[:oid], r:bat[:oid]):bat[:oid] ",	"BATleftproject;",	"Last step of a left outer join, ie project the inner join (l,r) over the left input side (col)"	]
[ "sql",	"projectdelta",	"command sql.projectdelta(select:bat[:oid], col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3]):bat[:any_3] ",	"DELTAproject2;",	"Return column bat with delta's applied."	]
[ "sql",	"projectdelta",	"command sql.projectdelta(select:bat[:oid], col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3], ins:bat[:any_3]):bat[:any_3] ",	"DELTAproject;",	"Return column bat with delta's applied."	]
[ "sql",	"querylog_calls",	"pattern sql.querylog_calls() (id:bat[:oid], start:bat[:timestamp], stop:bat[:timestamp], arguments:bat[:str], tuples:bat[:lng], exec:bat[:lng], result:bat[:lng], cpuload:bat[:int], iowait:bat[:int]) ",	"sql_querylog_calls;",	"Obtain the query log calls"	]
[ "sql",	"querylog_catalog",	"pattern sql.querylog_catalog() (id:bat[:oid], user:bat[:str], defined:bat[:timestamp], query:bat[:str], pipe:bat[:str], plan:bat[:str], mal:bat[:int], optimize:bat[:lng]) ",	"sql_querylog_catalog;",	"Obtain the query log catalog"	]
[ "sql",	"querylog_disable",	"unsafe command sql.querylog_disable():void ",	"QLOGdisable;",	""	]
[ "sql",	"querylog_empty",	"unsafe pattern sql.querylog_empty():void ",	"sql_querylog_empty;",	""	]
[ "sql",	"querylog_enable",	"unsafe command sql.querylog_enable():void ",	"QLOGenable;",	""	]
[ "sql",	"querylog_enable",	"unsafe command sql.querylog_enable(thres:int):void ",	"QLOGenableThreshold;",	""	]
[ "sql",	"rank",	"pattern sql.rank(b:any_1, p:bit, o:bit):int ",	"SQLrank;",	"return the ranked groups"	]
[ "sql",	"register",	"pattern sql.register(mod:str, fname:str, rel_stmt:str, sig:str):int ",	"RAstatement2;",	""	]
[ "sql",	"register",	"pattern sql.register(mod:str, fname:str, rel_stmt:str, sig:str, typ:str):int ",	"RAstatement2;",	"Compile the relational statement (rel_smt) and register it as mal function, mod.fname(signature)"	]
[ "sql",	"restart",	"unsafe pattern sql.restart(sname:str, sequence:str, start:lng):lng ",	"mvc_restart_seq;",	"restart the sequence with value start"	]
[ "sql",	"resultSet",	"unsafe pattern sql.resultSet(tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int], scale:bat[:int], cols:any...):int ",	"mvc_row_result_wrap;",	"Prepare a table result set for the client front-end"	]
[ "sql",	"resultSet",	"unsafe pattern sql.resultSet(tbl:str, attr:str, tpe:str, len:int, scale:int, eclass:int, val:any):int ",	"mvc_scalar_value_wrap;",	"Prepare a table result set for the client front-end."	]
[ "sql",	"resultSet",	"unsafe pattern sql.resultSet(tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int], scale:bat[:int], cols:bat[:any]...):int ",	"mvc_table_result_wrap;",	"Prepare a table result set for the client in default CSV format"	]
[ "sql",	"resume_log_flushing",	"unsafe command sql.resume_log_flushing():void ",	"SQLresume_log_flushing;",	"Resume WAL log flushing"	]
[ "sql",	"reuse",	"unsafe pattern sql.reuse(sch:str, tbl:str):void ",	"SQLreuse;",	"Consolidate the deletion table over all columns reusing deleted slots"	]
[ "sql",	"round",	"command sql.round(v:bte, d:int, s:int, r:bte):bte ",	"bte_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:dbl, r:bte):dbl ",	"dbl_round_wrap;",	"round off the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:flt, r:bte):flt ",	"flt_round_wrap;",	"round off the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:hge, d:int, s:int, r:bte):hge ",	"hge_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:int, d:int, s:int, r:bte):int ",	"int_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:lng, d:int, s:int, r:bte):lng ",	"lng_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:sht, d:int, s:int, r:bte):sht ",	"sht_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"row_number",	"pattern sql.row_number(b:any_1, p:bit, o:bit):int ",	"SQLrow_number;",	"return the row_numer-ed groups"	]
[ "sql",	"rt_credentials",	"pattern sql.rt_credentials(tablename:str) (uri:bat[:str], username:bat[:str], hash:bat[:str]) ",	"sql_rt_credentials_wrap;",	"Return the remote table credentials for the given table"	]
[ "sql",	"sessions",	"pattern sql.sessions() (id:bat[:int], user:bat[:str], start:bat[:timestamp], idle:bat[:timestamp], optmizer:bat[:str], stimeout:bat[:int], qtimeout:bat[:int], wlimit:bat[:int], mlimit:bat[:int]) ",	"sql_sessions_wrap;",	"SQL export table of active sessions, their timeouts and idle status"	]
[ "sql",	"setVariable",	"unsafe pattern sql.setVariable(mvc:int, varname:str, value:any_1):int ",	"setVariable;",	"Set the value of a session variable"	]
[ "sql",	"shrink",	"unsafe pattern sql.shrink(sch:str, tbl:str):void ",	"SQLshrink;",	"Consolidate the deletion table over all columns using shrinking"	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:bte):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:bte, force:bit):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:int):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:int, force:bit):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:sht):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:sht, force:bit):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"single",	"pattern sql.single(x:any_2):bat[:any_2] ",	"CMDBATsingle;",	""	]
[ "sql",	"sql_environment",	"inline function sql.sql_environment() (name:bat[:str], value:bat[:str]);",	"",	""	]
[ "sql",	"sql_variables",	"pattern sql.sql_variables():bat[:str] ",	"sql_variables;",	"return the table with session variables"	]
[ "sql",	"stdev",	"pattern sql.stdev(b:bte, s:lng, e:lng):dbl ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "sql",	"stdev",	"pattern sql.stdev(b:dbl, s:lng, e:lng):dbl ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "sql",	"stdev",	"pattern sql.stdev(b:flt, s:lng, e:lng):dbl ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "sql",	"stdev",	"pattern sql.stdev(b:hge, s:lng, e:lng):dbl ",	"SQLstddev_samp;",	"return the standard deviation of groups"	]
[ "sql",	"stdev",	"pattern sql.stdev(b:int, s:lng, e:lng):dbl ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "sql",	"stdev",	"pattern sql.stdev(b:lng, s:lng, e:lng):dbl ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "sql",	"stdev",	"pattern sql.stdev(b:sht, s:lng, e:lng):dbl ",	"SQLstddev_samp;",	"return the standard deviation sample of groups"	]
[ "sql",	"stdevp",	"pattern sql.stdevp(b:bte, s:lng, e:lng):dbl ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "sql",	"stdevp",	"pattern sql.stdevp(b:dbl, s:lng, e:lng):dbl ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "sql",	"stdevp",	"pattern sql.stdevp(b:flt, s:lng, e:lng):dbl ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "sql",	"stdevp",	"pattern sql.stdevp(b:hge, s:lng, e:lng):dbl ",	"SQLstddev_pop;",	"return the standard deviation of groups"	]
[ "sql",	"stdevp",	"pattern sql.stdevp(b:int, s:lng, e:lng):dbl ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "sql",	"stdevp",	"pattern sql.stdevp(b:lng, s:lng, e:lng):dbl ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "sql",	"stdevp",	"pattern sql.stdevp(b:sht, s:lng, e:lng):dbl ",	"SQLstddev_pop;",	"return the standard deviation population of groups"	]
[ "sql",	"storage",	"pattern sql.storage() (schema:bat[:str], table:bat[:str], column:bat[:str], type:bat[:str], mode:bat[:str], location:bat[:str], count:bat[:lng], atomwidth:bat[:int], columnsize:bat[:lng], heap:bat[:lng], hashes:bat[:lng], phash:bat[:bit], imprints:bat[:lng], sorted:bat[:bit], revsorted:bat[:bit], key:bat[:bit], orderidx:bat[:lng]) ",	"sql_storage;",	"return a table with storage information "	]
[ "sql",	"storage",	"pattern sql.storage(sname:str) (schema:bat[:str], table:bat[:str], column:bat[:str], type:bat[:str], mode:bat[:str], location:bat[:str], count:bat[:lng], atomwidth:bat[:int], columnsize:bat[:lng], heap:bat[:lng], hashes:bat[:lng], phash:bat[:bit], imprints:bat[:lng], sorted:bat[:bit], revsorted:bat[:bit], key:bat[:bit], orderidx:bat[:lng]) ",	"sql_storage;",	"return a table with storage information for a particular schema "	]
[ "sql",	"storage",	"pattern sql.storage(sname:str, tname:str) (schema:bat[:str], table:bat[:str], column:bat[:str], type:bat[:str], mode:bat[:str], location:bat[:str], count:bat[:lng], atomwidth:bat[:int], columnsize:bat[:lng], heap:bat[:lng], hashes:bat[:lng], phash:bat[:bit], imprints:bat[:lng], sorted:bat[:bit], revsorted:bat[:bit], key:bat[:bit], orderidx:bat[:lng]) ",	"sql_storage;",	"return a table with storage information for a particular table"	]
[ "sql",	"storage",	"pattern sql.storage(sname:str, tname:str, cname:str) (schema:bat[:str], table:bat[:str], column:bat[:str], type:bat[:str], mode:bat[:str], location:bat[:str], count:bat[:lng], atomwidth:bat[:int], columnsize:bat[:lng], heap:bat[:lng], hashes:bat[:lng], phash:bat[:bit], imprints:bat[:lng], sorted:bat[:bit], revsorted:bat[:bit], key:bat[:bit], orderidx:bat[:lng]) ",	"sql_storage;",	"return a table with storage information for a particular column"	]
[ "sql",	"str_group_concat",	"pattern sql.str_group_concat(b:str, s:lng, e:lng):str ",	"SQLstrgroup_concat;",	"return the string concatenation of groups"	]
[ "sql",	"str_group_concat",	"pattern sql.str_group_concat(b:str, sep:str, s:lng, e:lng):str ",	"SQLstrgroup_concat;",	"return the string concatenation of groups with a custom separator"	]
[ "sql",	"suball",	"command sql.suball(l:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit):bat[:any_1] ",	"SQLall_grp;",	"if all values in l are equal (per group) return the value, else nil"	]
[ "sql",	"subdelta",	"command sql.subdelta(col:bat[:oid], cand:bat[:oid], uid:bat[:oid], uval:bat[:oid]):bat[:oid] ",	"DELTAsub2;",	"Return a single bat of selected delta."	]
[ "sql",	"subdelta",	"command sql.subdelta(col:bat[:oid], cand:bat[:oid], uid:bat[:oid], uval:bat[:oid], ins:bat[:oid]):bat[:oid] ",	"DELTAsub;",	"Return a single bat of selected delta."	]
[ "sql",	"subnull",	"command sql.subnull(l:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit):bat[:bit] ",	"SQLnil_grp;",	"if any value in l is nil with in a group return true for that group, else false"	]
[ "sql",	"subzero_or_one",	"command sql.subzero_or_one(b:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit):bat[:any_1] ",	"SQLsubzero_or_one;",	""	]
[ "sql",	"sum",	"pattern sql.sum(b:bte, s:lng, e:lng):hge ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:bte, s:lng, e:lng):lng ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:dbl, s:lng, e:lng):dbl ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:flt, s:lng, e:lng):dbl ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:flt, s:lng, e:lng):flt ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:hge, s:lng, e:lng):hge ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:int, s:lng, e:lng):hge ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:int, s:lng, e:lng):lng ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:lng, s:lng, e:lng):hge ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:lng, s:lng, e:lng):lng ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:sht, s:lng, e:lng):hge ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"sum",	"pattern sql.sum(b:sht, s:lng, e:lng):lng ",	"SQLsum;",	"return the sum of groups"	]
[ "sql",	"suspend_log_flushing",	"unsafe command sql.suspend_log_flushing():void ",	"SQLsuspend_log_flushing;",	"Suspend WAL log flushing"	]
[ "sql",	"sysmon_pause",	"unsafe pattern sql.sysmon_pause(tag:bte):void ",	"SYSMONpause;",	""	]
[ "sql",	"sysmon_pause",	"unsafe pattern sql.sysmon_pause(tag:int):void ",	"SYSMONpause;",	""	]
[ "sql",	"sysmon_pause",	"unsafe pattern sql.sysmon_pause(tag:lng):void ",	"SYSMONpause;",	""	]
[ "sql",	"sysmon_pause",	"unsafe pattern sql.sysmon_pause(tag:sht):void ",	"SYSMONpause;",	""	]
[ "sql",	"sysmon_queue",	"pattern sql.sysmon_queue() (tag:bat[:lng], sessionid:bat[:int], user:bat[:str], started:bat[:timestamp], status:bat[:str], query:bat[:str], progress:bat[:int], workers:bat[:int], memory:bat[:int]) ",	"SYSMONqueue;",	""	]
[ "sql",	"sysmon_resume",	"unsafe pattern sql.sysmon_resume(tag:bte):void ",	"SYSMONresume;",	""	]
[ "sql",	"sysmon_resume",	"unsafe pattern sql.sysmon_resume(tag:int):void ",	"SYSMONresume;",	""	]
[ "sql",	"sysmon_resume",	"unsafe pattern sql.sysmon_resume(tag:lng):void ",	"SYSMONresume;",	""	]
[ "sql",	"sysmon_resume",	"unsafe pattern sql.sysmon_resume(tag:sht):void ",	"SYSMONresume;",	""	]
[ "sql",	"sysmon_stop",	"unsafe pattern sql.sysmon_stop(tag:bte):void ",	"SYSMONstop;",	""	]
[ "sql",	"sysmon_stop",	"unsafe pattern sql.sysmon_stop(tag:int):void ",	"SYSMONstop;",	""	]
[ "sql",	"sysmon_stop",	"unsafe pattern sql.sysmon_stop(tag:lng):void ",	"SYSMONstop;",	""	]
[ "sql",	"sysmon_stop",	"unsafe pattern sql.sysmon_stop(tag:sht):void ",	"SYSMONstop;",	""	]
[ "sql",	"tid",	"pattern sql.tid(mvc:int, sname:str, tname:str):bat[:oid] ",	"SQLtid;",	"Return a column with the valid tuple identifiers associated with the table sname.tname."	]
[ "sql",	"tid",	"pattern sql.tid(mvc:int, sname:str, tname:str, part_nr:int, nr_parts:int):bat[:oid] ",	"SQLtid;",	"Return the tables tid column."	]
[ "sql",	"transaction",	"unsafe pattern sql.transaction():void ",	"SQLtransaction2;",	"Start an autocommit transaction"	]
[ "sql",	"transaction",	"unsafe pattern sql.transaction():void ",	"SQLtransaction2;",	"Start an autocommit transaction"	]
[ "sql",	"transaction_begin",	"unsafe pattern sql.transaction_begin(chain:int, name:str):void ",	"SQLtransaction_begin;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "sql",	"transaction_commit",	"unsafe pattern sql.transaction_commit(chain:int, name:str):void ",	"SQLtransaction_commit;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "sql",	"transaction_release",	"unsafe pattern sql.transaction_release(chain:int, name:str):void ",	"SQLtransaction_release;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "sql",	"transaction_rollback",	"unsafe pattern sql.transaction_rollback(chain:int, name:str):void ",	"SQLtransaction_rollback;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "sql",	"unionfunc",	"pattern sql.unionfunc(mod:str, fcn:str, X_0:any...):any... ",	"SQLunionfunc;",	""	]
[ "sql",	"update",	"pattern sql.update(mvc:int, sname:str, tname:str, cname:str, rids:any, upd:any):int ",	"mvc_update_wrap;",	"Update the values of the column tname.cname. Returns sequence number for order dependence)"	]
[ "sql",	"update_schemas",	"unsafe pattern sql.update_schemas():void ",	"SYSupdate_schemas;",	"Procedure triggered on update of the sys.schemas table"	]
[ "sql",	"update_tables",	"unsafe pattern sql.update_tables():void ",	"SYSupdate_tables;",	"Procedure triggered on update of the sys._tables table"	]
[ "sql",	"vacuum",	"unsafe pattern sql.vacuum(sch:str, tbl:str):void ",	"SQLvacuum;",	"Choose an approach to consolidate the deletions"	]
[ "sql",	"variance",	"pattern sql.variance(b:bte, s:lng, e:lng):dbl ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "sql",	"variance",	"pattern sql.variance(b:dbl, s:lng, e:lng):dbl ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "sql",	"variance",	"pattern sql.variance(b:flt, s:lng, e:lng):dbl ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "sql",	"variance",	"pattern sql.variance(b:hge, s:lng, e:lng):dbl ",	"SQLvar_samp;",	"return the variance of groups"	]
[ "sql",	"variance",	"pattern sql.variance(b:int, s:lng, e:lng):dbl ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "sql",	"variance",	"pattern sql.variance(b:lng, s:lng, e:lng):dbl ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "sql",	"variance",	"pattern sql.variance(b:sht, s:lng, e:lng):dbl ",	"SQLvar_samp;",	"return the variance sample of groups"	]
[ "sql",	"variancep",	"pattern sql.variancep(b:bte, s:lng, e:lng):dbl ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "sql",	"variancep",	"pattern sql.variancep(b:dbl, s:lng, e:lng):dbl ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "sql",	"variancep",	"pattern sql.variancep(b:flt, s:lng, e:lng):dbl ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "sql",	"variancep",	"pattern sql.variancep(b:hge, s:lng, e:lng):dbl ",	"SQLvar_pop;",	"return the variance of groups"	]
[ "sql",	"variancep",	"pattern sql.variancep(b:int, s:lng, e:lng):dbl ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "sql",	"variancep",	"pattern sql.variancep(b:lng, s:lng, e:lng):dbl ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "sql",	"variancep",	"pattern sql.variancep(b:sht, s:lng, e:lng):dbl ",	"SQLvar_pop;",	"return the variance population of groups"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(b:any_1, unit:int, bound:int, excl:int, limit:bte):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(b:any_1, unit:int, bound:int, excl:int, limit:dbl):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(b:any_1, unit:int, bound:int, excl:int, limit:flt):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(b:any_1, unit:int, bound:int, excl:int, limit:int):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(b:any_1, unit:int, bound:int, excl:int, limit:lng):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(b:any_1, unit:int, bound:int, excl:int, limit:sht):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(b:any_1, unit:int, bound:int, excl:int, start:hge):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(p:bit, b:any_1, unit:int, bound:int, excl:int, limit:bte):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(p:bit, b:any_1, unit:int, bound:int, excl:int, limit:dbl):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(p:bit, b:any_1, unit:int, bound:int, excl:int, limit:flt):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(p:bit, b:any_1, unit:int, bound:int, excl:int, limit:int):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(p:bit, b:any_1, unit:int, bound:int, excl:int, limit:lng):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(p:bit, b:any_1, unit:int, bound:int, excl:int, limit:sht):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"window_bound",	"pattern sql.window_bound(p:bit, b:any_1, unit:int, bound:int, excl:int, start:hge):lng ",	"SQLwindow_bound;",	"computes window ranges for each row"	]
[ "sql",	"zero_or_one",	"command sql.zero_or_one(col:bat[:any_1]):any_1 ",	"zero_or_one;",	"if col contains exactly one value return this. Incase of more raise an exception else return nil"	]
[ "sql",	"zero_or_one",	"command sql.zero_or_one(col:bat[:any_1], err:bit):any_1 ",	"zero_or_one_error;",	"if col contains exactly one value return this. Incase of more raise an exception if err is true else return nil"	]
[ "sql",	"zero_or_one",	"command sql.zero_or_one(col:bat[:any_1], err:bat[:bit]):any_1 ",	"zero_or_one_error_bat;",	"if col contains exactly one value return this. Incase of more raise an exception if err is true else return nil"	]
[ "sqlcatalog",	"alter_add_range_partition",	"pattern sqlcatalog.alter_add_range_partition(sname:str, mtnme:str, psnme:str, ptnme:str, min:any_1, max:any_1, nills:bit, update:int):void ",	"SQLalter_add_range_partition;",	"Catalog operation alter_add_range_partition"	]
[ "sqlcatalog",	"alter_add_table",	"pattern sqlcatalog.alter_add_table(sname:str, mtnme:str, psnme:str, ptnme:str, action:int):void ",	"SQLalter_add_table;",	"Catalog operation alter_add_table"	]
[ "sqlcatalog",	"alter_add_value_partition",	"pattern sqlcatalog.alter_add_value_partition(sname:str, mtnme:str, psnme:str, ptnme:str, nills:bit, update:int):void ",	"SQLalter_add_value_partition;",	"Catalog operation alter_add_value_partition"	]
[ "sqlcatalog",	"alter_add_value_partition",	"pattern sqlcatalog.alter_add_value_partition(sname:str, mtnme:str, psnme:str, ptnme:str, nills:bit, update:int, arg:any...):void ",	"SQLalter_add_value_partition;",	"Catalog operation alter_add_value_partition"	]
[ "sqlcatalog",	"alter_del_table",	"pattern sqlcatalog.alter_del_table(sname:str, mtnme:str, psnme:str, ptnme:str, action:int):void ",	"SQLalter_del_table;",	"Catalog operation alter_del_table"	]
[ "sqlcatalog",	"alter_seq",	"pattern sqlcatalog.alter_seq(sname:str, seqname:str, seq:ptr, val:bat[:lng]):void ",	"SQLalter_seq;",	"Catalog operation alter_seq"	]
[ "sqlcatalog",	"alter_seq",	"pattern sqlcatalog.alter_seq(sname:str, seqname:str, seq:ptr, val:lng):void ",	"SQLalter_seq;",	"Catalog operation alter_seq"	]
[ "sqlcatalog",	"alter_set_table",	"pattern sqlcatalog.alter_set_table(sname:str, tnme:str, access:int):void ",	"SQLalter_set_table;",	"Catalog operation alter_set_table"	]
[ "sqlcatalog",	"alter_table",	"pattern sqlcatalog.alter_table(sname:str, tname:str, tbl:ptr, action:int):void ",	"SQLalter_table;",	"Catalog operation alter_table"	]
[ "sqlcatalog",	"alter_user",	"pattern sqlcatalog.alter_user(sname:str, passwrd:str, enc:int, schema:str, oldpasswrd:str):void ",	"SQLalter_user;",	"Catalog operation alter_user"	]
[ "sqlcatalog",	"comment_on",	"pattern sqlcatalog.comment_on(objid:int, remark:str):void ",	"SQLcomment_on;",	"Catalog operation comment_on"	]
[ "sqlcatalog",	"create_function",	"pattern sqlcatalog.create_function(sname:str, fname:str, fcn:ptr):void ",	"SQLcreate_function;",	"Catalog operation create_function"	]
[ "sqlcatalog",	"create_role",	"pattern sqlcatalog.create_role(sname:str, role:str, grator:int):void ",	"SQLcreate_role;",	"Catalog operation create_role"	]
[ "sqlcatalog",	"create_schema",	"pattern sqlcatalog.create_schema(sname:str, auth:str, ifnotexists:int, action:int):void ",	"SQLcreate_schema;",	"Catalog operation create_schema"	]
[ "sqlcatalog",	"create_seq",	"pattern sqlcatalog.create_seq(sname:str, seqname:str, seq:ptr, action:int):void ",	"SQLcreate_seq;",	"Catalog operation create_seq"	]
[ "sqlcatalog",	"create_table",	"pattern sqlcatalog.create_table(sname:str, tname:str, tbl:ptr, temp:int):void ",	"SQLcreate_table;",	"Catalog operation create_table"	]
[ "sqlcatalog",	"create_trigger",	"pattern sqlcatalog.create_trigger(sname:str, tname:str, triggername:str, time:int, orientation:int, event:int, old:str, new:str, cond:str, qry:str):void ",	"SQLcreate_trigger;",	"Catalog operation create_trigger"	]
[ "sqlcatalog",	"create_type",	"pattern sqlcatalog.create_type(sname:str, nme:str, impl:str):void ",	"SQLcreate_type;",	"Catalog operation create_type"	]
[ "sqlcatalog",	"create_user",	"pattern sqlcatalog.create_user(sname:str, passwrd:str, enc:int, schema:str, fullname:str):void ",	"SQLcreate_user;",	"Catalog operation create_user"	]
[ "sqlcatalog",	"create_view",	"pattern sqlcatalog.create_view(sname:str, vname:str, tbl:ptr, temp:int):void ",	"SQLcreate_view;",	"Catalog operation create_view"	]
[ "sqlcatalog",	"drop_constraint",	"pattern sqlcatalog.drop_constraint(sname:str, name:str, action:int, ifexists:int):void ",	"SQLdrop_constraint;",	"Catalog operation drop_constraint"	]
[ "sqlcatalog",	"drop_function",	"pattern sqlcatalog.drop_function(sname:str, fname:str, fid:int, type:int, action:int):void ",	"SQLdrop_function;",	"Catalog operation drop_function"	]
[ "sqlcatalog",	"drop_index",	"pattern sqlcatalog.drop_index(sname:str, iname:str, action:int):void ",	"SQLdrop_index;",	"Catalog operation drop_index"	]
[ "sqlcatalog",	"drop_role",	"pattern sqlcatalog.drop_role(auth:str, role:str, action:int):void ",	"SQLdrop_role;",	"Catalog operation drop_role"	]
[ "sqlcatalog",	"drop_role",	"pattern sqlcatalog.drop_role(role:str, action:int):void ",	"SQLdrop_role;",	"Catalog operation drop_role"	]
[ "sqlcatalog",	"drop_schema",	"pattern sqlcatalog.drop_schema(sname:str, s:str, ifexists:int, action:int):void ",	"SQLdrop_schema;",	"Catalog operation drop_schema"	]
[ "sqlcatalog",	"drop_seq",	"pattern sqlcatalog.drop_seq(sname:str, nme:str, action:int):void ",	"SQLdrop_seq;",	"Catalog operation drop_seq"	]
[ "sqlcatalog",	"drop_table",	"pattern sqlcatalog.drop_table(sname:str, name:str, action:int, ifexists:int):void ",	"SQLdrop_table;",	"Catalog operation drop_table"	]
[ "sqlcatalog",	"drop_trigger",	"pattern sqlcatalog.drop_trigger(sname:str, nme:str, ifexists:int):void ",	"SQLdrop_trigger;",	"Catalog operation drop_trigger"	]
[ "sqlcatalog",	"drop_type",	"pattern sqlcatalog.drop_type(sname:str, nme:str, action:int):void ",	"SQLdrop_type;",	"Catalog operation drop_type"	]
[ "sqlcatalog",	"drop_user",	"pattern sqlcatalog.drop_user(sname:str, action:int):void ",	"SQLdrop_user;",	"Catalog operation drop_user"	]
[ "sqlcatalog",	"drop_user",	"pattern sqlcatalog.drop_user(sname:str, auth:str, action:int):void ",	"SQLdrop_user;",	"Catalog operation drop_user"	]
[ "sqlcatalog",	"drop_view",	"pattern sqlcatalog.drop_view(sname:str, name:str, action:int, ifexists:int):void ",	"SQLdrop_view;",	"Catalog operation drop_view"	]
[ "sqlcatalog",	"grant",	"pattern sqlcatalog.grant(sname:str, tbl:str, grantee:str, privs:int, cname:str, gr:int, grantor:int):void ",	"SQLgrant;",	"Catalog operation grant"	]
[ "sqlcatalog",	"grant_function",	"pattern sqlcatalog.grant_function(sname:str, fcnid:int, grantee:str, privs:int, grant:int, grantor:int):void ",	"SQLgrant_function;",	"Catalog operation grant_function"	]
[ "sqlcatalog",	"grant_roles",	"pattern sqlcatalog.grant_roles(sname:str, auth:str, grantor:int, admin:int):void ",	"SQLgrant_roles;",	"Catalog operation grant_roles"	]
[ "sqlcatalog",	"rename_column",	"pattern sqlcatalog.rename_column(sname:str, tname:str, cname:str, newnme:str):void ",	"SQLrename_column;",	"Catalog operation rename_column"	]
[ "sqlcatalog",	"rename_schema",	"pattern sqlcatalog.rename_schema(sname:str, newnme:str):void ",	"SQLrename_schema;",	"Catalog operation rename_schema"	]
[ "sqlcatalog",	"rename_table",	"pattern sqlcatalog.rename_table(osname:str, nsname:str, otname:str, ntname:str):void ",	"SQLrename_table;",	"Catalog operation rename_table"	]
[ "sqlcatalog",	"rename_user",	"pattern sqlcatalog.rename_user(sname:str, newnme:str, action:int):void ",	"SQLrename_user;",	"Catalog operation rename_user"	]
[ "sqlcatalog",	"revoke",	"pattern sqlcatalog.revoke(sname:str, tbl:str, grantee:str, privs:int, cname:str, grant:int, grantor:int):void ",	"SQLrevoke;",	"Catalog operation revoke"	]
[ "sqlcatalog",	"revoke_function",	"pattern sqlcatalog.revoke_function(sname:str, fcnid:int, grantee:str, privs:int, grant:int, grantor:int):void ",	"SQLrevoke_function;",	"Catalog operation revoke_function"	]
[ "sqlcatalog",	"revoke_roles",	"pattern sqlcatalog.revoke_roles(sname:str, auth:str, grantor:int, admin:int):void ",	"SQLrevoke_roles;",	"Catalog operation revoke_roles"	]
[ "status",	"batStatistics",	"command status.batStatistics() (X_0:bat[:str], X_1:bat[:str]) ",	"SYSgdkEnv;",	"Show distribution of bats by kind"	]
[ "status",	"cpuStatistics",	"command status.cpuStatistics() (X_0:bat[:str], X_1:bat[:lng]) ",	"SYScpuStatistics;",	"Global cpu usage information"	]
[ "status",	"getThreads",	"command status.getThreads() (X_0:bat[:int], X_1:bat[:str]) ",	"SYSgdkThread;",	"Produce overview of active threads"	]
[ "status",	"ioStatistics",	"command status.ioStatistics() (X_0:bat[:str], X_1:bat[:lng]) ",	"SYSioStatistics;",	"Global IO activity information"	]
[ "status",	"memStatistics",	"command status.memStatistics() (X_0:bat[:str], X_1:bat[:lng]) ",	"SYSmemStatistics;",	"Global memory usage information"	]
[ "status",	"memUsage",	"command status.memUsage(minsize:lng) (X_0:bat[:str], X_1:bat[:lng]) ",	"SYSmem_usage;",	"Get a split-up of how much memory blocks are in use"	]
[ "status",	"mem_cursize",	"command status.mem_cursize():lng ",	"SYSgetmem_cursize;",	"The amount of physical swapspace in KB that is currently in use"	]
[ "status",	"mem_maxsize",	"command status.mem_maxsize():lng ",	"SYSgetmem_maxsize;",	"The maximum usable amount of physical swapspace in KB (target only)"	]
[ "status",	"mem_maxsize",	"command status.mem_maxsize(v:lng):void ",	"SYSsetmem_maxsize;",	"Set the maximum usable amount of physical swapspace in KB"	]
[ "status",	"vmStatistics",	"command status.vmStatistics(minsize:lng) (X_0:bat[:str], X_1:bat[:lng]) ",	"SYSvm_usage;",	"Get a split-up of how much virtual memory blocks are in use"	]
[ "status",	"vm_cursize",	"command status.vm_cursize():lng ",	"SYSgetvm_cursize;",	"The amount of logical VM space in KB that is currently in use"	]
[ "status",	"vm_maxsize",	"command status.vm_maxsize():lng ",	"SYSgetvm_maxsize;",	"The maximum usable amount of logical VM space in KB (target only)"	]
[ "status",	"vm_maxsize",	"command status.vm_maxsize(v:lng):void ",	"SYSsetvm_maxsize;",	"Set the maximum usable amount of physical swapspace in KB"	]
[ "str",	"+",	"command str.+(l:str, r:str):str ",	"STRConcat;",	"Concatenate two strings."	]
[ "str",	"STRepilogue",	"command str.STRepilogue():void ",	"strEpilogue;",	""	]
[ "str",	"STRprelude",	"command str.STRprelude():void ",	"strPrelude;",	""	]
[ "str",	"ascii",	"command str.ascii(s:str):int ",	"STRascii;",	"Return unicode of head of string"	]
[ "str",	"endsWith",	"command str.endsWith(s:str, suffix:str):bit ",	"STRSuffix;",	"Suffix check."	]
[ "str",	"insert",	"command str.insert(s:str, start:int, l:int, s2:str):str ",	"STRinsert;",	"Insert a string into another"	]
[ "str",	"length",	"command str.length(s:str):int ",	"STRLength;",	"Return the length of a string."	]
[ "str",	"like",	"command str.like(s:str, pat:str):bit ",	"STRlikewrap2;",	"SQL pattern match function"	]
[ "str",	"like",	"command str.like(s:str, pat:str, esc:str):bit ",	"STRlikewrap;",	"SQL pattern match function"	]
[ "str",	"locate",	"command str.locate(s1:str, s2:str, start:int):int ",	"STRlocate2;",	"Locate the start position of a string"	]
[ "str",	"locate",	"command str.locate(s1:str, s2:str):int ",	"STRlocate;",	"Locate the start position of a string"	]
[ "str",	"lpad",	"command str.lpad(s:str, len:int, s2:str):str ",	"STRLpad2;",	"Fill up the first string to the given length prepending characters of the second string."	]
[ "str",	"lpad",	"command str.lpad(s:str, len:int):str ",	"STRLpad;",	"Fill up a string to the given length prepending the whitespace character."	]
[ "str",	"ltrim",	"command str.ltrim(s:str, s2:str):str ",	"STRLtrim2;",	"Remove the longest string containing only characters from the second string from the start of the first string."	]
[ "str",	"ltrim",	"command str.ltrim(s:str):str ",	"STRLtrim;",	"Strip whitespaces from start of a string."	]
[ "str",	"nbytes",	"command str.nbytes(s:str):int ",	"STRBytes;",	"Return the string length in bytes."	]
[ "str",	"prefix",	"command str.prefix(s:str, l:int):str ",	"STRprefix;",	"Extract the prefix of a given length"	]
[ "str",	"r_search",	"command str.r_search(s:str, c:str):int ",	"STRReverseStrSearch;",	"Reverse search for a substring. Returns\n\t position, -1 if not found."	]
[ "str",	"repeat",	"command str.repeat(s2:str, c:int):str ",	"STRrepeat;",	""	]
[ "str",	"replace",	"command str.replace(origin:str, pat:str, repl:str, flags:str):str ",	"PCREreplace_wrap;",	""	]
[ "str",	"replace",	"command str.replace(s:str, pat:str, s2:str):str ",	"STRreplace;",	"Insert a string into another"	]
[ "str",	"rpad",	"command str.rpad(s:str, len:int, s2:str):str ",	"STRRpad2;",	"Fill up the first string to the given length appending characters of the second string."	]
[ "str",	"rpad",	"command str.rpad(s:str, len:int):str ",	"STRRpad;",	"Fill up a string to the given length appending the whitespace character."	]
[ "str",	"rtrim",	"command str.rtrim(s:str, s2:str):str ",	"STRRtrim2;",	"Remove the longest string containing only characters from the second string from the end of the first string."	]
[ "str",	"rtrim",	"command str.rtrim(s:str):str ",	"STRRtrim;",	"Strip whitespaces from end of a string."	]
[ "str",	"search",	"command str.search(s:str, c:str):int ",	"STRstrSearch;",	"Search for a substring. Returns\n\t position, -1 if not found."	]
[ "str",	"space",	"command str.space(l:int):str ",	"STRspace;",	""	]
[ "str",	"splitpart",	"command str.splitpart(s:str, needle:str, field:int):str ",	"STRsplitpart;",	"Split string on delimiter. Returns\n\t given field (counting from one.)"	]
[ "str",	"startsWith",	"command str.startsWith(s:str, prefix:str):bit ",	"STRPrefix;",	"Prefix check."	]
[ "str",	"str",	"command str.str(s:str):str ",	"STRtostr;",	"Noop routine."	]
[ "str",	"string",	"command str.string(s:str, offset:int, count:int):str ",	"STRSubString;",	"Return substring s[offset..offset+count] of a string s[0..n]"	]
[ "str",	"string",	"command str.string(s:str, offset:int):str ",	"STRTail;",	"Return the tail s[offset..n]\n\t of a string s[0..n]."	]
[ "str",	"stringleft",	"command str.stringleft(s:str, l:int):str ",	"STRprefix;",	""	]
[ "str",	"stringright",	"command str.stringright(s:str, l:int):str ",	"STRsuffix;",	""	]
[ "str",	"substitute",	"command str.substitute(s:str, src:str, dst:str, rep:bit):str ",	"STRSubstitute;",	"Substitute first occurrence of 'src' by\n\t'dst'.  Iff repeated = true this is\n\trepeated while 'src' can be found in the\n\tresult string. In order to prevent\n\trecursion and result strings of unlimited\n\tsize, repeating is only done iff src is\n\tnot a substring of dst."	]
[ "str",	"substring",	"command str.substring(s:str, start:int, len:int):str ",	"STRsubstring;",	"Extract a substring from str starting at start, for length len"	]
[ "str",	"substring",	"command str.substring(s:str, start:int):str ",	"STRsubstringTail;",	"Extract the tail of a string"	]
[ "str",	"suffix",	"command str.suffix(s:str, l:int):str ",	"STRsuffix;",	"Extract the suffix of a given length"	]
[ "str",	"toLower",	"command str.toLower(s:str):str ",	"STRLower;",	"Convert a string to lower case."	]
[ "str",	"toUpper",	"command str.toUpper(s:str):str ",	"STRUpper;",	"Convert a string to upper case."	]
[ "str",	"trim",	"command str.trim(s:str, s2:str):str ",	"STRStrip2;",	"Remove the longest string containing only characters from the second string around the first string."	]
[ "str",	"trim",	"command str.trim(s:str):str ",	"STRStrip;",	"Strip whitespaces around a string."	]
[ "str",	"unicode",	"command str.unicode(wchar:int):str ",	"STRFromWChr;",	"convert a unicode to a character."	]
[ "str",	"unicodeAt",	"command str.unicodeAt(s:str, index:int):int ",	"STRWChrAt;",	"get a unicode character\n\t(as an int) from a string position."	]
[ "streams",	"blocked",	"unsafe command streams.blocked(s:streams):streams ",	"open_block_streamwrap;",	"open a block based stream"	]
[ "streams",	"close",	"unsafe command streams.close(s:streams):void ",	"mnstr_close_streamwrap;",	"close and destroy the stream s"	]
[ "streams",	"flush",	"unsafe command streams.flush(s:streams):void ",	"mnstr_flush_streamwrap;",	"flush the stream"	]
[ "streams",	"openRead",	"unsafe command streams.openRead(filename:str):streams ",	"mnstr_open_rastreamwrap;",	"open ascii file stream for reading"	]
[ "streams",	"openReadBytes",	"unsafe command streams.openReadBytes(filename:str):streams ",	"mnstr_open_rstreamwrap;",	"open a file stream for reading"	]
[ "streams",	"openWrite",	"unsafe command streams.openWrite(filename:str):streams ",	"mnstr_open_wastreamwrap;",	"open ascii file stream for writing"	]
[ "streams",	"openWriteBytes",	"unsafe command streams.openWriteBytes(filename:str):streams ",	"mnstr_open_wstreamwrap;",	"open a file stream for writing"	]
[ "streams",	"readInt",	"unsafe command streams.readInt(s:streams):int ",	"mnstr_readIntwrap;",	"read integer data from the stream"	]
[ "streams",	"readStr",	"unsafe command streams.readStr(s:streams):str ",	"mnstr_read_stringwrap;",	"read string data from the stream"	]
[ "streams",	"writeInt",	"unsafe command streams.writeInt(s:streams, data:int):void ",	"mnstr_writeIntwrap;",	"write data on the stream"	]
[ "streams",	"writeStr",	"unsafe command streams.writeStr(s:streams, data:str):void ",	"mnstr_write_stringwrap;",	"write data on the stream"	]
[ "sysmon",	"pause",	"pattern sysmon.pause(id:int):void ",	"SYSMONpause;",	"Suspend a running query"	]
[ "sysmon",	"pause",	"pattern sysmon.pause(id:lng):void ",	"SYSMONpause;",	"Suspend a running query"	]
[ "sysmon",	"pause",	"pattern sysmon.pause(id:sht):void ",	"SYSMONpause;",	"Suspend a running query"	]
[ "sysmon",	"queue",	"pattern sysmon.queue() (tag:bat[:lng], sessionid:bat[:int], user:bat[:str], started:bat[:timestamp], status:bat[:str], query:bat[:str], progress:bat[:int], workers:bat[:int], memory:bat[:int]) ",	"SYSMONqueue;",	""	]
[ "sysmon",	"resume",	"pattern sysmon.resume(id:int):void ",	"SYSMONresume;",	"Resume processing of a query "	]
[ "sysmon",	"resume",	"pattern sysmon.resume(id:lng):void ",	"SYSMONresume;",	"Resume processing of a query "	]
[ "sysmon",	"resume",	"pattern sysmon.resume(id:sht):void ",	"SYSMONresume;",	"Resume processing of a query "	]
[ "sysmon",	"stop",	"pattern sysmon.stop(id:int):void ",	"SYSMONstop;",	"Stop a single query a.s.a.p."	]
[ "sysmon",	"stop",	"pattern sysmon.stop(id:lng):void ",	"SYSMONstop;",	"Stop a single query a.s.a.p."	]
[ "sysmon",	"stop",	"pattern sysmon.stop(id:sht):void ",	"SYSMONstop;",	"Stop a single query a.s.a.p."	]
[ "tokenizer",	"append",	"command tokenizer.append(u:str):oid ",	"TKNZRappend;",	"tokenize a new string and append it to the tokenizer (duplicate elimination is performed)"	]
[ "tokenizer",	"close",	"command tokenizer.close():void ",	"TKNZRclose;",	"close the current tokenizer store"	]
[ "tokenizer",	"depositFile",	"command tokenizer.depositFile(fnme:str):void ",	"TKNZRdepositFile;",	"batch insertion from a file of strings to tokenize, each string is separated by a new line"	]
[ "tokenizer",	"getCardinality",	"command tokenizer.getCardinality():bat[:lng] ",	"TKNZRgetCardinality;",	"debugging function that returns the unique tokens at each level"	]
[ "tokenizer",	"getCount",	"command tokenizer.getCount():bat[:lng] ",	"TKNZRgetCount;",	"debugging function that returns the size of the bats at each level"	]
[ "tokenizer",	"getIndex",	"command tokenizer.getIndex():bat[:oid] ",	"TKNZRgetIndex;",	"administrative function that returns the INDEX bat"	]
[ "tokenizer",	"getLevel",	"command tokenizer.getLevel(i:int):bat[:str] ",	"TKNZRgetLevel;",	"administrative function that returns the bat on level i"	]
[ "tokenizer",	"locate",	"pattern tokenizer.locate(s:str):oid ",	"TKNZRlocate;",	"if the given string is in the store returns its oid, otherwise oid_nil"	]
[ "tokenizer",	"open",	"command tokenizer.open(name:str):void ",	"TKNZRopen;",	"open the named tokenizer store, a new one is created if the specified name does not exist"	]
[ "tokenizer",	"take",	"pattern tokenizer.take(i:oid):str ",	"TKNZRtakeOid;",	"reconstruct and returns the i-th string"	]
[ "txtsim",	"editdistance",	"command txtsim.editdistance(s:str, t:str):int ",	"levenshteinbasic_impl;",	"Alias for Levenshtein(str,str)"	]
[ "txtsim",	"editdistance2",	"command txtsim.editdistance2(s:str, t:str):int ",	"levenshteinbasic2_impl;",	"Calculates Levenshtein distance (edit distance) between two strings. Cost of transposition is 1 instead of 2"	]
[ "txtsim",	"levenshtein",	"command txtsim.levenshtein(s:str, t:str, insdel_cost:int, replace_cost:int, transpose_cost:int):int ",	"levenshtein_impl;",	"Calculates Levenshtein distance (edit distance) between two strings, variable operation costs (ins/del, replacement, transposition)"	]
[ "txtsim",	"levenshtein",	"command txtsim.levenshtein(s:str, t:str):int ",	"levenshteinbasic_impl;",	"Calculates Levenshtein distance (edit distance) between two strings"	]
[ "txtsim",	"qgramnormalize",	"command txtsim.qgramnormalize(input:str):str ",	"CMDqgramnormalize;",	"'Normalizes' strings (eg. toUpper and replaces non-alphanumerics with one space"	]
[ "txtsim",	"qgramselfjoin",	"command txtsim.qgramselfjoin(qgram:bat[:oid], id:bat[:oid], pos:bat[:int], len:bat[:int], c:flt, k:int) (X_0:bat[:int], X_1:bat[:int]) ",	"CMDqgramselfjoin;",	"QGram self-join on ordered(!) qgram tables and sub-ordered q-gram positions"	]
[ "txtsim",	"similarity",	"command txtsim.similarity(string1:str, string2:str):dbl ",	"fstrcmp0_impl;",	"Normalized edit distance between two strings"	]
[ "txtsim",	"similarity",	"command txtsim.similarity(string1:str, string2:str, minimum:dbl):dbl ",	"fstrcmp_impl;",	"Normalized edit distance between two strings"	]
[ "txtsim",	"soundex",	"command txtsim.soundex(name:str):str ",	"soundex_impl;",	"Soundex function for phonetic matching"	]
[ "txtsim",	"str2qgrams",	"command txtsim.str2qgrams(s:str):bat[:str] ",	"CMDstr2qgrams;",	"Break the string into 4-grams"	]
[ "txtsim",	"stringdiff",	"command txtsim.stringdiff(s1:str, s2:str):int ",	"stringdiff_impl;",	"calculate the soundexed editdistance"	]
[ "udf",	"fuse",	"command udf.fuse(one:bte, two:bte):sht ",	"UDFfuse_bte_sht;",	"fuse two (1-byte) bte values into one (2-byte) sht value"	]
[ "udf",	"fuse",	"command udf.fuse(one:int, two:int):lng ",	"UDFfuse_int_lng;",	"fuse two (4-byte) int values into one (8-byte) lng value"	]
[ "udf",	"fuse",	"command udf.fuse(one:lng, two:lng):hge ",	"UDFfuse_lng_hge;",	"fuse two (8-byte) lng values into one (16-byte) hge value"	]
[ "udf",	"fuse",	"command udf.fuse(one:sht, two:sht):int ",	"UDFfuse_sht_int;",	"fuse two (2-byte) sht values into one (4-byte) int value"	]
[ "udf",	"reverse",	"command udf.reverse(ra1:str):str ",	"UDFreverse;",	"Reverse a string"	]
[ "url",	"#fromstr",	"command url.#fromstr():void ",	"URLfromString;",	"Convert a string to an url. "	]
[ "url",	"#tostr",	"command url.#tostr():void ",	"URLtoString;",	"Convert url to string equivalent"	]
[ "url",	"getAnchor",	"command url.getAnchor(u:url):str ",	"URLgetAnchor;",	"Extract the URL anchor (reference)"	]
[ "url",	"getBasename",	"command url.getBasename(u:url):str ",	"URLgetBasename;",	"Extract the URL base file name"	]
[ "url",	"getContent",	"command url.getContent(u:url):str ",	"URLgetContent;",	"Get the URL resource in a local file"	]
[ "url",	"getContext",	"command url.getContext(u:url):str ",	"URLgetContext;",	"Get the path context of a URL"	]
[ "url",	"getDomain",	"command url.getDomain(u:url):str ",	"URLgetDomain;",	"Extract Internet domain from the URL"	]
[ "url",	"getExtension",	"command url.getExtension(u:url):str ",	"URLgetExtension;",	"Extract the file extension of the URL"	]
[ "url",	"getFile",	"command url.getFile(u:url):str ",	"URLgetFile;",	"Extract the last file name of the URL"	]
[ "url",	"getHost",	"command url.getHost(u:url):str ",	"URLgetHost;",	"Extract the server name from the URL"	]
[ "url",	"getPort",	"command url.getPort(u:url):str ",	"URLgetPort;",	"Extract the port id from the URL"	]
[ "url",	"getProtocol",	"command url.getProtocol(u:url):str ",	"URLgetProtocol;",	"Extract the protocol from the URL"	]
[ "url",	"getQuery",	"command url.getQuery(u:url):str ",	"URLgetQuery;",	"Extract the query string from the URL"	]
[ "url",	"getRobotURL",	"command url.getRobotURL(u:url):str ",	"URLgetRobotURL;",	"Extract the location of the robot control file"	]
[ "url",	"getUser",	"command url.getUser(u:url):str ",	"URLgetUser;",	"Extract the user identity from the URL"	]
[ "url",	"isaURL",	"command url.isaURL(u:str):bit ",	"URLisaURL;",	"Check conformity of the URL syntax"	]
[ "url",	"new",	"command url.new(prot:str, host:str, fnme:str):url ",	"URLnew3;",	"Construct URL from protocol, host,and file"	]
[ "url",	"new",	"command url.new(p:str, h:str, prt:int, f:str):url ",	"URLnew4;",	"Construct URL from protocol, host, port, and file"	]
[ "url",	"url",	"command url.url(s:str):url ",	"URLnew;",	"Create an URL from a string literal"	]
[ "url",	"url",	"command url.url(s:url):url ",	"URLnoop;",	"Create an URL from a string literal"	]
[ "user",	"main",	"function user.main():void;",	"",	""	]
[ "user",	"s2_0",	"function user.s2_0():void;",	"",	""	]
[ "uuid",	"#cmp",	"command uuid.#cmp():void ",	"UUIDcompare;",	""	]
[ "uuid",	"#fromstr",	"command uuid.#fromstr():void ",	"UUIDfromString;",	""	]
[ "uuid",	"#hash",	"command uuid.#hash():void ",	"UUIDhash;",	""	]
[ "uuid",	"#null",	"command uuid.#null():void ",	"UUIDnull;",	""	]
[ "uuid",	"#read",	"command uuid.#read():void ",	"UUIDread;",	""	]
[ "uuid",	"#tostr",	"command uuid.#tostr():void ",	"UUIDtoString;",	""	]
[ "uuid",	"#write",	"command uuid.#write():void ",	"UUIDwrite;",	""	]
[ "uuid",	"isaUUID",	"command uuid.isaUUID(u:str):bit ",	"UUIDisaUUID;",	"Test a string for a UUID format"	]
[ "uuid",	"new",	"unsafe command uuid.new():uuid ",	"UUIDgenerateUuid;",	"Generate a new uuid"	]
[ "uuid",	"new",	"unsafe command uuid.new(d:int):uuid ",	"UUIDgenerateUuidInt;",	"Generate a new uuid (dummy version for side effect free multiplex loop)"	]
[ "uuid",	"prelude",	"command uuid.prelude():void ",	"UUIDprelude;",	""	]
[ "uuid",	"str",	"command uuid.str(u:uuid):str ",	"UUIDuuid2str;",	"Coerce a uuid to its string type"	]
[ "uuid",	"uuid",	"command uuid.uuid(s:str):uuid ",	"UUIDstr2uuid;",	"Coerce a string to a uuid, validating its format"	]
[ "wkb",	"#cmp",	"command wkb.#cmp():void ",	"wkbCOMP;",	""	]
[ "wkb",	"#del",	"command wkb.#del():void ",	"wkbDEL;",	""	]
[ "wkb",	"#fromstr",	"command wkb.#fromstr():void ",	"wkbFROMSTR;",	""	]
[ "wkb",	"#hash",	"command wkb.#hash():void ",	"wkbHASH;",	""	]
[ "wkb",	"#heap",	"command wkb.#heap():void ",	"wkbHEAP;",	""	]
[ "wkb",	"#length",	"command wkb.#length():void ",	"wkbLENGTH;",	""	]
[ "wkb",	"#null",	"command wkb.#null():void ",	"wkbNULL;",	""	]
[ "wkb",	"#put",	"command wkb.#put():void ",	"wkbPUT;",	""	]
[ "wkb",	"#read",	"command wkb.#read():void ",	"wkbREAD;",	""	]
[ "wkb",	"#tostr",	"command wkb.#tostr():void ",	"wkbTOSTR;",	""	]
[ "wkb",	"#write",	"command wkb.#write():void ",	"wkbWRITE;",	""	]
[ "wkba",	"#cmp",	"command wkba.#cmp():void ",	"wkbaCOMP;",	""	]
[ "wkba",	"#del",	"command wkba.#del():void ",	"wkbaDEL;",	""	]
[ "wkba",	"#fromstr",	"command wkba.#fromstr():void ",	"wkbaFROMSTR;",	""	]
[ "wkba",	"#hash",	"command wkba.#hash():void ",	"wkbaHASH;",	""	]
[ "wkba",	"#heap",	"command wkba.#heap():void ",	"wkbaHEAP;",	""	]
[ "wkba",	"#length",	"command wkba.#length():void ",	"wkbaLENGTH;",	""	]
[ "wkba",	"#null",	"command wkba.#null():void ",	"wkbaNULL;",	""	]
[ "wkba",	"#put",	"command wkba.#put():void ",	"wkbaPUT;",	""	]
[ "wkba",	"#read",	"command wkba.#read():void ",	"wkbaREAD;",	""	]
[ "wkba",	"#tostr",	"command wkba.#tostr():void ",	"wkbaTOSTR;",	""	]
[ "wkba",	"#write",	"command wkba.#write():void ",	"wkbaWRITE;",	""	]
[ "wlc",	"action",	"pattern wlc.action(q:str):void ",	"WLCaction;",	"Keep the database changing queries for replay. "	]
[ "wlc",	"alter_add_range_partition",	"pattern wlc.alter_add_range_partition(sname:str, mtnme:str, psnme:str, ptnme:str, min:str, max:str, nills:bit, update:int):void ",	"WLCgeneric;",	"Catalog operation alter_add_range_partition"	]
[ "wlc",	"alter_add_table",	"pattern wlc.alter_add_table(sname:str, mtnme:str, psnme:str, ptnme:str, action:int):void ",	"WLCgeneric;",	"Catalog operation alter_add_table"	]
[ "wlc",	"alter_add_value_partition",	"pattern wlc.alter_add_value_partition(sname:str, mtnme:str, psnme:str, ptnme:str, nills:bit, update:int):void ",	"WLCgeneric;",	"Catalog operation alter_add_value_partition"	]
[ "wlc",	"alter_add_value_partition",	"pattern wlc.alter_add_value_partition(sname:str, mtnme:str, psnme:str, ptnme:str, nills:bit, update:int, arg:str...):void ",	"WLCgeneric;",	"Catalog operation alter_add_value_partition"	]
[ "wlc",	"alter_del_table",	"pattern wlc.alter_del_table(sname:str, mtnme:str, psnme:str, ptnme:str, action:int):void ",	"WLCgeneric;",	"Catalog operation alter_del_table"	]
[ "wlc",	"alter_seq",	"pattern wlc.alter_seq(sname:str, seqname:str, seq:ptr, val:bat[:lng]):void ",	"WLCgeneric;",	"Catalog operation alter_seq"	]
[ "wlc",	"alter_seq",	"pattern wlc.alter_seq(sname:str, seqname:str, val:lng):void ",	"WLCgeneric;",	"Catalog operation alter_seq"	]
[ "wlc",	"alter_set_table",	"pattern wlc.alter_set_table(sname:str, tnme:str, access:int):void ",	"WLCgeneric;",	"Catalog operation alter_set_table"	]
[ "wlc",	"alter_table",	"pattern wlc.alter_table(sname:str, tname:str, action:int):void ",	"WLCgeneric;",	"Catalog operation alter_table"	]
[ "wlc",	"alter_user",	"pattern wlc.alter_user(sname:str, passwrd:str, enc:int, schema:str, oldpasswrd:str):void ",	"WLCgeneric;",	"Catalog operation alter_user"	]
[ "wlc",	"append",	"pattern wlc.append(sname:str, tname:str, cname:str, ins:any):int ",	"WLCappend;",	"Keep the insertions in the workload-capture-replay list"	]
[ "wlc",	"catalog",	"pattern wlc.catalog(q:str):void ",	"WLCcatalog;",	"Keep the catalog changing queries for replay. "	]
[ "wlc",	"clear_table",	"pattern wlc.clear_table(sname:str, tname:str):int ",	"WLCclear_table;",	"Keep the deletions in the workload-capture-replay list"	]
[ "wlc",	"comment_on",	"pattern wlc.comment_on(objid:int, remark:str):void ",	"WLCgeneric;",	"Catalog operation comment_on"	]
[ "wlc",	"commit",	"pattern wlc.commit():void ",	"WLCcommitCmd;",	"Commit the workload-capture-replay record"	]
[ "wlc",	"commit",	"pattern wlc.commit():void ",	"WLCcommitCmd;",	"Mark the end of the work unit"	]
[ "wlc",	"create_function",	"pattern wlc.create_function(sname:str, fname:str):void ",	"WLCgeneric;",	"Catalog operation create_function"	]
[ "wlc",	"create_role",	"pattern wlc.create_role(sname:str, role:str, grator:int):void ",	"WLCgeneric;",	"Catalog operation create_role"	]
[ "wlc",	"create_schema",	"pattern wlc.create_schema(sname:str, auth:str, ifnotexists:int, action:int):void ",	"WLCgeneric;",	"Catalog operation create_schema"	]
[ "wlc",	"create_seq",	"pattern wlc.create_seq(sname:str, seqname:str, action:int):void ",	"WLCgeneric;",	"Catalog operation create_seq"	]
[ "wlc",	"create_table",	"pattern wlc.create_table(sname:str, tname:str, temp:int):void ",	"WLCgeneric;",	"Catalog operation create_table"	]
[ "wlc",	"create_trigger",	"pattern wlc.create_trigger(sname:str, tname:str, triggername:str, time:int, orientation:int, event:int, old:str, new:str, cond:str, qry:str):void ",	"WLCgeneric;",	"Catalog operation create_trigger"	]
[ "wlc",	"create_type",	"pattern wlc.create_type(sname:str, nme:str, impl:str):void ",	"WLCgeneric;",	"Catalog operation create_type"	]
[ "wlc",	"create_user",	"pattern wlc.create_user(sname:str, passwrd:str, enc:int, schema:str, fullname:str):void ",	"WLCgeneric;",	"Catalog operation create_user"	]
[ "wlc",	"create_view",	"pattern wlc.create_view(sname:str, tname:str, temp:int):void ",	"WLCgeneric;",	"Catalog operation create_view"	]
[ "wlc",	"delete",	"pattern wlc.delete(sname:str, tname:str, b:any):int ",	"WLCdelete;",	"Keep the deletions in the workload-capture-replay list"	]
[ "wlc",	"drop_constraint",	"pattern wlc.drop_constraint(sname:str, name:str, action:int, ifexists:int):void ",	"WLCgeneric;",	"Catalog operation drop_constraint"	]
[ "wlc",	"drop_function",	"pattern wlc.drop_function(sname:str, fname:str, fid:int, type:int, action:int):void ",	"WLCgeneric;",	"Catalog operation drop_function"	]
[ "wlc",	"drop_index",	"pattern wlc.drop_index(sname:str, iname:str, action:int):void ",	"WLCgeneric;",	"Catalog operation drop_index"	]
[ "wlc",	"drop_role",	"pattern wlc.drop_role(auth:str, role:str, action:int):void ",	"WLCgeneric;",	"Catalog operation drop_role"	]
[ "wlc",	"drop_role",	"pattern wlc.drop_role(role:str, action:int):void ",	"WLCgeneric;",	"Catalog operation drop_role"	]
[ "wlc",	"drop_schema",	"pattern wlc.drop_schema(sname:str, s:str, ifexists:int, action:int):void ",	"WLCgeneric;",	"Catalog operation drop_schema"	]
[ "wlc",	"drop_seq",	"pattern wlc.drop_seq(sname:str, nme:str, action:int):void ",	"WLCgeneric;",	"Catalog operation drop_seq"	]
[ "wlc",	"drop_table",	"pattern wlc.drop_table(sname:str, name:str, action:int, ifexists:int):void ",	"WLCgeneric;",	"Catalog operation drop_table"	]
[ "wlc",	"drop_trigger",	"pattern wlc.drop_trigger(sname:str, nme:str, ifexists:int):void ",	"WLCgeneric;",	"Catalog operation drop_trigger"	]
[ "wlc",	"drop_type",	"pattern wlc.drop_type(sname:str, nme:str, action:int):void ",	"WLCgeneric;",	"Catalog operation drop_type"	]
[ "wlc",	"drop_user",	"pattern wlc.drop_user(sname:str, action:int):void ",	"WLCgeneric;",	"Catalog operation drop_user"	]
[ "wlc",	"drop_user",	"pattern wlc.drop_user(sname:str, auth:str, action:int):void ",	"WLCgeneric;",	"Catalog operation drop_user"	]
[ "wlc",	"drop_view",	"pattern wlc.drop_view(sname:str, name:str, action:int, ifexists:int):void ",	"WLCgeneric;",	"Catalog operation drop_view"	]
[ "wlc",	"epilogue",	"command wlc.epilogue():void ",	"WLCepilogue;",	"release the resources held by the wlc module"	]
[ "wlc",	"flush",	"pattern wlc.flush():void ",	"WLCflush;",	"Flush current log buffer"	]
[ "wlc",	"getbeat",	"pattern wlc.getbeat(duration:int):str ",	"WLCgetbeat;",	"Maximal delay for transaction log flushing"	]
[ "wlc",	"getclock",	"pattern wlc.getclock():str ",	"WLCgetclock;",	"Timestamp of last update transaction"	]
[ "wlc",	"gettick",	"pattern wlc.gettick():lng ",	"WLCgettick;",	"Transaction identifier of the last committed transaction"	]
[ "wlc",	"grant",	"pattern wlc.grant(sname:str, tbl:str, grantee:str, privs:int, cname:str, gr:int, grantor:int):void ",	"WLCgeneric;",	"Catalog operation grant"	]
[ "wlc",	"grant_function",	"pattern wlc.grant_function(sname:str, fcnid:int, grantee:str, privs:int, grant:int, grantor:int):void ",	"WLCgeneric;",	"Catalog operation grant_function"	]
[ "wlc",	"grant_roles",	"pattern wlc.grant_roles(sname:str, auth:str, grantor:int, admin:int):void ",	"WLCgeneric;",	"Catalog operation grant_roles"	]
[ "wlc",	"init",	"pattern wlc.init():void ",	"WLCinitCmd;",	"Test for running as master"	]
[ "wlc",	"master",	"pattern wlc.master():void ",	"WLCmaster;",	"Activate the workload-capture-replay process"	]
[ "wlc",	"master",	"pattern wlc.master(path:str):void ",	"WLCmaster;",	"Activate the workload-capture-replay process. Use a different location for the logs."	]
[ "wlc",	"query",	"pattern wlc.query(q:str):void ",	"WLCquery;",	"Keep the queries for replay."	]
[ "wlc",	"rename_column",	"pattern wlc.rename_column(sname:str, tname:str, cname:str, newnme:str):void ",	"WLCgeneric;",	"Catalog operation rename_column"	]
[ "wlc",	"rename_schema",	"pattern wlc.rename_schema(sname:str, newnme:str):void ",	"WLCgeneric;",	"Catalog operation rename_schema"	]
[ "wlc",	"rename_table",	"pattern wlc.rename_table(osname:str, nsname:str, otname:str, ntname:str):void ",	"WLCgeneric;",	"Catalog operation rename_table"	]
[ "wlc",	"rename_user",	"pattern wlc.rename_user(sname:str, newnme:str, action:int):void ",	"WLCgeneric;",	"Catalog operation rename_user"	]
[ "wlc",	"revoke",	"pattern wlc.revoke(sname:str, tbl:str, grantee:str, privs:int, cname:str, grant:int, grantor:int):void ",	"WLCgeneric;",	"Catalog operation revoke"	]
[ "wlc",	"revoke_function",	"pattern wlc.revoke_function(sname:str, fcnid:int, grantee:str, privs:int, grant:int, grantor:int):void ",	"WLCgeneric;",	"Catalog operation revoke_function"	]
[ "wlc",	"revoke_roles",	"pattern wlc.revoke_roles(sname:str, auth:str, grantor:int, admin:int):void ",	"WLCgeneric;",	"Catalog operation revoke_roles"	]
[ "wlc",	"rollback",	"pattern wlc.rollback():void ",	"WLCcommitCmd;",	"Rollback the workload-capture-replay record"	]
[ "wlc",	"rollback",	"pattern wlc.rollback():void ",	"WLCrollbackCmd;",	"Mark the end of the work unit"	]
[ "wlc",	"setbeat",	"pattern wlc.setbeat(duration:int):void ",	"WLCsetbeat;",	"Maximal delay for transaction log flushing"	]
[ "wlc",	"stop",	"pattern wlc.stop():void ",	"WLCstop;",	"Stop capturing the logs"	]
[ "wlc",	"transaction",	"unsafe pattern wlc.transaction():void ",	"WLCgeneric;",	"Start an autocommit transaction"	]
[ "wlc",	"transaction_begin",	"pattern wlc.transaction_begin(chain:int, name:str):void ",	"WLCgeneric;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "wlc",	"transaction_commit",	"pattern wlc.transaction_commit(chain:int, name:str):void ",	"WLCgeneric;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "wlc",	"transaction_release",	"pattern wlc.transaction_release(chain:int, name:str):void ",	"WLCgeneric;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "wlc",	"transaction_rollback",	"pattern wlc.transaction_rollback(chain:int, name:str):void ",	"WLCgeneric;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "wlc",	"update",	"pattern wlc.update(sname:str, tname:str, cname:str, tid:any, val:any):int ",	"WLCupdate;",	"Keep the update in the workload-capture-replay list"	]
[ "wlr",	"accept",	"pattern wlr.accept():void ",	"WLRaccept;",	"Accept failing transaction"	]
[ "wlr",	"action",	"pattern wlr.action(q:str):void ",	"WLRaction;",	"A query producing updates"	]
[ "wlr",	"alter_add_range_partition",	"pattern wlr.alter_add_range_partition(sname:str, mtnme:str, psnme:str, ptnme:str, min:str, max:str, nills:bit, update:int):void ",	"WLRgeneric;",	"Catalog operation alter_add_range_partition"	]
[ "wlr",	"alter_add_table",	"pattern wlr.alter_add_table(sname:str, mtnme:str, psnme:str, ptnme:str, action:int):void ",	"WLRgeneric;",	"Catalog operation alter_add_table"	]
[ "wlr",	"alter_add_value_partition",	"pattern wlr.alter_add_value_partition(sname:str, mtnme:str, psnme:str, ptnme:str, nills:bit, update:int):void ",	"WLRgeneric;",	"Catalog operation alter_add_value_partition"	]
[ "wlr",	"alter_add_value_partition",	"pattern wlr.alter_add_value_partition(sname:str, mtnme:str, psnme:str, ptnme:str, nills:bit, update:int, arg:str...):void ",	"WLRgeneric;",	"Catalog operation alter_add_value_partition"	]
[ "wlr",	"alter_del_table",	"pattern wlr.alter_del_table(sname:str, mtnme:str, psnme:str, ptnme:str, action:int):void ",	"WLRgeneric;",	"Catalog operation alter_del_table"	]
[ "wlr",	"alter_seq",	"pattern wlr.alter_seq(sname:str, seqname:str, seq:ptr, val:bat[:lng]):void ",	"WLRgeneric;",	"Catalog operation alter_seq"	]
[ "wlr",	"alter_seq",	"pattern wlr.alter_seq(sname:str, seqname:str, val:lng):void ",	"WLRgeneric;",	"Catalog operation alter_seq"	]
[ "wlr",	"alter_set_table",	"pattern wlr.alter_set_table(sname:str, tnme:str, access:int):void ",	"WLRgeneric;",	"Catalog operation alter_set_table"	]
[ "wlr",	"alter_table",	"pattern wlr.alter_table(sname:str, tname:str, action:int):void ",	"WLRgeneric;",	"Catalog operation alter_table"	]
[ "wlr",	"alter_user",	"pattern wlr.alter_user(sname:str, passwrd:str, enc:int, schema:str, oldpasswrd:str):void ",	"WLRgeneric;",	"Catalog operation alter_user"	]
[ "wlr",	"append",	"pattern wlr.append(sname:str, tname:str, cname:str, ins:any...):int ",	"WLRappend;",	"Apply the insertions in the workload-capture-replay list"	]
[ "wlr",	"catalog",	"pattern wlr.catalog(q:str):void ",	"WLRcatalog;",	"A catalog changing query"	]
[ "wlr",	"clear_table",	"pattern wlr.clear_table(sname:str, tname:str):int ",	"WLRclear_table;",	"Destroy the tuples in the table"	]
[ "wlr",	"comment_on",	"pattern wlr.comment_on(objid:int, remark:str):void ",	"WLRgeneric;",	"Catalog operation comment_on"	]
[ "wlr",	"commit",	"pattern wlr.commit():void ",	"WLRcommit;",	"Mark the end of the work unit"	]
[ "wlr",	"create_function",	"pattern wlr.create_function(sname:str, fname:str):void ",	"WLRgeneric;",	"Catalog operation create_function"	]
[ "wlr",	"create_role",	"pattern wlr.create_role(sname:str, role:str, grator:int):void ",	"WLRgeneric;",	"Catalog operation create_role"	]
[ "wlr",	"create_schema",	"pattern wlr.create_schema(sname:str, auth:str, ifnotexists:int, action:int):void ",	"WLRgeneric;",	"Catalog operation create_schema"	]
[ "wlr",	"create_seq",	"pattern wlr.create_seq(sname:str, seqname:str, action:int):void ",	"WLRgeneric;",	"Catalog operation create_seq"	]
[ "wlr",	"create_table",	"pattern wlr.create_table(sname:str, tname:str, temp:int):void ",	"WLRgeneric;",	"Catalog operation create_table"	]
[ "wlr",	"create_trigger",	"pattern wlr.create_trigger(sname:str, tname:str, triggername:str, time:int, orientation:int, event:int, old:str, new:str, cond:str, qry:str):void ",	"WLRgeneric;",	"Catalog operation create_trigger"	]
[ "wlr",	"create_type",	"pattern wlr.create_type(sname:str, nme:str, impl:str):void ",	"WLRgeneric;",	"Catalog operation create_type"	]
[ "wlr",	"create_user",	"pattern wlr.create_user(sname:str, passwrd:str, enc:int, schema:str, fullname:str):void ",	"WLRgeneric;",	"Catalog operation create_user"	]
[ "wlr",	"create_view",	"pattern wlr.create_view(sname:str, tname:str, temp:int):void ",	"WLRgeneric;",	"Catalog operation create_view"	]
[ "wlr",	"delete",	"pattern wlr.delete(sname:str, tname:str, b:oid...):int ",	"WLRdelete;",	"Apply the deletions in the workload-capture-replay list"	]
[ "wlr",	"drop_constraint",	"pattern wlr.drop_constraint(sname:str, name:str, action:int, ifexists:int):void ",	"WLRgeneric;",	"Catalog operation drop_constraint"	]
[ "wlr",	"drop_function",	"pattern wlr.drop_function(sname:str, fname:str, fid:int, type:int, action:int):void ",	"WLRgeneric;",	"Catalog operation drop_function"	]
[ "wlr",	"drop_index",	"pattern wlr.drop_index(sname:str, iname:str, action:int):void ",	"WLRgeneric;",	"Catalog operation drop_index"	]
[ "wlr",	"drop_role",	"pattern wlr.drop_role(auth:str, role:str, action:int):void ",	"WLRgeneric;",	"Catalog operation drop_role"	]
[ "wlr",	"drop_role",	"pattern wlr.drop_role(role:str, action:int):void ",	"WLRgeneric;",	"Catalog operation drop_role"	]
[ "wlr",	"drop_schema",	"pattern wlr.drop_schema(sname:str, s:str, ifexists:int, action:int):void ",	"WLRgeneric;",	"Catalog operation drop_schema"	]
[ "wlr",	"drop_seq",	"pattern wlr.drop_seq(sname:str, nme:str, action:int):void ",	"WLRgeneric;",	"Catalog operation drop_seq"	]
[ "wlr",	"drop_table",	"pattern wlr.drop_table(sname:str, name:str, action:int, ifexists:int):void ",	"WLRgeneric;",	"Catalog operation drop_table"	]
[ "wlr",	"drop_trigger",	"pattern wlr.drop_trigger(sname:str, nme:str, ifexists:int):void ",	"WLRgeneric;",	"Catalog operation drop_trigger"	]
[ "wlr",	"drop_type",	"pattern wlr.drop_type(sname:str, nme:str, action:int):void ",	"WLRgeneric;",	"Catalog operation drop_type"	]
[ "wlr",	"drop_user",	"pattern wlr.drop_user(sname:str, action:int):void ",	"WLRgeneric;",	"Catalog operation drop_user"	]
[ "wlr",	"drop_user",	"pattern wlr.drop_user(sname:str, auth:str, action:int):void ",	"WLRgeneric;",	"Catalog operation drop_user"	]
[ "wlr",	"drop_view",	"pattern wlr.drop_view(sname:str, name:str, action:int, ifexists:int):void ",	"WLRgeneric;",	"Catalog operation drop_view"	]
[ "wlr",	"getMaster",	"pattern wlr.getMaster():str ",	"WLRgetmaster;",	"What is the current master database"	]
[ "wlr",	"getclock",	"pattern wlr.getclock():str ",	"WLRgetclock;",	"Timestamp of last replicated transaction."	]
[ "wlr",	"gettick",	"pattern wlr.gettick():lng ",	"WLRgettick;",	"Transaction identifier of the last replicated transaction."	]
[ "wlr",	"grant",	"pattern wlr.grant(sname:str, tbl:str, grantee:str, privs:int, cname:str, gr:int, grantor:int):void ",	"WLRgeneric;",	"Catalog operation grant"	]
[ "wlr",	"grant_function",	"pattern wlr.grant_function(sname:str, fcnid:int, grantee:str, privs:int, grant:int, grantor:int):void ",	"WLRgeneric;",	"Catalog operation grant_function"	]
[ "wlr",	"grant_roles",	"pattern wlr.grant_roles(sname:str, auth:str, grantor:int, admin:int):void ",	"WLRgeneric;",	"Catalog operation grant_roles"	]
[ "wlr",	"master",	"pattern wlr.master(dbname:str):void ",	"WLRmaster;",	"Initialize the replicator thread"	]
[ "wlr",	"rename_column",	"pattern wlr.rename_column(sname:str, tname:str, cname:str, newnme:str):void ",	"WLRgeneric;",	"Catalog operation rename_column"	]
[ "wlr",	"rename_schema",	"pattern wlr.rename_schema(sname:str, newnme:str):void ",	"WLRgeneric;",	"Catalog operation rename_schema"	]
[ "wlr",	"rename_table",	"pattern wlr.rename_table(osname:str, nsname:str, otname:str, ntname:str):void ",	"WLRgeneric;",	"Catalog operation rename_table"	]
[ "wlr",	"rename_user",	"pattern wlr.rename_user(sname:str, newnme:str, action:int):void ",	"WLRgeneric;",	"Catalog operation rename_user"	]
[ "wlr",	"replicate",	"pattern wlr.replicate():void ",	"WLRreplicate;",	"Continue to keep the replica in sink"	]
[ "wlr",	"replicate",	"pattern wlr.replicate(id:bte):void ",	"WLRreplicate;",	"Roll the snapshot forward to a specific transaction id"	]
[ "wlr",	"replicate",	"pattern wlr.replicate(id:int):void ",	"WLRreplicate;",	"Roll the snapshot forward to a specific transaction id"	]
[ "wlr",	"replicate",	"pattern wlr.replicate(id:lng):void ",	"WLRreplicate;",	"Roll the snapshot forward to a specific transaction id"	]
[ "wlr",	"replicate",	"pattern wlr.replicate(id:sht):void ",	"WLRreplicate;",	"Roll the snapshot forward to a specific transaction id"	]
[ "wlr",	"replicate",	"pattern wlr.replicate(ts:timestamp):void ",	"WLRreplicate;",	"Roll the snapshot forward to an up-to-date clone"	]
[ "wlr",	"revoke",	"pattern wlr.revoke(sname:str, tbl:str, grantee:str, privs:int, cname:str, grant:int, grantor:int):void ",	"WLRgeneric;",	"Catalog operation revoke"	]
[ "wlr",	"revoke_function",	"pattern wlr.revoke_function(sname:str, fcnid:int, grantee:str, privs:int, grant:int, grantor:int):void ",	"WLRgeneric;",	"Catalog operation revoke_function"	]
[ "wlr",	"revoke_roles",	"pattern wlr.revoke_roles(sname:str, auth:str, grantor:int, admin:int):void ",	"WLRgeneric;",	"Catalog operation revoke_roles"	]
[ "wlr",	"rollback",	"pattern wlr.rollback():void ",	"WLRrollback;",	"Mark the end of the work unit"	]
[ "wlr",	"setbeat",	"pattern wlr.setbeat(dur:int):void ",	"WLRsetbeat;",	"Threshold (in seconds) for re-running queries"	]
[ "wlr",	"stop",	"pattern wlr.stop():void ",	"WLRstop;",	"Stop the replicator thread"	]
[ "wlr",	"transaction",	"unsafe pattern wlr.transaction():void ",	"WLRgeneric;",	"Start an autocommit transaction"	]
[ "wlr",	"transaction",	"pattern wlr.transaction(tid:lng, started:str, user:str):void ",	"WLRtransaction;",	"Mark the beginning of the work unit which can be a compound transaction"	]
[ "wlr",	"transaction_begin",	"pattern wlr.transaction_begin(chain:int, name:str):void ",	"WLRgeneric;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "wlr",	"transaction_commit",	"pattern wlr.transaction_commit(chain:int, name:str):void ",	"WLRgeneric;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "wlr",	"transaction_release",	"pattern wlr.transaction_release(chain:int, name:str):void ",	"WLRgeneric;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "wlr",	"transaction_rollback",	"pattern wlr.transaction_rollback(chain:int, name:str):void ",	"WLRgeneric;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "wlr",	"update",	"pattern wlr.update(sname:str, tname:str, cname:str, tid:oid, val:any):int ",	"WLRupdate;",	"Apply the update in the workload-capture-replay list"	]
[ "xml",	"#fromstr",	"command xml.#fromstr():void ",	"XMLfromString;",	"Convert a string to an xml."	]
[ "xml",	"#tostr",	"command xml.#tostr():void ",	"XMLtoString;",	"Convert xml to string equivalent"	]
[ "xml",	"aggr",	"command xml.aggr(val:bat[:xml]):xml ",	"BATXMLgroup;",	"Aggregate the XML values."	]
[ "xml",	"attribute",	"command xml.attribute(name:str, val:str):xml ",	"XMLattribute;",	"Construct an attribute value pair"	]
[ "xml",	"comment",	"command xml.comment(val:str):xml ",	"XMLcomment;",	"Construct an comment struction "	]
[ "xml",	"concat",	"command xml.concat(val1:xml, val2:xml):xml ",	"XMLconcat;",	"Concatenate the xml values"	]
[ "xml",	"content",	"command xml.content(val:str):xml ",	"XMLcontent;",	"Check the value for compliance as content, i.e.  it may contain multiple roots and character data."	]
[ "xml",	"document",	"command xml.document(val:str):xml ",	"XMLdocument;",	"Check the value for compliance as XML document"	]
[ "xml",	"element",	"command xml.element(name:str, ns:xml, attr:xml, s:xml):xml ",	"XMLelement;",	"The basic building block for XML elements are namespaces, attributes and a sequence of xml elements. The name space and the attributes may be left unspecified(=nil:bat)."	]
[ "xml",	"element",	"command xml.element(name:str, s:xml):xml ",	"XMLelementSmall;",	"The basic building block for XML elements are namespaces, attributes and a sequence of xml elements. The name space and the attributes may be left unspecified(=nil:bat)."	]
[ "xml",	"epilogue",	"command xml.epilogue():void ",	"XMLepilogue;",	""	]
[ "xml",	"forest",	"pattern xml.forest(val:xml...):xml ",	"XMLforest;",	"Construct an element list"	]
[ "xml",	"isdocument",	"command xml.isdocument(val:str):bit ",	"XMLisdocument;",	"Validate the string as a document"	]
[ "xml",	"parse",	"command xml.parse(doccont:str, val:str, option:str):xml ",	"XMLparse;",	"Parse the XML document or element string values "	]
[ "xml",	"pi",	"command xml.pi(target:str, val:str):xml ",	"XMLpi;",	"Construct a processing instruction"	]
[ "xml",	"prelude",	"command xml.prelude():void ",	"XMLprelude;",	""	]
[ "xml",	"root",	"command xml.root(val:xml, version:str, standalone:str):xml ",	"XMLroot;",	"Construct the root nodes"	]
[ "xml",	"str",	"command xml.str(src:xml):str ",	"XMLxml2str;",	"Cast the string to an xml compliant string"	]
[ "xml",	"subaggr",	"command xml.subaggr(val:bat[:xml], g:bat[:oid], e:bat[:any_1], skip_nils:bit):bat[:xml] ",	"AGGRsubxml;",	"Grouped aggregation of XML values."	]
[ "xml",	"subaggr",	"command xml.subaggr(val:bat[:xml], g:bat[:oid], e:bat[:any_1], s:bat[:oid], skip_nils:bit):bat[:xml] ",	"AGGRsubxmlcand;",	"Grouped aggregation of XML values with candidates list."	]
[ "xml",	"text",	"command xml.text(src:xml):str ",	"XMLxmltext;",	"Extract text from an xml atom"	]
[ "xml",	"xml",	"command xml.xml(src:str):xml ",	"XMLstr2xml;",	"Cast the string to an xml compliant string"	]

# 12:57:40 >  
# 12:57:40 >  "Done."
# 12:57:40 >  

