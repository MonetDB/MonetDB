stdout of test 'MAL-signatures` in directory 'clients` itself:


# 21:44:50 >  
# 21:44:50 >  "mserver5" "--debug=10" "--set" "gdk_nr_threads=0" "--set" "mapi_open=true" "--set" "mapi_port=33053" "--set" "mapi_usock=/var/tmp/mtest-13793/.s.monetdb.33053" "--set" "monet_prompt=" "--forcemito" "--set" "mal_listing=2" "--dbpath=/home/sjoerd/Monet-devel/var/MonetDB/mTests_clients" "--set" "mal_listing=2" "--set" "embedded_r=yes"
# 21:44:50 >  

# MonetDB 5 server v11.20.0
# This is an unreleased version
# Serving database 'mTests_clients', using 8 threads
# Compiled for x86_64-unknown-linux-gnu/64bit with 64bit OIDs and 128bit integers dynamically linked
# Found 7.734 GiB available main-memory.
# Copyright (c) 1993-July 2008 CWI.
# Copyright (c) August 2008-2015 MonetDB B.V., all rights reserved
# Visit http://www.monetdb.org/ for further information

Ready.
# SQL catalog created, loading sql scripts once
# loading sql script: 09_like.sql
# loading sql script: 10_math.sql
# loading sql script: 11_times.sql
# loading sql script: 12_url.sql
# loading sql script: 13_date.sql
# loading sql script: 14_inet.sql
# loading sql script: 15_querylog.sql
# loading sql script: 16_tracelog.sql
# loading sql script: 17_temporal.sql
# loading sql script: 18_index.sql
# loading sql script: 20_vacuum.sql
# loading sql script: 21_dependency_functions.sql
# loading sql script: 22_clients.sql
# loading sql script: 23_skyserver.sql
# loading sql script: 24_zorder.sql
# loading sql script: 25_debug.sql
# loading sql script: 26_sysmon.sql
# loading sql script: 27_rejects.sql
# loading sql script: 39_analytics.sql
# loading sql script: 39_analytics_hge.sql
# loading sql script: 40_geom.sql
# loading sql script: 40_json.sql
# loading sql script: 40_json_hge.sql
# loading sql script: 41_md5sum.sql
# loading sql script: 45_uuid.sql
# loading sql script: 46_gsl.sql
# loading sql script: 46_profiler.sql
# loading sql script: 51_sys_schema_extension.sql
# loading sql script: 72_fits.sql
# loading sql script: 74_netcdf.sql
# loading sql script: 75_shp.sql
# loading sql script: 75_storagemodel.sql
# loading sql script: 80_statistics.sql
# loading sql script: 80_udf.sql
# loading sql script: 80_udf_hge.sql
# loading sql script: 85_bam.sql
# loading sql script: 90_generator.sql
# loading sql script: 90_generator_hge.sql
# loading sql script: 99_system.sql

# 12:57:39 >  
# 12:57:39 >  "mclient" "-lsql" "-ftest" "-Eutf-8" "-i" "-e" "--host=/var/tmp/mtest-21549" "--port=35702"
# 12:57:39 >  

#select * from sys.malfunctions() order by module, "function", address, signature, comment;
% .L1,	.L1,	.L1,	.L1,	.L1 # table_name
% module,	function,	signature,	address,	comment # name
% clob,	clob,	clob,	clob,	clob # type
% 11,	28,	346,	44,	874 # length
[ "aggr",	"avg",	"command aggr.avg(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on bte"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on dbl"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on flt"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:hge],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on hge"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on int"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on lng"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRavg13_dbl;",	"Grouped tail average on sht"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on bte, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on dbl, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:flt],g:bat[:oid],e:bat[:any_1]) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on flt, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:hge],g:bat[:oid],e:bat[:any_1]) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on hge, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:int],g:bat[:oid],e:bat[:any_1]) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on int, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:lng],g:bat[:oid],e:bat[:any_1]) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on lng, also returns count"	]
[ "aggr",	"avg",	"command aggr.avg(b:bat[:sht],g:bat[:oid],e:bat[:any_1]) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRavg23_dbl;",	"Grouped tail average on sht, also returns count"	]
[ "aggr",	"avg",	"pattern aggr.avg(b:bat[:any_2]):dbl ",	"CMDcalcavg;",	"Gives the avg of all tail values"	]
[ "aggr",	"cardinality",	"command aggr.cardinality(b:bat[:any_2]):lng ",	"ALGcard;",	"Return the cardinality of the BAT tail values."	]
[ "aggr",	"corr",	"function aggr.corr(e1:bat[:bte],e2:bat[:bte]):bte;",	"",	""	]
[ "aggr",	"corr",	"function aggr.corr(e1:bat[:dbl],e2:bat[:dbl]):dbl;",	"",	""	]
[ "aggr",	"corr",	"function aggr.corr(e1:bat[:flt],e2:bat[:flt]):flt;",	"",	""	]
[ "aggr",	"corr",	"function aggr.corr(e1:bat[:hge],e2:bat[:hge]):hge;",	"",	""	]
[ "aggr",	"corr",	"function aggr.corr(e1:bat[:int],e2:bat[:int]):int;",	"",	""	]
[ "aggr",	"corr",	"function aggr.corr(e1:bat[:lng],e2:bat[:lng]):lng;",	"",	""	]
[ "aggr",	"corr",	"function aggr.corr(e1:bat[:sht],e2:bat[:sht]):sht;",	"",	""	]
[ "aggr",	"count",	"command aggr.count(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],ignorenils:bit):bat[:lng] ",	"AGGRcount3;",	""	]
[ "aggr",	"count",	"command aggr.count(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:lng] ",	"AGGRcount3nils;",	"Grouped count"	]
[ "aggr",	"count",	"command aggr.count(b:bat[:any]):lng ",	"ALGcount_bat;",	"Return the current size (in number of elements) in a BAT."	]
[ "aggr",	"count",	"command aggr.count(b:bat[:any],ignore_nils:bit):lng ",	"ALGcount_nil;",	"Return the number of elements currently in a BAT ignores\n\t\tBUNs with nil-tail iff ignore_nils==TRUE."	]
[ "aggr",	"count_no_nil",	"command aggr.count_no_nil(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:lng] ",	"AGGRcount3nonils;",	""	]
[ "aggr",	"count_no_nil",	"command aggr.count_no_nil(b:bat[:any_2]):lng ",	"ALGcount_no_nil;",	"Return the number of elements currently\n\tin a BAT ignoring BUNs with nil-tail"	]
[ "aggr",	"covar",	"function aggr.covar(e1:bat[:bte],e2:bat[:bte]):bte;",	"",	""	]
[ "aggr",	"covar",	"function aggr.covar(e1:bat[:dbl],e2:bat[:dbl]):dbl;",	"",	""	]
[ "aggr",	"covar",	"function aggr.covar(e1:bat[:flt],e2:bat[:flt]):flt;",	"",	""	]
[ "aggr",	"covar",	"function aggr.covar(e1:bat[:hge],e2:bat[:hge]):hge;",	"",	""	]
[ "aggr",	"covar",	"function aggr.covar(e1:bat[:int],e2:bat[:int]):int;",	"",	""	]
[ "aggr",	"covar",	"function aggr.covar(e1:bat[:lng],e2:bat[:lng]):lng;",	"",	""	]
[ "aggr",	"covar",	"function aggr.covar(e1:bat[:sht],e2:bat[:sht]):sht;",	"",	""	]
[ "aggr",	"exist",	"command aggr.exist(b:bat[:any_2],h:any_1):bit ",	"ALGexist;",	""	]
[ "aggr",	"jsonaggr",	"command aggr.jsonaggr(val:bat[:dbl]):str ",	"JSONgroupStr;",	"Aggregate the double values to array."	]
[ "aggr",	"jsonaggr",	"command aggr.jsonaggr(val:bat[:str]):str ",	"JSONgroupStr;",	"Aggregate the string values to array."	]
[ "aggr",	"max",	"command aggr.max(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:any_1] ",	"AGGRmax3;",	""	]
[ "aggr",	"max",	"command aggr.max(b:bat[:any_2]):any_2 ",	"ALGmaxany;",	"Return the highest tail value or nil."	]
[ "aggr",	"median",	"function aggr.median(b:bat[:any_1]):any_1;",	"",	""	]
[ "aggr",	"median",	"command aggr.median(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:any_1] ",	"AGGRmedian3;",	"Grouped median aggregate"	]
[ "aggr",	"min",	"command aggr.min(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:any_1] ",	"AGGRmin3;",	""	]
[ "aggr",	"min",	"command aggr.min(b:bat[:any_2]):any_2 ",	"ALGminany;",	"Return the lowest tail value or nil."	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:bte] ",	"AGGRprod3_bte;",	"Grouped tail product on bte"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRprod3_dbl;",	"Grouped tail product on dbl"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRprod3_dbl;",	"Grouped tail product on flt"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:flt] ",	"AGGRprod3_flt;",	"Grouped tail product on flt"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:hge] ",	"AGGRprod3_hge;",	"Grouped tail product on bte"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:hge],g:bat[:oid],e:bat[:any_1]):bat[:hge] ",	"AGGRprod3_hge;",	"Grouped tail product on hge"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:hge] ",	"AGGRprod3_hge;",	"Grouped tail product on int"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:hge] ",	"AGGRprod3_hge;",	"Grouped tail product on lng"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:hge] ",	"AGGRprod3_hge;",	"Grouped tail product on sht"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:int] ",	"AGGRprod3_int;",	"Grouped tail product on bte"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:int] ",	"AGGRprod3_int;",	"Grouped tail product on int"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:int] ",	"AGGRprod3_int;",	"Grouped tail product on sht"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:lng] ",	"AGGRprod3_lng;",	"Grouped tail product on bte"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:lng] ",	"AGGRprod3_lng;",	"Grouped tail product on int"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:lng] ",	"AGGRprod3_lng;",	"Grouped tail product on lng"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:lng] ",	"AGGRprod3_lng;",	"Grouped tail product on sht"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:sht] ",	"AGGRprod3_sht;",	"Grouped tail product on bte"	]
[ "aggr",	"prod",	"command aggr.prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:sht] ",	"AGGRprod3_sht;",	"Grouped tail product on sht"	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):bte ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte]):sht ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):bte ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):sht ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid]):bte ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid]):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid]):sht ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):bte ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):sht ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:dbl]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:dbl],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:dbl],s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:dbl],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt]):flt ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt],nil_if_empty:bit):flt ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt],s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt],s:bat[:oid]):flt ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:flt],s:bat[:oid],nil_if_empty:bit):flt ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge],nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge],s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge],s:bat[:oid]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:hge],s:bat[:oid],nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int]):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],s:bat[:oid]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],s:bat[:oid]):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],s:bat[:oid]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng],nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng],nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng],s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng],s:bat[:oid]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng],s:bat[:oid]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht]):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht]):sht ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],nil_if_empty:bit):sht ",	"CMDBATprod;",	"Calculate aggregate product of B."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],s:bat[:oid]):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],s:bat[:oid]):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],s:bat[:oid]):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],s:bat[:oid]):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],s:bat[:oid]):sht ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):hge ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):int ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):lng ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"prod",	"pattern aggr.prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):sht ",	"CMDBATprod;",	"Calculate aggregate product of B with candidate list."	]
[ "aggr",	"quantile",	"function aggr.quantile(b:bat[:any_1],q:bat[:dbl]):any_1;",	"",	""	]
[ "aggr",	"quantile",	"command aggr.quantile(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],q:bat[:dbl]):bat[:any_1] ",	"AGGRquantile3;",	"Grouped quantile aggregate"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on bte"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on dbl"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on flt"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:hge],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on hge"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on int"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on lng"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdev3_dbl;",	"Grouped tail standard deviation (sample/non-biased) on sht"	]
[ "aggr",	"stdev",	"command aggr.stdev(b:bat[:any_2]):dbl ",	"ALGstdev;",	"Gives the standard deviation of all tail values"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on bte"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on dbl"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on flt"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:hge],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on hge"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on int"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on lng"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRstdevp3_dbl;",	"Grouped tail standard deviation (population/biased) on sht"	]
[ "aggr",	"stdevp",	"command aggr.stdevp(b:bat[:any_2]):dbl ",	"ALGstdevp;",	"Gives the standard deviation of all tail values"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:hge],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1_dbl;",	"Grouped average aggregate"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:hge],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubavg1cand_dbl;",	"Grouped average aggregate with candidates list"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:hge],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2_dbl;",	"Grouped average aggregate, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:hge],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subavg",	"command aggr.subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_0:bat[:dbl],X_1:bat[:lng]) ",	"AGGRsubavg2cand_dbl;",	"Grouped average aggregate with candidates list, also returns count"	]
[ "aggr",	"subcorr",	"function aggr.subcorr(e1:bat[:bte],e2:bat[:bte],g:bat[:oid],e:bat[:any_2],f:bit):bat[:bte];",	"",	""	]
[ "aggr",	"subcorr",	"function aggr.subcorr(e1:bat[:dbl],e2:bat[:dbl],g:bat[:oid],e:bat[:any_2],f:bit):bat[:dbl];",	"",	""	]
[ "aggr",	"subcorr",	"function aggr.subcorr(e1:bat[:flt],e2:bat[:flt],g:bat[:oid],e:bat[:any_2],f:bit):bat[:flt];",	"",	""	]
[ "aggr",	"subcorr",	"function aggr.subcorr(e1:bat[:hge],e2:bat[:hge],g:bat[:oid],e:bat[:any_2],f:bit):bat[:hge];",	"",	""	]
[ "aggr",	"subcorr",	"function aggr.subcorr(e1:bat[:int],e2:bat[:int],g:bat[:oid],e:bat[:any_2],f:bit):bat[:int];",	"",	""	]
[ "aggr",	"subcorr",	"function aggr.subcorr(e1:bat[:lng],e2:bat[:lng],g:bat[:oid],e:bat[:any_2],f:bit):bat[:lng];",	"",	""	]
[ "aggr",	"subcorr",	"function aggr.subcorr(e1:bat[:sht],e2:bat[:sht],g:bat[:oid],e:bat[:any_2],f:bit):bat[:sht];",	"",	""	]
[ "aggr",	"subcount",	"command aggr.subcount(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:lng] ",	"AGGRsubcount;",	"Grouped count aggregate"	]
[ "aggr",	"subcount",	"command aggr.subcount(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:lng] ",	"AGGRsubcountcand;",	"Grouped count aggregate with candidates list"	]
[ "aggr",	"subcovar",	"function aggr.subcovar(e1:bat[:bte],e2:bat[:bte],g:bat[:oid],e:bat[:any_2],f:bit):bat[:bte];",	"",	""	]
[ "aggr",	"subcovar",	"function aggr.subcovar(e1:bat[:dbl],e2:bat[:dbl],g:bat[:oid],e:bat[:any_2],f:bit):bat[:dbl];",	"",	""	]
[ "aggr",	"subcovar",	"function aggr.subcovar(e1:bat[:flt],e2:bat[:flt],g:bat[:oid],e:bat[:any_2],f:bit):bat[:flt];",	"",	""	]
[ "aggr",	"subcovar",	"function aggr.subcovar(e1:bat[:hge],e2:bat[:hge],g:bat[:oid],e:bat[:any_2],f:bit):bat[:hge];",	"",	""	]
[ "aggr",	"subcovar",	"function aggr.subcovar(e1:bat[:int],e2:bat[:int],g:bat[:oid],e:bat[:any_2],f:bit):bat[:int];",	"",	""	]
[ "aggr",	"subcovar",	"function aggr.subcovar(e1:bat[:lng],e2:bat[:lng],g:bat[:oid],e:bat[:any_2],f:bit):bat[:lng];",	"",	""	]
[ "aggr",	"subcovar",	"function aggr.subcovar(e1:bat[:sht],e2:bat[:sht],g:bat[:oid],e:bat[:any_2],f:bit):bat[:sht];",	"",	""	]
[ "aggr",	"subjsonaggr",	"command aggr.subjsonaggr(val:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit):bat[:str] ",	"JSONsubjson;",	"Grouped aggregation of values."	]
[ "aggr",	"subjsonaggr",	"command aggr.subjsonaggr(val:bat[:str],g:bat[:oid],e:bat[:any_1],skip_nils:bit):bat[:str] ",	"JSONsubjson;",	"Grouped aggregation of values."	]
[ "aggr",	"subjsonaggr",	"command aggr.subjsonaggr(val:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit):bat[:str] ",	"JSONsubjsoncand;",	"Grouped aggregation of values with candidates list."	]
[ "aggr",	"subjsonaggr",	"command aggr.subjsonaggr(val:bat[:str],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit):bat[:str] ",	"JSONsubjsoncand;",	"Grouped aggregation of values with candidates list."	]
[ "aggr",	"submax",	"command aggr.submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:oid] ",	"AGGRsubmax;",	"Grouped maximum aggregate"	]
[ "aggr",	"submax",	"command aggr.submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:any_1] ",	"AGGRsubmax_val;",	"Grouped maximum aggregate"	]
[ "aggr",	"submax",	"command aggr.submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:oid] ",	"AGGRsubmaxcand;",	"Grouped maximum aggregate with candidates list"	]
[ "aggr",	"submax",	"command aggr.submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:any_1] ",	"AGGRsubmaxcand_val;",	"Grouped maximum aggregate with candidates list"	]
[ "aggr",	"submedian",	"command aggr.submedian(b:bat[:any_1],skip_nils:bit):bat[:any_1] ",	"AGGRmedian;",	"Median aggregate"	]
[ "aggr",	"submedian",	"command aggr.submedian(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:any_1] ",	"AGGRsubmedian;",	"Grouped median aggregate"	]
[ "aggr",	"submedian",	"command aggr.submedian(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:any_1] ",	"AGGRsubmediancand;",	"Grouped median aggregate with candidate list"	]
[ "aggr",	"submin",	"command aggr.submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:oid] ",	"AGGRsubmin;",	"Grouped minimum aggregate"	]
[ "aggr",	"submin",	"command aggr.submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:any_1] ",	"AGGRsubmin_val;",	"Grouped minimum aggregate"	]
[ "aggr",	"submin",	"command aggr.submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:oid] ",	"AGGRsubmincand;",	"Grouped minimum aggregate with candidates list"	]
[ "aggr",	"submin",	"command aggr.submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:any_1] ",	"AGGRsubmincand_val;",	"Grouped minimum aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:bte] ",	"AGGRsubprod_bte;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubprod_dbl;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubprod_dbl;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:flt] ",	"AGGRsubprod_flt;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubprod_hge;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:hge],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubprod_hge;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubprod_hge;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubprod_hge;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubprod_hge;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubprod_int;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubprod_int;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubprod_int;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubprod_lng;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubprod_lng;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubprod_lng;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubprod_lng;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:sht] ",	"AGGRsubprod_sht;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:sht] ",	"AGGRsubprod_sht;",	"Grouped product aggregate"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:bte] ",	"AGGRsubprodcand_bte;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubprodcand_dbl;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubprodcand_dbl;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:flt] ",	"AGGRsubprodcand_flt;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubprodcand_hge;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:hge],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubprodcand_hge;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubprodcand_hge;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubprodcand_hge;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubprodcand_hge;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubprodcand_int;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubprodcand_int;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubprodcand_int;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubprodcand_lng;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubprodcand_lng;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubprodcand_lng;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubprodcand_lng;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:sht] ",	"AGGRsubprodcand_sht;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subprod",	"command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:sht] ",	"AGGRsubprodcand_sht;",	"Grouped product aggregate with candidates list"	]
[ "aggr",	"subquantile",	"command aggr.subquantile(b:bat[:any_1],q:bat[:dbl],skip_nils:bit):bat[:any_1] ",	"AGGRquantile;",	"Quantile aggregate"	]
[ "aggr",	"subquantile",	"command aggr.subquantile(b:bat[:any_1],q:bat[:dbl],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:any_1] ",	"AGGRsubquantile;",	"Grouped quantile aggregate"	]
[ "aggr",	"subquantile",	"command aggr.subquantile(b:bat[:any_1],q:bat[:dbl],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:any_1] ",	"AGGRsubquantilecand;",	"Grouped median quantile with candidate list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:hge],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdev_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:hge],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdev",	"command aggr.substdev(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevcand_dbl;",	"Grouped standard deviation (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:hge],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevp_dbl;",	"Grouped standard deviation (population/biased) aggregate"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:hge],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"substdevp",	"command aggr.substdevp(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubstdevpcand_dbl;",	"Grouped standard deviation (population/biased) aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:bte] ",	"AGGRsubsum_bte;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubsum_dbl;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubsum_dbl;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:flt] ",	"AGGRsubsum_flt;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubsum_hge;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:hge],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubsum_hge;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubsum_hge;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubsum_hge;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubsum_hge;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubsum_int;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubsum_int;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubsum_int;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubsum_lng;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubsum_lng;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubsum_lng;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubsum_lng;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:sht] ",	"AGGRsubsum_sht;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:sht] ",	"AGGRsubsum_sht;",	"Grouped sum aggregate"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:bte] ",	"AGGRsubsumcand_bte;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubsumcand_dbl;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubsumcand_dbl;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:flt] ",	"AGGRsubsumcand_flt;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubsumcand_hge;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:hge],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubsumcand_hge;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubsumcand_hge;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubsumcand_hge;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:hge] ",	"AGGRsubsumcand_hge;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubsumcand_int;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubsumcand_int;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] ",	"AGGRsubsumcand_int;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubsumcand_lng;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubsumcand_lng;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubsumcand_lng;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] ",	"AGGRsubsumcand_lng;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:sht] ",	"AGGRsubsumcand_sht;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subsum",	"command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:sht] ",	"AGGRsubsumcand_sht;",	"Grouped sum aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:hge],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariance_dbl;",	"Grouped variance (sample/non-biased) aggregate"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:hge],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariance",	"command aggr.subvariance(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancecand_dbl;",	"Grouped variance (sample/non-biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:hge],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancep_dbl;",	"Grouped variance (population/biased) aggregate"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:hge],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"subvariancep",	"command aggr.subvariancep(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] ",	"AGGRsubvariancepcand_dbl;",	"Grouped variance (population/biased) aggregate with candidates list"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:bte] ",	"AGGRsum3_bte;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on dbl"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on flt"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on int"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on lng"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRsum3_dbl;",	"Grouped tail sum on sht"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:flt] ",	"AGGRsum3_flt;",	"Grouped tail sum on flt"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:hge] ",	"AGGRsum3_hge;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:hge],g:bat[:oid],e:bat[:any_1]):bat[:hge] ",	"AGGRsum3_hge;",	"Grouped tail sum on hge"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:hge] ",	"AGGRsum3_hge;",	"Grouped tail sum on int"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:hge] ",	"AGGRsum3_hge;",	"Grouped tail sum on lng"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:hge] ",	"AGGRsum3_hge;",	"Grouped tail sum on sht"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:int] ",	"AGGRsum3_int;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:int] ",	"AGGRsum3_int;",	"Grouped tail sum on int"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:int] ",	"AGGRsum3_int;",	"Grouped tail sum on sht"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:lng] ",	"AGGRsum3_lng;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:lng] ",	"AGGRsum3_lng;",	"Grouped tail sum on int"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:lng] ",	"AGGRsum3_lng;",	"Grouped tail sum on lng"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:lng] ",	"AGGRsum3_lng;",	"Grouped tail sum on sht"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:sht] ",	"AGGRsum3_sht;",	"Grouped tail sum on bte"	]
[ "aggr",	"sum",	"command aggr.sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:sht] ",	"AGGRsum3_sht;",	"Grouped tail sum on sht"	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):bte ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte]):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):bte ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid]):bte ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid]):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):bte ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:dbl]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:dbl],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:dbl],s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:dbl],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt]):flt ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt],nil_if_empty:bit):flt ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt],s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt],s:bat[:oid]):flt ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:flt],s:bat[:oid],nil_if_empty:bit):flt ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge],nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge],s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge],s:bat[:oid]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:hge],s:bat[:oid],nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],s:bat[:oid]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],s:bat[:oid]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],s:bat[:oid]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng],nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng],nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng],s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng],s:bat[:oid]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng],s:bat[:oid]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht]):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],nil_if_empty:bit):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],s:bat[:oid]):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],s:bat[:oid]):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],s:bat[:oid]):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],s:bat[:oid]):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],s:bat[:oid]):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):dbl ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):hge ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):int ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):lng ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"sum",	"pattern aggr.sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):sht ",	"CMDBATsum;",	"Calculate aggregate sum of B with candidate list."	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on bte"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on dbl"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on flt"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:hge],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on hge"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on int"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on lng"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariance3_dbl;",	"Grouped tail variance (sample/non-biased) on sht"	]
[ "aggr",	"variance",	"command aggr.variance(b:bat[:any_2]):dbl ",	"ALGvariance;",	"Gives the variance of all tail values"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on bte"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on dbl"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on flt"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:hge],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on hge"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on int"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on lng"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] ",	"AGGRvariancep3_dbl;",	"Grouped tail variance (population/biased) on sht"	]
[ "aggr",	"variancep",	"command aggr.variancep(b:bat[:any_2]):dbl ",	"ALGvariancep;",	"Gives the variance of all tail values"	]
[ "alarm",	"ctime",	"command alarm.ctime():str ",	"ALARMctime;",	"Return the current time as a C-time string."	]
[ "alarm",	"epilogue",	"command alarm.epilogue():void ",	"ALARMepilogue;",	"Finalize alarm module."	]
[ "alarm",	"epoch",	"command alarm.epoch():int ",	"ALARMepoch;",	"Return the current time as UNIX epoch."	]
[ "alarm",	"prelude",	"command alarm.prelude():void ",	"ALARMprelude;",	"Initialize alarm module."	]
[ "alarm",	"sleep",	"command alarm.sleep(secs:int):void ",	"ALARMsleep;",	"Sleep a few seconds"	]
[ "alarm",	"time",	"command alarm.time():int ",	"ALARMtime;",	"Return time in milliseconds."	]
[ "alarm",	"usec",	"command alarm.usec():lng ",	"ALARMusec;",	"Return time in microseconds."	]
[ "algebra",	"copy",	"command algebra.copy(b:bat[:any_1]):bat[:any_1] ",	"ALGcopy;",	"Returns physical copy of a BAT."	]
[ "algebra",	"crossproduct",	"command algebra.crossproduct(left:bat[:any_1],right:bat[:any_2]) (l:bat[:oid],r:bat[:oid]) ",	"ALGcrossproduct2;",	"Returns 2 columns with all BUNs, consisting of the head-oids\n\t  from 'left' and 'right' for which there are BUNs in 'left'\n\t  and 'right' with equal tails"	]
[ "algebra",	"exist",	"command algebra.exist(b:bat[:any_1],val:any_1):bit ",	"ALGexist;",	"Returns whether 'val' occurs in b."	]
[ "algebra",	"fetch",	"command algebra.fetch(b:bat[:any_1],x:oid):any_1 ",	"ALGfetchoid;",	"Returns the value of the BUN at x-th position with 0 <= x < b.count"	]
[ "algebra",	"find",	"command algebra.find(b:bat[:any_1],t:any_1):oid ",	"ALGfind;",	"Returns the index position of a value.  If no such BUN exists return OID-nil."	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any],n:lng,asc:bit,distinct:bit) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ALGfirstn;",	"Calculate first N values of B"	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any],n:lng,asc:bit,distinct:bit):bat[:oid] ",	"ALGfirstn;",	"Calculate first N values of B"	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any],s:bat[:oid],g:bat[:oid],n:lng,asc:bit,distinct:bit) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ALGfirstn;",	"Calculate first N values of B with candidate list S"	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any],s:bat[:oid],g:bat[:oid],n:lng,asc:bit,distinct:bit):bat[:oid] ",	"ALGfirstn;",	"Calculate first N values of B with candidate list S"	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any],s:bat[:oid],n:lng,asc:bit,distinct:bit) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ALGfirstn;",	"Calculate first N values of B with candidate list S"	]
[ "algebra",	"firstn",	"pattern algebra.firstn(b:bat[:any],s:bat[:oid],n:lng,asc:bit,distinct:bit):bat[:oid] ",	"ALGfirstn;",	"Calculate first N values of B with candidate list S"	]
[ "algebra",	"groupby",	"command algebra.groupby(gids:bat[:oid],cnts:bat[:lng]):bat[:oid] ",	"ALGgroupby;",	"Produces a new BAT with groups identified by the head column. The result contains tail times the head value, ie the tail contains the result group sizes."	]
[ "algebra",	"ilike",	"command algebra.ilike(s:str,pat:str):bit ",	"PCREilike2;",	""	]
[ "algebra",	"ilike",	"command algebra.ilike(s:str,pat:str,esc:str):bit ",	"PCREilike3;",	""	]
[ "algebra",	"ilikesubjoin",	"command algebra.ilikesubjoin(l:bat[:str],r:bat[:str],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ILIKEsubjoin1;",	""	]
[ "algebra",	"ilikesubjoin",	"command algebra.ilikesubjoin(l:bat[:str],r:bat[:str],esc:str,sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ILIKEsubjoin;",	"Join the string bat L with the pattern bat R\nwith optional candidate lists SL and SR using pattern escape string ESC\nand doing a case insensitive match.\nThe result is two aligned bats with oids of matching rows."	]
[ "algebra",	"ilikesubselect",	"command algebra.ilikesubselect(b:bat[:str],cand:bat[:oid],pat:str,esc:str,anti:bit):bat[:oid] ",	"PCRElikesubselect1;",	""	]
[ "algebra",	"ilikesubselect",	"command algebra.ilikesubselect(b:bat[:str],cand:bat[:oid],pat:str,anti:bit):bat[:oid] ",	"PCRElikesubselect4;",	""	]
[ "algebra",	"like",	"command algebra.like(s:str,pat:str):bit ",	"PCRElike2;",	""	]
[ "algebra",	"like",	"command algebra.like(s:str,pat:str,esc:str):bit ",	"PCRElike3;",	""	]
[ "algebra",	"likesubjoin",	"command algebra.likesubjoin(l:bat[:str],r:bat[:str],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"LIKEsubjoin1;",	""	]
[ "algebra",	"likesubjoin",	"command algebra.likesubjoin(l:bat[:str],r:bat[:str],esc:str,sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"LIKEsubjoin;",	"Join the string bat L with the pattern bat R\nwith optional candidate lists SL and SR using pattern escape string ESC\nand doing a case sensitive match.\nThe result is two aligned bats with oids of matching rows."	]
[ "algebra",	"likesubselect",	"command algebra.likesubselect(b:bat[:str],s:bat[:oid],pat:str,esc:str,caseignore:bit,anti:bit):bat[:oid] ",	"PCRElikesubselect2;",	"Select all head values of the first input BAT for which the\n\ttail value is \"like\" the given (SQL-style) pattern and for\n\twhich the head value occurs in the tail of the second input\n\tBAT.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the\n\trelationship holds.  The output BAT is sorted on the tail value."	]
[ "algebra",	"likesubselect",	"command algebra.likesubselect(b:bat[:str],cand:bat[:oid],pat:str,esc:str,anti:bit):bat[:oid] ",	"PCRElikesubselect3;",	""	]
[ "algebra",	"likesubselect",	"command algebra.likesubselect(b:bat[:str],cand:bat[:oid],pat:str,anti:bit):bat[:oid] ",	"PCRElikesubselect5;",	""	]
[ "algebra",	"not_ilike",	"command algebra.not_ilike(s:str,pat:str):bit ",	"PCREnotilike2;",	""	]
[ "algebra",	"not_ilike",	"command algebra.not_ilike(s:str,pat:str,esc:str):bit ",	"PCREnotilike3;",	""	]
[ "algebra",	"not_like",	"command algebra.not_like(s:str,pat:str):bit ",	"PCREnotlike2;",	""	]
[ "algebra",	"not_like",	"command algebra.not_like(s:str,pat:str,esc:str):bit ",	"PCREnotlike3;",	""	]
[ "algebra",	"orderidx",	"command algebra.orderidx(bv:bat[:any_1],stable:bit):bat[:any_1] ",	"OIDXorderidx;",	"Create an order index"	]
[ "algebra",	"project",	"pattern algebra.project(b:bat[:any_1],v:any_3):bat[:any_3] ",	"ALGprojecttail;",	"Fill the tail with a constant"	]
[ "algebra",	"projection",	"command algebra.projection(left:bat[:oid],right:bat[:any_3]):bat[:any_3] ",	"ALGprojection;",	"Project left input onto right input."	]
[ "algebra",	"projectionpath",	"pattern algebra.projectionpath(l:bat[:any]...):bat[:any] ",	"ALGprojectionpath;",	"Routine to handle join paths.  The type analysis is rather tricky."	]
[ "algebra",	"reuse",	"command algebra.reuse(b:bat[:any_1]):bat[:any_1] ",	"ALGreuse;",	"Reuse a temporary BAT if you can. Otherwise,\n\tallocate enough storage to accept result of an\n \toperation (not involving the heap)"	]
[ "algebra",	"selectNotNil",	"command algebra.selectNotNil(b:bat[:any_2]):bat[:any_2] ",	"ALGselectNotNil;",	"Select all not-nil values"	]
[ "algebra",	"slice",	"command algebra.slice(b:bat[:any_1],x:lng,y:lng):bat[:any_1] ",	"ALGslice;",	"Return the slice with the BUNs at position x till y."	]
[ "algebra",	"slice",	"command algebra.slice(b:bat[:any_1],x:int,y:int):bat[:any_1] ",	"ALGslice_int;",	"Return the slice with the BUNs at position x till y."	]
[ "algebra",	"slice",	"command algebra.slice(b:bat[:any_1],x:lng,y:lng):bat[:any_1] ",	"ALGslice_lng;",	"Return the slice with the BUNs at position x till y."	]
[ "algebra",	"slice",	"command algebra.slice(b:bat[:any_1],x:oid,y:oid):bat[:any_1] ",	"ALGslice_oid;",	"Return the slice based on head oid x till y (exclusive)."	]
[ "algebra",	"subantijoin",	"function algebra.subantijoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]);",	"",	""	]
[ "algebra",	"subbandjoin",	"command algebra.subbandjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],c1:any_1,c2:any_1,li:bit,hi:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ALGsubbandjoin;",	"Band join: values in l and r match if r - c1 <[=] l <[=] r + c2"	]
[ "algebra",	"subdiff",	"command algebra.subdiff(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng):bat[:oid] ",	"ALGsubdiff;",	"Difference of l and r with candidate lists"	]
[ "algebra",	"subinter",	"command algebra.subinter(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng):bat[:oid] ",	"ALGsubinter;",	"Intersection of l and r with candidate lists (i.e. half of semi-join)"	]
[ "algebra",	"subjoin",	"command algebra.subjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ALGsubjoin;",	"Join"	]
[ "algebra",	"subleftjoin",	"command algebra.subleftjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ALGsubleftjoin;",	"Left join with candidate lists"	]
[ "algebra",	"subouterjoin",	"command algebra.subouterjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ALGsubouterjoin;",	"Left outer join with candidate lists"	]
[ "algebra",	"subrangejoin",	"command algebra.subrangejoin(l:bat[:any_1],r1:bat[:any_1],r2:bat[:any_1],sl:bat[:oid],sr:bat[:oid],li:bit,hi:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ALGsubrangejoin;",	"Range join: values in l and r1/r2 match if r1 <[=] l <[=] r2"	]
[ "algebra",	"subselect",	"command algebra.subselect(b:bat[:any_1],low:any_1,high:any_1,li:bit,hi:bit,anti:bit):bat[:oid] ",	"ALGsubselect1;",	"Select all head values for which the tail value is in range.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the tail value\n\tis between the values low and high (inclusive if li respectively\n\thi is set).  The output BAT is sorted on the tail value.  If low\n\tor high is nil, the boundary is not considered (effectively - and\n\t+ infinity).  If anti is set, the result is the complement.  Nil\n\tvalues in the tail are never matched, unless low=nil, high=nil,\n\tli=1, hi=1, anti=0.  All non-nil values are returned if low=nil,\n\thigh=nil, and li, hi are not both 1, or anti=1.\n\tNote that the output is suitable as second input for the other\n\tversion of this function."	]
[ "algebra",	"subselect",	"command algebra.subselect(b:bat[:any_1],s:bat[:oid],low:any_1,high:any_1,li:bit,hi:bit,anti:bit):bat[:oid] ",	"ALGsubselect2;",	"Select all head values of the first input BAT for which the tail value\n\tis in range and for which the head value occurs in the tail of the\n\tsecond input BAT.\n\tThe first input is a dense-headed BAT, the second input is a\n\tdense-headed BAT with sorted tail, output is a dense-headed BAT\n\twith in the tail the head value of the input BAT for which the\n\ttail value is between the values low and high (inclusive if li\n\trespectively hi is set).  The output BAT is sorted on the tail\n\tvalue.  If low or high is nil, the boundary is not considered\n\t(effectively - and + infinity).  If anti is set, the result is the\n\tcomplement.  Nil values in the tail are never matched, unless\n\tlow=nil, high=nil, li=1, hi=1, anti=0.  All non-nil values are\n\treturned if low=nil, high=nil, and li, hi are not both 1, or anti=1.\n\tNote that the output is suitable as second input for this\n\tfunction."	]
[ "algebra",	"subsemijoin",	"command algebra.subsemijoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ALGsubsemijoin;",	"Semi join with candidate lists"	]
[ "algebra",	"subslice",	"command algebra.subslice(b:bat[:any_1],x:lng,y:lng):bat[:oid] ",	"ALGsubslice_lng;",	"Return the oids of the slice with the BUNs at position x till y."	]
[ "algebra",	"subsort",	"command algebra.subsort(b:bat[:any_1],reverse:bit,stable:bit):bat[:any_1] ",	"ALGsubsort11;",	"Returns a copy of the BAT sorted on tail values.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"subsort",	"command algebra.subsort(b:bat[:any_1],reverse:bit,stable:bit) (X_0:bat[:any_1],X_1:bat[:oid]) ",	"ALGsubsort12;",	"Returns a copy of the BAT sorted on tail values and a BAT that\n         specifies how the input was reordered.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"subsort",	"command algebra.subsort(b:bat[:any_1],reverse:bit,stable:bit) (X_0:bat[:any_1],X_1:bat[:oid],X_2:bat[:oid]) ",	"ALGsubsort13;",	"Returns a copy of the BAT sorted on tail values, a BAT that specifies\n         how the input was reordered, and a BAT with group information.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"subsort",	"command algebra.subsort(b:bat[:any_1],o:bat[:oid],reverse:bit,stable:bit):bat[:any_1] ",	"ALGsubsort21;",	"Returns a copy of the BAT sorted on tail values.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"subsort",	"command algebra.subsort(b:bat[:any_1],o:bat[:oid],reverse:bit,stable:bit) (X_0:bat[:any_1],X_1:bat[:oid]) ",	"ALGsubsort22;",	"Returns a copy of the BAT sorted on tail values and a BAT that\n         specifies how the input was reordered.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"subsort",	"command algebra.subsort(b:bat[:any_1],o:bat[:oid],reverse:bit,stable:bit) (X_0:bat[:any_1],X_1:bat[:oid],X_2:bat[:oid]) ",	"ALGsubsort23;",	"Returns a copy of the BAT sorted on tail values, a BAT that specifies\n         how the input was reordered, and a BAT with group information.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"subsort",	"command algebra.subsort(b:bat[:any_1],o:bat[:oid],g:bat[:oid],reverse:bit,stable:bit):bat[:any_1] ",	"ALGsubsort31;",	"Returns a copy of the BAT sorted on tail values.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"subsort",	"command algebra.subsort(b:bat[:any_1],o:bat[:oid],g:bat[:oid],reverse:bit,stable:bit) (X_0:bat[:any_1],X_1:bat[:oid]) ",	"ALGsubsort32;",	"Returns a copy of the BAT sorted on tail values and a BAT that\n         specifies how the input was reordered.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"subsort",	"command algebra.subsort(b:bat[:any_1],o:bat[:oid],g:bat[:oid],reverse:bit,stable:bit) (X_0:bat[:any_1],X_1:bat[:oid],X_2:bat[:oid]) ",	"ALGsubsort33;",	"Returns a copy of the BAT sorted on tail values, a BAT that specifies\n         how the input was reordered, and a BAT with group information.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set."	]
[ "algebra",	"subthetajoin",	"command algebra.subthetajoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],op:int,nil_matches:bit,estimate:lng) (X_0:bat[:oid],X_1:bat[:oid]) ",	"ALGsubthetajoin;",	"Theta join with candidate lists"	]
[ "algebra",	"subunique",	"command algebra.subunique(b:bat[:any_1]):bat[:oid] ",	"ALGsubunique1;",	"Select all unique values from the tail of the input.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with\n\tin the tail the head value of the input BAT that was selected.\n\tThe output BAT is sorted on the tail value."	]
[ "algebra",	"subunique",	"command algebra.subunique(b:bat[:any_1],s:bat[:oid]):bat[:oid] ",	"ALGsubunique2;",	"Select all unique values from the tail of the first input.\n\tInput is a dense-headed BAT, the second input is a\n\tdense-headed BAT with sorted tail, output is a dense-headed\n\tBAT with in the tail the head value of the input BAT that was\n\tselected.  The output BAT is sorted on the tail value.  The\n\tsecond input BAT is a list of candidates."	]
[ "algebra",	"thetasubselect",	"command algebra.thetasubselect(b:bat[:any_1],val:any_1,op:str):bat[:oid] ",	"ALGthetasubselect1;",	"Select all head values for which the tail value obeys the relation\n\tvalue OP VAL.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the\n\trelationship holds.  The output BAT is sorted on the tail value."	]
[ "algebra",	"thetasubselect",	"command algebra.thetasubselect(b:bat[:any_1],s:bat[:oid],val:any_1,op:str):bat[:oid] ",	"ALGthetasubselect2;",	"Select all head values of the first input BAT for which the tail value\n\tobeys the relation value OP VAL and for which the head value occurs in\n\tthe tail of the second input BAT.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the\n\trelationship holds.  The output BAT is sorted on the tail value."	]
[ "bam",	"bam_drop_file",	"pattern bam.bam_drop_file(file_id:lng,dbschema:sht):void ",	"bam_drop_file;",	"Drop alignment tables and header data for the bam file with the given file_id"	]
[ "bam",	"bam_export",	"pattern bam.bam_export(output_path:str):void ",	"bam_exportf;",	"Export results in the bam.export table to a BAM file"	]
[ "bam",	"bam_flag",	"command bam.bam_flag(flag:sht,name:str):bit ",	"bam_flag;",	"Get bam flag by name."	]
[ "bam",	"bam_loader_file",	"pattern bam.bam_loader_file(bam_file:str,dbschema:sht):void ",	"bam_loader_file;",	"Read bam_file and store it in the given dbschema"	]
[ "bam",	"bam_loader_files",	"pattern bam.bam_loader_files(bam_files:str,dbschema:sht):void ",	"bam_loader_files;",	"Read all bam files in the file list stored in the file bam_files (separated by a newline) and store them in the given dbschema"	]
[ "bam",	"bam_loader_repos",	"pattern bam.bam_loader_repos(bam_repos:str,dbschema:sht):void ",	"bam_loader_repos;",	"Read all bam files in the given bam_repos directory (non-recursive) and store them in the given dbschema"	]
[ "bam",	"reverse_qual",	"command bam.reverse_qual(qual:str):str ",	"reverse_qual;",	"Reverse a DNA Quality string."	]
[ "bam",	"reverse_seq",	"command bam.reverse_seq(seq:str):str ",	"reverse_seq;",	"Reverse a DNA sequence."	]
[ "bam",	"sam_export",	"pattern bam.sam_export(output_path:str):void ",	"sam_exportf;",	"Export results in the bam.export table to a SAM file"	]
[ "bam",	"seq_char",	"command bam.seq_char(ref_pos:int,alg_seq:str,alg_pos:int,alg_cigar:str):str ",	"seq_char;",	"Calculate the character in the alignment string (alg_str) that is aligned to position 'ref_pos', conforming to the given cigar string"	]
[ "bam",	"seq_length",	"command bam.seq_length(cigar:str):int ",	"seq_length;",	"Calculate the real length of a DNA sequence, given its CIGAR string."	]
[ "bat",	"append",	"command bat.append(i:bat[:any_1],u:bat[:any_1],force:bit):bat[:any_1] ",	"BKCappend_force_wrap;",	"append the content of u to i"	]
[ "bat",	"append",	"command bat.append(i:bat[:any_1],u:any_1,force:bit):bat[:any_1] ",	"BKCappend_val_force_wrap;",	"append the value u to i"	]
[ "bat",	"append",	"command bat.append(i:bat[:any_1],u:any_1):bat[:any_1] ",	"BKCappend_val_wrap;",	"append the value u to i"	]
[ "bat",	"append",	"command bat.append(i:bat[:any_1],u:bat[:any_1]):bat[:any_1] ",	"BKCappend_wrap;",	"append the content of u to i"	]
[ "bat",	"attach",	"command bat.attach(tt:int,heapfile:str):bat[:any_1] ",	"BKCattach;",	"Returns a new BAT with dense head and tail of the given type and uses\n        the given file to initialize the tail. The file will be owned by the\n        server."	]
[ "bat",	"delete",	"command bat.delete(b:bat[:any_1],h:oid):bat[:any_1] ",	"BKCdelete;",	"Delete BUN indicated by head value, exchanging with last BUN"	]
[ "bat",	"delete",	"command bat.delete(b:bat[:any_1]):bat[:any_1] ",	"BKCdelete_all;",	"Delete all entries."	]
[ "bat",	"delete",	"command bat.delete(b:bat[:any_1],d:bat[:oid]):bat[:any_1] ",	"BKCdelete_multi;",	"Delete multiple BUN, shifting BUNs up"	]
[ "bat",	"densebat",	"command bat.densebat(sz:lng):bat[:oid] ",	"BKCdensebat;",	"Creates a new [void,void] BAT of size 'sz'."	]
[ "bat",	"getAccess",	"command bat.getAccess(b:bat[:any_1]):str ",	"BKCgetAccess;",	"Return the access mode attached to this BAT as a character."	]
[ "bat",	"getCapacity",	"command bat.getCapacity(b:bat[:any_1]):lng ",	"BKCgetCapacity;",	"Returns the current allocation size (in max number of elements) of a BAT."	]
[ "bat",	"getColumnType",	"command bat.getColumnType(b:bat[:any_1]):str ",	"BKCgetColumnType;",	"Returns the type of the tail column of a BAT, as an integer type number."	]
[ "bat",	"getName",	"command bat.getName(b:bat[:any_1]):str ",	"BKCgetBBPname;",	"Gives back the logical name of a BAT."	]
[ "bat",	"getRole",	"command bat.getRole(bid:bat[:any_1]):str ",	"BKCgetRole;",	"Returns the rolename of the head column of a BAT."	]
[ "bat",	"getSequenceBase",	"command bat.getSequenceBase(b:bat[:any_1]):oid ",	"BKCgetSequenceBase;",	"Get the sequence base for the void column of a BAT."	]
[ "bat",	"getSize",	"command bat.getSize(b:bat[:any_1]):lng ",	"BKCgetSize;",	"Calculate the actual size of the BAT descriptor, heaps, hashes and imprint indices in bytes\n         rounded to the memory page size (see bbp.getPageSize())."	]
[ "bat",	"getorderidx",	"pattern bat.getorderidx(bv:bat[:any_1]):bat[:oid] ",	"OIDXgetorderidx;",	"Return the order index if it exists"	]
[ "bat",	"hasorderidx",	"pattern bat.hasorderidx(bv:bat[:any_1]):bit ",	"OIDXhasorderidx;",	"Return true if order index exists"	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:bte]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:dbl]):void ",	"CMDBATimprints;",	"Check for existence or create an imprint index on the BAT."	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:flt]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:hge]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:int]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:lng]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprints",	"command bat.imprints(b:bat[:sht]):void ",	"CMDBATimprints;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:bte]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:dbl]):lng ",	"CMDBATimprintsize;",	"Return the storage size of the imprints index structure."	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:flt]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:hge]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:int]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:lng]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"imprintsize",	"command bat.imprintsize(b:bat[:sht]):lng ",	"CMDBATimprintsize;",	""	]
[ "bat",	"info",	"command bat.info(b:bat[:any_1]) (X_0:bat[:str],X_1:bat[:str]) ",	"BKCinfo;",	"Produce a table containing information about a BAT in [attribute,value] format. \n        It contains all properties of the BAT record. "	]
[ "bat",	"intersectcand",	"command bat.intersectcand(a:bat[:oid],b:bat[:oid]):bat[:oid] ",	"BKCintersectcand;",	"Intersect two candidate lists into one"	]
[ "bat",	"isPersistent",	"command bat.isPersistent(b:bat[:any_1]):bit ",	"BKCisPersistent;",	""	]
[ "bat",	"isSorted",	"command bat.isSorted(b:bat[:any_1]):bit ",	"BKCisSorted;",	"Returns true if BAT values are ordered."	]
[ "bat",	"isSortedReverse",	"command bat.isSortedReverse(b:bat[:any_1]):bit ",	"BKCisSortedReverse;",	"Returns true if BAT values are reversely ordered."	]
[ "bat",	"isSynced",	"command bat.isSynced(b1:bat[:any_1],b2:bat[:any_2]):bit ",	"BKCisSynced;",	"Tests whether two BATs are synced or not. "	]
[ "bat",	"isTransient",	"command bat.isTransient(b:bat[:any_1]):bit ",	"BKCisTransient;",	""	]
[ "bat",	"isaKey",	"command bat.isaKey(b:bat[:any_1]):bit ",	"BKCgetKey;",	"Return whether the column tail values are unique (key)."	]
[ "bat",	"mergecand",	"command bat.mergecand(a:bat[:oid],b:bat[:oid]):bat[:oid] ",	"BKCmergecand;",	"Merge two candidate lists into one"	]
[ "bat",	"mirror",	"command bat.mirror(b:bat[:any_2]):bat[:oid] ",	"BKCmirror;",	"Returns the head-mirror image of a BAT (two head columns)."	]
[ "bat",	"new",	"pattern bat.new(tt:any_1):bat[:any_1] ",	"CMDBATnew;",	""	]
[ "bat",	"new",	"pattern bat.new(tt:any_1,size:int):bat[:any_1] ",	"CMDBATnew;",	""	]
[ "bat",	"new",	"pattern bat.new(tt:any_1,size:int,persist:bit):bat[:any_1] ",	"CMDBATnew;",	""	]
[ "bat",	"new",	"pattern bat.new(tt:any_1,size:lng):bat[:any_1] ",	"CMDBATnew;",	"Creates a new empty transient BAT, with tail-types as indicated."	]
[ "bat",	"new",	"pattern bat.new(tt:any_1,size:lng,persist:bit):bat[:any_1] ",	"CMDBATnew;",	""	]
[ "bat",	"orderidx",	"pattern bat.orderidx(bv:bat[:any_1]):void ",	"OIDXcreate;",	"Introduces the OID index arrangement of ordered values"	]
[ "bat",	"orderidx",	"pattern bat.orderidx(bv:bat[:any_1],pieces:int):void ",	"OIDXcreate;",	"Introduces the OID index arrangement of ordered values"	]
[ "bat",	"orderidx",	"pattern bat.orderidx(bv:bat[:any_1],l:bat[:any_1]...):void ",	"OIDXmerge;",	"Consolidates the OID index arrangement"	]
[ "bat",	"partition",	"pattern bat.partition(b:bat[:any_1],pieces:int,n:int):bat[:any_1] ",	"CMDBATpartition2;",	"Create the n-th slice over the BAT broken into several pieces."	]
[ "bat",	"partition",	"pattern bat.partition(b:bat[:any_1]):bat[:any_1]... ",	"CMDBATpartition;",	"Create a serie of slices over the BAT argument. The BUNs are distributed evenly."	]
[ "bat",	"replace",	"command bat.replace(b:bat[:any_1],rid:bat[:oid],val:bat[:any_1]):bat[:any_1] ",	"BKCbat_inplace;",	"Perform replace for all BUNs of the second BAT into the first."	]
[ "bat",	"replace",	"command bat.replace(b:bat[:any_1],rid:bat[:oid],val:bat[:any_1],force:bit):bat[:any_1] ",	"BKCbat_inplace_force;",	"Perform replace for all BUNs of the second BAT into the first."	]
[ "bat",	"replace",	"command bat.replace(b:bat[:any_1],h:oid,t:any_1):bat[:any_1] ",	"BKCbun_inplace;",	"Replace the tail value of one BUN that has some head value."	]
[ "bat",	"replace",	"command bat.replace(b:bat[:any_1],h:oid,t:any_1,force:bit):bat[:any_1] ",	"BKCbun_inplace_force;",	"Replace the tail value of one BUN that has some head value."	]
[ "bat",	"reuse",	"command bat.reuse(b:bat[:any_1],del:bat[:oid]):bat[:any_1] ",	"BKCreuseBAT;",	"Shuffle the values around to restore a dense representation of buns."	]
[ "bat",	"reuseMap",	"command bat.reuseMap(b:bat[:any_1],del:bat[:oid]):bat[:oid] ",	"BKCreuseBATmap;",	"Derive the oid mapping for reuse BAT based on list of to-be-deleted"	]
[ "bat",	"save",	"command bat.save(nme:bat[:any_1]):void ",	"BKCsave2;",	""	]
[ "bat",	"save",	"command bat.save(nme:str):bit ",	"BKCsave;",	"Save a BAT to storage, if it was loaded and dirty.  \n        Returns whether IO was necessary.  Please realize that \n\tcalling this function violates the atomic commit protocol!!"	]
[ "bat",	"setAccess",	"command bat.setAccess(b:bat[:any_1],mode:str):bat[:any_1] ",	"BKCsetAccess;",	"Try to change the update access priviliges \n\tto this BAT. Mode:\n\t r[ead-only]      - allow only read access.\n\t a[append-only]   - allow reads and update.\n\t w[riteable]      - allow all operations.\n\t BATs are updatable by default. On making a BAT read-only, \n     all subsequent updates fail with an error message.\n\t Returns the BAT itself."	]
[ "bat",	"setColumn",	"command bat.setColumn(b:bat[:any_1],t:str):void ",	"BKCsetColumn;",	"Give a logical name to the tail column of a BAT."	]
[ "bat",	"setHash",	"command bat.setHash(b:bat[:any_1]):bit ",	"BKCsetHash;",	"Create a hash structure on the column"	]
[ "bat",	"setImprints",	"command bat.setImprints(b:bat[:any_1]):bit ",	"BKCsetImprints;",	"Create an imprints structure on the column"	]
[ "bat",	"setKey",	"command bat.setKey(b:bat[:any_1],mode:bit):bat[:any_1] ",	"BKCsetkey;",	"Sets the 'key' property of the tail column to 'mode'. In 'key' mode, \n        the kernel will silently block insertions that cause a duplicate \n        entries in the head column. KNOWN BUG:when 'key' is set to TRUE, this \n\t\tfunction does not automatically eliminate duplicates. "	]
[ "bat",	"setName",	"command bat.setName(b:bat[:any_1],s:str):void ",	"BKCsetName;",	"Give a logical name to a BAT. "	]
[ "bat",	"setPersistent",	"command bat.setPersistent(b:bat[:any_1]):void ",	"BKCsetPersistent;",	"Make the BAT persistent."	]
[ "bat",	"setTransient",	"command bat.setTransient(b:bat[:any_1]):void ",	"BKCsetTransient;",	"Make the BAT transient.  Returns \n\tboolean which indicates if the\nBAT administration has indeed changed."	]
[ "bat",	"single",	"pattern bat.single(val:any_1):bat[:any_1] ",	"CMDBATsingle;",	"Create a BAT with a single elemenet"	]
[ "batalgebra",	"ilike",	"command batalgebra.ilike(s:bat[:str],pat:str):bat[:bit] ",	"BATPCREilike2;",	""	]
[ "batalgebra",	"ilike",	"command batalgebra.ilike(s:bat[:str],pat:str,esc:str):bat[:bit] ",	"BATPCREilike;",	""	]
[ "batalgebra",	"like",	"command batalgebra.like(s:bat[:str],pat:str):bat[:bit] ",	"BATPCRElike2;",	""	]
[ "batalgebra",	"like",	"command batalgebra.like(s:bat[:str],pat:str,esc:str):bat[:bit] ",	"BATPCRElike;",	""	]
[ "batalgebra",	"not_ilike",	"command batalgebra.not_ilike(s:bat[:str],pat:str):bat[:bit] ",	"BATPCREnotilike2;",	""	]
[ "batalgebra",	"not_ilike",	"command batalgebra.not_ilike(s:bat[:str],pat:str,esc:str):bat[:bit] ",	"BATPCREnotilike;",	""	]
[ "batalgebra",	"not_like",	"command batalgebra.not_like(s:bat[:str],pat:str):bat[:bit] ",	"BATPCREnotlike2;",	""	]
[ "batalgebra",	"not_like",	"command batalgebra.not_like(s:bat[:str],pat:str,esc:str):bat[:bit] ",	"BATPCREnotlike;",	""	]
[ "batbam",	"bam_flag",	"command batbam.bam_flag(flags:bat[:sht],name:str):bat[:bit] ",	"bam_flag_bat;",	"Get bat of bam flags by name."	]
[ "batbam",	"reverse_qual",	"command batbam.reverse_qual(seqs:bat[:str]):bat[:str] ",	"reverse_qual_bat;",	"Reverse a bat of DNA Quality strings."	]
[ "batbam",	"reverse_seq",	"command batbam.reverse_seq(seqs:bat[:str]):bat[:str] ",	"reverse_seq_bat;",	"Reverse a bat of DNA sequences."	]
[ "batbam",	"seq_char",	"command batbam.seq_char(ref_pos:int,alg_seq:bat[:str],alg_pos:bat[:int],alg_cigar:bat[:str]):bat[:str] ",	"seq_char_bat;",	"Calculate the character in the alignment string (alg_str) that is aligned to position 'ref_pos', conforming to the given cigar string (bat based version)"	]
[ "batbam",	"seq_length",	"command batbam.seq_length(cigars:bat[:str]):bat[:int] ",	"seq_length_bat;",	"Calculate the real length of a bat of DNA sequences, given their CIGAR string."	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bit],b2:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:date],b2:bat[:date]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:json],b2:bat[:json]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:oid],b2:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:str],b2:bat[:str]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2 with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] ",	"CMDbatNE;",	"Return B1 != B2"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bit],v:bit):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:date],v:date):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:daytime],v:daytime):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:hge],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:oid],v:oid):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:bte):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:dbl):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:flt):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:hge):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:int):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:lng):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:sht):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:str],v:str):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:timestamp],v:timestamp):bat[:bit] ",	"CMDbatNE;",	"Return B != V"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return B != V with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bit,b:bat[:bit]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:date,b:bat[:date]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:daytime,b:bat[:daytime]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:hge,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:oid,b:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:bte]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:dbl]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:flt]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:hge]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:int]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:lng]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:sht]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:str,b:bat[:str]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:timestamp,b:bat[:timestamp]):bat[:bit] ",	"CMDbatNE;",	"Return V != B"	]
[ "batcalc",	"!=",	"pattern batcalc.!=(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatNE;",	"Return V != B with candidates list"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:hge]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:int]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:lng]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:sht]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:hge]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:bte]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:hge]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:int]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:lng]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:sht]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:bte]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:int]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:lng]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:sht]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:bte]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:hge]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:lng]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:sht]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:bte]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:hge]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:int]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:sht]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:bte]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:hge]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:int]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:lng]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B1 % B2 with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:dbl):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:flt):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:hge):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:int):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:lng):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:sht):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:bte):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:dbl):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:flt):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:hge):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:int):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:lng):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:sht):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:bte):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:dbl):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:flt):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:hge):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:hge,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:int):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:lng):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:sht):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:bte):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:dbl):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:flt):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:int):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:lng):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:sht):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:hge],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:bte):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:dbl):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:flt):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:hge):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:hge,s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:int):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:lng):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:sht):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:int],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:bte):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:dbl):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:flt):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:hge):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:hge,s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:int):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:sht):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:lng],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:bte):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:dbl):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:flt):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:hge):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:hge,s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:int):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:lng):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return B % V with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:hge]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:int]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:lng]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:sht]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:bte]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:flt]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:hge]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:int]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:lng]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:sht]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:bte]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:hge]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:int]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:lng]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:sht]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:bte]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:int]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:lng]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:sht]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:hge,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:bte]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:hge]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:int]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:lng]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:sht]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:int,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:bte]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:hge]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:int]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:sht]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:lng,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:bte]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:flt]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:hge]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:int]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:lng]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B, signal error on divide by zero"	]
[ "batcalc",	"%",	"pattern batcalc.%(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMODsignal;",	"Return V % B with candidates list, signal error on divide by zero"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:bte]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:int]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:lng]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:sht]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:bte]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:hge]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:int]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:lng]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:sht]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:bte]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:int]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:lng]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:sht]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:bte]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:int]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:lng]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:sht]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:bte]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:int]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:lng]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:sht]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:bte):bat[:sht] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:flt):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:int):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:lng):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:sht):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:bte):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:flt):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:hge):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:int):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:lng):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:sht):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:flt):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:bte):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:flt):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:int):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:lng):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:sht):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:bte):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:flt):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:int):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:lng):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:sht):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:bte):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:flt):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:int):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:lng):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:sht):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return B * V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:bte]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:int]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:lng]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:sht]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:bte]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:hge]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:int]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:lng]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:sht]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:bte]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:int]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:lng]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:sht]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:bte]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:int]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:lng]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:sht]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:bte]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:flt]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:int]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:lng]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:sht]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatMULenlarge;",	"Return V * B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:hge]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:int]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:lng]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:sht]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:hge]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:bte]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:hge]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:int]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:lng]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:sht]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:hge]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:lng]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:hge]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:hge]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:int]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:lng]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B1 * B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:dbl):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:flt):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:hge):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:int):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:lng):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:sht):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:bte):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:dbl):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:flt):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:hge):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:int):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:lng):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:sht):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:bte):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:dbl):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:flt):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:hge):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:hge,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:int):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:lng):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:sht):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:dbl):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:flt):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:bte):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:dbl):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:flt):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:hge):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:int):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:lng):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:sht):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:dbl):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:flt):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:hge):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:dbl):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:flt):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:hge):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:int):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:lng):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return B * V with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:hge]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:int]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:lng]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:sht]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:bte]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:flt]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:hge]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:int]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:lng]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:sht]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:bte]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:hge]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:int]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:lng]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:sht]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:hge]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:int]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:lng]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:hge]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:flt]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:hge]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:int]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:lng]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B, signal error on overflow"	]
[ "batcalc",	"*",	"pattern batcalc.*(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMULsignal;",	"Return V * B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:str],b2:bat[:str]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of B1 and B2"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of B1 and B2 with candidates list"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:str],v:str):bat[:str] ",	"CMDbatADD;",	"Return concatenation of B and V"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:str],v:str,s:bat[:oid]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of B and V with candidates list"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:str,b:bat[:str]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of V and B"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:str,b:bat[:str],s:bat[:oid]):bat[:str] ",	"CMDbatADD;",	"Return concatenation of V and B with candidates list"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:bte]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:int]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:lng]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:sht]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:bte]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:hge]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:int]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:lng]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:sht]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:bte]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:int]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:lng]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:sht]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:bte]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:int]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:lng]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:sht]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:bte]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:int]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:lng]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:sht]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:bte):bat[:sht] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:flt):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:int):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:lng):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:sht):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:bte):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:flt):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:hge):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:int):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:lng):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:sht):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:flt):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:bte):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:flt):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:int):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:lng):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:sht):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:bte):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:flt):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:int):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:lng):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:sht):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:bte):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:flt):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:int):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:lng):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:sht):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return B + V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:bte]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:int]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:lng]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:sht]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:bte]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:hge]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:int]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:lng]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:sht]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:bte]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:int]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:lng]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:sht]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:bte]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:int]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:lng]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:sht]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:bte]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:flt]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:int]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:lng]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:sht]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatADDenlarge;",	"Return V + B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:hge]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:int]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:lng]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:sht]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:hge]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:bte]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:hge]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:int]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:lng]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:sht]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:hge]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:lng]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:hge]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:hge]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:int]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:lng]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B1 + B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:dbl):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:flt):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:hge):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:int):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:lng):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:sht):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:bte):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:dbl):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:flt):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:hge):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:int):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:lng):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:sht):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:bte):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:dbl):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:flt):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:hge):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:hge,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:int):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:lng):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:sht):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:dbl):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:flt):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:bte):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:dbl):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:flt):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:hge):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:int):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:lng):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:sht):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:dbl):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:flt):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:hge):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:dbl):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:flt):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:hge):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:int):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:lng):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return B + V with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:hge]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:int]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:lng]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:sht]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:bte]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:flt]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:hge]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:int]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:lng]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:sht]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:bte]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:hge]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:int]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:lng]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:sht]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:hge]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:int]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:lng]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:hge]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:flt]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:hge]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:int]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:lng]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B, signal error on overflow"	]
[ "batcalc",	"+",	"pattern batcalc.+(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatADDsignal;",	"Return V + B with candidates list, signal error on overflow"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:bte]):bat[:bte] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:dbl]):bat[:dbl] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:flt]):bat[:flt] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:hge]):bat[:hge] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:int]):bat[:int] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:lng]):bat[:lng] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:sht]):bat[:sht] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat"	]
[ "batcalc",	"++",	"pattern batcalc.++(b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatINCR;",	"Unary increment over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte]):bat[:bte] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl]):bat[:dbl] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt]):bat[:flt] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge]):bat[:hge] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int]):bat[:int] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng]):bat[:lng] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht]):bat[:sht] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatNEG;",	"Unary neg over the tail of the bat with candidates list"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:bte]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:int]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:lng]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:sht]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:bte]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:hge]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:int]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:lng]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:sht]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:bte]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:int]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:lng]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:sht]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:bte]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:int]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:lng]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:sht]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:bte]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:int]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:lng]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:sht]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:bte):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:flt):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:int):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:lng):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:sht):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:bte):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:flt):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:hge):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:int):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:lng):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:sht):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:flt):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:bte):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:flt):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:int):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:lng):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:sht):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:bte):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:flt):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:int):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:lng):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:sht):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:bte):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:flt):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:int):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:lng):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:sht):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return B - V with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:bte]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:int]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:lng]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:sht]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:bte]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:hge]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:int]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:lng]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:sht]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:bte]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:int]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:lng]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:sht]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:bte]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:int]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:lng]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:sht]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:bte]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:flt]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:int]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:lng]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:sht]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatSUBenlarge;",	"Return V - B with candidates list, guarantee no overflow by returning larger type"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:hge]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:int]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:lng]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:sht]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:hge]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:bte]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:hge]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:int]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:lng]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:sht]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:hge]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:lng]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:hge]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:hge]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:int]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:lng]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B1 - B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:dbl):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:flt):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:hge):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:int):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:lng):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:sht):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:bte):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:dbl):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:flt):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:hge):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:int):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:lng):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:sht):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:bte):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:dbl):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:flt):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:hge):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:hge,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:int):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:lng):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:sht):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:dbl):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:flt):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:bte):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:dbl):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:flt):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:hge):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:int):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:lng):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:sht):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:dbl):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:flt):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:hge):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:dbl):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:flt):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:hge):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:int):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:lng):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return B - V with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:hge]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:int]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:lng]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:sht]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:bte]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:flt]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:hge]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:int]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:lng]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:sht]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:bte]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:hge]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:int]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:lng]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:sht]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:hge]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:int]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:lng]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:hge]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:flt]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:hge]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:int]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:lng]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B, signal error on overflow"	]
[ "batcalc",	"-",	"pattern batcalc.-(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatSUBsignal;",	"Return V - B with candidates list, signal error on overflow"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:bte]):bat[:bte] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:dbl]):bat[:dbl] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:flt]):bat[:flt] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:hge]):bat[:hge] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:int]):bat[:int] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:lng]):bat[:lng] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:sht]):bat[:sht] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat"	]
[ "batcalc",	"--",	"pattern batcalc.--(b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatDECR;",	"Unary decrement over the tail of the bat with candidates list"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:hge]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:int]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:lng]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:sht]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:hge]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:bte]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:hge]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:int]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:lng]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:sht]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:hge]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:lng]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:hge]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:hge]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:int]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:lng]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B1 / B2 with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:dbl):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:flt):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:hge):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:int):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:lng):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:sht):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:bte):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:dbl):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:flt):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:hge):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:int):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:lng):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:sht):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:bte):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:dbl):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:flt):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:hge):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:hge,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:int):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:lng):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:sht):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:dbl):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:flt):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:bte):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:dbl):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:flt):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:hge):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:hge,s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:int):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:lng):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:sht):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:dbl):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:flt):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:hge):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:hge,s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:dbl):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:flt):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:hge):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:hge,s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:int):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:lng):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return B / V with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:hge]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:int]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:lng]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:sht]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:bte]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:flt]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:hge]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:int]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:lng]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:sht]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:bte]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:hge]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:int]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:lng]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:sht]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:hge]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:int]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:lng]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:hge]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:flt]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:hge]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:int]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:lng]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B, signal error on overflow"	]
[ "batcalc",	"/",	"pattern batcalc./(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatDIVsignal;",	"Return V / B with candidates list, signal error on overflow"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bit],b2:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:date],b2:bat[:date]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:json],b2:bat[:json]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:oid],b2:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:str],b2:bat[:str]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2 with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] ",	"CMDbatLT;",	"Return B1 < B2"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bit],v:bit):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:date],v:date):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:daytime],v:daytime):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:hge],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:oid],v:oid):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:bte):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:dbl):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:flt):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:hge):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:int):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:lng):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:sht):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:str],v:str):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:timestamp],v:timestamp):bat[:bit] ",	"CMDbatLT;",	"Return B < V"	]
[ "batcalc",	"<",	"pattern batcalc.<(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return B < V with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bit,b:bat[:bit]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:date,b:bat[:date]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:daytime,b:bat[:daytime]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:hge,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:oid,b:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:bte]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:dbl]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:flt]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:hge]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:int]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:lng]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:sht]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:str,b:bat[:str]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:timestamp,b:bat[:timestamp]):bat[:bit] ",	"CMDbatLT;",	"Return V < B"	]
[ "batcalc",	"<",	"pattern batcalc.<(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatLT;",	"Return V < B with candidates list"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte],b2:bat[:hge]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte],b2:bat[:int]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte],b2:bat[:lng]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte],b2:bat[:sht]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int],b2:bat[:hge]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int],b2:bat[:lng]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng],b2:bat[:hge]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht],b2:bat[:hge]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht],b2:bat[:int]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht],b2:bat[:lng]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B1 << B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte],v:hge):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte],v:int):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte],v:lng):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte],v:sht):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int],v:bte):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int],v:hge):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int],v:hge,s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int],v:int):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int],v:lng):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int],v:sht):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng],v:hge):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng],v:hge,s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht],v:hge):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht],v:hge,s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht],v:int):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht],v:lng):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return B << V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte,b:bat[:hge]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte,b:bat[:int]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte,b:bat[:lng]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte,b:bat[:sht]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int,b:bat[:hge]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int,b:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int,b:bat[:int]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int,b:bat[:lng]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng,b:bat[:hge]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng,b:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht,b:bat[:hge]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht,b:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht,b:bat[:int]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht,b:bat[:lng]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B, raise error on out of range second operand"	]
[ "batcalc",	"<<",	"pattern batcalc.<<(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatLSHsignal;",	"Return V << B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bit],b2:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:date],b2:bat[:date]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:json],b2:bat[:json]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:oid],b2:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:str],b2:bat[:str]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2 with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] ",	"CMDbatLE;",	"Return B1 <= B2"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bit],v:bit):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:date],v:date):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:daytime],v:daytime):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:hge],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:oid],v:oid):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:bte):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:dbl):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:flt):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:hge):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:int):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:lng):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:sht):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:str],v:str):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:timestamp],v:timestamp):bat[:bit] ",	"CMDbatLE;",	"Return B <= V"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return B <= V with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bit,b:bat[:bit]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:date,b:bat[:date]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:daytime,b:bat[:daytime]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:hge,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:oid,b:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:bte]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:dbl]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:flt]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:hge]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:int]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:lng]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:sht]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:str,b:bat[:str]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:timestamp,b:bat[:timestamp]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B"	]
[ "batcalc",	"<=",	"pattern batcalc.<=(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatLE;",	"Return V <= B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bit],b2:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:date],b2:bat[:date]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:json],b2:bat[:json]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:oid],b2:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:str],b2:bat[:str]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2 with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] ",	"CMDbatEQ;",	"Return B1 == B2"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bit],v:bit):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:date],v:date):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:daytime],v:daytime):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:hge],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:oid],v:oid):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:bte):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:dbl):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:flt):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:hge):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:int):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:lng):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:sht):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:str],v:str):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:timestamp],v:timestamp):bat[:bit] ",	"CMDbatEQ;",	"Return B == V"	]
[ "batcalc",	"==",	"pattern batcalc.==(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return B == V with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bit,b:bat[:bit]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:date,b:bat[:date]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:daytime,b:bat[:daytime]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:hge,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:oid,b:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:bte]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:dbl]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:flt]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:hge]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:int]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:lng]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:sht]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:str,b:bat[:str]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:timestamp,b:bat[:timestamp]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B"	]
[ "batcalc",	"==",	"pattern batcalc.==(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatEQ;",	"Return V == B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bit],b2:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:date],b2:bat[:date]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:json],b2:bat[:json]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:oid],b2:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:str],b2:bat[:str]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2 with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] ",	"CMDbatGT;",	"Return B1 > B2"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bit],v:bit):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:date],v:date):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:daytime],v:daytime):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:hge],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:oid],v:oid):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:bte):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:dbl):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:flt):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:hge):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:int):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:lng):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:sht):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:str],v:str):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:timestamp],v:timestamp):bat[:bit] ",	"CMDbatGT;",	"Return B > V"	]
[ "batcalc",	">",	"pattern batcalc.>(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return B > V with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bit,b:bat[:bit]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:date,b:bat[:date]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:daytime,b:bat[:daytime]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:hge,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:oid,b:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:bte]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:dbl]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:flt]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:hge]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:int]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:lng]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:sht]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:str,b:bat[:str]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">",	"pattern batcalc.>(v:timestamp,b:bat[:timestamp]):bat[:bit] ",	"CMDbatGT;",	"Return V > B"	]
[ "batcalc",	">",	"pattern batcalc.>(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatGT;",	"Return V > B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bit],b2:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:date],b2:bat[:date]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:json],b2:bat[:json]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:oid],b2:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:str],b2:bat[:str]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2 with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] ",	"CMDbatGE;",	"Return B1 >= B2"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bit],v:bit):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:date],v:date):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:daytime],v:daytime):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:hge],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:oid],v:oid):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:bte):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:dbl):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:flt):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:hge):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:int):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:lng):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:sht):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:str],v:str):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:timestamp],v:timestamp):bat[:bit] ",	"CMDbatGE;",	"Return B >= V"	]
[ "batcalc",	">=",	"pattern batcalc.>=(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return B >= V with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bit,b:bat[:bit]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:date,b:bat[:date]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:daytime,b:bat[:daytime]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:hge,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:oid,b:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:bte]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:dbl]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:flt]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:hge]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:int]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:lng]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:sht]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:str,b:bat[:str]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:timestamp,b:bat[:timestamp]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B"	]
[ "batcalc",	">=",	"pattern batcalc.>=(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] ",	"CMDbatGE;",	"Return V >= B with candidates list"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte],b2:bat[:hge]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte],b2:bat[:int]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte],b2:bat[:lng]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte],b2:bat[:sht]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int],b2:bat[:hge]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int],b2:bat[:lng]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng],b2:bat[:hge]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht],b2:bat[:hge]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht],b2:bat[:int]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht],b2:bat[:lng]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B1 >> B2 with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte],v:hge):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte],v:int):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte],v:lng):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte],v:sht):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int],v:bte):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int],v:hge):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int],v:hge,s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int],v:int):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int],v:lng):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int],v:sht):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng],v:hge):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng],v:hge,s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht],v:hge):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht],v:hge,s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht],v:int):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht],v:lng):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return B >> V with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte,b:bat[:hge]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte,b:bat[:int]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte,b:bat[:lng]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte,b:bat[:sht]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int,b:bat[:hge]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int,b:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int,b:bat[:int]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int,b:bat[:lng]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng,b:bat[:hge]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng,b:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht,b:bat[:hge]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht,b:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht,b:bat[:int]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht,b:bat[:lng]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B, raise error on out of range second operand"	]
[ "batcalc",	">>",	"pattern batcalc.>>(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatRSHsignal;",	"Return V >> B with candidates list, raise error on out of range second operand"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:bte]):bat[:bte] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:dbl]):bat[:dbl] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:flt]):bat[:flt] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:hge]):bat[:hge] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:int]):bat[:int] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:lng]):bat[:lng] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:sht]):bat[:sht] ",	"CMDbatABS;",	"Unary abs over the tail of the bat"	]
[ "batcalc",	"abs",	"pattern batcalc.abs(b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatABS;",	"Unary abs over the tail of the bat with candidates list"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:hge]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:int]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:hge]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:bte]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:hge]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:int]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:lng]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:sht]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:hge]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:lng]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:hge]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:hge]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:int]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B1 + B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:dbl):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:flt):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:hge):bat[:hge] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:int):bat[:int] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:lng):bat[:lng] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:sht):bat[:sht] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:bte):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:dbl):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:flt):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:hge):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:int):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:lng):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:sht):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:bte):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:dbl):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:flt):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:hge):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:hge,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:int):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:lng):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:sht):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:dbl):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:flt):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:bte):bat[:int] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:dbl):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:flt):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:hge):bat[:hge] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:int):bat[:int] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:lng):bat[:lng] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:sht):bat[:int] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:dbl):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:flt):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:hge):bat[:hge] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:dbl):bat[:dbl] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:flt):bat[:flt] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:hge):bat[:hge] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:int):bat[:int] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:lng):bat[:lng] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatADD;",	"Return B + V, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return B + V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:hge]):bat[:hge] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:int]):bat[:int] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:lng]):bat[:lng] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:sht]):bat[:sht] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:bte]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:flt]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:hge]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:int]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:lng]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:sht]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:bte]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:hge]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:int]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:lng]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:sht]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:hge]):bat[:hge] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:int]):bat[:int] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:lng]):bat[:lng] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:hge]):bat[:hge] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:dbl]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:flt]):bat[:flt] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:hge]):bat[:hge] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:int]):bat[:int] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:lng]):bat[:lng] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatADD;",	"Return V + B, overflow causes NIL value"	]
[ "batcalc",	"add_noerror",	"pattern batcalc.add_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatADD;",	"Return V + B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bit],b2:bat[:bit]):bat[:bit] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatAND;",	"Return B1 AND B2"	]
[ "batcalc",	"and",	"pattern batcalc.and(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatAND;",	"Return B1 AND B2 with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bit],v:bit):bat[:bit] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:int],v:int):bat[:int] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatAND;",	"Return B AND V"	]
[ "batcalc",	"and",	"pattern batcalc.and(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatAND;",	"Return B AND V with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bit,b:bat[:bit]):bat[:bit] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:int,b:bat[:int]):bat[:int] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatAND;",	"Return V AND B"	]
[ "batcalc",	"and",	"pattern batcalc.and(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatAND;",	"Return V AND B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte],s:bat[:oid]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:bte],s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl],s:bat[:oid]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:dbl],s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt],s:bat[:oid]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:flt],s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge],s:bat[:oid]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:hge],s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int],s:bat[:oid]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:int],s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng],s:bat[:oid]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:lng],s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht],s:bat[:oid]) (X_0:dbl,X_1:lng) ",	"CMDcalcavg;",	"average and number of non-nil values of B with candidates list"	]
[ "batcalc",	"avg",	"pattern batcalc.avg(b:bat[:sht],s:bat[:oid]):dbl ",	"CMDcalcavg;",	"average of non-nil values of B"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1],lo:any_1,hi:any_1):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1],lo:any_1,hi:any_1,s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive with candidates list"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1],lo:any_1,hi:bat[:any_1]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1],lo:any_1,hi:bat[:any_1],s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive with candidates list"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1],lo:bat[:any_1],hi:any_1):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1],lo:bat[:any_1],hi:any_1,s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive with candidates list"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1],lo:bat[:any_1],hi:bat[:any_1]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:any_1],lo:bat[:any_1],hi:bat[:any_1],s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive with candidates list"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:hge],lo:bat[:hge],hi:bat[:hge]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive, nil border is (minus) infinity"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:hge],lo:bat[:hge],hi:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive with candidates list, nil border is (minus) infinity"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:hge],lo:bat[:hge],hi:hge):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive, nil border is (minus) infinity"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:hge],lo:bat[:hge],hi:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive with candidates list, nil border is (minus) infinity"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:hge],lo:hge,hi:bat[:hge]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive, nil border is (minus) infinity"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:hge],lo:hge,hi:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive with candidates list, nil border is (minus) infinity"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:hge],lo:hge,hi:hge):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive, nil border is (minus) infinity"	]
[ "batcalc",	"between",	"pattern batcalc.between(b:bat[:hge],lo:hge,hi:hge,s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEEN;",	"B between LO and HI inclusive with candidates list, nil border is (minus) infinity"	]
[ "batcalc",	"between_symmetric",	"pattern batcalc.between_symmetric(b:bat[:any_1],v1:any_1,v2:any_1):bat[:bit] ",	"CMDbatBETWEENsymmetric;",	"B between V1 and V2 (or vice versa) inclusive"	]
[ "batcalc",	"between_symmetric",	"pattern batcalc.between_symmetric(b:bat[:any_1],v1:any_1,v2:any_1,s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEENsymmetric;",	"B between V1 and V2 (or vice versa) inclusive with candidates list"	]
[ "batcalc",	"between_symmetric",	"pattern batcalc.between_symmetric(b:bat[:any_1],v1:any_1,v2:bat[:any_1]):bat[:bit] ",	"CMDbatBETWEENsymmetric;",	"B between V1 and V2 (or vice versa) inclusive"	]
[ "batcalc",	"between_symmetric",	"pattern batcalc.between_symmetric(b:bat[:any_1],v1:any_1,v2:bat[:any_1],s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEENsymmetric;",	"B between V1 and V2 (or vice versa) inclusive with candidates list"	]
[ "batcalc",	"between_symmetric",	"pattern batcalc.between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:any_1):bat[:bit] ",	"CMDbatBETWEENsymmetric;",	"B between V1 and V2 (or vice versa) inclusive"	]
[ "batcalc",	"between_symmetric",	"pattern batcalc.between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:any_1,s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEENsymmetric;",	"B between V1 and V2 (or vice versa) inclusive with candidates list"	]
[ "batcalc",	"between_symmetric",	"pattern batcalc.between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:bat[:any_1]):bat[:bit] ",	"CMDbatBETWEENsymmetric;",	"B between V1 and V2 (or vice versa) inclusive"	]
[ "batcalc",	"between_symmetric",	"pattern batcalc.between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:bat[:any_1],s:bat[:oid]):bat[:bit] ",	"CMDbatBETWEENsymmetric;",	"B between V1 and V2 (or vice versa) inclusive with candidates list"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bit]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bit to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bit to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bte]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bte to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from bte to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:dbl]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from dbl to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from dbl to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:flt]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from flt to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from flt to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:hge]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from hge to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from hge to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:int]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from int to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from int to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:lng]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from lng to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from lng to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from oid to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from oid to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:sht]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from sht to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from sht to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:str]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from str to bit, signal error on overflow"	]
[ "batcalc",	"bit",	"pattern batcalc.bit(b:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDconvertsignal_bit;",	"cast from str to bit with candidates list, signal error on overflow"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bit]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bit to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bit to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bte]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bte to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from bte to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:dbl]):bat[:bit] ",	"CMDconvert_bit;",	"cast from dbl to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from dbl to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:flt]):bat[:bit] ",	"CMDconvert_bit;",	"cast from flt to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from flt to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:hge]):bat[:bit] ",	"CMDconvert_bit;",	"cast from hge to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from hge to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:int]):bat[:bit] ",	"CMDconvert_bit;",	"cast from int to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from int to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:lng]):bat[:bit] ",	"CMDconvert_bit;",	"cast from lng to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from lng to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from oid to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:oid],s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from oid to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:sht]):bat[:bit] ",	"CMDconvert_bit;",	"cast from sht to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from sht to bit with candidates list"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:str]):bat[:bit] ",	"CMDconvert_bit;",	"cast from str to bit"	]
[ "batcalc",	"bit_noerror",	"pattern batcalc.bit_noerror(b:bat[:str],s:bat[:oid]):bat[:bit] ",	"CMDconvert_bit;",	"cast from str to bit with candidates list"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bit]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bit to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bit],s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bit to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bte]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bte to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from bte to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:dbl]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from dbl to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from dbl to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:flt]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from flt to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from flt to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:hge]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from hge to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from hge to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:int]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from int to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from int to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:lng]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from lng to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from lng to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from oid to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:oid],s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from oid to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:sht]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from sht to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from sht to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:str]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from str to bte, signal error on overflow"	]
[ "batcalc",	"bte",	"pattern batcalc.bte(b:bat[:str],s:bat[:oid]):bat[:bte] ",	"CMDconvertsignal_bte;",	"cast from str to bte with candidates list, signal error on overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int,v:bat[:bte]):bat[:bte] ",	"batbte_dec2_bte;",	"cast decimal(bte) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int,v:bat[:bte],d2:int,s2:int):bat[:bte] ",	"batbte_dec2dec_bte;",	"cast decimal(bte) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:bte],digits:int,scale:int):bat[:bte] ",	"batbte_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:dbl],digits:int,scale:int):bat[:bte] ",	"batdbl_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:flt],digits:int,scale:int):bat[:bte] ",	"batflt_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int,v:bat[:hge]):bat[:bte] ",	"bathge_dec2_bte;",	"cast decimal(hge) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int,v:bat[:hge],d2:int,s2:int):bat[:bte] ",	"bathge_dec2dec_bte;",	"cast decimal(hge) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:hge],digits:int,scale:int):bat[:bte] ",	"bathge_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int,v:bat[:int]):bat[:bte] ",	"batint_dec2_bte;",	"cast decimal(int) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int,v:bat[:int],d2:int,s2:int):bat[:bte] ",	"batint_dec2dec_bte;",	"cast decimal(int) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:int],digits:int,scale:int):bat[:bte] ",	"batint_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int,v:bat[:lng]):bat[:bte] ",	"batlng_dec2_bte;",	"cast decimal(lng) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int,v:bat[:lng],d2:int,s2:int):bat[:bte] ",	"batlng_dec2dec_bte;",	"cast decimal(lng) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:lng],digits:int,scale:int):bat[:bte] ",	"batlng_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:oid],digits:int,scale:int):bat[:bte] ",	"batnil_2dec_bte;",	"cast to dec(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:oid],digits:int):bat[:bte] ",	"batnil_2num_bte;",	"cast to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int,v:bat[:sht]):bat[:bte] ",	"batsht_dec2_bte;",	"cast decimal(sht) to bte and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(s1:int,v:bat[:sht],d2:int,s2:int):bat[:bte] ",	"batsht_dec2dec_bte;",	"cast decimal(sht) to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:sht],digits:int,scale:int):bat[:bte] ",	"batsht_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:str],digits:int,scale:int):bat[:bte] ",	"batstr_2dec_bte;",	"cast to dec(bte) and check for overflow"	]
[ "batcalc",	"bte",	"command batcalc.bte(v:bat[:str],digits:int):bat[:bte] ",	"batstr_2num_bte;",	"cast to bte and check for overflow"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bit]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bit to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bit],s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bit to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bte]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bte to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from bte to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:dbl]):bat[:bte] ",	"CMDconvert_bte;",	"cast from dbl to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from dbl to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:flt]):bat[:bte] ",	"CMDconvert_bte;",	"cast from flt to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from flt to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:hge]):bat[:bte] ",	"CMDconvert_bte;",	"cast from hge to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from hge to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:int]):bat[:bte] ",	"CMDconvert_bte;",	"cast from int to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from int to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:lng]):bat[:bte] ",	"CMDconvert_bte;",	"cast from lng to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from lng to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from oid to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:oid],s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from oid to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:sht]):bat[:bte] ",	"CMDconvert_bte;",	"cast from sht to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from sht to bte with candidates list"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:str]):bat[:bte] ",	"CMDconvert_bte;",	"cast from str to bte"	]
[ "batcalc",	"bte_noerror",	"pattern batcalc.bte_noerror(b:bat[:str],s:bat[:oid]):bat[:bte] ",	"CMDconvert_bte;",	"cast from str to bte with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bit],b2:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:oid],b2:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:str],b2:bat[:str]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B1 </==/> B2 with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bit],v:bit):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:flt,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:hge],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:flt,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:int],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:oid],v:oid):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:bte):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:dbl):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:flt):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:hge):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:int):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:lng):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:sht):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:str],v:str):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(b:bat[:str],v:str,s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if B </==/> V with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bit,b:bat[:bit]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:hge,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:int,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:oid,b:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:bte]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:dbl]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:flt]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:hge]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:int]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:lng]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:sht]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:str,b:bat[:str]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B"	]
[ "batcalc",	"cmp",	"pattern batcalc.cmp(v:str,b:bat[:str],s:bat[:oid]):bat[:bte] ",	"CMDbatCMP;",	"Return -1/0/1 if V </==/> B with candidates list"	]
[ "batcalc",	"date",	"command batcalc.date(t:bat[:timestamp]):bat[:date] ",	"MTIMEtimestamp_extract_date_default_bulk;",	""	]
[ "batcalc",	"date",	"command batcalc.date(v:bat[:oid]):bat[:date] ",	"batnil_2_date;",	"cast to date"	]
[ "batcalc",	"date",	"command batcalc.date(v:bat[:str]):bat[:date] ",	"batstr_2_date;",	"cast to date"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(s:bat[:lng]):bat[:daytime] ",	"MTIMEsecs2daytime_bulk;",	""	]
[ "batcalc",	"daytime",	"command batcalc.daytime(t:bat[:timestamp]):bat[:daytime] ",	"MTIMEtimestamp_extract_daytime_default_bulk;",	""	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:daytime],digits:int):bat[:daytime] ",	"batdaytime_2time_daytime;",	"cast daytime to daytime and check for overflow"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:oid]):bat[:daytime] ",	"batnil_2_daytime;",	"Cast to daytime"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:oid],digits:int):bat[:daytime] ",	"batnil_2time_daytime;",	"cast to daytime and check for overflow"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:str]):bat[:daytime] ",	"batstr_2_daytime;",	"Cast to daytime"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:str],digits:int):bat[:daytime] ",	"batstr_2time_daytime;",	"cast to daytime and check for overflow"	]
[ "batcalc",	"daytime",	"command batcalc.daytime(v:bat[:str],digits:int,has_tz:int):bat[:daytime] ",	"batstr_2time_daytimetz;",	"cast to daytime and check for overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bit]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bit to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bit],s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bit to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bte]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bte to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from bte to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:dbl]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from dbl to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from dbl to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:flt]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from flt to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from flt to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:hge]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from hge to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from hge to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:int]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from int to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from int to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:lng]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from lng to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from lng to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from oid to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:oid],s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from oid to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:sht]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from sht to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from sht to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:str]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from str to dbl, signal error on overflow"	]
[ "batcalc",	"dbl",	"pattern batcalc.dbl(b:bat[:str],s:bat[:oid]):bat[:dbl] ",	"CMDconvertsignal_dbl;",	"cast from str to dbl with candidates list, signal error on overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int,v:bat[:bte]):bat[:dbl] ",	"batbte_dec2_dbl;",	"cast decimal(bte) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int,v:bat[:bte],d2:int,s2:int):bat[:dbl] ",	"batbte_dec2dec_dbl;",	"cast decimal(bte) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:bte],digits:int,scale:int):bat[:dbl] ",	"batbte_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int,v:bat[:hge]):bat[:dbl] ",	"bathge_dec2_dbl;",	"cast decimal(hge) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int,v:bat[:hge],d2:int,s2:int):bat[:dbl] ",	"bathge_dec2dec_dbl;",	"cast decimal(hge) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:hge],digits:int,scale:int):bat[:dbl] ",	"bathge_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int,v:bat[:int]):bat[:dbl] ",	"batint_dec2_dbl;",	"cast decimal(int) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int,v:bat[:int],d2:int,s2:int):bat[:dbl] ",	"batint_dec2dec_dbl;",	"cast decimal(int) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:int],digits:int,scale:int):bat[:dbl] ",	"batint_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int,v:bat[:lng]):bat[:dbl] ",	"batlng_dec2_dbl;",	"cast decimal(lng) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int,v:bat[:lng],d2:int,s2:int):bat[:dbl] ",	"batlng_dec2dec_dbl;",	"cast decimal(lng) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:lng],digits:int,scale:int):bat[:dbl] ",	"batlng_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int,v:bat[:sht]):bat[:dbl] ",	"batsht_dec2_dbl;",	"cast decimal(sht) to dbl and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(s1:int,v:bat[:sht],d2:int,s2:int):bat[:dbl] ",	"batsht_dec2dec_dbl;",	"cast decimal(sht) to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl",	"command batcalc.dbl(v:bat[:sht],digits:int,scale:int):bat[:dbl] ",	"batsht_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bit]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bit to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bit],s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bit to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bte]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bte to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from bte to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:dbl]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from dbl to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from dbl to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:flt]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from flt to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from flt to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:hge]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from hge to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from hge to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:int]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from int to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from int to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:lng]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from lng to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from lng to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from oid to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:oid],s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from oid to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:sht]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from sht to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from sht to dbl with candidates list"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:str]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from str to dbl"	]
[ "batcalc",	"dbl_noerror",	"pattern batcalc.dbl_noerror(b:bat[:str],s:bat[:oid]):bat[:dbl] ",	"CMDconvert_dbl;",	"cast from str to dbl with candidates list"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:hge]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:int]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:hge]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:bte]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:hge]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:int]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:lng]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:sht]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:hge]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:lng]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:hge]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:hge]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:int]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B1 / B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:dbl):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:flt):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:hge):bat[:bte] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:int):bat[:bte] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:lng):bat[:bte] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:sht):bat[:bte] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:bte):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:dbl):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:flt):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:hge):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:int):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:lng):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:sht):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:bte):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:dbl):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:flt):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:hge):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:hge,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:int):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:lng):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:sht):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:dbl):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:flt):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:bte):bat[:int] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:dbl):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:flt):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:hge):bat[:int] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:hge,s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:int):bat[:int] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:lng):bat[:int] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:sht):bat[:int] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:dbl):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:flt):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:hge):bat[:lng] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:hge,s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:dbl):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:flt):bat[:flt] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:hge):bat[:sht] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:hge,s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:int):bat[:sht] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:lng):bat[:sht] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatDIV;",	"Return B / V, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return B / V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:hge]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:int]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:lng]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:sht]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:bte]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:flt]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:hge]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:int]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:lng]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:sht]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:bte]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:hge]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:int]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:lng]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:sht]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:hge]):bat[:int] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:int]):bat[:int] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:lng]):bat[:int] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:hge]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:dbl]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:flt]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:hge]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:int]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:lng]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B, overflow causes NIL value"	]
[ "batcalc",	"div_noerror",	"pattern batcalc.div_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatDIV;",	"Return V / B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bit]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bit to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bit],s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bit to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bte]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bte to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from bte to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:dbl]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from dbl to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:dbl],s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from dbl to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:flt]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from flt to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from flt to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:hge]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from hge to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from hge to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:int]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from int to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from int to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:lng]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from lng to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from lng to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from oid to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:oid],s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from oid to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:sht]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from sht to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from sht to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:str]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from str to flt, signal error on overflow"	]
[ "batcalc",	"flt",	"pattern batcalc.flt(b:bat[:str],s:bat[:oid]):bat[:flt] ",	"CMDconvertsignal_flt;",	"cast from str to flt with candidates list, signal error on overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int,v:bat[:bte]):bat[:flt] ",	"batbte_dec2_flt;",	"cast decimal(bte) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int,v:bat[:bte],d2:int,s2:int):bat[:flt] ",	"batbte_dec2dec_flt;",	"cast decimal(bte) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:bte],digits:int,scale:int):bat[:flt] ",	"batbte_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int,v:bat[:hge]):bat[:flt] ",	"bathge_dec2_flt;",	"cast decimal(hge) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int,v:bat[:hge],d2:int,s2:int):bat[:flt] ",	"bathge_dec2dec_flt;",	"cast decimal(hge) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:hge],digits:int,scale:int):bat[:flt] ",	"bathge_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int,v:bat[:int]):bat[:flt] ",	"batint_dec2_flt;",	"cast decimal(int) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int,v:bat[:int],d2:int,s2:int):bat[:flt] ",	"batint_dec2dec_flt;",	"cast decimal(int) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:int],digits:int,scale:int):bat[:flt] ",	"batint_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int,v:bat[:lng]):bat[:flt] ",	"batlng_dec2_flt;",	"cast decimal(lng) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int,v:bat[:lng],d2:int,s2:int):bat[:flt] ",	"batlng_dec2dec_flt;",	"cast decimal(lng) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:lng],digits:int,scale:int):bat[:flt] ",	"batlng_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int,v:bat[:sht]):bat[:flt] ",	"batsht_dec2_flt;",	"cast decimal(sht) to flt and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(s1:int,v:bat[:sht],d2:int,s2:int):bat[:flt] ",	"batsht_dec2dec_flt;",	"cast decimal(sht) to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt",	"command batcalc.flt(v:bat[:sht],digits:int,scale:int):bat[:flt] ",	"batsht_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bit]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bit to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bit],s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bit to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bte]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bte to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from bte to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:dbl]):bat[:flt] ",	"CMDconvert_flt;",	"cast from dbl to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:dbl],s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from dbl to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:flt]):bat[:flt] ",	"CMDconvert_flt;",	"cast from flt to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from flt to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:hge]):bat[:flt] ",	"CMDconvert_flt;",	"cast from hge to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from hge to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:int]):bat[:flt] ",	"CMDconvert_flt;",	"cast from int to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from int to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:lng]):bat[:flt] ",	"CMDconvert_flt;",	"cast from lng to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from lng to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from oid to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:oid],s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from oid to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:sht]):bat[:flt] ",	"CMDconvert_flt;",	"cast from sht to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from sht to flt with candidates list"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:str]):bat[:flt] ",	"CMDconvert_flt;",	"cast from str to flt"	]
[ "batcalc",	"flt_noerror",	"pattern batcalc.flt_noerror(b:bat[:str],s:bat[:oid]):bat[:flt] ",	"CMDconvert_flt;",	"cast from str to flt with candidates list"	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:any_1]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:bte]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:dbl]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:flt]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:hge]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:int]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:lng]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:lng]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:oid]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hash",	"command batcalc.hash(b:bat[:sht]):bat[:lng] ",	"MKEYbathash;",	""	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bit]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bit to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bit],s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bit to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bte]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bte to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from bte to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:dbl]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from dbl to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:dbl],s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from dbl to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:flt]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from flt to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:flt],s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from flt to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:hge]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from hge to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from hge to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:int]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from int to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from int to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:lng]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from lng to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from lng to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from oid to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:oid],s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from oid to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:sht]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from sht to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from sht to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:str]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from str to hge, signal error on overflow"	]
[ "batcalc",	"hge",	"pattern batcalc.hge(b:bat[:str],s:bat[:oid]):bat[:hge] ",	"CMDconvertsignal_hge;",	"cast from str to hge with candidates list, signal error on overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int,v:bat[:bte]):bat[:hge] ",	"batbte_dec2_hge;",	"cast decimal(bte) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int,v:bat[:bte],d2:int,s2:int):bat[:hge] ",	"batbte_dec2dec_hge;",	"cast decimal(bte) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:bte],digits:int,scale:int):bat[:hge] ",	"batbte_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:dbl],digits:int,scale:int):bat[:hge] ",	"batdbl_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:flt],digits:int,scale:int):bat[:hge] ",	"batflt_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int,v:bat[:hge]):bat[:hge] ",	"bathge_dec2_hge;",	"cast decimal(hge) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int,v:bat[:hge],d2:int,s2:int):bat[:hge] ",	"bathge_dec2dec_hge;",	"cast decimal(hge) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:hge],digits:int,scale:int):bat[:hge] ",	"bathge_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int,v:bat[:int]):bat[:hge] ",	"batint_dec2_hge;",	"cast decimal(int) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int,v:bat[:int],d2:int,s2:int):bat[:hge] ",	"batint_dec2dec_hge;",	"cast decimal(int) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:int],digits:int,scale:int):bat[:hge] ",	"batint_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int,v:bat[:lng]):bat[:hge] ",	"batlng_dec2_hge;",	"cast decimal(lng) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int,v:bat[:lng],d2:int,s2:int):bat[:hge] ",	"batlng_dec2dec_hge;",	"cast decimal(lng) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:lng],digits:int,scale:int):bat[:hge] ",	"batlng_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:void],digits:int,scale:int):bat[:hge] ",	"batnil_2dec_hge;",	"cast to dec(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:void],digits:int):bat[:hge] ",	"batnil_2num_hge;",	"cast to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int,v:bat[:sht]):bat[:hge] ",	"batsht_dec2_hge;",	"cast decimal(sht) to hge and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(s1:int,v:bat[:sht],d2:int,s2:int):bat[:hge] ",	"batsht_dec2dec_hge;",	"cast decimal(sht) to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:sht],digits:int,scale:int):bat[:hge] ",	"batsht_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:str],digits:int,scale:int):bat[:hge] ",	"batstr_2dec_hge;",	"cast to dec(hge) and check for overflow"	]
[ "batcalc",	"hge",	"command batcalc.hge(v:bat[:str],digits:int):bat[:hge] ",	"batstr_2num_hge;",	"cast to hge and check for overflow"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bit]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bit to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bit],s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bit to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bte]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bte to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from bte to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:dbl]):bat[:hge] ",	"CMDconvert_hge;",	"cast from dbl to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:dbl],s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from dbl to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:flt]):bat[:hge] ",	"CMDconvert_hge;",	"cast from flt to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:flt],s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from flt to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:hge]):bat[:hge] ",	"CMDconvert_hge;",	"cast from hge to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from hge to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:int]):bat[:hge] ",	"CMDconvert_hge;",	"cast from int to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from int to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:lng]):bat[:hge] ",	"CMDconvert_hge;",	"cast from lng to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from lng to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from oid to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:oid],s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from oid to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:sht]):bat[:hge] ",	"CMDconvert_hge;",	"cast from sht to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from sht to hge with candidates list"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:str]):bat[:hge] ",	"CMDconvert_hge;",	"cast from str to hge"	]
[ "batcalc",	"hge_noerror",	"pattern batcalc.hge_noerror(b:bat[:str],s:bat[:oid]):bat[:hge] ",	"CMDconvert_hge;",	"cast from str to hge with candidates list"	]
[ "batcalc",	"identity",	"command batcalc.identity(b:bat[:any_2]):bat[:oid] ",	"BATSQLidentity;",	"Returns the unique row identitfiers."	]
[ "batcalc",	"identity",	"pattern batcalc.identity(b:bat[:any_2],s:oid) (resb:bat[:oid],ns:oid) ",	"PBATSQLidentity;",	"Returns the unique row identitfiers."	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(b:bat[:bit],b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(b:bat[:bit],b1:bat[:any_1],v2:any_1):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(b:bat[:bit],v1:any_1,b2:bat[:any_1]):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(b:bat[:bit],v1:any_1,v2:any_1):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(v:bit,b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(v:bit,b1:bat[:any_1],v2:any_1):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"ifthenelse",	"pattern batcalc.ifthenelse(v:bit,v1:any_1,b2:bat[:any_1]):bat[:any_1] ",	"CMDifthen;",	"If-then-else operation to assemble a conditional result"	]
[ "batcalc",	"index",	"command batcalc.index(v:bat[:str],u:bit):bat[:bte] ",	"BATSTRindex_bte;",	"Return the offsets as an index bat"	]
[ "batcalc",	"index",	"command batcalc.index(v:bat[:str],u:bit):bat[:int] ",	"BATSTRindex_int;",	"Return the offsets as an index bat"	]
[ "batcalc",	"index",	"command batcalc.index(v:bat[:str],u:bit):bat[:sht] ",	"BATSTRindex_sht;",	"Return the offsets as an index bat"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bit]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bit to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bit],s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bit to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bte]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bte to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from bte to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:dbl]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from dbl to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:dbl],s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from dbl to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:flt]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from flt to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:flt],s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from flt to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:hge]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from hge to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from hge to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:int]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from int to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from int to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:lng]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from lng to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from lng to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from oid to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:oid],s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from oid to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:sht]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from sht to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from sht to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:str]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from str to int, signal error on overflow"	]
[ "batcalc",	"int",	"pattern batcalc.int(b:bat[:str],s:bat[:oid]):bat[:int] ",	"CMDconvertsignal_int;",	"cast from str to int with candidates list, signal error on overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int,v:bat[:bte]):bat[:int] ",	"batbte_dec2_int;",	"cast decimal(bte) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int,v:bat[:bte],d2:int,s2:int):bat[:int] ",	"batbte_dec2dec_int;",	"cast decimal(bte) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:bte],digits:int,scale:int):bat[:int] ",	"batbte_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:dbl],digits:int,scale:int):bat[:int] ",	"batdbl_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:flt],digits:int,scale:int):bat[:int] ",	"batflt_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int,v:bat[:hge]):bat[:int] ",	"bathge_dec2_int;",	"cast decimal(hge) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int,v:bat[:hge],d2:int,s2:int):bat[:int] ",	"bathge_dec2dec_int;",	"cast decimal(hge) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:hge],digits:int,scale:int):bat[:int] ",	"bathge_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int,v:bat[:int]):bat[:int] ",	"batint_dec2_int;",	"cast decimal(int) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int,v:bat[:int],d2:int,s2:int):bat[:int] ",	"batint_dec2dec_int;",	"cast decimal(int) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:int],digits:int,scale:int):bat[:int] ",	"batint_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int,v:bat[:lng]):bat[:int] ",	"batlng_dec2_int;",	"cast decimal(lng) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int,v:bat[:lng],d2:int,s2:int):bat[:int] ",	"batlng_dec2dec_int;",	"cast decimal(lng) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:lng],digits:int,scale:int):bat[:int] ",	"batlng_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:oid],digits:int,scale:int):bat[:int] ",	"batnil_2dec_int;",	"cast to dec(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:oid],digits:int):bat[:int] ",	"batnil_2num_int;",	"cast to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int,v:bat[:sht]):bat[:int] ",	"batsht_dec2_int;",	"cast decimal(sht) to int and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(s1:int,v:bat[:sht],d2:int,s2:int):bat[:int] ",	"batsht_dec2dec_int;",	"cast decimal(sht) to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:sht],digits:int,scale:int):bat[:int] ",	"batsht_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:str],digits:int,scale:int):bat[:int] ",	"batstr_2dec_int;",	"cast to dec(int) and check for overflow"	]
[ "batcalc",	"int",	"command batcalc.int(v:bat[:str],digits:int):bat[:int] ",	"batstr_2num_int;",	"cast to int and check for overflow"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bit]):bat[:int] ",	"CMDconvert_int;",	"cast from bit to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bit],s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from bit to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bte]):bat[:int] ",	"CMDconvert_int;",	"cast from bte to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from bte to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:dbl]):bat[:int] ",	"CMDconvert_int;",	"cast from dbl to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:dbl],s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from dbl to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:flt]):bat[:int] ",	"CMDconvert_int;",	"cast from flt to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:flt],s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from flt to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:hge]):bat[:int] ",	"CMDconvert_int;",	"cast from hge to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from hge to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:int]):bat[:int] ",	"CMDconvert_int;",	"cast from int to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from int to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:lng]):bat[:int] ",	"CMDconvert_int;",	"cast from lng to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from lng to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from oid to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:oid],s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from oid to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:sht]):bat[:int] ",	"CMDconvert_int;",	"cast from sht to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from sht to int with candidates list"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:str]):bat[:int] ",	"CMDconvert_int;",	"cast from str to int"	]
[ "batcalc",	"int_noerror",	"pattern batcalc.int_noerror(b:bat[:str],s:bat[:oid]):bat[:int] ",	"CMDconvert_int;",	"cast from str to int with candidates list"	]
[ "batcalc",	"isnil",	"pattern batcalc.isnil(b:bat[:any]):bat[:bit] ",	"CMDbatISNIL;",	"Unary check for nil over the tail of the bat"	]
[ "batcalc",	"isnil",	"pattern batcalc.isnil(b:bat[:any],s:bat[:oid]):bat[:bit] ",	"CMDbatISNIL;",	"Unary check for nil over the tail of the bat with candidates list"	]
[ "batcalc",	"isnotnil",	"pattern batcalc.isnotnil(b:bat[:any]):bat[:bit] ",	"CMDbatISNOTNIL;",	"Unary check for notnil over the tail of the bat"	]
[ "batcalc",	"isnotnil",	"pattern batcalc.isnotnil(b:bat[:any],s:bat[:oid]):bat[:bit] ",	"CMDbatISNOTNIL;",	"Unary check for notnil over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:bte]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:bte],s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:dbl]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:dbl],s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:flt]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:flt],s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:hge]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:hge],s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:int]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:int],s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:lng]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:lng],s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:sht]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat"	]
[ "batcalc",	"iszero",	"pattern batcalc.iszero(b:bat[:sht],s:bat[:oid]):bat[:bit] ",	"CMDbatISZERO;",	"Unary check for zero over the tail of the bat with candidates list"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bit]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bit to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bit],s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bit to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bte]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bte to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from bte to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:dbl]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from dbl to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:dbl],s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from dbl to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:flt]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from flt to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:flt],s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from flt to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:hge]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from hge to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from hge to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:int]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from int to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from int to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:lng]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from lng to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from lng to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from oid to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:oid],s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from oid to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:sht]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from sht to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from sht to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:str]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from str to lng, signal error on overflow"	]
[ "batcalc",	"lng",	"pattern batcalc.lng(b:bat[:str],s:bat[:oid]):bat[:lng] ",	"CMDconvertsignal_lng;",	"cast from str to lng with candidates list, signal error on overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int,v:bat[:bte]):bat[:lng] ",	"batbte_dec2_lng;",	"cast decimal(bte) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int,v:bat[:bte],d2:int,s2:int):bat[:lng] ",	"batbte_dec2dec_lng;",	"cast decimal(bte) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:bte],digits:int,scale:int):bat[:lng] ",	"batbte_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:dbl],digits:int,scale:int):bat[:lng] ",	"batdbl_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:flt],digits:int,scale:int):bat[:lng] ",	"batflt_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int,v:bat[:hge]):bat[:lng] ",	"bathge_dec2_lng;",	"cast decimal(hge) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int,v:bat[:hge],d2:int,s2:int):bat[:lng] ",	"bathge_dec2dec_lng;",	"cast decimal(hge) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:hge],digits:int,scale:int):bat[:lng] ",	"bathge_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int,v:bat[:int]):bat[:lng] ",	"batint_dec2_lng;",	"cast decimal(int) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int,v:bat[:int],d2:int,s2:int):bat[:lng] ",	"batint_dec2dec_lng;",	"cast decimal(int) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:int],digits:int,scale:int):bat[:lng] ",	"batint_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int,v:bat[:lng]):bat[:lng] ",	"batlng_dec2_lng;",	"cast decimal(lng) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int,v:bat[:lng],d2:int,s2:int):bat[:lng] ",	"batlng_dec2dec_lng;",	"cast decimal(lng) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:lng],digits:int,scale:int):bat[:lng] ",	"batlng_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:oid],digits:int,scale:int):bat[:lng] ",	"batnil_2dec_lng;",	"cast to dec(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:oid],digits:int):bat[:lng] ",	"batnil_2num_lng;",	"cast to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int,v:bat[:sht]):bat[:lng] ",	"batsht_dec2_lng;",	"cast decimal(sht) to lng and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(s1:int,v:bat[:sht],d2:int,s2:int):bat[:lng] ",	"batsht_dec2dec_lng;",	"cast decimal(sht) to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:sht],digits:int,scale:int):bat[:lng] ",	"batsht_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:str],digits:int,scale:int):bat[:lng] ",	"batstr_2dec_lng;",	"cast to dec(lng) and check for overflow"	]
[ "batcalc",	"lng",	"command batcalc.lng(v:bat[:str],digits:int):bat[:lng] ",	"batstr_2num_lng;",	"cast to lng and check for overflow"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bit]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bit to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bit],s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bit to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bte]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bte to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from bte to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:dbl]):bat[:lng] ",	"CMDconvert_lng;",	"cast from dbl to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:dbl],s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from dbl to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:flt]):bat[:lng] ",	"CMDconvert_lng;",	"cast from flt to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:flt],s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from flt to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:hge]):bat[:lng] ",	"CMDconvert_lng;",	"cast from hge to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from hge to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:int]):bat[:lng] ",	"CMDconvert_lng;",	"cast from int to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from int to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:lng]):bat[:lng] ",	"CMDconvert_lng;",	"cast from lng to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from lng to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from oid to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:oid],s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from oid to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:sht]):bat[:lng] ",	"CMDconvert_lng;",	"cast from sht to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from sht to lng with candidates list"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:str]):bat[:lng] ",	"CMDconvert_lng;",	"cast from str to lng"	]
[ "batcalc",	"lng_noerror",	"pattern batcalc.lng_noerror(b:bat[:str],s:bat[:oid]):bat[:lng] ",	"CMDconvert_lng;",	"cast from str to lng with candidates list"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:hge]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:int]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:hge]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:lng]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:hge]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:hge]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:int]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B1 << B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte],v:hge):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte],v:int):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte],v:lng):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte],v:sht):bat[:bte] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int],v:bte):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int],v:hge):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int],v:hge,s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int],v:int):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int],v:lng):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int],v:sht):bat[:int] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng],v:hge):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng],v:hge,s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht],v:hge):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht],v:hge,s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht],v:int):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht],v:lng):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatLSH;",	"Return B << V, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return B << V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte,b:bat[:hge]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte,b:bat[:int]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte,b:bat[:lng]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte,b:bat[:sht]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int,b:bat[:hge]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int,b:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int,b:bat[:int]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int,b:bat[:lng]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng,b:bat[:hge]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng,b:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht,b:bat[:hge]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht,b:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht,b:bat[:int]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht,b:bat[:lng]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B, out of range second operand causes NIL value"	]
[ "batcalc",	"lsh_noerror",	"pattern batcalc.lsh_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatLSH;",	"Return V << B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"max",	"pattern batcalc.max(b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(b:bat[:any_1],v:any_1):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(b:bat[:any_1],v:any_1,s:bat[:oid]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(v:any_1,b:bat[:any_1]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max",	"pattern batcalc.max(v:any_1,b:bat[:any_1],s:bat[:oid]):bat[:any_1] ",	"CMDbatMAX;",	"Return bat with maximum value of each pair of inputs"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b:bat[:any_1],v:any_1):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(b:bat[:any_1],v:any_1,s:bat[:oid]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(v:any_1,b:bat[:any_1]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"max_no_nil",	"pattern batcalc.max_no_nil(v:any_1,b:bat[:any_1],s:bat[:oid]):bat[:any_1] ",	"CMDbatMAX_no_nil;",	"Return bat with maximum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min",	"pattern batcalc.min(b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(b:bat[:any_1],v:any_1):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(b:bat[:any_1],v:any_1,s:bat[:oid]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(v:any_1,b:bat[:any_1]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min",	"pattern batcalc.min(v:any_1,b:bat[:any_1],s:bat[:oid]):bat[:any_1] ",	"CMDbatMIN;",	"Return bat with minimum value of each pair of inputs"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b:bat[:any_1],v:any_1):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(b:bat[:any_1],v:any_1,s:bat[:oid]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(v:any_1,b:bat[:any_1]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"min_no_nil",	"pattern batcalc.min_no_nil(v:any_1,b:bat[:any_1],s:bat[:oid]):bat[:any_1] ",	"CMDbatMIN_no_nil;",	"Return bat with minimum value of each pair of inputs, ignoring nil values"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:hge]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:int]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:hge]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:bte]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:hge]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:int]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:lng]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:sht]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:bte]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:int]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:lng]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:sht]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:bte]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:hge]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:lng]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:sht]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:hge]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:int]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:hge]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:int]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B1 % B2 with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:dbl):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:flt):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:hge):bat[:bte] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:int):bat[:bte] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:lng):bat[:bte] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:sht):bat[:bte] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:bte):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:dbl):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:flt):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:hge):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:int):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:lng):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:sht):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:bte):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:dbl):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:flt):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:hge):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:hge,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:int):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:lng):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:sht):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:bte):bat[:bte] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:dbl):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:flt):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:int):bat[:int] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:lng):bat[:lng] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:sht):bat[:sht] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:hge],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:bte):bat[:bte] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:dbl):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:flt):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:hge):bat[:int] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:hge,s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:int):bat[:int] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:lng):bat[:int] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:sht):bat[:sht] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:bte):bat[:bte] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:dbl):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:flt):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:hge):bat[:lng] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:hge,s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:int):bat[:int] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:sht):bat[:sht] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:bte):bat[:bte] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:dbl):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:flt):bat[:flt] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:hge):bat[:sht] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:hge,s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:int):bat[:sht] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:lng):bat[:sht] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatMOD;",	"Return B % V, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return B % V with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:hge]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:int]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:lng]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:sht]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:bte]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:flt]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:hge]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:int]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:lng]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:sht]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:bte]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:hge]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:int]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:lng]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:sht]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:bte]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:int]):bat[:int] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:lng]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:sht]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:hge,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:bte]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:hge]):bat[:int] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:int]):bat[:int] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:lng]):bat[:int] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:sht]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:bte]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:hge]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:int]):bat[:int] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:sht]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:bte]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:flt]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:hge]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:int]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:lng]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B, divide by zero causes NIL value"	]
[ "batcalc",	"mod_noerror",	"pattern batcalc.mod_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMOD;",	"Return V % B with candidates list, divide by zero causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:hge]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:int]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:hge]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:bte]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:hge]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:int]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:lng]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:sht]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:hge]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:lng]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:hge]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:hge]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:int]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B1 * B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:dbl):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:flt):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:hge):bat[:hge] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:int):bat[:int] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:lng):bat[:lng] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:sht):bat[:sht] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:bte):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:dbl):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:flt):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:hge):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:int):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:lng):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:sht):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:bte):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:dbl):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:flt):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:hge):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:hge,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:int):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:lng):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:sht):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:dbl):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:flt):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:bte):bat[:int] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:dbl):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:flt):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:hge):bat[:hge] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:int):bat[:int] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:lng):bat[:lng] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:sht):bat[:int] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:dbl):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:flt):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:hge):bat[:hge] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:dbl):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:flt):bat[:flt] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:hge):bat[:hge] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:int):bat[:int] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:lng):bat[:lng] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatMUL;",	"Return B * V, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return B * V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:hge]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:int]):bat[:int] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:lng]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:sht]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:bte]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:flt]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:hge]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:int]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:lng]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:sht]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:bte]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:hge]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:int]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:lng]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:sht]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:hge]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:int]):bat[:int] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:lng]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:hge]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:dbl]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:flt]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:hge]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:int]):bat[:int] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:lng]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B, overflow causes NIL value"	]
[ "batcalc",	"mul_noerror",	"pattern batcalc.mul_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatMUL;",	"Return V * B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bit]):bat[:bit] ",	"CMDbatNOT;",	"Return the Boolean inverse"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatNOT;",	"Return the Boolean inverse with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bte]):bat[:bte] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:hge]):bat[:hge] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:int]):bat[:int] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:lng]):bat[:lng] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:sht]):bat[:sht] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat"	]
[ "batcalc",	"not",	"pattern batcalc.not(b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatNOT;",	"Unary bitwise not over the tail of the bat with candidates list"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bit]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bit to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bit],s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bit to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bte]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bte to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:bte],s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from bte to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:dbl]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from dbl to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:dbl],s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from dbl to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:flt]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from flt to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:flt],s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from flt to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:hge]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from hge to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:hge],s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from hge to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:int]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from int to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:int],s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from int to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:lng]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from lng to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:lng],s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from lng to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from oid to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:oid],s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from oid to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:sht]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from sht to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:sht],s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from sht to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:str]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from str to oid, signal error on overflow"	]
[ "batcalc",	"oid",	"pattern batcalc.oid(b:bat[:str],s:bat[:oid]):bat[:oid] ",	"CMDconvertsignal_oid;",	"cast from str to oid with candidates list, signal error on overflow"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bit]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bit to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bit],s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bit to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bte]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bte to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:bte],s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from bte to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:dbl]):bat[:oid] ",	"CMDconvert_oid;",	"cast from dbl to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:dbl],s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from dbl to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:flt]):bat[:oid] ",	"CMDconvert_oid;",	"cast from flt to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:flt],s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from flt to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:hge]):bat[:oid] ",	"CMDconvert_oid;",	"cast from hge to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:hge],s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from hge to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:int]):bat[:oid] ",	"CMDconvert_oid;",	"cast from int to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:int],s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from int to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:lng]):bat[:oid] ",	"CMDconvert_oid;",	"cast from lng to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:lng],s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from lng to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from oid to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:oid],s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from oid to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:sht]):bat[:oid] ",	"CMDconvert_oid;",	"cast from sht to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:sht],s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from sht to oid with candidates list"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:str]):bat[:oid] ",	"CMDconvert_oid;",	"cast from str to oid"	]
[ "batcalc",	"oid_noerror",	"pattern batcalc.oid_noerror(b:bat[:str],s:bat[:oid]):bat[:oid] ",	"CMDconvert_oid;",	"cast from str to oid with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bit],b2:bat[:bit]):bat[:bit] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatOR;",	"Return B1 OR B2"	]
[ "batcalc",	"or",	"pattern batcalc.or(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatOR;",	"Return B1 OR B2 with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bit],v:bit):bat[:bit] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:int],v:int):bat[:int] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatOR;",	"Return B OR V"	]
[ "batcalc",	"or",	"pattern batcalc.or(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatOR;",	"Return B OR V with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bit,b:bat[:bit]):bat[:bit] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:int,b:bat[:int]):bat[:int] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatOR;",	"Return V OR B"	]
[ "batcalc",	"or",	"pattern batcalc.or(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatOR;",	"Return V OR B with candidates list"	]
[ "batcalc",	"rotate_xor_hash",	"command batcalc.rotate_xor_hash(h:bat[:lng],nbits:int,b:bat[:any_1]):bat[:int] ",	"MKEYbulk_rotate_xor_hash;",	""	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:hge]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:int]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:hge]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:lng]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:hge]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:hge]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:int]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B1 >> B2 with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte],v:hge):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte],v:hge,s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte],v:int):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte],v:lng):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte],v:sht):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int],v:bte):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int],v:hge):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int],v:hge,s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int],v:int):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int],v:lng):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int],v:sht):bat[:int] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng],v:hge):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng],v:hge,s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht],v:hge):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht],v:hge,s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht],v:int):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht],v:lng):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return B >> V with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte,b:bat[:hge]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte,b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte,b:bat[:int]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte,b:bat[:lng]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte,b:bat[:sht]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int,b:bat[:hge]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int,b:bat[:hge],s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int,b:bat[:int]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int,b:bat[:lng]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng,b:bat[:hge]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng,b:bat[:hge],s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht,b:bat[:hge]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht,b:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht,b:bat[:int]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht,b:bat[:lng]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B, out of range second operand causes NIL value"	]
[ "batcalc",	"rsh_noerror",	"pattern batcalc.rsh_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatRSH;",	"Return V >> B with candidates list, out of range second operand causes NIL value"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bit]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bit to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bit],s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bit to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bte]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bte to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from bte to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:dbl]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from dbl to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:dbl],s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from dbl to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:flt]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from flt to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:flt],s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from flt to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:hge]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from hge to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from hge to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:int]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from int to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from int to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:lng]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from lng to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from lng to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from oid to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:oid],s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from oid to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:sht]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from sht to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from sht to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:str]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from str to sht, signal error on overflow"	]
[ "batcalc",	"sht",	"pattern batcalc.sht(b:bat[:str],s:bat[:oid]):bat[:sht] ",	"CMDconvertsignal_sht;",	"cast from str to sht with candidates list, signal error on overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int,v:bat[:bte]):bat[:sht] ",	"batbte_dec2_sht;",	"cast decimal(bte) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int,v:bat[:bte],d2:int,s2:int):bat[:sht] ",	"batbte_dec2dec_sht;",	"cast decimal(bte) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:bte],digits:int,scale:int):bat[:sht] ",	"batbte_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:dbl],digits:int,scale:int):bat[:sht] ",	"batdbl_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:flt],digits:int,scale:int):bat[:sht] ",	"batflt_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int,v:bat[:hge]):bat[:sht] ",	"bathge_dec2_sht;",	"cast decimal(hge) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int,v:bat[:hge],d2:int,s2:int):bat[:sht] ",	"bathge_dec2dec_sht;",	"cast decimal(hge) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:hge],digits:int,scale:int):bat[:sht] ",	"bathge_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int,v:bat[:int]):bat[:sht] ",	"batint_dec2_sht;",	"cast decimal(int) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int,v:bat[:int],d2:int,s2:int):bat[:sht] ",	"batint_dec2dec_sht;",	"cast decimal(int) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:int],digits:int,scale:int):bat[:sht] ",	"batint_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int,v:bat[:lng]):bat[:sht] ",	"batlng_dec2_sht;",	"cast decimal(lng) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int,v:bat[:lng],d2:int,s2:int):bat[:sht] ",	"batlng_dec2dec_sht;",	"cast decimal(lng) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:lng],digits:int,scale:int):bat[:sht] ",	"batlng_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:oid],digits:int,scale:int):bat[:sht] ",	"batnil_2dec_sht;",	"cast to dec(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:oid],digits:int):bat[:sht] ",	"batnil_2num_sht;",	"cast to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int,v:bat[:sht]):bat[:sht] ",	"batsht_dec2_sht;",	"cast decimal(sht) to sht and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(s1:int,v:bat[:sht],d2:int,s2:int):bat[:sht] ",	"batsht_dec2dec_sht;",	"cast decimal(sht) to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:sht],digits:int,scale:int):bat[:sht] ",	"batsht_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:str],digits:int,scale:int):bat[:sht] ",	"batstr_2dec_sht;",	"cast to dec(sht) and check for overflow"	]
[ "batcalc",	"sht",	"command batcalc.sht(v:bat[:str],digits:int):bat[:sht] ",	"batstr_2num_sht;",	"cast to sht and check for overflow"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bit]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bit to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bit],s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bit to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bte]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bte to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from bte to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:dbl]):bat[:sht] ",	"CMDconvert_sht;",	"cast from dbl to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:dbl],s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from dbl to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:flt]):bat[:sht] ",	"CMDconvert_sht;",	"cast from flt to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:flt],s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from flt to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:hge]):bat[:sht] ",	"CMDconvert_sht;",	"cast from hge to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:hge],s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from hge to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:int]):bat[:sht] ",	"CMDconvert_sht;",	"cast from int to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:int],s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from int to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:lng]):bat[:sht] ",	"CMDconvert_sht;",	"cast from lng to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:lng],s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from lng to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from oid to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:oid],s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from oid to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:sht]):bat[:sht] ",	"CMDconvert_sht;",	"cast from sht to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from sht to sht with candidates list"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:str]):bat[:sht] ",	"CMDconvert_sht;",	"cast from str to sht"	]
[ "batcalc",	"sht_noerror",	"pattern batcalc.sht_noerror(b:bat[:str],s:bat[:oid]):bat[:sht] ",	"CMDconvert_sht;",	"cast from str to sht with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:bte]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:dbl]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:dbl],s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:flt]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:flt],s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:hge]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:hge],s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:int]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:int],s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:lng]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:lng],s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:sht]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat"	]
[ "batcalc",	"sign",	"pattern batcalc.sign(b:bat[:sht],s:bat[:oid]):bat[:bte] ",	"CMDbatSIGN;",	"Unary sign (-1,0,1) over the tail of the bat with candidates list"	]
[ "batcalc",	"sqlblob",	"command batcalc.sqlblob(v:bat[:str]):bat[:sqlblob] ",	"batstr_2_sqlblob;",	"cast to sqlblob"	]
[ "batcalc",	"str",	"pattern batcalc.str(b:bat[:any]):bat[:str] ",	"CMDconvertsignal_str;",	"cast from any to str, signal error on overflow"	]
[ "batcalc",	"str",	"pattern batcalc.str(b:bat[:any],s:bat[:oid]):bat[:str] ",	"CMDconvertsignal_str;",	"cast from any to str with candidates list, signal error on overflow"	]
[ "batcalc",	"str",	"pattern batcalc.str(eclass:int,d1:int,s1:int,has_tz:int,v:bat[:any_1],digits:int):bat[:str] ",	"SQLbatstr_cast;",	"cast to string and check for overflow"	]
[ "batcalc",	"str_noerror",	"pattern batcalc.str_noerror(b:bat[:any]):bat[:str] ",	"CMDconvert_str;",	"cast from any to str"	]
[ "batcalc",	"str_noerror",	"pattern batcalc.str_noerror(b:bat[:any],s:bat[:oid]):bat[:str] ",	"CMDconvert_str;",	"cast from any to str with candidates list"	]
[ "batcalc",	"strings",	"command batcalc.strings(v:bat[:str]):bat[:str] ",	"BATSTRstrings;",	"Return the strings"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:hge]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:int]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:hge]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:bte]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:hge]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:int]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:lng]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:sht]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:bte]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:int]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:lng]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:sht]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:hge]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:lng]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:hge]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:hge]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:int]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B1 - B2 with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:dbl):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:flt):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:hge):bat[:hge] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:int):bat[:int] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:lng):bat[:lng] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:sht):bat[:sht] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:bte):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:dbl):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:flt):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:hge):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:hge,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:int):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:lng):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:sht):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:bte):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:dbl):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:flt):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:hge):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:hge,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:int):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:lng):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:sht):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:bte):bat[:hge] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:bte,s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:dbl):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:flt):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:int):bat[:hge] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:int,s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:lng):bat[:hge] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:lng,s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:sht):bat[:hge] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:hge],v:sht,s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:bte):bat[:int] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:dbl):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:flt):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:hge):bat[:hge] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:int):bat[:int] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:lng):bat[:lng] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:sht):bat[:int] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:bte):bat[:lng] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:dbl):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:flt):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:hge):bat[:hge] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:int):bat[:lng] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:sht):bat[:lng] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:bte):bat[:sht] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:dbl):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:flt):bat[:flt] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:hge):bat[:hge] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:int):bat[:int] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:lng):bat[:lng] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatSUB;",	"Return B - V, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return B - V with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:hge]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:int]):bat[:int] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:lng]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:sht]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:bte]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:flt]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:hge]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:hge],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:int]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:lng]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:sht]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:bte]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:hge]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:hge],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:int]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:lng]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:sht]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:bte]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:bte],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:int]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:int],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:lng]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:lng],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:sht]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:hge,b:bat[:sht],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:bte]):bat[:int] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:hge]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:int]):bat[:int] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:lng]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:sht]):bat[:int] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:bte]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:hge]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:int]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:sht]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:bte]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:dbl]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:flt]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:hge]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:int]):bat[:int] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:lng]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B, overflow causes NIL value"	]
[ "batcalc",	"sub_noerror",	"pattern batcalc.sub_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatSUB;",	"Return V - B with candidates list, overflow causes NIL value"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(secs:bat[:int]):bat[:timestamp] ",	"MTIMEtimestamp_bulk;",	""	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(d:bat[:date]):bat[:timestamp] ",	"MTIMEtimestamp_create_from_date_bulk;",	""	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(msecs:bat[:lng]):bat[:timestamp] ",	"MTIMEtimestamp_lng_bulk;",	""	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:oid]):bat[:timestamp] ",	"batnil_2_timestamp;",	"Cast to timestamp"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:oid],digits:int):bat[:timestamp] ",	"batnil_2time_timestamp;",	"cast to timestamp and check for overflow"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:str]):bat[:timestamp] ",	"batstr_2_timestamp;",	"Cast to timestamp"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:str],digits:int):bat[:timestamp] ",	"batstr_2time_timestamp;",	"cast to timestamp and check for overflow"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:str],digits:int,has_tz:int):bat[:timestamp] ",	"batstr_2time_timestamptz;",	"cast to timestamp and check for overflow"	]
[ "batcalc",	"timestamp",	"command batcalc.timestamp(v:bat[:timestamp],digits:int):bat[:timestamp] ",	"battimestamp_2time_timestamp;",	"cast timestamp to timestamp and check for overflow"	]
[ "batcalc",	"uuid",	"function batcalc.uuid(u:bat[:uuid]):bat[:uuid];",	"",	""	]
[ "batcalc",	"wkb",	"command batcalc.wkb(geo:bat[:wkb],columnType:int,columnSRID:int):bat[:wkb] ",	"geom_2_geom_bat;",	"Called when inserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition"	]
[ "batcalc",	"xml",	"command batcalc.xml(src:bat[:str]):bat[:xml] ",	"BATXMLstr2xml;",	""	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bit],b2:bat[:bit]):bat[:bit] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bte],b2:bat[:bte]):bat[:bte] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:hge],b2:bat[:hge]):bat[:hge] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:int],b2:bat[:int]):bat[:int] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:lng],b2:bat[:lng]):bat[:lng] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:sht],b2:bat[:sht]):bat[:sht] ",	"CMDbatXOR;",	"Return B1 XOR B2"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatXOR;",	"Return B1 XOR B2 with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bit],v:bit):bat[:bit] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bte],v:bte):bat[:bte] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:hge],v:hge):bat[:hge] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:hge],v:hge,s:bat[:oid]):bat[:hge] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:int],v:int):bat[:int] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:int],v:int,s:bat[:oid]):bat[:int] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:lng],v:lng):bat[:lng] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:sht],v:sht):bat[:sht] ",	"CMDbatXOR;",	"Return B XOR V"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] ",	"CMDbatXOR;",	"Return B XOR V with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bit,b:bat[:bit]):bat[:bit] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bte,b:bat[:bte]):bat[:bte] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:hge,b:bat[:hge]):bat[:hge] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:hge,b:bat[:hge],s:bat[:oid]):bat[:hge] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:int,b:bat[:int]):bat[:int] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:int,b:bat[:int],s:bat[:oid]):bat[:int] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:lng,b:bat[:lng]):bat[:lng] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:sht,b:bat[:sht]):bat[:sht] ",	"CMDbatXOR;",	"Return V XOR B"	]
[ "batcalc",	"xor",	"pattern batcalc.xor(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] ",	"CMDbatXOR;",	"Return V XOR B with candidates list"	]
[ "batcolor",	"blue",	"command batcolor.blue(c:bat[:color]):bat[:int] ",	"CLRbatBlue;",	"Extracts blue component from a color atom"	]
[ "batcolor",	"cb",	"command batcolor.cb(c:bat[:color]):bat[:int] ",	"CLRbatCb;",	"Extracts Cb(blue color) component from a color atom"	]
[ "batcolor",	"color",	"command batcolor.color(s:bat[:str]):bat[:color] ",	"CLRbatColor;",	"Converts string to color"	]
[ "batcolor",	"cr",	"command batcolor.cr(c:bat[:color]):bat[:int] ",	"CLRbatCr;",	"Extracts Cr(red color) component from a color atom"	]
[ "batcolor",	"green",	"command batcolor.green(c:bat[:color]):bat[:int] ",	"CLRbatGreen;",	"Extracts green component from a color atom"	]
[ "batcolor",	"hsv",	"command batcolor.hsv(h:bat[:flt],s:bat[:flt],v:bat[:flt]):bat[:color] ",	"CLRbatHsv;",	"Converts an HSV triplets to a color atom"	]
[ "batcolor",	"hue",	"command batcolor.hue(c:bat[:color]):bat[:flt] ",	"CLRbatHue;",	"Extracts hue component from a color atom"	]
[ "batcolor",	"hue",	"command batcolor.hue(c:bat[:color]):bat[:int] ",	"CLRbatHueInt;",	"Extracts hue component from a color atom"	]
[ "batcolor",	"luminance",	"command batcolor.luminance(c:bat[:color]):bat[:int] ",	"CLRbatLuminance;",	"Extracts Y(luminance) component from a color atom"	]
[ "batcolor",	"red",	"command batcolor.red(c:bat[:color]):bat[:int] ",	"CLRbatRed;",	"Extracts red component from a color atom"	]
[ "batcolor",	"rgb",	"command batcolor.rgb(r:bat[:int],g:bat[:int],b:bat[:int]):bat[:color] ",	"CLRbatRgb;",	"Converts an RGB triplets to a color atom"	]
[ "batcolor",	"saturation",	"command batcolor.saturation(c:bat[:color]):bat[:flt] ",	"CLRbatSaturation;",	"Extracts saturation component from a color atom"	]
[ "batcolor",	"saturation",	"command batcolor.saturation(c:bat[:color]):bat[:int] ",	"CLRbatSaturationInt;",	"Extracts saturation component from a color atom"	]
[ "batcolor",	"str",	"command batcolor.str(b:bat[:color]):bat[:str] ",	"CLRbatStr;",	"Identity mapping for string bats"	]
[ "batcolor",	"value",	"command batcolor.value(c:bat[:color]):bat[:flt] ",	"CLRbatValue;",	"Extracts value component from a color atom"	]
[ "batcolor",	"value",	"command batcolor.value(c:bat[:color]):bat[:int] ",	"CLRbatValueInt;",	"Extracts value component from a color atom"	]
[ "batcolor",	"ycc",	"command batcolor.ycc(y:bat[:flt],cr:bat[:flt],cb:bat[:flt]):bat[:color] ",	"CLRbatycc;",	"Converts an YCC triplets to a color atom"	]
[ "batgeom",	"AsEWKT",	"function batgeom.AsEWKT(w:bat[:wkb]):bat[:str];",	"",	""	]
[ "batgeom",	"AsText",	"function batgeom.AsText(w:bat[:wkb]):bat[:str];",	"",	""	]
[ "batgeom",	"Boundary",	"command batgeom.Boundary(w:bat[:wkb]):bat[:wkb] ",	"wkbBoundary_bat;",	""	]
[ "batgeom",	"Contains",	"command batgeom.Contains(a:bat[:wkb],b:bat[:wkb]):bat[:bit] ",	"wkbContains_bat;",	""	]
[ "batgeom",	"Contains",	"command batgeom.Contains(a:bat[:wkb],b:wkb):bat[:bit] ",	"wkbContains_bat_geom;",	""	]
[ "batgeom",	"Contains",	"command batgeom.Contains(a:wkb,b:bat[:wkb]):bat[:bit] ",	"wkbContains_geom_bat;",	""	]
[ "batgeom",	"Dimension",	"command batgeom.Dimension(w:bat[:wkb]):bat[:int] ",	"wkbDimension_bat;",	""	]
[ "batgeom",	"Distance",	"command batgeom.Distance(a:bat[:wkb],b:bat[:wkb]):bat[:dbl] ",	"wkbDistance_bat;",	""	]
[ "batgeom",	"Distance",	"command batgeom.Distance(a:bat[:wkb],b:wkb):bat[:dbl] ",	"wkbDistance_bat_geom;",	""	]
[ "batgeom",	"Distance",	"command batgeom.Distance(a:wkb,b:bat[:wkb]):bat[:dbl] ",	"wkbDistance_geom_bat;",	""	]
[ "batgeom",	"Filter",	"command batgeom.Filter(a:bat[:wkb],b:wkb):bat[:wkb] ",	"wkbFilter_bat_geom;",	""	]
[ "batgeom",	"Filter",	"command batgeom.Filter(a:wkb,b:bat[:wkb]):bat[:wkb] ",	"wkbFilter_geom_bat;",	"Filters the points in the bats according to the MBR of the other bat."	]
[ "batgeom",	"FromText",	"command batgeom.FromText(wkt:bat[:str],srid:int,type:int):bat[:wkb] ",	"wkbFromText_bat;",	""	]
[ "batgeom",	"GeomCollFromText",	"function batgeom.GeomCollFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"GeomCollFromText",	"function batgeom.GeomCollFromText(wkt:bat[:str],srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"GeomFromText",	"function batgeom.GeomFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"GeomFromText",	"function batgeom.GeomFromText(wkt:bat[:str],srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"GeometryN",	"command batgeom.GeometryN(w:bat[:wkb],n:int):bat[:wkb] ",	"wkbGeometryN_bat;",	"Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON. Otherwise, return NULL"	]
[ "batgeom",	"GeometryType",	"command batgeom.GeometryType(w:bat[:wkb],flag:int):bat[:str] ",	"wkbGeometryType_bat;",	""	]
[ "batgeom",	"GeometryType1",	"function batgeom.GeometryType1(w:bat[:wkb]):bat[:str];",	"",	""	]
[ "batgeom",	"GeometryType2",	"function batgeom.GeometryType2(w:bat[:wkb]):bat[:str];",	"",	""	]
[ "batgeom",	"GetCoordinate",	"command batgeom.GetCoordinate(w:bat[:wkb],idx:int):bat[:dbl] ",	"wkbGetCoordinate_bat;",	"Returns the coordinate at position idx of a point, or NULL if not available. idx=0 -> X, idx=1 -> Y, idx=2 -> Z. Input must be point"	]
[ "batgeom",	"IsClosed",	"command batgeom.IsClosed(w:bat[:wkb]):bat[:bit] ",	"wkbIsClosed_bat;",	""	]
[ "batgeom",	"IsEmpty",	"command batgeom.IsEmpty(w:bat[:wkb]):bat[:bit] ",	"wkbIsEmpty_bat;",	""	]
[ "batgeom",	"IsRing",	"command batgeom.IsRing(w:bat[:wkb]):bat[:bit] ",	"wkbIsRing_bat;",	""	]
[ "batgeom",	"IsSimple",	"command batgeom.IsSimple(w:bat[:wkb]):bat[:bit] ",	"wkbIsSimple_bat;",	""	]
[ "batgeom",	"IsValid",	"command batgeom.IsValid(w:bat[:wkb]):bat[:bit] ",	"wkbIsValid_bat;",	""	]
[ "batgeom",	"LineFromText",	"function batgeom.LineFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"LineFromText",	"function batgeom.LineFromText(wkt:bat[:str],srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"MLineFromText",	"function batgeom.MLineFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MLineFromText",	"function batgeom.MLineFromText(wkt:bat[:str],srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"MPointFromText",	"function batgeom.MPointFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MPointFromText",	"function batgeom.MPointFromText(wkt:bat[:str],srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"MPolyFromText",	"function batgeom.MPolyFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MPolyFromText",	"function batgeom.MPolyFromText(wkt:bat[:str],srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"MakeBox2D",	"command batgeom.MakeBox2D(p1:bat[:wkb],p2:bat[:wkb]):bat[:mbr] ",	"wkbBox2D_bat;",	""	]
[ "batgeom",	"MakeLine",	"command batgeom.MakeLine(a:bat[:wkb],b:bat[:wkb]):bat[:wkb] ",	"wkbMakeLine_bat;",	"Gets two BATS of point or linestring geometries and returns a bat with linestring geometries"	]
[ "batgeom",	"MakePoint",	"function batgeom.MakePoint(x:bat[:dbl],y:bat[:dbl]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MakePoint",	"function batgeom.MakePoint(x:bat[:dbl],y:bat[:dbl],z:bat[:dbl]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MakePoint",	"function batgeom.MakePoint(x:bat[:dbl],y:bat[:dbl],z:bat[:dbl],m:bat[:dbl]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MakePointM",	"function batgeom.MakePointM(x:bat[:dbl],y:bat[:dbl],m:bat[:dbl]):bat[:wkb];",	"",	""	]
[ "batgeom",	"MakePointXYZM",	"command batgeom.MakePointXYZM(x:bat[:dbl],y:bat[:dbl],z:bat[:dbl],m:bat[:dbl],zmFlag:int):bat[:wkb] ",	"wkbMakePoint_bat;",	"creates a point using the coordinates"	]
[ "batgeom",	"NPoints",	"function batgeom.NPoints(w:bat[:wkb]):bat[:int];",	"",	""	]
[ "batgeom",	"NRings",	"function batgeom.NRings(w:bat[:wkb]):bat[:int];",	"",	""	]
[ "batgeom",	"NumGeometries",	"command batgeom.NumGeometries(w:bat[:wkb]):bat[:int] ",	"wkbNumGeometries_bat;",	"Returns the number of geometries"	]
[ "batgeom",	"NumInteriorRings",	"function batgeom.NumInteriorRings(w:bat[:wkb]):bat[:int];",	"",	""	]
[ "batgeom",	"NumPoints",	"function batgeom.NumPoints(w:bat[:wkb]):bat[:int];",	"",	""	]
[ "batgeom",	"NumRings",	"command batgeom.NumRings(w:bat[:wkb],exterior:int):bat[:int] ",	"wkbNumRings_bat;",	"Returns the number of interior rings+exterior on the first polygon of the geometry"	]
[ "batgeom",	"PointFromText",	"function batgeom.PointFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"PointFromText",	"function batgeom.PointFromText(wkt:bat[:str],srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"PointsNum",	"command batgeom.PointsNum(w:bat[:wkb],check:int):bat[:int] ",	"wkbNumPoints_bat;",	"The number of points in the Geometry. If check=1, the geometry should be a linestring"	]
[ "batgeom",	"PolygonFromText",	"function batgeom.PolygonFromText(wkt:bat[:str]):bat[:wkb];",	"",	""	]
[ "batgeom",	"PolygonFromText",	"function batgeom.PolygonFromText(wkt:bat[:str],srid:int):bat[:wkb];",	"",	""	]
[ "batgeom",	"ToText",	"command batgeom.ToText(w:bat[:wkb],withSRID:int):bat[:str] ",	"wkbAsText_bat;",	""	]
[ "batgeom",	"Union",	"command batgeom.Union(a:bat[:wkb],b:bat[:wkb]):bat[:wkb] ",	"wkbUnion_bat;",	"Gets two BATS of geometries and returns the pairwise unions"	]
[ "batgeom",	"X",	"function batgeom.X(w:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"XMaxFromMBR",	"function batgeom.XMaxFromMBR(b:bat[:mbr]):bat[:dbl];",	"",	""	]
[ "batgeom",	"XMaxFromWKB",	"function batgeom.XMaxFromWKB(g:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"XMinFromMBR",	"function batgeom.XMinFromMBR(b:bat[:mbr]):bat[:dbl];",	"",	""	]
[ "batgeom",	"XMinFromWKB",	"function batgeom.XMinFromWKB(g:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"Y",	"function batgeom.Y(w:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"YMaxFromMBR",	"function batgeom.YMaxFromMBR(b:bat[:mbr]):bat[:dbl];",	"",	""	]
[ "batgeom",	"YMaxFromWKB",	"function batgeom.YMaxFromWKB(g:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"YMinFromMBR",	"function batgeom.YMinFromMBR(b:bat[:mbr]):bat[:dbl];",	"",	""	]
[ "batgeom",	"YMinFromWKB",	"function batgeom.YMinFromWKB(g:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"Z",	"function batgeom.Z(w:bat[:wkb]):bat[:dbl];",	"",	""	]
[ "batgeom",	"coordinateFromMBR",	"command batgeom.coordinateFromMBR(X_0:bat[:mbr],X_1:int):bat[:dbl] ",	"wkbCoordinateFromMBR_bat;",	"returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided mbr"	]
[ "batgeom",	"coordinateFromWKB",	"command batgeom.coordinateFromWKB(X_0:bat[:wkb],X_1:int):bat[:dbl] ",	"wkbCoordinateFromWKB_bat;",	"returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided geometry"	]
[ "batgeom",	"mbr",	"command batgeom.mbr(X_0:bat[:wkb]):bat[:mbr] ",	"wkbMBR_bat;",	"Creates the mbr for the given wkb."	]
[ "batgeom",	"setSRID",	"command batgeom.setSRID(w:bat[:wkb],srid:int):bat[:wkb] ",	"wkbSetSRID_bat;",	"Sets the Reference System ID for this Geometry."	]
[ "batgsl",	"chi2prob",	"command batgsl.chi2prob(d:bat[:dbl],i:bat[:dbl]):bat[:dbl] ",	"GSLbat_chisqProb_bat;",	"Chi Squared probability"	]
[ "batgsl",	"chi2prob",	"command batgsl.chi2prob(d:bat[:dbl],i:dbl):bat[:dbl] ",	"GSLbat_chisqProb_cst;",	"Chi Squared probability"	]
[ "batgsl",	"chi2prob",	"command batgsl.chi2prob(d:dbl,i:bat[:dbl]):bat[:dbl] ",	"GSLcst_chisqProb_bat;",	"Chi Squared probability"	]
[ "batmal",	"multiplex",	"pattern batmal.multiplex(mod:str,fcn:str,a:any...):any... ",	"MANIFOLDremapMultiplex;",	""	]
[ "batmkey",	"hash",	"command batmkey.hash(b:bat[:any_1]):bat[:lng] ",	"MKEYbathash;",	"calculate a hash value"	]
[ "batmmath",	"acos",	"command batmmath.acos(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_acos;",	""	]
[ "batmmath",	"acos",	"command batmmath.acos(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_acos;",	""	]
[ "batmmath",	"asin",	"command batmmath.asin(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_asin;",	""	]
[ "batmmath",	"asin",	"command batmmath.asin(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_asin;",	""	]
[ "batmmath",	"atan",	"command batmmath.atan(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_atan;",	""	]
[ "batmmath",	"atan",	"command batmmath.atan(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_atan;",	""	]
[ "batmmath",	"atan2",	"command batmmath.atan2(x:bat[:dbl],y:dbl):bat[:dbl] ",	"CMDscience_bat_cst_atan2_dbl;",	""	]
[ "batmmath",	"atan2",	"command batmmath.atan2(x:bat[:flt],y:flt):bat[:flt] ",	"CMDscience_bat_cst_atan2_flt;",	""	]
[ "batmmath",	"atan2",	"command batmmath.atan2(x:dbl,y:bat[:dbl]):bat[:dbl] ",	"CMDscience_cst_bat_atan2_dbl;",	""	]
[ "batmmath",	"atan2",	"command batmmath.atan2(x:flt,y:bat[:flt]):bat[:flt] ",	"CMDscience_cst_bat_atan2_flt;",	""	]
[ "batmmath",	"ceil",	"command batmmath.ceil(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_ceil;",	""	]
[ "batmmath",	"ceil",	"command batmmath.ceil(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_ceil;",	""	]
[ "batmmath",	"cos",	"command batmmath.cos(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_cos;",	""	]
[ "batmmath",	"cos",	"command batmmath.cos(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_cos;",	""	]
[ "batmmath",	"cosh",	"command batmmath.cosh(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_cosh;",	""	]
[ "batmmath",	"cosh",	"command batmmath.cosh(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_cosh;",	""	]
[ "batmmath",	"degrees",	"command batmmath.degrees(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_degrees;",	""	]
[ "batmmath",	"degrees",	"command batmmath.degrees(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_degrees;",	""	]
[ "batmmath",	"exp",	"command batmmath.exp(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_exp;",	""	]
[ "batmmath",	"exp",	"command batmmath.exp(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_exp;",	""	]
[ "batmmath",	"fabs",	"command batmmath.fabs(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_fabs;",	""	]
[ "batmmath",	"fabs",	"command batmmath.fabs(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_fabs;",	""	]
[ "batmmath",	"floor",	"command batmmath.floor(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_floor;",	""	]
[ "batmmath",	"floor",	"command batmmath.floor(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_floor;",	""	]
[ "batmmath",	"fmod",	"pattern batmmath.fmod(x:bat[:dbl],y:dbl):bat[:dbl] ",	"CMDbatMODsignal;",	""	]
[ "batmmath",	"fmod",	"pattern batmmath.fmod(x:bat[:flt],y:flt):bat[:flt] ",	"CMDbatMODsignal;",	""	]
[ "batmmath",	"log",	"command batmmath.log(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_log;",	""	]
[ "batmmath",	"log",	"command batmmath.log(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_log;",	""	]
[ "batmmath",	"log10",	"command batmmath.log10(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_log10;",	""	]
[ "batmmath",	"log10",	"command batmmath.log10(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_log10;",	""	]
[ "batmmath",	"pow",	"command batmmath.pow(x:bat[:dbl],y:dbl):bat[:dbl] ",	"CMDscience_bat_cst_pow_dbl;",	""	]
[ "batmmath",	"pow",	"command batmmath.pow(x:bat[:flt],y:flt):bat[:flt] ",	"CMDscience_bat_cst_pow_flt;",	""	]
[ "batmmath",	"pow",	"command batmmath.pow(x:dbl,y:bat[:dbl]):bat[:dbl] ",	"CMDscience_cst_bat_pow_dbl;",	""	]
[ "batmmath",	"pow",	"command batmmath.pow(x:flt,y:bat[:flt]):bat[:flt] ",	"CMDscience_cst_bat_pow_flt;",	""	]
[ "batmmath",	"radians",	"command batmmath.radians(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_radians;",	""	]
[ "batmmath",	"radians",	"command batmmath.radians(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_radians;",	""	]
[ "batmmath",	"sin",	"command batmmath.sin(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_sin;",	""	]
[ "batmmath",	"sin",	"command batmmath.sin(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_sin;",	""	]
[ "batmmath",	"sinh",	"command batmmath.sinh(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_sinh;",	""	]
[ "batmmath",	"sinh",	"command batmmath.sinh(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_sinh;",	""	]
[ "batmmath",	"sqrt",	"command batmmath.sqrt(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_sqrt;",	""	]
[ "batmmath",	"sqrt",	"command batmmath.sqrt(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_sqrt;",	""	]
[ "batmmath",	"tan",	"command batmmath.tan(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_tan;",	""	]
[ "batmmath",	"tan",	"command batmmath.tan(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_tan;",	""	]
[ "batmmath",	"tanh",	"command batmmath.tanh(x:bat[:dbl]):bat[:dbl] ",	"CMDscience_bat_dbl_tanh;",	""	]
[ "batmmath",	"tanh",	"command batmmath.tanh(x:bat[:flt]):bat[:flt] ",	"CMDscience_bat_flt_tanh;",	""	]
[ "batmtime",	"day",	"command batmtime.day(d:bat[:date]):bat[:int] ",	"MTIMEdate_extract_day_bulk;",	""	]
[ "batmtime",	"diff",	"command batmtime.diff(b1:bat[:date],b2:bat[:date]):bat[:int] ",	"MTIMEdate_diff_bulk;",	"Difference of two sets of date."	]
[ "batmtime",	"diff",	"command batmtime.diff(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:lng] ",	"MTIMEtimestamp_diff_bulk;",	"Difference of two sets of timestamp."	]
[ "batmtime",	"hours",	"command batmtime.hours(d:bat[:daytime]):bat[:int] ",	"MTIMEdaytime_extract_hours_bulk;",	""	]
[ "batmtime",	"milliseconds",	"command batmtime.milliseconds(d:bat[:daytime]):bat[:int] ",	"MTIMEdaytime_extract_milliseconds_bulk;",	""	]
[ "batmtime",	"minutes",	"command batmtime.minutes(d:bat[:daytime]):bat[:int] ",	"MTIMEdaytime_extract_minutes_bulk;",	""	]
[ "batmtime",	"month",	"command batmtime.month(d:bat[:date]):bat[:int] ",	"MTIMEdate_extract_month_bulk;",	""	]
[ "batmtime",	"seconds",	"command batmtime.seconds(d:bat[:daytime]):bat[:int] ",	"MTIMEdaytime_extract_seconds_bulk;",	""	]
[ "batmtime",	"sql_seconds",	"command batmtime.sql_seconds(d:bat[:daytime]):bat[:int] ",	"MTIMEdaytime_extract_sql_seconds_bulk;",	""	]
[ "batmtime",	"year",	"command batmtime.year(d:bat[:date]):bat[:int] ",	"MTIMEdate_extract_year_bulk;",	""	]
[ "batpyapi",	"eval",	"pattern batpyapi.eval(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalStd;",	"Execute a simple Python script value"	]
[ "batpyapi",	"eval_aggr",	"pattern batpyapi.eval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalAggr;",	"grouped aggregates through Python"	]
[ "batpyapi",	"eval_loader",	"pattern batpyapi.eval_loader(fptr:ptr,expr:str):any... ",	"PyAPIevalLoader;",	"loader functions through Python"	]
[ "batpyapi",	"eval_loader",	"pattern batpyapi.eval_loader(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalLoader;",	"loader functions through Python"	]
[ "batpyapi",	"subeval_aggr",	"pattern batpyapi.subeval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalAggr;",	"grouped aggregates through Python"	]
[ "batpyapimap",	"eval",	"pattern batpyapimap.eval(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalStdMap;",	"Execute a simple Python script value"	]
[ "batpyapimap",	"eval_aggr",	"pattern batpyapimap.eval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalAggrMap;",	"grouped aggregates through Python"	]
[ "batpyapimap",	"subeval_aggr",	"pattern batpyapimap.subeval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalAggrMap;",	"grouped aggregates through Python"	]
[ "batrapi",	"eval",	"pattern batrapi.eval(fptr:ptr,expr:str,arg:any...):any... ",	"RAPIevalStd;",	"Execute a simple R script value"	]
[ "batrapi",	"eval_aggr",	"pattern batrapi.eval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"RAPIevalAggr;",	"grouped aggregates through R"	]
[ "batrapi",	"subeval_aggr",	"pattern batrapi.subeval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"RAPIevalAggr;",	"grouped aggregates through R"	]
[ "batsql",	"alpha",	"command batsql.alpha(dec:bat[:dbl],theta:dbl):bat[:dbl] ",	"SQLbat_alpha_cst;",	"BAT implementation of astronomy alpha function"	]
[ "batsql",	"alpha",	"command batsql.alpha(dec:dbl,theta:bat[:dbl]):bat[:dbl] ",	"SQLcst_alpha_bat;",	"BAT implementation of astronomy alpha function"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:bte],r:bte):bat[:bte] ",	"bte_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:dbl],r:dbl):bat[:dbl] ",	"dbl_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:flt],r:flt):bat[:flt] ",	"flt_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:hge],r:hge):bat[:hge] ",	"hge_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:int],r:int):bat[:int] ",	"int_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:lng],r:lng):bat[:lng] ",	"lng_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dec_round",	"command batsql.dec_round(v:bat[:sht],r:sht):bat[:sht] ",	"sht_bat_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "batsql",	"dense_rank",	"pattern batsql.dense_rank(b:bat[:any_1],p:any_2,o:any_3):bat[:int] ",	"SQLdense_rank;",	"return the densely ranked groups"	]
[ "batsql",	"diff",	"pattern batsql.diff(b:bat[:any_1]):bat[:bit] ",	"SQLdiff;",	"return true if cur != prev row"	]
[ "batsql",	"diff",	"pattern batsql.diff(p:bat[:bit],b:bat[:any_1]):bat[:bit] ",	"SQLdiff;",	"return true if cur != prev row"	]
[ "batsql",	"next_value",	"pattern batsql.next_value(sname:bat[:str],sequence:str):bat[:lng] ",	"mvc_bat_next_value;",	"return the next value of the sequence"	]
[ "batsql",	"rank",	"pattern batsql.rank(b:bat[:any_1],p:any_2,o:any_3):bat[:int] ",	"SQLrank;",	"return the ranked groups"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:bte],d:int,s:int,r:bte):bat[:bte] ",	"bte_bat_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:dbl],r:bte):bat[:dbl] ",	"dbl_bat_round_wrap;",	"round off the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:flt],r:bte):bat[:flt] ",	"flt_bat_round_wrap;",	"round off the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:hge],d:int,s:int,r:bte):bat[:hge] ",	"hge_bat_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:int],d:int,s:int,r:bte):bat[:int] ",	"int_bat_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:lng],d:int,s:int,r:bte):bat[:lng] ",	"lng_bat_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"round",	"command batsql.round(v:bat[:sht],d:int,s:int,r:bte):bat[:sht] ",	"sht_bat_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "batsql",	"row_number",	"pattern batsql.row_number(b:bat[:any_1],p:any_2,o:any_3):bat[:int] ",	"SQLrow_number;",	"return the row_numer-ed groups"	]
[ "batstr",	"endsWith",	"command batstr.endsWith(s:bat[:str],suffix:bat[:str]):bat[:bit] ",	"STRbatSuffix;",	"Suffix check."	]
[ "batstr",	"endsWith",	"command batstr.endsWith(s:bat[:str],suffix:str):bat[:bit] ",	"STRbatSuffixcst;",	"Suffix check."	]
[ "batstr",	"length",	"command batstr.length(s:bat[:str]):bat[:int] ",	"STRbatLength;",	"Return the length of a string."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str],n:bat[:int],s2:bat[:str]):bat[:str] ",	"STRbatLpad2_bat_bat;",	"Prepend the second strings to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str],n:bat[:int],s2:str):bat[:str] ",	"STRbatLpad2_bat_const;",	"Prepend the second string to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str],n:int,s2:bat[:str]):bat[:str] ",	"STRbatLpad2_const_bat;",	"Prepend the second strings to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str],n:int,s2:str):bat[:str] ",	"STRbatLpad2_const_const;",	"Prepend the second string to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str],n:bat[:int]):bat[:str] ",	"STRbatLpad_bat;",	"Prepend whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"lpad",	"command batstr.lpad(s:bat[:str],n:int):bat[:str] ",	"STRbatLpad_const;",	"Prepend whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"ltrim",	"command batstr.ltrim(s:bat[:str],s2:bat[:str]):bat[:str] ",	"STRbatLtrim2_bat;",	"Strip characters in the second strings from start of the first strings."	]
[ "batstr",	"ltrim",	"command batstr.ltrim(s:bat[:str],s2:str):bat[:str] ",	"STRbatLtrim2_const;",	"Strip characters in the second string from start of the first strings."	]
[ "batstr",	"ltrim",	"command batstr.ltrim(s:bat[:str]):bat[:str] ",	"STRbatLtrim;",	"Strip whitespaces from start of a string."	]
[ "batstr",	"nbytes",	"command batstr.nbytes(s:bat[:str]):bat[:int] ",	"STRbatBytes;",	"Return the string length in bytes."	]
[ "batstr",	"r_search",	"command batstr.r_search(s:bat[:str],c:bat[:str]):bat[:int] ",	"STRbatRstrSearch;",	"Reverse search for a substring. Returns position, -1 if not found."	]
[ "batstr",	"r_search",	"command batstr.r_search(s:bat[:str],c:str):bat[:int] ",	"STRbatRstrSearchcst;",	"Reverse search for a substring. Returns position, -1 if not found."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str],n:bat[:int],s2:bat[:str]):bat[:str] ",	"STRbatRpad2_bat_bat;",	"Append the second strings to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str],n:bat[:int],s2:str):bat[:str] ",	"STRbatRpad2_bat_const;",	"Append the second string to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str],n:int,s2:bat[:str]):bat[:str] ",	"STRbatRpad2_const_bat;",	"Append the second strings to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str],n:int,s2:str):bat[:str] ",	"STRbatRpad2_const_const;",	"Append the second string to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str],n:bat[:int]):bat[:str] ",	"STRbatRpad_bat;",	"Append whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths."	]
[ "batstr",	"rpad",	"command batstr.rpad(s:bat[:str],n:int):bat[:str] ",	"STRbatRpad_const;",	"Append whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length."	]
[ "batstr",	"rtrim",	"command batstr.rtrim(s:bat[:str],s2:bat[:str]):bat[:str] ",	"STRbatRtrim2_bat;",	"Strip characters in the second strings from end of the first strings."	]
[ "batstr",	"rtrim",	"command batstr.rtrim(s:bat[:str],s2:str):bat[:str] ",	"STRbatRtrim2_const;",	"Strip characters in the second string from end of the first strings."	]
[ "batstr",	"rtrim",	"command batstr.rtrim(s:bat[:str]):bat[:str] ",	"STRbatRtrim;",	"Strip whitespaces from end of a string."	]
[ "batstr",	"search",	"command batstr.search(s:bat[:str],c:bat[:str]):bat[:int] ",	"STRbatstrSearch;",	"Search for a substring. Returns position, -1 if not found."	]
[ "batstr",	"search",	"command batstr.search(s:bat[:str],c:str):bat[:int] ",	"STRbatstrSearchcst;",	"Search for a substring. Returns position, -1 if not found."	]
[ "batstr",	"startsWith",	"command batstr.startsWith(s:bat[:str],prefix:bat[:str]):bat[:bit] ",	"STRbatPrefix;",	"Prefix check."	]
[ "batstr",	"startsWith",	"command batstr.startsWith(s:bat[:str],prefix:str):bat[:bit] ",	"STRbatPrefixcst;",	"Prefix check."	]
[ "batstr",	"string",	"command batstr.string(b:bat[:str],offset:bat[:int]):bat[:str] ",	"STRbatTail;",	"Return the tail s[offset..n] of a string s[0..n]."	]
[ "batstr",	"string",	"command batstr.string(b:bat[:str],offset:int):bat[:str] ",	"STRbatTailcst;",	"Return the tail s[offset..n] of a string s[0..n]."	]
[ "batstr",	"substitute",	"command batstr.substitute(s:bat[:str],src:str,dst:str,rep:bit):bat[:str] ",	"STRbatSubstitutecst;",	"Substitute first occurrence of 'src' by\n\t'dst'.  Iff repeated = true this is\n\trepeated while 'src' can be found in the\n\tresult string. In order to prevent\n\trecursion and result strings of unlimited\n\tsize, repeating is only done iff src is\n\tnot a substring of dst."	]
[ "batstr",	"substring",	"command batstr.substring(s:bat[:str],start:bat[:int],index:bat[:int]):bat[:str] ",	"STRbatsubstring;",	"Substring extraction using [start,start+length]"	]
[ "batstr",	"substring",	"command batstr.substring(s:bat[:str],start:int,index:int):bat[:str] ",	"STRbatsubstringcst;",	"Substring extraction using [start,start+length]"	]
[ "batstr",	"toLower",	"command batstr.toLower(s:bat[:str]):bat[:str] ",	"STRbatLower;",	"Convert a string to lower case."	]
[ "batstr",	"toUpper",	"command batstr.toUpper(s:bat[:str]):bat[:str] ",	"STRbatUpper;",	"Convert a string to upper case."	]
[ "batstr",	"trim",	"command batstr.trim(s:bat[:str],s2:bat[:str]):bat[:str] ",	"STRbatStrip2_bat;",	"Strip characters in the second strings around the first strings."	]
[ "batstr",	"trim",	"command batstr.trim(s:bat[:str],s2:str):bat[:str] ",	"STRbatStrip2_const;",	"Strip characters in the second string around the first strings."	]
[ "batstr",	"trim",	"command batstr.trim(s:bat[:str]):bat[:str] ",	"STRbatStrip;",	"Strip whitespaces around a string."	]
[ "batstr",	"unicodeAt",	"command batstr.unicodeAt(s:bat[:str],index:bat[:int]):bat[:int] ",	"STRbatWChrAt;",	"get a unicode character (as an int) from a string position."	]
[ "batstr",	"unicodeAt",	"command batstr.unicodeAt(s:bat[:str],index:int):bat[:int] ",	"STRbatWChrAtcst;",	"get a unicode character (as an int) from a string position."	]
[ "batudf",	"fuse",	"command batudf.fuse(one:bat[:bte],two:bat[:bte]):bat[:sht] ",	"UDFBATfuse;",	"fuse two (1-byte) bte values into one (2-byte) sht value"	]
[ "batudf",	"fuse",	"command batudf.fuse(one:bat[:int],two:bat[:int]):bat[:lng] ",	"UDFBATfuse;",	"fuse two (4-byte) int values into one (8-byte) lng value"	]
[ "batudf",	"fuse",	"command batudf.fuse(one:bat[:lng],two:bat[:lng]):bat[:hge] ",	"UDFBATfuse;",	"fuse two (8-byte) lng values into one (16-byte) hge value"	]
[ "batudf",	"fuse",	"command batudf.fuse(one:bat[:sht],two:bat[:sht]):bat[:int] ",	"UDFBATfuse;",	"fuse two (2-byte) sht values into one (4-byte) int value"	]
[ "batudf",	"reverse",	"command batudf.reverse(b:bat[:str]):bat[:str] ",	"UDFBATreverse;",	"Reverse a BAT of strings"	]
[ "batxml",	"attribute",	"command batxml.attribute(name:str,val:bat[:str]):bat[:xml] ",	"BATXMLattribute;",	"Construct an attribute value pair."	]
[ "batxml",	"comment",	"command batxml.comment(val:bat[:str]):bat[:xml] ",	"BATXMLcomment;",	"Create an XML comment element."	]
[ "batxml",	"concat",	"command batxml.concat(left:bat[:xml],right:bat[:xml]):bat[:xml] ",	"BATXMLconcat;",	"Concatenate the XML values."	]
[ "batxml",	"content",	"command batxml.content(src:bat[:str]):bat[:xml] ",	"BATXMLcontent;",	"Parse the string as XML element content."	]
[ "batxml",	"document",	"command batxml.document(src:bat[:str]):bat[:xml] ",	"BATXMLdocument;",	"Parse the string as an XML document."	]
[ "batxml",	"element",	"command batxml.element(name:str,ns:xml,attr:xml,s:bat[:xml]):bat[:xml] ",	"BATXMLelement;",	"The basic building block for XML elements are namespaces, attributes and a sequence of XML elements. The name space and the attributes may be left unspecified(=nil)."	]
[ "batxml",	"element",	"command batxml.element(name:str,s:bat[:xml]):bat[:xml] ",	"BATXMLelementSmall;",	"The basic building block for XML elements are namespaces, attributes and a sequence of XML elements. The name space and the attributes may be left unspecified."	]
[ "batxml",	"forest",	"pattern batxml.forest(val:bat[:xml]...):bat[:xml] ",	"BATXMLforest;",	"Construct an element list."	]
[ "batxml",	"isdocument",	"command batxml.isdocument(val:bat[:str]):bat[:bit] ",	"BATXMLisdocument;",	"Validate the string as a XML document."	]
[ "batxml",	"options",	"command batxml.options(tag:str,option:str,left:bat[:xml]):bat[:xml] ",	"BATXMLoptions;",	"Create the components including NULL conversions."	]
[ "batxml",	"parse",	"command batxml.parse(doccont:str,val:bat[:str],option:str):bat[:xml] ",	"BATXMLparse;",	"Parse the XML document or element string values."	]
[ "batxml",	"pi",	"command batxml.pi(target:str,val:bat[:xml]):bat[:xml] ",	"BATXMLpi;",	"Construct a processing instruction."	]
[ "batxml",	"root",	"command batxml.root(val:bat[:xml],version:str,standalone:str):bat[:xml] ",	"BATXMLroot;",	"Contruct the root nodes."	]
[ "batxml",	"serialize",	"command batxml.serialize(val:bat[:xml]):bat[:str] ",	"BATXMLxml2str;",	"Serialize the XML object to a string."	]
[ "batxml",	"str",	"command batxml.str(src:bat[:xml]):bat[:str] ",	"BATXMLxml2str;",	"Cast the xml to a string."	]
[ "batxml",	"text",	"command batxml.text(val:bat[:xml]):bat[:str] ",	"BATXMLxmltext;",	"Serialize the XML object to a string."	]
[ "batxml",	"xml",	"command batxml.xml(src:bat[:str]):bat[:xml] ",	"BATXMLstr2xml;",	"Cast the string to an xml compliant string."	]
[ "batxml",	"xquery",	"command batxml.xquery(val:bat[:str],expr:str):bat[:xml] ",	"BATXMLxquery;",	"Execute the XQuery against the elements."	]
[ "bbp",	"bind",	"pattern bbp.bind(name:str):bat[:any_2] ",	"CMDbbpbind;",	"Locate the BAT using its logical name"	]
[ "bbp",	"get",	"command bbp.get() (id:bat[:int],ns:bat[:str],tt:bat[:str],cnt:bat[:lng],refcnt:bat[:int],lrefcnt:bat[:int],location:bat[:str],heat:bat[:int],dirty:bat[:str],status:bat[:str],kind:bat[:str]) ",	"CMDbbp;",	"bpp"	]
[ "bbp",	"getCount",	"command bbp.getCount():bat[:lng] ",	"CMDbbpCount;",	"Create a BAT with the cardinalities of all known BATs"	]
[ "bbp",	"getDirty",	"command bbp.getDirty():bat[:str] ",	"CMDbbpDirty;",	"Create a BAT with the dirty/ diffs/clean status"	]
[ "bbp",	"getDiskSpace",	"command bbp.getDiskSpace():lng ",	"CMDbbpDiskSpace;",	"Estimate the amount of disk space occupied by dbpath"	]
[ "bbp",	"getIndex",	"command bbp.getIndex(b:bat[:any_2]):int ",	"CMDbbpgetIndex;",	"Retrieve the index in the BBP"	]
[ "bbp",	"getKind",	"command bbp.getKind():bat[:str] ",	"CMDbbpKind;",	"Create a BAT with the persistency status"	]
[ "bbp",	"getLRefCount",	"command bbp.getLRefCount():bat[:int] ",	"CMDbbpLRefCount;",	"Create a BAT with the logical reference counts"	]
[ "bbp",	"getLRefCount",	"command bbp.getLRefCount(b:bat[:any_1]):int ",	"CMDgetBATlrefcnt;",	"Utility for debugging MAL interpreter"	]
[ "bbp",	"getLocation",	"command bbp.getLocation():bat[:str] ",	"CMDbbpLocation;",	"Create a BAT with their disk locations"	]
[ "bbp",	"getName",	"command bbp.getName(b:bat[:any_1]):str ",	"CMDbbpName;",	"Map a BAT into its internal name"	]
[ "bbp",	"getNames",	"command bbp.getNames():bat[:str] ",	"CMDbbpNames;",	"Map BAT into its bbp name"	]
[ "bbp",	"getPageSize",	"command bbp.getPageSize():int ",	"CMDgetPageSize;",	"Obtain the memory page size"	]
[ "bbp",	"getRefCount",	"command bbp.getRefCount():bat[:int] ",	"CMDbbpRefCount;",	"Create a BAT with the (hard) reference counts"	]
[ "bbp",	"getRefCount",	"command bbp.getRefCount(b:bat[:any_1]):int ",	"CMDgetBATrefcnt;",	"Utility for debugging MAL interpreter"	]
[ "bbp",	"getStatus",	"command bbp.getStatus():bat[:str] ",	"CMDbbpStatus;",	"Create a BAT with the disk/load status"	]
[ "bbp",	"setName",	"command bbp.setName(b:bat[:any_1],n:str):str ",	"CMDsetName;",	"Rename a BAT"	]
[ "blob",	"#del",	"command blob.#del():void ",	"BLOBdel;",	""	]
[ "blob",	"#fromstr",	"command blob.#fromstr():void ",	"BLOBfromstr;",	""	]
[ "blob",	"#hash",	"command blob.#hash():void ",	"BLOBhash;",	""	]
[ "blob",	"#heap",	"command blob.#heap():void ",	"BLOBheap;",	""	]
[ "blob",	"#length",	"command blob.#length():void ",	"BLOBlength;",	""	]
[ "blob",	"#nequal",	"command blob.#nequal():void ",	"BLOBnequal;",	""	]
[ "blob",	"#null",	"command blob.#null():void ",	"BLOBnull;",	""	]
[ "blob",	"#put",	"command blob.#put():void ",	"BLOBput;",	""	]
[ "blob",	"#read",	"command blob.#read():void ",	"BLOBread;",	""	]
[ "blob",	"#tostr",	"command blob.#tostr():void ",	"BLOBtostr;",	""	]
[ "blob",	"#write",	"command blob.#write():void ",	"BLOBwrite;",	""	]
[ "blob",	"blob",	"command blob.blob(s:blob):blob ",	"BLOBblob_blob;",	"Noop routine."	]
[ "blob",	"blob",	"command blob.blob(s:str):blob ",	"BLOBblob_fromstr;",	""	]
[ "blob",	"nitems",	"command blob.nitems(b:blob):int ",	"BLOBnitems;",	" get the number of bytes in this blob."	]
[ "blob",	"prelude",	"command blob.prelude():void ",	"BLOBprelude;",	""	]
[ "blob",	"toblob",	"command blob.toblob(v:str):blob ",	"BLOBtoblob;",	"store a string as a blob."	]
[ "blob",	"tostring",	"command blob.tostring(v:blob):str ",	"BLOBfromblob;",	"get the bytes from blob as a string, till\n\tthe first 0 byte or the end of the blob"	]
[ "blob",	"tostring",	"command blob.tostring(v:blob,index:int):str ",	"BLOBfromidx;",	"get the bytes from blob as a string,\n\t starting at byte 'index' till the first\n\t0 byte or the end of the blob."	]
[ "bstream",	"create",	"command bstream.create(s:streams,bufsize:int):bstream ",	"bstream_create_wrapwrap;",	"create a buffered stream"	]
[ "bstream",	"destroy",	"command bstream.destroy(s:bstream):void ",	"bstream_destroy_wrapwrap;",	"destroy bstream"	]
[ "bstream",	"read",	"command bstream.read(s:bstream,size:int):int ",	"bstream_read_wrapwrap;",	"read at least size bytes into the buffer of s"	]
[ "calc",	"!=",	"pattern calc.!=(l:json,r:json):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(l:uuid,r:uuid):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bit,v2:bit):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte,v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte,v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte,v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte,v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte,v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte,v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:bte,v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl,v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl,v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl,v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl,v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl,v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl,v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:dbl,v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt,v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt,v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt,v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt,v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt,v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt,v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:flt,v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge,v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge,v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge,v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge,v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge,v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge,v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:hge,v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int,v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int,v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int,v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int,v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int,v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int,v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:int,v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng,v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng,v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng,v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng,v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng,v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng,v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:lng,v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:oid,v2:oid):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht,v2:bte):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht,v2:dbl):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht,v2:flt):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht,v2:hge):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht,v2:int):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht,v2:lng):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:sht,v2:sht):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v1:str,v2:str):bit ",	"CMDvarNE;",	"Return V1 != V2"	]
[ "calc",	"!=",	"pattern calc.!=(v:date,w:date):bit ",	"CMDvarNE;",	"Equality of two dates"	]
[ "calc",	"!=",	"pattern calc.!=(v:daytime,w:daytime):bit ",	"CMDvarNE;",	"Equality of two daytimes"	]
[ "calc",	"!=",	"pattern calc.!=(v:timestamp,w:timestamp):bit ",	"CMDvarNE;",	"Equality of two timestamps"	]
[ "calc",	"!=",	"command calc.!=(v:inet,w:inet):bit ",	"INET_comp_NEQ;",	"Inequality of two inets"	]
[ "calc",	"%",	"pattern calc.%(v1:bte,v2:bte):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte,v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte,v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte,v2:hge):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte,v2:int):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte,v2:lng):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:bte,v2:sht):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl,v2:bte):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl,v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl,v2:flt):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl,v2:hge):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl,v2:int):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl,v2:lng):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:dbl,v2:sht):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt,v2:bte):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt,v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt,v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt,v2:hge):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt,v2:int):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt,v2:lng):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:flt,v2:sht):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge,v2:bte):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge,v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge,v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge,v2:hge):hge ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge,v2:int):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge,v2:lng):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:hge,v2:sht):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int,v2:bte):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int,v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int,v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int,v2:hge):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int,v2:int):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int,v2:lng):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:int,v2:sht):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng,v2:bte):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng,v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng,v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng,v2:hge):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng,v2:int):int ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng,v2:lng):lng ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:lng,v2:sht):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht,v2:bte):bte ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht,v2:dbl):dbl ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht,v2:flt):flt ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht,v2:hge):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht,v2:int):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht,v2:lng):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"%",	"pattern calc.%(v1:sht,v2:sht):sht ",	"CMDvarMODsignal;",	"Return V1 % V2, signal error on divide by zero"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:bte):bte ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:bte):sht ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:hge):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:int):int ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:int):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:lng):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:lng):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:sht):int ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:bte,v2:sht):sht ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl,v2:bte):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl,v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl,v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl,v2:hge):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl,v2:int):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl,v2:lng):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:dbl,v2:sht):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:bte):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:bte):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:hge):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:hge):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:int):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:int):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:lng):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:lng):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:sht):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:flt,v2:sht):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge,v2:bte):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge,v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge,v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:hge,v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge,v2:hge):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge,v2:int):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge,v2:lng):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:hge,v2:sht):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:bte):int ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:bte):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:hge):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:int):int ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:int):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:lng):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:lng):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:sht):int ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:int,v2:sht):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:bte):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:bte):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:hge):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:int):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:int):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:lng):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:lng):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:sht):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:lng,v2:sht):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:bte):int ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:bte):sht ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:dbl):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:flt):dbl ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:flt):flt ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:hge):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:int):int ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:int):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:lng):hge ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:lng):lng ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:sht):int ",	"CMDvarMULsignal;",	"Return V1 * V2, guarantee no overflow by returning larger type"	]
[ "calc",	"*",	"pattern calc.*(v1:sht,v2:sht):sht ",	"CMDvarMULsignal;",	"Return V1 * V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:bte):bte ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:bte):sht ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:hge):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:int):int ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:int):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:lng):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:lng):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:sht):int ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:bte,v2:sht):sht ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl,v2:bte):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl,v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl,v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl,v2:hge):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl,v2:int):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl,v2:lng):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:dbl,v2:sht):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:bte):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:bte):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:hge):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:hge):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:int):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:int):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:lng):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:lng):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:sht):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:flt,v2:sht):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge,v2:bte):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge,v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge,v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:hge,v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge,v2:hge):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge,v2:int):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge,v2:lng):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:hge,v2:sht):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:bte):int ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:bte):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:hge):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:int):int ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:int):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:lng):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:lng):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:sht):int ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:int,v2:sht):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:bte):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:bte):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:hge):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:int):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:int):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:lng):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:lng):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:sht):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:lng,v2:sht):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:bte):int ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:bte):sht ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:dbl):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:flt):dbl ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:flt):flt ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:hge):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:int):int ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:int):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:lng):hge ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:lng):lng ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:sht):int ",	"CMDvarADDsignal;",	"Return V1 + V2, guarantee no overflow by returning larger type"	]
[ "calc",	"+",	"pattern calc.+(v1:sht,v2:sht):sht ",	"CMDvarADDsignal;",	"Return V1 + V2, signal error on overflow"	]
[ "calc",	"+",	"command calc.+(v1:str,v2:str):str ",	"CMDvarADDstr;",	"Concatenate LEFT and RIGHT"	]
[ "calc",	"+",	"command calc.+(v1:str,i:int):str ",	"CMDvarADDstrint;",	"Concatenate LEFT and string representation of RIGHT"	]
[ "calc",	"++",	"pattern calc.++(v:bte):bte ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:dbl):dbl ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:flt):flt ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:hge):hge ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:int):int ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:lng):lng ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"++",	"pattern calc.++(v:sht):sht ",	"CMDvarINCRsignal;",	"Unary V + 1"	]
[ "calc",	"-",	"pattern calc.-(v:bte):bte ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:dbl):dbl ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:flt):flt ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:hge):hge ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:int):int ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:lng):lng ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v:sht):sht ",	"CMDvarNEG;",	"Unary negation of V"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:bte):bte ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:bte):sht ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:hge):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:int):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:int):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:lng):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:lng):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:sht):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:bte,v2:sht):sht ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl,v2:bte):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl,v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl,v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl,v2:hge):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl,v2:int):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl,v2:lng):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:dbl,v2:sht):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:bte):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:bte):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:hge):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:hge):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:int):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:int):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:lng):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:lng):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:sht):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:flt,v2:sht):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge,v2:bte):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge,v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge,v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:hge,v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge,v2:hge):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge,v2:int):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge,v2:lng):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:hge,v2:sht):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:bte):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:bte):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:hge):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:int):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:int):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:lng):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:lng):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:sht):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:int,v2:sht):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:bte):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:bte):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:hge):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:int):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:int):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:lng):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:lng):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:sht):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:lng,v2:sht):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:bte):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:bte):sht ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:dbl):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:flt):dbl ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:flt):flt ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:hge):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:int):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:int):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:lng):hge ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:lng):lng ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:sht):int ",	"CMDvarSUBsignal;",	"Return V1 - V2, guarantee no overflow by returning larger type"	]
[ "calc",	"-",	"pattern calc.-(v1:sht,v2:sht):sht ",	"CMDvarSUBsignal;",	"Return V1 - V2, signal error on overflow"	]
[ "calc",	"--",	"pattern calc.--(v:bte):bte ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:dbl):dbl ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:flt):flt ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:hge):hge ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:int):int ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:lng):lng ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"--",	"pattern calc.--(v:sht):sht ",	"CMDvarDECRsignal;",	"Unary V - 1"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:bte):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:hge):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:int):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:lng):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:sht):bte ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:bte,v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:dbl,v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:dbl,v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:dbl,v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:dbl,v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:dbl,v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:dbl,v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:dbl,v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:flt,v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:bte):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:hge):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:int):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:lng):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:hge,v2:sht):hge ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:bte):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:hge):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:int):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:lng):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:int,v2:sht):int ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:bte):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:hge):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:int):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:lng):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:lng,v2:sht):lng ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:bte):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:bte):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:bte):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:dbl):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:flt):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:flt):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:hge):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:hge):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:hge):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:int):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:int):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:int):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:lng):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:lng):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:lng):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:sht):dbl ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:sht):flt ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"/",	"pattern calc./(v1:sht,v2:sht):sht ",	"CMDvarDIVsignal;",	"Return V1 / V2, signal error on overflow"	]
[ "calc",	"<",	"pattern calc.<(l:json,r:json):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(l:uuid,r:uuid):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bit,v2:bit):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte,v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte,v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte,v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte,v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte,v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte,v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:bte,v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl,v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl,v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl,v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl,v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl,v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl,v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:dbl,v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt,v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt,v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt,v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt,v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt,v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt,v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:flt,v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge,v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge,v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge,v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge,v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge,v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge,v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:hge,v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int,v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int,v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int,v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int,v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int,v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int,v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:int,v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng,v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng,v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng,v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng,v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng,v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng,v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:lng,v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:oid,v2:oid):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht,v2:bte):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht,v2:dbl):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht,v2:flt):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht,v2:hge):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht,v2:int):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht,v2:lng):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:sht,v2:sht):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v1:str,v2:str):bit ",	"CMDvarLT;",	"Return V1 < V2"	]
[ "calc",	"<",	"pattern calc.<(v:date,w:date):bit ",	"CMDvarLT;",	"Equality of two dates"	]
[ "calc",	"<",	"pattern calc.<(v:daytime,w:daytime):bit ",	"CMDvarLT;",	"Equality of two daytimes"	]
[ "calc",	"<",	"pattern calc.<(v:timestamp,w:timestamp):bit ",	"CMDvarLT;",	"Equality of two timestamps"	]
[ "calc",	"<",	"command calc.<(v:inet,w:inet):bit ",	"INET_comp_LT;",	"Whether v is less than w"	]
[ "calc",	"<<",	"pattern calc.<<(v1:bte,v2:bte):bte ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:bte,v2:hge):bte ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:bte,v2:int):bte ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:bte,v2:lng):bte ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:bte,v2:sht):bte ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:hge,v2:bte):hge ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:hge,v2:hge):hge ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:hge,v2:int):hge ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:hge,v2:lng):hge ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:hge,v2:sht):hge ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:int,v2:bte):int ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:int,v2:hge):int ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:int,v2:int):int ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:int,v2:lng):int ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:int,v2:sht):int ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:lng,v2:bte):lng ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:lng,v2:hge):lng ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:lng,v2:int):lng ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:lng,v2:lng):lng ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:lng,v2:sht):lng ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:sht,v2:bte):sht ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:sht,v2:hge):sht ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:sht,v2:int):sht ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:sht,v2:lng):sht ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<<",	"pattern calc.<<(v1:sht,v2:sht):sht ",	"CMDvarLSHsignal;",	"Return V1 << V2, raise error on out of range second operand"	]
[ "calc",	"<=",	"pattern calc.<=(l:json,r:json):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(l:uuid,r:uuid):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bit,v2:bit):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte,v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte,v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte,v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte,v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte,v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte,v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:bte,v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl,v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl,v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl,v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl,v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl,v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl,v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:dbl,v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt,v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt,v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt,v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt,v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt,v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt,v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:flt,v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge,v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge,v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge,v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge,v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge,v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge,v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:hge,v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int,v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int,v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int,v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int,v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int,v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int,v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:int,v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng,v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng,v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng,v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng,v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng,v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng,v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:lng,v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:oid,v2:oid):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht,v2:bte):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht,v2:dbl):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht,v2:flt):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht,v2:hge):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht,v2:int):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht,v2:lng):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:sht,v2:sht):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v1:str,v2:str):bit ",	"CMDvarLE;",	"Return V1 <= V2"	]
[ "calc",	"<=",	"pattern calc.<=(v:date,w:date):bit ",	"CMDvarLE;",	"Equality of two dates"	]
[ "calc",	"<=",	"pattern calc.<=(v:daytime,w:daytime):bit ",	"CMDvarLE;",	"Equality of two daytimes"	]
[ "calc",	"<=",	"pattern calc.<=(v:timestamp,w:timestamp):bit ",	"CMDvarLE;",	"Equality of two timestamps"	]
[ "calc",	"<=",	"command calc.<=(v:inet,w:inet):bit ",	"INET_comp_LE;",	"Whether v is less than or equal to w"	]
[ "calc",	"==",	"pattern calc.==(l:json,r:json):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(l:uuid,r:uuid):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bit,v2:bit):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte,v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte,v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte,v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte,v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte,v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte,v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:bte,v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl,v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl,v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl,v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl,v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl,v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl,v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:dbl,v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt,v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt,v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt,v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt,v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt,v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt,v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:flt,v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge,v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge,v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge,v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge,v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge,v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge,v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:hge,v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int,v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int,v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int,v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int,v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int,v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int,v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:int,v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng,v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng,v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng,v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng,v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng,v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng,v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:lng,v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:oid,v2:oid):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht,v2:bte):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht,v2:dbl):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht,v2:flt):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht,v2:hge):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht,v2:int):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht,v2:lng):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:sht,v2:sht):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v1:str,v2:str):bit ",	"CMDvarEQ;",	"Return V1 == V2"	]
[ "calc",	"==",	"pattern calc.==(v:date,w:date):bit ",	"CMDvarEQ;",	"Equality of two dates"	]
[ "calc",	"==",	"pattern calc.==(v:daytime,w:daytime):bit ",	"CMDvarEQ;",	"Equality of two daytimes"	]
[ "calc",	"==",	"pattern calc.==(v:timestamp,w:timestamp):bit ",	"CMDvarEQ;",	"Equality of two timestamps"	]
[ "calc",	"==",	"command calc.==(v:inet,w:inet):bit ",	"INET_comp_EQ;",	"Equality of two inets"	]
[ "calc",	">",	"pattern calc.>(l:json,r:json):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(l:uuid,r:uuid):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bit,v2:bit):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte,v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte,v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte,v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte,v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte,v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte,v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:bte,v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl,v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl,v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl,v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl,v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl,v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl,v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:dbl,v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt,v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt,v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt,v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt,v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt,v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt,v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:flt,v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge,v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge,v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge,v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge,v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge,v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge,v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:hge,v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int,v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int,v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int,v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int,v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int,v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int,v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:int,v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng,v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng,v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng,v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng,v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng,v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng,v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:lng,v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:oid,v2:oid):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht,v2:bte):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht,v2:dbl):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht,v2:flt):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht,v2:hge):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht,v2:int):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht,v2:lng):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:sht,v2:sht):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v1:str,v2:str):bit ",	"CMDvarGT;",	"Return V1 > V2"	]
[ "calc",	">",	"pattern calc.>(v:date,w:date):bit ",	"CMDvarGT;",	"Equality of two dates"	]
[ "calc",	">",	"pattern calc.>(v:daytime,w:daytime):bit ",	"CMDvarGT;",	"Equality of two daytimes"	]
[ "calc",	">",	"pattern calc.>(v:timestamp,w:timestamp):bit ",	"CMDvarGT;",	"Equality of two timestamps"	]
[ "calc",	">",	"command calc.>(v:inet,w:inet):bit ",	"INET_comp_GT;",	"Whether v is greater than w"	]
[ "calc",	">=",	"pattern calc.>=(l:json,r:json):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(l:uuid,r:uuid):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bit,v2:bit):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte,v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte,v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte,v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte,v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte,v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte,v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:bte,v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl,v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl,v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl,v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl,v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl,v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl,v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:dbl,v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt,v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt,v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt,v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt,v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt,v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt,v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:flt,v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge,v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge,v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge,v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge,v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge,v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge,v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:hge,v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int,v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int,v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int,v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int,v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int,v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int,v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:int,v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng,v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng,v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng,v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng,v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng,v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng,v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:lng,v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:oid,v2:oid):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht,v2:bte):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht,v2:dbl):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht,v2:flt):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht,v2:hge):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht,v2:int):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht,v2:lng):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:sht,v2:sht):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v1:str,v2:str):bit ",	"CMDvarGE;",	"Return V1 >= V2"	]
[ "calc",	">=",	"pattern calc.>=(v:date,w:date):bit ",	"CMDvarGE;",	"Equality of two dates"	]
[ "calc",	">=",	"pattern calc.>=(v:daytime,w:daytime):bit ",	"CMDvarGE;",	"Equality of two daytimes"	]
[ "calc",	">=",	"pattern calc.>=(v:timestamp,w:timestamp):bit ",	"CMDvarGE;",	"Equality of two timestamps"	]
[ "calc",	">=",	"command calc.>=(v:inet,w:inet):bit ",	"INET_comp_GE;",	"Whether v is equal to or greater than w"	]
[ "calc",	">>",	"pattern calc.>>(v1:bte,v2:bte):bte ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:bte,v2:hge):bte ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:bte,v2:int):bte ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:bte,v2:lng):bte ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:bte,v2:sht):bte ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:hge,v2:bte):hge ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:hge,v2:hge):hge ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:hge,v2:int):hge ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:hge,v2:lng):hge ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:hge,v2:sht):hge ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:int,v2:bte):int ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:int,v2:hge):int ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:int,v2:int):int ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:int,v2:lng):int ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:int,v2:sht):int ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:lng,v2:bte):lng ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:lng,v2:hge):lng ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:lng,v2:int):lng ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:lng,v2:lng):lng ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:lng,v2:sht):lng ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:sht,v2:bte):sht ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:sht,v2:hge):sht ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:sht,v2:int):sht ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:sht,v2:lng):sht ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	">>",	"pattern calc.>>(v1:sht,v2:sht):sht ",	"CMDvarRSHsignal;",	"Return V1 >> V2, raise error on out of range second operand"	]
[ "calc",	"abs",	"pattern calc.abs(v:bte):bte ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:dbl):dbl ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:flt):flt ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:hge):hge ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:int):int ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:lng):lng ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"abs",	"pattern calc.abs(v:sht):sht ",	"CMDvarABS;",	"Unary absolute value of V"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte,v2:bte):bte ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte,v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte,v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte,v2:hge):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte,v2:int):int ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte,v2:lng):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:bte,v2:sht):sht ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl,v2:bte):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl,v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl,v2:flt):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl,v2:hge):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl,v2:int):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl,v2:lng):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:dbl,v2:sht):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt,v2:bte):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt,v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt,v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt,v2:hge):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt,v2:int):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt,v2:lng):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:flt,v2:sht):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge,v2:bte):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge,v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge,v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge,v2:hge):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge,v2:int):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge,v2:lng):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:hge,v2:sht):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int,v2:bte):int ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int,v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int,v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int,v2:hge):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int,v2:int):int ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int,v2:lng):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:int,v2:sht):int ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng,v2:bte):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng,v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng,v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng,v2:hge):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng,v2:int):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng,v2:lng):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:lng,v2:sht):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht,v2:bte):sht ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht,v2:dbl):dbl ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht,v2:flt):flt ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht,v2:hge):hge ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht,v2:int):int ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht,v2:lng):lng ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"add_noerror",	"pattern calc.add_noerror(v1:sht,v2:sht):sht ",	"CMDvarADD;",	"Return V1 + V2, overflow causes NIL value"	]
[ "calc",	"and",	"pattern calc.and(v1:bit,v2:bit):bit ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"and",	"pattern calc.and(v1:bte,v2:bte):bte ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"and",	"pattern calc.and(v1:hge,v2:hge):hge ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"and",	"pattern calc.and(v1:int,v2:int):int ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"and",	"pattern calc.and(v1:lng,v2:lng):lng ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"and",	"pattern calc.and(v1:sht,v2:sht):sht ",	"CMDvarAND;",	"Return V1 AND V2"	]
[ "calc",	"between",	"pattern calc.between(b:any_1,lo:any_1,hi:any_1):bit ",	"CMDvarBETWEEN;",	"B between LO and HI inclusive"	]
[ "calc",	"between_symmetric",	"pattern calc.between_symmetric(b:any_1,v1:any_1,v2:any_1):bit ",	"CMDvarBETWEENsymmetric;",	"B between V1 and V2 (or vice versa) inclusive"	]
[ "calc",	"bit",	"pattern calc.bit(v:bit):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:bte):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:dbl):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:flt):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:hge):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:int):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:lng):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:oid):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:sht):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:str):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"bit",	"pattern calc.bit(v:void):bit ",	"CMDvarCONVERT;",	"Cast VALUE to bit"	]
[ "calc",	"blob",	"command calc.blob(b:blob):blob ",	"BLOBblob_blob;",	""	]
[ "calc",	"blob",	"command calc.blob(s:str):blob ",	"BLOBblob_fromstr;",	""	]
[ "calc",	"bte",	"pattern calc.bte(v:bit):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:bte):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:dbl):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:flt):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:hge):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:int):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:lng):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:oid):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:sht):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:str):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"pattern calc.bte(v:void):bte ",	"CMDvarCONVERT;",	"Cast VALUE to bte"	]
[ "calc",	"bte",	"command calc.bte(s1:int,v:bte):bte ",	"bte_dec2_bte;",	"cast decimal(bte) to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int,v:bte,d2:int,s2:int):bte ",	"bte_dec2dec_bte;",	"cast decimal(bte) to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:bte,digits:int,scale:int):bte ",	"bte_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:dbl,digits:int,scale:int):bte ",	"dbl_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:flt,digits:int,scale:int):bte ",	"flt_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int,v:hge):bte ",	"hge_dec2_bte;",	"cast decimal(hge) to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int,v:hge,d2:int,s2:int):bte ",	"hge_dec2dec_bte;",	"cast decimal(hge) to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:hge,digits:int,scale:int):bte ",	"hge_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int,v:int):bte ",	"int_dec2_bte;",	"cast decimal(int) to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int,v:int,d2:int,s2:int):bte ",	"int_dec2dec_bte;",	"cast decimal(int) to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:int,digits:int,scale:int):bte ",	"int_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int,v:lng):bte ",	"lng_dec2_bte;",	"cast decimal(lng) to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int,v:lng,d2:int,s2:int):bte ",	"lng_dec2dec_bte;",	"cast decimal(lng) to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:lng,digits:int,scale:int):bte ",	"lng_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:void,digits:int,scale:int):bte ",	"nil_2dec_bte;",	"cast to dec(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:void,digits:int):bte ",	"nil_2num_bte;",	"cast to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int,v:sht):bte ",	"sht_dec2_bte;",	"cast decimal(sht) to bte and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(s1:int,v:sht,d2:int,s2:int):bte ",	"sht_dec2dec_bte;",	"cast decimal(sht) to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:sht,digits:int,scale:int):bte ",	"sht_num2dec_bte;",	"cast number to decimal(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:str,digits:int,scale:int):bte ",	"str_2dec_bte;",	"cast to dec(bte) and check for overflow"	]
[ "calc",	"bte",	"command calc.bte(v:str,digits:int):bte ",	"str_2num_bte;",	"cast to bte and check for overflow"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bit,v2:bit):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte,v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte,v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte,v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte,v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte,v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte,v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:bte,v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl,v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl,v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl,v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl,v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl,v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl,v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:dbl,v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt,v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt,v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt,v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt,v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt,v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt,v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:flt,v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge,v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge,v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge,v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge,v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge,v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge,v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:hge,v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int,v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int,v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int,v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int,v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int,v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int,v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:int,v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng,v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng,v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng,v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng,v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng,v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng,v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:lng,v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:oid,v2:oid):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht,v2:bte):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht,v2:dbl):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht,v2:flt):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht,v2:hge):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht,v2:int):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht,v2:lng):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:sht,v2:sht):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"cmp",	"pattern calc.cmp(v1:str,v2:str):bte ",	"CMDvarCMP;",	"Return -1/0/1 if V1 </==/> V2"	]
[ "calc",	"date",	"command calc.date(d:date):date ",	"MTIMEdate_date;",	""	]
[ "calc",	"date",	"command calc.date(s:str):date ",	"MTIMEdate_fromstr;",	""	]
[ "calc",	"date",	"command calc.date(t:timestamp):date ",	"MTIMEtimestamp_extract_date_default;",	""	]
[ "calc",	"date",	"command calc.date(v:void):date ",	"nil_2_date;",	"cast to date"	]
[ "calc",	"date",	"command calc.date(v:str):date ",	"str_2_date;",	"cast to date"	]
[ "calc",	"daytime",	"command calc.daytime(d:daytime):daytime ",	"MTIMEdaytime2daytime;",	""	]
[ "calc",	"daytime",	"command calc.daytime(s:str):daytime ",	"MTIMEdaytime_fromstr;",	""	]
[ "calc",	"daytime",	"command calc.daytime(s:lng):daytime ",	"MTIMEsecs2daytime;",	""	]
[ "calc",	"daytime",	"command calc.daytime(t:timestamp):daytime ",	"MTIMEtimestamp_extract_daytime_default;",	""	]
[ "calc",	"daytime",	"command calc.daytime(v:daytime,digits:int):daytime ",	"daytime_2time_daytime;",	"cast daytime to daytime and check for overflow"	]
[ "calc",	"daytime",	"command calc.daytime(v:void):daytime ",	"nil_2_daytime;",	"Cast to daytime"	]
[ "calc",	"daytime",	"command calc.daytime(v:void,digits:int):daytime ",	"nil_2time_daytime;",	"cast to daytime and check for overflow"	]
[ "calc",	"daytime",	"command calc.daytime(v:lng,d:int):daytime ",	"second_interval_2_daytime;",	"cast second_interval to a daytime and check for overflow"	]
[ "calc",	"daytime",	"command calc.daytime(v:str):daytime ",	"str_2_daytime;",	"Cast to daytime"	]
[ "calc",	"daytime",	"command calc.daytime(v:str,digits:int):daytime ",	"str_2time_daytime;",	"cast to daytime and check for overflow"	]
[ "calc",	"daytime",	"command calc.daytime(v:str,digits:int,has_tz:int):daytime ",	"str_2time_daytimetz;",	"cast to daytime and check for overflow"	]
[ "calc",	"daytime",	"command calc.daytime(v:timestamp,d:int):daytime ",	"timestamp_2_daytime;",	"cast timestamp to a daytime and check for overflow"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:bit):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:bte):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:dbl):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:flt):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:hge):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:int):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:lng):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:oid):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:sht):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:str):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"pattern calc.dbl(v:void):dbl ",	"CMDvarCONVERT;",	"Cast VALUE to dbl"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int,v:bte):dbl ",	"bte_dec2_dbl;",	"cast decimal(bte) to dbl and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int,v:bte,d2:int,s2:int):dbl ",	"bte_dec2dec_dbl;",	"cast decimal(bte) to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(v:bte,digits:int,scale:int):dbl ",	"bte_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int,v:hge):dbl ",	"hge_dec2_dbl;",	"cast decimal(hge) to dbl and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int,v:hge,d2:int,s2:int):dbl ",	"hge_dec2dec_dbl;",	"cast decimal(hge) to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(v:hge,digits:int,scale:int):dbl ",	"hge_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int,v:int):dbl ",	"int_dec2_dbl;",	"cast decimal(int) to dbl and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int,v:int,d2:int,s2:int):dbl ",	"int_dec2dec_dbl;",	"cast decimal(int) to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(v:int,digits:int,scale:int):dbl ",	"int_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int,v:lng):dbl ",	"lng_dec2_dbl;",	"cast decimal(lng) to dbl and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int,v:lng,d2:int,s2:int):dbl ",	"lng_dec2dec_dbl;",	"cast decimal(lng) to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(v:lng,digits:int,scale:int):dbl ",	"lng_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int,v:sht):dbl ",	"sht_dec2_dbl;",	"cast decimal(sht) to dbl and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(s1:int,v:sht,d2:int,s2:int):dbl ",	"sht_dec2dec_dbl;",	"cast decimal(sht) to decimal(dbl) and check for overflow"	]
[ "calc",	"dbl",	"command calc.dbl(v:sht,digits:int,scale:int):dbl ",	"sht_num2dec_dbl;",	"cast number to decimal(dbl) and check for overflow"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte,v2:bte):bte ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte,v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte,v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte,v2:hge):bte ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte,v2:int):bte ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte,v2:lng):bte ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:bte,v2:sht):bte ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl,v2:bte):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl,v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl,v2:flt):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl,v2:hge):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl,v2:int):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl,v2:lng):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:dbl,v2:sht):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt,v2:bte):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt,v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt,v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt,v2:hge):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt,v2:int):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt,v2:lng):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:flt,v2:sht):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge,v2:bte):hge ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge,v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge,v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge,v2:hge):hge ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge,v2:int):hge ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge,v2:lng):hge ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:hge,v2:sht):hge ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int,v2:bte):int ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int,v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int,v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int,v2:hge):int ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int,v2:int):int ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int,v2:lng):int ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:int,v2:sht):int ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng,v2:bte):lng ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng,v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng,v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng,v2:hge):lng ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng,v2:int):lng ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng,v2:lng):lng ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:lng,v2:sht):lng ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht,v2:bte):sht ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht,v2:dbl):dbl ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht,v2:flt):flt ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht,v2:hge):sht ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht,v2:int):sht ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht,v2:lng):sht ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"div_noerror",	"pattern calc.div_noerror(v1:sht,v2:sht):sht ",	"CMDvarDIV;",	"Return V1 / V2, overflow causes NIL value"	]
[ "calc",	"flt",	"pattern calc.flt(v:bit):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:bte):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:dbl):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:flt):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:hge):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:int):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:lng):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:oid):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:sht):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:str):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"pattern calc.flt(v:void):flt ",	"CMDvarCONVERT;",	"Cast VALUE to flt"	]
[ "calc",	"flt",	"command calc.flt(s1:int,v:bte):flt ",	"bte_dec2_flt;",	"cast decimal(bte) to flt and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int,v:bte,d2:int,s2:int):flt ",	"bte_dec2dec_flt;",	"cast decimal(bte) to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(v:bte,digits:int,scale:int):flt ",	"bte_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int,v:hge):flt ",	"hge_dec2_flt;",	"cast decimal(hge) to flt and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int,v:hge,d2:int,s2:int):flt ",	"hge_dec2dec_flt;",	"cast decimal(hge) to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(v:hge,digits:int,scale:int):flt ",	"hge_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int,v:int):flt ",	"int_dec2_flt;",	"cast decimal(int) to flt and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int,v:int,d2:int,s2:int):flt ",	"int_dec2dec_flt;",	"cast decimal(int) to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(v:int,digits:int,scale:int):flt ",	"int_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int,v:lng):flt ",	"lng_dec2_flt;",	"cast decimal(lng) to flt and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int,v:lng,d2:int,s2:int):flt ",	"lng_dec2dec_flt;",	"cast decimal(lng) to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(v:lng,digits:int,scale:int):flt ",	"lng_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int,v:sht):flt ",	"sht_dec2_flt;",	"cast decimal(sht) to flt and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(s1:int,v:sht,d2:int,s2:int):flt ",	"sht_dec2dec_flt;",	"cast decimal(sht) to decimal(flt) and check for overflow"	]
[ "calc",	"flt",	"command calc.flt(v:sht,digits:int,scale:int):flt ",	"sht_num2dec_flt;",	"cast number to decimal(flt) and check for overflow"	]
[ "calc",	"hash",	"pattern calc.hash(v:any):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:bte):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:dbl):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:flt):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:hge):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:int):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:lng):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:lng):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:oid):lng ",	"MKEYhash;",	""	]
[ "calc",	"hash",	"pattern calc.hash(v:sht):lng ",	"MKEYhash;",	""	]
[ "calc",	"hge",	"pattern calc.hge(v:bit):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:bte):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:dbl):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:flt):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:hge):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:int):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:lng):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:oid):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:sht):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:str):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"pattern calc.hge(v:void):hge ",	"CMDvarCONVERT;",	"Cast VALUE to hge"	]
[ "calc",	"hge",	"command calc.hge(s1:int,v:bte):hge ",	"bte_dec2_hge;",	"cast decimal(bte) to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int,v:bte,d2:int,s2:int):hge ",	"bte_dec2dec_hge;",	"cast decimal(bte) to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:bte,digits:int,scale:int):hge ",	"bte_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:dbl,digits:int,scale:int):hge ",	"dbl_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:flt,digits:int,scale:int):hge ",	"flt_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int,v:hge):hge ",	"hge_dec2_hge;",	"cast decimal(hge) to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int,v:hge,d2:int,s2:int):hge ",	"hge_dec2dec_hge;",	"cast decimal(hge) to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:hge,digits:int,scale:int):hge ",	"hge_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int,v:int):hge ",	"int_dec2_hge;",	"cast decimal(int) to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int,v:int,d2:int,s2:int):hge ",	"int_dec2dec_hge;",	"cast decimal(int) to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:int,digits:int,scale:int):hge ",	"int_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int,v:lng):hge ",	"lng_dec2_hge;",	"cast decimal(lng) to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int,v:lng,d2:int,s2:int):hge ",	"lng_dec2dec_hge;",	"cast decimal(lng) to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:lng,digits:int,scale:int):hge ",	"lng_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:void,digits:int,scale:int):hge ",	"nil_2dec_hge;",	"cast to dec(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:void,digits:int):hge ",	"nil_2num_hge;",	"cast to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int,v:sht):hge ",	"sht_dec2_hge;",	"cast decimal(sht) to hge and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(s1:int,v:sht,d2:int,s2:int):hge ",	"sht_dec2dec_hge;",	"cast decimal(sht) to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:sht,digits:int,scale:int):hge ",	"sht_num2dec_hge;",	"cast number to decimal(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:str,digits:int,scale:int):hge ",	"str_2dec_hge;",	"cast to dec(hge) and check for overflow"	]
[ "calc",	"hge",	"command calc.hge(v:str,digits:int):hge ",	"str_2num_hge;",	"cast to hge and check for overflow"	]
[ "calc",	"identity",	"command calc.identity(X_0:any_2):oid ",	"SQLidentity;",	"Returns a unique row identitfier."	]
[ "calc",	"ifthenelse",	"pattern calc.ifthenelse(b:bit,t:any_1,f:any_1):any_1 ",	"CALCswitchbit;",	"If VALUE is true return MIDDLE else RIGHT"	]
[ "calc",	"index",	"command calc.index(v:str,u:bit):bte ",	"STRindex_bte;",	"Return the offsets as an index bat"	]
[ "calc",	"index",	"command calc.index(v:str,u:bit):int ",	"STRindex_int;",	"Return the offsets as an index bat"	]
[ "calc",	"index",	"command calc.index(v:str,u:bit):sht ",	"STRindex_sht;",	"Return the offsets as an index bat"	]
[ "calc",	"inet",	"command calc.inet(s:str):inet ",	"INET_fromstr;",	"Convert a string to an inet"	]
[ "calc",	"inet",	"command calc.inet(s:inet):inet ",	"INET_inet;",	"Convert a inet to an inet"	]
[ "calc",	"int",	"pattern calc.int(v:bit):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:bte):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:dbl):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:flt):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:hge):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:int):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:lng):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:oid):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:sht):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:str):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"pattern calc.int(v:void):int ",	"CMDvarCONVERT;",	"Cast VALUE to int"	]
[ "calc",	"int",	"command calc.int(s1:int,v:bte):int ",	"bte_dec2_int;",	"cast decimal(bte) to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int,v:bte,d2:int,s2:int):int ",	"bte_dec2dec_int;",	"cast decimal(bte) to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:bte,digits:int,scale:int):int ",	"bte_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:dbl,digits:int,scale:int):int ",	"dbl_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:flt,digits:int,scale:int):int ",	"flt_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int,v:hge):int ",	"hge_dec2_int;",	"cast decimal(hge) to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int,v:hge,d2:int,s2:int):int ",	"hge_dec2dec_int;",	"cast decimal(hge) to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:hge,digits:int,scale:int):int ",	"hge_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int,v:int):int ",	"int_dec2_int;",	"cast decimal(int) to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int,v:int,d2:int,s2:int):int ",	"int_dec2dec_int;",	"cast decimal(int) to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:int,digits:int,scale:int):int ",	"int_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int,v:lng):int ",	"lng_dec2_int;",	"cast decimal(lng) to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int,v:lng,d2:int,s2:int):int ",	"lng_dec2dec_int;",	"cast decimal(lng) to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:lng,digits:int,scale:int):int ",	"lng_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:void,digits:int,scale:int):int ",	"nil_2dec_int;",	"cast to dec(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:void,digits:int):int ",	"nil_2num_int;",	"cast to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int,v:sht):int ",	"sht_dec2_int;",	"cast decimal(sht) to int and check for overflow"	]
[ "calc",	"int",	"command calc.int(s1:int,v:sht,d2:int,s2:int):int ",	"sht_dec2dec_int;",	"cast decimal(sht) to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:sht,digits:int,scale:int):int ",	"sht_num2dec_int;",	"cast number to decimal(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:str,digits:int,scale:int):int ",	"str_2dec_int;",	"cast to dec(int) and check for overflow"	]
[ "calc",	"int",	"command calc.int(v:str,digits:int):int ",	"str_2num_int;",	"cast to int and check for overflow"	]
[ "calc",	"isnil",	"pattern calc.isnil(v:any):bit ",	"CMDvarISNIL;",	"Unary check for nil of V"	]
[ "calc",	"isnotnil",	"pattern calc.isnotnil(v:any):bit ",	"CMDvarISNOTNIL;",	"Unary check for notnil of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:bte):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:dbl):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:flt):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:hge):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:int):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:lng):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"iszero",	"pattern calc.iszero(v:sht):bit ",	"CMDvarISZERO;",	"Unary check for zero of V"	]
[ "calc",	"json",	"command calc.json(j:json):json ",	"JSONstr2json;",	"Convert JSON to JSON. Dealing with escape characters"	]
[ "calc",	"json",	"command calc.json(j:str):json ",	"JSONstr2json;",	"Convert string to its JSON. Dealing with escape characters"	]
[ "calc",	"length",	"command calc.length(s:str):int ",	"CMDstrlength;",	"Length of STRING"	]
[ "calc",	"lng",	"pattern calc.lng(v:bit):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:bte):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:dbl):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:flt):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:hge):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:int):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:lng):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:oid):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:sht):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:str):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"pattern calc.lng(v:void):lng ",	"CMDvarCONVERT;",	"Cast VALUE to lng"	]
[ "calc",	"lng",	"command calc.lng(s1:int,v:bte):lng ",	"bte_dec2_lng;",	"cast decimal(bte) to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int,v:bte,d2:int,s2:int):lng ",	"bte_dec2dec_lng;",	"cast decimal(bte) to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:bte,digits:int,scale:int):lng ",	"bte_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:dbl,digits:int,scale:int):lng ",	"dbl_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:flt,digits:int,scale:int):lng ",	"flt_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int,v:hge):lng ",	"hge_dec2_lng;",	"cast decimal(hge) to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int,v:hge,d2:int,s2:int):lng ",	"hge_dec2dec_lng;",	"cast decimal(hge) to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:hge,digits:int,scale:int):lng ",	"hge_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int,v:int):lng ",	"int_dec2_lng;",	"cast decimal(int) to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int,v:int,d2:int,s2:int):lng ",	"int_dec2dec_lng;",	"cast decimal(int) to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:int,digits:int,scale:int):lng ",	"int_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int,v:lng):lng ",	"lng_dec2_lng;",	"cast decimal(lng) to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int,v:lng,d2:int,s2:int):lng ",	"lng_dec2dec_lng;",	"cast decimal(lng) to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:lng,digits:int,scale:int):lng ",	"lng_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:void,digits:int,scale:int):lng ",	"nil_2dec_lng;",	"cast to dec(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:void,digits:int):lng ",	"nil_2num_lng;",	"cast to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int,v:sht):lng ",	"sht_dec2_lng;",	"cast decimal(sht) to lng and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(s1:int,v:sht,d2:int,s2:int):lng ",	"sht_dec2dec_lng;",	"cast decimal(sht) to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:sht,digits:int,scale:int):lng ",	"sht_num2dec_lng;",	"cast number to decimal(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:str,digits:int,scale:int):lng ",	"str_2dec_lng;",	"cast to dec(lng) and check for overflow"	]
[ "calc",	"lng",	"command calc.lng(v:str,digits:int):lng ",	"str_2num_lng;",	"cast to lng and check for overflow"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:bte,v2:bte):bte ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:bte,v2:hge):bte ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:bte,v2:int):bte ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:bte,v2:lng):bte ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:bte,v2:sht):bte ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:hge,v2:bte):hge ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:hge,v2:hge):hge ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:hge,v2:int):hge ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:hge,v2:lng):hge ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:hge,v2:sht):hge ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:int,v2:bte):int ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:int,v2:hge):int ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:int,v2:int):int ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:int,v2:lng):int ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:int,v2:sht):int ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:lng,v2:bte):lng ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:lng,v2:hge):lng ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:lng,v2:int):lng ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:lng,v2:lng):lng ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:lng,v2:sht):lng ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:sht,v2:bte):sht ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:sht,v2:hge):sht ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:sht,v2:int):sht ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:sht,v2:lng):sht ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"lsh_noerror",	"pattern calc.lsh_noerror(v1:sht,v2:sht):sht ",	"CMDvarLSH;",	"Return V1 << V2, out of range second operand causes NIL value"	]
[ "calc",	"max",	"pattern calc.max(v1:any_1,v2:any_1):any_1 ",	"CALCmax;",	"Return max of V1 and V2"	]
[ "calc",	"max_no_nil",	"pattern calc.max_no_nil(v1:any_1,v2:any_1):any_1 ",	"CALCmax_no_nil;",	"Return max of V1 and V2, ignoring nil values"	]
[ "calc",	"mbr",	"command calc.mbr(v:mbr):mbr ",	"mbrFromMBR;",	""	]
[ "calc",	"mbr",	"command calc.mbr(v:str):mbr ",	"mbrFromString;",	""	]
[ "calc",	"min",	"pattern calc.min(v1:any_1,v2:any_1):any_1 ",	"CALCmin;",	"Return min of V1 and V2"	]
[ "calc",	"min_no_nil",	"pattern calc.min_no_nil(v1:any_1,v2:any_1):any_1 ",	"CALCmin_no_nil;",	"Return min of V1 and V2, ignoring nil values"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte,v2:bte):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte,v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte,v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte,v2:hge):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte,v2:int):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte,v2:lng):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:bte,v2:sht):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl,v2:bte):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl,v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl,v2:flt):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl,v2:hge):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl,v2:int):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl,v2:lng):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:dbl,v2:sht):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt,v2:bte):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt,v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt,v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt,v2:hge):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt,v2:int):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt,v2:lng):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:flt,v2:sht):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge,v2:bte):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge,v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge,v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge,v2:hge):hge ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge,v2:int):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge,v2:lng):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:hge,v2:sht):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int,v2:bte):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int,v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int,v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int,v2:hge):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int,v2:int):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int,v2:lng):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:int,v2:sht):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng,v2:bte):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng,v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng,v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng,v2:hge):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng,v2:int):int ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng,v2:lng):lng ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:lng,v2:sht):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht,v2:bte):bte ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht,v2:dbl):dbl ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht,v2:flt):flt ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht,v2:hge):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht,v2:int):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht,v2:lng):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"mod_noerror",	"pattern calc.mod_noerror(v1:sht,v2:sht):sht ",	"CMDvarMOD;",	"Return V1 % V2, divide by zero causes NIL value"	]
[ "calc",	"month_interval",	"pattern calc.month_interval(v:bte,ek:int,sk:int):int ",	"month_interval;",	"cast bte to a month_interval and check for overflow"	]
[ "calc",	"month_interval",	"pattern calc.month_interval(v:hge,ek:int,sk:int):int ",	"month_interval;",	"cast hge to a month_interval and check for overflow"	]
[ "calc",	"month_interval",	"pattern calc.month_interval(v:int,ek:int,sk:int):int ",	"month_interval;",	"cast int to a month_interval and check for overflow"	]
[ "calc",	"month_interval",	"pattern calc.month_interval(v:lng,ek:int,sk:int):int ",	"month_interval;",	"cast lng to a month_interval and check for overflow"	]
[ "calc",	"month_interval",	"pattern calc.month_interval(v:sht,ek:int,sk:int):int ",	"month_interval;",	"cast sht to a month_interval and check for overflow"	]
[ "calc",	"month_interval",	"command calc.month_interval(v:str,ek:int,sk:int):int ",	"month_interval_str;",	"cast str to a month_interval and check for overflow"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte,v2:bte):bte ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte,v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte,v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte,v2:hge):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte,v2:int):int ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte,v2:lng):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:bte,v2:sht):sht ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl,v2:bte):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl,v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl,v2:flt):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl,v2:hge):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl,v2:int):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl,v2:lng):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:dbl,v2:sht):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt,v2:bte):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt,v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt,v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt,v2:hge):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt,v2:int):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt,v2:lng):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:flt,v2:sht):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge,v2:bte):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge,v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge,v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge,v2:hge):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge,v2:int):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge,v2:lng):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:hge,v2:sht):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int,v2:bte):int ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int,v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int,v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int,v2:hge):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int,v2:int):int ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int,v2:lng):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:int,v2:sht):int ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng,v2:bte):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng,v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng,v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng,v2:hge):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng,v2:int):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng,v2:lng):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:lng,v2:sht):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht,v2:bte):sht ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht,v2:dbl):dbl ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht,v2:flt):flt ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht,v2:hge):hge ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht,v2:int):int ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht,v2:lng):lng ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"mul_noerror",	"pattern calc.mul_noerror(v1:sht,v2:sht):sht ",	"CMDvarMUL;",	"Return V1 * V2, overflow causes NIL value"	]
[ "calc",	"not",	"pattern calc.not(v:bit):bit ",	"CMDvarNOT;",	"Return the Boolean inverse"	]
[ "calc",	"not",	"pattern calc.not(v:bte):bte ",	"CMDvarNOT;",	"Unary bitwise not of V"	]
[ "calc",	"not",	"pattern calc.not(v:hge):hge ",	"CMDvarNOT;",	"Unary bitwise not of V"	]
[ "calc",	"not",	"pattern calc.not(v:int):int ",	"CMDvarNOT;",	"Unary bitwise not of V"	]
[ "calc",	"not",	"pattern calc.not(v:lng):lng ",	"CMDvarNOT;",	"Unary bitwise not of V"	]
[ "calc",	"not",	"pattern calc.not(v:sht):sht ",	"CMDvarNOT;",	"Unary bitwise not of V"	]
[ "calc",	"oid",	"pattern calc.oid(v:bit):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:bte):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:dbl):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:flt):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:hge):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:int):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:lng):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:oid):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:sht):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:str):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"oid",	"pattern calc.oid(v:void):oid ",	"CMDvarCONVERT;",	"Cast VALUE to oid"	]
[ "calc",	"or",	"pattern calc.or(v1:bit,v2:bit):bit ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"or",	"pattern calc.or(v1:bte,v2:bte):bte ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"or",	"pattern calc.or(v1:hge,v2:hge):hge ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"or",	"pattern calc.or(v1:int,v2:int):int ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"or",	"pattern calc.or(v1:lng,v2:lng):lng ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"or",	"pattern calc.or(v1:sht,v2:sht):sht ",	"CMDvarOR;",	"Return V1 OR V2"	]
[ "calc",	"ptr",	"command calc.ptr(v:ptr):ptr ",	"CMDvarCONVERTptr;",	"Cast VALUE to ptr"	]
[ "calc",	"rotate_xor_hash",	"pattern calc.rotate_xor_hash(h:lng,nbits:int,v:any_1):lng ",	"MKEYrotate_xor_hash;",	""	]
[ "calc",	"rowid",	"pattern calc.rowid(v:any_1,schema:str,table:str):oid ",	"sql_rowid;",	"return the next rowid"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:bte,v2:bte):bte ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:bte,v2:hge):bte ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:bte,v2:int):bte ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:bte,v2:lng):bte ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:bte,v2:sht):bte ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:hge,v2:bte):hge ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:hge,v2:hge):hge ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:hge,v2:int):hge ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:hge,v2:lng):hge ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:hge,v2:sht):hge ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:int,v2:bte):int ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:int,v2:hge):int ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:int,v2:int):int ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:int,v2:lng):int ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:int,v2:sht):int ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:lng,v2:bte):lng ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:lng,v2:hge):lng ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:lng,v2:int):lng ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:lng,v2:lng):lng ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:lng,v2:sht):lng ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:sht,v2:bte):sht ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:sht,v2:hge):sht ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:sht,v2:int):sht ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:sht,v2:lng):sht ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"rsh_noerror",	"pattern calc.rsh_noerror(v1:sht,v2:sht):sht ",	"CMDvarRSH;",	"Return V1 >> V2, out of range second operand causes NIL value"	]
[ "calc",	"second_interval",	"command calc.second_interval(sc:int,v:bte,ek:int,sk:int):lng ",	"bte_dec2second_interval;",	"cast bte decimal to a second_interval"	]
[ "calc",	"second_interval",	"command calc.second_interval(sc:int,v:hge,ek:int,sk:int):lng ",	"hge_dec2second_interval;",	"cast hge decimal to a second_interval"	]
[ "calc",	"second_interval",	"command calc.second_interval(sc:int,v:int,ek:int,sk:int):lng ",	"int_dec2second_interval;",	"cast int decimal to a second_interval"	]
[ "calc",	"second_interval",	"command calc.second_interval(sc:int,v:lng,ek:int,sk:int):lng ",	"lng_dec2second_interval;",	"cast lng decimal to a second_interval"	]
[ "calc",	"second_interval",	"pattern calc.second_interval(v:bte,ek:int,sk:int):lng ",	"second_interval;",	"cast bte to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"pattern calc.second_interval(v:hge,ek:int,sk:int):lng ",	"second_interval;",	"cast hge to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"pattern calc.second_interval(v:int,ek:int,sk:int):lng ",	"second_interval;",	"cast int to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"pattern calc.second_interval(v:lng,ek:int,sk:int):lng ",	"second_interval;",	"cast lng to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"pattern calc.second_interval(v:sht,ek:int,sk:int):lng ",	"second_interval;",	"cast sht to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"command calc.second_interval(v:daytime,ek:int,sk:int):lng ",	"second_interval_daytime;",	"cast daytime to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"command calc.second_interval(v:str,ek:int,sk:int):lng ",	"second_interval_str;",	"cast str to a second_interval and check for overflow"	]
[ "calc",	"second_interval",	"command calc.second_interval(sc:int,v:sht,ek:int,sk:int):lng ",	"sht_dec2second_interval;",	"cast sht decimal to a second_interval"	]
[ "calc",	"setoid",	"pattern calc.setoid(v:int):void ",	"CMDsetoid;",	""	]
[ "calc",	"setoid",	"pattern calc.setoid(v:lng):void ",	"CMDsetoid;",	""	]
[ "calc",	"setoid",	"pattern calc.setoid(v:oid):void ",	"CMDsetoid;",	""	]
[ "calc",	"sht",	"pattern calc.sht(v:bit):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:bte):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:dbl):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:flt):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:hge):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:int):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:lng):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:oid):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:sht):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:str):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"pattern calc.sht(v:void):sht ",	"CMDvarCONVERT;",	"Cast VALUE to sht"	]
[ "calc",	"sht",	"command calc.sht(s1:int,v:bte):sht ",	"bte_dec2_sht;",	"cast decimal(bte) to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int,v:bte,d2:int,s2:int):sht ",	"bte_dec2dec_sht;",	"cast decimal(bte) to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:bte,digits:int,scale:int):sht ",	"bte_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:dbl,digits:int,scale:int):sht ",	"dbl_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:flt,digits:int,scale:int):sht ",	"flt_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int,v:hge):sht ",	"hge_dec2_sht;",	"cast decimal(hge) to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int,v:hge,d2:int,s2:int):sht ",	"hge_dec2dec_sht;",	"cast decimal(hge) to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:hge,digits:int,scale:int):sht ",	"hge_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int,v:int):sht ",	"int_dec2_sht;",	"cast decimal(int) to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int,v:int,d2:int,s2:int):sht ",	"int_dec2dec_sht;",	"cast decimal(int) to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:int,digits:int,scale:int):sht ",	"int_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int,v:lng):sht ",	"lng_dec2_sht;",	"cast decimal(lng) to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int,v:lng,d2:int,s2:int):sht ",	"lng_dec2dec_sht;",	"cast decimal(lng) to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:lng,digits:int,scale:int):sht ",	"lng_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:void,digits:int,scale:int):sht ",	"nil_2dec_sht;",	"cast to dec(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:void,digits:int):sht ",	"nil_2num_sht;",	"cast to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int,v:sht):sht ",	"sht_dec2_sht;",	"cast decimal(sht) to sht and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(s1:int,v:sht,d2:int,s2:int):sht ",	"sht_dec2dec_sht;",	"cast decimal(sht) to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:sht,digits:int,scale:int):sht ",	"sht_num2dec_sht;",	"cast number to decimal(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:str,digits:int,scale:int):sht ",	"str_2dec_sht;",	"cast to dec(sht) and check for overflow"	]
[ "calc",	"sht",	"command calc.sht(v:str,digits:int):sht ",	"str_2num_sht;",	"cast to sht and check for overflow"	]
[ "calc",	"sign",	"pattern calc.sign(v:bte):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:dbl):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:flt):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:hge):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:int):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:lng):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sign",	"pattern calc.sign(v:sht):bte ",	"CMDvarSIGN;",	"Unary sign (-1,0,1) of V"	]
[ "calc",	"sqlblob",	"command calc.sqlblob(b:sqlblob):sqlblob ",	"BLOBblob_blob;",	""	]
[ "calc",	"sqlblob",	"command calc.sqlblob(s:str):sqlblob ",	"BLOBsqlblob_fromstr;",	""	]
[ "calc",	"sqlblob",	"command calc.sqlblob(v:str):sqlblob ",	"str_2_sqlblob;",	"cast to sqlblob"	]
[ "calc",	"str",	"pattern calc.str(v:any):str ",	"CMDvarCONVERT;",	"Cast VALUE to str"	]
[ "calc",	"str",	"command calc.str(v:date):str ",	"SQLdate_2_str;",	"cast date to str"	]
[ "calc",	"str",	"command calc.str(v:sqlblob):str ",	"SQLsqlblob_2_str;",	"cast sqlblob to str"	]
[ "calc",	"str",	"pattern calc.str(eclass:int,d1:int,s1:int,has_tz:int,v:any_1,digits:int):str ",	"SQLstr_cast;",	"cast to string and check for overflow"	]
[ "calc",	"str",	"command calc.str(s:uuid):str ",	"UUIDuuid2str;",	"Coerce a uuid to a string type"	]
[ "calc",	"strings",	"command calc.strings(v:str):str ",	"STRstrings;",	"Return the strings"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte,v2:bte):bte ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte,v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte,v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte,v2:hge):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte,v2:int):int ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte,v2:lng):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:bte,v2:sht):sht ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl,v2:bte):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl,v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl,v2:flt):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl,v2:hge):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl,v2:int):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl,v2:lng):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:dbl,v2:sht):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt,v2:bte):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt,v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt,v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt,v2:hge):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt,v2:int):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt,v2:lng):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:flt,v2:sht):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge,v2:bte):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge,v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge,v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge,v2:hge):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge,v2:int):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge,v2:lng):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:hge,v2:sht):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int,v2:bte):int ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int,v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int,v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int,v2:hge):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int,v2:int):int ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int,v2:lng):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:int,v2:sht):int ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng,v2:bte):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng,v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng,v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng,v2:hge):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng,v2:int):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng,v2:lng):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:lng,v2:sht):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht,v2:bte):sht ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht,v2:dbl):dbl ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht,v2:flt):flt ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht,v2:hge):hge ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht,v2:int):int ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht,v2:lng):lng ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"sub_noerror",	"pattern calc.sub_noerror(v1:sht,v2:sht):sht ",	"CMDvarSUB;",	"Return V1 - V2, overflow causes NIL value"	]
[ "calc",	"substring",	"command calc.substring(s:str,offset:int,count:int):str ",	"STRsubstring;",	""	]
[ "calc",	"substring",	"command calc.substring(s:str,offset:int):str ",	"STRsubstringTail;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(t:timestamp):timestamp ",	"MTIMEtimestamp2timestamp;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(secs:int):timestamp ",	"MTIMEtimestamp;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(d:date):timestamp ",	"MTIMEtimestamp_create_from_date;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(s:str):timestamp ",	"MTIMEtimestamp_fromstr;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(msecs:lng):timestamp ",	"MTIMEtimestamp_lng;",	""	]
[ "calc",	"timestamp",	"command calc.timestamp(v:date,d:int):timestamp ",	"date_2_timestamp;",	"cast date to a timestamp and check for overflow"	]
[ "calc",	"timestamp",	"command calc.timestamp(v:void):timestamp ",	"nil_2_timestamp;",	"Cast to timestamp"	]
[ "calc",	"timestamp",	"command calc.timestamp(v:void,digits:int):timestamp ",	"nil_2time_timestamp;",	"cast to timestamp and check for overflow"	]
[ "calc",	"timestamp",	"command calc.timestamp(v:str):timestamp ",	"str_2_timestamp;",	"Cast to timestamp"	]
[ "calc",	"timestamp",	"command calc.timestamp(v:str,digits:int):timestamp ",	"str_2time_timestamp;",	"cast to timestamp and check for overflow"	]
[ "calc",	"timestamp",	"command calc.timestamp(v:str,digits:int,has_tz:int):timestamp ",	"str_2time_timestamptz;",	"cast to timestamp and check for overflow"	]
[ "calc",	"timestamp",	"command calc.timestamp(v:timestamp,digits:int):timestamp ",	"timestamp_2time_timestamp;",	"cast timestamp to timestamp and check for overflow"	]
[ "calc",	"url",	"command calc.url(s:str):url ",	"URLnew;",	"Create an URL from a string literal"	]
[ "calc",	"url",	"command calc.url(s:url):url ",	"URLnoop;",	"Create an URL from a string literal"	]
[ "calc",	"uuid",	"function calc.uuid(u:uuid):uuid;",	"",	""	]
[ "calc",	"uuid",	"command calc.uuid(s:str):uuid ",	"UUIDstr2uuid;",	"Coerce a string to a uuid, validating its format"	]
[ "calc",	"void",	"pattern calc.void(v:bit):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:bte):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:dbl):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:flt):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:hge):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:int):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:lng):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:oid):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:sht):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:str):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"void",	"pattern calc.void(v:void):void ",	"CMDvarCONVERT;",	"Cast VALUE to void"	]
[ "calc",	"wkb",	"function calc.wkb(wkt:str,srid:int,type:int):wkb;",	"",	""	]
[ "calc",	"wkb",	"command calc.wkb(geo:wkb,columnType:int,columnSRID:int):wkb ",	"geom_2_geom;",	"Called when inserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition"	]
[ "calc",	"wkb",	"command calc.wkb(v:wkb):wkb ",	"wkbFromWKB;",	"It is called when adding a new geometry column to an existing table"	]
[ "calc",	"xml",	"command calc.xml(src:str):xml ",	"XMLstr2xml;",	""	]
[ "calc",	"xml",	"command calc.xml(src:xml):xml ",	"XMLxml2xml;",	""	]
[ "calc",	"xor",	"pattern calc.xor(v1:bit,v2:bit):bit ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "calc",	"xor",	"pattern calc.xor(v1:bte,v2:bte):bte ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "calc",	"xor",	"pattern calc.xor(v1:hge,v2:hge):hge ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "calc",	"xor",	"pattern calc.xor(v1:int,v2:int):int ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "calc",	"xor",	"pattern calc.xor(v1:lng,v2:lng):lng ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "calc",	"xor",	"pattern calc.xor(v1:sht,v2:sht):sht ",	"CMDvarXOR;",	"Return V1 XOR V2"	]
[ "clients",	"addUser",	"pattern clients.addUser(nme:str,pw:str):oid ",	"CLTaddUser;",	"Allow user with password access to the given scenarios"	]
[ "clients",	"backendsum",	"command clients.backendsum(pw:str):str ",	"CLTbackendsum;",	"Return hex string representation of the currently used hash of the given string"	]
[ "clients",	"changePassword",	"pattern clients.changePassword(old:str,new:str):void ",	"CLTchangePassword;",	"Change the password for the current user"	]
[ "clients",	"changeUsername",	"pattern clients.changeUsername(old:str,new:str):void ",	"CLTchangeUsername;",	"Change the username of the user into the new string"	]
[ "clients",	"checkPermission",	"pattern clients.checkPermission(usr:str,pw:str):void ",	"CLTcheckPermission;",	"Check permission for a user, requires hashed password (backendsum)"	]
[ "clients",	"getActions",	"command clients.getActions():bat[:int] ",	"CLTActions;",	"Pseudo bat of client's command counts."	]
[ "clients",	"getId",	"pattern clients.getId():int ",	"CLTgetClientId;",	"Return a number that uniquely represents the current client."	]
[ "clients",	"getInfo",	"pattern clients.getInfo() (X_0:bat[:str],X_1:bat[:str]) ",	"CLTInfo;",	"Pseudo bat with client attributes."	]
[ "clients",	"getLastCommand",	"command clients.getLastCommand():bat[:str] ",	"CLTLastCommand;",	"Pseudo bat of client's last command time."	]
[ "clients",	"getLogins",	"command clients.getLogins() (user:bat[:oid],start:bat[:str]) ",	"CLTLogin;",	"Pseudo bat of client id and login time."	]
[ "clients",	"getPasswordHash",	"pattern clients.getPasswordHash(user:str):str ",	"CLTgetPasswordHash;",	"Return the password hash of the given user"	]
[ "clients",	"getScenario",	"pattern clients.getScenario():str ",	"CLTgetScenario;",	"Retrieve current scenario name."	]
[ "clients",	"getTime",	"command clients.getTime():bat[:lng] ",	"CLTTime;",	"Pseudo bat of client's total time usage(in usec)."	]
[ "clients",	"getTimeout",	"pattern clients.getTimeout() (q:lng,s:lng) ",	"CLTgetTimeout;",	"A query is aborted after q milliseconds (q=0 means run undisturbed).\nThe session timeout aborts the connection after spending too\nmany seconds on query processing."	]
[ "clients",	"getUsername",	"pattern clients.getUsername():str ",	"CLTgetUsername;",	"Return the username of the currently logged in user"	]
[ "clients",	"getUsers",	"pattern clients.getUsers() (X_0:bat[:oid],X_1:bat[:str]) ",	"CLTgetUsers;",	"return a BAT with user id and one with name available in the system"	]
[ "clients",	"getUsers",	"command clients.getUsers():bat[:str] ",	"CLTusers;",	"Pseudo bat of users id and name."	]
[ "clients",	"md5sum",	"command clients.md5sum(pw:str):str ",	"CLTmd5sum;",	"Return hex string representation of the MD5 hash of the given string"	]
[ "clients",	"quit",	"pattern clients.quit():void ",	"CLTquit;",	"Terminate the client session."	]
[ "clients",	"quit",	"pattern clients.quit(idx:int):void ",	"CLTquit;",	"Terminate the session for a single client using a soft error.\nIt is the privilige of the console user."	]
[ "clients",	"removeUser",	"pattern clients.removeUser(nme:str):void ",	"CLTremoveUser;",	"Remove the given user from the system"	]
[ "clients",	"ripemd160sum",	"command clients.ripemd160sum(pw:str):str ",	"CLTripemd160sum;",	"Return hex string representation of the RIPEMD160 hash of the given string"	]
[ "clients",	"setListing",	"pattern clients.setListing(flag:int):int ",	"CLTsetListing;",	"Turn on/off echo of MAL instructions:\n\t1 - echo input,\n\t2 - show mal instruction,\n\t4 - show details of type resolutoin, \n\t8 - show binding information."	]
[ "clients",	"setPassword",	"pattern clients.setPassword(user:str,pass:str):void ",	"CLTsetPassword;",	"Set the password for the given user"	]
[ "clients",	"setScenario",	"pattern clients.setScenario(msg:str):str ",	"CLTsetScenario;",	"Switch to other scenario handler, return previous one."	]
[ "clients",	"setsession",	"pattern clients.setsession(n:lng):void ",	"CLTsetSessionTimeout;",	"Abort a session after  n seconds."	]
[ "clients",	"settimeout",	"pattern clients.settimeout(n:lng):void ",	"CLTsetTimeout;",	"Abort a query after  n seconds."	]
[ "clients",	"settimeout",	"pattern clients.settimeout(q:lng,s:lng):void ",	"CLTsetTimeout;",	"Abort a query after q seconds (q=0 means run undisturbed).\nThe session timeout aborts the connection after spending too\nmany seconds on query processing."	]
[ "clients",	"sha1sum",	"command clients.sha1sum(pw:str):str ",	"CLTsha1sum;",	"Return hex string representation of the SHA-1 hash of the given string"	]
[ "clients",	"sha2sum",	"command clients.sha2sum(pw:str,bits:int):str ",	"CLTsha2sum;",	"Return hex string representation of the SHA-2 hash with bits of the given string"	]
[ "clients",	"shutdown",	"pattern clients.shutdown(delay:int):str ",	"CLTshutdown;",	""	]
[ "clients",	"shutdown",	"pattern clients.shutdown(delay:int,forced:bit):str ",	"CLTshutdown;",	"Close all other client connections. Return if it succeeds.\nIf forced is set then always stop the system the hard way"	]
[ "clients",	"stop",	"pattern clients.stop(id:int):void ",	"CLTstop;",	"Stop the query execution at the next eligble statement."	]
[ "clients",	"suspend",	"pattern clients.suspend(id:int):void ",	"CLTsuspend;",	"Put a client process to sleep for some time.\nIt will simple sleep for a second at a time, until\nthe awake bit has been set in its descriptor"	]
[ "clients",	"wakeup",	"command clients.wakeup(id:int):void ",	"CLTwakeup;",	"Wakeup a client process"	]
[ "color",	"#fromstr",	"command color.#fromstr():void ",	"color_fromstr;",	""	]
[ "color",	"#tostr",	"command color.#tostr():void ",	"color_tostr;",	""	]
[ "color",	"blue",	"command color.blue(c:color):int ",	"CLRblue;",	"Extracts blue component from a color atom"	]
[ "color",	"cb",	"command color.cb(c:color):int ",	"CLRcb;",	"Extracts Cb(blue color) component from a color atom"	]
[ "color",	"color",	"command color.color(s:str):color ",	"CLRcolor;",	"Converts string to color"	]
[ "color",	"cr",	"command color.cr(c:color):int ",	"CLRcr;",	"Extracts Cr(red color) component from a color atom"	]
[ "color",	"green",	"command color.green(c:color):int ",	"CLRgreen;",	"Extracts green component from a color atom"	]
[ "color",	"hsv",	"command color.hsv(h:flt,s:flt,v:flt):color ",	"CLRhsv;",	"Converts an HSV triplets to a color atom"	]
[ "color",	"hue",	"command color.hue(c:color):flt ",	"CLRhue;",	"Extracts hue component from a color atom"	]
[ "color",	"hue",	"command color.hue(c:color):int ",	"CLRhueInt;",	"Extracts hue component from a color atom"	]
[ "color",	"luminance",	"command color.luminance(c:color):int ",	"CLRluminance;",	"Extracts Y(luminance) component from a color atom"	]
[ "color",	"red",	"command color.red(c:color):int ",	"CLRred;",	"Extracts red component from a color atom"	]
[ "color",	"rgb",	"command color.rgb(r:int,g:int,b:int):color ",	"CLRrgb;",	"Converts an RGB triplets to a color atom"	]
[ "color",	"saturation",	"command color.saturation(c:color):flt ",	"CLRsaturation;",	"Extracts saturation component from a color atom"	]
[ "color",	"saturation",	"command color.saturation(c:color):int ",	"CLRsaturationInt;",	"Extracts saturation component from a color atom"	]
[ "color",	"str",	"command color.str(s:color):str ",	"CLRstr;",	"Converts color to string "	]
[ "color",	"value",	"command color.value(c:color):flt ",	"CLRvalue;",	"Extracts value component from a color atom"	]
[ "color",	"value",	"command color.value(c:color):int ",	"CLRvalueInt;",	"Extracts value component from a color atom"	]
[ "color",	"ycc",	"command color.ycc(y:int,cr:int,cb:int):color ",	"CLRycc;",	"Converts an YCC triplets to a color atom"	]
[ "date",	"!=",	"pattern date.!=(v:date,w:date):bit ",	"CMDvarNE;",	"Equality of two dates"	]
[ "date",	"#fromstr",	"command date.#fromstr():void ",	"date_fromstr;",	""	]
[ "date",	"#tostr",	"command date.#tostr():void ",	"date_tostr;",	""	]
[ "date",	"<",	"pattern date.<(v:date,w:date):bit ",	"CMDvarLT;",	"Equality of two dates"	]
[ "date",	"<=",	"pattern date.<=(v:date,w:date):bit ",	"CMDvarLE;",	"Equality of two dates"	]
[ "date",	"==",	"pattern date.==(v:date,w:date):bit ",	"CMDvarEQ;",	"Equality of two dates"	]
[ "date",	">",	"pattern date.>(v:date,w:date):bit ",	"CMDvarGT;",	"Equality of two dates"	]
[ "date",	">=",	"pattern date.>=(v:date,w:date):bit ",	"CMDvarGE;",	"Equality of two dates"	]
[ "date",	"date",	"command date.date(s:date):date ",	"MTIMEdate_date;",	"Noop routine."	]
[ "date",	"isnil",	"pattern date.isnil(v:date):bit ",	"CMDvarISNIL;",	"Nil test for date value"	]
[ "daytime",	"!=",	"pattern daytime.!=(v:daytime,w:daytime):bit ",	"CMDvarNE;",	"Equality of two daytimes"	]
[ "daytime",	"#fromstr",	"command daytime.#fromstr():void ",	"daytime_tz_fromstr;",	""	]
[ "daytime",	"#tostr",	"command daytime.#tostr():void ",	"daytime_tostr;",	""	]
[ "daytime",	"<",	"pattern daytime.<(v:daytime,w:daytime):bit ",	"CMDvarLT;",	"Equality of two daytimes"	]
[ "daytime",	"<=",	"pattern daytime.<=(v:daytime,w:daytime):bit ",	"CMDvarLE;",	"Equality of two daytimes"	]
[ "daytime",	"==",	"pattern daytime.==(v:daytime,w:daytime):bit ",	"CMDvarEQ;",	"Equality of two daytimes"	]
[ "daytime",	">",	"pattern daytime.>(v:daytime,w:daytime):bit ",	"CMDvarGT;",	"Equality of two daytimes"	]
[ "daytime",	">=",	"pattern daytime.>=(v:daytime,w:daytime):bit ",	"CMDvarGE;",	"Equality of two daytimes"	]
[ "daytime",	"isnil",	"pattern daytime.isnil(v:daytime):bit ",	"CMDvarISNIL;",	"Nil test for daytime value"	]
[ "factories",	"getArrival",	"command factories.getArrival():bat[:timestamp] ",	"FCTgetArrival;",	"Retrieve the time stamp the last call was made."	]
[ "factories",	"getCaller",	"command factories.getCaller():int ",	"FCTgetCaller;",	"Retrieve the unique identity of the factory caller."	]
[ "factories",	"getDeparture",	"command factories.getDeparture():bat[:timestamp] ",	"FCTgetDeparture;",	"Retrieve the time stamp the last answer was returned."	]
[ "factories",	"getOwners",	"command factories.getOwners():bat[:str] ",	"FCTgetOwners;",	"Retrieve the factory owners table."	]
[ "factories",	"getPlants",	"command factories.getPlants() (mod:bat[:str],fcn:bat[:str]) ",	"FCTgetPlants;",	"Retrieve the names for all active factories."	]
[ "factories",	"shutdown",	"pattern factories.shutdown(m:str,f:str):void ",	"FCTshutdown;",	"Close a factory."	]
[ "fits",	"attach",	"pattern fits.attach(fname:str):void ",	"FITSattach;",	"Open a FITS file and return catalog of the table HDUs"	]
[ "fits",	"export",	"pattern fits.export(tablename:str):void ",	"FITSexportTable;",	"Export a table to a FITS file"	]
[ "fits",	"fitstest",	"command fits.fitstest(filename:str):int ",	"FITStest;",	"Returns the type of first extension in the FITS file filename"	]
[ "fits",	"listdir",	"pattern fits.listdir(dirname:str):void ",	"FITSdir;",	"Attach all FITS files in the directory"	]
[ "fits",	"listdirpattern",	"pattern fits.listdirpattern(dirname:str,pattern:str):void ",	"FITSdirpat;",	"Attach all FITS file in the directory, giving a pattern"	]
[ "fits",	"load",	"pattern fits.load(tablename:str):void ",	"FITSloadTable;",	"Load a FITS table from an attached file"	]
[ "generator",	"join",	"pattern generator.join(b:bat[:bte],gen:bat[:bte]) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_join;",	""	]
[ "generator",	"join",	"pattern generator.join(b:bat[:dbl],gen:bat[:dbl]) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_join;",	"Overloaded join operation"	]
[ "generator",	"join",	"pattern generator.join(b:bat[:flt],gen:bat[:flt]) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_join;",	""	]
[ "generator",	"join",	"pattern generator.join(b:bat[:hge],gen:bat[:hge]) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_join;",	"Overloaded join operation"	]
[ "generator",	"join",	"pattern generator.join(b:bat[:int],gen:bat[:int]) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_join;",	""	]
[ "generator",	"join",	"pattern generator.join(b:bat[:lng],gen:bat[:lng]) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_join;",	""	]
[ "generator",	"join",	"pattern generator.join(b:bat[:sht],gen:bat[:sht]) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_join;",	""	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:bte],low:bat[:bte],hgh:bat[:bte],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	""	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:dbl],low:bat[:dbl],hgh:bat[:dbl],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	"Overloaded range join operation"	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:flt],low:bat[:flt],hgh:bat[:flt],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	""	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:int],low:bat[:int],hgh:bat[:int],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	""	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:lng],low:bat[:lng],hgh:bat[:lng],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	""	]
[ "generator",	"join",	"pattern generator.join(gen:bat[:sht],low:bat[:sht],hgh:bat[:sht],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) ",	"VLTgenerator_rangejoin;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:bte,last:bte):bat[:bte] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:bte,last:bte,step:bte):bat[:bte] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:dbl,last:dbl):bat[:dbl] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:dbl,last:dbl,step:dbl):bat[:dbl] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:flt,last:flt):bat[:flt] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:flt,last:flt,step:flt):bat[:flt] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:hge,last:hge):bat[:hge] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:hge,last:hge,step:hge):bat[:hge] ",	"VLTgenerator_noop;",	"Retain the table definition, but don't materialize"	]
[ "generator",	"parameters",	"pattern generator.parameters(first:int,last:int):bat[:int] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:int,last:int,step:int):bat[:int] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:lng,last:lng):bat[:lng] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:lng,last:lng,step:lng):bat[:lng] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:sht,last:sht):bat[:sht] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:sht,last:sht,step:sht):bat[:sht] ",	"VLTgenerator_noop;",	""	]
[ "generator",	"parameters",	"pattern generator.parameters(first:timestamp,last:timestamp,step:lng):bat[:timestamp] ",	"VLTgenerator_noop;",	"Retain the table definition, but don't materialize"	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid],cand:bat[:bte]):bat[:bte] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid],cand:bat[:dbl]):bat[:dbl] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid],cand:bat[:flt]):bat[:flt] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid],cand:bat[:hge]):bat[:hge] ",	"VLTgenerator_projection;",	"Overloaded projection operation"	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid],cand:bat[:int]):bat[:int] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid],cand:bat[:lng]):bat[:lng] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid],cand:bat[:sht]):bat[:sht] ",	"VLTgenerator_projection;",	""	]
[ "generator",	"projection",	"pattern generator.projection(b:bat[:oid],cand:bat[:timestamp]):bat[:timestamp] ",	"VLTgenerator_projection;",	"Overloaded projection operation"	]
[ "generator",	"series",	"pattern generator.series(first:bte,last:bte):bat[:bte] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:bte,last:bte,step:bte):bat[:bte] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:dbl,last:dbl):bat[:dbl] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:dbl,last:dbl,step:dbl):bat[:dbl] ",	"VLTgenerator_table;",	"Create and materialize a generator table"	]
[ "generator",	"series",	"pattern generator.series(first:flt,last:flt):bat[:flt] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:flt,last:flt,step:flt):bat[:flt] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:hge,last:hge):bat[:hge] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:hge,last:hge,step:hge):bat[:hge] ",	"VLTgenerator_table;",	"Create and materialize a generator table"	]
[ "generator",	"series",	"pattern generator.series(first:int,last:int):bat[:int] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:int,last:int,step:int):bat[:int] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:lng,last:lng):bat[:lng] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:lng,last:lng,step:lng):bat[:lng] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:sht,last:sht):bat[:sht] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:sht,last:sht,step:sht):bat[:sht] ",	"VLTgenerator_table;",	""	]
[ "generator",	"series",	"pattern generator.series(first:timestamp,last:timestamp,step:lng):bat[:timestamp] ",	"VLTgenerator_table;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:bte],cand:bat[:oid],low:bte,high:bte,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:bte],low:bte,high:bte,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:dbl],cand:bat[:oid],low:dbl,high:dbl,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:dbl],low:dbl,high:dbl,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:flt],cand:bat[:oid],low:flt,high:flt,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:flt],low:flt,high:flt,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:hge],cand:bat[:oid],low:hge,high:hge,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	"Overloaded selection routine"	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:hge],low:hge,high:hge,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	"Overloaded selection routine"	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:int],cand:bat[:oid],low:int,high:int,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:int],low:int,high:int,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:lng],cand:bat[:oid],low:lng,high:lng,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:lng],low:lng,high:lng,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:sht],cand:bat[:oid],low:sht,high:sht,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:sht],low:sht,high:sht,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	""	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:timestamp],cand:bat[:oid],low:timestamp,high:timestamp,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	"Overloaded selection routine"	]
[ "generator",	"subselect",	"pattern generator.subselect(b:bat[:timestamp],low:timestamp,high:timestamp,li:bit,hi:bit,anti:bit):bat[:oid] ",	"VLTgenerator_subselect;",	"Overloaded selection routine"	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:bte],cnd:bat[:oid],low:bte,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:bte],low:bte,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:dbl],cnd:bat[:oid],low:dbl,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:dbl],low:dbl,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:flt],cnd:bat[:oid],low:flt,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:flt],low:flt,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:hge],cnd:bat[:oid],low:hge,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	"Overloaded selection routine"	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:hge],low:hge,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	"Overloaded selection routine"	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:int],cnd:bat[:oid],low:int,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:int],low:int,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:lng],cnd:bat[:oid],low:lng,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:lng],low:lng,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:sht],cnd:bat[:oid],low:sht,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:sht],low:sht,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	""	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:timestamp],cnd:bat[:oid],low:timestamp,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	"Overloaded selection routine"	]
[ "generator",	"thetasubselect",	"pattern generator.thetasubselect(b:bat[:timestamp],low:timestamp,oper:str):bat[:oid] ",	"VLTgenerator_thetasubselect;",	"Overloaded selection routine"	]
[ "geom",	"Area",	"command geom.Area(w:wkb):dbl ",	"wkbArea;",	"Returns the area of the surface if it is a polygon or multi-polygon"	]
[ "geom",	"AsBinary",	"command geom.AsBinary(w:wkb):str ",	"wkbAsBinary;",	"Returns the wkb representation into HEX format"	]
[ "geom",	"AsEWKT",	"function geom.AsEWKT(w:wkb):str;",	"",	""	]
[ "geom",	"AsText",	"function geom.AsText(w:wkb):str;",	"",	""	]
[ "geom",	"BdMPolyFromText",	"function geom.BdMPolyFromText(wkt:str,srid:int):wkb;",	"",	""	]
[ "geom",	"BdPolyFromText",	"function geom.BdPolyFromText(wkt:str,srid:int):wkb;",	"",	""	]
[ "geom",	"Boundary",	"command geom.Boundary(w:wkb):wkb ",	"wkbBoundary;",	"Returns the closure of the combinatorial boundary of the Geometry."	]
[ "geom",	"Buffer",	"command geom.Buffer(a:wkb,distance:dbl):wkb ",	"wkbBuffer;",	"Returns a geometry that represents all points whose distance from this geometry is less than or equal to distance. Calculations are in the Spatial Reference System of this Geometry."	]
[ "geom",	"Centroid",	"command geom.Centroid(w:wkb):wkb ",	"wkbCentroid;",	"Computes the geometric center of a geometry, or equivalently, the center of mass of the geometry as a POINT."	]
[ "geom",	"Contains",	"command geom.Contains(a:wkb,b:wkb):bit ",	"wkbContains;",	"Returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A."	]
[ "geom",	"Contains",	"command geom.Contains(a:wkb,x:dbl,y:dbl):bit ",	"wkbContains_point;",	"Returns true if the Geometry a 'spatially contains' Geometry b"	]
[ "geom",	"Contains",	"command geom.Contains(a:wkb,px:bat[:dbl],py:bat[:dbl]):bat[:bit] ",	"wkbContains_point_bat;",	"Returns true if the Geometry-BAT a 'spatially contains' Geometry-B b"	]
[ "geom",	"ConvexHull",	"command geom.ConvexHull(w:wkb):wkb ",	"wkbConvexHull;",	"Returns a geometry that represents the convex hull of this geometry. The convex hull of a geometry represents the minimum convex geometry that encloses all geometries within the set."	]
[ "geom",	"CoordDim",	"command geom.CoordDim(w:wkb):int ",	"wkbCoordDim;",	" Return the coordinate dimension of the geometry"	]
[ "geom",	"CoveredBy",	"command geom.CoveredBy(a:wkb,b:wkb):bit ",	"wkbCoveredBy;",	"Returns TRUE if no point of geometry A is outside geometry B"	]
[ "geom",	"Covers",	"command geom.Covers(a:wkb,b:wkb):bit ",	"wkbCovers;",	"Returns TRUE if no point of geometry B is outside geometry A"	]
[ "geom",	"Crosses",	"command geom.Crosses(a:wkb,b:wkb):bit ",	"wkbCrosses;",	"Returns TRUE if the supplied geometries have some, but not all, interior points in common."	]
[ "geom",	"DWithin",	"command geom.DWithin(a:wkb,b:wkb,dst:dbl):bit ",	"wkbDWithin;",	"Returns true if the two geometries are within the specifies distance from each other"	]
[ "geom",	"DelaunayTriangles",	"command geom.DelaunayTriangles(a:wkb,tolerance:dbl,flag:int):wkb ",	"wkbDelaunayTriangles;",	"Returns a Delaunay triangulation, flag=0 => collection of polygons, flag=1 => multilinestring"	]
[ "geom",	"Difference",	"command geom.Difference(a:wkb,b:wkb):wkb ",	"wkbDifference;",	"Returns a geometry that represents that part of geometry A that does not intersect with geometry B"	]
[ "geom",	"Dimension",	"command geom.Dimension(w:wkb):int ",	"wkbDimension;",	"The inherent dimension of this Geometry object, which must be less than or equal to the coordinate dimension."	]
[ "geom",	"Disjoint",	"command geom.Disjoint(a:wkb,b:wkb):bit ",	"wkbDisjoint;",	"Returns true if these Geometries are 'spatially disjoint'"	]
[ "geom",	"Distance",	"command geom.Distance(a:wkb,b:wkb):dbl ",	"wkbDistance;",	"Returns the 2-dimensional minimum cartesian distance between the two geometries in projected units (spatial ref units."	]
[ "geom",	"Dump",	"command geom.Dump(a:wkb) (id:bat[:str],geom:bat[:wkb]) ",	"wkbDump;",	"Gets a MultiPolygon and returns the Polygons in it"	]
[ "geom",	"DumpPoints",	"command geom.DumpPoints(a:wkb) (id:bat[:str],geom:bat[:wkb]) ",	"wkbDumpPoints;",	"Gets a Geometry and returns the Points in it"	]
[ "geom",	"EndPoint",	"command geom.EndPoint(w:wkb):wkb ",	"wkbEndPoint;",	"Returns the last point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING."	]
[ "geom",	"Envelope",	"command geom.Envelope(w:wkb):wkb ",	"wkbEnvelope;",	"The minimum bounding box for this Geometry, returned as a Geometry. The polygon is defined by the corner points of the bounding box ((MINX,MINY),(MAXX,MINY),(MAXX,MAXY),(MINX,MAXY))."	]
[ "geom",	"EnvelopeFromCoordinates",	"command geom.EnvelopeFromCoordinates(X_0:dbl,X_1:dbl,X_2:dbl,X_3:dbl,X_4:int):wkb ",	"wkbEnvelopeFromCoordinates;",	"A polygon created by the provided coordinates"	]
[ "geom",	"Equals",	"command geom.Equals(a:wkb,b:wkb):bit ",	"wkbEquals;",	"Returns true if the given geometries represent the same geometry. Directionality is ignored."	]
[ "geom",	"ExteriorRing",	"command geom.ExteriorRing(w:wkb):wkb ",	"wkbExteriorRing;",	"Returns a line string representing the exterior ring of the POLYGON geometry. Return NULL if the geometry is not a polygon."	]
[ "geom",	"Force2D",	"function geom.Force2D(g:wkb):wkb;",	"",	""	]
[ "geom",	"Force3D",	"function geom.Force3D(g:wkb):wkb;",	"",	""	]
[ "geom",	"ForceDimensions",	"command geom.ForceDimensions(g:wkb,d:int):wkb ",	"wkbForceDim;",	"Removes or Adds additional coordinates in the geometry to make it d dimensions"	]
[ "geom",	"FromBinary",	"command geom.FromBinary(w:str):wkb ",	"wkbFromBinary;",	"Creates a wkb using the HEX representation"	]
[ "geom",	"FromText",	"command geom.FromText(wkt:str,srid:int,type:int):wkb ",	"wkbFromText;",	""	]
[ "geom",	"GeomCollFromText",	"function geom.GeomCollFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"GeomCollFromText",	"function geom.GeomCollFromText(wkt:str,srid:int):wkb;",	"",	""	]
[ "geom",	"GeomFromText",	"function geom.GeomFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"GeomFromText",	"function geom.GeomFromText(wkt:str,srid:int):wkb;",	"",	""	]
[ "geom",	"GeometryN",	"command geom.GeometryN(g:wkb,n:int):wkb ",	"wkbGeometryN;",	"Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON. Otherwise, return NULL"	]
[ "geom",	"GeometryType",	"command geom.GeometryType(w:wkb,flag:int):str ",	"wkbGeometryType;",	""	]
[ "geom",	"GeometryType1",	"function geom.GeometryType1(w:wkb):str;",	"",	""	]
[ "geom",	"GeometryType2",	"function geom.GeometryType2(w:wkb):str;",	"",	""	]
[ "geom",	"GetCoordinate",	"command geom.GetCoordinate(w:wkb,idx:int):dbl ",	"wkbGetCoordinate;",	"Returns the coordinate at position idx of a point, or NULL if not available. idx=0 -> X, idx=1 -> Y, idx=2 -> Z. Input must be point"	]
[ "geom",	"InteriorRingN",	"command geom.InteriorRingN(w:wkb,n:int):wkb ",	"wkbInteriorRingN;",	"Return the Nth interior linestring ring of the polygon geometry. Return NULL if the geometry is not a polygon or the given N is out of range."	]
[ "geom",	"InteriorRings",	"command geom.InteriorRings(w:wkb):wkba ",	"wkbInteriorRings;",	"Returns an 'array' with all the interior rings of the polygon"	]
[ "geom",	"Intersection",	"command geom.Intersection(a:wkb,b:wkb):wkb ",	"wkbIntersection;",	"Returns a geometry that represents the point set intersection of the Geometries a, b"	]
[ "geom",	"Intersects",	"command geom.Intersects(a:wkb,b:wkb):bit ",	"wkbIntersects;",	"Returns true if these Geometries 'spatially intersect in 2D'"	]
[ "geom",	"IsClosed",	"command geom.IsClosed(w:wkb):bit ",	"wkbIsClosed;",	"Returns TRUE if the LINESTRING's start and end points are coincident."	]
[ "geom",	"IsEmpty",	"command geom.IsEmpty(w:wkb):bit ",	"wkbIsEmpty;",	"Returns true if this Geometry is an empty geometry."	]
[ "geom",	"IsRing",	"command geom.IsRing(w:wkb):bit ",	"wkbIsRing;",	"Returns TRUE if this LINESTRING is both closed and simple."	]
[ "geom",	"IsSimple",	"command geom.IsSimple(w:wkb):bit ",	"wkbIsSimple;",	"Returns (TRUE) if this Geometry has no anomalous geometric points, such as self intersection or self tangency."	]
[ "geom",	"IsValid",	"command geom.IsValid(w:wkb):bit ",	"wkbIsValid;",	"Returns true if the ST_Geometry is well formed."	]
[ "geom",	"IsValidDetail",	"command geom.IsValidDetail(w:wkb):str ",	"wkbIsValidDetail;",	"Returns a valid_detail (valid,reason,location) row stating if a geometry is valid or not and if not valid, a reason why and a location where."	]
[ "geom",	"IsValidReason",	"command geom.IsValidReason(w:wkb):str ",	"wkbIsValidReason;",	"Returns text stating if a geometry is valid or not and if not valid, a reason why."	]
[ "geom",	"Length",	"command geom.Length(w:wkb):dbl ",	"wkbLength;",	"Returns the cartesian 2D length of the geometry if it is a linestrin or multilinestring"	]
[ "geom",	"LineFromText",	"function geom.LineFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"LineFromText",	"function geom.LineFromText(wkt:str,srid:int):wkb;",	"",	""	]
[ "geom",	"MLineFromText",	"function geom.MLineFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"MLineFromText",	"function geom.MLineFromText(wkt:str,srid:int):wkb;",	"",	""	]
[ "geom",	"MLineStringToPolygon",	"command geom.MLineStringToPolygon(wkt:str,srid:int,flag:int):wkb ",	"wkbMLineStringToPolygon;",	"Creates polygons using the MultiLineString provided as WKT. Depending on the flag creates one (flag=0) or multiple (flag=1) polygons"	]
[ "geom",	"MPointFromText",	"function geom.MPointFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"MPointFromText",	"function geom.MPointFromText(wkt:str,srid:int):wkb;",	"",	""	]
[ "geom",	"MPolyFromText",	"function geom.MPolyFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"MPolyFromText",	"function geom.MPolyFromText(wkt:str,srid:int):wkb;",	"",	""	]
[ "geom",	"MakeBox2D",	"command geom.MakeBox2D(X_0:wkb,X_1:wkb):mbr ",	"wkbBox2D;",	"Creates an mbr from the two 2D points"	]
[ "geom",	"MakeEnvelope",	"function geom.MakeEnvelope(xmin:dbl,ymin:dbl,xmax:dbl,ymax:dbl):wkb;",	"",	""	]
[ "geom",	"MakeEnvelope",	"function geom.MakeEnvelope(xmin:dbl,ymin:dbl,xmax:dbl,ymax:dbl,srid:int):wkb;",	"",	""	]
[ "geom",	"MakeLine",	"command geom.MakeLine(a:wkb,b:wkb):wkb ",	"wkbMakeLine;",	"Gets two point or linestring geometries and returns a linestring geometry"	]
[ "geom",	"MakeLine",	"command geom.MakeLine(a:bat[:wkb]):wkb ",	"wkbMakeLineAggr;",	"Gets a BAT with point or linestring geometries and returns a single linestring geometry"	]
[ "geom",	"MakePoint",	"function geom.MakePoint(x:dbl,y:dbl):wkb;",	"",	""	]
[ "geom",	"MakePoint",	"function geom.MakePoint(x:dbl,y:dbl,z:dbl):wkb;",	"",	""	]
[ "geom",	"MakePoint",	"function geom.MakePoint(x:dbl,y:dbl,z:dbl,m:dbl):wkb;",	"",	""	]
[ "geom",	"MakePointM",	"function geom.MakePointM(x:dbl,y:dbl,m:dbl):wkb;",	"",	""	]
[ "geom",	"MakePointXYZM",	"command geom.MakePointXYZM(x:dbl,y:dbl,z:dbl,m:dbl,zmFlag:int):wkb ",	"wkbMakePoint;",	"creates a point using the coordinates"	]
[ "geom",	"MakePolygon",	"function geom.MakePolygon(external:wkb):wkb;",	"",	""	]
[ "geom",	"MakePolygon",	"function geom.MakePolygon(external:wkb,srid:int):wkb;",	"",	""	]
[ "geom",	"NPoints",	"function geom.NPoints(w:wkb):int;",	"",	""	]
[ "geom",	"NRings",	"function geom.NRings(w:wkb):int;",	"",	""	]
[ "geom",	"NumGeometries",	"command geom.NumGeometries(g:wkb):int ",	"wkbNumGeometries;",	"Returns the number of geometries"	]
[ "geom",	"NumInteriorRings",	"function geom.NumInteriorRings(w:wkb):int;",	"",	""	]
[ "geom",	"NumPoints",	"function geom.NumPoints(w:wkb):int;",	"",	""	]
[ "geom",	"NumRings",	"command geom.NumRings(w:wkb,exterior:int):int ",	"wkbNumRings;",	"Returns the number of interior rings+exterior on the first polygon of the geometry"	]
[ "geom",	"Overlaps",	"command geom.Overlaps(a:wkb,b:wkb):bit ",	"wkbOverlaps;",	" Returns TRUE if the Geometries intersect but are not completely contained by each other."	]
[ "geom",	"PointFromText",	"function geom.PointFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"PointFromText",	"function geom.PointFromText(wkt:str,srid:int):wkb;",	"",	""	]
[ "geom",	"PointN",	"command geom.PointN(w:wkb,n:int):wkb ",	"wkbPointN;",	"Returns the n-th point of the Geometry. Argument w should be Linestring."	]
[ "geom",	"PointOnSurface",	"command geom.PointOnSurface(w:wkb):wkb ",	"wkbPointOnSurface;",	"Returns a point guaranteed to lie on the surface. Similar to postGIS it works for points and lines in addition to surfaces and for 3d geometries."	]
[ "geom",	"PointsNum",	"command geom.PointsNum(w:wkb,check:int):int ",	"wkbNumPoints;",	"The number of points in the Geometry. If check=1, the geometry should be a linestring"	]
[ "geom",	"Polygon",	"command geom.Polygon(X_0:wkb,X_1:bat[:wkb],X_2:int):wkb ",	"wkbMakePolygon;",	"Returns a Polygon created from the provided LineStrings"	]
[ "geom",	"PolygonFromText",	"function geom.PolygonFromText(wkt:str):wkb;",	"",	""	]
[ "geom",	"PolygonFromText",	"function geom.PolygonFromText(wkt:str,srid:int):wkb;",	"",	""	]
[ "geom",	"Relate",	"command geom.Relate(a:wkb,b:wkb,intersection_matrix_pattern:str):bit ",	"wkbRelate;",	"Returns true if the Geometry a 'spatially related' to Geometry b, by testing for intersection between the Interior, Boundary and Exterior of the two geometries as specified by the values in the intersectionPatternMatrix."	]
[ "geom",	"Segmentize",	"command geom.Segmentize(g:wkb,sz:dbl):wkb ",	"wkbSegmentize;",	"It creates a new geometry with all segments on it smaller or equal to sz"	]
[ "geom",	"StartPoint",	"command geom.StartPoint(w:wkb):wkb ",	"wkbStartPoint;",	"Returns the first point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING"	]
[ "geom",	"SymDifference",	"command geom.SymDifference(a:wkb,b:wkb):wkb ",	"wkbSymDifference;",	"Returns a geometry that represents the portions of A and B that do not intersect"	]
[ "geom",	"ToText",	"command geom.ToText(w:wkb,withSRID:int):str ",	"wkbAsText;",	""	]
[ "geom",	"Touches",	"command geom.Touches(a:wkb,b:wkb):bit ",	"wkbTouches;",	"Returns TRUE if the geometries have at least one point in common, but their interiors do not intersect."	]
[ "geom",	"Transform",	"command geom.Transform(g:wkb,srid_src:int,srid_dst:int,proj_src:str,proj_dest:str):wkb ",	"wkbTransform;",	"Transforms a geometry from one srid to another"	]
[ "geom",	"Translate",	"function geom.Translate(g:wkb,dx:dbl,dy:dbl):wkb;",	"",	""	]
[ "geom",	"Translate",	"function geom.Translate(g:wkb,dx:dbl,dy:dbl,dz:dbl):wkb;",	"",	""	]
[ "geom",	"Translate3D",	"command geom.Translate3D(g:wkb,dx:dbl,dy:dbl,dz:dbl):wkb ",	"wkbTranslate;",	"Moves all points of the geometry by dx, dy, dz"	]
[ "geom",	"Union",	"command geom.Union(a:wkb,b:wkb):wkb ",	"wkbUnion;",	"Returns a geometry that represents the point set union of the Geometries a, b"	]
[ "geom",	"Union",	"command geom.Union(a:bat[:wkb]):wkb ",	"wkbUnionAggr;",	"Gets a BAT with geometries and returns their union"	]
[ "geom",	"Within",	"command geom.Within(a:wkb,b:wkb):bit ",	"wkbWithin;",	"Returns TRUE if the geometry A is completely inside geometry B"	]
[ "geom",	"X",	"function geom.X(w:wkb):dbl;",	"",	""	]
[ "geom",	"XMaxFromMBR",	"function geom.XMaxFromMBR(b:mbr):dbl;",	"",	""	]
[ "geom",	"XMaxFromWKB",	"function geom.XMaxFromWKB(g:wkb):dbl;",	"",	""	]
[ "geom",	"XMinFromMBR",	"function geom.XMinFromMBR(b:mbr):dbl;",	"",	""	]
[ "geom",	"XMinFromWKB",	"function geom.XMinFromWKB(g:wkb):dbl;",	"",	""	]
[ "geom",	"Y",	"function geom.Y(w:wkb):dbl;",	"",	""	]
[ "geom",	"YMaxFromMBR",	"function geom.YMaxFromMBR(b:mbr):dbl;",	"",	""	]
[ "geom",	"YMaxFromWKB",	"function geom.YMaxFromWKB(g:wkb):dbl;",	"",	""	]
[ "geom",	"YMinFromMBR",	"function geom.YMinFromMBR(b:mbr):dbl;",	"",	""	]
[ "geom",	"YMinFromWKB",	"function geom.YMinFromWKB(g:wkb):dbl;",	"",	""	]
[ "geom",	"Z",	"function geom.Z(w:wkb):dbl;",	"",	""	]
[ "geom",	"coordinateFromMBR",	"command geom.coordinateFromMBR(X_0:mbr,X_1:int):dbl ",	"wkbCoordinateFromMBR;",	"returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided mbr"	]
[ "geom",	"coordinateFromWKB",	"command geom.coordinateFromWKB(X_0:wkb,X_1:int):dbl ",	"wkbCoordinateFromWKB;",	"returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided geometry"	]
[ "geom",	"epilogue",	"command geom.epilogue():void ",	"geom_epilogue;",	""	]
[ "geom",	"getSRID",	"command geom.getSRID(w:wkb):int ",	"wkbGetSRID;",	"Returns the Spatial Reference System ID for this Geometry."	]
[ "geom",	"getType",	"command geom.getType(flags:int,format:int):str ",	"geoGetType;",	"returns the str representation of the geometry type"	]
[ "geom",	"hasM",	"command geom.hasM(flags:int):int ",	"geoHasM;",	"returns 1 if the geometry has m coordinate"	]
[ "geom",	"hasZ",	"command geom.hasZ(flags:int):int ",	"geoHasZ;",	"returns 1 if the geometry has z coordinate"	]
[ "geom",	"mbr",	"command geom.mbr(X_0:wkb):mbr ",	"wkbMBR;",	"Creates the mbr for the given wkb."	]
[ "geom",	"mbrAbove",	"command geom.mbrAbove(box1:mbr,box2:mbr):bit ",	"mbrAbove;",	"Returns true if box1 is above box2"	]
[ "geom",	"mbrAbove",	"command geom.mbrAbove(geom1:wkb,geom2:wkb):bit ",	"mbrAbove_wkb;",	"Returns true if the mbr of geom1 is above the mbr of geom2"	]
[ "geom",	"mbrBelow",	"command geom.mbrBelow(box1:mbr,box2:mbr):bit ",	"mbrBelow;",	"Returns true if box1 is below box2"	]
[ "geom",	"mbrBelow",	"command geom.mbrBelow(geom1:wkb,geom2:wkb):bit ",	"mbrBelow_wkb;",	"Returns true if the mbr of geom1 is below the mbr of geom2"	]
[ "geom",	"mbrContained",	"command geom.mbrContained(box1:mbr,box2:mbr):bit ",	"mbrContained;",	"Returns true if box1 is contained by box2"	]
[ "geom",	"mbrContained",	"command geom.mbrContained(geom1:wkb,geom2:wkb):bit ",	"mbrContained_wkb;",	"Returns true if the mbr of geom1 is contained by the mbr of geom2"	]
[ "geom",	"mbrContains",	"command geom.mbrContains(box1:mbr,box2:mbr):bit ",	"mbrContains;",	"Returns true if box1 contains box2"	]
[ "geom",	"mbrContains",	"command geom.mbrContains(geom1:wkb,geom2:wkb):bit ",	"mbrContains_wkb;",	"Returns true if the mbr of geom1 contains the mbr of geom2"	]
[ "geom",	"mbrDistance",	"command geom.mbrDistance(box1:mbr,box2:mbr):dbl ",	"mbrDistance;",	"Returns the distance of the centroids of the two boxes"	]
[ "geom",	"mbrDistance",	"command geom.mbrDistance(geom1:wkb,geom2:wkb):dbl ",	"mbrDistance_wkb;",	"Returns the distance of the centroids of the mbrs of the two geometries"	]
[ "geom",	"mbrEqual",	"command geom.mbrEqual(box1:mbr,box2:mbr):bit ",	"mbrEqual;",	"Returns true if box1 is the same as box2"	]
[ "geom",	"mbrEqual",	"command geom.mbrEqual(geom1:wkb,geom2:wkb):bit ",	"mbrEqual_wkb;",	"Returns true if the mbr of geom1 is the same as the mbr of geom2"	]
[ "geom",	"mbrLeft",	"command geom.mbrLeft(box1:mbr,box2:mbr):bit ",	"mbrLeft;",	"Returns true if box1 is left of box2"	]
[ "geom",	"mbrLeft",	"command geom.mbrLeft(geom1:wkb,geom2:wkb):bit ",	"mbrLeft_wkb;",	"Returns true if the mbr of geom1 is left of the mbr of geom2"	]
[ "geom",	"mbrOverlapOrAbove",	"command geom.mbrOverlapOrAbove(box1:mbr,box2:mbr):bit ",	"mbrOverlapOrAbove;",	"Returns true if box1 overlaps or is above box2"	]
[ "geom",	"mbrOverlapOrAbove",	"command geom.mbrOverlapOrAbove(geom1:wkb,geom2:wkb):bit ",	"mbrOverlapOrAbove_wkb;",	"Returns true if the mbr of geom1 overlaps or is above the mbr of geom2"	]
[ "geom",	"mbrOverlapOrBelow",	"command geom.mbrOverlapOrBelow(box1:mbr,box2:mbr):bit ",	"mbrOverlapOrBelow;",	"Returns true if box1 overlaps or is below box2"	]
[ "geom",	"mbrOverlapOrBelow",	"command geom.mbrOverlapOrBelow(geom1:wkb,geom2:wkb):bit ",	"mbrOverlapOrBelow_wkb;",	"Returns true if the mbr of geom1 overlaps or is below the mbr of geom2"	]
[ "geom",	"mbrOverlapOrLeft",	"command geom.mbrOverlapOrLeft(box1:mbr,box2:mbr):bit ",	"mbrOverlapOrLeft;",	"Returns true if box1 overlaps or is to the left of box2"	]
[ "geom",	"mbrOverlapOrLeft",	"command geom.mbrOverlapOrLeft(geom1:wkb,geom2:wkb):bit ",	"mbrOverlapOrLeft_wkb;",	"Returns true if the mbr of geom1 overlaps or is to the left of thr mbr of geom2"	]
[ "geom",	"mbrOverlapOrRight",	"command geom.mbrOverlapOrRight(box1:mbr,box2:mbr):bit ",	"mbrOverlapOrRight;",	"Returns true if box1 overlalps or is right of box2"	]
[ "geom",	"mbrOverlapOrRight",	"command geom.mbrOverlapOrRight(geom1:wkb,geom2:wkb):bit ",	"mbrOverlapOrRight_wkb;",	"Returns true if the mbr of geom1 overlalps or is right of the mbr of geom2"	]
[ "geom",	"mbrOverlaps",	"command geom.mbrOverlaps(box1:mbr,box2:mbr):bit ",	"mbrOverlaps;",	"Returns true if box1 overlaps box2"	]
[ "geom",	"mbrOverlaps",	"command geom.mbrOverlaps(geom1:wkb,geom2:wkb):bit ",	"mbrOverlaps_wkb;",	"Returns true if the mbr of geom1 overlaps the mbr of geom2"	]
[ "geom",	"mbrRight",	"command geom.mbrRight(box1:mbr,box2:mbr):bit ",	"mbrRight;",	"Returns true if box1 is right of box2"	]
[ "geom",	"mbrRight",	"command geom.mbrRight(geom1:wkb,geom2:wkb):bit ",	"mbrRight_wkb;",	"Returns true if the mbr of geom1 is right of the mbr of geom2"	]
[ "geom",	"prelude",	"command geom.prelude():void ",	"geom_prelude;",	""	]
[ "geom",	"setSRID",	"command geom.setSRID(w:wkb,srid:int):wkb ",	"wkbSetSRID;",	"Sets the Reference System ID for this Geometry."	]
[ "group",	"multicolumn",	"pattern group.multicolumn(b:bat[:any]...) (ref:bat[:oid],grp:bat[:oid],hist:bat[:any]) ",	"GROUPmulticolumngroup;",	"Derivation of a group index over multiple columns."	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:lng]) ",	"GRPsubgroup1;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1],g:bat[:oid]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:lng]) ",	"GRPsubgroup2;",	""	]
[ "group",	"subgroup",	"command group.subgroup(b:bat[:any_1],g:bat[:oid],e:bat[:oid],h:bat[:lng]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:lng]) ",	"GRPsubgroup4;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:lng]) ",	"GRPsubgroup1;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1],g:bat[:oid]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:lng]) ",	"GRPsubgroup2;",	""	]
[ "group",	"subgroupdone",	"command group.subgroupdone(b:bat[:any_1],g:bat[:oid],e:bat[:oid],h:bat[:lng]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:lng]) ",	"GRPsubgroup4;",	""	]
[ "gsl",	"chi2prob",	"command gsl.chi2prob(d:dbl,i:dbl):dbl ",	"GSLchisqProb;",	"Chi Squared probability"	]
[ "identifier",	"#fromstr",	"command identifier.#fromstr():void ",	"IDfromString;",	"Convert a string to an identifier without any check"	]
[ "identifier",	"#tostr",	"command identifier.#tostr():void ",	"IDtoString;",	"Convert identifier to string equivalent"	]
[ "identifier",	"identifier",	"command identifier.identifier(s:str):identifier ",	"IDentifier;",	"Cast a string to an identifer "	]
[ "identifier",	"prelude",	"command identifier.prelude():void ",	"IDprelude;",	"Initialize the module"	]
[ "inet",	"!=",	"command inet.!=(v:inet,w:inet):bit ",	"INET_comp_NEQ;",	"Inequality of two inets"	]
[ "inet",	"#cmp",	"command inet.#cmp():void ",	"INETcompare;",	""	]
[ "inet",	"#fromstr",	"command inet.#fromstr():void ",	"INETfromString;",	"Convert a string to an inet"	]
[ "inet",	"#null",	"command inet.#null():void ",	"INETnull;",	""	]
[ "inet",	"#tostr",	"command inet.#tostr():void ",	"INETtoString;",	"Convert inet to string equivalent"	]
[ "inet",	"<",	"command inet.<(v:inet,w:inet):bit ",	"INET_comp_LT;",	"Whether v is less than w"	]
[ "inet",	"<<",	"command inet.<<(v:inet,w:inet):bit ",	"INET_comp_CW;",	"Whether v is contained within w"	]
[ "inet",	"<<=",	"command inet.<<=(v:inet,w:inet):bit ",	"INET_comp_CWE;",	"Whether v is contained within or is equal to w"	]
[ "inet",	"<=",	"command inet.<=(v:inet,w:inet):bit ",	"INET_comp_LE;",	"Whether v is less than or equal to w"	]
[ "inet",	"=",	"command inet.=(v:inet,w:inet):bit ",	"INET_comp_EQ;",	"Equality of two inets"	]
[ "inet",	">",	"command inet.>(v:inet,w:inet):bit ",	"INET_comp_GT;",	"Whether v is greater than w"	]
[ "inet",	">=",	"command inet.>=(v:inet,w:inet):bit ",	"INET_comp_GE;",	"Whether v is equal to or greater than w"	]
[ "inet",	">>",	"command inet.>>(v:inet,w:inet):bit ",	"INET_comp_CS;",	"Whether v contains w"	]
[ "inet",	">>=",	"command inet.>>=(v:inet,w:inet):bit ",	"INET_comp_CSE;",	"Whether v contains or is equal to w"	]
[ "inet",	"abbrev",	"command inet.abbrev(X_0:inet):str ",	"INETabbrev;",	"Abbreviated display format as text"	]
[ "inet",	"broadcast",	"command inet.broadcast(X_0:inet):inet ",	"INETbroadcast;",	"Returns the broadcast address for network"	]
[ "inet",	"host",	"command inet.host(X_0:inet):str ",	"INEThost;",	"Extract IP address as text"	]
[ "inet",	"hostmask",	"command inet.hostmask(X_0:inet):inet ",	"INEThostmask;",	"Construct host mask for network"	]
[ "inet",	"isnil",	"command inet.isnil(v:inet):bit ",	"INET_isnil;",	"Nil test for inet value"	]
[ "inet",	"masklen",	"command inet.masklen(X_0:inet):int ",	"INETmasklen;",	"Extract netmask length"	]
[ "inet",	"netmask",	"command inet.netmask(X_0:inet):inet ",	"INETnetmask;",	"Construct netmask for network"	]
[ "inet",	"network",	"command inet.network(X_0:inet):inet ",	"INETnetwork;",	"Extract network part of address"	]
[ "inet",	"new",	"command inet.new(s:str):inet ",	"INETnew;",	"Create an inet from a string literal"	]
[ "inet",	"setmasklen",	"command inet.setmasklen(X_0:inet,X_1:int):inet ",	"INETsetmasklen;",	"Set netmask length for inet value"	]
[ "inet",	"text",	"command inet.text(X_0:inet):str ",	"INETtext;",	"Extract IP address and netmask length as text"	]
[ "inspect",	"equalType",	"pattern inspect.equalType(l:any,r:any):bit ",	"INSPECTequalType;",	"Return true if both operands are of the same type"	]
[ "inspect",	"getAddress",	"pattern inspect.getAddress(mod:str,fcn:str):bat[:str] ",	"INSPECTgetAddress;",	"Returns the function signature(s)."	]
[ "inspect",	"getAddresses",	"pattern inspect.getAddresses():bat[:str] ",	"INSPECTgetAllAddresses;",	"Obtain the function address."	]
[ "inspect",	"getAtomNames",	"command inspect.getAtomNames():bat[:str] ",	"INSPECTatom_names;",	"Collect a BAT with the atom names."	]
[ "inspect",	"getAtomSizes",	"command inspect.getAtomSizes():bat[:int] ",	"INSPECTatom_sizes;",	"Collect a BAT with the atom sizes."	]
[ "inspect",	"getAtomSuper",	"command inspect.getAtomSuper():bat[:str] ",	"INSPECTatom_sup_names;",	"Collect a BAT with the atom names."	]
[ "inspect",	"getComment",	"pattern inspect.getComment(mod:str,fcn:str):bat[:str] ",	"INSPECTgetComment;",	"Returns the function help information."	]
[ "inspect",	"getDefinition",	"pattern inspect.getDefinition(mod:str,fcn:str):bat[:str] ",	"INSPECTgetDefinition;",	"Returns a string representation of a specific function."	]
[ "inspect",	"getEnvironment",	"command inspect.getEnvironment() (k:bat[:str],v:bat[:str]) ",	"INSPECTgetEnvironment;",	"Collect the environment variables."	]
[ "inspect",	"getEnvironment",	"command inspect.getEnvironment(k:str):str ",	"INSPECTgetEnvironmentKey;",	"Get the value of an environemnt variable"	]
[ "inspect",	"getFunction",	"pattern inspect.getFunction():bat[:str] ",	"INSPECTgetAllFunctions;",	"Obtain the function name."	]
[ "inspect",	"getKind",	"pattern inspect.getKind():bat[:str] ",	"INSPECTgetkind;",	"Obtain the instruction kind."	]
[ "inspect",	"getModule",	"pattern inspect.getModule():bat[:str] ",	"INSPECTgetAllModules;",	"Obtain the function name."	]
[ "inspect",	"getSignature",	"pattern inspect.getSignature(mod:str,fcn:str):bat[:str] ",	"INSPECTgetSignature;",	"Returns the function signature(s)."	]
[ "inspect",	"getSignatures",	"pattern inspect.getSignatures():bat[:str] ",	"INSPECTgetAllSignatures;",	"Obtain the function signatures."	]
[ "inspect",	"getSize",	"pattern inspect.getSize(mod:str,fcn:str):lng ",	"INSPECTgetFunctionSize;",	"Return the storage size for a function (in bytes)."	]
[ "inspect",	"getSize",	"pattern inspect.getSize():lng ",	"INSPECTgetSize;",	"Return the storage size for the current function (in bytes)."	]
[ "inspect",	"getSource",	"pattern inspect.getSource(mod:str,fcn:str):str ",	"INSPECTgetSource;",	"Return the original input for a function."	]
[ "inspect",	"getStatistics",	"command inspect.getStatistics(nme:str):bat[:any_2] ",	"QOTgetStatistics;",	"Get optimizer property statistics \nsuch as #calls, #total actions, #total time"	]
[ "inspect",	"getType",	"pattern inspect.getType(v:any_1):str ",	"INSPECTtypeName;",	"Return the concrete type of a variable (expression)."	]
[ "io",	"export",	"command io.export(b:bat[:any_2],filepath:str):void ",	"IOexport;",	"Export a BAT as ASCII to a file. If the 'filepath' is not absolute, it\n is put into the $DBPATH directory. Success of failure is indicated."	]
[ "io",	"import",	"command io.import(b:bat[:any_2],filepath:str):void ",	"IOimport;",	"Import a BAT from an ASCII dump. The tuples are appended to the\n first argument. Its signature must match the dump,\n else parsing errors will occur as an exception."	]
[ "io",	"print",	"pattern io.print(val:any_1):void ",	"IOprint_val;",	"Print a MAL value."	]
[ "io",	"print",	"pattern io.print(val:any_1,lst:any...):void ",	"IOprint_val;",	"Print a MAL value tuple ."	]
[ "io",	"print",	"pattern io.print(val:bat[:any_1]):void ",	"IOprint_val;",	"Print a MAL value column ."	]
[ "io",	"print",	"pattern io.print(b1:bat[:any]...):void ",	"IOtable;",	"BATs are printed with '#' for legend \n\tlines, and the BUNs on seperate lines \n\tbetween brackets, containing each to \n\tcomma separated values (head and tail). \n\tIf multiple BATs are passed for printing, \n\tprint() performs an implicit natural \n\tjoin on the void head, producing a multi attribute table."	]
[ "io",	"printf",	"pattern io.printf(fmt:str):void ",	"IOprintf;",	"Select default format "	]
[ "io",	"printf",	"pattern io.printf(fmt:str,val:any...):void ",	"IOprintf;",	"Select default format "	]
[ "io",	"printf",	"pattern io.printf(filep:streams,fmt:str):void ",	"IOprintfStream;",	"Select default format "	]
[ "io",	"printf",	"pattern io.printf(filep:streams,fmt:str,val:any...):void ",	"IOprintfStream;",	"Select default format "	]
[ "io",	"setmemorylimit",	"command io.setmemorylimit(nbytes:lng):void ",	"IOsetmemorylimit;",	"Set memory limit for testing"	]
[ "io",	"stderr",	"pattern io.stderr():streams ",	"io_stderr;",	"return the error stream for the database console"	]
[ "io",	"stdin",	"pattern io.stdin():bstream ",	"io_stdin;",	"return the input stream to the database client"	]
[ "io",	"stdout",	"pattern io.stdout():streams ",	"io_stdout;",	"return the output stream for the database client"	]
[ "iterator",	"filter",	"command iterator.filter(name:json,idx:hge,other:str):json ",	"JSONfilterArrayDefault_hge;",	""	]
[ "iterator",	"filter",	"command iterator.filter(name:json,idx:hge):json ",	"JSONfilterArray_hge;",	""	]
[ "iterator",	"new",	"pattern iterator.new(b:bat[:any_2]) (h:oid,t:any_2) ",	"ITRbunIterator;",	"Process the buns one by one extracted from a void table."	]
[ "iterator",	"new",	"command iterator.new(b:bat[:any_2],size:lng) (X_0:lng,X_1:bat[:any_2]) ",	"ITRnewChunk;",	"Create an iterator with fixed granule size.\n\t  The result is a view."	]
[ "iterator",	"next",	"pattern iterator.next(b:bat[:any_2]) (h:oid,t:any_2) ",	"ITRbunNext;",	"Produce the next bun for processing."	]
[ "iterator",	"next",	"command iterator.next(b:bat[:any_2],size:lng) (X_0:lng,X_1:bat[:any_2]) ",	"ITRnextChunk;",	"Produce the next chunk for processing."	]
[ "iterator",	"next",	"command iterator.next(step:dbl,last:dbl):dbl ",	"ITRnext_dbl;",	"Advances the iterator with a fixed value"	]
[ "iterator",	"next",	"command iterator.next(step:flt,last:flt):flt ",	"ITRnext_flt;",	""	]
[ "iterator",	"next",	"command iterator.next(step:hge,last:hge):hge ",	"ITRnext_hge;",	""	]
[ "iterator",	"next",	"command iterator.next(step:int,last:int):int ",	"ITRnext_int;",	""	]
[ "iterator",	"next",	"command iterator.next(step:lng,last:lng):lng ",	"ITRnext_lng;",	""	]
[ "iterator",	"next",	"command iterator.next(step:oid,last:oid):oid ",	"ITRnext_oid;",	""	]
[ "iterator",	"next",	"command iterator.next(step:sht,last:sht):sht ",	"ITRnext_sht;",	""	]
[ "json",	"#fromstr",	"command json.#fromstr():void ",	"JSONfromString;",	"Validate a string to be JSON compliant. A NOOP if valid json, NULL otherwise."	]
[ "json",	"#tostr",	"command json.#tostr():void ",	"JSONtoString;",	"Convert JSON to its string equivalent. Dealing with escape characters"	]
[ "json",	"dump",	"command json.dump(j:json):void ",	"JSONdump;",	""	]
[ "json",	"filter",	"command json.filter(name:json,pathexpr:str):json ",	"JSONfilter;",	"Filter all members of an object by a path expression, returning an array.\nNon-matching elements are skipped."	]
[ "json",	"filter",	"command json.filter(name:json,idx:bte,other:str):json ",	"JSONfilterArrayDefault_bte;",	""	]
[ "json",	"filter",	"command json.filter(name:json,idx:int,other:str):json ",	"JSONfilterArrayDefault_int;",	""	]
[ "json",	"filter",	"command json.filter(name:json,idx:lng,other:str):json ",	"JSONfilterArrayDefault_lng;",	"Extract a single array element"	]
[ "json",	"filter",	"command json.filter(name:json,idx:sht,other:str):json ",	"JSONfilterArrayDefault_sht;",	""	]
[ "json",	"filter",	"command json.filter(name:json,idx:bte):json ",	"JSONfilterArray_bte;",	""	]
[ "json",	"filter",	"command json.filter(name:json,idx:int):json ",	"JSONfilterArray_int;",	""	]
[ "json",	"filter",	"command json.filter(name:json,idx:lng):json ",	"JSONfilterArray_lng;",	""	]
[ "json",	"filter",	"command json.filter(name:json,idx:sht):json ",	"JSONfilterArray_sht;",	""	]
[ "json",	"fold",	"pattern json.fold(k:bat[:str],v:bat[:any]):json ",	"JSONfold;",	"Combine the key-value pairs into a single json object list."	]
[ "json",	"fold",	"pattern json.fold(o:bat[:oid],k:bat[:str],v:bat[:any]):json ",	"JSONfold;",	"Combine the key-value pairs into a single json object list."	]
[ "json",	"fold",	"pattern json.fold(v:bat[:any]):json ",	"JSONfold;",	"Combine the value list into a single json array object."	]
[ "json",	"integer",	"command json.integer(j:json):lng ",	"JSONjson2integer;",	"Convert simple JSON values to an integer, return nil upon error."	]
[ "json",	"isarray",	"command json.isarray(val:json):bit ",	"JSONisarray;",	"Validate the string as a valid JSON array"	]
[ "json",	"isarray",	"command json.isarray(val:str):bit ",	"JSONisarray;",	"Validate the string as a valid JSON array"	]
[ "json",	"isobject",	"command json.isobject(val:json):bit ",	"JSONisobject;",	"Validate the string as a valid JSON object"	]
[ "json",	"isobject",	"command json.isobject(val:str):bit ",	"JSONisobject;",	"Validate the string as a valid JSON object"	]
[ "json",	"isvalid",	"command json.isvalid(val:json):bit ",	"JSONisvalid;",	"Validate the string as a valid JSON document"	]
[ "json",	"isvalid",	"command json.isvalid(val:str):bit ",	"JSONisvalid;",	"Validate the string as a valid JSON document"	]
[ "json",	"keyarray",	"command json.keyarray(val:json):json ",	"JSONkeyArray;",	"Expands the outermost JSON object keys into a JSON value array."	]
[ "json",	"keys",	"command json.keys(val:json):bat[:str] ",	"JSONkeyTable;",	"Expands the outermost JSON object names."	]
[ "json",	"length",	"command json.length(val:json):int ",	"JSONlength;",	"Returns the number of elements in the outermost JSON object."	]
[ "json",	"new",	"command json.new(j:str):json ",	"JSONstr2json;",	"Convert string to its JSON. Dealing with escape characters"	]
[ "json",	"number",	"command json.number(j:json):dbl ",	"JSONjson2number;",	"Convert simple JSON values to a double, return nil upon error."	]
[ "json",	"output",	"command json.output(b:bat[:any_1]):str ",	"JSONtextString;",	"Pack the values into a single json structure"	]
[ "json",	"prelude",	"command json.prelude():void ",	"JSONprelude;",	""	]
[ "json",	"renderarray",	"pattern json.renderarray(val:any...):json ",	"JSONrenderarray;",	""	]
[ "json",	"renderobject",	"pattern json.renderobject(val:any...):json ",	"JSONrenderobject;",	""	]
[ "json",	"resultSet",	"command json.resultSet(u:bat[:uuid],rev:bat[:lng],js:bat[:json]):json ",	"JSONresultSet;",	"Converts the json store into a single json string:"	]
[ "json",	"str",	"command json.str(j:json):str ",	"JSONjson2str;",	"Convert JSON to its string equivalent. Dealing with escape characters"	]
[ "json",	"suboutput",	"command json.suboutput(b:bat[:any_1],gid:bat[:oid],ext:bat[:lng],flg:bit):bat[:str] ",	"JSONtextGrouped;",	"Pack the values into a json structure"	]
[ "json",	"text",	"command json.text(j:json):str ",	"JSONjson2text;",	"Convert JSON values to their plain string equivalent."	]
[ "json",	"text",	"command json.text(j:json,s:str):str ",	"JSONjson2textSeparator;",	"Convert JSON values to their plain string equivalent, injecting a separator."	]
[ "json",	"unfold",	"pattern json.unfold(val:json) (k:bat[:str],v:bat[:json]) ",	"JSONunfold;",	"Expands the outermost JSON object into key-value pairs."	]
[ "json",	"unfold",	"pattern json.unfold(val:json) (o:bat[:oid],k:bat[:str],v:bat[:json]) ",	"JSONunfold;",	"Expands the outermost JSON object into key-value pairs."	]
[ "json",	"valuearray",	"command json.valuearray(val:json):json ",	"JSONvalueArray;",	"Expands the outermost JSON object values into a JSON value array."	]
[ "json",	"values",	"command json.values(val:json):bat[:json] ",	"JSONvalueTable;",	"Expands the outermost JSON values."	]
[ "language",	"assert",	"command language.assert(v:bit,term:str):void ",	"MALassertBit;",	""	]
[ "language",	"assert",	"command language.assert(v:hge,term:str):void ",	"MALassertHge;",	""	]
[ "language",	"assert",	"command language.assert(v:int,term:str):void ",	"MALassertInt;",	""	]
[ "language",	"assert",	"command language.assert(v:lng,term:str):void ",	"MALassertLng;",	""	]
[ "language",	"assert",	"command language.assert(v:oid,term:str):void ",	"MALassertOid;",	""	]
[ "language",	"assert",	"command language.assert(v:sht,term:str):void ",	"MALassertSht;",	""	]
[ "language",	"assert",	"command language.assert(v:str,term:str):void ",	"MALassertStr;",	""	]
[ "language",	"assert",	"pattern language.assert(v:any_1,pname:str,oper:str,val:any_2):void ",	"MALassertTriple;",	"Assertion test."	]
[ "language",	"block",	"pattern language.block(v:int,w:any...):int ",	"deblockdataflow;",	"Block on availability of all variables w, and then pass on v"	]
[ "language",	"call",	"pattern language.call(s:bat[:str]):void ",	"CMDcallBAT;",	"Evaluate a program stored in a BAT."	]
[ "language",	"call",	"pattern language.call(m:str,f:str):void ",	"CMDcallFunction;",	""	]
[ "language",	"call",	"pattern language.call(s:str):void ",	"CMDcallString;",	"Evaluate a MAL string program."	]
[ "language",	"dataflow",	"pattern language.dataflow():bit ",	"MALstartDataflow;",	"The current guarded block is executed using dataflow control. "	]
[ "language",	"pass",	"pattern language.pass(v:any_1):void ",	"MALpass;",	"Cheap instruction to disgard storage while retaining the dataflow dependency"	]
[ "language",	"raise",	"command language.raise(msg:str):str ",	"CMDraise;",	"Raise an exception labeled \n\twith a specific message."	]
[ "language",	"register",	"pattern language.register(m:str,f:str,code:str,help:str):void ",	"CMDregisterFunction;",	"Compile the code string to MAL and register it as a function."	]
[ "language",	"sink",	"pattern language.sink(v:any...):void ",	"MALgarbagesink;",	"Variables to be considered together when triggering garbage collection.\nUsed in the dataflow blocks to avoid early release of values."	]
[ "language",	"source",	"pattern language.source(f:str):void ",	"CMDevalFile;",	"Merge the instructions stored in the file with the current program."	]
[ "lidar",	"attach",	"pattern lidar.attach(fname:str):void ",	"LIDARattach;",	"Open a LIDAR file and return catalog of the table HDUs"	]
[ "lidar",	"export",	"pattern lidar.export(tablename:str,fname:str,type:str):void ",	"LIDARexportTable;",	"Exporta LIDAR table to a LAS/LAZ file"	]
[ "lidar",	"load",	"pattern lidar.load(tablename:str):void ",	"LIDARloadTable;",	"Load a LIDAR table from an attached file"	]
[ "lidar",	"prelude",	"command lidar.prelude():void ",	"LIDARprelude;",	""	]
[ "lsst",	"angsep",	"command lsst.angsep(ra1:dbl,dec1:dbl,ra2:dbl,dec2:dbl):dbl ",	"qserv_angSep;",	"Returns the angular separation in degrees between two spherical\ncoordinate pairs (ra1,dec1) and (ra2,dec2)"	]
[ "lsst",	"ptinsphbox",	"command lsst.ptinsphbox(ra:dbl,dec:dbl,ra_min:dbl,dec_min:dbl,ra_max:dbl,dec_max:dbl):int ",	"qserv_ptInSphBox;",	"Returns 1 if the given spherical longitude/latitude box contains the given position"	]
[ "lsst",	"ptinsphcircle",	"command lsst.ptinsphcircle(ra:dbl,dec:dbl,ra_cen:dbl,dec_cen:dbl,radius:dbl):int ",	"qserv_ptInSphCircle;",	"Returns 1 if the given spherical longitude/latitude circle contains the given position"	]
[ "lsst",	"ptinsphellipse",	"command lsst.ptinsphellipse(ra:dbl,dec:dbl,ra_cen:dbl,dec_cen:dbl,smaa:dbl,smia:dbl,ang:dbl):int ",	"qserv_ptInSphEllipse;",	"Returns 1 if the given spherical longitude/latitude ellipse contains the given position"	]
[ "lsst",	"ptinsphpoly",	"pattern lsst.ptinsphpoly(ra:dbl,dec:dbl,list:dbl...):int ",	"qserv_ptInSphPoly;",	"Returns 1 if the given spherical longitude/latitude polyline contains the given position"	]
[ "lsst",	"xmatch",	"command lsst.xmatch(l:lng,r:lng,depth:int):bit ",	"LSSTxmatch;",	"Return true when the HtmID pairs that lie within the same triangle at level depth"	]
[ "lsst",	"xmatchsubjoin",	"command lsst.xmatchsubjoin(l:bat[:lng],r:bat[:lng],depth:int,sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (lr:bat[:oid],rr:bat[:oid]) ",	"LSSTxmatchsubjoin;",	"Return the HtmID pairs that lie within the same triangle at level depth"	]
[ "lsst",	"xmatchsubselect",	"command lsst.xmatchsubselect(l:bat[:lng],cand:bat[:oid],r:lng,depth:int,anti:bit):bat[:oid] ",	"LSSTxmatchsubselect;",	"Return the HtmID's that lie within the same triangle as r at level depth"	]
[ "mal",	"manifold",	"pattern mal.manifold(mod:str,fcn:str,a:any...):bat[:any] ",	"MANIFOLDevaluate;",	""	]
[ "mal",	"multiplex",	"pattern mal.multiplex(mod:str,fcn:str,a:any...):any... ",	"MANIFOLDremapMultiplex;",	""	]
[ "manual",	"functions",	"pattern manual.functions() (mod:bat[:str],fcn:bat[:str],sig:bat[:str],adr:bat[:str],com:bat[:str]) ",	"MANUALcreateOverview;",	"Produces a table with all MAL functions known"	]
[ "mapi",	"bind",	"pattern mapi.bind(key:int,remoteName:str):bat[:any_2] ",	"SERVERbindBAT;",	"Bind a remote variable to a local one."	]
[ "mapi",	"bind",	"pattern mapi.bind(key:int,rschema:str,rtable:str,i:int):bat[:any_2] ",	"SERVERbindBAT;",	"Bind a remote variable to a local one."	]
[ "mapi",	"bind",	"pattern mapi.bind(key:int,rschema:str,rtable:str,rcolumn:str,i:int):bat[:any_2] ",	"SERVERbindBAT;",	"Bind a remote variable to a local one."	]
[ "mapi",	"connect",	"pattern mapi.connect(host:str,port:int,usr:str,passwd:str,lang:str):int ",	"SERVERconnect;",	"Establish connection with a remote mserver."	]
[ "mapi",	"destroy",	"command mapi.destroy(mid:int):void ",	"SERVERdestroy;",	"Destroy the handle for an Mserver."	]
[ "mapi",	"disconnect",	"command mapi.disconnect(mid:int):void ",	"SERVERdisconnect;",	"Terminate the session."	]
[ "mapi",	"disconnect",	"command mapi.disconnect():int ",	"SERVERdisconnectALL;",	"Close connections with all remote Mserver."	]
[ "mapi",	"disconnect",	"command mapi.disconnect(dbalias:str):int ",	"SERVERdisconnectWithAlias;",	"Close connection with a remote Mserver."	]
[ "mapi",	"error",	"command mapi.error(mid:int):int ",	"SERVERerror;",	"Check for an error in the communication."	]
[ "mapi",	"explain",	"command mapi.explain(mid:int):str ",	"SERVERexplain;",	"Turn the error seen into a string."	]
[ "mapi",	"fetch_all_rows",	"command mapi.fetch_all_rows(hdl:int):lng ",	"SERVERfetch_all_rows;",	"Retrieve all rows into the cache."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int,fnr:int):bte ",	"SERVERfetch_field_bte;",	"Retrieve a single bte field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int,fnr:int):hge ",	"SERVERfetch_field_hge;",	"Retrieve a single hge field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int,fnr:int):int ",	"SERVERfetch_field_int;",	"Retrieve a single int field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int,fnr:int):lng ",	"SERVERfetch_field_lng;",	"Retrieve a single lng field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int,fnr:int):oid ",	"SERVERfetch_field_oid;",	"Retrieve a single void field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int,fnr:int):sht ",	"SERVERfetch_field_sht;",	"Retrieve a single sht field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int,fnr:int):str ",	"SERVERfetch_field_str;",	"Retrieve a single field."	]
[ "mapi",	"fetch_field",	"command mapi.fetch_field(hdl:int,fnr:int):void ",	"SERVERfetch_field_void;",	"Retrieve a single void field."	]
[ "mapi",	"fetch_field_array",	"command mapi.fetch_field_array(hdl:int):bat[:str] ",	"SERVERfetch_field_bat;",	"Retrieve all fields for a row."	]
[ "mapi",	"fetch_line",	"command mapi.fetch_line(hdl:int):str ",	"SERVERfetch_line;",	"Retrieve a complete line."	]
[ "mapi",	"fetch_reset",	"command mapi.fetch_reset(hdl:int):int ",	"SERVERfetch_reset;",	"Reset the cache read line."	]
[ "mapi",	"fetch_row",	"command mapi.fetch_row(hdl:int):int ",	"SERVERfetch_row;",	"Retrieve the next row for analysis."	]
[ "mapi",	"finish",	"command mapi.finish(hdl:int):int ",	"SERVERfinish;",	"Remove all remaining answers."	]
[ "mapi",	"getError",	"command mapi.getError(mid:int):str ",	"SERVERgetError;",	"Get error message."	]
[ "mapi",	"get_field_count",	"command mapi.get_field_count(hdl:int):int ",	"SERVERget_field_count;",	"Return number of fields."	]
[ "mapi",	"get_row_count",	"command mapi.get_row_count(hdl:int):lng ",	"SERVERget_row_count;",	"Return number of rows."	]
[ "mapi",	"listen",	"command mapi.listen():int ",	"SERVERlisten_default;",	"Start a Mapi server with the default settings."	]
[ "mapi",	"listen",	"command mapi.listen(port:int):int ",	"SERVERlisten_port;",	"Start a Mapi listener on the port given."	]
[ "mapi",	"listen",	"command mapi.listen(unixsocket:str):int ",	"SERVERlisten_usock;",	"Start a Mapi listener on the unix socket file given."	]
[ "mapi",	"lookup",	"command mapi.lookup(dbalias:str):int ",	"SERVERlookup;",	"Retrieve the connection identifier."	]
[ "mapi",	"malclient",	"command mapi.malclient(in:streams,out:streams):void ",	"SERVERclient;",	"Start a Mapi client for a particular stream pair."	]
[ "mapi",	"next_result",	"command mapi.next_result(hdl:int):int ",	"SERVERnext_result;",	"Go to next result set."	]
[ "mapi",	"ping",	"command mapi.ping(mid:int):int ",	"SERVERping;",	"Test availability of an Mserver."	]
[ "mapi",	"prepare",	"command mapi.prepare(mid:int,qry:str):int ",	"SERVERprepare;",	"Prepare a query for execution."	]
[ "mapi",	"put",	"pattern mapi.put(mid:int,nme:str,val:any_1):void ",	"SERVERput;",	"Send a value to a remote site."	]
[ "mapi",	"put",	"pattern mapi.put(nme:str,val:any_1):str ",	"SERVERputLocal;",	"Prepare sending a value to a remote site."	]
[ "mapi",	"query",	"command mapi.query(mid:int,qry:str):int ",	"SERVERquery;",	"Send the query for execution"	]
[ "mapi",	"query_array",	"pattern mapi.query_array(mid:int,qry:str,arg:str...):int ",	"SERVERquery_array;",	"Send the query for execution replacing '?' by arguments."	]
[ "mapi",	"query_handle",	"command mapi.query_handle(mid:int,qry:str):int ",	"SERVERquery_handle;",	"Send the query for execution."	]
[ "mapi",	"reconnect",	"command mapi.reconnect(mid:int):void ",	"SERVERreconnect;",	"Re-establish a connection."	]
[ "mapi",	"reconnect",	"pattern mapi.reconnect(host:str,port:int,db_alias:str,usr:str,passwd:str,lang:str):int ",	"SERVERreconnectAlias;",	"Re-establish connection with a remote mserver."	]
[ "mapi",	"reconnect",	"pattern mapi.reconnect(host:str,port:int,usr:str,passwd:str,lang:str):int ",	"SERVERreconnectWithoutAlias;",	"Re-establish connection with a remote mserver."	]
[ "mapi",	"resume",	"command mapi.resume():void ",	"SERVERresume;",	"Resume connection listeners."	]
[ "mapi",	"rows_affected",	"command mapi.rows_affected(hdl:int):lng ",	"SERVERrows_affected;",	"Return number of affected rows."	]
[ "mapi",	"rpc",	"pattern mapi.rpc(key:int,qry:str):bat[:any_2] ",	"SERVERmapi_rpc_bat;",	""	]
[ "mapi",	"rpc",	"pattern mapi.rpc(key:int,qry:str...):any ",	"SERVERmapi_rpc_single_row;",	"Send a simple query for execution and fetch result."	]
[ "mapi",	"rpc",	"command mapi.rpc(key:int,qry:str):int ",	"SERVERquery;",	"Send a simple query for execution."	]
[ "mapi",	"setAlias",	"command mapi.setAlias(key:int,dbalias:str):void ",	"SERVERsetAlias;",	"Give the channel a logical name."	]
[ "mapi",	"stop",	"command mapi.stop():void ",	"SERVERstop;",	"Terminate connection listeners."	]
[ "mapi",	"suspend",	"command mapi.suspend():void ",	"SERVERsuspend;",	"Suspend accepting connections."	]
[ "mapi",	"trace",	"command mapi.trace(mid:int,flag:int):void ",	"SERVERtrace;",	"Toggle the Mapi library debug tracer."	]
[ "mat",	"new",	"pattern mat.new(b:bat[:any_2]...):bat[:any_2] ",	"MATpack;",	"Define a Merge Association Table (MAT). Fall back to the pack operation\nwhen this is called "	]
[ "mat",	"pack",	"pattern mat.pack(b:bat[:any_2]...):bat[:any_2] ",	"MATpack;",	"Materialize the MAT into a BAT"	]
[ "mat",	"pack",	"pattern mat.pack(X_0:any_2...):bat[:any_2] ",	"MATpackValues;",	"Materialize the MAT (of values) into a BAT"	]
[ "mat",	"packIncrement",	"pattern mat.packIncrement(b:bat[:any_2],c:bat[:any_2]):bat[:any_2] ",	"MATpackIncrement;",	"Prepare incremental mat pack"	]
[ "mat",	"packIncrement",	"pattern mat.packIncrement(b:bat[:any_2],pieces:int):bat[:any_2] ",	"MATpackIncrement;",	"Prepare incremental mat pack"	]
[ "mbr",	"#cmp",	"command mbr.#cmp():void ",	"mbrCOMP;",	""	]
[ "mbr",	"#fromstr",	"command mbr.#fromstr():void ",	"mbrFROMSTR;",	""	]
[ "mbr",	"#hash",	"command mbr.#hash():void ",	"mbrHASH;",	""	]
[ "mbr",	"#null",	"command mbr.#null():void ",	"mbrNULL;",	""	]
[ "mbr",	"#read",	"command mbr.#read():void ",	"mbrREAD;",	""	]
[ "mbr",	"#tostr",	"command mbr.#tostr():void ",	"mbrTOSTR;",	""	]
[ "mbr",	"#write",	"command mbr.#write():void ",	"mbrWRITE;",	""	]
[ "mcurl",	"deleterequest",	"command mcurl.deleterequest(s:str):str ",	"CURLdeleteRequest;",	"Perform a http delete request"	]
[ "mcurl",	"getrequest",	"command mcurl.getrequest(s:str):str ",	"CURLgetRequest;",	"Perform a http get request"	]
[ "mcurl",	"postrequest",	"command mcurl.postrequest(s:str):str ",	"CURLpostRequest;",	"Perform a http post request"	]
[ "mcurl",	"putrequest",	"command mcurl.putrequest(s:str):str ",	"CURLputRequest;",	"Perform a http put request"	]
[ "mdb",	"List",	"pattern mdb.List(M:str,F:str):void ",	"MDBlist3Detail;",	"Dump the routine M.F on standard out."	]
[ "mdb",	"List",	"pattern mdb.List():void ",	"MDBlistDetail;",	"Dump the current routine on standard out."	]
[ "mdb",	"dot",	"pattern mdb.dot(M:str,F:str,s:str):void ",	"MDBshowFlowGraph;",	"Dump the data flow of the function \n\tM.F in a format recognizable by the \n\tcommand 'dot' on the file s"	]
[ "mdb",	"dot",	"pattern mdb.dot(s:str):void ",	"MDBshowFlowGraph;",	"Dump the data flow of the current routine in a format recognizable by the command 'dot' to the file s"	]
[ "mdb",	"dump",	"pattern mdb.dump():void ",	"MDBdump;",	"Dump instruction, stacktrace, and stack"	]
[ "mdb",	"getContext",	"command mdb.getContext(s:str):str ",	"MDBgetExceptionContext;",	"Extract the context string from the exception message"	]
[ "mdb",	"getDebug",	"command mdb.getDebug():int ",	"MDBgetDebug;",	"Get the kernel debugging bit-set.\nSee the MonetDB configuration file for details"	]
[ "mdb",	"getDefinition",	"pattern mdb.getDefinition():bat[:str] ",	"MDBgetDefinition;",	"Returns a string representation of the current function \n\twith typing information attached"	]
[ "mdb",	"getException",	"command mdb.getException(s:str):str ",	"MDBgetExceptionVariable;",	"Extract the variable name from the exception message"	]
[ "mdb",	"getReason",	"command mdb.getReason(s:str):str ",	"MDBgetExceptionReason;",	"Extract the reason from the exception message"	]
[ "mdb",	"getStackDepth",	"pattern mdb.getStackDepth():int ",	"MDBStkDepth;",	"Return the depth of the calling stack."	]
[ "mdb",	"getStackFrame",	"pattern mdb.getStackFrame() (X_0:bat[:str],X_1:bat[:str]) ",	"MDBgetStackFrame;",	"Collect variable binding of current (n-th) stack frame."	]
[ "mdb",	"getStackFrame",	"pattern mdb.getStackFrame(i:int) (X_0:bat[:str],X_1:bat[:str]) ",	"MDBgetStackFrameN;",	""	]
[ "mdb",	"getStackTrace",	"pattern mdb.getStackTrace() (X_0:bat[:int],X_1:bat[:str]) ",	"MDBStkTrace;",	""	]
[ "mdb",	"grab",	"pattern mdb.grab():void ",	"mdbGrab;",	"Call debugger for a suspended process."	]
[ "mdb",	"inspect",	"pattern mdb.inspect(mod:str,fcn:str):void ",	"MDBinspect;",	"Run the debugger on a specific function"	]
[ "mdb",	"list",	"pattern mdb.list(M:str,F:str):void ",	"MDBlist3;",	"Dump the routine M.F on standard out."	]
[ "mdb",	"list",	"pattern mdb.list():void ",	"MDBlist;",	"Dump the current routine on standard out."	]
[ "mdb",	"listMapi",	"pattern mdb.listMapi():void ",	"MDBlistMapi;",	"Dump the current routine on standard out with Mapi prefix."	]
[ "mdb",	"modules",	"command mdb.modules():bat[:str] ",	"CMDmodules;",	"List available modules"	]
[ "mdb",	"setCatch",	"pattern mdb.setCatch(b:bit):void ",	"MDBsetCatch;",	"Turn on/off catching exceptions"	]
[ "mdb",	"setDebug",	"command mdb.setDebug(flg:int):int ",	"MDBsetDebug;",	"Set the kernel debugging bit-set and return its previous value."	]
[ "mdb",	"setDebug",	"command mdb.setDebug(flg:str):int ",	"MDBsetDebugStr;",	"Set the kernel debugging bit-set and return its previous value.\nThe recognized options are: threads, memory, properties,\nio, transactions, modules, algorithms, estimates."	]
[ "mdb",	"setTrace",	"pattern mdb.setTrace(b:bit):void ",	"MDBsetTrace;",	"Turn on/off tracing of current routine"	]
[ "mdb",	"setTrace",	"pattern mdb.setTrace(b:str):void ",	"MDBsetVarTrace;",	"Turn on/off tracing of a variable "	]
[ "mdb",	"setTrap",	"pattern mdb.setTrap(mod:str,fcn:str,b:bit):void ",	"MDBtrapFunction;",	"Suspend upon a call to the MAL function."	]
[ "mdb",	"setTrap",	"pattern mdb.setTrap(idx:int):void ",	"mdbTrapClient;",	"Call debugger for a specific process."	]
[ "mdb",	"start",	"pattern mdb.start():void ",	"MDBstart;",	"Start interactive debugger"	]
[ "mdb",	"start",	"pattern mdb.start(clientid:int):void ",	"MDBstart;",	"Start interactive debugger on a client"	]
[ "mdb",	"start",	"pattern mdb.start(mod:str,fcn:str):void ",	"MDBstartFactory;",	"Start interactive debugger on a running factory"	]
[ "mdb",	"stop",	"pattern mdb.stop():void ",	"MDBstop;",	"Stop the interactive debugger"	]
[ "mdb",	"traceOptimizer",	"command mdb.traceOptimizer(flg:str):void ",	"OPTsetDebugStr;",	"Otherwise it is considered a request to trace the optimizers,\nwhich requires a comma separated list or pipeline name."	]
[ "mdb",	"trap",	"pattern mdb.trap():void ",	"mdbTrap;",	"A suspended process for debugging."	]
[ "mdb",	"var",	"pattern mdb.var(M:str,F:str):void ",	"MDBvar3;",	"Dump the symboltable of routine M.F on standard out."	]
[ "mdb",	"var",	"pattern mdb.var():void ",	"MDBvar;",	"Dump the symboltable of current routine on standard out."	]
[ "mkey",	"bulk_rotate_xor_hash",	"command mkey.bulk_rotate_xor_hash(h:bat[:lng],nbits:int,b:bat[:any_1]):bat[:lng] ",	"MKEYbulk_rotate_xor_hash;",	"pre:  h and b should be synced on head\n         post: [:xor=]([:rotate=](h, nbits), [hash](b))"	]
[ "mkey",	"bulk_rotate_xor_hash",	"pattern mkey.bulk_rotate_xor_hash(h:bat[:lng],nbits:int,v:any):bat[:lng] ",	"MKEYbulkconst_rotate_xor_hash;",	"pre:  h and b should be synced on head\n         post: [:xor=]([:rotate=](h, nbits), [hash](b))"	]
[ "mkey",	"bulk_rotate_xor_hash",	"command mkey.bulk_rotate_xor_hash(h:lng,nbits:int,b:bat[:any_1]):bat[:lng] ",	"MKEYconstbulk_rotate_xor_hash;",	"pre:  h and b should be synced on head\n         post: [:xor=]([:rotate=](h, nbits), [hash](b))"	]
[ "mkey",	"bulk_rotate_xor_hash",	"pattern mkey.bulk_rotate_xor_hash(h:lng,nbits:int,v:any):lng ",	"MKEYrotate_xor_hash;",	"post: [:xor=]([:rotate=](h, nbits), [hash](b))"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:any):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:bit):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:bte):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:dbl):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:flt):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:hge):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:int):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:lng):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:sht):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"hash",	"pattern mkey.hash(v:str):lng ",	"MKEYhash;",	"calculate a hash value"	]
[ "mkey",	"rotate",	"command mkey.rotate(v:lng,nbits:int):lng ",	"MKEYrotate;",	"left-rotate an int by nbits"	]
[ "mmath",	"acos",	"command mmath.acos(x:dbl):dbl ",	"MATHunary_ACOSdbl;",	"The acos(x) function calculates the arc cosine of x, that is the \n\tvalue whose cosine is x. The value is returned in radians and is \n\tmathematically defined to be between 0 and PI (inclusive)."	]
[ "mmath",	"acos",	"command mmath.acos(x:flt):flt ",	"MATHunary_ACOSflt;",	""	]
[ "mmath",	"asin",	"command mmath.asin(x:dbl):dbl ",	"MATHunary_ASINdbl;",	"The asin(x) function calculates the arc sine of x, that is the value \n\twhose sine is x. The value is returned in radians and is mathematically \n\tdefined to be between -PI/20 and -PI/2 (inclusive)."	]
[ "mmath",	"asin",	"command mmath.asin(x:flt):flt ",	"MATHunary_ASINflt;",	""	]
[ "mmath",	"atan",	"command mmath.atan(x:dbl):dbl ",	"MATHunary_ATANdbl;",	"The atan(x) function calculates the arc tangent of x, that is the value \n\twhose tangent is x. The value is returned in radians and is mathematically \n\tdefined to be between -PI/2 and PI/2 (inclusive)."	]
[ "mmath",	"atan",	"command mmath.atan(x:flt):flt ",	"MATHunary_ATANflt;",	""	]
[ "mmath",	"atan2",	"command mmath.atan2(x:dbl,y:dbl):dbl ",	"MATHbinary_ATAN2dbl;",	"The atan2(x,y) function calculates the arc tangent of the two \n        variables x and y.  It is similar to calculating the arc\n\ttangent of y / x, except that the signs of both arguments are \n        used to determine the quadrant of the result.  The value is \n\treturned in radians and is mathematically defined to be between \n        -PI/2 and PI/2 (inclusive)."	]
[ "mmath",	"atan2",	"command mmath.atan2(x:flt,y:flt):flt ",	"MATHbinary_ATAN2flt;",	""	]
[ "mmath",	"ceil",	"command mmath.ceil(y:dbl):dbl ",	"MATHunary_CEILdbl;",	"The ceil(x) function rounds x upwards to the nearest integer."	]
[ "mmath",	"ceil",	"command mmath.ceil(y:flt):flt ",	"MATHunary_CEILflt;",	""	]
[ "mmath",	"cos",	"command mmath.cos(x:dbl):dbl ",	"MATHunary_COSdbl;",	"The cos(x) function returns the cosine of x, where x is given in \n        radians. The return value is between -1 and 1."	]
[ "mmath",	"cos",	"command mmath.cos(x:flt):flt ",	"MATHunary_COSflt;",	""	]
[ "mmath",	"cosh",	"command mmath.cosh(x:dbl):dbl ",	"MATHunary_COSHdbl;",	"The cosh() function  returns the hyperbolic cosine of x, which is \n\tdefined mathematically as (exp(x) + exp(-x)) / 2."	]
[ "mmath",	"cosh",	"command mmath.cosh(x:flt):flt ",	"MATHunary_COSHflt;",	""	]
[ "mmath",	"cot",	"command mmath.cot(x:dbl):dbl ",	"MATHunary_COTdbl;",	"The cot(x) function returns the Cotangent of x,\n        where x is given in radians"	]
[ "mmath",	"cot",	"command mmath.cot(x:flt):flt ",	"MATHunary_COTflt;",	""	]
[ "mmath",	"degrees",	"command mmath.degrees(x:dbl):dbl ",	"MATHunary_DEGREESdbl;",	"The degrees() function converts radians into degrees"	]
[ "mmath",	"degrees",	"command mmath.degrees(x:flt):flt ",	"MATHunary_DEGREESflt;",	""	]
[ "mmath",	"exp",	"command mmath.exp(x:dbl):dbl ",	"MATHunary_EXPdbl;",	"The exp(x) function returns the value of e (the base of \n        natural logarithms) raised to the power of x."	]
[ "mmath",	"exp",	"command mmath.exp(x:flt):flt ",	"MATHunary_EXPflt;",	""	]
[ "mmath",	"fabs",	"command mmath.fabs(y:dbl):dbl ",	"MATHunary_FABSdbl;",	"The fabs(x) function  returns  the  absolute value of the \n        floating-point number x."	]
[ "mmath",	"finite",	"command mmath.finite(d:dbl):bit ",	"MATHunary_FINITE;",	"The finite(x) function returns true if x is neither infinite \n        nor a 'not-a-number' (NaN) value, and false otherwise."	]
[ "mmath",	"floor",	"command mmath.floor(y:dbl):dbl ",	"MATHunary_FLOORdbl;",	"The floor(x) function rounds x downwards to the nearest integer."	]
[ "mmath",	"floor",	"command mmath.floor(y:flt):flt ",	"MATHunary_FLOORflt;",	""	]
[ "mmath",	"fmod",	"pattern mmath.fmod(y:dbl,x:dbl):dbl ",	"CMDvarMODsignal;",	"The fmod(x,y) function computes the remainder of dividing x by y.\n\tThe return value is x - n * y, where n is the quotient of x / y,\n\trounded towards zero to an integer."	]
[ "mmath",	"fmod",	"pattern mmath.fmod(y:flt,x:flt):flt ",	"CMDvarMODsignal;",	""	]
[ "mmath",	"isinf",	"command mmath.isinf(d:dbl):int ",	"MATHunary_ISINF;",	"The isinf(x) function returns -1 if x represents negative \n        infinity, 1 if x represents positive infinity, and 0 otherwise."	]
[ "mmath",	"isnan",	"command mmath.isnan(d:dbl):bit ",	"MATHunary_ISNAN;",	"The isnan(x) function returns true if x is 'not-a-number' \n        (NaN), and false otherwise."	]
[ "mmath",	"log",	"command mmath.log(x:dbl):dbl ",	"MATHunary_LOGdbl;",	"The log(x) function returns the natural logarithm of x."	]
[ "mmath",	"log",	"command mmath.log(x:flt):flt ",	"MATHunary_LOGflt;",	""	]
[ "mmath",	"log10",	"command mmath.log10(x:dbl):dbl ",	"MATHunary_LOG10dbl;",	"The log10(x) function returns the base-10 logarithm of x."	]
[ "mmath",	"log10",	"command mmath.log10(x:flt):flt ",	"MATHunary_LOG10flt;",	""	]
[ "mmath",	"pi",	"command mmath.pi():dbl ",	"MATHpi;",	"return an important mathematical value"	]
[ "mmath",	"pow",	"command mmath.pow(x:dbl,y:dbl):dbl ",	"MATHbinary_POWdbl;",	"The pow(x,y) function  returns the value of x raised to the power of y."	]
[ "mmath",	"pow",	"command mmath.pow(x:flt,y:flt):flt ",	"MATHbinary_POWflt;",	""	]
[ "mmath",	"radians",	"command mmath.radians(x:dbl):dbl ",	"MATHunary_RADIANSdbl;",	"The radians() function converts degrees into radians"	]
[ "mmath",	"radians",	"command mmath.radians(x:flt):flt ",	"MATHunary_RADIANSflt;",	""	]
[ "mmath",	"rand",	"command mmath.rand():int ",	"MATHrandint;",	"return a random number"	]
[ "mmath",	"rand",	"command mmath.rand(v:int):int ",	"MATHrandintarg;",	"return a random number"	]
[ "mmath",	"round",	"command mmath.round(x:dbl,y:int):dbl ",	"MATHbinary_ROUNDdbl;",	"The round(n, m) returns n rounded to m places to the right \n        of the decimal point; if m is omitted, to 0 places. m can be \n\tnegative to round off digits left of the decimal point. \n        m must be an integer."	]
[ "mmath",	"round",	"command mmath.round(x:flt,y:int):flt ",	"MATHbinary_ROUNDflt;",	""	]
[ "mmath",	"sin",	"command mmath.sin(x:dbl):dbl ",	"MATHunary_SINdbl;",	"The sin(x) function returns the cosine of x, where x is given in \n        radians. The return value is between -1 and 1."	]
[ "mmath",	"sin",	"command mmath.sin(x:flt):flt ",	"MATHunary_SINflt;",	""	]
[ "mmath",	"sinh",	"command mmath.sinh(x:dbl):dbl ",	"MATHunary_SINHdbl;",	"The sinh() function  returns  the  hyperbolic sine of x, which \n        is defined mathematically as (exp(x) - exp(-x)) / 2."	]
[ "mmath",	"sinh",	"command mmath.sinh(x:flt):flt ",	"MATHunary_SINHflt;",	""	]
[ "mmath",	"sqlrand",	"command mmath.sqlrand(seed:int):int ",	"MATHsqlrandint;",	"initialize the rand() function with a seed and call rand()"	]
[ "mmath",	"sqrt",	"command mmath.sqrt(y:dbl):dbl ",	"MATHunary_SQRTdbl;",	"The sqrt(x) function returns the non-negative square root of x."	]
[ "mmath",	"sqrt",	"command mmath.sqrt(y:flt):flt ",	"MATHunary_SQRTflt;",	""	]
[ "mmath",	"srand",	"command mmath.srand(seed:int):void ",	"MATHsrandint;",	"initialize the rand() function with a seed"	]
[ "mmath",	"tan",	"command mmath.tan(x:dbl):dbl ",	"MATHunary_TANdbl;",	"The tan(x) function returns the tangent of x,\n        where x is given in radians"	]
[ "mmath",	"tan",	"command mmath.tan(x:flt):flt ",	"MATHunary_TANflt;",	""	]
[ "mmath",	"tanh",	"command mmath.tanh(x:dbl):dbl ",	"MATHunary_TANHdbl;",	"The tanh() function returns the hyperbolic tangent of x, which is \n\tdefined mathematically as sinh(x) / cosh(x)."	]
[ "mmath",	"tanh",	"command mmath.tanh(x:flt):flt ",	"MATHunary_TANHflt;",	""	]
[ "mtime",	"add",	"command mtime.add(v:timestamp,msecs:lng):timestamp ",	"MTIMEtimestamp_add;",	"returns the timestamp that comes 'msecs'\n\t(possibly negative) after 'value'."	]
[ "mtime",	"adddays",	"command mtime.adddays(value:date,days:int):date ",	"MTIMEdate_adddays;",	"returns the date after a number\n\tof days (possibly negative)."	]
[ "mtime",	"addmonths",	"command mtime.addmonths(value:date,months:int):date ",	"MTIMEdate_addmonths;",	"returns the date after a number of\n\tmonths (possibly negative)."	]
[ "mtime",	"addyears",	"command mtime.addyears(value:date,years:int):date ",	"MTIMEdate_addyears;",	"returns the date after a number\n\tof years (possibly negative)."	]
[ "mtime",	"compute",	"command mtime.compute(r:zrule,year:int):date ",	"MTIMEcompute_rule_foryear;",	"compute the date from a rule in a given year"	]
[ "mtime",	"current_date",	"command mtime.current_date():date ",	"MTIMEcurrent_date;",	""	]
[ "mtime",	"current_time",	"command mtime.current_time():daytime ",	"MTIMEcurrent_time;",	""	]
[ "mtime",	"current_timestamp",	"command mtime.current_timestamp():timestamp ",	"MTIMEcurrent_timestamp;",	""	]
[ "mtime",	"date",	"command mtime.date(X_0:date):date ",	"MTIMEdate2date;",	"generate the nil date"	]
[ "mtime",	"date",	"command mtime.date(yr:int,mo:int,day:int):date ",	"MTIMEdate_create;",	"creates a date from (year,month,day)."	]
[ "mtime",	"date",	"command mtime.date(s:str):date ",	"MTIMEdate_fromstr;",	"convert the string to a type date value"	]
[ "mtime",	"date",	"command mtime.date(X_0:void):date ",	"MTIMEnil2date;",	"generate the nil date"	]
[ "mtime",	"date",	"command mtime.date(t:timestamp,v:timezone):date ",	"MTIMEtimestamp_extract_date;",	"extracts date from timestamp in a\n\tspecific timezone."	]
[ "mtime",	"date",	"command mtime.date(t:timestamp):date ",	"MTIMEtimestamp_extract_date_default;",	"extracts date from timestamp\n\tin the local timezone."	]
[ "mtime",	"date_add_month_interval",	"command mtime.date_add_month_interval(t:date,s:int):date ",	"MTIMEdate_addmonths;",	"Add months to a date"	]
[ "mtime",	"date_add_msec_interval",	"command mtime.date_add_msec_interval(t:date,ms:lng):date ",	"MTIMEdate_add_msec_interval_lng_wrap;",	""	]
[ "mtime",	"date_add_sec_interval",	"command mtime.date_add_sec_interval(t:date,s:int):date ",	"MTIMEdate_add_sec_interval_wrap;",	"Add seconds to a date"	]
[ "mtime",	"date_sub_month_interval",	"command mtime.date_sub_month_interval(t:date,s:int):date ",	"MTIMEdate_submonths;",	"Subtract months from a date"	]
[ "mtime",	"date_sub_msec_interval",	"command mtime.date_sub_msec_interval(t:date,ms:lng):date ",	"MTIMEdate_sub_msec_interval_lng_wrap;",	""	]
[ "mtime",	"date_sub_sec_interval",	"command mtime.date_sub_sec_interval(t:date,s:int):date ",	"MTIMEdate_sub_sec_interval_wrap;",	"Subtract seconds from a date"	]
[ "mtime",	"date_to_str",	"command mtime.date_to_str(d:date,format:str):str ",	"MTIMEdate_to_str;",	"create a string from the date, using the specified format (see man strftime)"	]
[ "mtime",	"day",	"command mtime.day(d:date):int ",	"MTIMEdate_extract_day;",	"extracts day from date "	]
[ "mtime",	"day",	"command mtime.day(t:zrule):int ",	"MTIMErule_extract_day;",	"extract day from rule."	]
[ "mtime",	"day",	"command mtime.day(msecs:lng):lng ",	"MTIMEsql_day;",	""	]
[ "mtime",	"day",	"command mtime.day(t:timestamp):int ",	"MTIMEtimestamp_day;",	""	]
[ "mtime",	"dayname",	"command mtime.dayname(day:int):str ",	"MTIMEday_to_str;",	"Returns day name from a number\n\tbetween [1-7], str(nil) otherwise."	]
[ "mtime",	"daynum",	"command mtime.daynum(day:str):int ",	"MTIMEday_from_str;",	"Returns number of day [1-7] from a\n\tstring or nil if does not match any."	]
[ "mtime",	"dayofweek",	"command mtime.dayofweek(d:date):int ",	"MTIMEdate_extract_dayofweek;",	"Returns the current day of the week\n\twhere 1=monday, .., 7=sunday"	]
[ "mtime",	"dayofyear",	"command mtime.dayofyear(d:date):int ",	"MTIMEdate_extract_dayofyear;",	"Returns N where d is the Nth day\n\tof the year (january 1 returns 1)"	]
[ "mtime",	"daytime",	"command mtime.daytime(h:int):daytime ",	"MTIMEdaytime1;",	"default time with zeroed components"	]
[ "mtime",	"daytime",	"command mtime.daytime(h:int,m:int):daytime ",	"MTIMEdaytime2;",	"default time with zeroed components"	]
[ "mtime",	"daytime",	"command mtime.daytime(X_0:daytime):daytime ",	"MTIMEdaytime2daytime;",	""	]
[ "mtime",	"daytime",	"command mtime.daytime(h:int,m:int,s:int):daytime ",	"MTIMEdaytime3;",	"default time with zeroed components"	]
[ "mtime",	"daytime",	"command mtime.daytime(h:int,m:int,s:int,mi:int):daytime ",	"MTIMEdaytime_create;",	"creates a time from (hours,minutes,\n\tseconds,milliseconds) parameters."	]
[ "mtime",	"daytime",	"command mtime.daytime(s:str):daytime ",	"MTIMEdaytime_fromstr;",	"convert the string to a daytime value."	]
[ "mtime",	"daytime",	"command mtime.daytime(X_0:lng):daytime ",	"MTIMEsecs2daytime;",	""	]
[ "mtime",	"daytime",	"command mtime.daytime(t:timestamp,v:timezone):daytime ",	"MTIMEtimestamp_extract_daytime;",	"extracts daytime from timestamp\n\tin a specific timezone."	]
[ "mtime",	"daytime",	"command mtime.daytime(t:timestamp):daytime ",	"MTIMEtimestamp_extract_daytime_default;",	"extracts daytime from timestamp\n\tin the local timezone."	]
[ "mtime",	"diff",	"command mtime.diff(val1:date,val2:date):int ",	"MTIMEdate_diff;",	"returns the number of days\n\tbetween 'val1' and 'val2'."	]
[ "mtime",	"diff",	"command mtime.diff(val1:daytime,val2:daytime):lng ",	"MTIMEdaytime_diff;",	"returns the number of msec between 'val1' and 'val2'."	]
[ "mtime",	"diff",	"command mtime.diff(val1:timestamp,val2:timestamp):lng ",	"MTIMEtimestamp_diff;",	"returns the number of milliseconds\n\tbetween 'val1' and 'val2'."	]
[ "mtime",	"dst",	"command mtime.dst(t:timestamp,v:timezone):bit ",	"MTIMEtimestamp_inside_dst;",	"return whether DST holds in the\n\ttimezone at a certain point of time."	]
[ "mtime",	"end_dst",	"command mtime.end_dst(t:timezone):zrule ",	"MTIMEtzone_extract_end;",	"extract rule that determines\n\tend of DST from timezone."	]
[ "mtime",	"epilogue",	"command mtime.epilogue():void ",	"MTIMEepilogue;",	""	]
[ "mtime",	"hours",	"command mtime.hours(h:daytime):int ",	"MTIMEdaytime_extract_hours;",	"extracts hour from daytime"	]
[ "mtime",	"hours",	"command mtime.hours(msecs:lng):int ",	"MTIMEsql_hours;",	""	]
[ "mtime",	"hours",	"command mtime.hours(t:timestamp):int ",	"MTIMEtimestamp_hours;",	""	]
[ "mtime",	"local_timezone",	"command mtime.local_timezone():lng ",	"MTIMElocal_timezone;",	"get the local timezone in seconds"	]
[ "mtime",	"milliseconds",	"command mtime.milliseconds(d:daytime):int ",	"MTIMEdaytime_extract_milliseconds;",	"extracts milliseconds from daytime"	]
[ "mtime",	"milliseconds",	"command mtime.milliseconds(t:timestamp):int ",	"MTIMEtimestamp_milliseconds;",	""	]
[ "mtime",	"minutes",	"command mtime.minutes(d:daytime):int ",	"MTIMEdaytime_extract_minutes;",	"extracts minutes from daytime"	]
[ "mtime",	"minutes",	"command mtime.minutes(t:zrule):int ",	"MTIMErule_extract_minutes;",	"extract minutes from rule."	]
[ "mtime",	"minutes",	"command mtime.minutes(msecs:lng):int ",	"MTIMEsql_minutes;",	""	]
[ "mtime",	"minutes",	"command mtime.minutes(t:timestamp):int ",	"MTIMEtimestamp_minutes;",	""	]
[ "mtime",	"minutes",	"command mtime.minutes(t:timezone):int ",	"MTIMEtzone_extract_minutes;",	"extract number of minutes that\n\ttime zone is offset wrt GMT."	]
[ "mtime",	"month",	"command mtime.month(d:date):int ",	"MTIMEdate_extract_month;",	"extracts month from date"	]
[ "mtime",	"month",	"command mtime.month(t:zrule):int ",	"MTIMErule_extract_month;",	"extract month from rule."	]
[ "mtime",	"month",	"command mtime.month(months:int):int ",	"MTIMEsql_month;",	""	]
[ "mtime",	"month",	"command mtime.month(t:timestamp):int ",	"MTIMEtimestamp_month;",	""	]
[ "mtime",	"monthname",	"command mtime.monthname(month:int):str ",	"MTIMEmonth_to_str;",	"Returns month name from a number\n\tbetween [1-12], str(nil) otherwise."	]
[ "mtime",	"monthnum",	"command mtime.monthnum(month:str):int ",	"MTIMEmonth_from_str;",	"Returns month number [1-12] from a string\n\t or nil if does not match any."	]
[ "mtime",	"msec",	"command mtime.msec():lng ",	"MTIMEmsec;",	"get time of day in msec since 1-1-1970."	]
[ "mtime",	"msecs",	"command mtime.msecs(d:int,h:int,m:int,s:int,ms:int):lng ",	"MTIMEmsecs;",	"convert date components to milliseconds"	]
[ "mtime",	"prelude",	"command mtime.prelude():void ",	"MTIMEprelude;",	""	]
[ "mtime",	"rule",	"command mtime.rule(mo:int,d:int,wkday:int,mi:int):zrule ",	"MTIMErule_create;",	"create a DST start/end date rule."	]
[ "mtime",	"rule",	"command mtime.rule(s:str):zrule ",	"MTIMErule_fromstr;",	"create a rule from a  string."	]
[ "mtime",	"seconds",	"command mtime.seconds(d:daytime):int ",	"MTIMEdaytime_extract_seconds;",	"extracts seconds from daytime"	]
[ "mtime",	"seconds",	"command mtime.seconds(msecs:lng):int ",	"MTIMEsql_seconds;",	""	]
[ "mtime",	"seconds",	"command mtime.seconds(t:timestamp):int ",	"MTIMEtimestamp_seconds;",	""	]
[ "mtime",	"setTimezone",	"command mtime.setTimezone(name:str):timezone ",	"MTIMEtimezone;",	"Test and set the timezone."	]
[ "mtime",	"sql_seconds",	"command mtime.sql_seconds(d:daytime):int ",	"MTIMEdaytime_extract_sql_seconds;",	"extracts seconds (with fractional milliseconds) from daytime"	]
[ "mtime",	"sql_seconds",	"command mtime.sql_seconds(t:timestamp):int ",	"MTIMEtimestamp_sql_seconds;",	""	]
[ "mtime",	"start_dst",	"command mtime.start_dst(t:timezone):zrule ",	"MTIMEtzone_extract_start;",	"extract rule that determines\n\tstart of DST from timezone."	]
[ "mtime",	"str_to_date",	"command mtime.str_to_date(s:str,format:str):date ",	"MTIMEstr_to_date;",	"create a date from the string, using the specified format (see man strptime)"	]
[ "mtime",	"str_to_time",	"command mtime.str_to_time(s:str,format:str):daytime ",	"MTIMEstr_to_time;",	"create a time from the string, using the specified format (see man strptime)"	]
[ "mtime",	"str_to_timestamp",	"command mtime.str_to_timestamp(s:str,format:str):timestamp ",	"MTIMEstr_to_timestamp;",	"create a timestamp from the string, using the specified format (see man strptime)"	]
[ "mtime",	"time_add_msec_interval",	"command mtime.time_add_msec_interval(t:daytime,ms:lng):daytime ",	"MTIMEtime_add_msec_interval_wrap;",	"Add seconds to a time"	]
[ "mtime",	"time_sub_msec_interval",	"command mtime.time_sub_msec_interval(t:daytime,ms:lng):daytime ",	"MTIMEtime_sub_msec_interval_wrap;",	"Subtract seconds from a time"	]
[ "mtime",	"time_synonyms",	"command mtime.time_synonyms(allow:bit):void ",	"MTIMEsynonyms;",	"Allow synonyms for the parse format of\n\tdate/timestamp."	]
[ "mtime",	"time_to_str",	"command mtime.time_to_str(d:daytime,format:str):str ",	"MTIMEtime_to_str;",	"create a string from the time, using the specified format (see man strftime)"	]
[ "mtime",	"timestamp",	"command mtime.timestamp(t:timestamp):timestamp ",	"MTIMEtimestamp2timestamp;",	""	]
[ "mtime",	"timestamp",	"command mtime.timestamp(d:date,dt:daytime,t:timezone):timestamp ",	"MTIMEtimestamp_create;",	"creates a timestamp from (date, daytime,timezone) parameters."	]
[ "mtime",	"timestamp",	"command mtime.timestamp(d:date,dt:daytime):timestamp ",	"MTIMEtimestamp_create_default;",	"creates a timestamp from (d,dt) parameters (in the local timezone)."	]
[ "mtime",	"timestamp",	"command mtime.timestamp(d:date):timestamp ",	"MTIMEtimestamp_create_from_date;",	"creates a timestamp from (d,00:00:00) parameters (in the local timezone)."	]
[ "mtime",	"timestamp_add_month_interval",	"command mtime.timestamp_add_month_interval(t:timestamp,s:lng):timestamp ",	"MTIMEtimestamp_add_month_interval_lng_wrap;",	"Add months to a timestamp"	]
[ "mtime",	"timestamp_add_month_interval",	"command mtime.timestamp_add_month_interval(t:timestamp,s:int):timestamp ",	"MTIMEtimestamp_add_month_interval_wrap;",	"Add months to a timestamp"	]
[ "mtime",	"timestamp_add_msec_interval",	"command mtime.timestamp_add_msec_interval(t:timestamp,ms:lng):timestamp ",	"MTIMEtimestamp_add;",	""	]
[ "mtime",	"timestamp_sub_month_interval",	"command mtime.timestamp_sub_month_interval(t:timestamp,s:lng):timestamp ",	"MTIMEtimestamp_sub_month_interval_lng_wrap;",	"Subtract months from a timestamp"	]
[ "mtime",	"timestamp_sub_month_interval",	"command mtime.timestamp_sub_month_interval(t:timestamp,s:int):timestamp ",	"MTIMEtimestamp_sub_month_interval_wrap;",	"Subtract months from a timestamp"	]
[ "mtime",	"timestamp_sub_msec_interval",	"command mtime.timestamp_sub_msec_interval(t:timestamp,ms:lng):timestamp ",	"MTIMEtimestamp_sub_msec_interval_lng_wrap;",	""	]
[ "mtime",	"timestamp_to_str",	"command mtime.timestamp_to_str(d:timestamp,format:str):str ",	"MTIMEtimestamp_to_str;",	"create a string from the time, using the specified format (see man strftime)"	]
[ "mtime",	"timezone",	"command mtime.timezone(s:int):timezone ",	"MTIMEtzone_create;",	"Convert the int to a timezone."	]
[ "mtime",	"timezone",	"command mtime.timezone(mi:int,s:zrule,erule:zrule):timezone ",	"MTIMEtzone_create_dst;",	"create a timezone as an hour difference\n\tfrom GMT and a DST."	]
[ "mtime",	"timezone",	"command mtime.timezone(s:lng):timezone ",	"MTIMEtzone_create_lng;",	"Convert the int to a timezone."	]
[ "mtime",	"timezone",	"command mtime.timezone(s:str):timezone ",	"MTIMEtzone_fromstr;",	"Convert the string to a timezone."	]
[ "mtime",	"timezone_local",	"command mtime.timezone_local():timezone ",	"MTIMEtzone_get_local;",	"get the local timezone; which is used for printing timestamps"	]
[ "mtime",	"timezone_local",	"command mtime.timezone_local(t:timezone):void ",	"MTIMEtzone_set_local;",	"set the local timezone; which is used for printing timestamps"	]
[ "mtime",	"weekday",	"command mtime.weekday(t:zrule):int ",	"MTIMErule_extract_weekday;",	"extract weekday from rule."	]
[ "mtime",	"weekofyear",	"command mtime.weekofyear(d:date):int ",	"MTIMEdate_extract_weekofyear;",	"Returns the week number in the year."	]
[ "mtime",	"year",	"command mtime.year(d:date):int ",	"MTIMEdate_extract_year;",	"extracts year from date (nonzero\n\tvalue between -5867411 and +5867411)."	]
[ "mtime",	"year",	"command mtime.year(months:int):int ",	"MTIMEsql_year;",	""	]
[ "mtime",	"year",	"command mtime.year(t:timestamp):int ",	"MTIMEtimestamp_year;",	""	]
[ "netcdf",	"attach",	"pattern netcdf.attach(filename:str):void ",	"NCDFattach;",	"Register a NetCDF file in the vault"	]
[ "netcdf",	"importvar",	"command netcdf.importvar(filename:str,varid:int):str ",	"NCDFimportVarStmt;",	"Import variable: compose create array string"	]
[ "netcdf",	"importvariable",	"pattern netcdf.importvariable(fileid:int,varname:str):void ",	"NCDFimportVariable;",	"Import variable: create array and load data from variable varname of file fileid"	]
[ "netcdf",	"test",	"command netcdf.test(filename:str):int ",	"NCDFtest;",	"Returns number of variables in a given NetCDF dataset (file)"	]
[ "optimizer",	"aliases",	"pattern optimizer.aliases():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"aliases",	"pattern optimizer.aliases(mod:str,fcn:str):str ",	"OPTwrapper;",	"Alias removal optimizer"	]
[ "optimizer",	"candidates",	"pattern optimizer.candidates():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"candidates",	"pattern optimizer.candidates(mod:str,fcn:str):str ",	"OPTwrapper;",	"Mark candidate list variables"	]
[ "optimizer",	"coercions",	"pattern optimizer.coercions():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"coercions",	"pattern optimizer.coercions(mod:str,fcn:str):str ",	"OPTwrapper;",	"Handle simple type coercions"	]
[ "optimizer",	"commonTerms",	"pattern optimizer.commonTerms():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"commonTerms",	"pattern optimizer.commonTerms(mod:any_1,fcn:any_2):str ",	"OPTwrapper;",	"Common sub-expression optimizer"	]
[ "optimizer",	"constants",	"pattern optimizer.constants():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"constants",	"pattern optimizer.constants(mod:str,fcn:str):str ",	"OPTwrapper;",	"Duplicate constant removal optimizer"	]
[ "optimizer",	"costModel",	"pattern optimizer.costModel():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"costModel",	"pattern optimizer.costModel(mod:str,fcn:str):str ",	"OPTwrapper;",	"Estimate the cost of a relational expression"	]
[ "optimizer",	"crackers",	"pattern optimizer.crackers():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"crackers",	"pattern optimizer.crackers(mod:str,fcn:str):str ",	"OPTwrapper;",	"Replace algebra select with crackers select"	]
[ "optimizer",	"dataflow",	"pattern optimizer.dataflow():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"dataflow",	"pattern optimizer.dataflow(mod:str,fcn:str):str ",	"OPTwrapper;",	"Dataflow bracket code injection"	]
[ "optimizer",	"deadcode",	"pattern optimizer.deadcode():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"deadcode",	"pattern optimizer.deadcode(mod:str,fcn:str):str ",	"OPTwrapper;",	"Dead code optimizer"	]
[ "optimizer",	"derivePath",	"pattern optimizer.derivePath():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"derivePath",	"pattern optimizer.derivePath(mod:str,fcn:str):str ",	"OPTwrapper;",	"Join path constructor"	]
[ "optimizer",	"emptybind",	"pattern optimizer.emptybind():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"emptybind",	"pattern optimizer.emptybind(mod:str,fcn:str):str ",	"OPTwrapper;",	"Evaluate empty set expressions."	]
[ "optimizer",	"evaluate",	"pattern optimizer.evaluate():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"evaluate",	"pattern optimizer.evaluate(mod:str,fcn:str):str ",	"OPTwrapper;",	"Evaluate constant expressions once."	]
[ "optimizer",	"garbageCollector",	"pattern optimizer.garbageCollector():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"garbageCollector",	"pattern optimizer.garbageCollector(mod:str,fcn:str):str ",	"OPTwrapper;",	"Garbage collector optimizer"	]
[ "optimizer",	"generator",	"pattern optimizer.generator():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"generator",	"pattern optimizer.generator(mod:str,fcn:str):str ",	"OPTwrapper;",	"Sequence generator optimizer"	]
[ "optimizer",	"inline",	"pattern optimizer.inline():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"inline",	"pattern optimizer.inline(mod:str,fcn:str):str ",	"OPTwrapper;",	"Expand inline functions"	]
[ "optimizer",	"jit",	"pattern optimizer.jit():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"jit",	"pattern optimizer.jit(mod:str,fcn:str):str ",	"OPTwrapper;",	"Propagate candidate lists in just-in-time optimization"	]
[ "optimizer",	"joinselect",	"pattern optimizer.joinselect():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"joinselect",	"pattern optimizer.joinselect(mod:str,fcn:str):str ",	"OPTwrapper;",	"Replace select with join select"	]
[ "optimizer",	"json",	"pattern optimizer.json():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"json",	"pattern optimizer.json(mod:str,fcn:str):str ",	"OPTwrapper;",	"Unroll the mat.pack operation"	]
[ "optimizer",	"macro",	"pattern optimizer.macro(mod:str,fcn:str,targetmod:str,targetfcn:str):void ",	"OPTmacro;",	"Inline a target function used in a specific function."	]
[ "optimizer",	"macro",	"pattern optimizer.macro(targetmod:str,targetfcn:str):void ",	"OPTmacro;",	"Inline the code of the target function."	]
[ "optimizer",	"matpack",	"pattern optimizer.matpack():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"matpack",	"pattern optimizer.matpack(mod:str,fcn:str):str ",	"OPTwrapper;",	"Unroll the mat.pack operation"	]
[ "optimizer",	"mergetable",	"pattern optimizer.mergetable():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"mergetable",	"pattern optimizer.mergetable(mod:str,fcn:str):str ",	"OPTwrapper;",	"Resolve the multi-table definitions"	]
[ "optimizer",	"mitosis",	"pattern optimizer.mitosis():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"mitosis",	"pattern optimizer.mitosis(mod:str,fcn:str):str ",	"OPTwrapper;",	"Modify the plan to exploit parallel processing on multiple cores"	]
[ "optimizer",	"multiplex",	"pattern optimizer.multiplex():void ",	"OPTwrapper;",	"Compiler for multiplexed instructions."	]
[ "optimizer",	"multiplex",	"pattern optimizer.multiplex(mod:str,fcn:str):void ",	"OPTwrapper;",	"Compiler for multiplexed instructions."	]
[ "optimizer",	"optimize",	"pattern optimizer.optimize(mod:str,fcn:str):void ",	"QOToptimize;",	"Optimize a specific operation"	]
[ "optimizer",	"orcam",	"pattern optimizer.orcam(mod:str,fcn:str,targetmod:str,targetfcn:str):void ",	"OPTorcam;",	"Inverse macro, find pattern and replace with a function call."	]
[ "optimizer",	"orcam",	"pattern optimizer.orcam(targetmod:str,targetfcn:str):void ",	"OPTorcam;",	"Inverse macro processor for current function"	]
[ "optimizer",	"origin",	"pattern optimizer.origin():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"origin",	"pattern optimizer.origin(mod:str,fcn:str):str ",	"OPTwrapper;",	"OID origin tracker"	]
[ "optimizer",	"partitions",	"pattern optimizer.partitions():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"partitions",	"pattern optimizer.partitions(mod:str,fcn:str):str ",	"OPTwrapper;",	"Experiment with partitioned databases"	]
[ "optimizer",	"prejoin",	"pattern optimizer.prejoin():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"prejoin",	"pattern optimizer.prejoin(mod:str,fcn:str):str ",	"OPTwrapper;",	"Dead code optimizer"	]
[ "optimizer",	"prelude",	"pattern optimizer.prelude():void ",	"optimizer_prelude;",	"Initialize the optimizer"	]
[ "optimizer",	"profiler",	"pattern optimizer.profiler():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"profiler",	"pattern optimizer.profiler(mod:str,fcn:str):str ",	"OPTwrapper;",	"Collect properties for the profiler"	]
[ "optimizer",	"projectionpath",	"pattern optimizer.projectionpath():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"projectionpath",	"pattern optimizer.projectionpath(mod:str,fcn:str):str ",	"OPTwrapper;",	"Join path constructor"	]
[ "optimizer",	"pushselect",	"pattern optimizer.pushselect():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"pushselect",	"pattern optimizer.pushselect(mod:str,fcn:str):str ",	"OPTwrapper;",	"Push selects down projections"	]
[ "optimizer",	"querylog",	"pattern optimizer.querylog():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"querylog",	"pattern optimizer.querylog(mod:str,fcn:str):str ",	"OPTwrapper;",	"Collect SQL query statistics"	]
[ "optimizer",	"recycler",	"pattern optimizer.recycler():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"recycler",	"pattern optimizer.recycler(mod:str,fcn:str):str ",	"OPTwrapper;",	"Recycler marking and code injection"	]
[ "optimizer",	"reduce",	"pattern optimizer.reduce():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"reduce",	"pattern optimizer.reduce(mod:str,fcn:str):str ",	"OPTwrapper;",	"Reduce the stack space claims"	]
[ "optimizer",	"remap",	"pattern optimizer.remap():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"remap",	"pattern optimizer.remap(mod:str,fcn:str):str ",	"OPTwrapper;",	"Remapping function calls to a their multiplex variant"	]
[ "optimizer",	"remoteQueries",	"pattern optimizer.remoteQueries():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"remoteQueries",	"pattern optimizer.remoteQueries(mod:str,fcn:str):str ",	"OPTwrapper;",	"Resolve the multi-table definitions"	]
[ "optimizer",	"reorder",	"pattern optimizer.reorder():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"reorder",	"pattern optimizer.reorder(mod:str,fcn:str):str ",	"OPTwrapper;",	"Reorder by dataflow dependencies"	]
[ "optimizer",	"selcrack",	"pattern optimizer.selcrack():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"selcrack",	"pattern optimizer.selcrack(mod:str,fcn:str):str ",	"OPTwrapper;",	"Selection cracking"	]
[ "optimizer",	"showFlowGraph",	"pattern optimizer.showFlowGraph(M:str,F:str,s:str):void ",	"QOTshowFlowGraph;",	"Dump the data flow of the function \n\tM.F in a format recognizable by the \n\tcommand 'dot' on the file s"	]
[ "optimizer",	"showPlan",	"pattern optimizer.showPlan():void ",	"QOTshowPlan;",	"Illustrate the plan derived so far"	]
[ "optimizer",	"showPlan",	"pattern optimizer.showPlan(M:str,F:str,s:str):void ",	"QOTshowPlan;",	""	]
[ "optimizer",	"sql_append",	"pattern optimizer.sql_append():str ",	"OPTsql_append;",	"Avoid extra BAT copy with sql.append() whenever possible."	]
[ "optimizer",	"sql_append",	"pattern optimizer.sql_append(mod:str,fcn:str):str ",	"OPTsql_append;",	"Avoid extra BAT copy with sql.append() whenever possible."	]
[ "optimizer",	"trace",	"pattern optimizer.trace():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"trace",	"pattern optimizer.trace(mod:str,fcn:str):str ",	"OPTwrapper;",	"Collect trace of a specific operation"	]
[ "optimizer",	"volcano",	"pattern optimizer.volcano():str ",	"OPTwrapper;",	""	]
[ "optimizer",	"volcano",	"pattern optimizer.volcano(mod:str,fcn:str):str ",	"OPTwrapper;",	"Simulate volcano style execution"	]
[ "pcre",	"imatch",	"command pcre.imatch(s:str,pat:str):bit ",	"PCREimatch;",	"Caseless Perl Compatible Regular Expression pattern matching against a string"	]
[ "pcre",	"index",	"command pcre.index(pat:pcre,s:str):int ",	"PCREindex;",	"match a pattern, return matched position (or 0 when not found)"	]
[ "pcre",	"match",	"command pcre.match(s:str,pat:str):bit ",	"PCREmatch;",	"Perl Compatible Regular Expression pattern matching against a string"	]
[ "pcre",	"patindex",	"command pcre.patindex(pat:str,s:str):int ",	"PCREpatindex;",	"Location of the first POSIX pattern matching against a string"	]
[ "pcre",	"pcre_quote",	"command pcre.pcre_quote(s:str):str ",	"PCREquote;",	"Return a PCRE pattern string that matches the argument exactly."	]
[ "pcre",	"prelude",	"command pcre.prelude():void ",	"pcre_init;",	"Initialize pcre"	]
[ "pcre",	"replace",	"command pcre.replace(orig:bat[:str],pat:str,repl:str,flag:str):bat[:str] ",	"PCREreplace_bat_wrap;",	""	]
[ "pcre",	"replace",	"command pcre.replace(origin:str,pat:str,repl:str,flags:str):str ",	"PCREreplace_wrap;",	"Replace _all_ matches of \"pattern\" in \"origin_str\" with \"replacement\".\n\t Parameter \"flags\" accept these flags: 'i', 'm', 's', and 'x'.\n\t   'e': if present, an empty string is considered to be a valid match\n\t   'i': if present, the match operates in case-insensitive mode.\n\t\tOtherwise, in case-sensitive mode.\n\t   'm': if present, the match operates in multi-line mode.\n\t   's': if present, the match operates in \"dot-all\"\n\t   The specifications of the flags can be found in \"man pcreapi\"\n\t   The flag letters may be repeated.\n\t   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \"flags\".\n\t   Returns the replaced string, or if no matches found, the original string."	]
[ "pcre",	"sql2pcre",	"command pcre.sql2pcre(pat:str,esc:str):str ",	"PCREsql2pcre;",	"Convert a SQL like pattern with the given escape character into a PCRE pattern."	]
[ "profiler",	"cleanup",	"command profiler.cleanup():void ",	"CMDcleanupTraces;",	"Remove the temporary tables for profiling"	]
[ "profiler",	"closestream",	"command profiler.closestream():void ",	"CMDcloseProfilerStream;",	"Stop offline proviling"	]
[ "profiler",	"cpuload",	"command profiler.cpuload(user:lng,nice:lng,sys:lng,idle:lng,iowait:lng) (cycles:int,io:int) ",	"CMDcpuloadPercentage;",	"Calculate the average cpu load percentage and io waiting times"	]
[ "profiler",	"cpustats",	"command profiler.cpustats() (user:lng,nice:lng,sys:lng,idle:lng,iowait:lng) ",	"CMDcpustats;",	"Extract cpu statistics from the kernel"	]
[ "profiler",	"getDiskReads",	"command profiler.getDiskReads():lng ",	"CMDgetDiskReads;",	"Obtain the number of physical reads"	]
[ "profiler",	"getDiskWrites",	"command profiler.getDiskWrites():lng ",	"CMDgetDiskWrites;",	"Obtain the number of physical reads"	]
[ "profiler",	"getSystemTime",	"command profiler.getSystemTime():lng ",	"CMDgetSystemTime;",	"Obtain the user timing information."	]
[ "profiler",	"getTrace",	"command profiler.getTrace(e:str):bat[:any_1] ",	"CMDgetTrace;",	"Get the trace details of a specific event"	]
[ "profiler",	"getUserTime",	"command profiler.getUserTime():lng ",	"CMDgetUserTime;",	"Obtain the user timing information."	]
[ "profiler",	"noop",	"command profiler.noop():void ",	"CMDnoopProfiler;",	"Fetch any pending performance events"	]
[ "profiler",	"openstream",	"pattern profiler.openstream(mode:int):void ",	"CMDopenProfilerStream;",	"Start profiling the events, sent to output stream"	]
[ "profiler",	"setheartbeat",	"command profiler.setheartbeat(b:int):void ",	"CMDsetHeartbeat;",	"Set heart beat performance tracing"	]
[ "profiler",	"start",	"pattern profiler.start():void ",	"CMDstartProfiler;",	"Start offline performance profiling"	]
[ "profiler",	"starttrace",	"command profiler.starttrace():void ",	"CMDstartTrace;",	"Start collecting trace information"	]
[ "profiler",	"starttrace",	"command profiler.starttrace(path:str):void ",	"CMDstartTracePath;",	"Start collecting trace information and keep around in 'path' directory"	]
[ "profiler",	"stop",	"pattern profiler.stop():void ",	"CMDstopProfiler;",	"Stop offline performance profiling"	]
[ "profiler",	"stoptrace",	"command profiler.stoptrace():void ",	"CMDstopTrace;",	"Stop collecting trace information"	]
[ "profiler",	"stoptrace",	"command profiler.stoptrace(path:str):void ",	"CMDstopTracePath;",	"Stop collecting trace information"	]
[ "pyapi",	"eval",	"pattern pyapi.eval(fptr:ptr,expr:str):any ",	"PyAPIevalStd;",	"Execute a simple Python script returning a single value"	]
[ "pyapi",	"eval",	"pattern pyapi.eval(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalStd;",	"Execute a simple Python script value"	]
[ "pyapi",	"eval_aggr",	"pattern pyapi.eval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalAggr;",	"grouped aggregates through Python"	]
[ "pyapi",	"eval_loader",	"pattern pyapi.eval_loader(fptr:ptr,expr:str):any... ",	"PyAPIevalLoader;",	"loader functions through Python"	]
[ "pyapi",	"eval_loader",	"pattern pyapi.eval_loader(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalLoader;",	"loader functions through Python"	]
[ "pyapi",	"prelude",	"command pyapi.prelude():void ",	"PyAPIprelude;",	""	]
[ "pyapi",	"subeval_aggr",	"pattern pyapi.subeval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalAggr;",	"grouped aggregates through Python"	]
[ "pyapimap",	"eval",	"pattern pyapimap.eval(fptr:ptr,expr:str):any ",	"PyAPIevalStdMap;",	"Execute a simple Python script returning a single value"	]
[ "pyapimap",	"eval",	"pattern pyapimap.eval(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalStdMap;",	"Execute a simple Python script value"	]
[ "pyapimap",	"eval_aggr",	"pattern pyapimap.eval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalAggrMap;",	"grouped aggregates through Python"	]
[ "pyapimap",	"subeval_aggr",	"pattern pyapimap.subeval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"PyAPIevalAggrMap;",	"grouped aggregates through Python"	]
[ "querylog",	"append",	"pattern querylog.append(q:str,pipe:str,usr:str,tick:timestamp):void ",	"QLOGappend;",	"Add a new query call to the query log"	]
[ "querylog",	"call",	"pattern querylog.call(tick1:timestamp,tick2:timestamp,arg:str,tuples:lng,xtime:lng,rtime:lng,cpu:int,iowait:int):void ",	"QLOGcall;",	"Add a new query call to the query log"	]
[ "querylog",	"define",	"command querylog.define(q:str,pipe:str,size:int):void ",	"QLOGdefineNaive;",	"Noop operation, just marking the query"	]
[ "querylog",	"disable",	"command querylog.disable():void ",	"QLOGdisable;",	"Turn off the query logger"	]
[ "querylog",	"empty",	"command querylog.empty():void ",	"QLOGempty;",	"Clear the query log tables"	]
[ "querylog",	"enable",	"command querylog.enable():void ",	"QLOGenable;",	"Turn on the query logger"	]
[ "querylog",	"enable",	"command querylog.enable(threshold:int):void ",	"QLOGenableThreshold;",	"Turn on the query logger"	]
[ "querylog",	"isset",	"command querylog.isset():int ",	"QLOGissetFcn;",	"Return status of query logger"	]
[ "rapi",	"eval",	"pattern rapi.eval(fptr:ptr,expr:str):any ",	"RAPIevalStd;",	"Execute a simple R script returning a single value"	]
[ "rapi",	"eval",	"pattern rapi.eval(fptr:ptr,expr:str,arg:any...):any... ",	"RAPIevalStd;",	"Execute a simple R script value"	]
[ "rapi",	"eval_aggr",	"pattern rapi.eval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"RAPIevalAggr;",	"grouped aggregates through R"	]
[ "rapi",	"prelude",	"command rapi.prelude():void ",	"RAPIprelude;",	""	]
[ "rapi",	"subeval_aggr",	"pattern rapi.subeval_aggr(fptr:ptr,expr:str,arg:any...):any... ",	"RAPIevalAggr;",	"grouped aggregates through R"	]
[ "remote",	"batbincopy",	"pattern remote.batbincopy():bat[:any] ",	"RMTbincopyfrom;",	"store the binary BAT data in the BBP and return as BAT"	]
[ "remote",	"batbincopy",	"pattern remote.batbincopy(b:bat[:any]):void ",	"RMTbincopyto;",	"dump BAT b in binary form to the stream"	]
[ "remote",	"batload",	"pattern remote.batload(tt:any_1,size:int):bat[:any_1] ",	"RMTbatload;",	"create a BAT of the given type and size, and load values from the input stream"	]
[ "remote",	"bintype",	"pattern remote.bintype():void ",	"RMTbintype;",	"print the binary type of this mserver5"	]
[ "remote",	"connect",	"command remote.connect(uri:str,user:str,passwd:str):str ",	"RMTconnect;",	"returns a newly created connection for uri, using user name and password"	]
[ "remote",	"connect",	"command remote.connect(uri:str,user:str,passwd:str,scen:str):str ",	"RMTconnectScen;",	"returns a newly created connection for uri, using user name, password and scenario"	]
[ "remote",	"disconnect",	"command remote.disconnect(conn:str):void ",	"RMTdisconnect;",	"disconnects the connection pointed to by handle (received from a call to connect()"	]
[ "remote",	"epilogue",	"command remote.epilogue():void ",	"RMTepilogue;",	"release the resources held by the remote module"	]
[ "remote",	"exec",	"pattern remote.exec(conn:str,mod:str,func:str):str ",	"RMTexec;",	"remotely executes <mod>.<func> and returns the handle to its result"	]
[ "remote",	"exec",	"pattern remote.exec(conn:str,mod:str,func:str):str... ",	"RMTexec;",	"remotely executes <mod>.<func> and returns the handle to its result"	]
[ "remote",	"exec",	"pattern remote.exec(conn:str,mod:str,func:str,X_0:str...):str ",	"RMTexec;",	"remotely executes <mod>.<func> using the argument list of remote objects and returns the handle to its result"	]
[ "remote",	"exec",	"pattern remote.exec(conn:str,mod:str,func:str,X_0:str...):str... ",	"RMTexec;",	"remotely executes <mod>.<func> using the argument list of remote objects and returns the handle to its result"	]
[ "remote",	"get",	"pattern remote.get(conn:str,ident:str):any ",	"RMTget;",	"retrieves a copy of remote object ident"	]
[ "remote",	"isalive",	"command remote.isalive(conn:str):int ",	"RMTisalive;",	"check if conn is still valid and connected"	]
[ "remote",	"prelude",	"command remote.prelude():void ",	"RMTprelude;",	"initialise the remote module"	]
[ "remote",	"put",	"pattern remote.put(conn:str,object:any):str ",	"RMTput;",	"copies object to the remote site and returns its identifier"	]
[ "remote",	"register",	"pattern remote.register(conn:str,mod:str,fcn:str):void ",	"RMTregister;",	"register <mod>.<fcn> at the remote site"	]
[ "remote",	"resolve",	"command remote.resolve(pattern:str):bat[:str] ",	"RMTresolve;",	"resolve a pattern against Merovingian and return the URIs"	]
[ "sabaoth",	"epilogue",	"command sabaoth.epilogue():void ",	"SABepilogue;",	"Release the resources held by the sabaoth module"	]
[ "sabaoth",	"getLocalConnectionHost",	"command sabaoth.getLocalConnectionHost():str ",	"SABgetLocalConnectionHost;",	"Returns the hostname this server can be connected to, or nil if none"	]
[ "sabaoth",	"getLocalConnectionPort",	"command sabaoth.getLocalConnectionPort():int ",	"SABgetLocalConnectionPort;",	"Returns the port this server can be connected to, or 0 if none"	]
[ "sabaoth",	"getLocalConnectionURI",	"command sabaoth.getLocalConnectionURI():str ",	"SABgetLocalConnectionURI;",	"Returns the URI this server can be connected to, or nil if none"	]
[ "sabaoth",	"marchConnection",	"command sabaoth.marchConnection(host:str,port:int):void ",	"SABmarchConnection;",	"Publishes the given host/port as available for connecting to this server"	]
[ "sabaoth",	"marchScenario",	"command sabaoth.marchScenario(lang:str):void ",	"SABmarchScenario;",	"Publishes the given language as available for this server"	]
[ "sabaoth",	"prelude",	"command sabaoth.prelude():void ",	"SABprelude;",	"Initialise the sabaoth module"	]
[ "sabaoth",	"retreatScenario",	"command sabaoth.retreatScenario(lang:str):void ",	"SABretreatScenario;",	"Unpublishes the given language as available for this server"	]
[ "sample",	"subuniform",	"command sample.subuniform(b:bat[:any],s:lng):bat[:oid] ",	"SAMPLEuniform;",	"Returns the oids of a uniform sample of size s"	]
[ "sample",	"subuniform",	"command sample.subuniform(b:bat[:any],p:dbl):bat[:oid] ",	"SAMPLEuniform_dbl;",	"Returns the oids of a uniform sample of size = (p x count(b)), where 0 <= p <= 1.0"	]
[ "scheduler",	"pattern",	"pattern scheduler.pattern(pat:str):void ",	"SRVsetServers;",	"Activate the peers matching the pattern and return number found."	]
[ "scheduler",	"peers",	"pattern scheduler.peers(N:int):void ",	"SRVsetServers;",	"Simulate N peers"	]
[ "scheduler",	"srvpool",	"pattern scheduler.srvpool():int ",	"SRVPOOLscheduler;",	"Run a program block in parallel."	]
[ "shp",	"attach",	"pattern shp.attach(filename:str):void ",	"SHPattach;",	"Register an ESRI Shapefile in the vault catalog"	]
[ "shp",	"import",	"pattern shp.import(fileid:int):void ",	"SHPimport;",	"Import an ESRI Shapefile with given id into the vault"	]
[ "shp",	"import",	"pattern shp.import(fileid:int,po:wkb):void ",	"SHPpartialimport;",	"Partially import an ESRI Shapefile with given id into the vault"	]
[ "sphinx",	"search",	"function sphinx.search(q:str):bat[:lng];",	"",	""	]
[ "sphinx",	"searchIndex",	"function sphinx.searchIndex(q:str,i:str):bat[:lng];",	"",	""	]
[ "sphinx",	"searchIndexLimit",	"command sphinx.searchIndexLimit(q:str,i:str,l:int):bat[:lng] ",	"SPHINXsearchIndexLimit;",	"Search the query on the specified index, with limit"	]
[ "sphinx",	"sphinx_search",	"function sphinx.sphinx_search(q:str):bat[:lng];",	"",	""	]
[ "sphinx",	"sphinx_searchIndex",	"function sphinx.sphinx_searchIndex(q:str,i:str):bat[:lng];",	"",	""	]
[ "sphinx",	"sphinx_searchIndexLimit",	"function sphinx.sphinx_searchIndexLimit(q:str,i:str,l:int):bat[:lng];",	"",	""	]
[ "sql",	"abort",	"pattern sql.abort():void ",	"SQLabort;",	"Trigger the abort operation for a MAL block"	]
[ "sql",	"affectedRows",	"pattern sql.affectedRows(mvc:int,nr:lng):int ",	"mvc_affected_rows_wrap;",	"export the number of affected rows by the current query"	]
[ "sql",	"all",	"inline function sql.all(b:bat[:any_1],gp:bat[:oid],gpe:bat[:oid],no_nil:bit):bat[:any_1];",	"",	""	]
[ "sql",	"all",	"command sql.all(col:bat[:any_1]):any_1 ",	"SQLall;",	"if col contains exactly one value return this. Incase of more raise an exception else return nil"	]
[ "sql",	"alpha",	"command sql.alpha(dec:dbl,theta:dbl):dbl ",	"SQLcst_alpha_cst;",	"Implementation of astronomy alpha function: expands the radius theta depending on the declination"	]
[ "sql",	"analyze",	"pattern sql.analyze(minmax:int,sample:lng):void ",	"sql_analyze;",	""	]
[ "sql",	"analyze",	"pattern sql.analyze(minmax:int,sample:lng,sch:str):void ",	"sql_analyze;",	""	]
[ "sql",	"analyze",	"pattern sql.analyze(minmax:int,sample:lng,sch:str,tbl:str):void ",	"sql_analyze;",	""	]
[ "sql",	"analyze",	"pattern sql.analyze(minmax:int,sample:lng,sch:str,tbl:str,col:str):void ",	"sql_analyze;",	"Update the database statistics table"	]
[ "sql",	"append",	"pattern sql.append(mvc:int,sname:str,tname:str,cname:str,ins:any):int ",	"mvc_append_wrap;",	"Append b to the column tname.cname (possibly optimized to replace the insert bat of tname.cname (returns sequence number for order dependence)"	]
[ "sql",	"argRecord",	"pattern sql.argRecord():str ",	"SQLargRecord;",	"Glue together the calling sequence"	]
[ "sql",	"argRecord",	"pattern sql.argRecord(a:any...):str ",	"SQLargRecord;",	"Glue together the calling sequence"	]
[ "sql",	"assert",	"pattern sql.assert(b:bit,msg:str):void ",	"SQLassert;",	"Generate an exception when b==true"	]
[ "sql",	"assert",	"pattern sql.assert(b:int,msg:str):void ",	"SQLassertInt;",	"Generate an exception when b!=0"	]
[ "sql",	"assert",	"pattern sql.assert(b:lng,msg:str):void ",	"SQLassertLng;",	"Generate an exception when b!=0"	]
[ "sql",	"bind",	"pattern sql.bind(mvc:int,schema:str,table:str,column:str,access:int) (uid:bat[:oid],uval:bat[:any_1]) ",	"mvc_bind_wrap;",	"Bind the 'schema.table.column' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind",	"pattern sql.bind(mvc:int,schema:str,table:str,column:str,access:int):bat[:any_1] ",	"mvc_bind_wrap;",	"Bind the 'schema.table.column' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind",	"pattern sql.bind(mvc:int,schema:str,table:str,column:str,access:int,part_nr:int,nr_parts:int) (uid:bat[:oid],uval:bat[:any_1]) ",	"mvc_bind_wrap;",	"Bind the 'schema.table.column' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind",	"pattern sql.bind(mvc:int,schema:str,table:str,column:str,access:int,part_nr:int,nr_parts:int):bat[:any_1] ",	"mvc_bind_wrap;",	"Bind the 'schema.table.column' BAT partition with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind_idxbat",	"pattern sql.bind_idxbat(mvc:int,schema:str,table:str,index:str,access:int) (uid:bat[:oid],uval:bat[:any_1]) ",	"mvc_bind_idxbat_wrap;",	"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind_idxbat",	"pattern sql.bind_idxbat(mvc:int,schema:str,table:str,index:str,access:int):bat[:any_1] ",	"mvc_bind_idxbat_wrap;",	"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind_idxbat",	"pattern sql.bind_idxbat(mvc:int,schema:str,table:str,index:str,access:int,part_nr:int,nr_parts:int) (uid:bat[:oid],uval:bat[:any_1]) ",	"mvc_bind_idxbat_wrap;",	"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"bind_idxbat",	"pattern sql.bind_idxbat(mvc:int,schema:str,table:str,index:str,access:int,part_nr:int,nr_parts:int):bat[:any_1] ",	"mvc_bind_idxbat_wrap;",	"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,grantee:str,role:str,grantor:int,admin:int):void ",	"SQLcatalog;",	"a grant/revoke role statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,iname:str,itype:int,sname:str,tname:str...):void ",	"SQLcatalog;",	"a create index catalog statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,msname:str,mtname:str,psname:str,ptname:str,action:int):void ",	"SQLcatalog;",	"a alter table add/del table catalog statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,func:int,grantee:str,privs:int,grant:int,grantor:int):void ",	"SQLcatalog;",	"a grant/revoke function privileges statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,name:str,action:int):void ",	"SQLcatalog;",	"a catalog statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,name:str,funcid:int,ft:int,action:int):void ",	"SQLcatalog;",	"a catalog statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,name:str,tname:str,time:int,o:int,event:int,oname:str,nname:str,condition:str,query:str):void ",	"SQLcatalog;",	"a catalog statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,t:ptr):void ",	"SQLcatalog;",	"a catalog statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,t:ptr,restart:lng):void ",	"SQLcatalog;",	"a catalog statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,t:ptr,temp:int):void ",	"SQLcatalog;",	"a catalog statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,tname:str):void ",	"SQLcatalog;",	"a catalog trigger statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,tname:str,access:int):void ",	"SQLcatalog;",	"a alter table access statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,tname:str,grantee:str,privs:int,cname:str,grant:int,grantor:int):void ",	"SQLcatalog;",	"a grant/revoke privileges statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,sname:str,tname:str,impl:str):void ",	"SQLcatalog;",	"a create type catalog statement"	]
[ "sql",	"catalog",	"pattern sql.catalog(type:int,user:str,passwd:str,enc:int,schema:str,fullname:str):void ",	"SQLcatalog;",	"a user catalog statement"	]
[ "sql",	"clear_table",	"pattern sql.clear_table(sname:str,tname:str):lng ",	"mvc_clear_table_wrap;",	"Clear table"	]
[ "sql",	"commit",	"pattern sql.commit():void ",	"SQLcommit;",	"Trigger the commit operation for a MAL block"	]
[ "sql",	"copy_from",	"pattern sql.copy_from(t:ptr,sep:str,rsep:str,ssep:str,ns:str,fname:str,nr:lng,offset:lng,locked:int,best:int):bat[:any]... ",	"mvc_import_table_wrap;",	"Import a table from bstream s with the \n\tgiven tuple and seperators (sep/rsep)"	]
[ "sql",	"copy_rejects",	"pattern sql.copy_rejects() (rowid:bat[:lng],fldid:bat[:int],msg:bat[:str],inp:bat[:str]) ",	"COPYrejects;",	""	]
[ "sql",	"copy_rejects_clear",	"pattern sql.copy_rejects_clear():void ",	"COPYrejects_clear;",	""	]
[ "sql",	"create_func_upgrade_oct2014",	"pattern sql.create_func_upgrade_oct2014(sname:str,f:str):int ",	"UPGcreate_func;",	"Create the function described by f, needed for the Oct2014 upgrade"	]
[ "sql",	"create_view_upgrade_oct2014",	"pattern sql.create_view_upgrade_oct2014(sname:str,v:str):int ",	"UPGcreate_view;",	"Create the view described by f, needed for the Oct2014 upgrade"	]
[ "sql",	"createorderindex",	"pattern sql.createorderindex(sch:str,tbl:str,col:str):void ",	"sql_createorderindex;",	"Instantiate the order index on a column"	]
[ "sql",	"current_time",	"pattern sql.current_time():daytime ",	"SQLcurrent_daytime;",	"Get the clients current daytime"	]
[ "sql",	"current_timestamp",	"pattern sql.current_timestamp():timestamp ",	"SQLcurrent_timestamp;",	"Get the clients current timestamp"	]
[ "sql",	"db_users",	"pattern sql.db_users():bat[:str] ",	"db_users_wrap;",	"return table of users with sql scenario"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:bte,r:bte):bte ",	"bte_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:dbl,r:dbl):dbl ",	"dbl_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:flt,r:flt):flt ",	"flt_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:hge,r:hge):hge ",	"hge_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:int,r:int):int ",	"int_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:lng,r:lng):lng ",	"lng_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"dec_round",	"command sql.dec_round(v:sht,r:sht):sht ",	"sht_dec_round_wrap;",	"round off the value v to nearests multiple of r"	]
[ "sql",	"declaredTable",	"pattern sql.declaredTable(name:str):int ",	"mvc_declared_table_wrap;",	"Prepare a declared table"	]
[ "sql",	"delete",	"pattern sql.delete(mvc:int,sname:str,tname:str,b:any):int ",	"mvc_delete_wrap;",	"delete from table"	]
[ "sql",	"delta",	"command sql.delta(col:bat[:any_3],uid:bat[:oid],uval:bat[:any_3]):bat[:any_3] ",	"DELTAbat2;",	"Return column bat with delta's applied."	]
[ "sql",	"delta",	"command sql.delta(col:bat[:any_3],uid:bat[:oid],uval:bat[:any_3],ins:bat[:any_3]):bat[:any_3] ",	"DELTAbat;",	"Return column bat with delta's applied."	]
[ "sql",	"dense_rank",	"pattern sql.dense_rank(b:any_1,p:bit,o:bit):int ",	"SQLdense_rank;",	"return the densely ranked groups"	]
[ "sql",	"diff",	"pattern sql.diff(b:any_1):bit ",	"SQLdiff;",	"return true if cur != prev row"	]
[ "sql",	"diff",	"pattern sql.diff(p:bit,b:any_1):bit ",	"SQLdiff;",	"return true if cur != prev row"	]
[ "sql",	"dropDeclaredTable",	"pattern sql.dropDeclaredTable(name:str):void ",	"mvc_drop_declared_table_wrap;",	"drop a declared table"	]
[ "sql",	"dropDeclaredTables",	"pattern sql.dropDeclaredTables(nr:int):void ",	"mvc_drop_declared_tables_wrap;",	"drop top n declared tables"	]
[ "sql",	"drop_func_upgrade_oct2014",	"pattern sql.drop_func_upgrade_oct2014(id:int):int ",	"UPGdrop_func;",	"Drop the function identified by id, needed for the Oct2014 upgrade"	]
[ "sql",	"drop_hash",	"pattern sql.drop_hash(sch:str,tbl:str):void ",	"SQLdrop_hash;",	"Drop hash indices for the given table"	]
[ "sql",	"droporderindex",	"pattern sql.droporderindex(sch:str,tbl:str,col:str):void ",	"sql_droporderindex;",	"Drop the order index on a column"	]
[ "sql",	"dtColumn",	"pattern sql.dtColumn(rs:int,tname:str,name:str,typename:str,digits:int,scale:int):void ",	"mvc_declared_table_column_wrap;",	""	]
[ "sql",	"dump_cache",	"pattern sql.dump_cache() (query:bat[:str],count:bat[:int]) ",	"dump_cache;",	"dump the content of the query cache"	]
[ "sql",	"dump_opt_stats",	"pattern sql.dump_opt_stats() (rewrite:bat[:str],count:bat[:int]) ",	"dump_opt_stats;",	"dump the optimizer rewrite statistics"	]
[ "sql",	"dump_trace",	"pattern sql.dump_trace() (event:bat[:int],clk:bat[:str],pc:bat[:str],thread:bat[:int],ticks:bat[:lng],rssMB:bat[:lng],vmMB:bat[:lng],reads:bat[:lng],writes:bat[:lng],minflt:bat[:lng],majflt:bat[:lng],nvcsw:bat[:lng],stmt:bat[:str]) ",	"dump_trace;",	"dump the trace statistics"	]
[ "sql",	"emptybind",	"pattern sql.emptybind(mvc:int,schema:str,table:str,column:str,access:int) (uid:bat[:oid],uval:bat[:any_1]) ",	"mvc_bind_wrap;",	""	]
[ "sql",	"emptybind",	"pattern sql.emptybind(mvc:int,schema:str,table:str,column:str,access:int):bat[:any_1] ",	"mvc_bind_wrap;",	""	]
[ "sql",	"emptybind",	"pattern sql.emptybind(mvc:int,schema:str,table:str,column:str,access:int,part_nr:int,nr_parts:int) (uid:bat[:oid],uval:bat[:any_1]) ",	"mvc_bind_wrap;",	""	]
[ "sql",	"emptybind",	"pattern sql.emptybind(mvc:int,schema:str,table:str,column:str,access:int,part_nr:int,nr_parts:int):bat[:any_1] ",	"mvc_bind_wrap;",	""	]
[ "sql",	"emptybindidx",	"pattern sql.emptybindidx(mvc:int,schema:str,table:str,index:str,access:int) (uid:bat[:oid],uval:bat[:any_1]) ",	"mvc_bind_idxbat_wrap;",	""	]
[ "sql",	"emptybindidx",	"pattern sql.emptybindidx(mvc:int,schema:str,table:str,index:str,access:int):bat[:any_1] ",	"mvc_bind_idxbat_wrap;",	""	]
[ "sql",	"emptybindidx",	"pattern sql.emptybindidx(mvc:int,schema:str,table:str,index:str,access:int,part_nr:int,nr_parts:int) (uid:bat[:oid],uval:bat[:any_1]) ",	"mvc_bind_idxbat_wrap;",	""	]
[ "sql",	"emptybindidx",	"pattern sql.emptybindidx(mvc:int,schema:str,table:str,index:str,access:int,part_nr:int,nr_parts:int):bat[:any_1] ",	"mvc_bind_idxbat_wrap;",	""	]
[ "sql",	"epilogue",	"command sql.epilogue():void ",	"SQLepilogue;",	""	]
[ "sql",	"eval",	"pattern sql.eval(cmd:str):void ",	"SQLstatement;",	"Compile and execute a single sql statement"	]
[ "sql",	"eval",	"pattern sql.eval(cmd:str,output:bit):void ",	"SQLstatement;",	"Compile and execute a single sql statement (and optionaly send output on the output stream)"	]
[ "sql",	"evalAlgebra",	"pattern sql.evalAlgebra(cmd:str,optimize:bit):void ",	"RAstatement;",	"Compile and execute a single 'relational algebra' statement"	]
[ "sql",	"exportChunk",	"pattern sql.exportChunk(s:streams,res_id:int):void ",	"mvc_export_chunk_wrap;",	"Export a chunk of the result set (in order) to stream s"	]
[ "sql",	"exportChunk",	"pattern sql.exportChunk(s:streams,res_id:int,offset:int,nr:int):void ",	"mvc_export_chunk_wrap;",	"Export a chunk of the result set (in order) to stream s"	]
[ "sql",	"exportHead",	"pattern sql.exportHead(s:streams,res_id:int):void ",	"mvc_export_head_wrap;",	"Export a result (in order) to stream s"	]
[ "sql",	"exportOperation",	"pattern sql.exportOperation():void ",	"mvc_export_operation_wrap;",	"Export result of schema/transaction queries"	]
[ "sql",	"exportResult",	"pattern sql.exportResult(s:streams,res_id:int):void ",	"mvc_export_result_wrap;",	"Export a result (in order) to stream s"	]
[ "sql",	"export_table",	"pattern sql.export_table(fname:str,fmt:str,colsep:str,recsep:str,qout:str,nullrep:str,tbl:bat[:str],attr:bat[:str],tpe:bat[:str],len:bat[:int],scale:bat[:int],cols:any...):int ",	"mvc_export_row_wrap;",	"Prepare a table result set for the COPY INTO stream"	]
[ "sql",	"export_table",	"pattern sql.export_table(fname:str,fmt:str,colsep:str,recsep:str,qout:str,nullrep:str,tbl:bat[:str],attr:bat[:str],tpe:bat[:str],len:bat[:int],scale:bat[:int],cols:bat[:any]...):int ",	"mvc_export_table_wrap;",	"Prepare a table result set for the COPY INTO stream"	]
[ "sql",	"flush_log",	"command sql.flush_log():void ",	"SQLflush_log;",	"flush the log now"	]
[ "sql",	"getVariable",	"pattern sql.getVariable(mvc:int,varname:str):any_1 ",	"getVariable;",	"Get the value of a session variable"	]
[ "sql",	"getVersion",	"command sql.getVersion(clientid:int):lng ",	"mvc_getVersion;",	"Return the database version identifier for a client"	]
[ "sql",	"get_value",	"pattern sql.get_value(sname:str,sequence:str):lng ",	"mvc_get_value;",	"return the current value of the sequence"	]
[ "sql",	"importTable",	"pattern sql.importTable(sname:str,tname:str,fname:str...):bat[:any]... ",	"mvc_bin_import_table_wrap;",	"Import a table from the files (fname)"	]
[ "sql",	"include",	"pattern sql.include(fname:str):void ",	"SQLinclude;",	"Compile and execute a sql statements on the file"	]
[ "sql",	"init",	"pattern sql.init():void ",	"SQLinitEnvironment;",	"Initialize the environment for MAL"	]
[ "sql",	"logfile",	"pattern sql.logfile(filename:str):void ",	"mvc_logfile;",	"Enable/disable saving the sql statement traces"	]
[ "sql",	"ms_trunc",	"command sql.ms_trunc(v:dbl,r:int):dbl ",	"dbl_trunc_wrap;",	"truncate the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"ms_trunc",	"command sql.ms_trunc(v:flt,r:int):flt ",	"flt_trunc_wrap;",	"truncate the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"mvc",	"pattern sql.mvc():int ",	"SQLmvc;",	"Get the multiversion catalog context. \nNeeded for correct statement dependencies\n(ie sql.update, should be after sql.bind in concurrent execution)"	]
[ "sql",	"next_value",	"pattern sql.next_value(sname:str,sequence:str):lng ",	"mvc_next_value;",	"return the next value of the sequence"	]
[ "sql",	"not_unique",	"command sql.not_unique(b:bat[:oid]):bit ",	"not_unique;",	"check if the tail sorted bat b doesn't have unique tail values"	]
[ "sql",	"optimizer_updates",	"pattern sql.optimizer_updates():void ",	"SQLoptimizersUpdate;",	""	]
[ "sql",	"optimizers",	"command sql.optimizers() (X_0:bat[:str],X_1:bat[:str],X_2:bat[:str]) ",	"getPipeCatalog;",	""	]
[ "sql",	"password",	"pattern sql.password(user:str):str ",	"db_password_wrap;",	"Return password hash of user"	]
[ "sql",	"prelude",	"command sql.prelude():void ",	"SQLprelude;",	""	]
[ "sql",	"project",	"command sql.project(col:bat[:oid],l:bat[:oid],r:bat[:oid]):bat[:oid] ",	"BATleftproject;",	"Last step of a left outer join, ie project the inner join (l,r) over the left input side (col)"	]
[ "sql",	"projectdelta",	"command sql.projectdelta(subselect:bat[:oid],col:bat[:any_3],uid:bat[:oid],uval:bat[:any_3]):bat[:any_3] ",	"DELTAproject2;",	"Return column bat with delta's applied."	]
[ "sql",	"projectdelta",	"command sql.projectdelta(subselect:bat[:oid],col:bat[:any_3],uid:bat[:oid],uval:bat[:any_3],ins:bat[:any_3]):bat[:any_3] ",	"DELTAproject;",	"Return column bat with delta's applied."	]
[ "sql",	"querylog_calls",	"pattern sql.querylog_calls() (id:bat[:oid],start:bat[:timestamp],stop:bat[:timestamp],arguments:bat[:str],tuples:bat[:lng],exec:bat[:lng],result:bat[:lng],cpuload:bat[:int],iowait:bat[:int]) ",	"sql_querylog_calls;",	"Obtain the query log calls"	]
[ "sql",	"querylog_catalog",	"pattern sql.querylog_catalog() (id:bat[:oid],user:bat[:str],defined:bat[:timestamp],query:bat[:str],pipe:bat[:str],plan:bat[:str],mal:bat[:int],optimize:bat[:lng]) ",	"sql_querylog_catalog;",	"Obtain the query log catalog"	]
[ "sql",	"querylog_disable",	"command sql.querylog_disable():void ",	"QLOGdisable;",	""	]
[ "sql",	"querylog_empty",	"pattern sql.querylog_empty():void ",	"sql_querylog_empty;",	""	]
[ "sql",	"querylog_enable",	"command sql.querylog_enable():void ",	"QLOGenable;",	""	]
[ "sql",	"querylog_enable",	"command sql.querylog_enable(thres:int):void ",	"QLOGenableThreshold;",	""	]
[ "sql",	"rank",	"pattern sql.rank(b:any_1,p:bit,o:bit):int ",	"SQLrank;",	"return the ranked groups"	]
[ "sql",	"register",	"pattern sql.register(mod:str,fname:str,rel_stmt:str,sig:str):int ",	"RAstatement2;",	"Compile the relational statement (rel_smt) and register it as mal function, mod.fname(signature)"	]
[ "sql",	"restart",	"pattern sql.restart(sname:str,sequence:str,start:lng):lng ",	"mvc_restart_seq;",	"restart the sequence with value start"	]
[ "sql",	"resultSet",	"pattern sql.resultSet(tbl:bat[:str],attr:bat[:str],tpe:bat[:str],len:bat[:int],scale:bat[:int],cols:any...):int ",	"mvc_row_result_wrap;",	"Prepare a table result set"	]
[ "sql",	"resultSet",	"pattern sql.resultSet(tbl:str,attr:str,tpe:str,len:int,scale:int,eclass:int,val:any):int ",	"mvc_scalar_value_wrap;",	"Prepare a table result set"	]
[ "sql",	"resultSet",	"pattern sql.resultSet(tbl:bat[:str],attr:bat[:str],tpe:bat[:str],len:bat[:int],scale:bat[:int],cols:bat[:any]...):int ",	"mvc_table_result_wrap;",	"Prepare a table result set for the client in default CSV format"	]
[ "sql",	"reuse",	"pattern sql.reuse(sch:str,tbl:str):void ",	"SQLreuse;",	"Consolidate the deletion table over all columns reusing deleted slots"	]
[ "sql",	"round",	"command sql.round(v:bte,d:int,s:int,r:bte):bte ",	"bte_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:dbl,r:bte):dbl ",	"dbl_round_wrap;",	"round off the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:flt,r:bte):flt ",	"flt_round_wrap;",	"round off the floating point v to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:hge,d:int,s:int,r:bte):hge ",	"hge_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:int,d:int,s:int,r:bte):int ",	"int_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:lng,d:int,s:int,r:bte):lng ",	"lng_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"round",	"command sql.round(v:sht,d:int,s:int,r:bte):sht ",	"sht_round_wrap;",	"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"	]
[ "sql",	"row_number",	"pattern sql.row_number(b:any_1,p:bit,o:bit):int ",	"SQLrow_number;",	"return the row_numer-ed groups"	]
[ "sql",	"sessions",	"pattern sql.sessions() (user:bat[:str],start:bat[:timestamp],stimeout:bat[:lng],lastcmd:bat[:timestamp],qtimeout:bat[:lng],idle:bat[:bit]) ",	"sql_sessions_wrap;",	"SQL export table of active sessions, their timeouts and idle status"	]
[ "sql",	"setVariable",	"pattern sql.setVariable(mvc:int,varname:str,value:any_1):int ",	"setVariable;",	"Set the value of a session variable"	]
[ "sql",	"shrink",	"pattern sql.shrink(sch:str,tbl:str):void ",	"SQLshrink;",	"Consolidate the deletion table over all columns using shrinking"	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:bte):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:bte,force:bit):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:int):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:int,force:bit):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:sht):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"shutdown",	"pattern sql.shutdown(delay:sht,force:bit):str ",	"SQLshutdown_wrap;",	""	]
[ "sql",	"single",	"pattern sql.single(x:any_2):bat[:any_2] ",	"CMDBATsingle;",	""	]
[ "sql",	"sql_environment",	"inline function sql.sql_environment() (name:bat[:str],value:bat[:str]);",	"",	""	]
[ "sql",	"sql_variables",	"pattern sql.sql_variables():bat[:str] ",	"sql_variables;",	"return the table with session variables"	]
[ "sql",	"start",	"pattern sql.start():void ",	"SQLsession;",	"Switch to processing SQL statements"	]
[ "sql",	"start2",	"pattern sql.start2():void ",	"SQLsession2;",	"Switch to processing precompiled sql statements"	]
[ "sql",	"storage",	"pattern sql.storage() (schema:bat[:str],table:bat[:str],column:bat[:str],type:bat[:str],mode:bat[:str],location:bat[:str],count:bat[:lng],atomwidth:bat[:int],columnsize:bat[:lng],heap:bat[:lng],hashes:bat[:lng],phash:bat[:bit],imprints:bat[:lng],sorted:bat[:bit],revsorted:bat[:bit],key:bat[:bit],orderidx:bat[:lng]) ",	"sql_storage;",	"return a table with storage information "	]
[ "sql",	"storage",	"pattern sql.storage(sname:str) (schema:bat[:str],table:bat[:str],column:bat[:str],type:bat[:str],mode:bat[:str],location:bat[:str],count:bat[:lng],atomwidth:bat[:int],columnsize:bat[:lng],heap:bat[:lng],hashes:bat[:lng],phash:bat[:bit],imprints:bat[:lng],sorted:bat[:bit],revsorted:bat[:bit],key:bat[:bit],orderidx:bat[:lng]) ",	"sql_storage;",	"return a table with storage information for a particular schema "	]
[ "sql",	"storage",	"pattern sql.storage(sname:str,tname:str) (schema:bat[:str],table:bat[:str],column:bat[:str],type:bat[:str],mode:bat[:str],location:bat[:str],count:bat[:lng],atomwidth:bat[:int],columnsize:bat[:lng],heap:bat[:lng],hashes:bat[:lng],phash:bat[:bit],imprints:bat[:lng],sorted:bat[:bit],revsorted:bat[:bit],key:bat[:bit],orderidx:bat[:lng]) ",	"sql_storage;",	"return a table with storage information for a particular table"	]
[ "sql",	"storage",	"pattern sql.storage(sname:str,tname:str,cname:str) (schema:bat[:str],table:bat[:str],column:bat[:str],type:bat[:str],mode:bat[:str],location:bat[:str],count:bat[:lng],atomwidth:bat[:int],columnsize:bat[:lng],heap:bat[:lng],hashes:bat[:lng],phash:bat[:bit],imprints:bat[:lng],sorted:bat[:bit],revsorted:bat[:bit],key:bat[:bit],orderidx:bat[:lng]) ",	"sql_storage;",	"return a table with storage information for a particular column"	]
[ "sql",	"subdelta",	"command sql.subdelta(col:bat[:oid],cand:bat[:oid],uid:bat[:oid],uval:bat[:oid]):bat[:oid] ",	"DELTAsub2;",	"Return a single bat of subselected delta."	]
[ "sql",	"subdelta",	"command sql.subdelta(col:bat[:oid],cand:bat[:oid],uid:bat[:oid],uval:bat[:oid],ins:bat[:oid]):bat[:oid] ",	"DELTAsub;",	"Return a single bat of subselected delta."	]
[ "sql",	"subzero_or_one",	"inline function sql.subzero_or_one(b:bat[:any_1],gp:bat[:oid],gpe:bat[:oid],no_nil:bit):bat[:any_1];",	"",	""	]
[ "sql",	"sysmon_pause",	"pattern sql.sysmon_pause(tag:int):void ",	"SYSMONpause;",	""	]
[ "sql",	"sysmon_pause",	"pattern sql.sysmon_pause(tag:lng):void ",	"SYSMONpause;",	""	]
[ "sql",	"sysmon_pause",	"pattern sql.sysmon_pause(tag:sht):void ",	"SYSMONpause;",	""	]
[ "sql",	"sysmon_queue",	"pattern sql.sysmon_queue() (qtag:bat[:lng],user:bat[:str],started:bat[:timestamp],estimate:bat[:timestamp],progress:bat[:int],status:bat[:str],tag:bat[:oid],query:bat[:str]) ",	"SYSMONqueue;",	""	]
[ "sql",	"sysmon_resume",	"pattern sql.sysmon_resume(tag:int):void ",	"SYSMONresume;",	""	]
[ "sql",	"sysmon_resume",	"pattern sql.sysmon_resume(tag:lng):void ",	"SYSMONresume;",	""	]
[ "sql",	"sysmon_resume",	"pattern sql.sysmon_resume(tag:sht):void ",	"SYSMONresume;",	""	]
[ "sql",	"sysmon_stop",	"pattern sql.sysmon_stop(tag:int):void ",	"SYSMONstop;",	""	]
[ "sql",	"sysmon_stop",	"pattern sql.sysmon_stop(tag:lng):void ",	"SYSMONstop;",	""	]
[ "sql",	"sysmon_stop",	"pattern sql.sysmon_stop(tag:sht):void ",	"SYSMONstop;",	""	]
[ "sql",	"tid",	"pattern sql.tid(mvc:int,sname:str,tname:str):bat[:oid] ",	"SQLtid;",	"Return the tables tid column."	]
[ "sql",	"tid",	"pattern sql.tid(mvc:int,sname:str,tname:str,part_nr:int,nr_parts:int):bat[:oid] ",	"SQLtid;",	"Return the tables tid column."	]
[ "sql",	"trans",	"pattern sql.trans(type:int,chain:int,name:str):void ",	"SQLtransaction;",	"A transaction statement (type can be commit,release,rollback or start)"	]
[ "sql",	"transaction",	"pattern sql.transaction():void ",	"SQLtransaction2;",	"Start an autocommit transaction"	]
[ "sql",	"update",	"pattern sql.update(mvc:int,sname:str,tname:str,cname:str,rids:any,upd:any):int ",	"mvc_update_wrap;",	"Update the values of the column tname.cname"	]
[ "sql",	"vacuum",	"pattern sql.vacuum(sch:str,tbl:str):void ",	"SQLvacuum;",	"Choose an approach to consolidate the deletions"	]
[ "sql",	"zero_or_one",	"command sql.zero_or_one(col:bat[:any_1]):any_1 ",	"zero_or_one;",	"if col contains exactly one value return this. Incase of more raise an exception else return nil"	]
[ "sqlblob",	"#fromstr",	"command sqlblob.#fromstr():void ",	"SQLBLOBfromstr;",	""	]
[ "sqlblob",	"#tostr",	"command sqlblob.#tostr():void ",	"SQLBLOBtostr;",	""	]
[ "sqlblob",	"sqlblob",	"command sqlblob.sqlblob(s:sqlblob):sqlblob ",	"BLOBblob_blob;",	"Noop routine."	]
[ "sqlblob",	"sqlblob",	"command sqlblob.sqlblob(s:str):sqlblob ",	"BLOBsqlblob_fromstr;",	""	]
[ "srvpool",	"connect",	"command srvpool.connect(dbname:str):str ",	"SRVPOOLconnect;",	"Returns the connection to the server dbname."	]
[ "srvpool",	"exec",	"pattern srvpool.exec(fname:str,arg:any...):any... ",	"SRVPOOLexec;",	"Remote execution of the function on dbname if channel is free."	]
[ "srvpool",	"local",	"command srvpool.local(b:bit):void ",	"SRVPOOLlocal;",	"Change location from remote to local execution"	]
[ "srvpool",	"query",	"pattern srvpool.query(plan:str):str... ",	"SRVPOOLquery;",	"Allocate a list of servers for query execution"	]
[ "srvpool",	"reset",	"pattern srvpool.reset(dbname:str):str ",	"SRVPOOLreset;",	"Clear the server cache"	]
[ "status",	"batStatistics",	"command status.batStatistics() (X_0:bat[:str],X_1:bat[:str]) ",	"SYSgdkEnv;",	"Show distribution of bats by kind"	]
[ "status",	"cpuStatistics",	"command status.cpuStatistics() (X_0:bat[:str],X_1:bat[:int]) ",	"SYScpuStatistics;",	"Global cpu usage information"	]
[ "status",	"getThreads",	"command status.getThreads() (X_0:bat[:int],X_1:bat[:str]) ",	"SYSgdkThread;",	"Produce overview of active threads"	]
[ "status",	"ioStatistics",	"command status.ioStatistics() (X_0:bat[:str],X_1:bat[:int]) ",	"SYSioStatistics;",	"Global IO activity information"	]
[ "status",	"memStatistics",	"command status.memStatistics() (X_0:bat[:str],X_1:bat[:lng]) ",	"SYSmemStatistics;",	"Global memory usage information"	]
[ "status",	"memUsage",	"command status.memUsage(minsize:lng) (X_0:bat[:str],X_1:bat[:lng]) ",	"SYSmem_usage;",	"Get a split-up of how much memory blocks are in use"	]
[ "status",	"mem_cursize",	"command status.mem_cursize():lng ",	"SYSgetmem_cursize;",	"The amount of physical swapspace in KB that is currently in use"	]
[ "status",	"mem_maxsize",	"command status.mem_maxsize():lng ",	"SYSgetmem_maxsize;",	"The maximum usable amount of physical swapspace in KB (target only)"	]
[ "status",	"mem_maxsize",	"command status.mem_maxsize(v:lng):void ",	"SYSsetmem_maxsize;",	"Set the maximum usable amount of physical swapspace in KB"	]
[ "status",	"vmStatistics",	"command status.vmStatistics(minsize:lng) (X_0:bat[:str],X_1:bat[:lng]) ",	"SYSvm_usage;",	"Get a split-up of how much virtual memory blocks are in use"	]
[ "status",	"vm_cursize",	"command status.vm_cursize():lng ",	"SYSgetvm_cursize;",	"The amount of logical VM space in KB that is currently in use"	]
[ "status",	"vm_maxsize",	"command status.vm_maxsize():lng ",	"SYSgetvm_maxsize;",	"The maximum usable amount of logical VM space in KB (target only)"	]
[ "status",	"vm_maxsize",	"command status.vm_maxsize(v:lng):void ",	"SYSsetvm_maxsize;",	"Set the maximum usable amount of physical swapspace in KB"	]
[ "str",	"+",	"command str.+(l:str,r:str):str ",	"STRConcat;",	"Concatenate two strings."	]
[ "str",	"STRepilogue",	"command str.STRepilogue():void ",	"strEpilogue;",	""	]
[ "str",	"STRprelude",	"command str.STRprelude():void ",	"strPrelude;",	""	]
[ "str",	"ascii",	"command str.ascii(s:str):int ",	"STRascii;",	"Return unicode of head of string"	]
[ "str",	"endsWith",	"command str.endsWith(s:str,suffix:str):bit ",	"STRSuffix;",	"Suffix check."	]
[ "str",	"insert",	"command str.insert(s:str,start:int,l:int,s2:str):str ",	"STRinsert;",	"Insert a string into another"	]
[ "str",	"length",	"command str.length(s:str):int ",	"STRLength;",	"Return the length of a string."	]
[ "str",	"like",	"command str.like(s:str,pat:str):bit ",	"STRlikewrap2;",	"SQL pattern match function"	]
[ "str",	"like",	"command str.like(s:str,pat:str,esc:str):bit ",	"STRlikewrap;",	"SQL pattern match function"	]
[ "str",	"locate",	"command str.locate(s1:str,s2:str,start:int):int ",	"STRlocate2;",	"Locate the start position of a string"	]
[ "str",	"locate",	"command str.locate(s1:str,s2:str):int ",	"STRlocate;",	"Locate the start position of a string"	]
[ "str",	"lpad",	"command str.lpad(s:str,len:int,s2:str):str ",	"STRLpad2;",	"Fill up the first string to the given length prepending characters of the second string."	]
[ "str",	"lpad",	"command str.lpad(s:str,len:int):str ",	"STRLpad;",	"Fill up a string to the given length prepending the whitespace character."	]
[ "str",	"ltrim",	"command str.ltrim(s:str,s2:str):str ",	"STRLtrim2;",	"Remove the longest string containing only characters from the second string from the start of the first string."	]
[ "str",	"ltrim",	"command str.ltrim(s:str):str ",	"STRLtrim;",	"Strip whitespaces from start of a string."	]
[ "str",	"nbytes",	"command str.nbytes(s:str):int ",	"STRBytes;",	"Return the string length in bytes."	]
[ "str",	"prefix",	"command str.prefix(s:str,l:int):str ",	"STRprefix;",	"Extract the prefix of a given length"	]
[ "str",	"r_search",	"command str.r_search(s:str,c:str):int ",	"STRReverseStrSearch;",	"Reverse search for a substring. Returns\n\t position, -1 if not found."	]
[ "str",	"repeat",	"command str.repeat(s2:str,c:int):str ",	"STRrepeat;",	""	]
[ "str",	"replace",	"command str.replace(origin:str,pat:str,repl:str,flags:str):str ",	"PCREreplace_wrap;",	""	]
[ "str",	"replace",	"command str.replace(s:str,pat:str,s2:str):str ",	"STRreplace;",	"Insert a string into another"	]
[ "str",	"rpad",	"command str.rpad(s:str,len:int,s2:str):str ",	"STRRpad2;",	"Fill up the first string to the given length appending characters of the second string."	]
[ "str",	"rpad",	"command str.rpad(s:str,len:int):str ",	"STRRpad;",	"Fill up a string to the given length appending the whitespace character."	]
[ "str",	"rtrim",	"command str.rtrim(s:str,s2:str):str ",	"STRRtrim2;",	"Remove the longest string containing only characters from the second string from the end of the first string."	]
[ "str",	"rtrim",	"command str.rtrim(s:str):str ",	"STRRtrim;",	"Strip whitespaces from end of a string."	]
[ "str",	"search",	"command str.search(s:str,c:str):int ",	"STRstrSearch;",	"Search for a substring. Returns\n\t position, -1 if not found."	]
[ "str",	"space",	"command str.space(l:int):str ",	"STRspace;",	""	]
[ "str",	"splitpart",	"command str.splitpart(s:str,needle:str,field:int):str ",	"STRsplitpart;",	"Split string on delimiter. Returns\n\t given field (counting from one.)"	]
[ "str",	"startsWith",	"command str.startsWith(s:str,prefix:str):bit ",	"STRPrefix;",	"Prefix check."	]
[ "str",	"str",	"command str.str(s:str):str ",	"STRtostr;",	"Noop routine."	]
[ "str",	"string",	"command str.string(s:str,offset:int,count:int):str ",	"STRSubString;",	"Return substring s[offset..offset+count] of a string s[0..n]"	]
[ "str",	"string",	"command str.string(s:str,offset:int):str ",	"STRTail;",	"Return the tail s[offset..n]\n\t of a string s[0..n]."	]
[ "str",	"stringleft",	"command str.stringleft(s:str,l:int):str ",	"STRprefix;",	""	]
[ "str",	"stringright",	"command str.stringright(s:str,l:int):str ",	"STRsuffix;",	""	]
[ "str",	"substitute",	"command str.substitute(s:str,src:str,dst:str,rep:bit):str ",	"STRSubstitute;",	"Substitute first occurrence of 'src' by\n\t'dst'.  Iff repeated = true this is\n\trepeated while 'src' can be found in the\n\tresult string. In order to prevent\n\trecursion and result strings of unlimited\n\tsize, repeating is only done iff src is\n\tnot a substring of dst."	]
[ "str",	"substring",	"command str.substring(s:str,start:int,len:int):str ",	"STRsubstring;",	"Extract a substring from str starting at start, for length len"	]
[ "str",	"substring",	"command str.substring(s:str,start:int):str ",	"STRsubstringTail;",	"Extract the tail of a string"	]
[ "str",	"suffix",	"command str.suffix(s:str,l:int):str ",	"STRsuffix;",	"Extract the suffix of a given length"	]
[ "str",	"toLower",	"command str.toLower(s:str):str ",	"STRLower;",	"Convert a string to lower case."	]
[ "str",	"toUpper",	"command str.toUpper(s:str):str ",	"STRUpper;",	"Convert a string to upper case."	]
[ "str",	"trim",	"command str.trim(s:str,s2:str):str ",	"STRStrip2;",	"Remove the longest string containing only characters from the second string around the first string."	]
[ "str",	"trim",	"command str.trim(s:str):str ",	"STRStrip;",	"Strip whitespaces around a string."	]
[ "str",	"unicode",	"command str.unicode(wchar:int):str ",	"STRFromWChr;",	"convert a unicode to a character."	]
[ "str",	"unicodeAt",	"command str.unicodeAt(s:str,index:int):int ",	"STRWChrAt;",	"get a unicode character\n\t(as an int) from a string position."	]
[ "streams",	"blocked",	"command streams.blocked(s:streams):streams ",	"open_block_streamwrap;",	"open a block based stream"	]
[ "streams",	"close",	"command streams.close(s:streams):void ",	"mnstr_close_streamwrap;",	"close and destroy the stream s"	]
[ "streams",	"flush",	"command streams.flush(s:streams):void ",	"mnstr_flush_streamwrap;",	"flush the stream"	]
[ "streams",	"openRead",	"command streams.openRead(filename:str):streams ",	"mnstr_open_rastreamwrap;",	"open ascii file stream for reading"	]
[ "streams",	"openRead",	"command streams.openRead(s:streams):streams ",	"mnstr_stream_rstreamwrap;",	"convert an ascii stream to binary"	]
[ "streams",	"openReadBytes",	"command streams.openReadBytes(filename:str):streams ",	"mnstr_open_rstreamwrap;",	"open a file stream for reading"	]
[ "streams",	"openWrite",	"command streams.openWrite(filename:str):streams ",	"mnstr_open_wastreamwrap;",	"open ascii file stream for writing"	]
[ "streams",	"openWrite",	"command streams.openWrite(s:streams):streams ",	"mnstr_stream_wstreamwrap;",	"convert an ascii stream to binary"	]
[ "streams",	"openWriteBytes",	"command streams.openWriteBytes(filename:str):streams ",	"mnstr_open_wstreamwrap;",	"open a file stream for writing"	]
[ "streams",	"readInt",	"command streams.readInt(s:streams):int ",	"mnstr_readIntwrap;",	"read integer data from the stream"	]
[ "streams",	"readStr",	"command streams.readStr(s:streams):str ",	"mnstr_read_stringwrap;",	"read string data from the stream"	]
[ "streams",	"socketRead",	"command streams.socketRead(skt:int,name:str):streams ",	"mnstr_socket_rastreamwrap;",	"open ascii socket stream for reading"	]
[ "streams",	"socketReadBytes",	"command streams.socketReadBytes(skt:int,name:str):streams ",	"mnstr_socket_rstreamwrap;",	"open a socket stream for reading"	]
[ "streams",	"socketWrite",	"command streams.socketWrite(skt:int,name:str):streams ",	"mnstr_socket_wastreamwrap;",	"open ascii socket stream for writing"	]
[ "streams",	"socketWriteBytes",	"command streams.socketWriteBytes(skt:int,name:str):streams ",	"mnstr_socket_wstreamwrap;",	"open a socket stream for writing"	]
[ "streams",	"writeInt",	"command streams.writeInt(s:streams,data:int):void ",	"mnstr_writeIntwrap;",	"write data on the stream"	]
[ "streams",	"writeStr",	"command streams.writeStr(s:streams,data:str):void ",	"mnstr_write_stringwrap;",	"write data on the stream"	]
[ "sysmon",	"pause",	"pattern sysmon.pause(id:int):void ",	"SYSMONpause;",	""	]
[ "sysmon",	"pause",	"pattern sysmon.pause(id:lng):void ",	"SYSMONpause;",	"Temporary suspend a single query"	]
[ "sysmon",	"pause",	"pattern sysmon.pause(id:sht):void ",	"SYSMONpause;",	""	]
[ "sysmon",	"queue",	"pattern sysmon.queue() (tag:bat[:lng],user:bat[:str],started:bat[:timestamp],estimate:bat[:timestamp],progress:bat[:int],status:bat[:str],qrytag:bat[:oid],query:bat[:str]) ",	"SYSMONqueue;",	""	]
[ "sysmon",	"resume",	"pattern sysmon.resume(id:int):void ",	"SYSMONresume;",	""	]
[ "sysmon",	"resume",	"pattern sysmon.resume(id:lng):void ",	"SYSMONresume;",	"Resume processing "	]
[ "sysmon",	"resume",	"pattern sysmon.resume(id:sht):void ",	"SYSMONresume;",	""	]
[ "sysmon",	"stop",	"pattern sysmon.stop(id:int):void ",	"SYSMONstop;",	""	]
[ "sysmon",	"stop",	"pattern sysmon.stop(id:lng):void ",	"SYSMONstop;",	"Stop a single query a.s.a.p."	]
[ "sysmon",	"stop",	"pattern sysmon.stop(id:sht):void ",	"SYSMONstop;",	""	]
[ "timestamp",	"!=",	"pattern timestamp.!=(v:timestamp,w:timestamp):bit ",	"CMDvarNE;",	"Equality of two timestamps"	]
[ "timestamp",	"#fromstr",	"command timestamp.#fromstr():void ",	"timestamp_fromstr;",	""	]
[ "timestamp",	"#tostr",	"command timestamp.#tostr():void ",	"timestamp_tostr;",	""	]
[ "timestamp",	"<",	"pattern timestamp.<(v:timestamp,w:timestamp):bit ",	"CMDvarLT;",	"Equality of two timestamps"	]
[ "timestamp",	"<=",	"pattern timestamp.<=(v:timestamp,w:timestamp):bit ",	"CMDvarLE;",	"Equality of two timestamps"	]
[ "timestamp",	"==",	"pattern timestamp.==(v:timestamp,w:timestamp):bit ",	"CMDvarEQ;",	"Equality of two timestamps"	]
[ "timestamp",	">",	"pattern timestamp.>(v:timestamp,w:timestamp):bit ",	"CMDvarGT;",	"Equality of two timestamps"	]
[ "timestamp",	">=",	"pattern timestamp.>=(v:timestamp,w:timestamp):bit ",	"CMDvarGE;",	"Equality of two timestamps"	]
[ "timestamp",	"epoch",	"command timestamp.epoch():timestamp ",	"MTIMEcurrent_timestamp;",	"unix-time (epoch) support: seconds since the Unix epoch"	]
[ "timestamp",	"epoch",	"command timestamp.epoch(t:timestamp):int ",	"MTIMEepoch2int;",	"unix-time (epoch) support: seconds since epoch"	]
[ "timestamp",	"epoch",	"command timestamp.epoch(t:int):timestamp ",	"MTIMEtimestamp;",	"convert seconds since epoch into a timestamp"	]
[ "timestamp",	"epoch",	"command timestamp.epoch(t:lng):timestamp ",	"MTIMEtimestamplng;",	"convert milli seconds since epoch into a timestamp"	]
[ "timestamp",	"isnil",	"pattern timestamp.isnil(v:timestamp):bit ",	"CMDvarISNIL;",	"Nil test for timestamp value"	]
[ "timestamp",	"unix_epoch",	"command timestamp.unix_epoch():timestamp ",	"MTIMEunix_epoch;",	"The Unix epoch time (00:00:00 UTC on January 1, 1970)"	]
[ "timezone",	"#fromstr",	"command timezone.#fromstr():void ",	"tzone_fromstr;",	""	]
[ "timezone",	"#tostr",	"command timezone.#tostr():void ",	"tzone_tostr;",	""	]
[ "timezone",	"str",	"command timezone.str(z:timezone):str ",	"MTIMEtzone_tostr;",	""	]
[ "timezone",	"timestamp",	"command timezone.timestamp(secs:int):timestamp ",	"MTIMEtimestamp;",	"Utility function to create a timestamp from a number of seconds since the Unix epoch"	]
[ "timezone",	"timestamp",	"command timezone.timestamp(s:str):timestamp ",	"MTIMEtimestamp_fromstr;",	""	]
[ "tokenizer",	"append",	"command tokenizer.append(u:str):oid ",	"TKNZRappend;",	"tokenize a new string and append it to the tokenizer (duplicate elimination is performed)"	]
[ "tokenizer",	"close",	"command tokenizer.close():void ",	"TKNZRclose;",	"close the current tokenizer store"	]
[ "tokenizer",	"depositFile",	"command tokenizer.depositFile(fnme:str):void ",	"TKNZRdepositFile;",	"batch insertion from a file of strings to tokenize, each string is separated by a new line"	]
[ "tokenizer",	"getCardinality",	"command tokenizer.getCardinality():bat[:lng] ",	"TKNZRgetCardinality;",	"debugging function that returns the unique tokens at each level"	]
[ "tokenizer",	"getCount",	"command tokenizer.getCount():bat[:lng] ",	"TKNZRgetCount;",	"debugging function that returns the size of the bats at each level"	]
[ "tokenizer",	"getIndex",	"command tokenizer.getIndex():bat[:oid] ",	"TKNZRgetIndex;",	"administrative function that returns the INDEX bat"	]
[ "tokenizer",	"getLevel",	"command tokenizer.getLevel(i:int):bat[:str] ",	"TKNZRgetLevel;",	"administrative function that returns the bat on level i"	]
[ "tokenizer",	"locate",	"pattern tokenizer.locate(s:str):oid ",	"TKNZRlocate;",	"if the given string is in the store returns its oid, otherwise oid_nil"	]
[ "tokenizer",	"open",	"command tokenizer.open(name:str):void ",	"TKNZRopen;",	"open the named tokenizer store, a new one is created if the specified name does not exist"	]
[ "tokenizer",	"take",	"pattern tokenizer.take(i:oid):str ",	"TKNZRtakeOid;",	"reconstruct and returns the i-th string"	]
[ "txtsim",	"editdistance",	"command txtsim.editdistance(s:str,t:str):int ",	"levenshteinbasic_impl;",	"Alias for Levenshtein(str,str)"	]
[ "txtsim",	"editdistance2",	"command txtsim.editdistance2(s:str,t:str):int ",	"levenshteinbasic2_impl;",	"Calculates Levenshtein distance (edit distance) between two strings. Cost of transposition is 1 instead of 2"	]
[ "txtsim",	"levenshtein",	"command txtsim.levenshtein(s:str,t:str,insdel_cost:int,replace_cost:int,transpose_cost:int):int ",	"levenshtein_impl;",	"Calculates Levenshtein distance (edit distance) between two strings, variable operation costs (ins/del, replacement, transposition)"	]
[ "txtsim",	"levenshtein",	"command txtsim.levenshtein(s:str,t:str):int ",	"levenshteinbasic_impl;",	"Calculates Levenshtein distance (edit distance) between two strings"	]
[ "txtsim",	"qgramnormalize",	"command txtsim.qgramnormalize(input:str):str ",	"CMDqgramnormalize;",	"'Normalizes' strings (eg. toUpper and replaces non-alphanumerics with one space"	]
[ "txtsim",	"qgramselfjoin",	"command txtsim.qgramselfjoin(qgram:bat[:oid],id:bat[:oid],pos:bat[:int],len:bat[:int],c:flt,k:int) (X_0:bat[:int],X_1:bat[:int]) ",	"CMDqgramselfjoin;",	"QGram self-join on ordered(!) qgram tables and sub-ordered q-gram positions"	]
[ "txtsim",	"similarity",	"command txtsim.similarity(string1:str,string2:str):dbl ",	"fstrcmp0_impl;",	"Normalized edit distance between two strings"	]
[ "txtsim",	"similarity",	"command txtsim.similarity(string1:str,string2:str,minimum:dbl):dbl ",	"fstrcmp_impl;",	"Normalized edit distance between two strings"	]
[ "txtsim",	"soundex",	"command txtsim.soundex(name:str):str ",	"soundex_impl;",	"Soundex function for phonetic matching"	]
[ "txtsim",	"str2qgrams",	"command txtsim.str2qgrams(s:str):bat[:str] ",	"CMDstr2qgrams;",	"Break the string into 4-grams"	]
[ "txtsim",	"stringdiff",	"command txtsim.stringdiff(s1:str,s2:str):int ",	"stringdiff_impl;",	"calculate the soundexed editdistance"	]
[ "udf",	"fuse",	"command udf.fuse(one:bte,two:bte):sht ",	"UDFfuse_bte_sht;",	"fuse two (1-byte) bte values into one (2-byte) sht value"	]
[ "udf",	"fuse",	"command udf.fuse(one:int,two:int):lng ",	"UDFfuse_int_lng;",	"fuse two (4-byte) int values into one (8-byte) lng value"	]
[ "udf",	"fuse",	"command udf.fuse(one:lng,two:lng):hge ",	"UDFfuse_lng_hge;",	"fuse two (8-byte) lng values into one (16-byte) hge value"	]
[ "udf",	"fuse",	"command udf.fuse(one:sht,two:sht):int ",	"UDFfuse_sht_int;",	"fuse two (2-byte) sht values into one (4-byte) int value"	]
[ "udf",	"reverse",	"command udf.reverse(ra1:str):str ",	"UDFreverse;",	"Reverse a string"	]
[ "url",	"#fromstr",	"command url.#fromstr():void ",	"URLfromString;",	"Convert a string to an url. "	]
[ "url",	"#tostr",	"command url.#tostr():void ",	"URLtoString;",	"Convert url to string equivalent"	]
[ "url",	"getAnchor",	"command url.getAnchor(u:url):str ",	"URLgetAnchor;",	"Extract the URL anchor (reference)"	]
[ "url",	"getBasename",	"command url.getBasename(u:url):str ",	"URLgetBasename;",	"Extract the URL base file name"	]
[ "url",	"getContent",	"command url.getContent(u:url):str ",	"URLgetContent;",	"Get the URL resource in a local file"	]
[ "url",	"getContext",	"command url.getContext(u:url):str ",	"URLgetContext;",	"Get the path context of a URL"	]
[ "url",	"getDomain",	"command url.getDomain(u:url):str ",	"URLgetDomain;",	"Extract Internet domain from the URL"	]
[ "url",	"getExtension",	"command url.getExtension(u:url):str ",	"URLgetExtension;",	"Extract the file extension of the URL"	]
[ "url",	"getFile",	"command url.getFile(u:url):str ",	"URLgetFile;",	"Extract the last file name of the URL"	]
[ "url",	"getHost",	"command url.getHost(u:url):str ",	"URLgetHost;",	"Extract the server name from the URL"	]
[ "url",	"getPort",	"command url.getPort(u:url):str ",	"URLgetPort;",	"Extract the port id from the URL"	]
[ "url",	"getProtocol",	"command url.getProtocol(u:url):str ",	"URLgetProtocol;",	"Extract the protocol from the URL"	]
[ "url",	"getQuery",	"command url.getQuery(u:url):str ",	"URLgetQuery;",	"Extract the query string from the URL"	]
[ "url",	"getRobotURL",	"command url.getRobotURL(u:url):str ",	"URLgetRobotURL;",	"Extract the location of the robot control file"	]
[ "url",	"getUser",	"command url.getUser(u:url):str ",	"URLgetUser;",	"Extract the user identity from the URL"	]
[ "url",	"isaURL",	"command url.isaURL(u:url):bit ",	"URLisaURL;",	"Check conformity of the URL syntax"	]
[ "url",	"new",	"command url.new(prot:str,host:str,fnme:str):url ",	"URLnew3;",	"Construct URL from protocol, host,and file"	]
[ "url",	"new",	"command url.new(p:str,h:str,prt:int,f:str):url ",	"URLnew4;",	"Construct URL from protocol, host, port, and file"	]
[ "url",	"url",	"command url.url(s:str):url ",	"URLnew;",	"Create an URL from a string literal"	]
[ "url",	"url",	"command url.url(s:url):url ",	"URLnoop;",	"Create an URL from a string literal"	]
[ "user",	"main",	"function user.main():void;",	"",	""	]
[ "user",	"main",	"function user.main():void;",	"",	""	]
[ "user",	"main",	"function user.main():void;",	"",	""	]
[ "user",	"main",	"function user.main():void;",	"",	""	]
[ "user",	"s2_1",	"function user.s2_1():void;",	"",	""	]
[ "uuid",	"#cmp",	"command uuid.#cmp():void ",	"UUIDcompare;",	""	]
[ "uuid",	"#fromstr",	"command uuid.#fromstr():void ",	"UUIDfromString;",	""	]
[ "uuid",	"#hash",	"command uuid.#hash():void ",	"UUIDhash;",	""	]
[ "uuid",	"#null",	"command uuid.#null():void ",	"UUIDnull;",	""	]
[ "uuid",	"#read",	"command uuid.#read():void ",	"UUIDread;",	""	]
[ "uuid",	"#tostr",	"command uuid.#tostr():void ",	"UUIDtoString;",	""	]
[ "uuid",	"#write",	"command uuid.#write():void ",	"UUIDwrite;",	""	]
[ "uuid",	"isaUUID",	"command uuid.isaUUID(u:str):bit ",	"UUIDisaUUID;",	"Test a string for a UUID format"	]
[ "uuid",	"new",	"command uuid.new():uuid ",	"UUIDgenerateUuid;",	"Generate a new uuid"	]
[ "uuid",	"prelude",	"command uuid.prelude():void ",	"UUIDprelude;",	""	]
[ "uuid",	"str",	"command uuid.str(u:uuid):str ",	"UUIDuuid2str;",	"Coerce a uuid to its string type"	]
[ "uuid",	"uuid",	"command uuid.uuid(s:str):uuid ",	"UUIDstr2uuid;",	"Coerce a string to a uuid, validating its format"	]
[ "wkb",	"#cmp",	"command wkb.#cmp():void ",	"wkbCOMP;",	""	]
[ "wkb",	"#del",	"command wkb.#del():void ",	"wkbDEL;",	""	]
[ "wkb",	"#fromstr",	"command wkb.#fromstr():void ",	"wkbFROMSTR;",	""	]
[ "wkb",	"#hash",	"command wkb.#hash():void ",	"wkbHASH;",	""	]
[ "wkb",	"#heap",	"command wkb.#heap():void ",	"wkbHEAP;",	""	]
[ "wkb",	"#length",	"command wkb.#length():void ",	"wkbLENGTH;",	""	]
[ "wkb",	"#null",	"command wkb.#null():void ",	"wkbNULL;",	""	]
[ "wkb",	"#put",	"command wkb.#put():void ",	"wkbPUT;",	""	]
[ "wkb",	"#read",	"command wkb.#read():void ",	"wkbREAD;",	""	]
[ "wkb",	"#tostr",	"command wkb.#tostr():void ",	"wkbTOSTR;",	""	]
[ "wkb",	"#write",	"command wkb.#write():void ",	"wkbWRITE;",	""	]
[ "wkba",	"#cmp",	"command wkba.#cmp():void ",	"wkbaCOMP;",	""	]
[ "wkba",	"#del",	"command wkba.#del():void ",	"wkbaDEL;",	""	]
[ "wkba",	"#fromstr",	"command wkba.#fromstr():void ",	"wkbaFROMSTR;",	""	]
[ "wkba",	"#hash",	"command wkba.#hash():void ",	"wkbaHASH;",	""	]
[ "wkba",	"#heap",	"command wkba.#heap():void ",	"wkbaHEAP;",	""	]
[ "wkba",	"#length",	"command wkba.#length():void ",	"wkbaLENGTH;",	""	]
[ "wkba",	"#null",	"command wkba.#null():void ",	"wkbaNULL;",	""	]
[ "wkba",	"#put",	"command wkba.#put():void ",	"wkbaPUT;",	""	]
[ "wkba",	"#read",	"command wkba.#read():void ",	"wkbaREAD;",	""	]
[ "wkba",	"#tostr",	"command wkba.#tostr():void ",	"wkbaTOSTR;",	""	]
[ "wkba",	"#write",	"command wkba.#write():void ",	"wkbaWRITE;",	""	]
[ "xml",	"#fromstr",	"command xml.#fromstr():void ",	"XMLfromString;",	"Convert a string to an xml."	]
[ "xml",	"#tostr",	"command xml.#tostr():void ",	"XMLtoString;",	"Convert xml to string equivalent"	]
[ "xml",	"aggr",	"command xml.aggr(val:bat[:xml]):xml ",	"BATXMLgroup;",	"Aggregate the XML values."	]
[ "xml",	"attribute",	"command xml.attribute(name:str,val:str):xml ",	"XMLattribute;",	"Construct an attribute value pair"	]
[ "xml",	"comment",	"command xml.comment(val:str):xml ",	"XMLcomment;",	"Construct an comment struction "	]
[ "xml",	"concat",	"command xml.concat(val1:xml,val2:xml):xml ",	"XMLconcat;",	"Concatenate the xml values"	]
[ "xml",	"content",	"command xml.content(val:str):xml ",	"XMLcontent;",	"Check the value for compliance as content, i.e.  it may contain multiple roots and character data."	]
[ "xml",	"document",	"command xml.document(val:str):xml ",	"XMLdocument;",	"Check the value for compliance as XML document"	]
[ "xml",	"element",	"command xml.element(name:str,ns:xml,attr:xml,s:xml):xml ",	"XMLelement;",	"The basic building block for XML elements are namespaces, attributes and a sequence of xml elements. The name space and the attributes may be left unspecified(=nil:bat)."	]
[ "xml",	"element",	"command xml.element(name:str,s:xml):xml ",	"XMLelementSmall;",	"The basic building block for XML elements are namespaces, attributes and a sequence of xml elements. The name space and the attributes may be left unspecified(=nil:bat)."	]
[ "xml",	"forest",	"pattern xml.forest(val:xml...):xml ",	"XMLforest;",	"Construct an element list"	]
[ "xml",	"isdocument",	"command xml.isdocument(val:str):bit ",	"XMLisdocument;",	"Validate the string as a document"	]
[ "xml",	"parse",	"command xml.parse(doccont:str,val:str,option:str):xml ",	"XMLparse;",	"Parse the XML document or element string values "	]
[ "xml",	"pi",	"command xml.pi(target:str,val:str):xml ",	"XMLpi;",	"Construct a processing instruction"	]
[ "xml",	"prelude",	"command xml.prelude():void ",	"XMLprelude;",	""	]
[ "xml",	"root",	"command xml.root(val:xml,version:str,standalone:str):xml ",	"XMLroot;",	"Construct the root nodes"	]
[ "xml",	"str",	"command xml.str(src:xml):str ",	"XMLxml2str;",	"Cast the string to an xml compliant string"	]
[ "xml",	"subaggr",	"command xml.subaggr(val:bat[:xml],g:bat[:oid],e:bat[:any_1],skip_nils:bit):bat[:xml] ",	"AGGRsubxml;",	"Grouped aggregation of XML values."	]
[ "xml",	"subaggr",	"command xml.subaggr(val:bat[:xml],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit):bat[:xml] ",	"AGGRsubxmlcand;",	"Grouped aggregation of XML values with candidates list."	]
[ "xml",	"text",	"command xml.text(src:xml):str ",	"XMLxmltext;",	"Extract text from an xml atom"	]
[ "xml",	"xml",	"command xml.xml(src:str):xml ",	"XMLstr2xml;",	"Cast the string to an xml compliant string"	]
[ "zrule",	"#fromstr",	"command zrule.#fromstr():void ",	"rule_fromstr;",	""	]
[ "zrule",	"#tostr",	"command zrule.#tostr():void ",	"rule_tostr;",	""	]
[ "zrule",	"define",	"command zrule.define(m:int,d:int,w:int,h:int,min:int):zrule ",	"MTIMEruleDef0;",	"Introduce a synomym timezone rule."	]
[ "zrule",	"define",	"command zrule.define(m:int,d:str,w:int,h:int,min:int):zrule ",	"MTIMEruleDef1;",	"Introduce a synomym timezone rule."	]
[ "zrule",	"define",	"command zrule.define(m:int,d:str,w:int,min:int):zrule ",	"MTIMEruleDef2;",	"Introduce a synomym timezone rule."	]

# 12:57:40 >  
# 12:57:40 >  "Done."
# 12:57:40 >  

