hash-threshold 100000
query TTTTT nosort
select * from sys.malfunctions() order by module, "function", address, signature, comment
----
aggr
all
command aggr.all(X_0:bat[:any_1]):any_1 
SQLall;
if all values in b are equal return this, else nil
aggr
allnotequal
pattern aggr.allnotequal(X_0:bat[:any_1], X_1:bat[:any_1]):bit 
SQLallnotequal;
if all values in r are not equal to l return true, else if r has nil nil else false
aggr
anyequal
pattern aggr.anyequal(X_0:any_1, X_1:any_1):bit 
CMDvarEQ;
(empty)
aggr
anyequal
pattern aggr.anyequal(X_0:bat[:any_1], X_1:bat[:any_1]):bit 
SQLanyequal;
if any value in r is equal to l return true, else if r has nil nil else false
aggr
avg
command aggr.avg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRavg13_dbl;
Grouped tail average on bte
aggr
avg
command aggr.avg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRavg13_dbl;
Grouped tail average on dbl
aggr
avg
command aggr.avg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRavg13_dbl;
Grouped tail average on flt
aggr
avg
command aggr.avg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRavg13_dbl;
Grouped tail average on int
aggr
avg
command aggr.avg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRavg13_dbl;
Grouped tail average on lng
aggr
avg
command aggr.avg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRavg13_dbl;
Grouped tail average on sht
aggr
avg
command aggr.avg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:int):bat[:dbl] 
AGGRavg14_dbl;
Grouped tail average on bte
aggr
avg
command aggr.avg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:int):bat[:dbl] 
AGGRavg14_dbl;
Grouped tail average on dbl
aggr
avg
command aggr.avg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:int):bat[:dbl] 
AGGRavg14_dbl;
Grouped tail average on flt
aggr
avg
command aggr.avg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:int):bat[:dbl] 
AGGRavg14_dbl;
Grouped tail average on int
aggr
avg
command aggr.avg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:int):bat[:dbl] 
AGGRavg14_dbl;
Grouped tail average on lng
aggr
avg
command aggr.avg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:int):bat[:dbl] 
AGGRavg14_dbl;
Grouped tail average on sht
aggr
avg
command aggr.avg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]) (X_3:bat[:dbl], X_4:bat[:lng]) 
AGGRavg23_dbl;
Grouped tail average on bte, also returns count
aggr
avg
command aggr.avg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1]) (X_3:bat[:dbl], X_4:bat[:lng]) 
AGGRavg23_dbl;
Grouped tail average on dbl, also returns count
aggr
avg
command aggr.avg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1]) (X_3:bat[:dbl], X_4:bat[:lng]) 
AGGRavg23_dbl;
Grouped tail average on flt, also returns count
aggr
avg
command aggr.avg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]) (X_3:bat[:dbl], X_4:bat[:lng]) 
AGGRavg23_dbl;
Grouped tail average on int, also returns count
aggr
avg
command aggr.avg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1]) (X_3:bat[:dbl], X_4:bat[:lng]) 
AGGRavg23_dbl;
Grouped tail average on lng, also returns count
aggr
avg
command aggr.avg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]) (X_3:bat[:dbl], X_4:bat[:lng]) 
AGGRavg23_dbl;
Grouped tail average on sht, also returns count
aggr
avg
command aggr.avg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:int) (X_4:bat[:dbl], X_5:bat[:lng]) 
AGGRavg24_dbl;
Grouped tail average on bte, also returns count
aggr
avg
command aggr.avg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:int) (X_4:bat[:dbl], X_5:bat[:lng]) 
AGGRavg24_dbl;
Grouped tail average on dbl, also returns count
aggr
avg
command aggr.avg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:int) (X_4:bat[:dbl], X_5:bat[:lng]) 
AGGRavg24_dbl;
Grouped tail average on flt, also returns count
aggr
avg
command aggr.avg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:int) (X_4:bat[:dbl], X_5:bat[:lng]) 
AGGRavg24_dbl;
Grouped tail average on int, also returns count
aggr
avg
command aggr.avg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:int) (X_4:bat[:dbl], X_5:bat[:lng]) 
AGGRavg24_dbl;
Grouped tail average on lng, also returns count
aggr
avg
command aggr.avg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:int) (X_4:bat[:dbl], X_5:bat[:lng]) 
AGGRavg24_dbl;
Grouped tail average on sht, also returns count
aggr
avg
pattern aggr.avg(X_0:bat[:bte], X_1:bat[:oid], X_2:bit) (X_3:bte, X_4:lng, X_5:lng) 
CMDBATavg3;
Calculate aggregate average of B.
aggr
avg
pattern aggr.avg(X_0:bat[:int], X_1:bat[:oid], X_2:bit) (X_3:int, X_4:lng, X_5:lng) 
CMDBATavg3;
Calculate aggregate average of B.
aggr
avg
pattern aggr.avg(X_0:bat[:lng], X_1:bat[:oid], X_2:bit) (X_3:lng, X_4:lng, X_5:lng) 
CMDBATavg3;
Calculate aggregate average of B.
aggr
avg
pattern aggr.avg(X_0:bat[:sht], X_1:bat[:oid], X_2:bit) (X_3:sht, X_4:lng, X_5:lng) 
CMDBATavg3;
Calculate aggregate average of B.
aggr
avg
pattern aggr.avg(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:lng]):bte 
CMDBATavg3comb;
Average aggregation combiner.
aggr
avg
pattern aggr.avg(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:lng]):int 
CMDBATavg3comb;
Average aggregation combiner.
aggr
avg
pattern aggr.avg(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:lng]):lng 
CMDBATavg3comb;
Average aggregation combiner.
aggr
avg
pattern aggr.avg(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:lng]):sht 
CMDBATavg3comb;
Average aggregation combiner.
aggr
avg
pattern aggr.avg(X_0:bat[:any_2]):dbl 
CMDcalcavg;
Gives the avg of all tail values
aggr
avg
pattern aggr.avg(X_0:bat[:any_2], X_1:int):dbl 
CMDcalcavg;
Gives the avg of all tail values
aggr
cardinality
command aggr.cardinality(X_0:bat[:any_2]):lng 
ALGcard;
Return the cardinality of the BAT tail values.
aggr
corr
command aggr.corr(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcorr;
Correlation aggregate
aggr
corr
command aggr.corr(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcorr;
Correlation aggregate
aggr
corr
command aggr.corr(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcorr;
Correlation aggregate
aggr
corr
command aggr.corr(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcorr;
Correlation aggregate
aggr
corr
command aggr.corr(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcorr;
Correlation aggregate
aggr
corr
command aggr.corr(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcorr;
Correlation aggregate
aggr
corr
command aggr.corr(X_0:bat[:any_2], X_1:bat[:any_2]):dbl 
ALGcorr;
Gives the correlation of all tail values
aggr
count
command aggr.count(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bit):bat[:lng] 
AGGRcount3;
(empty)
aggr
count
command aggr.count(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2]):bat[:lng] 
AGGRcount3nils;
Grouped count
aggr
count
command aggr.count(X_0:bat[:any], X_1:bat[:oid]):lng 
ALGcountCND_bat;
Return the current size (in number of elements) in a BAT.
aggr
count
command aggr.count(X_0:bat[:any], X_1:bat[:oid], X_2:bit):lng 
ALGcountCND_nil;
Return the number of elements currently in a BAT ignores@BUNs with nil-tail iff ignore_nils==TRUE.
aggr
count
command aggr.count(X_0:bat[:any]):lng 
ALGcount_bat;
Return the current size (in number of elements) in a BAT.
aggr
count
command aggr.count(X_0:bat[:any], X_1:bit):lng 
ALGcount_nil;
Return the number of elements currently in a BAT ignores@BUNs with nil-tail iff ignore_nils==TRUE.
aggr
count_no_nil
command aggr.count_no_nil(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2]):bat[:lng] 
AGGRcount3nonils;
(empty)
aggr
count_no_nil
command aggr.count_no_nil(X_0:bat[:any_2], X_1:bat[:oid]):lng 
ALGcountCND_no_nil;
Return the number of elements currently@in a BAT ignoring BUNs with nil-tail
aggr
count_no_nil
command aggr.count_no_nil(X_0:bat[:any_2]):lng 
ALGcount_no_nil;
Return the number of elements currently@in a BAT ignoring BUNs with nil-tail
aggr
covariance
command aggr.covariance(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariance;
Covariance sample aggregate
aggr
covariance
command aggr.covariance(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariance;
Covariance sample aggregate
aggr
covariance
command aggr.covariance(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariance;
Covariance sample aggregate
aggr
covariance
command aggr.covariance(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariance;
Covariance sample aggregate
aggr
covariance
command aggr.covariance(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariance;
Covariance sample aggregate
aggr
covariance
command aggr.covariance(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariance;
Covariance sample aggregate
aggr
covariance
command aggr.covariance(X_0:bat[:any_2], X_1:bat[:any_2]):dbl 
ALGcovariance;
Gives the covariance of all tail values
aggr
covariancep
command aggr.covariancep(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariancep;
Covariance population aggregate
aggr
covariancep
command aggr.covariancep(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariancep;
Covariance population aggregate
aggr
covariancep
command aggr.covariancep(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariancep;
Covariance population aggregate
aggr
covariancep
command aggr.covariancep(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariancep;
Covariance population aggregate
aggr
covariancep
command aggr.covariancep(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariancep;
Covariance population aggregate
aggr
covariancep
command aggr.covariancep(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:any_1]):bat[:dbl] 
AGGRcovariancep;
Covariance population aggregate
aggr
covariancep
command aggr.covariancep(X_0:bat[:any_2], X_1:bat[:any_2]):dbl 
ALGcovariancep;
Gives the covariance of all tail values
aggr
exist
command aggr.exist(X_0:bat[:any_2], X_1:any_1):bit 
ALGexist;
(empty)
aggr
exist
pattern aggr.exist(X_0:any_1):bit 
SQLexist;
(empty)
aggr
jsonaggr
command aggr.jsonaggr(X_0:bat[:dbl]):str 
JSONgroupStr;
Aggregate the double values to array.
aggr
jsonaggr
command aggr.jsonaggr(X_0:bat[:str]):str 
JSONgroupStr;
Aggregate the string values to array.
aggr
max
command aggr.max(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2]):bat[:any_1] 
AGGRmax3;
(empty)
aggr
max
command aggr.max(X_0:bat[:any_2]):any_2 
ALGmaxany;
Return the highest tail value or nil.
aggr
max
command aggr.max(X_0:bat[:any_2], X_1:bit):any_2 
ALGmaxany_skipnil;
Return the highest tail value or nil.
aggr
median
command aggr.median(X_0:bat[:any_1]):any_1 
AGGRmedian;
Median aggregate
aggr
median_avg
command aggr.median_avg(X_0:bat[:any_1]):dbl 
AGGRmedian_avg;
Median aggregate
aggr
min
command aggr.min(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2]):bat[:any_1] 
AGGRmin3;
(empty)
aggr
min
command aggr.min(X_0:bat[:any_2]):any_2 
ALGminany;
Return the lowest tail value or nil.
aggr
min
command aggr.min(X_0:bat[:any_2], X_1:bit):any_2 
ALGminany_skipnil;
Return the lowest tail value or nil.
aggr
not_anyequal
pattern aggr.not_anyequal(X_0:any_1, X_1:any_1):bit 
CMDvarNE;
(empty)
aggr
not_exist
pattern aggr.not_exist(X_0:any_1):bit 
SQLnot_exist;
(empty)
aggr
not_unique
command aggr.not_unique(X_0:bat[:oid]):bit 
not_unique;
check if the tail sorted bat b doesn't have unique tail values
aggr
null
command aggr.null(X_0:bat[:any_1]):bit 
SQLnil;
if b has a nil return true, else false
aggr
prod
command aggr.prod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:bte] 
AGGRprod3_bte;
Grouped tail product on bte
aggr
prod
command aggr.prod(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRprod3_dbl;
Grouped tail product on dbl
aggr
prod
command aggr.prod(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRprod3_dbl;
Grouped tail product on flt
aggr
prod
command aggr.prod(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1]):bat[:flt] 
AGGRprod3_flt;
Grouped tail product on flt
aggr
prod
command aggr.prod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:int] 
AGGRprod3_int;
Grouped tail product on bte
aggr
prod
command aggr.prod(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]):bat[:int] 
AGGRprod3_int;
Grouped tail product on int
aggr
prod
command aggr.prod(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:int] 
AGGRprod3_int;
Grouped tail product on sht
aggr
prod
command aggr.prod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:lng] 
AGGRprod3_lng;
Grouped tail product on bte
aggr
prod
command aggr.prod(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]):bat[:lng] 
AGGRprod3_lng;
Grouped tail product on int
aggr
prod
command aggr.prod(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1]):bat[:lng] 
AGGRprod3_lng;
Grouped tail product on lng
aggr
prod
command aggr.prod(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:lng] 
AGGRprod3_lng;
Grouped tail product on sht
aggr
prod
command aggr.prod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:sht] 
AGGRprod3_sht;
Grouped tail product on bte
aggr
prod
command aggr.prod(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:sht] 
AGGRprod3_sht;
Grouped tail product on sht
aggr
prod
pattern aggr.prod(X_0:bat[:bte]):bte 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:bte]):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:bte]):int 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:bte]):lng 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:bte]):sht 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bat[:oid]):bte 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bat[:oid]):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bat[:oid]):int 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bat[:oid]):lng 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bat[:oid]):sht 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bat[:oid], X_2:bit):bte 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bat[:oid], X_2:bit):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bat[:oid], X_2:bit):int 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bat[:oid], X_2:bit):lng 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bat[:oid], X_2:bit):sht 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bit):bte 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bit):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bit):int 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bit):lng 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:bte], X_1:bit):sht 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:dbl]):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:dbl], X_1:bat[:oid]):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:dbl], X_1:bat[:oid], X_2:bit):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:dbl], X_1:bit):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:flt]):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:flt]):flt 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:flt], X_1:bat[:oid]):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:flt], X_1:bat[:oid]):flt 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:flt], X_1:bat[:oid], X_2:bit):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:flt], X_1:bat[:oid], X_2:bit):flt 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:flt], X_1:bit):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:flt], X_1:bit):flt 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:int]):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:int]):int 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:int]):lng 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:int], X_1:bat[:oid]):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:int], X_1:bat[:oid]):int 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:int], X_1:bat[:oid]):lng 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:int], X_1:bat[:oid], X_2:bit):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:int], X_1:bat[:oid], X_2:bit):int 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:int], X_1:bat[:oid], X_2:bit):lng 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:int], X_1:bit):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:int], X_1:bit):int 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:int], X_1:bit):lng 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:lng]):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:lng]):lng 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:lng], X_1:bat[:oid]):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:lng], X_1:bat[:oid]):lng 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:lng], X_1:bat[:oid], X_2:bit):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:lng], X_1:bat[:oid], X_2:bit):lng 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:lng], X_1:bit):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:lng], X_1:bit):lng 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:sht]):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:sht]):int 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:sht]):lng 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:sht]):sht 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bat[:oid]):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bat[:oid]):int 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bat[:oid]):lng 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bat[:oid]):sht 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bat[:oid], X_2:bit):dbl 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bat[:oid], X_2:bit):int 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bat[:oid], X_2:bit):lng 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bat[:oid], X_2:bit):sht 
CMDBATprod;
Calculate aggregate product of B with candidate list.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bit):dbl 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bit):int 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bit):lng 
CMDBATprod;
Calculate aggregate product of B.
aggr
prod
pattern aggr.prod(X_0:bat[:sht], X_1:bit):sht 
CMDBATprod;
Calculate aggregate product of B.
aggr
quantile
command aggr.quantile(X_0:bat[:any_1], X_1:bat[:dbl]):any_1 
AGGRquantile;
Quantile aggregate
aggr
quantile_avg
command aggr.quantile_avg(X_0:bat[:any_1], X_1:bat[:dbl]):dbl 
AGGRquantile_avg;
Quantile aggregate
aggr
stdev
command aggr.stdev(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdev3_dbl;
Grouped tail standard deviation (sample/non-biased) on bte
aggr
stdev
command aggr.stdev(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdev3_dbl;
Grouped tail standard deviation (sample/non-biased) on dbl
aggr
stdev
command aggr.stdev(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdev3_dbl;
Grouped tail standard deviation (sample/non-biased) on flt
aggr
stdev
command aggr.stdev(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdev3_dbl;
Grouped tail standard deviation (sample/non-biased) on int
aggr
stdev
command aggr.stdev(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdev3_dbl;
Grouped tail standard deviation (sample/non-biased) on lng
aggr
stdev
command aggr.stdev(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdev3_dbl;
Grouped tail standard deviation (sample/non-biased) on sht
aggr
stdev
command aggr.stdev(X_0:bat[:any_2]):dbl 
ALGstdev;
Gives the standard deviation of all tail values
aggr
stdevp
command aggr.stdevp(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdevp3_dbl;
Grouped tail standard deviation (population/biased) on bte
aggr
stdevp
command aggr.stdevp(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdevp3_dbl;
Grouped tail standard deviation (population/biased) on dbl
aggr
stdevp
command aggr.stdevp(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdevp3_dbl;
Grouped tail standard deviation (population/biased) on flt
aggr
stdevp
command aggr.stdevp(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdevp3_dbl;
Grouped tail standard deviation (population/biased) on int
aggr
stdevp
command aggr.stdevp(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdevp3_dbl;
Grouped tail standard deviation (population/biased) on lng
aggr
stdevp
command aggr.stdevp(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRstdevp3_dbl;
Grouped tail standard deviation (population/biased) on sht
aggr
stdevp
command aggr.stdevp(X_0:bat[:any_2]):dbl 
ALGstdevp;
Gives the standard deviation of all tail values
aggr
str_group_concat
command aggr.str_group_concat(X_0:bat[:str], X_1:bat[:oid], X_2:bat[:any_1]):bat[:str] 
AGGRstr_group_concat;
Grouped string tail concat
aggr
str_group_concat
command aggr.str_group_concat(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:any_1]):bat[:str] 
AGGRstr_group_concat_sep;
Grouped string tail concat with custom separator
aggr
str_group_concat
pattern aggr.str_group_concat(X_0:bat[:str]):str 
CMDBATstr_group_concat;
Calculate aggregate string concatenate of B.
aggr
str_group_concat
pattern aggr.str_group_concat(X_0:bat[:str], X_1:bat[:oid]):str 
CMDBATstr_group_concat;
Calculate aggregate string concatenate of B with candidate list.
aggr
str_group_concat
pattern aggr.str_group_concat(X_0:bat[:str], X_1:bat[:oid], X_2:bit):str 
CMDBATstr_group_concat;
Calculate aggregate string concatenate of B with candidate list.
aggr
str_group_concat
pattern aggr.str_group_concat(X_0:bat[:str], X_1:bat[:str]):str 
CMDBATstr_group_concat;
Calculate aggregate string concatenate of B with separator SEP.
aggr
str_group_concat
pattern aggr.str_group_concat(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid]):str 
CMDBATstr_group_concat;
Calculate aggregate string concatenate of B with candidate list and separator SEP.
aggr
str_group_concat
pattern aggr.str_group_concat(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bit):str 
CMDBATstr_group_concat;
Calculate aggregate string concatenate of B with candidate list and separator SEP.
aggr
str_group_concat
pattern aggr.str_group_concat(X_0:bat[:str], X_1:bat[:str], X_2:bit):str 
CMDBATstr_group_concat;
Calculate aggregate string concatenate of B with separator SEP.
aggr
str_group_concat
pattern aggr.str_group_concat(X_0:bat[:str], X_1:bit):str 
CMDBATstr_group_concat;
Calculate aggregate string concatenate of B.
aggr
suball
pattern aggr.suball(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:any_1] 
SQLall_grp;
if all values in l are equal (per group) return the value, else nil
aggr
suball
pattern aggr.suball(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bit):bat[:any_1] 
SQLall_grp;
if all values in l are equal (per group) return the value, else nil
aggr
suballnotequal
pattern aggr.suballnotequal(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:oid], X_5:bat[:oid], X_6:bit):bat[:bit] 
SQLallnotequal_grp2;
if all values in r are not equal to l return true, else if r has nil nil else false, except if rid is nil (ie empty) then true; with candidate list
aggr
suballnotequal
pattern aggr.suballnotequal(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:oid], X_5:bit):bat[:bit] 
SQLallnotequal_grp2;
if all values in r are not equal to l return true, else if r has nil nil else false, except if rid is nil (ie empty) then true
aggr
suballnotequal
pattern aggr.suballnotequal(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:oid], X_5:bit):bat[:bit] 
SQLallnotequal_grp;
if all values in r are not equal to l return true, else if r has nil nil else false; with candidate list
aggr
suballnotequal
pattern aggr.suballnotequal(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
SQLallnotequal_grp;
if all values in r are not equal to l return true, else if r has nil nil else false
aggr
subanyequal
pattern aggr.subanyequal(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:oid], X_5:bat[:oid], X_6:bit):bat[:bit] 
SQLanyequal_grp2;
if any value in r is equal to l return true, else if r has nil nil else false, except if rid is nil (ie empty) then false; with candidate list
aggr
subanyequal
pattern aggr.subanyequal(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:oid], X_5:bit):bat[:bit] 
SQLanyequal_grp2;
if any value in r is equal to l return true, else if r has nil nil else false, except if rid is nil (ie empty) then false
aggr
subanyequal
pattern aggr.subanyequal(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:oid], X_5:bit):bat[:bit] 
SQLanyequal_grp;
if any value in r is equal to l return true, else if r has nil nil else false; with candidate list
aggr
subanyequal
pattern aggr.subanyequal(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
SQLanyequal_grp;
if any value in r is equal to l return true, else if r has nil nil else false
aggr
subavg
command aggr.subavg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit) (X_5:bat[:bte], X_6:bat[:lng], X_7:bat[:lng]) 
AGGRavg3;
Grouped average aggregation
aggr
subavg
command aggr.subavg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit) (X_5:bat[:int], X_6:bat[:lng], X_7:bat[:lng]) 
AGGRavg3;
Grouped average aggregation
aggr
subavg
command aggr.subavg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit) (X_5:bat[:lng], X_6:bat[:lng], X_7:bat[:lng]) 
AGGRavg3;
Grouped average aggregation
aggr
subavg
command aggr.subavg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit) (X_5:bat[:sht], X_6:bat[:lng], X_7:bat[:lng]) 
AGGRavg3;
Grouped average aggregation
aggr
subavg
command aggr.subavg(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:lng], X_3:bat[:oid], X_4:bat[:any_1], X_5:bit):bat[:bte] 
AGGRavg3comb;
Grouped average aggregation combiner
aggr
subavg
command aggr.subavg(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:lng], X_3:bat[:oid], X_4:bat[:any_1], X_5:bit):bat[:int] 
AGGRavg3comb;
Grouped average aggregation combiner
aggr
subavg
command aggr.subavg(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:lng], X_3:bat[:oid], X_4:bat[:any_1], X_5:bit):bat[:lng] 
AGGRavg3comb;
Grouped average aggregation combiner
aggr
subavg
command aggr.subavg(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:lng], X_3:bat[:oid], X_4:bat[:any_1], X_5:bit):bat[:sht] 
AGGRavg3comb;
Grouped average aggregation combiner
aggr
subavg
command aggr.subavg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubavg1_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubavg1_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubavg1_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubavg1_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubavg1_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubavg1_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubavg1cand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubavg1cand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubavg1cand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubavg1cand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubavg1cand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubavg1cand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int):bat[:dbl] 
AGGRsubavg1s_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int):bat[:dbl] 
AGGRsubavg1s_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int):bat[:dbl] 
AGGRsubavg1s_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int):bat[:dbl] 
AGGRsubavg1s_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int):bat[:dbl] 
AGGRsubavg1s_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int):bat[:dbl] 
AGGRsubavg1s_dbl;
Grouped average aggregate
aggr
subavg
command aggr.subavg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int):bat[:dbl] 
AGGRsubavg1scand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int):bat[:dbl] 
AGGRsubavg1scand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int):bat[:dbl] 
AGGRsubavg1scand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int):bat[:dbl] 
AGGRsubavg1scand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int):bat[:dbl] 
AGGRsubavg1scand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int):bat[:dbl] 
AGGRsubavg1scand_dbl;
Grouped average aggregate with candidates list
aggr
subavg
command aggr.subavg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit) (X_5:bat[:dbl], X_6:bat[:lng]) 
AGGRsubavg2_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit) (X_5:bat[:dbl], X_6:bat[:lng]) 
AGGRsubavg2_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit) (X_5:bat[:dbl], X_6:bat[:lng]) 
AGGRsubavg2_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit) (X_5:bat[:dbl], X_6:bat[:lng]) 
AGGRsubavg2_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit) (X_5:bat[:dbl], X_6:bat[:lng]) 
AGGRsubavg2_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit) (X_5:bat[:dbl], X_6:bat[:lng]) 
AGGRsubavg2_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2cand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2cand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2cand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2cand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2cand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2cand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2s_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2s_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2s_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2s_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2s_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:int) (X_6:bat[:dbl], X_7:bat[:lng]) 
AGGRsubavg2s_dbl;
Grouped average aggregate, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int) (X_7:bat[:dbl], X_8:bat[:lng]) 
AGGRsubavg2scand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int) (X_7:bat[:dbl], X_8:bat[:lng]) 
AGGRsubavg2scand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int) (X_7:bat[:dbl], X_8:bat[:lng]) 
AGGRsubavg2scand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int) (X_7:bat[:dbl], X_8:bat[:lng]) 
AGGRsubavg2scand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int) (X_7:bat[:dbl], X_8:bat[:lng]) 
AGGRsubavg2scand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subavg
command aggr.subavg(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:int) (X_7:bat[:dbl], X_8:bat[:lng]) 
AGGRsubavg2scand_dbl;
Grouped average aggregate with candidates list, also returns count
aggr
subcorr
command aggr.subcorr(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcorr;
Grouped correlation aggregate
aggr
subcorr
command aggr.subcorr(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcorr;
Grouped correlation aggregate
aggr
subcorr
command aggr.subcorr(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcorr;
Grouped correlation aggregate
aggr
subcorr
command aggr.subcorr(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcorr;
Grouped correlation aggregate
aggr
subcorr
command aggr.subcorr(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcorr;
Grouped correlation aggregate
aggr
subcorr
command aggr.subcorr(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcorr;
Grouped correlation aggregate
aggr
subcorr
command aggr.subcorr(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcorrcand;
Grouped correlation aggregate with candidate list
aggr
subcorr
command aggr.subcorr(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcorrcand;
Grouped correlation aggregate with candidate list
aggr
subcorr
command aggr.subcorr(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcorrcand;
Grouped correlation aggregate with candidate list
aggr
subcorr
command aggr.subcorr(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcorrcand;
Grouped correlation aggregate with candidate list
aggr
subcorr
command aggr.subcorr(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcorrcand;
Grouped correlation aggregate with candidate list
aggr
subcorr
command aggr.subcorr(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcorrcand;
Grouped correlation aggregate with candidate list
aggr
subcount
command aggr.subcount(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bit):bat[:lng] 
AGGRsubcount;
Grouped count aggregate
aggr
subcount
command aggr.subcount(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bat[:oid], X_4:bit):bat[:lng] 
AGGRsubcountcand;
Grouped count aggregate with candidates list
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariance;
Grouped covariance sample aggregate
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariance;
Grouped covariance sample aggregate
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariance;
Grouped covariance sample aggregate
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariance;
Grouped covariance sample aggregate
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariance;
Grouped covariance sample aggregate
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariance;
Grouped covariance sample aggregate
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancecand;
Grouped covariance sample aggregate with candidate list
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancecand;
Grouped covariance sample aggregate with candidate list
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancecand;
Grouped covariance sample aggregate with candidate list
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancecand;
Grouped covariance sample aggregate with candidate list
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancecand;
Grouped covariance sample aggregate with candidate list
aggr
subcovariance
command aggr.subcovariance(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancecand;
Grouped covariance sample aggregate with candidate list
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariancep;
Grouped covariance population aggregate
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariancep;
Grouped covariance population aggregate
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariancep;
Grouped covariance population aggregate
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariancep;
Grouped covariance population aggregate
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariancep;
Grouped covariance population aggregate
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubcovariancep;
Grouped covariance population aggregate
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancepcand;
Grouped covariance population aggregate with candidate list
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancepcand;
Grouped covariance population aggregate with candidate list
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancepcand;
Grouped covariance population aggregate with candidate list
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancepcand;
Grouped covariance population aggregate with candidate list
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancepcand;
Grouped covariance population aggregate with candidate list
aggr
subcovariancep
command aggr.subcovariancep(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:dbl] 
AGGRsubcovariancepcand;
Grouped covariance population aggregate with candidate list
aggr
subexist
pattern aggr.subexist(X_0:bat[:any], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
SQLsubexist;
(empty)
aggr
subexist
pattern aggr.subexist(X_0:bat[:any], X_1:bat[:oid], X_2:bat[:oid], X_3:bit):bat[:bit] 
SQLsubexist;
(empty)
aggr
subjsonaggr
command aggr.subjsonaggr(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit):bat[:str] 
JSONsubjson;
Grouped aggregation of values.
aggr
subjsonaggr
command aggr.subjsonaggr(X_0:bat[:str], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit):bat[:str] 
JSONsubjson;
Grouped aggregation of values.
aggr
subjsonaggr
command aggr.subjsonaggr(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit):bat[:str] 
JSONsubjsoncand;
Grouped aggregation of values with candidates list.
aggr
subjsonaggr
command aggr.subjsonaggr(X_0:bat[:str], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit):bat[:str] 
JSONsubjsoncand;
Grouped aggregation of values with candidates list.
aggr
submax
command aggr.submax(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bit):bat[:oid] 
AGGRsubmax;
Grouped maximum aggregate
aggr
submax
command aggr.submax(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bit):bat[:any_1] 
AGGRsubmax_val;
Grouped maximum aggregate
aggr
submax
command aggr.submax(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bat[:oid], X_4:bit):bat[:oid] 
AGGRsubmaxcand;
Grouped maximum aggregate with candidates list
aggr
submax
command aggr.submax(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bat[:oid], X_4:bit):bat[:any_1] 
AGGRsubmaxcand_val;
Grouped maximum aggregate with candidates list
aggr
submedian
command aggr.submedian(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bit):bat[:any_1] 
AGGRsubmedian;
Grouped median aggregate
aggr
submedian
command aggr.submedian(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bat[:oid], X_4:bit):bat[:any_1] 
AGGRsubmediancand;
Grouped median aggregate with candidate list
aggr
submedian_avg
command aggr.submedian_avg(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bit):bat[:dbl] 
AGGRsubmedian_avg;
Grouped median aggregate
aggr
submedian_avg
command aggr.submedian_avg(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bat[:oid], X_4:bit):bat[:dbl] 
AGGRsubmediancand_avg;
Grouped median aggregate with candidate list
aggr
submin
command aggr.submin(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bit):bat[:oid] 
AGGRsubmin;
Grouped minimum aggregate
aggr
submin
command aggr.submin(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bit):bat[:any_1] 
AGGRsubmin_val;
Grouped minimum aggregate
aggr
submin
command aggr.submin(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bat[:oid], X_4:bit):bat[:oid] 
AGGRsubmincand;
Grouped minimum aggregate with candidates list
aggr
submin
command aggr.submin(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_2], X_3:bat[:oid], X_4:bit):bat[:any_1] 
AGGRsubmincand_val;
Grouped minimum aggregate with candidates list
aggr
subnot_exist
pattern aggr.subnot_exist(X_0:bat[:any], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
SQLsubnot_exist;
(empty)
aggr
subnot_exist
pattern aggr.subnot_exist(X_0:bat[:any], X_1:bat[:oid], X_2:bat[:oid], X_3:bit):bat[:bit] 
SQLsubnot_exist;
(empty)
aggr
subnull
pattern aggr.subnull(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
SQLnil_grp;
if any value in l is nil with in a group return true for that group, else false; with candidate list
aggr
subnull
pattern aggr.subnull(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bit):bat[:bit] 
SQLnil_grp;
if any value in l is nil with in a group return true for that group, else false
aggr
subprod
command aggr.subprod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:bte] 
AGGRsubprod_bte;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubprod_dbl;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubprod_dbl;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:flt] 
AGGRsubprod_flt;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:int] 
AGGRsubprod_int;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:int] 
AGGRsubprod_int;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:int] 
AGGRsubprod_int;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:lng] 
AGGRsubprod_lng;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:lng] 
AGGRsubprod_lng;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:lng] 
AGGRsubprod_lng;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:lng] 
AGGRsubprod_lng;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:sht] 
AGGRsubprod_sht;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:sht] 
AGGRsubprod_sht;
Grouped product aggregate
aggr
subprod
command aggr.subprod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:bte] 
AGGRsubprodcand_bte;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubprodcand_dbl;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubprodcand_dbl;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:flt] 
AGGRsubprodcand_flt;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:int] 
AGGRsubprodcand_int;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:int] 
AGGRsubprodcand_int;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:int] 
AGGRsubprodcand_int;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:lng] 
AGGRsubprodcand_lng;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:lng] 
AGGRsubprodcand_lng;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:lng] 
AGGRsubprodcand_lng;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:lng] 
AGGRsubprodcand_lng;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:sht] 
AGGRsubprodcand_sht;
Grouped product aggregate with candidates list
aggr
subprod
command aggr.subprod(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:sht] 
AGGRsubprodcand_sht;
Grouped product aggregate with candidates list
aggr
subquantile
command aggr.subquantile(X_0:bat[:any_1], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_2], X_4:bit):bat[:any_1] 
AGGRsubquantile;
Grouped quantile aggregate
aggr
subquantile
command aggr.subquantile(X_0:bat[:any_1], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_2], X_4:bat[:oid], X_5:bit):bat[:any_1] 
AGGRsubquantilecand;
Grouped quantile aggregate with candidate list
aggr
subquantile_avg
command aggr.subquantile_avg(X_0:bat[:any_1], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_2], X_4:bit):bat[:dbl] 
AGGRsubquantile_avg;
Grouped quantile aggregate
aggr
subquantile_avg
command aggr.subquantile_avg(X_0:bat[:any_1], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:any_2], X_4:bat[:oid], X_5:bit):bat[:dbl] 
AGGRsubquantilecand_avg;
Grouped quantile aggregate with candidate list
aggr
substdev
command aggr.substdev(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdev_dbl;
Grouped standard deviation (sample/non-biased) aggregate
aggr
substdev
command aggr.substdev(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdev_dbl;
Grouped standard deviation (sample/non-biased) aggregate
aggr
substdev
command aggr.substdev(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdev_dbl;
Grouped standard deviation (sample/non-biased) aggregate
aggr
substdev
command aggr.substdev(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdev_dbl;
Grouped standard deviation (sample/non-biased) aggregate
aggr
substdev
command aggr.substdev(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdev_dbl;
Grouped standard deviation (sample/non-biased) aggregate
aggr
substdev
command aggr.substdev(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdev_dbl;
Grouped standard deviation (sample/non-biased) aggregate
aggr
substdev
command aggr.substdev(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevcand_dbl;
Grouped standard deviation (sample/non-biased) aggregate with candidates list
aggr
substdev
command aggr.substdev(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevcand_dbl;
Grouped standard deviation (sample/non-biased) aggregate with candidates list
aggr
substdev
command aggr.substdev(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevcand_dbl;
Grouped standard deviation (sample/non-biased) aggregate with candidates list
aggr
substdev
command aggr.substdev(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevcand_dbl;
Grouped standard deviation (sample/non-biased) aggregate with candidates list
aggr
substdev
command aggr.substdev(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevcand_dbl;
Grouped standard deviation (sample/non-biased) aggregate with candidates list
aggr
substdev
command aggr.substdev(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevcand_dbl;
Grouped standard deviation (sample/non-biased) aggregate with candidates list
aggr
substdevp
command aggr.substdevp(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdevp_dbl;
Grouped standard deviation (population/biased) aggregate
aggr
substdevp
command aggr.substdevp(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdevp_dbl;
Grouped standard deviation (population/biased) aggregate
aggr
substdevp
command aggr.substdevp(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdevp_dbl;
Grouped standard deviation (population/biased) aggregate
aggr
substdevp
command aggr.substdevp(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdevp_dbl;
Grouped standard deviation (population/biased) aggregate
aggr
substdevp
command aggr.substdevp(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdevp_dbl;
Grouped standard deviation (population/biased) aggregate
aggr
substdevp
command aggr.substdevp(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubstdevp_dbl;
Grouped standard deviation (population/biased) aggregate
aggr
substdevp
command aggr.substdevp(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevpcand_dbl;
Grouped standard deviation (population/biased) aggregate with candidates list
aggr
substdevp
command aggr.substdevp(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevpcand_dbl;
Grouped standard deviation (population/biased) aggregate with candidates list
aggr
substdevp
command aggr.substdevp(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevpcand_dbl;
Grouped standard deviation (population/biased) aggregate with candidates list
aggr
substdevp
command aggr.substdevp(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevpcand_dbl;
Grouped standard deviation (population/biased) aggregate with candidates list
aggr
substdevp
command aggr.substdevp(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevpcand_dbl;
Grouped standard deviation (population/biased) aggregate with candidates list
aggr
substdevp
command aggr.substdevp(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubstdevpcand_dbl;
Grouped standard deviation (population/biased) aggregate with candidates list
aggr
substr_group_concat
command aggr.substr_group_concat(X_0:bat[:str], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:str] 
AGGRsubstr_group_concat;
Grouped string concat
aggr
substr_group_concat
command aggr.substr_group_concat(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:any_1], X_4:bit, X_5:bit):bat[:str] 
AGGRsubstr_group_concat_sep;
Grouped string concat with custom separator
aggr
substr_group_concat
command aggr.substr_group_concat(X_0:bat[:str], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:str] 
AGGRsubstr_group_concatcand;
Grouped string concat with candidates list
aggr
substr_group_concat
command aggr.substr_group_concat(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:any_1], X_4:bat[:oid], X_5:bit, X_6:bit):bat[:str] 
AGGRsubstr_group_concatcand_sep;
Grouped string concat with candidates list with custom separator
aggr
subsum
command aggr.subsum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:bte] 
AGGRsubsum_bte;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubsum_dbl;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubsum_dbl;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:flt] 
AGGRsubsum_flt;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:int] 
AGGRsubsum_int;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:int] 
AGGRsubsum_int;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:int] 
AGGRsubsum_int;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:lng] 
AGGRsubsum_lng;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:lng] 
AGGRsubsum_lng;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:lng] 
AGGRsubsum_lng;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:lng] 
AGGRsubsum_lng;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:sht] 
AGGRsubsum_sht;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:sht] 
AGGRsubsum_sht;
Grouped sum aggregate
aggr
subsum
command aggr.subsum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:bte] 
AGGRsubsumcand_bte;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubsumcand_dbl;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubsumcand_dbl;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:flt] 
AGGRsubsumcand_flt;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:int] 
AGGRsubsumcand_int;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:int] 
AGGRsubsumcand_int;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:int] 
AGGRsubsumcand_int;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:lng] 
AGGRsubsumcand_lng;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:lng] 
AGGRsubsumcand_lng;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:lng] 
AGGRsubsumcand_lng;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:lng] 
AGGRsubsumcand_lng;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:sht] 
AGGRsubsumcand_sht;
Grouped sum aggregate with candidates list
aggr
subsum
command aggr.subsum(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:sht] 
AGGRsubsumcand_sht;
Grouped sum aggregate with candidates list
aggr
subvariance
command aggr.subvariance(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariance_dbl;
Grouped variance (sample/non-biased) aggregate
aggr
subvariance
command aggr.subvariance(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariance_dbl;
Grouped variance (sample/non-biased) aggregate
aggr
subvariance
command aggr.subvariance(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariance_dbl;
Grouped variance (sample/non-biased) aggregate
aggr
subvariance
command aggr.subvariance(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariance_dbl;
Grouped variance (sample/non-biased) aggregate
aggr
subvariance
command aggr.subvariance(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariance_dbl;
Grouped variance (sample/non-biased) aggregate
aggr
subvariance
command aggr.subvariance(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariance_dbl;
Grouped variance (sample/non-biased) aggregate
aggr
subvariance
command aggr.subvariance(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancecand_dbl;
Grouped variance (sample/non-biased) aggregate with candidates list
aggr
subvariance
command aggr.subvariance(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancecand_dbl;
Grouped variance (sample/non-biased) aggregate with candidates list
aggr
subvariance
command aggr.subvariance(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancecand_dbl;
Grouped variance (sample/non-biased) aggregate with candidates list
aggr
subvariance
command aggr.subvariance(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancecand_dbl;
Grouped variance (sample/non-biased) aggregate with candidates list
aggr
subvariance
command aggr.subvariance(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancecand_dbl;
Grouped variance (sample/non-biased) aggregate with candidates list
aggr
subvariance
command aggr.subvariance(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancecand_dbl;
Grouped variance (sample/non-biased) aggregate with candidates list
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariancep_dbl;
Grouped variance (population/biased) aggregate
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariancep_dbl;
Grouped variance (population/biased) aggregate
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariancep_dbl;
Grouped variance (population/biased) aggregate
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariancep_dbl;
Grouped variance (population/biased) aggregate
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariancep_dbl;
Grouped variance (population/biased) aggregate
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit, X_4:bit):bat[:dbl] 
AGGRsubvariancep_dbl;
Grouped variance (population/biased) aggregate
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancepcand_dbl;
Grouped variance (population/biased) aggregate with candidates list
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancepcand_dbl;
Grouped variance (population/biased) aggregate with candidates list
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancepcand_dbl;
Grouped variance (population/biased) aggregate with candidates list
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancepcand_dbl;
Grouped variance (population/biased) aggregate with candidates list
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancepcand_dbl;
Grouped variance (population/biased) aggregate with candidates list
aggr
subvariancep
command aggr.subvariancep(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit, X_5:bit):bat[:dbl] 
AGGRsubvariancepcand_dbl;
Grouped variance (population/biased) aggregate with candidates list
aggr
subzero_or_one
command aggr.subzero_or_one(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bit):bat[:any_1] 
SQLsubzero_or_one;
(empty)
aggr
sum
command aggr.sum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:bte] 
AGGRsum3_bte;
Grouped tail sum on bte
aggr
sum
command aggr.sum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRsum3_dbl;
Grouped tail sum on bte
aggr
sum
command aggr.sum(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRsum3_dbl;
Grouped tail sum on dbl
aggr
sum
command aggr.sum(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRsum3_dbl;
Grouped tail sum on flt
aggr
sum
command aggr.sum(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRsum3_dbl;
Grouped tail sum on int
aggr
sum
command aggr.sum(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRsum3_dbl;
Grouped tail sum on lng
aggr
sum
command aggr.sum(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRsum3_dbl;
Grouped tail sum on sht
aggr
sum
command aggr.sum(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1]):bat[:flt] 
AGGRsum3_flt;
Grouped tail sum on flt
aggr
sum
command aggr.sum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:int] 
AGGRsum3_int;
Grouped tail sum on bte
aggr
sum
command aggr.sum(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]):bat[:int] 
AGGRsum3_int;
Grouped tail sum on int
aggr
sum
command aggr.sum(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:int] 
AGGRsum3_int;
Grouped tail sum on sht
aggr
sum
command aggr.sum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:lng] 
AGGRsum3_lng;
Grouped tail sum on bte
aggr
sum
command aggr.sum(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]):bat[:lng] 
AGGRsum3_lng;
Grouped tail sum on int
aggr
sum
command aggr.sum(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1]):bat[:lng] 
AGGRsum3_lng;
Grouped tail sum on lng
aggr
sum
command aggr.sum(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:lng] 
AGGRsum3_lng;
Grouped tail sum on sht
aggr
sum
command aggr.sum(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:sht] 
AGGRsum3_sht;
Grouped tail sum on bte
aggr
sum
command aggr.sum(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:sht] 
AGGRsum3_sht;
Grouped tail sum on sht
aggr
sum
pattern aggr.sum(X_0:bat[:bte]):bte 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:bte]):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:bte]):int 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:bte]):lng 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:bte]):sht 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bat[:oid]):bte 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bat[:oid]):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bat[:oid]):int 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bat[:oid]):lng 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bat[:oid]):sht 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bat[:oid], X_2:bit):bte 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bat[:oid], X_2:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bat[:oid], X_2:bit):int 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bat[:oid], X_2:bit):lng 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bat[:oid], X_2:bit):sht 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bit):bte 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bit):int 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bit):lng 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:bte], X_1:bit):sht 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:dbl]):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:dbl], X_1:bat[:oid]):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:dbl], X_1:bat[:oid], X_2:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:dbl], X_1:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:flt]):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:flt]):flt 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:flt], X_1:bat[:oid]):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:flt], X_1:bat[:oid]):flt 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:flt], X_1:bat[:oid], X_2:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:flt], X_1:bat[:oid], X_2:bit):flt 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:flt], X_1:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:flt], X_1:bit):flt 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:int]):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:int]):int 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:int]):lng 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:int], X_1:bat[:oid]):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:int], X_1:bat[:oid]):int 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:int], X_1:bat[:oid]):lng 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:int], X_1:bat[:oid], X_2:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:int], X_1:bat[:oid], X_2:bit):int 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:int], X_1:bat[:oid], X_2:bit):lng 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:int], X_1:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:int], X_1:bit):int 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:int], X_1:bit):lng 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:lng]):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:lng]):lng 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:lng], X_1:bat[:oid]):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:lng], X_1:bat[:oid]):lng 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:lng], X_1:bat[:oid], X_2:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:lng], X_1:bat[:oid], X_2:bit):lng 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:lng], X_1:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:lng], X_1:bit):lng 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:msk]):bte 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:msk]):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:msk]):int 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:msk]):lng 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:msk]):sht 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bat[:oid]):bte 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bat[:oid]):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bat[:oid]):int 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bat[:oid]):lng 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bat[:oid]):sht 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bat[:oid], X_2:bit):bte 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bat[:oid], X_2:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bat[:oid], X_2:bit):int 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bat[:oid], X_2:bit):lng 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bat[:oid], X_2:bit):sht 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bit):bte 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bit):int 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bit):lng 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:msk], X_1:bit):sht 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:sht]):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:sht]):int 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:sht]):lng 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:sht]):sht 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bat[:oid]):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bat[:oid]):int 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bat[:oid]):lng 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bat[:oid]):sht 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bat[:oid], X_2:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bat[:oid], X_2:bit):int 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bat[:oid], X_2:bit):lng 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bat[:oid], X_2:bit):sht 
CMDBATsum;
Calculate aggregate sum of B with candidate list.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bit):dbl 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bit):int 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bit):lng 
CMDBATsum;
Calculate aggregate sum of B.
aggr
sum
pattern aggr.sum(X_0:bat[:sht], X_1:bit):sht 
CMDBATsum;
Calculate aggregate sum of B.
aggr
variance
command aggr.variance(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariance3_dbl;
Grouped tail variance (sample/non-biased) on bte
aggr
variance
command aggr.variance(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariance3_dbl;
Grouped tail variance (sample/non-biased) on dbl
aggr
variance
command aggr.variance(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariance3_dbl;
Grouped tail variance (sample/non-biased) on flt
aggr
variance
command aggr.variance(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariance3_dbl;
Grouped tail variance (sample/non-biased) on int
aggr
variance
command aggr.variance(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariance3_dbl;
Grouped tail variance (sample/non-biased) on lng
aggr
variance
command aggr.variance(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariance3_dbl;
Grouped tail variance (sample/non-biased) on sht
aggr
variance
command aggr.variance(X_0:bat[:any_2]):dbl 
ALGvariance;
Gives the variance of all tail values
aggr
variancep
command aggr.variancep(X_0:bat[:bte], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariancep3_dbl;
Grouped tail variance (population/biased) on bte
aggr
variancep
command aggr.variancep(X_0:bat[:dbl], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariancep3_dbl;
Grouped tail variance (population/biased) on dbl
aggr
variancep
command aggr.variancep(X_0:bat[:flt], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariancep3_dbl;
Grouped tail variance (population/biased) on flt
aggr
variancep
command aggr.variancep(X_0:bat[:int], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariancep3_dbl;
Grouped tail variance (population/biased) on int
aggr
variancep
command aggr.variancep(X_0:bat[:lng], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariancep3_dbl;
Grouped tail variance (population/biased) on lng
aggr
variancep
command aggr.variancep(X_0:bat[:sht], X_1:bat[:oid], X_2:bat[:any_1]):bat[:dbl] 
AGGRvariancep3_dbl;
Grouped tail variance (population/biased) on sht
aggr
variancep
command aggr.variancep(X_0:bat[:any_2]):dbl 
ALGvariancep;
Gives the variance of all tail values
aggr
zero_or_one
command aggr.zero_or_one(X_0:bat[:any_1]):any_1 
zero_or_one;
if col contains exactly one value return this. Incase of more raise an exception else return nil
aggr
zero_or_one
command aggr.zero_or_one(X_0:bat[:any_1], X_1:bit):any_1 
zero_or_one_error;
if col contains exactly one value return this. Incase of more raise an exception if err is true else return nil
aggr
zero_or_one
command aggr.zero_or_one(X_0:bat[:any_1], X_1:bat[:bit]):any_1 
zero_or_one_error_bat;
if col contains exactly one value return this. Incase of more raise an exception if err is true else return nil
alarm
ctime
unsafe command alarm.ctime():str 
ALARMctime;
Return the current time as a C-time string.
alarm
epoch
unsafe command alarm.epoch():int 
ALARMepoch;
Return time since Jan 1, 1970 in seconds.
alarm
sleep
unsafe pattern alarm.sleep(X_0:any_1):any_1 
ALARMsleep;
Sleep a few milliseconds and return the slept value
alarm
sleep
unsafe pattern alarm.sleep(X_0:any_1):void 
ALARMsleep;
Sleep a few milliseconds
alarm
sleep
unsafe pattern alarm.sleep(X_0:bat[:any_1]):bat[:any_1] 
ALARMsleep;
Sleep a few milliseconds and return the slept value
alarm
time
unsafe command alarm.time():int 
ALARMtime;
Return time since program start in milliseconds.
alarm
usec
unsafe command alarm.usec():lng 
ALARMusec;
Return time since Jan 1, 1970 in microseconds.
algebra
bandjoin
command algebra.bandjoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:any_1, X_5:any_1, X_6:bit, X_7:bit, X_8:lng):bat[:oid] 
ALGbandjoin1;
Band join: values in l and r match if r - c1 <[=] l <[=] r + c2; only produce left output
algebra
bandjoin
command algebra.bandjoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:any_1, X_5:any_1, X_6:bit, X_7:bit, X_8:lng) (X_9:bat[:oid], X_10:bat[:oid]) 
ALGbandjoin;
Band join: values in l and r match if r - c1 <[=] l <[=] r + c2
algebra
copy
command algebra.copy(X_0:bat[:any_1]):bat[:any_1] 
ALGcopy;
Returns physical copy of a BAT.
algebra
crossproduct
command algebra.crossproduct(X_0:bat[:any_1], X_1:bat[:any_2], X_2:bit):bat[:oid] 
ALGcrossproduct1;
Compute the cross product of both input bats; but only produce left output
algebra
crossproduct
command algebra.crossproduct(X_0:bat[:any_1], X_1:bat[:any_2], X_2:bit) (X_3:bat[:oid], X_4:bat[:oid]) 
ALGcrossproduct2;
Returns 2 columns with all BUNs, consisting of the head-oids@from 'left' and 'right' for which there are BUNs in 'left'@and 'right' with equal tails
algebra
crossproduct
command algebra.crossproduct(X_0:bat[:any_1], X_1:bat[:any_2], X_2:bat[:oid], X_3:bat[:oid], X_4:bit) (X_5:bat[:oid], X_6:bat[:oid]) 
ALGcrossproduct3;
Compute the cross product of both input bats
algebra
crossproduct
command algebra.crossproduct(X_0:bat[:any_1], X_1:bat[:any_2], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:oid] 
ALGcrossproduct4;
Compute the cross product of both input bats; but only produce left output
algebra
difference
command algebra.difference(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:lng):bat[:oid] 
ALGdifference;
Difference of l and r with candidate lists
algebra
exist
command algebra.exist(X_0:bat[:any_1], X_1:any_1):bit 
ALGexist;
Returns whether 'val' occurs in b.
algebra
fetch
command algebra.fetch(X_0:bat[:any_1], X_1:oid):any_1 
ALGfetchoid;
Returns the value of the BUN at x-th position with 0 <= x < b.count
algebra
find
command algebra.find(X_0:bat[:any_1], X_1:any_1):oid 
ALGfind;
Returns the index position of a value.  If no such BUN exists return OID-nil.
algebra
firstn
pattern algebra.firstn(X_0:bat[:any], X_1:bat[:oid], X_2:bat[:oid], X_3:lng, X_4:bit, X_5:bit, X_6:bit) (X_7:bat[:oid], X_8:bat[:oid]) 
ALGfirstn;
Calculate first N values of B with candidate list S
algebra
firstn
pattern algebra.firstn(X_0:bat[:any], X_1:bat[:oid], X_2:bat[:oid], X_3:lng, X_4:bit, X_5:bit, X_6:bit):bat[:oid] 
ALGfirstn;
Calculate first N values of B with candidate list S
algebra
groupby
command algebra.groupby(X_0:bat[:oid], X_1:bat[:lng]):bat[:oid] 
ALGgroupby;
Produces a new BAT with groups identified by the head column. The result contains tail times the head value, ie the tail contains the result group sizes.
algebra
intersect
command algebra.intersect(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:lng):bat[:oid] 
ALGintersect;
Intersection of l and r with candidate lists (i.e. half of semi-join)
algebra
join
command algebra.join(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit, X_5:lng):bat[:oid] 
ALGjoin1;
Join; only produce left output
algebra
join
command algebra.join(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit, X_5:lng) (X_6:bat[:oid], X_7:bat[:oid]) 
ALGjoin;
Join
algebra
leftjoin
command algebra.leftjoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit, X_5:lng):bat[:oid] 
ALGleftjoin1;
Left join with candidate lists; only produce left output
algebra
leftjoin
command algebra.leftjoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit, X_5:lng) (X_6:bat[:oid], X_7:bat[:oid]) 
ALGleftjoin;
Left join with candidate lists
algebra
like
command algebra.like(X_0:str, X_1:str, X_2:str, X_3:bit):bit 
PCRElike;
(empty)
algebra
likejoin
command algebra.likejoin(X_0:bat[:str], X_1:bat[:str], X_2:bat[:str], X_3:bat[:bit], X_4:bat[:oid], X_5:bat[:oid], X_6:bit, X_7:lng, X_8:bit):bat[:oid] 
LIKEjoin1;
The same as LIKEjoin_esc, but only produce one output
algebra
likejoin
command algebra.likejoin(X_0:bat[:str], X_1:bat[:str], X_2:bat[:str], X_3:bat[:bit], X_4:bat[:oid], X_5:bat[:oid], X_6:bit, X_7:lng, X_8:bit) (X_9:bat[:oid], X_10:bat[:oid]) 
LIKEjoin;
Join the string bat L with the pattern bat R@with optional candidate lists SL and SR using pattern escape string ESC@and doing a case sensitive match.@The result is two aligned bats with oids of matching rows.
algebra
likeselect
command algebra.likeselect(X_0:bat[:str], X_1:bat[:oid], X_2:str, X_3:str, X_4:bit, X_5:bit):bat[:oid] 
PCRElikeselect;
Select all head values of the first input BAT for which the@tail value is "like" the given (SQL-style) pattern and for@which the head value occurs in the tail of the second input@BAT.@Input is a dense-headed BAT, output is a dense-headed BAT with in@the tail the head value of the input BAT for which the@relationship holds.  The output BAT is sorted on the tail value.
algebra
not_like
command algebra.not_like(X_0:str, X_1:str, X_2:str, X_3:bit):bit 
PCREnotlike;
(empty)
algebra
orderidx
command algebra.orderidx(X_0:bat[:any_1], X_1:bit):bat[:any_1] 
OIDXorderidx;
Create an order index
algebra
outerjoin
command algebra.outerjoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:lng):bat[:oid] 
ALGouterjoin1;
Left outer join with candidate lists; only produce left output
algebra
outerjoin
command algebra.outerjoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:lng) (X_7:bat[:oid], X_8:bat[:oid]) 
ALGouterjoin;
Left outer join with candidate lists
algebra
project
pattern algebra.project(X_0:bat[:any_1], X_1:any_3):bat[:any_3] 
ALGprojecttail;
Fill the tail with a constant
algebra
projection
command algebra.projection(X_0:bat[:oid], X_1:bat[:any_3], X_2:bat[:any_3]):bat[:any_3] 
ALGprojection2;
Project left input onto right inputs which should be consecutive.
algebra
projection
command algebra.projection(X_0:bat[:oid], X_1:bat[:any_3]):bat[:any_3] 
ALGprojection;
Project left input onto right input.
algebra
projectionpath
pattern algebra.projectionpath(X_0:bat[:any]...):bat[:any] 
ALGprojectionpath;
Routine to handle join paths.  The type analysis is rather tricky.
algebra
rangejoin
command algebra.rangejoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:any_1], X_3:bat[:oid], X_4:bat[:oid], X_5:bit, X_6:bit, X_7:bit, X_8:bit, X_9:lng):bat[:oid] 
ALGrangejoin1;
Range join: values in l and r1/r2 match if r1 <[=] l <[=] r2; only produce left output
algebra
rangejoin
command algebra.rangejoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:any_1], X_3:bat[:oid], X_4:bat[:oid], X_5:bit, X_6:bit, X_7:bit, X_8:bit, X_9:lng) (X_10:bat[:oid], X_11:bat[:oid]) 
ALGrangejoin;
Range join: values in l and r1/r2 match if r1 <[=] l <[=] r2
algebra
reuse
command algebra.reuse(X_0:bat[:any_1]):bat[:any_1] 
ALGreuse;
Reuse a temporary BAT if you can. Otherwise,@allocate enough storage to accept result of an@operation (not involving the heap)
algebra
select
command algebra.select(X_0:bat[:any_1], X_1:any_1, X_2:any_1, X_3:bit, X_4:bit, X_5:bit):bat[:oid] 
ALGselect1;
Select all head values for which the tail value is in range.@Input is a dense-headed BAT, output is a dense-headed BAT with in@the tail the head value of the input BAT for which the tail value@is between the values low and high (inclusive if li respectively@hi is set).  The output BAT is sorted on the tail value.  If low@or high is nil, the boundary is not considered (effectively - and@+ infinity).  If anti is set, the result is the complement.  Nil@values in the tail are never matched, unless low=nil, high=nil,@li=1, hi=1, anti=0.  All non-nil values are returned if low=nil,@high=nil, and li, hi are not both 1, or anti=1.@Note that the output is suitable as second input for the other@version of this function.
algebra
select
command algebra.select(X_0:bat[:any_1], X_1:any_1, X_2:any_1, X_3:bit, X_4:bit, X_5:bit, X_6:bit):bat[:oid] 
ALGselect1nil;
With unknown set, each nil != nil
algebra
select
command algebra.select(X_0:bat[:any_1], X_1:bat[:oid], X_2:any_1, X_3:any_1, X_4:bit, X_5:bit, X_6:bit):bat[:oid] 
ALGselect2;
Select all head values of the first input BAT for which the tail value@is in range and for which the head value occurs in the tail of the@second input BAT.@The first input is a dense-headed BAT, the second input is a@dense-headed BAT with sorted tail, output is a dense-headed BAT@with in the tail the head value of the input BAT for which the@tail value is between the values low and high (inclusive if li@respectively hi is set).  The output BAT is sorted on the tail@value.  If low or high is nil, the boundary is not considered@(effectively - and + infinity).  If anti is set, the result is the@complement.  Nil values in the tail are never matched, unless@low=nil, high=nil, li=1, hi=1, anti=0.  All non-nil values are@returned if low=nil, high=nil, and li, hi are not both 1, or anti=1.@Note that the output is suitable as second input for this@function.
algebra
select
command algebra.select(X_0:bat[:any_1], X_1:bat[:oid], X_2:any_1, X_3:any_1, X_4:bit, X_5:bit, X_6:bit, X_7:bit):bat[:oid] 
ALGselect2nil;
With unknown set, each nil != nil
algebra
selectNotNil
command algebra.selectNotNil(X_0:bat[:any_2]):bat[:any_2] 
ALGselectNotNil;
Select all not-nil values
algebra
semijoin
command algebra.semijoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit, X_5:bit, X_6:lng) (X_7:bat[:oid], X_8:bat[:oid]) 
ALGsemijoin;
Semi join with candidate lists
algebra
slice
command algebra.slice(X_0:bat[:any_1], X_1:lng, X_2:lng):bat[:any_1] 
ALGslice;
Return the slice with the BUNs at position x till y.
algebra
slice
command algebra.slice(X_0:bat[:any_1], X_1:int, X_2:int):bat[:any_1] 
ALGslice_int;
Return the slice with the BUNs at position x till y.
algebra
slice
command algebra.slice(X_0:bat[:any_1], X_1:lng, X_2:lng):bat[:any_1] 
ALGslice_lng;
Return the slice with the BUNs at position x till y.
algebra
slice
command algebra.slice(X_0:bat[:any_1], X_1:oid, X_2:oid):bat[:any_1] 
ALGslice_oid;
Return the slice based on head oid x till y (exclusive).
algebra
sort
command algebra.sort(X_0:bat[:any_1], X_1:bit, X_2:bit, X_3:bit):bat[:any_1] 
ALGsort11;
Returns a copy of the BAT sorted on tail values.@The order is descending if the reverse bit is set.@This is a stable sort if the stable bit is set.
algebra
sort
command algebra.sort(X_0:bat[:any_1], X_1:bit, X_2:bit, X_3:bit) (X_4:bat[:any_1], X_5:bat[:oid]) 
ALGsort12;
Returns a copy of the BAT sorted on tail values and a BAT that@specifies how the input was reordered.@The order is descending if the reverse bit is set.@This is a stable sort if the stable bit is set.
algebra
sort
command algebra.sort(X_0:bat[:any_1], X_1:bit, X_2:bit, X_3:bit) (X_4:bat[:any_1], X_5:bat[:oid], X_6:bat[:oid]) 
ALGsort13;
Returns a copy of the BAT sorted on tail values, a BAT that specifies@how the input was reordered, and a BAT with group information.@The order is descending if the reverse bit is set.@This is a stable sort if the stable bit is set.
algebra
sort
command algebra.sort(X_0:bat[:any_1], X_1:bat[:oid], X_2:bit, X_3:bit, X_4:bit):bat[:any_1] 
ALGsort21;
Returns a copy of the BAT sorted on tail values.@The order is descending if the reverse bit is set.@This is a stable sort if the stable bit is set.
algebra
sort
command algebra.sort(X_0:bat[:any_1], X_1:bat[:oid], X_2:bit, X_3:bit, X_4:bit) (X_5:bat[:any_1], X_6:bat[:oid]) 
ALGsort22;
Returns a copy of the BAT sorted on tail values and a BAT that@specifies how the input was reordered.@The order is descending if the reverse bit is set.@This is a stable sort if the stable bit is set.
algebra
sort
command algebra.sort(X_0:bat[:any_1], X_1:bat[:oid], X_2:bit, X_3:bit, X_4:bit) (X_5:bat[:any_1], X_6:bat[:oid], X_7:bat[:oid]) 
ALGsort23;
Returns a copy of the BAT sorted on tail values, a BAT that specifies@how the input was reordered, and a BAT with group information.@The order is descending if the reverse bit is set.@This is a stable sort if the stable bit is set.
algebra
sort
command algebra.sort(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bit, X_4:bit, X_5:bit):bat[:any_1] 
ALGsort31;
Returns a copy of the BAT sorted on tail values.@The order is descending if the reverse bit is set.@This is a stable sort if the stable bit is set.
algebra
sort
command algebra.sort(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bit, X_4:bit, X_5:bit) (X_6:bat[:any_1], X_7:bat[:oid]) 
ALGsort32;
Returns a copy of the BAT sorted on tail values and a BAT that@specifies how the input was reordered.@The order is descending if the reverse bit is set.@This is a stable sort if the stable bit is set.
algebra
sort
command algebra.sort(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bit, X_4:bit, X_5:bit) (X_6:bat[:any_1], X_7:bat[:oid], X_8:bat[:oid]) 
ALGsort33;
Returns a copy of the BAT sorted on tail values, a BAT that specifies@how the input was reordered, and a BAT with group information.@The order is descending if the reverse bit is set.@This is a stable sort if the stable bit is set.
algebra
subslice
command algebra.subslice(X_0:bat[:any_1], X_1:lng, X_2:lng):bat[:oid] 
ALGsubslice_lng;
Return the oids of the slice with the BUNs at position x till y.
algebra
thetajoin
command algebra.thetajoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:int, X_5:bit, X_6:lng):bat[:oid] 
ALGthetajoin1;
Theta join with candidate lists; only produce left output
algebra
thetajoin
command algebra.thetajoin(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:int, X_5:bit, X_6:lng) (X_7:bat[:oid], X_8:bat[:oid]) 
ALGthetajoin;
Theta join with candidate lists
algebra
thetaselect
command algebra.thetaselect(X_0:bat[:any_1], X_1:bat[:oid], X_2:any_1, X_3:str):bat[:oid] 
ALGthetaselect2;
Select all head values of the first input BAT for which the tail value@obeys the relation value OP VAL and for which the head value occurs in@the tail of the second input BAT.@Input is a dense-headed BAT, output is a dense-headed BAT with in@the tail the head value of the input BAT for which the@relationship holds.  The output BAT is sorted on the tail value.
algebra
unique
command algebra.unique(X_0:bat[:any_1], X_1:bat[:oid]):bat[:oid] 
ALGunique;
Select all unique values from the tail of the first input.@Input is a dense-headed BAT, the second input is a@dense-headed BAT with sorted tail, output is a dense-headed@BAT with in the tail the head value of the input BAT that was@selected.  The output BAT is sorted on the tail value.  The@second input BAT is a list of candidates.
bat
append
command bat.append(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bit):bat[:any_1] 
BKCappend_cand_force_wrap;
append the content of u with candidate list s to i
bat
append
command bat.append(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid]):bat[:any_1] 
BKCappend_cand_wrap;
append the content of u with candidate list s to i
bat
append
command bat.append(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bit):bat[:any_1] 
BKCappend_force_wrap;
append the content of u to i
bat
append
command bat.append(X_0:bat[:any_1], X_1:any_1, X_2:bit):bat[:any_1] 
BKCappend_val_force_wrap;
append the value u to i
bat
append
command bat.append(X_0:bat[:any_1], X_1:any_1):bat[:any_1] 
BKCappend_val_wrap;
append the value u to i
bat
append
command bat.append(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:any_1] 
BKCappend_wrap;
append the content of u to i
bat
appendBulk
pattern bat.appendBulk(X_0:bat[:any_1], X_1:bit, X_2:any_1...):bat[:any_1] 
CMDBATappend_bulk;
append the arguments ins to i
bat
appendBulk
pattern bat.appendBulk(X_0:bat[:any_1], X_1:bit, X_2:bat[:any_1]...):bat[:any_1] 
CMDBATappend_bulk;
append the arguments ins to i
bat
attach
command bat.attach(X_0:int, X_1:str):bat[:any_1] 
BKCattach;
Returns a new BAT with dense head and tail of the given type and uses@the given file to initialize the tail. The file will be owned by the@server.
bat
delete
command bat.delete(X_0:bat[:any_1], X_1:oid):bat[:any_1] 
BKCdelete;
Delete BUN indicated by head value, exchanging with last BUN
bat
delete
command bat.delete(X_0:bat[:any_1]):bat[:any_1] 
BKCdelete_all;
Delete all entries.
bat
delete
command bat.delete(X_0:bat[:any_1], X_1:bat[:oid]):bat[:any_1] 
BKCdelete_multi;
Delete multiple BUN, shifting BUNs up
bat
densebat
command bat.densebat(X_0:lng):bat[:oid] 
BKCdensebat;
Creates a new [void,void] BAT of size 'sz'.
bat
diffcand
command bat.diffcand(X_0:bat[:oid], X_1:bat[:oid]):bat[:oid] 
BKCdiffcand;
Calculate difference of two candidate lists
bat
getAccess
command bat.getAccess(X_0:bat[:any_1]):str 
BKCgetAccess;
Return the access mode attached to this BAT as a character.
bat
getCapacity
command bat.getCapacity(X_0:bat[:any_1]):lng 
BKCgetCapacity;
Returns the current allocation size (in max number of elements) of a BAT.
bat
getColumnType
command bat.getColumnType(X_0:bat[:any_1]):str 
BKCgetColumnType;
Returns the type of the tail column of a BAT, as an integer type number.
bat
getName
command bat.getName(X_0:bat[:any_1]):str 
BKCgetBBPname;
Gives back the logical name of a BAT.
bat
getRole
command bat.getRole(X_0:bat[:any_1]):str 
BKCgetRole;
Returns the rolename of the head column of a BAT.
bat
getSequenceBase
command bat.getSequenceBase(X_0:bat[:any_1]):oid 
BKCgetSequenceBase;
Get the sequence base for the void column of a BAT.
bat
getSize
command bat.getSize(X_0:bat[:any_1]):lng 
BKCgetSize;
Calculate the actual size of the BAT descriptor, heaps, hashes and imprint indices in bytes@rounded to the memory page size (see bbp.getPageSize()).
bat
getVHeapSize
command bat.getVHeapSize(X_0:bat[:any_1]):lng 
BKCgetVHeapSize;
Calculate the vheap size for varsized bats
bat
getorderidx
pattern bat.getorderidx(X_0:bat[:any_1]):bat[:oid] 
OIDXgetorderidx;
Return the order index if it exists
bat
hasorderidx
pattern bat.hasorderidx(X_0:bat[:any_1]):bit 
OIDXhasorderidx;
Return true if order index exists
bat
imprints
command bat.imprints(X_0:bat[:bte]):void 
CMDBATimprints;
(empty)
bat
imprints
command bat.imprints(X_0:bat[:dbl]):void 
CMDBATimprints;
Check for existence or create an imprint index on the BAT.
bat
imprints
command bat.imprints(X_0:bat[:flt]):void 
CMDBATimprints;
(empty)
bat
imprints
command bat.imprints(X_0:bat[:int]):void 
CMDBATimprints;
(empty)
bat
imprints
command bat.imprints(X_0:bat[:lng]):void 
CMDBATimprints;
(empty)
bat
imprints
command bat.imprints(X_0:bat[:sht]):void 
CMDBATimprints;
(empty)
bat
imprintsize
command bat.imprintsize(X_0:bat[:bte]):lng 
CMDBATimprintsize;
(empty)
bat
imprintsize
command bat.imprintsize(X_0:bat[:dbl]):lng 
CMDBATimprintsize;
Return the storage size of the imprints index structure.
bat
imprintsize
command bat.imprintsize(X_0:bat[:flt]):lng 
CMDBATimprintsize;
(empty)
bat
imprintsize
command bat.imprintsize(X_0:bat[:int]):lng 
CMDBATimprintsize;
(empty)
bat
imprintsize
command bat.imprintsize(X_0:bat[:lng]):lng 
CMDBATimprintsize;
(empty)
bat
imprintsize
command bat.imprintsize(X_0:bat[:sht]):lng 
CMDBATimprintsize;
(empty)
bat
info
command bat.info(X_0:bat[:any_1]) (X_1:bat[:str], X_2:bat[:str]) 
BKCinfo;
Produce a table containing information about a BAT in [attribute,value] format. @It contains all properties of the BAT record. 
bat
intersectcand
command bat.intersectcand(X_0:bat[:oid], X_1:bat[:oid]):bat[:oid] 
BKCintersectcand;
Intersect two candidate lists into one
bat
isPersistent
command bat.isPersistent(X_0:bat[:any_1]):bit 
BKCisPersistent;
(empty)
bat
isSorted
command bat.isSorted(X_0:bat[:any_1]):bit 
BKCisSorted;
Returns true if BAT values are ordered.
bat
isSortedReverse
command bat.isSortedReverse(X_0:bat[:any_1]):bit 
BKCisSortedReverse;
Returns true if BAT values are reversely ordered.
bat
isSynced
command bat.isSynced(X_0:bat[:any_1], X_1:bat[:any_2]):bit 
BKCisSynced;
Tests whether two BATs are synced or not. 
bat
isTransient
command bat.isTransient(X_0:bat[:any_1]):bit 
BKCisTransient;
(empty)
bat
isaKey
command bat.isaKey(X_0:bat[:any_1]):bit 
BKCgetKey;
Return whether the column tail values are unique (key).
bat
mergecand
command bat.mergecand(X_0:bat[:oid], X_1:bat[:oid]):bat[:oid] 
BKCmergecand;
Merge two candidate lists into one
bat
mirror
command bat.mirror(X_0:bat[:any_2]):bat[:oid] 
BKCmirror;
Returns the head-mirror image of a BAT (two head columns).
bat
new
pattern bat.new(X_0:any_1, X_1:bat[:any_2]):bat[:any_1] 
CMDBATdup;
Creates a new empty transient BAT, with tail-type tt and hseqbase and size from the input bat argument.
bat
new
pattern bat.new(X_0:any_1):bat[:any_1] 
CMDBATnew;
(empty)
bat
new
pattern bat.new(X_0:any_1, X_1:int):bat[:any_1] 
CMDBATnew;
(empty)
bat
new
pattern bat.new(X_0:any_1, X_1:int, X_2:bit):bat[:any_1] 
CMDBATnew;
(empty)
bat
new
pattern bat.new(X_0:any_1, X_1:lng):bat[:any_1] 
CMDBATnew;
Creates a new empty transient BAT, with tail-types as indicated.
bat
new
pattern bat.new(X_0:any_1, X_1:lng, X_2:bit):bat[:any_1] 
CMDBATnew;
(empty)
bat
orderidx
pattern bat.orderidx(X_0:bat[:any_1]):void 
OIDXcreate;
Introduces the OID index arrangement of ordered values
bat
orderidx
pattern bat.orderidx(X_0:bat[:any_1], X_1:int):void 
OIDXcreate;
Introduces the OID index arrangement of ordered values
bat
orderidx
pattern bat.orderidx(X_0:bat[:any_1], X_1:bat[:any_1]...):void 
OIDXmerge;
Consolidates the OID index arrangement
bat
pack
pattern bat.pack(X_0:any_2...):bat[:any_2] 
MATpackValues;
Materialize the values into a BAT. Avoiding a clash with mat.pack() in mergetable
bat
partition
pattern bat.partition(X_0:bat[:any_1], X_1:int, X_2:int):bat[:any_1] 
CMDBATpartition2;
Create the n-th slice over the BAT broken into several pieces.
bat
partition
pattern bat.partition(X_0:bat[:any_1]):bat[:any_1]... 
CMDBATpartition;
Create a serie of slices over the BAT argument. The BUNs are distributed evenly.
bat
replace
command bat.replace(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_1]):bat[:any_1] 
BKCbat_inplace;
Perform replace for all BUNs of the second BAT into the first.
bat
replace
command bat.replace(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit):bat[:any_1] 
BKCbat_inplace_force;
Perform replace for all BUNs of the second BAT into the first.
bat
replace
command bat.replace(X_0:bat[:any_1], X_1:oid, X_2:any_1):bat[:any_1] 
BKCbun_inplace;
Replace the tail value of one BUN that has some head value.
bat
replace
command bat.replace(X_0:bat[:any_1], X_1:oid, X_2:any_1, X_3:bit):bat[:any_1] 
BKCbun_inplace_force;
Replace the tail value of one BUN that has some head value.
bat
reuse
command bat.reuse(X_0:bat[:any_1], X_1:bat[:oid]):bat[:any_1] 
BKCreuseBAT;
Shuffle the values around to restore a dense representation of buns.
bat
reuseMap
command bat.reuseMap(X_0:bat[:any_1], X_1:bat[:oid]):bat[:oid] 
BKCreuseBATmap;
Derive the oid mapping for reuse BAT based on list of to-be-deleted
bat
save
command bat.save(X_0:bat[:any_1]):void 
BKCsave2;
(empty)
bat
save
command bat.save(X_0:str):bit 
BKCsave;
Save a BAT to storage, if it was loaded and dirty.  @Returns whether IO was necessary.  Please realize that @calling this function violates the atomic commit protocol!!
bat
setAccess
command bat.setAccess(X_0:bat[:any_1], X_1:str):bat[:any_1] 
BKCsetAccess;
Try to change the update access privileges @to this BAT. Mode:@r[ead-only]      - allow only read access.@a[append-only]   - allow reads and update.@w[riteable]      - allow all operations.@BATs are updatable by default. On making a BAT read-only, @all subsequent updates fail with an error message.@Returns the BAT itself.
bat
setColumn
command bat.setColumn(X_0:bat[:any_1], X_1:str):void 
BKCsetColumn;
Give a logical name to the tail column of a BAT.
bat
setHash
command bat.setHash(X_0:bat[:any_1]):bit 
BKCsetHash;
Create a hash structure on the column
bat
setImprints
command bat.setImprints(X_0:bat[:any_1]):bit 
BKCsetImprints;
Create an imprints structure on the column
bat
setName
command bat.setName(X_0:bat[:any_1], X_1:str):void 
BKCsetName;
Give a logical name to a BAT. 
bat
setPersistent
command bat.setPersistent(X_0:bat[:any_1]):void 
BKCsetPersistent;
Make the BAT persistent.
bat
setTransient
command bat.setTransient(X_0:bat[:any_1]):void 
BKCsetTransient;
Make the BAT transient.  Returns @boolean which indicates if the@BAT administration has indeed changed.
bat
single
pattern bat.single(X_0:any_1):bat[:any_1] 
CMDBATsingle;
Create a BAT with a single elemenet
bat
vacuum
command bat.vacuum(X_0:bat[:str]):bat[:str] 
CMDBATvacuum;
(empty)
bataggr
allnotequal
pattern bataggr.allnotequal(X_0:bat[:any_1], X_1:bat[:any_1]):bit 
SQLallnotequal;
(empty)
bataggr
anyequal
pattern bataggr.anyequal(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:bit] 
SQLanyequal;
(empty)
bataggr
exist
pattern bataggr.exist(X_0:any_1):bat[:bit] 
SQLexist;
(empty)
bataggr
exist
pattern bataggr.exist(X_0:bat[:any_1]):bat[:bit] 
SQLexist;
(empty)
bataggr
exist
pattern bataggr.exist(X_0:bat[:any_1]):bit 
SQLexist;
(empty)
bataggr
not_exist
pattern bataggr.not_exist(X_0:any_1):bat[:bit] 
SQLnot_exist;
(empty)
bataggr
not_exist
pattern bataggr.not_exist(X_0:bat[:any_1]):bat[:bit] 
SQLnot_exist;
(empty)
bataggr
not_exist
pattern bataggr.not_exist(X_0:bat[:any_1]):bit 
SQLnot_exist;
(empty)
batalgebra
like
pattern batalgebra.like(X_0:bat[:str], X_1:bat[:str], X_2:str, X_3:bit):bat[:bit] 
BATPCRElike;
(empty)
batalgebra
like
pattern batalgebra.like(X_0:bat[:str], X_1:str, X_2:str, X_3:bit):bat[:bit] 
BATPCRElike;
(empty)
batalgebra
like
pattern batalgebra.like(X_0:str, X_1:bat[:str], X_2:str, X_3:bit):bat[:bit] 
BATPCRElike;
(empty)
batalgebra
not_like
pattern batalgebra.not_like(X_0:bat[:str], X_1:bat[:str], X_2:str, X_3:bit):bat[:bit] 
BATPCREnotlike;
(empty)
batalgebra
not_like
pattern batalgebra.not_like(X_0:bat[:str], X_1:str, X_2:str, X_3:bit):bat[:bit] 
BATPCREnotlike;
(empty)
batalgebra
not_like
pattern batalgebra.not_like(X_0:str, X_1:bat[:str], X_2:str, X_3:bit):bat[:bit] 
BATPCREnotlike;
(empty)
batblob
nitems
pattern batblob.nitems(X_0:bat[:blob]):bat[:int] 
BLOBnitems_bulk;
(empty)
batblob
nitems
pattern batblob.nitems(X_0:bat[:blob], X_1:bat[:oid]):bat[:int] 
BLOBnitems_bulk;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:any_1, X_1:bat[:any_1]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:any_1, X_1:bat[:any_1], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:any_1], X_1:any_1):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:any_1], X_1:any_1, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:int]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:lng]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:sht]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:int):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:int, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:int, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:lng):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:lng, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:lng, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:sht):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:sht, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:bte], X_1:sht, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:date], X_1:bat[:date]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:date], X_1:bat[:date], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:date], X_1:bat[:date], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:date], X_1:bat[:date], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:date], X_1:date):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:date], X_1:date, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:date], X_1:date, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:date], X_1:date, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:daytime], X_1:bat[:daytime]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:daytime], X_1:daytime):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:daytime], X_1:daytime, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:daytime], X_1:daytime, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:daytime], X_1:daytime, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:inet], X_1:bat[:inet]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:inet], X_1:bat[:inet], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:inet], X_1:bat[:inet], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:inet], X_1:bat[:inet], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:inet], X_1:inet):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:inet], X_1:inet, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:inet], X_1:inet, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:inet], X_1:inet, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:bte]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:lng]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:sht]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bte):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bte, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:bte, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:lng):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:lng, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:lng, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:sht):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:sht, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:int], X_1:sht, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:json], X_1:bat[:json]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:json], X_1:bat[:json], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:json], X_1:bat[:json], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:json], X_1:bat[:json], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:json], X_1:json):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:json], X_1:json, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:json], X_1:json, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:json], X_1:json, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:bte]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:int]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:sht]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bte):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bte, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:bte, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:int):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:int, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:int, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:sht):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:sht, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:lng], X_1:sht, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:bte]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:int]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:lng]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bte):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bte, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:bte, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:int):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:int, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:int, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:lng):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:lng, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:sht], X_1:lng, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:timestamp], X_1:bat[:timestamp]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:timestamp], X_1:timestamp):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:timestamp], X_1:timestamp, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:timestamp], X_1:timestamp, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:timestamp], X_1:timestamp, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:uuid], X_1:bat[:uuid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:uuid], X_1:bat[:uuid], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:uuid], X_1:bat[:uuid], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:uuid], X_1:bat[:uuid], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:uuid], X_1:uuid):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:uuid], X_1:uuid, X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:uuid], X_1:uuid, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bat[:uuid], X_1:uuid, X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:int]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:int], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:lng]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:lng], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:sht]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:sht], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:bte, X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:date, X_1:bat[:date]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:date, X_1:bat[:date], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:date, X_1:bat[:date], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:date, X_1:bat[:date], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:daytime, X_1:bat[:daytime]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:daytime, X_1:bat[:daytime], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:daytime, X_1:bat[:daytime], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:daytime, X_1:bat[:daytime], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:inet, X_1:bat[:inet]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:inet, X_1:bat[:inet], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:inet, X_1:bat[:inet], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:inet, X_1:bat[:inet], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:bte]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:bte], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:lng]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:lng], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:sht]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:sht], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:int, X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:json, X_1:bat[:json]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:json, X_1:bat[:json], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:json, X_1:bat[:json], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:json, X_1:bat[:json], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:bte]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:bte], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:int]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:int], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:sht]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:sht], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:lng, X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:bte]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:bte], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:int]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:int], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:lng]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:lng], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:sht, X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:timestamp, X_1:bat[:timestamp]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:timestamp, X_1:bat[:timestamp], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:timestamp, X_1:bat[:timestamp], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:timestamp, X_1:bat[:timestamp], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:uuid, X_1:bat[:uuid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:uuid, X_1:bat[:uuid], X_2:bat[:oid]):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:uuid, X_1:bat[:uuid], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
!=
pattern batcalc.!=(X_0:uuid, X_1:bat[:uuid], X_2:bit):bat[:bit] 
CMDbatNE;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMODsignal;
(empty)
batcalc
%
pattern batcalc.%(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMODsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMULenlarge;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMULsignal;
(empty)
batcalc
*
pattern batcalc.*(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMULsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
CMDbatADD;
Return concatenation of B1 and B2 with candidates list
batcalc
+
pattern batcalc.+(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:str] 
CMDbatADD;
Return concatenation of B and V with candidates list
batcalc
+
pattern batcalc.+(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:str] 
CMDbatADD;
Return concatenation of V and B with candidates list
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatADDenlarge;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADDsignal;
(empty)
batcalc
+
pattern batcalc.+(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatADDsignal;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:bte]):bat[:bte] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:bte], X_1:bat[:oid]):bat[:bte] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:dbl]):bat[:dbl] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:flt]):bat[:flt] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:int]):bat[:int] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:int], X_1:bat[:oid]):bat[:int] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:lng]):bat[:lng] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:lng], X_1:bat[:oid]):bat[:lng] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:sht]):bat[:sht] 
CMDbatINCR;
(empty)
batcalc
++
pattern batcalc.++(X_0:bat[:sht], X_1:bat[:oid]):bat[:sht] 
CMDbatINCR;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte]):bat[:bte] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:oid]):bat[:bte] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl]):bat[:dbl] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt]):bat[:flt] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int]):bat[:int] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:oid]):bat[:int] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng]):bat[:lng] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:bat[:oid]):bat[:lng] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht]):bat[:sht] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:oid]):bat[:sht] 
CMDbatNEG;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBenlarge;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUBsignal;
(empty)
batcalc
-
pattern batcalc.-(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatSUBsignal;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:bte]):bat[:bte] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:bte], X_1:bat[:oid]):bat[:bte] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:dbl]):bat[:dbl] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:flt]):bat[:flt] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:int]):bat[:int] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:int], X_1:bat[:oid]):bat[:int] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:lng]):bat[:lng] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:lng], X_1:bat[:oid]):bat[:lng] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:sht]):bat[:sht] 
CMDbatDECR;
(empty)
batcalc
--
pattern batcalc.--(X_0:bat[:sht], X_1:bat[:oid]):bat[:sht] 
CMDbatDECR;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIVsignal;
(empty)
batcalc
/
pattern batcalc./(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatDIVsignal;
(empty)
batcalc
<
pattern batcalc.<(X_0:any_1, X_1:bat[:any_1]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:any_1], X_1:any_1):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:bat[:int]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:bat[:lng]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:bat[:sht]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:int):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:lng):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:sht):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:date], X_1:bat[:date]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:date], X_1:bat[:date], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:date], X_1:date):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:date], X_1:date, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:daytime], X_1:bat[:daytime]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:daytime], X_1:daytime):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:daytime], X_1:daytime, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:inet], X_1:bat[:inet]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:inet], X_1:bat[:inet], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:inet], X_1:inet):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:inet], X_1:inet, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:bat[:bte]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:bat[:lng]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:bat[:sht]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:bte):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:lng):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:sht):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:json], X_1:bat[:json]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:json], X_1:bat[:json], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:json], X_1:json):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:json], X_1:json, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:bat[:bte]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:bat[:int]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:bat[:sht]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:bte):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:int):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:sht):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:bat[:bte]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:bat[:int]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:bat[:lng]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:bte):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:int):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:lng):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:timestamp], X_1:bat[:timestamp]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:timestamp], X_1:timestamp):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:timestamp], X_1:timestamp, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:uuid], X_1:bat[:uuid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:uuid], X_1:bat[:uuid], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:uuid], X_1:uuid):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bat[:uuid], X_1:uuid, X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bte, X_1:bat[:int]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bte, X_1:bat[:lng]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bte, X_1:bat[:sht]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:date, X_1:bat[:date]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:date, X_1:bat[:date], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:daytime, X_1:bat[:daytime]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:daytime, X_1:bat[:daytime], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:inet, X_1:bat[:inet]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:inet, X_1:bat[:inet], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:int, X_1:bat[:bte]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:int, X_1:bat[:lng]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:int, X_1:bat[:sht]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:json, X_1:bat[:json]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:json, X_1:bat[:json], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:lng, X_1:bat[:bte]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:lng, X_1:bat[:int]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:lng, X_1:bat[:sht]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:sht, X_1:bat[:bte]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:sht, X_1:bat[:int]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:sht, X_1:bat[:lng]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:timestamp, X_1:bat[:timestamp]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:timestamp, X_1:bat[:timestamp], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:uuid, X_1:bat[:uuid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<
pattern batcalc.<(X_0:uuid, X_1:bat[:uuid], X_2:bat[:oid]):bat[:bit] 
CMDbatLT;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:bat[:bte]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:bat[:int]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:bat[:lng]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:bat[:sht]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:bte):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:int):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:lng):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:sht):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:bat[:bte]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:bat[:int]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:bat[:lng]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:bat[:sht]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:bte):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:int):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:lng):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:sht):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:bat[:bte]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:bat[:int]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:bat[:lng]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:bat[:sht]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:bte):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:int):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:lng):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:sht):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:bat[:bte]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:bat[:int]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:bat[:lng]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:bat[:sht]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:bte):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:int):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:lng):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:sht):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bte, X_1:bat[:bte]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bte, X_1:bat[:int]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bte, X_1:bat[:lng]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bte, X_1:bat[:sht]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:int, X_1:bat[:bte]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:int, X_1:bat[:int]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:int, X_1:bat[:lng]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:int, X_1:bat[:sht]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:lng, X_1:bat[:bte]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:lng, X_1:bat[:int]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:lng, X_1:bat[:lng]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:lng, X_1:bat[:sht]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:sht, X_1:bat[:bte]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:sht, X_1:bat[:int]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:sht, X_1:bat[:lng]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:sht, X_1:bat[:sht]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<<
pattern batcalc.<<(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatLSHsignal;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:any_1, X_1:bat[:any_1]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:any_1], X_1:any_1):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:bat[:int]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:bat[:lng]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:bat[:sht]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:int):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:lng):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:sht):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:date], X_1:bat[:date]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:date], X_1:bat[:date], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:date], X_1:date):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:date], X_1:date, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:daytime], X_1:bat[:daytime]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:daytime], X_1:daytime):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:daytime], X_1:daytime, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:inet], X_1:bat[:inet]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:inet], X_1:bat[:inet], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:inet], X_1:inet):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:inet], X_1:inet, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:bat[:bte]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:bat[:lng]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:bat[:sht]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:bte):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:lng):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:sht):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:json], X_1:bat[:json]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:json], X_1:bat[:json], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:json], X_1:json):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:json], X_1:json, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:bat[:bte]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:bat[:int]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:bat[:sht]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:bte):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:int):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:sht):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:bat[:bte]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:bat[:int]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:bat[:lng]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:bte):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:int):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:lng):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:timestamp], X_1:bat[:timestamp]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:timestamp], X_1:timestamp):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:timestamp], X_1:timestamp, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:uuid], X_1:bat[:uuid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:uuid], X_1:bat[:uuid], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:uuid], X_1:uuid):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bat[:uuid], X_1:uuid, X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bte, X_1:bat[:int]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bte, X_1:bat[:lng]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bte, X_1:bat[:sht]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:date, X_1:bat[:date]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:date, X_1:bat[:date], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:daytime, X_1:bat[:daytime]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:daytime, X_1:bat[:daytime], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:inet, X_1:bat[:inet]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:inet, X_1:bat[:inet], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:int, X_1:bat[:bte]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:int, X_1:bat[:lng]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:int, X_1:bat[:sht]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:json, X_1:bat[:json]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:json, X_1:bat[:json], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:lng, X_1:bat[:bte]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:lng, X_1:bat[:int]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:lng, X_1:bat[:sht]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:sht, X_1:bat[:bte]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:sht, X_1:bat[:int]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:sht, X_1:bat[:lng]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:timestamp, X_1:bat[:timestamp]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:timestamp, X_1:bat[:timestamp], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:uuid, X_1:bat[:uuid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
<=
pattern batcalc.<=(X_0:uuid, X_1:bat[:uuid], X_2:bat[:oid]):bat[:bit] 
CMDbatLE;
(empty)
batcalc
==
pattern batcalc.==(X_0:any_1, X_1:bat[:any_1]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:any_1, X_1:bat[:any_1], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:any_1], X_1:any_1):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:any_1], X_1:any_1, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:int]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:lng]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:sht]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:int):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:int, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:int, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:lng):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:lng, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:lng, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:sht):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:sht, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:bte], X_1:sht, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:date], X_1:bat[:date]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:date], X_1:bat[:date], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:date], X_1:bat[:date], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:date], X_1:bat[:date], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:date], X_1:date):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:date], X_1:date, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:date], X_1:date, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:date], X_1:date, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:daytime], X_1:bat[:daytime]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:daytime], X_1:daytime):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:daytime], X_1:daytime, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:daytime], X_1:daytime, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:daytime], X_1:daytime, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:inet], X_1:bat[:inet]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:inet], X_1:bat[:inet], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:inet], X_1:bat[:inet], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:inet], X_1:bat[:inet], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:inet], X_1:inet):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:inet], X_1:inet, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:inet], X_1:inet, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:inet], X_1:inet, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:bte]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:lng]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:sht]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bte):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bte, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:bte, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:lng):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:lng, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:lng, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:sht):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:sht, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:int], X_1:sht, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:json], X_1:bat[:json]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:json], X_1:bat[:json], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:json], X_1:bat[:json], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:json], X_1:bat[:json], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:json], X_1:json):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:json], X_1:json, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:json], X_1:json, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:json], X_1:json, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:bte]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:int]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:sht]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bte):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bte, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:bte, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:int):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:int, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:int, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:sht):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:sht, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:lng], X_1:sht, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:bte]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:int]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:lng]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bte):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bte, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:bte, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:int):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:int, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:int, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:lng):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:lng, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:sht], X_1:lng, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:timestamp], X_1:bat[:timestamp]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:timestamp], X_1:timestamp):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:timestamp], X_1:timestamp, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:timestamp], X_1:timestamp, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:timestamp], X_1:timestamp, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:uuid], X_1:bat[:uuid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:uuid], X_1:bat[:uuid], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:uuid], X_1:bat[:uuid], X_2:bat[:oid], X_3:bat[:oid], X_4:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:uuid], X_1:bat[:uuid], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:uuid], X_1:uuid):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:uuid], X_1:uuid, X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:uuid], X_1:uuid, X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bat[:uuid], X_1:uuid, X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:int]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:int], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:lng]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:lng], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:sht]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:sht], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:bte, X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:date, X_1:bat[:date]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:date, X_1:bat[:date], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:date, X_1:bat[:date], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:date, X_1:bat[:date], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:daytime, X_1:bat[:daytime]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:daytime, X_1:bat[:daytime], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:daytime, X_1:bat[:daytime], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:daytime, X_1:bat[:daytime], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:inet, X_1:bat[:inet]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:inet, X_1:bat[:inet], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:inet, X_1:bat[:inet], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:inet, X_1:bat[:inet], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:bte]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:bte], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:lng]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:lng], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:sht]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:sht], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:int, X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:json, X_1:bat[:json]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:json, X_1:bat[:json], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:json, X_1:bat[:json], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:json, X_1:bat[:json], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:bte]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:bte], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:int]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:int], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:sht]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:sht], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:lng, X_1:bat[:sht], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:bte]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:bte], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:bte], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:int]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:int], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:int], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:lng]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:lng], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:sht, X_1:bat[:lng], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:timestamp, X_1:bat[:timestamp]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:timestamp, X_1:bat[:timestamp], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:timestamp, X_1:bat[:timestamp], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:timestamp, X_1:bat[:timestamp], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:uuid, X_1:bat[:uuid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:uuid, X_1:bat[:uuid], X_2:bat[:oid]):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:uuid, X_1:bat[:uuid], X_2:bat[:oid], X_3:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
==
pattern batcalc.==(X_0:uuid, X_1:bat[:uuid], X_2:bit):bat[:bit] 
CMDbatEQ;
(empty)
batcalc
>
pattern batcalc.>(X_0:any_1, X_1:bat[:any_1]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:any_1], X_1:any_1):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:bat[:int]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:bat[:lng]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:bat[:sht]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:int):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:lng):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:sht):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:date], X_1:bat[:date]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:date], X_1:bat[:date], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:date], X_1:date):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:date], X_1:date, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:daytime], X_1:bat[:daytime]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:daytime], X_1:daytime):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:daytime], X_1:daytime, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:inet], X_1:bat[:inet]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:inet], X_1:bat[:inet], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:inet], X_1:inet):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:inet], X_1:inet, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:bat[:bte]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:bat[:lng]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:bat[:sht]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:bte):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:lng):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:sht):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:json], X_1:bat[:json]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:json], X_1:bat[:json], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:json], X_1:json):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:json], X_1:json, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:bat[:bte]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:bat[:int]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:bat[:sht]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:bte):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:int):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:sht):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:bat[:bte]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:bat[:int]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:bat[:lng]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:bte):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:int):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:lng):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:timestamp], X_1:bat[:timestamp]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:timestamp], X_1:timestamp):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:timestamp], X_1:timestamp, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:uuid], X_1:bat[:uuid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:uuid], X_1:bat[:uuid], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:uuid], X_1:uuid):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bat[:uuid], X_1:uuid, X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bte, X_1:bat[:int]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bte, X_1:bat[:lng]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bte, X_1:bat[:sht]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:date, X_1:bat[:date]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:date, X_1:bat[:date], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:daytime, X_1:bat[:daytime]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:daytime, X_1:bat[:daytime], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:inet, X_1:bat[:inet]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:inet, X_1:bat[:inet], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:int, X_1:bat[:bte]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:int, X_1:bat[:lng]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:int, X_1:bat[:sht]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:json, X_1:bat[:json]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:json, X_1:bat[:json], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:lng, X_1:bat[:bte]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:lng, X_1:bat[:int]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:lng, X_1:bat[:sht]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:sht, X_1:bat[:bte]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:sht, X_1:bat[:int]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:sht, X_1:bat[:lng]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:timestamp, X_1:bat[:timestamp]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:timestamp, X_1:bat[:timestamp], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:uuid, X_1:bat[:uuid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>
pattern batcalc.>(X_0:uuid, X_1:bat[:uuid], X_2:bat[:oid]):bat[:bit] 
CMDbatGT;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:any_1, X_1:bat[:any_1]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:any_1], X_1:any_1):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:bat[:int]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:bat[:lng]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:bat[:sht]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:int):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:lng):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:sht):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:date], X_1:bat[:date]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:date], X_1:bat[:date], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:date], X_1:date):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:date], X_1:date, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:daytime], X_1:bat[:daytime]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:daytime], X_1:daytime):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:daytime], X_1:daytime, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:inet], X_1:bat[:inet]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:inet], X_1:bat[:inet], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:inet], X_1:inet):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:inet], X_1:inet, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:bat[:bte]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:bat[:lng]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:bat[:sht]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:bte):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:lng):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:sht):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:json], X_1:bat[:json]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:json], X_1:bat[:json], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:json], X_1:json):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:json], X_1:json, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:bat[:bte]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:bat[:int]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:bat[:sht]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:bte):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:int):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:sht):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:bat[:bte]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:bat[:int]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:bat[:lng]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:bte):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:int):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:lng):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:timestamp], X_1:bat[:timestamp]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:timestamp], X_1:timestamp):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:timestamp], X_1:timestamp, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:uuid], X_1:bat[:uuid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:uuid], X_1:bat[:uuid], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:uuid], X_1:uuid):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bat[:uuid], X_1:uuid, X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bte, X_1:bat[:int]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bte, X_1:bat[:lng]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bte, X_1:bat[:sht]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:date, X_1:bat[:date]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:date, X_1:bat[:date], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:daytime, X_1:bat[:daytime]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:daytime, X_1:bat[:daytime], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:inet, X_1:bat[:inet]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:inet, X_1:bat[:inet], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:int, X_1:bat[:bte]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:int, X_1:bat[:lng]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:int, X_1:bat[:sht]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:json, X_1:bat[:json]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:json, X_1:bat[:json], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:lng, X_1:bat[:bte]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:lng, X_1:bat[:int]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:lng, X_1:bat[:sht]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:sht, X_1:bat[:bte]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:sht, X_1:bat[:int]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:sht, X_1:bat[:lng]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:timestamp, X_1:bat[:timestamp]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:timestamp, X_1:bat[:timestamp], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:uuid, X_1:bat[:uuid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>=
pattern batcalc.>=(X_0:uuid, X_1:bat[:uuid], X_2:bat[:oid]):bat[:bit] 
CMDbatGE;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:bat[:bte]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:bat[:int]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:bat[:lng]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:bat[:sht]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:bte):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:int):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:lng):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:sht):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:bat[:bte]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:bat[:int]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:bat[:lng]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:bat[:sht]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:bte):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:int):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:lng):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:sht):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:bat[:bte]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:bat[:int]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:bat[:lng]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:bat[:sht]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:bte):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:int):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:lng):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:sht):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:bat[:bte]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:bat[:int]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:bat[:lng]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:bat[:sht]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:bte):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:int):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:lng):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:sht):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bte, X_1:bat[:bte]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bte, X_1:bat[:int]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bte, X_1:bat[:lng]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bte, X_1:bat[:sht]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:int, X_1:bat[:bte]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:int, X_1:bat[:int]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:int, X_1:bat[:lng]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:int, X_1:bat[:sht]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:lng, X_1:bat[:bte]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:lng, X_1:bat[:int]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:lng, X_1:bat[:lng]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:lng, X_1:bat[:sht]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:sht, X_1:bat[:bte]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:sht, X_1:bat[:int]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:sht, X_1:bat[:lng]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:sht, X_1:bat[:sht]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
>>
pattern batcalc.>>(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatRSHsignal;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:bte]):bat[:bte] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:bte], X_1:bat[:oid]):bat[:bte] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:dbl]):bat[:dbl] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:flt]):bat[:flt] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:int]):bat[:int] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:int], X_1:bat[:oid]):bat[:int] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:lng]):bat[:lng] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:lng], X_1:bat[:oid]):bat[:lng] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:sht]):bat[:sht] 
CMDbatABS;
(empty)
batcalc
abs
pattern batcalc.abs(X_0:bat[:sht], X_1:bat[:oid]):bat[:sht] 
CMDbatABS;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatADD;
(empty)
batcalc
add_noerror
pattern batcalc.add_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatADD;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:bit], X_1:bat[:bit]):bat[:bit] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:bit], X_1:bat[:bit], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:bit], X_1:bit):bat[:bit] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:bit], X_1:bit, X_2:bat[:oid]):bat[:bit] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:bte], X_1:bat[:bte]):bat[:bte] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:bte], X_1:bte):bat[:bte] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:dbl], X_1:bat[:dbl]):bat[:dbl] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:dbl], X_1:dbl):bat[:dbl] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:flt], X_1:bat[:flt]):bat[:flt] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:flt], X_1:flt):bat[:flt] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:int], X_1:bat[:int]):bat[:int] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:int], X_1:int):bat[:int] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:lng], X_1:bat[:lng]):bat[:lng] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:lng], X_1:lng):bat[:lng] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:sht], X_1:bat[:sht]):bat[:sht] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:sht], X_1:sht):bat[:sht] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bit, X_1:bat[:bit]):bat[:bit] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bit, X_1:bat[:bit], X_2:bat[:oid]):bat[:bit] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bte, X_1:bat[:bte]):bat[:bte] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:dbl, X_1:bat[:dbl]):bat[:dbl] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:flt, X_1:bat[:flt]):bat[:flt] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:int, X_1:bat[:int]):bat[:int] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:lng, X_1:bat[:lng]):bat[:lng] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:sht, X_1:bat[:sht]):bat[:sht] 
CMDbatAND;
(empty)
batcalc
and
pattern batcalc.and(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatAND;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:bte]) (X_1:dbl, X_2:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:bte]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:bte], X_1:bat[:oid]) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:bte], X_1:bat[:oid]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:bte], X_1:bat[:oid], X_2:int) (X_3:dbl, X_4:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:bte], X_1:bat[:oid], X_2:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:bte], X_1:int) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:bte], X_1:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:dbl]) (X_1:dbl, X_2:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:dbl]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:dbl], X_1:bat[:oid]) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:dbl], X_1:bat[:oid]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:dbl], X_1:bat[:oid], X_2:int) (X_3:dbl, X_4:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:dbl], X_1:bat[:oid], X_2:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:dbl], X_1:int) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:dbl], X_1:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:flt]) (X_1:dbl, X_2:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:flt]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:flt], X_1:bat[:oid]) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:flt], X_1:bat[:oid]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:flt], X_1:bat[:oid], X_2:int) (X_3:dbl, X_4:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:flt], X_1:bat[:oid], X_2:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:flt], X_1:int) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:flt], X_1:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:int]) (X_1:dbl, X_2:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:int]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:int], X_1:bat[:oid]) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:int], X_1:bat[:oid]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:int], X_1:bat[:oid], X_2:int) (X_3:dbl, X_4:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:int], X_1:bat[:oid], X_2:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:int], X_1:int) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:int], X_1:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:lng]) (X_1:dbl, X_2:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:lng]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:lng], X_1:bat[:oid]) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:lng], X_1:bat[:oid]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:lng], X_1:bat[:oid], X_2:int) (X_3:dbl, X_4:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:lng], X_1:bat[:oid], X_2:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:lng], X_1:int) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:lng], X_1:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:sht]) (X_1:dbl, X_2:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:sht]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:sht], X_1:bat[:oid]) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:sht], X_1:bat[:oid]):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:sht], X_1:bat[:oid], X_2:int) (X_3:dbl, X_4:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:sht], X_1:bat[:oid], X_2:int):dbl 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:sht], X_1:int) (X_2:dbl, X_3:lng) 
CMDcalcavg;
(empty)
batcalc
avg
pattern batcalc.avg(X_0:bat[:sht], X_1:int):dbl 
CMDcalcavg;
(empty)
batcalc
between
pattern batcalc.between(X_0:bat[:any_1], X_1:any_1, X_2:any_1, X_3:bat[:oid], X_4:bit, X_5:bit, X_6:bit, X_7:bit, X_8:bit):bat[:bit] 
CMDbatBETWEEN;
B between V1 and V2 (or vice versa) with candidates list
batcalc
between
pattern batcalc.between(X_0:bat[:any_1], X_1:any_1, X_2:any_1, X_3:bit, X_4:bit, X_5:bit, X_6:bit, X_7:bit):bat[:bit] 
CMDbatBETWEEN;
B between V1 and V2 (or vice versa)
batcalc
between
pattern batcalc.between(X_0:bat[:any_1], X_1:any_1, X_2:bat[:any_1], X_3:bat[:oid], X_4:bat[:oid], X_5:bit, X_6:bit, X_7:bit, X_8:bit, X_9:bit):bat[:bit] 
CMDbatBETWEEN;
B between V1 and V2 (or vice versa) with candidates list
batcalc
between
pattern batcalc.between(X_0:bat[:any_1], X_1:any_1, X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:bit, X_6:bit, X_7:bit):bat[:bit] 
CMDbatBETWEEN;
B between V1 and V2 (or vice versa)
batcalc
between
pattern batcalc.between(X_0:bat[:any_1], X_1:bat[:any_1], X_2:any_1, X_3:bat[:oid], X_4:bat[:oid], X_5:bit, X_6:bit, X_7:bit, X_8:bit, X_9:bit):bat[:bit] 
CMDbatBETWEEN;
B between V1 and V2 (or vice versa) with candidates list
batcalc
between
pattern batcalc.between(X_0:bat[:any_1], X_1:bat[:any_1], X_2:any_1, X_3:bit, X_4:bit, X_5:bit, X_6:bit, X_7:bit):bat[:bit] 
CMDbatBETWEEN;
B between V1 and V2 (or vice versa)
batcalc
between
pattern batcalc.between(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:any_1], X_3:bat[:oid], X_4:bat[:oid], X_5:bat[:oid], X_6:bit, X_7:bit, X_8:bit, X_9:bit, X_10:bit):bat[:bit] 
CMDbatBETWEEN;
B between V1 and V2 (or vice versa) with candidates list
batcalc
between
pattern batcalc.between(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:any_1], X_3:bit, X_4:bit, X_5:bit, X_6:bit, X_7:bit):bat[:bit] 
CMDbatBETWEEN;
B between V1 and V2 (or vice versa)
batcalc
bit
pattern batcalc.bit(X_0:bat[:bit]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:bit], X_1:bat[:oid]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:bte]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:bte], X_1:bat[:oid]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:dbl]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:dbl], X_1:bat[:oid]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:flt]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:flt], X_1:bat[:oid]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:int]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:int], X_1:bat[:oid]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:lng]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:lng], X_1:bat[:oid]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:oid]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:oid], X_1:bat[:oid]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:sht]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:sht], X_1:bat[:oid]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:str]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit
pattern batcalc.bit(X_0:bat[:str], X_1:bat[:oid]):bat[:bit] 
CMDconvertsignal_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:bit]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:bit], X_1:bat[:oid]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:bte]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:bte], X_1:bat[:oid]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:dbl]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:dbl], X_1:bat[:oid]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:flt]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:flt], X_1:bat[:oid]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:int]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:int], X_1:bat[:oid]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:lng]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:lng], X_1:bat[:oid]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:oid]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:oid], X_1:bat[:oid]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:sht]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:sht], X_1:bat[:oid]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:str]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
bit_noerror
pattern batcalc.bit_noerror(X_0:bat[:str], X_1:bat[:oid]):bat[:bit] 
CMDconvert_bit;
(empty)
batcalc
blob
command batcalc.blob(X_0:bat[:blob], X_1:bat[:oid]):bat[:blob] 
BLOBblob_blob_bulk;
(empty)
batcalc
blob
command batcalc.blob(X_0:bat[:str], X_1:bat[:oid]):bat[:blob] 
batstr_2_blob;
cast to blob
batcalc
bte
pattern batcalc.bte(X_0:bat[:bit]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:bit], X_1:bat[:oid]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:bte]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:bte], X_1:bat[:oid]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:dbl]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:dbl], X_1:bat[:oid]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:flt]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:flt], X_1:bat[:oid]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:int]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:int], X_1:bat[:oid]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:lng]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:lng], X_1:bat[:oid]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:oid]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:oid], X_1:bat[:oid]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:sht]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:sht], X_1:bat[:oid]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:str]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
pattern batcalc.bte(X_0:bat[:str], X_1:bat[:oid]):bat[:bte] 
CMDconvertsignal_bte;
(empty)
batcalc
bte
command batcalc.bte(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
batbte_dec2_bte;
cast decimal(bte) to bte and check for overflow
batcalc
bte
command batcalc.bte(X_0:int, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:bte] 
batbte_dec2dec_bte;
cast decimal(bte) to decimal(bte) and check for overflow
batcalc
bte
command batcalc.bte(X_0:bat[:bte], X_1:bat[:oid], X_2:int, X_3:int):bat[:bte] 
batbte_num2dec_bte;
cast number to decimal(bte) and check for overflow
batcalc
bte
command batcalc.bte(X_0:bat[:dbl], X_1:bat[:oid], X_2:int, X_3:int):bat[:bte] 
batdbl_num2dec_bte;
cast number to decimal(bte) and check for overflow
batcalc
bte
command batcalc.bte(X_0:bat[:flt], X_1:bat[:oid], X_2:int, X_3:int):bat[:bte] 
batflt_num2dec_bte;
cast number to decimal(bte) and check for overflow
batcalc
bte
command batcalc.bte(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
batint_dec2_bte;
cast decimal(int) to bte and check for overflow
batcalc
bte
command batcalc.bte(X_0:int, X_1:bat[:int], X_2:bat[:oid], X_3:int, X_4:int):bat[:bte] 
batint_dec2dec_bte;
cast decimal(int) to decimal(bte) and check for overflow
batcalc
bte
command batcalc.bte(X_0:bat[:int], X_1:bat[:oid], X_2:int, X_3:int):bat[:bte] 
batint_num2dec_bte;
cast number to decimal(bte) and check for overflow
batcalc
bte
command batcalc.bte(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
batlng_dec2_bte;
cast decimal(lng) to bte and check for overflow
batcalc
bte
command batcalc.bte(X_0:int, X_1:bat[:lng], X_2:bat[:oid], X_3:int, X_4:int):bat[:bte] 
batlng_dec2dec_bte;
cast decimal(lng) to decimal(bte) and check for overflow
batcalc
bte
command batcalc.bte(X_0:bat[:lng], X_1:bat[:oid], X_2:int, X_3:int):bat[:bte] 
batlng_num2dec_bte;
cast number to decimal(bte) and check for overflow
batcalc
bte
command batcalc.bte(X_0:bat[:oid], X_1:int, X_2:int):bat[:bte] 
batnil_2dec_bte;
cast to dec(bte) and check for overflow
batcalc
bte
command batcalc.bte(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
batsht_dec2_bte;
cast decimal(sht) to bte and check for overflow
batcalc
bte
command batcalc.bte(X_0:int, X_1:bat[:sht], X_2:bat[:oid], X_3:int, X_4:int):bat[:bte] 
batsht_dec2dec_bte;
cast decimal(sht) to decimal(bte) and check for overflow
batcalc
bte
command batcalc.bte(X_0:bat[:sht], X_1:bat[:oid], X_2:int, X_3:int):bat[:bte] 
batsht_num2dec_bte;
cast number to decimal(bte) and check for overflow
batcalc
bte
pattern batcalc.bte(X_0:bat[:str], X_1:bat[:oid], X_2:int, X_3:int):bat[:bte] 
batstr_2dec_bte;
cast to dec(bte) and check for overflow
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:bit]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:bit], X_1:bat[:oid]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:bte]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:bte], X_1:bat[:oid]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:dbl]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:dbl], X_1:bat[:oid]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:flt]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:flt], X_1:bat[:oid]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:int]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:int], X_1:bat[:oid]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:lng]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:lng], X_1:bat[:oid]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:oid]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:oid], X_1:bat[:oid]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:sht]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:sht], X_1:bat[:oid]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:str]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
bte_noerror
pattern batcalc.bte_noerror(X_0:bat[:str], X_1:bat[:oid]):bat[:bte] 
CMDconvert_bte;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bit], X_1:bat[:bit]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bit], X_1:bat[:bit], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bit], X_1:bit):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bit], X_1:bit, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bte):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:dbl):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:flt):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:int):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:lng):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:sht):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bte):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:dbl):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:flt):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:int):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:lng):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:sht):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bte):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:dbl):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:flt):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:int):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:lng):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:sht):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bte):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:dbl):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:flt):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:int):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:lng):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:sht):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bte):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:dbl):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:flt):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:int):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:lng):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:sht):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:oid], X_1:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:oid], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:oid], X_1:oid):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:oid], X_1:oid, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bte):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:dbl):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:flt):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:int):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:lng):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:sht):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:str], X_1:bat[:str]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:str], X_1:str):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bit, X_1:bat[:bit]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bit, X_1:bat[:bit], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:oid, X_1:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:oid, X_1:bat[:oid], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:bte]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:dbl]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:flt]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:int]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:lng]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:sht]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:str, X_1:bat[:str]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
cmp
pattern batcalc.cmp(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:bte] 
CMDbatCMP;
(empty)
batcalc
date
pattern batcalc.date(X_0:bat[:date], X_1:bat[:oid]):bat[:date] 
MTIMEdate_date_bulk;
(empty)
batcalc
date
pattern batcalc.date(X_0:bat[:str], X_1:bat[:oid]):bat[:date] 
MTIMEdate_fromstr_bulk;
(empty)
batcalc
date
pattern batcalc.date(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:date] 
MTIMEtimestamp_extract_date_bulk;
(empty)
batcalc
date
command batcalc.date(X_0:bat[:str], X_1:bat[:oid]):bat[:date] 
batstr_2_date;
cast to date
batcalc
date
pattern batcalc.date(X_0:bat[:oid]):bat[:date] 
nil_2_date;
cast to date
batcalc
daytime
pattern batcalc.daytime(X_0:bat[:daytime], X_1:bat[:oid]):bat[:daytime] 
MTIMEdaytime_daytime_bulk;
(empty)
batcalc
daytime
pattern batcalc.daytime(X_0:bat[:lng], X_1:bat[:oid]):bat[:daytime] 
MTIMEdaytime_fromseconds_bulk;
(empty)
batcalc
daytime
pattern batcalc.daytime(X_0:bat[:str], X_1:bat[:oid]):bat[:daytime] 
MTIMEdaytime_fromstr_bulk;
(empty)
batcalc
daytime
pattern batcalc.daytime(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:daytime] 
MTIMEtimestamp_extract_daytime_bulk;
(empty)
batcalc
daytime
command batcalc.daytime(X_0:bat[:str], X_1:bat[:oid], X_2:int):bat[:daytime] 
batstr_2time_daytime;
cast to daytime and check for overflow
batcalc
daytime
pattern batcalc.daytime(X_0:bat[:daytime], X_1:bat[:oid], X_2:int):bat[:daytime] 
daytime_2time_daytime;
cast daytime to daytime and check for overflow
batcalc
daytime
pattern batcalc.daytime(X_0:bat[:oid], X_1:int):bat[:daytime] 
nil_2time_daytime;
cast to daytime and check for overflow
batcalc
daytime
pattern batcalc.daytime(X_0:bat[:lng], X_1:bat[:oid], X_2:int):bat[:daytime] 
second_interval_2_daytime;
cast second_interval to a daytime and check for overflow
batcalc
daytime
pattern batcalc.daytime(X_0:bat[:str], X_1:bat[:oid], X_2:int, X_3:int):bat[:daytime] 
str_2time_daytimetz;
cast daytime to daytime and check for overflow
batcalc
daytime
pattern batcalc.daytime(X_0:bat[:timestamp], X_1:bat[:oid], X_2:int):bat[:daytime] 
timestamp_2_daytime;
cast timestamp to a daytime and check for overflow
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:bit]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:bit], X_1:bat[:oid]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:bte]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:bte], X_1:bat[:oid]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:dbl]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:flt]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:flt], X_1:bat[:oid]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:int]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:int], X_1:bat[:oid]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:lng]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:lng], X_1:bat[:oid]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:oid]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:oid], X_1:bat[:oid]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:sht]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:sht], X_1:bat[:oid]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:str]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
pattern batcalc.dbl(X_0:bat[:str], X_1:bat[:oid]):bat[:dbl] 
CMDconvertsignal_dbl;
(empty)
batcalc
dbl
command batcalc.dbl(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
batbte_dec2_dbl;
cast decimal(bte) to dbl and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:int, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:dbl] 
batbte_dec2dec_dbl;
cast decimal(bte) to decimal(dbl) and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:bat[:bte], X_1:bat[:oid], X_2:int, X_3:int):bat[:dbl] 
batbte_num2dec_dbl;
cast number to decimal(dbl) and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
batint_dec2_dbl;
cast decimal(int) to dbl and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:int, X_1:bat[:int], X_2:bat[:oid], X_3:int, X_4:int):bat[:dbl] 
batint_dec2dec_dbl;
cast decimal(int) to decimal(dbl) and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:bat[:int], X_1:bat[:oid], X_2:int, X_3:int):bat[:dbl] 
batint_num2dec_dbl;
cast number to decimal(dbl) and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
batlng_dec2_dbl;
cast decimal(lng) to dbl and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:int, X_1:bat[:lng], X_2:bat[:oid], X_3:int, X_4:int):bat[:dbl] 
batlng_dec2dec_dbl;
cast decimal(lng) to decimal(dbl) and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:bat[:lng], X_1:bat[:oid], X_2:int, X_3:int):bat[:dbl] 
batlng_num2dec_dbl;
cast number to decimal(dbl) and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
batsht_dec2_dbl;
cast decimal(sht) to dbl and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:int, X_1:bat[:sht], X_2:bat[:oid], X_3:int, X_4:int):bat[:dbl] 
batsht_dec2dec_dbl;
cast decimal(sht) to decimal(dbl) and check for overflow
batcalc
dbl
command batcalc.dbl(X_0:bat[:sht], X_1:bat[:oid], X_2:int, X_3:int):bat[:dbl] 
batsht_num2dec_dbl;
cast number to decimal(dbl) and check for overflow
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:bit]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:bit], X_1:bat[:oid]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:bte]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:bte], X_1:bat[:oid]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:dbl]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:flt]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:flt], X_1:bat[:oid]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:int]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:int], X_1:bat[:oid]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:lng]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:lng], X_1:bat[:oid]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:oid]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:oid], X_1:bat[:oid]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:sht]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:sht], X_1:bat[:oid]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:str]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dbl_noerror
pattern batcalc.dbl_noerror(X_0:bat[:str], X_1:bat[:oid]):bat[:dbl] 
CMDconvert_dbl;
(empty)
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:bte], X_1:bte):bat[:bte] 
bte_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
bte_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bte, X_1:bat[:bte]):bat[:bte] 
bte_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
bte_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:bte], X_1:bat[:bte]):bat[:bte] 
bte_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
bte_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:dbl], X_1:dbl):bat[:dbl] 
dbl_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
dbl_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:dbl, X_1:bat[:dbl]):bat[:dbl] 
dbl_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
dbl_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:dbl], X_1:bat[:dbl]):bat[:dbl] 
dbl_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
dbl_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:flt], X_1:flt):bat[:flt] 
flt_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
flt_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:flt, X_1:bat[:flt]):bat[:flt] 
flt_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
flt_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:flt], X_1:bat[:flt]):bat[:flt] 
flt_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
flt_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:int], X_1:int):bat[:int] 
int_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
int_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:int, X_1:bat[:int]):bat[:int] 
int_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
int_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:int], X_1:bat[:int]):bat[:int] 
int_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
int_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:lng], X_1:lng):bat[:lng] 
lng_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
lng_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:lng, X_1:bat[:lng]):bat[:lng] 
lng_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
lng_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:lng], X_1:bat[:lng]):bat[:lng] 
lng_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
lng_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:sht], X_1:sht):bat[:sht] 
sht_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
sht_bat_dec_round_wrap;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:sht, X_1:bat[:sht]):bat[:sht] 
sht_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
sht_bat_dec_round_wrap_cst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:sht], X_1:bat[:sht]):bat[:sht] 
sht_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
dec_round
pattern batcalc.dec_round(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
sht_bat_dec_round_wrap_nocst;
round off the value v to nearests multiple of r
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatDIV;
(empty)
batcalc
div_noerror
pattern batcalc.div_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatDIV;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:bit]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:bit], X_1:bat[:oid]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:bte]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:bte], X_1:bat[:oid]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:dbl]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:dbl], X_1:bat[:oid]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:flt]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:int]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:int], X_1:bat[:oid]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:lng]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:lng], X_1:bat[:oid]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:oid]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:oid], X_1:bat[:oid]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:sht]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:sht], X_1:bat[:oid]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:str]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
pattern batcalc.flt(X_0:bat[:str], X_1:bat[:oid]):bat[:flt] 
CMDconvertsignal_flt;
(empty)
batcalc
flt
command batcalc.flt(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
batbte_dec2_flt;
cast decimal(bte) to flt and check for overflow
batcalc
flt
command batcalc.flt(X_0:int, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:flt] 
batbte_dec2dec_flt;
cast decimal(bte) to decimal(flt) and check for overflow
batcalc
flt
command batcalc.flt(X_0:bat[:bte], X_1:bat[:oid], X_2:int, X_3:int):bat[:flt] 
batbte_num2dec_flt;
cast number to decimal(flt) and check for overflow
batcalc
flt
command batcalc.flt(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
batint_dec2_flt;
cast decimal(int) to flt and check for overflow
batcalc
flt
command batcalc.flt(X_0:int, X_1:bat[:int], X_2:bat[:oid], X_3:int, X_4:int):bat[:flt] 
batint_dec2dec_flt;
cast decimal(int) to decimal(flt) and check for overflow
batcalc
flt
command batcalc.flt(X_0:bat[:int], X_1:bat[:oid], X_2:int, X_3:int):bat[:flt] 
batint_num2dec_flt;
cast number to decimal(flt) and check for overflow
batcalc
flt
command batcalc.flt(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:flt] 
batlng_dec2_flt;
cast decimal(lng) to flt and check for overflow
batcalc
flt
command batcalc.flt(X_0:int, X_1:bat[:lng], X_2:bat[:oid], X_3:int, X_4:int):bat[:flt] 
batlng_dec2dec_flt;
cast decimal(lng) to decimal(flt) and check for overflow
batcalc
flt
command batcalc.flt(X_0:bat[:lng], X_1:bat[:oid], X_2:int, X_3:int):bat[:flt] 
batlng_num2dec_flt;
cast number to decimal(flt) and check for overflow
batcalc
flt
command batcalc.flt(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
batsht_dec2_flt;
cast decimal(sht) to flt and check for overflow
batcalc
flt
command batcalc.flt(X_0:int, X_1:bat[:sht], X_2:bat[:oid], X_3:int, X_4:int):bat[:flt] 
batsht_dec2dec_flt;
cast decimal(sht) to decimal(flt) and check for overflow
batcalc
flt
command batcalc.flt(X_0:bat[:sht], X_1:bat[:oid], X_2:int, X_3:int):bat[:flt] 
batsht_num2dec_flt;
cast number to decimal(flt) and check for overflow
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:bit]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:bit], X_1:bat[:oid]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:bte]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:bte], X_1:bat[:oid]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:dbl]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:dbl], X_1:bat[:oid]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:flt]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:int]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:int], X_1:bat[:oid]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:lng]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:lng], X_1:bat[:oid]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:oid]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:oid], X_1:bat[:oid]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:sht]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:sht], X_1:bat[:oid]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:str]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
flt_noerror
pattern batcalc.flt_noerror(X_0:bat[:str], X_1:bat[:oid]):bat[:flt] 
CMDconvert_flt;
(empty)
batcalc
hash
command batcalc.hash(X_0:bat[:any_1]):bat[:lng] 
MKEYbathash;
(empty)
batcalc
hash
command batcalc.hash(X_0:bat[:bte]):bat[:lng] 
MKEYbathash;
(empty)
batcalc
hash
command batcalc.hash(X_0:bat[:dbl]):bat[:lng] 
MKEYbathash;
(empty)
batcalc
hash
command batcalc.hash(X_0:bat[:flt]):bat[:lng] 
MKEYbathash;
(empty)
batcalc
hash
command batcalc.hash(X_0:bat[:int]):bat[:lng] 
MKEYbathash;
(empty)
batcalc
hash
command batcalc.hash(X_0:bat[:lng]):bat[:lng] 
MKEYbathash;
(empty)
batcalc
hash
command batcalc.hash(X_0:bat[:lng]):bat[:lng] 
MKEYbathash;
(empty)
batcalc
hash
command batcalc.hash(X_0:bat[:oid]):bat[:lng] 
MKEYbathash;
(empty)
batcalc
hash
command batcalc.hash(X_0:bat[:sht]):bat[:lng] 
MKEYbathash;
(empty)
batcalc
identity
command batcalc.identity(X_0:bat[:any]):bat[:oid] 
BATSQLidentity;
Returns the unique row identitfiers.
batcalc
identity
pattern batcalc.identity(X_0:bat[:any], X_1:oid) (X_2:bat[:oid], X_3:oid) 
PBATSQLidentity;
Returns the unique row identitfiers.
batcalc
ifthenelse
pattern batcalc.ifthenelse(X_0:bat[:bit], X_1:any_1, X_2:any_1):bat[:any_1] 
CMDifthen;
If-then-else operation to assemble a conditional result
batcalc
ifthenelse
pattern batcalc.ifthenelse(X_0:bat[:bit], X_1:any_1, X_2:bat[:any_1]):bat[:any_1] 
CMDifthen;
If-then-else operation to assemble a conditional result
batcalc
ifthenelse
pattern batcalc.ifthenelse(X_0:bat[:bit], X_1:bat[:any_1], X_2:any_1):bat[:any_1] 
CMDifthen;
If-then-else operation to assemble a conditional result
batcalc
ifthenelse
pattern batcalc.ifthenelse(X_0:bat[:bit], X_1:bat[:any_1], X_2:bat[:any_1]):bat[:any_1] 
CMDifthen;
If-then-else operation to assemble a conditional result
batcalc
ifthenelse
pattern batcalc.ifthenelse(X_0:bit, X_1:any_1, X_2:bat[:any_1]):bat[:any_1] 
CMDifthen;
If-then-else operation to assemble a conditional result
batcalc
ifthenelse
pattern batcalc.ifthenelse(X_0:bit, X_1:bat[:any_1], X_2:any_1):bat[:any_1] 
CMDifthen;
If-then-else operation to assemble a conditional result
batcalc
ifthenelse
pattern batcalc.ifthenelse(X_0:bit, X_1:bat[:any_1], X_2:bat[:any_1]):bat[:any_1] 
CMDifthen;
If-then-else operation to assemble a conditional result
batcalc
int
pattern batcalc.int(X_0:bat[:bit]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:bit], X_1:bat[:oid]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:bte]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:bte], X_1:bat[:oid]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:dbl]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:dbl], X_1:bat[:oid]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:flt]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:flt], X_1:bat[:oid]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:int]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:int], X_1:bat[:oid]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:lng]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:lng], X_1:bat[:oid]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:oid]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:oid], X_1:bat[:oid]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:sht]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:sht], X_1:bat[:oid]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:str]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
pattern batcalc.int(X_0:bat[:str], X_1:bat[:oid]):bat[:int] 
CMDconvertsignal_int;
(empty)
batcalc
int
command batcalc.int(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
batbte_dec2_int;
cast decimal(bte) to int and check for overflow
batcalc
int
command batcalc.int(X_0:int, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:int] 
batbte_dec2dec_int;
cast decimal(bte) to decimal(int) and check for overflow
batcalc
int
command batcalc.int(X_0:bat[:bte], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
batbte_num2dec_int;
cast number to decimal(int) and check for overflow
batcalc
int
command batcalc.int(X_0:bat[:dbl], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
batdbl_num2dec_int;
cast number to decimal(int) and check for overflow
batcalc
int
command batcalc.int(X_0:bat[:flt], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
batflt_num2dec_int;
cast number to decimal(int) and check for overflow
batcalc
int
command batcalc.int(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
batint_dec2_int;
cast decimal(int) to int and check for overflow
batcalc
int
command batcalc.int(X_0:int, X_1:bat[:int], X_2:bat[:oid], X_3:int, X_4:int):bat[:int] 
batint_dec2dec_int;
cast decimal(int) to decimal(int) and check for overflow
batcalc
int
command batcalc.int(X_0:bat[:int], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
batint_num2dec_int;
cast number to decimal(int) and check for overflow
batcalc
int
command batcalc.int(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
batlng_dec2_int;
cast decimal(lng) to int and check for overflow
batcalc
int
command batcalc.int(X_0:int, X_1:bat[:lng], X_2:bat[:oid], X_3:int, X_4:int):bat[:int] 
batlng_dec2dec_int;
cast decimal(lng) to decimal(int) and check for overflow
batcalc
int
command batcalc.int(X_0:bat[:lng], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
batlng_num2dec_int;
cast number to decimal(int) and check for overflow
batcalc
int
command batcalc.int(X_0:bat[:oid], X_1:int, X_2:int):bat[:int] 
batnil_2dec_int;
cast to dec(int) and check for overflow
batcalc
int
command batcalc.int(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
batsht_dec2_int;
cast decimal(sht) to int and check for overflow
batcalc
int
command batcalc.int(X_0:int, X_1:bat[:sht], X_2:bat[:oid], X_3:int, X_4:int):bat[:int] 
batsht_dec2dec_int;
cast decimal(sht) to decimal(int) and check for overflow
batcalc
int
command batcalc.int(X_0:bat[:sht], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
batsht_num2dec_int;
cast number to decimal(int) and check for overflow
batcalc
int
pattern batcalc.int(X_0:bat[:str], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
batstr_2dec_int;
cast to dec(int) and check for overflow
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:bit]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:bit], X_1:bat[:oid]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:bte]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:bte], X_1:bat[:oid]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:dbl]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:dbl], X_1:bat[:oid]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:flt]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:flt], X_1:bat[:oid]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:int]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:int], X_1:bat[:oid]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:lng]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:lng], X_1:bat[:oid]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:oid]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:oid], X_1:bat[:oid]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:sht]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:sht], X_1:bat[:oid]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:str]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
int_noerror
pattern batcalc.int_noerror(X_0:bat[:str], X_1:bat[:oid]):bat[:int] 
CMDconvert_int;
(empty)
batcalc
isnil
pattern batcalc.isnil(X_0:bat[:any]):bat[:bit] 
CMDbatISNIL;
Unary check for nil over the tail of the bat
batcalc
isnil
pattern batcalc.isnil(X_0:bat[:any], X_1:bat[:oid]):bat[:bit] 
CMDbatISNIL;
Unary check for nil over the tail of the bat with candidates list
batcalc
isnotnil
pattern batcalc.isnotnil(X_0:bat[:any]):bat[:bit] 
CMDbatISNOTNIL;
Unary check for notnil over the tail of the bat
batcalc
isnotnil
pattern batcalc.isnotnil(X_0:bat[:any], X_1:bat[:oid]):bat[:bit] 
CMDbatISNOTNIL;
Unary check for notnil over the tail of the bat with candidates list
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:bte]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:bte], X_1:bat[:oid]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:dbl]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:dbl], X_1:bat[:oid]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:flt]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:flt], X_1:bat[:oid]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:int]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:int], X_1:bat[:oid]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:lng]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:lng], X_1:bat[:oid]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:sht]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
iszero
pattern batcalc.iszero(X_0:bat[:sht], X_1:bat[:oid]):bat[:bit] 
CMDbatISZERO;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:bit]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:bit], X_1:bat[:oid]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:bte]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:bte], X_1:bat[:oid]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:dbl]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:dbl], X_1:bat[:oid]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:flt]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:flt], X_1:bat[:oid]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:int]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:int], X_1:bat[:oid]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:lng]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:lng], X_1:bat[:oid]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:oid]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:oid], X_1:bat[:oid]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:sht]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:sht], X_1:bat[:oid]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:str]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
pattern batcalc.lng(X_0:bat[:str], X_1:bat[:oid]):bat[:lng] 
CMDconvertsignal_lng;
(empty)
batcalc
lng
command batcalc.lng(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
batbte_dec2_lng;
cast decimal(bte) to lng and check for overflow
batcalc
lng
command batcalc.lng(X_0:int, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:lng] 
batbte_dec2dec_lng;
cast decimal(bte) to decimal(lng) and check for overflow
batcalc
lng
command batcalc.lng(X_0:bat[:bte], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
batbte_num2dec_lng;
cast number to decimal(lng) and check for overflow
batcalc
lng
command batcalc.lng(X_0:bat[:dbl], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
batdbl_num2dec_lng;
cast number to decimal(lng) and check for overflow
batcalc
lng
command batcalc.lng(X_0:bat[:flt], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
batflt_num2dec_lng;
cast number to decimal(lng) and check for overflow
batcalc
lng
command batcalc.lng(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
batint_dec2_lng;
cast decimal(int) to lng and check for overflow
batcalc
lng
command batcalc.lng(X_0:int, X_1:bat[:int], X_2:bat[:oid], X_3:int, X_4:int):bat[:lng] 
batint_dec2dec_lng;
cast decimal(int) to decimal(lng) and check for overflow
batcalc
lng
command batcalc.lng(X_0:bat[:int], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
batint_num2dec_lng;
cast number to decimal(lng) and check for overflow
batcalc
lng
command batcalc.lng(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
batlng_dec2_lng;
cast decimal(lng) to lng and check for overflow
batcalc
lng
command batcalc.lng(X_0:int, X_1:bat[:lng], X_2:bat[:oid], X_3:int, X_4:int):bat[:lng] 
batlng_dec2dec_lng;
cast decimal(lng) to decimal(lng) and check for overflow
batcalc
lng
command batcalc.lng(X_0:bat[:lng], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
batlng_num2dec_lng;
cast number to decimal(lng) and check for overflow
batcalc
lng
command batcalc.lng(X_0:bat[:oid], X_1:int, X_2:int):bat[:lng] 
batnil_2dec_lng;
cast to dec(lng) and check for overflow
batcalc
lng
command batcalc.lng(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
batsht_dec2_lng;
cast decimal(sht) to lng and check for overflow
batcalc
lng
command batcalc.lng(X_0:int, X_1:bat[:sht], X_2:bat[:oid], X_3:int, X_4:int):bat[:lng] 
batsht_dec2dec_lng;
cast decimal(sht) to decimal(lng) and check for overflow
batcalc
lng
command batcalc.lng(X_0:bat[:sht], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
batsht_num2dec_lng;
cast number to decimal(lng) and check for overflow
batcalc
lng
pattern batcalc.lng(X_0:bat[:str], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
batstr_2dec_lng;
cast to dec(lng) and check for overflow
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:bit]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:bit], X_1:bat[:oid]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:bte]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:bte], X_1:bat[:oid]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:dbl]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:dbl], X_1:bat[:oid]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:flt]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:flt], X_1:bat[:oid]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:int]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:int], X_1:bat[:oid]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:lng]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:lng], X_1:bat[:oid]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:oid]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:oid], X_1:bat[:oid]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:sht]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:sht], X_1:bat[:oid]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:str]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lng_noerror
pattern batcalc.lng_noerror(X_0:bat[:str], X_1:bat[:oid]):bat[:lng] 
CMDconvert_lng;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:bat[:bte]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:bat[:int]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:bat[:lng]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:bat[:sht]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:bte):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:int):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:lng):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:sht):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:bat[:bte]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:bat[:int]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:bat[:lng]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:bat[:sht]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:bte):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:int):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:lng):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:sht):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:bat[:bte]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:bat[:int]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:bat[:lng]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:bat[:sht]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:bte):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:int):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:lng):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:sht):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:bat[:bte]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:bat[:int]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:bat[:lng]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:bat[:sht]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:bte):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:int):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:lng):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:sht):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bte, X_1:bat[:bte]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bte, X_1:bat[:int]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bte, X_1:bat[:lng]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bte, X_1:bat[:sht]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:int, X_1:bat[:bte]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:int, X_1:bat[:int]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:int, X_1:bat[:lng]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:int, X_1:bat[:sht]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:lng, X_1:bat[:bte]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:lng, X_1:bat[:int]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:lng, X_1:bat[:lng]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:lng, X_1:bat[:sht]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:sht, X_1:bat[:bte]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:sht, X_1:bat[:int]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:sht, X_1:bat[:lng]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:sht, X_1:bat[:sht]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
lsh_noerror
pattern batcalc.lsh_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatLSH;
(empty)
batcalc
max
pattern batcalc.max(X_0:any_1, X_1:bat[:any_1]):bat[:any_1] 
CMDbatMAX;
Return bat with maximum value of each pair of inputs
batcalc
max
pattern batcalc.max(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid]):bat[:any_1] 
CMDbatMAX;
Return bat with maximum value of each pair of inputs
batcalc
max
pattern batcalc.max(X_0:bat[:any_1], X_1:any_1):bat[:any_1] 
CMDbatMAX;
Return bat with maximum value of each pair of inputs
batcalc
max
pattern batcalc.max(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid]):bat[:any_1] 
CMDbatMAX;
Return bat with maximum value of each pair of inputs
batcalc
max
pattern batcalc.max(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:any_1] 
CMDbatMAX;
Return bat with maximum value of each pair of inputs
batcalc
max
pattern batcalc.max(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid]):bat[:any_1] 
CMDbatMAX;
Return bat with maximum value of each pair of inputs
batcalc
max_no_nil
pattern batcalc.max_no_nil(X_0:any_1, X_1:bat[:any_1]):bat[:any_1] 
CMDbatMAX_no_nil;
Return bat with maximum value of each pair of inputs, ignoring nil values
batcalc
max_no_nil
pattern batcalc.max_no_nil(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid]):bat[:any_1] 
CMDbatMAX_no_nil;
Return bat with maximum value of each pair of inputs, ignoring nil values
batcalc
max_no_nil
pattern batcalc.max_no_nil(X_0:bat[:any_1], X_1:any_1):bat[:any_1] 
CMDbatMAX_no_nil;
Return bat with maximum value of each pair of inputs, ignoring nil values
batcalc
max_no_nil
pattern batcalc.max_no_nil(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid]):bat[:any_1] 
CMDbatMAX_no_nil;
Return bat with maximum value of each pair of inputs, ignoring nil values
batcalc
max_no_nil
pattern batcalc.max_no_nil(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:any_1] 
CMDbatMAX_no_nil;
Return bat with maximum value of each pair of inputs, ignoring nil values
batcalc
max_no_nil
pattern batcalc.max_no_nil(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid]):bat[:any_1] 
CMDbatMAX_no_nil;
Return bat with maximum value of each pair of inputs, ignoring nil values
batcalc
min
pattern batcalc.min(X_0:any_1, X_1:bat[:any_1]):bat[:any_1] 
CMDbatMIN;
Return bat with minimum value of each pair of inputs
batcalc
min
pattern batcalc.min(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid]):bat[:any_1] 
CMDbatMIN;
Return bat with minimum value of each pair of inputs
batcalc
min
pattern batcalc.min(X_0:bat[:any_1], X_1:any_1):bat[:any_1] 
CMDbatMIN;
Return bat with minimum value of each pair of inputs
batcalc
min
pattern batcalc.min(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid]):bat[:any_1] 
CMDbatMIN;
Return bat with minimum value of each pair of inputs
batcalc
min
pattern batcalc.min(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:any_1] 
CMDbatMIN;
Return bat with minimum value of each pair of inputs
batcalc
min
pattern batcalc.min(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid]):bat[:any_1] 
CMDbatMIN;
Return bat with minimum value of each pair of inputs
batcalc
min_no_nil
pattern batcalc.min_no_nil(X_0:any_1, X_1:bat[:any_1]):bat[:any_1] 
CMDbatMIN_no_nil;
Return bat with minimum value of each pair of inputs, ignoring nil values
batcalc
min_no_nil
pattern batcalc.min_no_nil(X_0:any_1, X_1:bat[:any_1], X_2:bat[:oid]):bat[:any_1] 
CMDbatMIN_no_nil;
Return bat with minimum value of each pair of inputs, ignoring nil values
batcalc
min_no_nil
pattern batcalc.min_no_nil(X_0:bat[:any_1], X_1:any_1):bat[:any_1] 
CMDbatMIN_no_nil;
Return bat with minimum value of each pair of inputs, ignoring nil values
batcalc
min_no_nil
pattern batcalc.min_no_nil(X_0:bat[:any_1], X_1:any_1, X_2:bat[:oid]):bat[:any_1] 
CMDbatMIN_no_nil;
Return bat with minimum value of each pair of inputs, ignoring nil values
batcalc
min_no_nil
pattern batcalc.min_no_nil(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:any_1] 
CMDbatMIN_no_nil;
Return bat with minimum value of each pair of inputs, ignoring nil values
batcalc
min_no_nil
pattern batcalc.min_no_nil(X_0:bat[:any_1], X_1:bat[:any_1], X_2:bat[:oid], X_3:bat[:oid]):bat[:any_1] 
CMDbatMIN_no_nil;
Return bat with minimum value of each pair of inputs, ignoring nil values
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMOD;
(empty)
batcalc
mod_noerror
pattern batcalc.mod_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMOD;
(empty)
batcalc
month_interval
pattern batcalc.month_interval(X_0:bat[:bte], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
month_interval;
cast bte to a month_interval and check for overflow
batcalc
month_interval
pattern batcalc.month_interval(X_0:bat[:int], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
month_interval;
cast int to a month_interval and check for overflow
batcalc
month_interval
pattern batcalc.month_interval(X_0:bat[:lng], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
month_interval;
cast lng to a month_interval and check for overflow
batcalc
month_interval
pattern batcalc.month_interval(X_0:bat[:sht], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
month_interval;
cast sht to a month_interval and check for overflow
batcalc
month_interval
pattern batcalc.month_interval(X_0:bat[:str], X_1:bat[:oid], X_2:int, X_3:int):bat[:int] 
month_interval_str;
cast str to a month_interval and check for overflow
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:bte] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatMUL;
(empty)
batcalc
mul_noerror
pattern batcalc.mul_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatMUL;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:bit]):bat[:bit] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:bit], X_1:bat[:oid]):bat[:bit] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:bte]):bat[:bte] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:bte], X_1:bat[:oid]):bat[:bte] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:dbl]):bat[:dbl] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:flt]):bat[:flt] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:int]):bat[:int] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:int], X_1:bat[:oid]):bat[:int] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:lng]):bat[:lng] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:lng], X_1:bat[:oid]):bat[:lng] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:sht]):bat[:sht] 
CMDbatNOT;
(empty)
batcalc
not
pattern batcalc.not(X_0:bat[:sht], X_1:bat[:oid]):bat[:sht] 
CMDbatNOT;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:bit]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:bit], X_1:bat[:oid]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:bte]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:bte], X_1:bat[:oid]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:dbl]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:dbl], X_1:bat[:oid]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:flt]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:flt], X_1:bat[:oid]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:int]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:int], X_1:bat[:oid]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:lng]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:lng], X_1:bat[:oid]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:oid]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:oid], X_1:bat[:oid]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:sht]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:sht], X_1:bat[:oid]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:str]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid
pattern batcalc.oid(X_0:bat[:str], X_1:bat[:oid]):bat[:oid] 
CMDconvertsignal_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:bit]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:bit], X_1:bat[:oid]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:bte]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:bte], X_1:bat[:oid]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:dbl]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:dbl], X_1:bat[:oid]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:flt]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:flt], X_1:bat[:oid]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:int]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:int], X_1:bat[:oid]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:lng]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:lng], X_1:bat[:oid]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:oid]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:oid], X_1:bat[:oid]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:sht]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:sht], X_1:bat[:oid]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:str]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
oid_noerror
pattern batcalc.oid_noerror(X_0:bat[:str], X_1:bat[:oid]):bat[:oid] 
CMDconvert_oid;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:bit], X_1:bat[:bit]):bat[:bit] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:bit], X_1:bat[:bit], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:bit], X_1:bit):bat[:bit] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:bit], X_1:bit, X_2:bat[:oid]):bat[:bit] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:bte], X_1:bat[:bte]):bat[:bte] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:bte], X_1:bte):bat[:bte] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:dbl], X_1:bat[:dbl]):bat[:dbl] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:dbl], X_1:dbl):bat[:dbl] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:flt], X_1:bat[:flt]):bat[:flt] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:flt], X_1:flt):bat[:flt] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:int], X_1:bat[:int]):bat[:int] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:int], X_1:int):bat[:int] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:lng], X_1:bat[:lng]):bat[:lng] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:lng], X_1:lng):bat[:lng] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:sht], X_1:bat[:sht]):bat[:sht] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:sht], X_1:sht):bat[:sht] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bit, X_1:bat[:bit]):bat[:bit] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bit, X_1:bat[:bit], X_2:bat[:oid]):bat[:bit] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bte, X_1:bat[:bte]):bat[:bte] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:dbl, X_1:bat[:dbl]):bat[:dbl] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:flt, X_1:bat[:flt]):bat[:flt] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:int, X_1:bat[:int]):bat[:int] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:lng, X_1:bat[:lng]):bat[:lng] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:sht, X_1:bat[:sht]):bat[:sht] 
CMDbatOR;
(empty)
batcalc
or
pattern batcalc.or(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatOR;
(empty)
batcalc
rotate_xor_hash
command batcalc.rotate_xor_hash(X_0:bat[:lng], X_1:int, X_2:bat[:any_1]):bat[:int] 
MKEYbulk_rotate_xor_hash;
(empty)
batcalc
round
pattern batcalc.round(X_0:bat[:bte], X_1:bte, X_2:bat[:oid], X_3:int, X_4:int):bat[:bte] 
bte_bat_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:bte], X_1:bte, X_2:int, X_3:int):bat[:bte] 
bte_bat_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bte, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:bte] 
bte_bat_round_wrap_cst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bte, X_1:bat[:bte], X_2:int, X_3:int):bat[:bte] 
bte_bat_round_wrap_cst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid], X_4:int, X_5:int):bat[:bte] 
bte_bat_round_wrap_nocst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:bte], X_1:bat[:bte], X_2:int, X_3:int):bat[:bte] 
bte_bat_round_wrap_nocst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:dbl], X_1:bte):bat[:dbl] 
dbl_bat_round_wrap;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
dbl_bat_round_wrap;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:dbl, X_1:bat[:bte]):bat[:dbl] 
dbl_bat_round_wrap_cst;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
dbl_bat_round_wrap_cst;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:dbl], X_1:bat[:bte]):bat[:dbl] 
dbl_bat_round_wrap_nocst;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
dbl_bat_round_wrap_nocst;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:flt], X_1:bte):bat[:flt] 
flt_bat_round_wrap;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:flt] 
flt_bat_round_wrap;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:flt, X_1:bat[:bte]):bat[:flt] 
flt_bat_round_wrap_cst;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
flt_bat_round_wrap_cst;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:flt], X_1:bat[:bte]):bat[:flt] 
flt_bat_round_wrap_nocst;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
flt_bat_round_wrap_nocst;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:int], X_1:bte, X_2:bat[:oid], X_3:int, X_4:int):bat[:int] 
int_bat_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:int], X_1:bte, X_2:int, X_3:int):bat[:int] 
int_bat_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:int, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:int] 
int_bat_round_wrap_cst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:int, X_1:bat[:bte], X_2:int, X_3:int):bat[:int] 
int_bat_round_wrap_cst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid], X_4:int, X_5:int):bat[:int] 
int_bat_round_wrap_nocst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:int], X_1:bat[:bte], X_2:int, X_3:int):bat[:int] 
int_bat_round_wrap_nocst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:lng], X_1:bte, X_2:bat[:oid], X_3:int, X_4:int):bat[:lng] 
lng_bat_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:lng], X_1:bte, X_2:int, X_3:int):bat[:lng] 
lng_bat_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:lng, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:lng] 
lng_bat_round_wrap_cst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:lng, X_1:bat[:bte], X_2:int, X_3:int):bat[:lng] 
lng_bat_round_wrap_cst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid], X_4:int, X_5:int):bat[:lng] 
lng_bat_round_wrap_nocst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:lng], X_1:bat[:bte], X_2:int, X_3:int):bat[:lng] 
lng_bat_round_wrap_nocst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:sht], X_1:bte, X_2:bat[:oid], X_3:int, X_4:int):bat[:sht] 
sht_bat_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:sht], X_1:bte, X_2:int, X_3:int):bat[:sht] 
sht_bat_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:sht, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:sht] 
sht_bat_round_wrap_cst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:sht, X_1:bat[:bte], X_2:int, X_3:int):bat[:sht] 
sht_bat_round_wrap_cst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid], X_4:int, X_5:int):bat[:sht] 
sht_bat_round_wrap_nocst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
round
pattern batcalc.round(X_0:bat[:sht], X_1:bat[:bte], X_2:int, X_3:int):bat[:sht] 
sht_bat_round_wrap_nocst;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:bat[:bte]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:bat[:int]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:bat[:lng]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:bat[:sht]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:bte):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:int):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:lng):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:sht):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:bat[:bte]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:bat[:int]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:bat[:lng]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:bat[:sht]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:bte):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:int):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:lng):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:sht):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:bat[:bte]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:bat[:int]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:bat[:lng]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:bat[:sht]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:bte):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:int):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:lng):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:sht):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:bat[:bte]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:bat[:int]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:bat[:lng]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:bat[:sht]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:bte):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:int):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:lng):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:sht):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bte, X_1:bat[:bte]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bte, X_1:bat[:int]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bte, X_1:bat[:lng]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bte, X_1:bat[:sht]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:bte] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:int, X_1:bat[:bte]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:int, X_1:bat[:int]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:int, X_1:bat[:lng]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:int, X_1:bat[:sht]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:lng, X_1:bat[:bte]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:lng, X_1:bat[:int]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:lng, X_1:bat[:lng]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:lng, X_1:bat[:sht]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:sht, X_1:bat[:bte]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:sht, X_1:bat[:int]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:sht, X_1:bat[:lng]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:sht, X_1:bat[:sht]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
rsh_noerror
pattern batcalc.rsh_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatRSH;
(empty)
batcalc
second_interval
pattern batcalc.second_interval(X_0:int, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:lng] 
bte_batdec2second_interval;
cast bte decimal to a second_interval
batcalc
second_interval
pattern batcalc.second_interval(X_0:int, X_1:bat[:int], X_2:bat[:oid], X_3:int, X_4:int):bat[:lng] 
int_batdec2second_interval;
cast int decimal to a second_interval
batcalc
second_interval
pattern batcalc.second_interval(X_0:int, X_1:bat[:lng], X_2:bat[:oid], X_3:int, X_4:int):bat[:lng] 
lng_batdec2second_interval;
cast lng decimal to a second_interval
batcalc
second_interval
pattern batcalc.second_interval(X_0:bat[:bte], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
second_interval;
cast bte to a second_interval and check for overflow
batcalc
second_interval
pattern batcalc.second_interval(X_0:bat[:int], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
second_interval;
cast int to a second_interval and check for overflow
batcalc
second_interval
pattern batcalc.second_interval(X_0:bat[:lng], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
second_interval;
cast lng to a second_interval and check for overflow
batcalc
second_interval
pattern batcalc.second_interval(X_0:bat[:sht], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
second_interval;
cast sht to a second_interval and check for overflow
batcalc
second_interval
pattern batcalc.second_interval(X_0:bat[:daytime], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
second_interval_daytime;
cast daytime to a second_interval and check for overflow
batcalc
second_interval
pattern batcalc.second_interval(X_0:bat[:str], X_1:bat[:oid], X_2:int, X_3:int):bat[:lng] 
second_interval_str;
cast str to a second_interval and check for overflow
batcalc
second_interval
pattern batcalc.second_interval(X_0:int, X_1:bat[:sht], X_2:bat[:oid], X_3:int, X_4:int):bat[:lng] 
sht_batdec2second_interval;
cast sht decimal to a second_interval
batcalc
sht
pattern batcalc.sht(X_0:bat[:bit]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:bit], X_1:bat[:oid]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:bte]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:bte], X_1:bat[:oid]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:dbl]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:dbl], X_1:bat[:oid]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:flt]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:flt], X_1:bat[:oid]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:int]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:int], X_1:bat[:oid]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:lng]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:lng], X_1:bat[:oid]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:oid]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:oid], X_1:bat[:oid]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:sht]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:sht], X_1:bat[:oid]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:str]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
pattern batcalc.sht(X_0:bat[:str], X_1:bat[:oid]):bat[:sht] 
CMDconvertsignal_sht;
(empty)
batcalc
sht
command batcalc.sht(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
batbte_dec2_sht;
cast decimal(bte) to sht and check for overflow
batcalc
sht
command batcalc.sht(X_0:int, X_1:bat[:bte], X_2:bat[:oid], X_3:int, X_4:int):bat[:sht] 
batbte_dec2dec_sht;
cast decimal(bte) to decimal(sht) and check for overflow
batcalc
sht
command batcalc.sht(X_0:bat[:bte], X_1:bat[:oid], X_2:int, X_3:int):bat[:sht] 
batbte_num2dec_sht;
cast number to decimal(sht) and check for overflow
batcalc
sht
command batcalc.sht(X_0:bat[:dbl], X_1:bat[:oid], X_2:int, X_3:int):bat[:sht] 
batdbl_num2dec_sht;
cast number to decimal(sht) and check for overflow
batcalc
sht
command batcalc.sht(X_0:bat[:flt], X_1:bat[:oid], X_2:int, X_3:int):bat[:sht] 
batflt_num2dec_sht;
cast number to decimal(sht) and check for overflow
batcalc
sht
command batcalc.sht(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:sht] 
batint_dec2_sht;
cast decimal(int) to sht and check for overflow
batcalc
sht
command batcalc.sht(X_0:int, X_1:bat[:int], X_2:bat[:oid], X_3:int, X_4:int):bat[:sht] 
batint_dec2dec_sht;
cast decimal(int) to decimal(sht) and check for overflow
batcalc
sht
command batcalc.sht(X_0:bat[:int], X_1:bat[:oid], X_2:int, X_3:int):bat[:sht] 
batint_num2dec_sht;
cast number to decimal(sht) and check for overflow
batcalc
sht
command batcalc.sht(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:sht] 
batlng_dec2_sht;
cast decimal(lng) to sht and check for overflow
batcalc
sht
command batcalc.sht(X_0:int, X_1:bat[:lng], X_2:bat[:oid], X_3:int, X_4:int):bat[:sht] 
batlng_dec2dec_sht;
cast decimal(lng) to decimal(sht) and check for overflow
batcalc
sht
command batcalc.sht(X_0:bat[:lng], X_1:bat[:oid], X_2:int, X_3:int):bat[:sht] 
batlng_num2dec_sht;
cast number to decimal(sht) and check for overflow
batcalc
sht
command batcalc.sht(X_0:bat[:oid], X_1:int, X_2:int):bat[:sht] 
batnil_2dec_sht;
cast to dec(sht) and check for overflow
batcalc
sht
command batcalc.sht(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
batsht_dec2_sht;
cast decimal(sht) to sht and check for overflow
batcalc
sht
command batcalc.sht(X_0:int, X_1:bat[:sht], X_2:bat[:oid], X_3:int, X_4:int):bat[:sht] 
batsht_dec2dec_sht;
cast decimal(sht) to decimal(sht) and check for overflow
batcalc
sht
command batcalc.sht(X_0:bat[:sht], X_1:bat[:oid], X_2:int, X_3:int):bat[:sht] 
batsht_num2dec_sht;
cast number to decimal(sht) and check for overflow
batcalc
sht
pattern batcalc.sht(X_0:bat[:str], X_1:bat[:oid], X_2:int, X_3:int):bat[:sht] 
batstr_2dec_sht;
cast to dec(sht) and check for overflow
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:bit]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:bit], X_1:bat[:oid]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:bte]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:bte], X_1:bat[:oid]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:dbl]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:dbl], X_1:bat[:oid]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:flt]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:flt], X_1:bat[:oid]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:int]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:int], X_1:bat[:oid]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:lng]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:lng], X_1:bat[:oid]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:oid]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:oid], X_1:bat[:oid]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:sht]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:sht], X_1:bat[:oid]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:str]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sht_noerror
pattern batcalc.sht_noerror(X_0:bat[:str], X_1:bat[:oid]):bat[:sht] 
CMDconvert_sht;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:bte]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:bte], X_1:bat[:oid]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:dbl]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:dbl], X_1:bat[:oid]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:flt]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:flt], X_1:bat[:oid]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:int]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:int], X_1:bat[:oid]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:lng]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:lng], X_1:bat[:oid]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:sht]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
sign
pattern batcalc.sign(X_0:bat[:sht], X_1:bat[:oid]):bat[:bte] 
CMDbatSIGN;
(empty)
batcalc
str
pattern batcalc.str(X_0:bat[:any]):bat[:str] 
CMDconvertsignal_str;
(empty)
batcalc
str
pattern batcalc.str(X_0:bat[:any], X_1:bat[:oid]):bat[:str] 
CMDconvertsignal_str;
(empty)
batcalc
str
pattern batcalc.str(X_0:int, X_1:int, X_2:int, X_3:int, X_4:bat[:any_1], X_5:bat[:oid], X_6:int):bat[:str] 
SQLbatstr_cast;
cast to string and check for overflow
batcalc
str
command batcalc.str(X_0:bat[:uuid], X_1:bat[:oid]):bat[:str] 
UUIDuuid2str_bulk;
Coerce a uuid to a string type
batcalc
str_noerror
pattern batcalc.str_noerror(X_0:bat[:any]):bat[:str] 
CMDconvert_str;
(empty)
batcalc
str_noerror
pattern batcalc.str_noerror(X_0:bat[:any], X_1:bat[:oid]):bat[:str] 
CMDconvert_str;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:bte], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:bte, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:flt, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:int, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:dbl], X_1:sht, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:bte, X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:int, X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:flt], X_1:sht, X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:bte, X_2:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:int], X_1:sht, X_2:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:bte, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:dbl, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:flt, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:int, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:lng], X_1:sht, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:bte, X_2:bat[:oid]):bat[:sht] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bte, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bte, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bte, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bte, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:bte, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:dbl, X_1:bat[:bte], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:dbl, X_1:bat[:flt], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:dbl, X_1:bat[:int], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:dbl, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:dbl, X_1:bat[:sht], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:flt, X_1:bat[:bte], X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:flt, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:flt, X_1:bat[:int], X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:flt, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:flt, X_1:bat[:sht], X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:int, X_1:bat[:bte], X_2:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:int, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:int, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:int, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:int, X_1:bat[:sht], X_2:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:lng, X_1:bat[:bte], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:lng, X_1:bat[:dbl], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:lng, X_1:bat[:flt], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:lng, X_1:bat[:int], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:lng, X_1:bat[:sht], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:sht, X_1:bat[:bte], X_2:bat[:oid]):bat[:sht] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:sht, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:sht, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:sht, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:sht, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatSUB;
(empty)
batcalc
sub_noerror
pattern batcalc.sub_noerror(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatSUB;
(empty)
batcalc
timestamp
pattern batcalc.timestamp(X_0:bat[:date], X_1:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_fromdate_bulk;
(empty)
batcalc
timestamp
pattern batcalc.timestamp(X_0:bat[:lng], X_1:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_frommsec_bulk;
(empty)
batcalc
timestamp
pattern batcalc.timestamp(X_0:bat[:int], X_1:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_fromsecond_bulk;
(empty)
batcalc
timestamp
pattern batcalc.timestamp(X_0:bat[:str], X_1:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_fromstr_bulk;
(empty)
batcalc
timestamp
pattern batcalc.timestamp(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_timestamp_bulk;
(empty)
batcalc
timestamp
command batcalc.timestamp(X_0:bat[:str], X_1:bat[:oid], X_2:int):bat[:timestamp] 
batstr_2time_timestamp;
cast to timestamp and check for overflow
batcalc
timestamp
command batcalc.timestamp(X_0:bat[:str], X_1:bat[:oid], X_2:int, X_3:int):bat[:timestamp] 
batstr_2time_timestamptz;
cast to timestamp and check for overflow
batcalc
timestamp
pattern batcalc.timestamp(X_0:bat[:date], X_1:bat[:oid], X_2:int):bat[:timestamp] 
date_2_timestamp;
cast date to a timestamp and check for overflow
batcalc
timestamp
pattern batcalc.timestamp(X_0:bat[:oid], X_1:int):bat[:timestamp] 
nil_2time_timestamp;
cast to timestamp and check for overflow
batcalc
timestamp
pattern batcalc.timestamp(X_0:bat[:oid], X_1:int, X_2:bat[:BAT]):bat[:timestamp] 
nil_2time_timestamp;
cast to timestamp and check for overflow
batcalc
timestamp
pattern batcalc.timestamp(X_0:bat[:timestamp], X_1:bat[:oid], X_2:int):bat[:timestamp] 
timestamp_2time_timestamp;
cast timestamp to timestamp and check for overflow
batcalc
uuid
command batcalc.uuid(X_0:bat[:str], X_1:bat[:oid]):bat[:uuid] 
UUIDstr2uuid_bulk;
Coerce a string to a uuid, validating its format
batcalc
uuid
command batcalc.uuid(X_0:bat[:uuid], X_1:bat[:oid]):bat[:uuid] 
UUIDuuid2uuid_bulk;
(empty)
batcalc
wkb
command batcalc.wkb(X_0:bat[:wkb], X_1:bat[:oid], X_2:int, X_3:int):bat[:wkb] 
geom_2_geom_bat;
Called when inserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition
batcalc
wkb
command batcalc.wkb(X_0:bat[:str], X_1:bat[:oid], X_2:int, X_3:int):bat[:wkb] 
wkbFromText_bat_cand;
(empty)
batcalc
xml
command batcalc.xml(X_0:bat[:str]):bat[:xml] 
BATXMLstr2xml;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:bit], X_1:bat[:bit]):bat[:bit] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:bit], X_1:bat[:bit], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:bit], X_1:bit):bat[:bit] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:bit], X_1:bit, X_2:bat[:oid]):bat[:bit] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:bte], X_1:bat[:bte]):bat[:bte] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:oid], X_3:bat[:oid]):bat[:bte] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:bte], X_1:bte):bat[:bte] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:bte], X_1:bte, X_2:bat[:oid]):bat[:bte] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:dbl], X_1:bat[:dbl]):bat[:dbl] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:dbl], X_1:dbl):bat[:dbl] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:flt], X_1:bat[:flt]):bat[:flt] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:flt], X_1:flt):bat[:flt] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:int], X_1:bat[:int]):bat[:int] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:int], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:int], X_1:int):bat[:int] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:int], X_1:int, X_2:bat[:oid]):bat[:int] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:lng], X_1:bat[:lng]):bat[:lng] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:lng], X_1:lng):bat[:lng] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:lng], X_1:lng, X_2:bat[:oid]):bat[:lng] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:sht], X_1:bat[:sht]):bat[:sht] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:oid], X_3:bat[:oid]):bat[:sht] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:sht], X_1:sht):bat[:sht] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bat[:sht], X_1:sht, X_2:bat[:oid]):bat[:sht] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bit, X_1:bat[:bit]):bat[:bit] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bit, X_1:bat[:bit], X_2:bat[:oid]):bat[:bit] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bte, X_1:bat[:bte]):bat[:bte] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:bte, X_1:bat[:bte], X_2:bat[:oid]):bat[:bte] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:dbl, X_1:bat[:dbl]):bat[:dbl] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:flt, X_1:bat[:flt]):bat[:flt] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:int, X_1:bat[:int]):bat[:int] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:int, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:lng, X_1:bat[:lng]):bat[:lng] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:lng, X_1:bat[:lng], X_2:bat[:oid]):bat[:lng] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:sht, X_1:bat[:sht]):bat[:sht] 
CMDbatXOR;
(empty)
batcalc
xor
pattern batcalc.xor(X_0:sht, X_1:bat[:sht], X_2:bat[:oid]):bat[:sht] 
CMDbatXOR;
(empty)
batcapi
eval
pattern batcapi.eval(X_0:ptr, X_1:bit, X_2:str, X_3:any...):any... 
CUDFevalStd;
Execute a simple CUDF script value
batcapi
eval_aggr
pattern batcapi.eval_aggr(X_0:ptr, X_1:bit, X_2:str, X_3:any...):any... 
CUDFevalAggr;
grouped aggregates through CUDF
batcapi
subeval_aggr
pattern batcapi.subeval_aggr(X_0:ptr, X_1:bit, X_2:str, X_3:any...):any... 
CUDFevalAggr;
grouped aggregates through CUDF
batcolor
blue
command batcolor.blue(X_0:bat[:color]):bat[:int] 
CLRbatBlue;
Extracts blue component from a color atom
batcolor
cb
command batcolor.cb(X_0:bat[:color]):bat[:int] 
CLRbatCb;
Extracts Cb(blue color) component from a color atom
batcolor
color
command batcolor.color(X_0:bat[:str]):bat[:color] 
CLRbatColor;
Converts string to color
batcolor
cr
command batcolor.cr(X_0:bat[:color]):bat[:int] 
CLRbatCr;
Extracts Cr(red color) component from a color atom
batcolor
green
command batcolor.green(X_0:bat[:color]):bat[:int] 
CLRbatGreen;
Extracts green component from a color atom
batcolor
hsv
command batcolor.hsv(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:flt]):bat[:color] 
CLRbatHsv;
Converts an HSV triplets to a color atom
batcolor
hue
command batcolor.hue(X_0:bat[:color]):bat[:flt] 
CLRbatHue;
Extracts hue component from a color atom
batcolor
hue
command batcolor.hue(X_0:bat[:color]):bat[:int] 
CLRbatHueInt;
Extracts hue component from a color atom
batcolor
luminance
command batcolor.luminance(X_0:bat[:color]):bat[:int] 
CLRbatLuminance;
Extracts Y(luminance) component from a color atom
batcolor
red
command batcolor.red(X_0:bat[:color]):bat[:int] 
CLRbatRed;
Extracts red component from a color atom
batcolor
rgb
command batcolor.rgb(X_0:bat[:int], X_1:bat[:int], X_2:bat[:int]):bat[:color] 
CLRbatRgb;
Converts an RGB triplets to a color atom
batcolor
saturation
command batcolor.saturation(X_0:bat[:color]):bat[:flt] 
CLRbatSaturation;
Extracts saturation component from a color atom
batcolor
saturation
command batcolor.saturation(X_0:bat[:color]):bat[:int] 
CLRbatSaturationInt;
Extracts saturation component from a color atom
batcolor
str
command batcolor.str(X_0:bat[:color]):bat[:str] 
CLRbatStr;
Identity mapping for string bats
batcolor
value
command batcolor.value(X_0:bat[:color]):bat[:flt] 
CLRbatValue;
Extracts value component from a color atom
batcolor
value
command batcolor.value(X_0:bat[:color]):bat[:int] 
CLRbatValueInt;
Extracts value component from a color atom
batcolor
ycc
command batcolor.ycc(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:flt]):bat[:color] 
CLRbatycc;
Converts an YCC triplets to a color atom
batgeom
AsEWKT
function batgeom.AsEWKT(w:bat[:wkb]):bat[:str];
(empty)
(empty)
batgeom
AsText
function batgeom.AsText(w:bat[:wkb]):bat[:str];
(empty)
(empty)
batgeom
Boundary
command batgeom.Boundary(X_0:bat[:wkb]):bat[:wkb] 
wkbBoundary_bat;
(empty)
batgeom
Contains
command batgeom.Contains(X_0:bat[:wkb], X_1:bat[:wkb]):bat[:bit] 
wkbContains_bat;
(empty)
batgeom
Contains
command batgeom.Contains(X_0:bat[:wkb], X_1:wkb):bat[:bit] 
wkbContains_bat_geom;
(empty)
batgeom
Contains
command batgeom.Contains(X_0:wkb, X_1:bat[:wkb]):bat[:bit] 
wkbContains_geom_bat;
(empty)
batgeom
Dimension
command batgeom.Dimension(X_0:bat[:wkb]):bat[:int] 
wkbDimension_bat;
(empty)
batgeom
Distance
command batgeom.Distance(X_0:bat[:wkb], X_1:bat[:wkb]):bat[:dbl] 
wkbDistance_bat;
(empty)
batgeom
Distance
command batgeom.Distance(X_0:bat[:wkb], X_1:wkb):bat[:dbl] 
wkbDistance_bat_geom;
(empty)
batgeom
Distance
command batgeom.Distance(X_0:wkb, X_1:bat[:wkb]):bat[:dbl] 
wkbDistance_geom_bat;
(empty)
batgeom
Filter
command batgeom.Filter(X_0:bat[:wkb], X_1:wkb):bat[:wkb] 
wkbFilter_bat_geom;
(empty)
batgeom
Filter
command batgeom.Filter(X_0:wkb, X_1:bat[:wkb]):bat[:wkb] 
wkbFilter_geom_bat;
Filters the points in the bats according to the MBR of the other bat.
batgeom
FromText
command batgeom.FromText(X_0:bat[:str], X_1:int, X_2:int):bat[:wkb] 
wkbFromText_bat;
(empty)
batgeom
GeomCollFromText
function batgeom.GeomCollFromText(wkt:bat[:str]):bat[:wkb];
(empty)
(empty)
batgeom
GeomCollFromText
function batgeom.GeomCollFromText(wkt:bat[:str], srid:int):bat[:wkb];
(empty)
(empty)
batgeom
GeomFromText
function batgeom.GeomFromText(wkt:bat[:str]):bat[:wkb];
(empty)
(empty)
batgeom
GeomFromText
function batgeom.GeomFromText(wkt:bat[:str], srid:int):bat[:wkb];
(empty)
(empty)
batgeom
GeometryN
command batgeom.GeometryN(X_0:bat[:wkb], X_1:int):bat[:wkb] 
wkbGeometryN_bat;
Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON. Otherwise, return NULL
batgeom
GeometryType
command batgeom.GeometryType(X_0:bat[:wkb], X_1:int):bat[:str] 
wkbGeometryType_bat;
(empty)
batgeom
GeometryType1
function batgeom.GeometryType1(w:bat[:wkb]):bat[:str];
(empty)
(empty)
batgeom
GeometryType2
function batgeom.GeometryType2(w:bat[:wkb]):bat[:str];
(empty)
(empty)
batgeom
GetCoordinate
command batgeom.GetCoordinate(X_0:bat[:wkb], X_1:int):bat[:dbl] 
wkbGetCoordinate_bat;
Returns the coordinate at position idx of a point, or NULL if not available. idx=0 -> X, idx=1 -> Y, idx=2 -> Z. Input must be point
batgeom
IsClosed
command batgeom.IsClosed(X_0:bat[:wkb]):bat[:bit] 
wkbIsClosed_bat;
(empty)
batgeom
IsEmpty
command batgeom.IsEmpty(X_0:bat[:wkb]):bat[:bit] 
wkbIsEmpty_bat;
(empty)
batgeom
IsRing
command batgeom.IsRing(X_0:bat[:wkb]):bat[:bit] 
wkbIsRing_bat;
(empty)
batgeom
IsSimple
command batgeom.IsSimple(X_0:bat[:wkb]):bat[:bit] 
wkbIsSimple_bat;
(empty)
batgeom
IsValid
command batgeom.IsValid(X_0:bat[:wkb]):bat[:bit] 
wkbIsValid_bat;
(empty)
batgeom
LineFromText
function batgeom.LineFromText(wkt:bat[:str]):bat[:wkb];
(empty)
(empty)
batgeom
LineFromText
function batgeom.LineFromText(wkt:bat[:str], srid:int):bat[:wkb];
(empty)
(empty)
batgeom
MLineFromText
function batgeom.MLineFromText(wkt:bat[:str]):bat[:wkb];
(empty)
(empty)
batgeom
MLineFromText
function batgeom.MLineFromText(wkt:bat[:str], srid:int):bat[:wkb];
(empty)
(empty)
batgeom
MPointFromText
function batgeom.MPointFromText(wkt:bat[:str]):bat[:wkb];
(empty)
(empty)
batgeom
MPointFromText
function batgeom.MPointFromText(wkt:bat[:str], srid:int):bat[:wkb];
(empty)
(empty)
batgeom
MPolyFromText
function batgeom.MPolyFromText(wkt:bat[:str]):bat[:wkb];
(empty)
(empty)
batgeom
MPolyFromText
function batgeom.MPolyFromText(wkt:bat[:str], srid:int):bat[:wkb];
(empty)
(empty)
batgeom
MakeBox2D
command batgeom.MakeBox2D(X_0:bat[:wkb], X_1:bat[:wkb]):bat[:mbr] 
wkbBox2D_bat;
(empty)
batgeom
MakeLine
command batgeom.MakeLine(X_0:bat[:wkb], X_1:bat[:wkb]):bat[:wkb] 
wkbMakeLine_bat;
Gets two BATS of point or linestring geometries and returns a bat with linestring geometries
batgeom
MakePoint
function batgeom.MakePoint(x:bat[:dbl], y:bat[:dbl]):bat[:wkb];
(empty)
(empty)
batgeom
MakePoint
function batgeom.MakePoint(x:bat[:dbl], y:bat[:dbl], z:bat[:dbl]):bat[:wkb];
(empty)
(empty)
batgeom
MakePoint
function batgeom.MakePoint(x:bat[:dbl], y:bat[:dbl], z:bat[:dbl], m:bat[:dbl]):bat[:wkb];
(empty)
(empty)
batgeom
MakePointM
function batgeom.MakePointM(x:bat[:dbl], y:bat[:dbl], m:bat[:dbl]):bat[:wkb];
(empty)
(empty)
batgeom
MakePointXYZM
command batgeom.MakePointXYZM(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:dbl], X_3:bat[:dbl], X_4:int):bat[:wkb] 
wkbMakePoint_bat;
creates a point using the coordinates
batgeom
NPoints
function batgeom.NPoints(w:bat[:wkb]):bat[:int];
(empty)
(empty)
batgeom
NRings
function batgeom.NRings(w:bat[:wkb]):bat[:int];
(empty)
(empty)
batgeom
NumGeometries
command batgeom.NumGeometries(X_0:bat[:wkb]):bat[:int] 
wkbNumGeometries_bat;
Returns the number of geometries
batgeom
NumInteriorRings
function batgeom.NumInteriorRings(w:bat[:wkb]):bat[:int];
(empty)
(empty)
batgeom
NumPoints
function batgeom.NumPoints(w:bat[:wkb]):bat[:int];
(empty)
(empty)
batgeom
NumRings
command batgeom.NumRings(X_0:bat[:wkb], X_1:int):bat[:int] 
wkbNumRings_bat;
Returns the number of interior rings+exterior on the first polygon of the geometry
batgeom
PointFromText
function batgeom.PointFromText(wkt:bat[:str]):bat[:wkb];
(empty)
(empty)
batgeom
PointFromText
function batgeom.PointFromText(wkt:bat[:str], srid:int):bat[:wkb];
(empty)
(empty)
batgeom
PointsNum
command batgeom.PointsNum(X_0:bat[:wkb], X_1:int):bat[:int] 
wkbNumPoints_bat;
The number of points in the Geometry. If check=1, the geometry should be a linestring
batgeom
PolygonFromText
function batgeom.PolygonFromText(wkt:bat[:str]):bat[:wkb];
(empty)
(empty)
batgeom
PolygonFromText
function batgeom.PolygonFromText(wkt:bat[:str], srid:int):bat[:wkb];
(empty)
(empty)
batgeom
ToText
command batgeom.ToText(X_0:bat[:wkb], X_1:int):bat[:str] 
wkbAsText_bat;
(empty)
batgeom
Union
command batgeom.Union(X_0:bat[:wkb], X_1:bat[:wkb]):bat[:wkb] 
wkbUnion_bat;
Gets two BATS of geometries and returns the pairwise unions
batgeom
X
function batgeom.X(w:bat[:wkb]):bat[:dbl];
(empty)
(empty)
batgeom
XMaxFromMBR
function batgeom.XMaxFromMBR(b:bat[:mbr]):bat[:dbl];
(empty)
(empty)
batgeom
XMaxFromWKB
function batgeom.XMaxFromWKB(g:bat[:wkb]):bat[:dbl];
(empty)
(empty)
batgeom
XMinFromMBR
function batgeom.XMinFromMBR(b:bat[:mbr]):bat[:dbl];
(empty)
(empty)
batgeom
XMinFromWKB
function batgeom.XMinFromWKB(g:bat[:wkb]):bat[:dbl];
(empty)
(empty)
batgeom
Y
function batgeom.Y(w:bat[:wkb]):bat[:dbl];
(empty)
(empty)
batgeom
YMaxFromMBR
function batgeom.YMaxFromMBR(b:bat[:mbr]):bat[:dbl];
(empty)
(empty)
batgeom
YMaxFromWKB
function batgeom.YMaxFromWKB(g:bat[:wkb]):bat[:dbl];
(empty)
(empty)
batgeom
YMinFromMBR
function batgeom.YMinFromMBR(b:bat[:mbr]):bat[:dbl];
(empty)
(empty)
batgeom
YMinFromWKB
function batgeom.YMinFromWKB(g:bat[:wkb]):bat[:dbl];
(empty)
(empty)
batgeom
Z
function batgeom.Z(w:bat[:wkb]):bat[:dbl];
(empty)
(empty)
batgeom
coordinateFromMBR
command batgeom.coordinateFromMBR(X_0:bat[:mbr], X_1:int):bat[:dbl] 
wkbCoordinateFromMBR_bat;
returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided mbr
batgeom
coordinateFromWKB
command batgeom.coordinateFromWKB(X_0:bat[:wkb], X_1:int):bat[:dbl] 
wkbCoordinateFromWKB_bat;
returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided geometry
batgeom
mbr
command batgeom.mbr(X_0:bat[:wkb]):bat[:mbr] 
wkbMBR_bat;
Creates the mbr for the given wkb.
batgeom
setSRID
command batgeom.setSRID(X_0:bat[:wkb], X_1:int):bat[:wkb] 
wkbSetSRID_bat;
Sets the Reference System ID for this Geometry.
batmal
multiplex
pattern batmal.multiplex(X_0:str, X_1:str, X_2:any...):any... 
MANIFOLDremapMultiplex;
(empty)
batmkey
hash
command batmkey.hash(X_0:bat[:any_1]):bat[:lng] 
MKEYbathash;
calculate a hash value
batmmath
acos
pattern batmmath.acos(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_acos;
(empty)
batmmath
acos
pattern batmmath.acos(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_acos;
(empty)
batmmath
acos
pattern batmmath.acos(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_acos;
(empty)
batmmath
acos
pattern batmmath.acos(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_acos;
(empty)
batmmath
asin
pattern batmmath.asin(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_asin;
(empty)
batmmath
asin
pattern batmmath.asin(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_asin;
(empty)
batmmath
asin
pattern batmmath.asin(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_asin;
(empty)
batmmath
asin
pattern batmmath.asin(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_asin;
(empty)
batmmath
atan
pattern batmmath.atan(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_atan;
(empty)
batmmath
atan
pattern batmmath.atan(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_atan;
(empty)
batmmath
atan
pattern batmmath.atan(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_atan;
(empty)
batmmath
atan
pattern batmmath.atan(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_atan;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:bat[:dbl], X_1:bat[:dbl]):bat[:dbl] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:bat[:dbl], X_1:dbl):bat[:dbl] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:bat[:flt], X_1:bat[:flt]):bat[:flt] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:bat[:flt], X_1:flt):bat[:flt] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:dbl, X_1:bat[:dbl]):bat[:dbl] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:flt, X_1:bat[:flt]):bat[:flt] 
CMDscience_bat_atan2;
(empty)
batmmath
atan2
pattern batmmath.atan2(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDscience_bat_atan2;
(empty)
batmmath
cbrt
pattern batmmath.cbrt(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_cbrt;
(empty)
batmmath
cbrt
pattern batmmath.cbrt(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_cbrt;
(empty)
batmmath
cbrt
pattern batmmath.cbrt(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_cbrt;
(empty)
batmmath
cbrt
pattern batmmath.cbrt(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_cbrt;
(empty)
batmmath
ceil
pattern batmmath.ceil(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_ceil;
(empty)
batmmath
ceil
pattern batmmath.ceil(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_ceil;
(empty)
batmmath
ceil
pattern batmmath.ceil(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_ceil;
(empty)
batmmath
ceil
pattern batmmath.ceil(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_ceil;
(empty)
batmmath
cos
pattern batmmath.cos(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_cos;
(empty)
batmmath
cos
pattern batmmath.cos(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_cos;
(empty)
batmmath
cos
pattern batmmath.cos(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_cos;
(empty)
batmmath
cos
pattern batmmath.cos(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_cos;
(empty)
batmmath
cosh
pattern batmmath.cosh(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_cosh;
(empty)
batmmath
cosh
pattern batmmath.cosh(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_cosh;
(empty)
batmmath
cosh
pattern batmmath.cosh(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_cosh;
(empty)
batmmath
cosh
pattern batmmath.cosh(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_cosh;
(empty)
batmmath
cot
pattern batmmath.cot(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_cot;
(empty)
batmmath
cot
pattern batmmath.cot(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_cot;
(empty)
batmmath
cot
pattern batmmath.cot(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_cot;
(empty)
batmmath
cot
pattern batmmath.cot(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_cot;
(empty)
batmmath
degrees
pattern batmmath.degrees(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_degrees;
(empty)
batmmath
degrees
pattern batmmath.degrees(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_degrees;
(empty)
batmmath
degrees
pattern batmmath.degrees(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_degrees;
(empty)
batmmath
degrees
pattern batmmath.degrees(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_degrees;
(empty)
batmmath
exp
pattern batmmath.exp(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_exp;
(empty)
batmmath
exp
pattern batmmath.exp(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_exp;
(empty)
batmmath
exp
pattern batmmath.exp(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_exp;
(empty)
batmmath
exp
pattern batmmath.exp(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_exp;
(empty)
batmmath
fabs
pattern batmmath.fabs(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_fabs;
(empty)
batmmath
fabs
pattern batmmath.fabs(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_fabs;
(empty)
batmmath
fabs
pattern batmmath.fabs(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_fabs;
(empty)
batmmath
fabs
pattern batmmath.fabs(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_fabs;
(empty)
batmmath
floor
pattern batmmath.floor(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_floor;
(empty)
batmmath
floor
pattern batmmath.floor(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_floor;
(empty)
batmmath
floor
pattern batmmath.floor(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_floor;
(empty)
batmmath
floor
pattern batmmath.floor(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_floor;
(empty)
batmmath
fmod
pattern batmmath.fmod(X_0:bat[:dbl], X_1:dbl):bat[:dbl] 
CMDbatMODsignal;
(empty)
batmmath
fmod
pattern batmmath.fmod(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDbatMODsignal;
(empty)
batmmath
fmod
pattern batmmath.fmod(X_0:bat[:flt], X_1:flt):bat[:flt] 
CMDbatMODsignal;
(empty)
batmmath
fmod
pattern batmmath.fmod(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDbatMODsignal;
(empty)
batmmath
log
pattern batmmath.log(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_log;
(empty)
batmmath
log
pattern batmmath.log(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_log;
(empty)
batmmath
log
pattern batmmath.log(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_log;
(empty)
batmmath
log
pattern batmmath.log(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_log;
(empty)
batmmath
log10
pattern batmmath.log10(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_log10;
(empty)
batmmath
log10
pattern batmmath.log10(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_log10;
(empty)
batmmath
log10
pattern batmmath.log10(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_log10;
(empty)
batmmath
log10
pattern batmmath.log10(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_log10;
(empty)
batmmath
log2
pattern batmmath.log2(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_log2;
(empty)
batmmath
log2
pattern batmmath.log2(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_log2;
(empty)
batmmath
log2
pattern batmmath.log2(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_log2;
(empty)
batmmath
log2
pattern batmmath.log2(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_log2;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:bat[:dbl], X_1:bat[:dbl]):bat[:dbl] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:bat[:dbl], X_1:dbl):bat[:dbl] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:bat[:flt], X_1:bat[:flt]):bat[:flt] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:bat[:flt], X_1:flt):bat[:flt] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:dbl, X_1:bat[:dbl]):bat[:dbl] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:flt, X_1:bat[:flt]):bat[:flt] 
CMDscience_bat_logbs;
(empty)
batmmath
log2arg
pattern batmmath.log2arg(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDscience_bat_logbs;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:bat[:dbl], X_1:bat[:dbl]):bat[:dbl] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:oid], X_3:bat[:oid]):bat[:dbl] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:bat[:dbl], X_1:dbl):bat[:dbl] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:bat[:dbl], X_1:dbl, X_2:bat[:oid]):bat[:dbl] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:bat[:flt], X_1:bat[:flt]):bat[:flt] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:oid], X_3:bat[:oid]):bat[:flt] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:bat[:flt], X_1:flt):bat[:flt] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:bat[:flt], X_1:flt, X_2:bat[:oid]):bat[:flt] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:dbl, X_1:bat[:dbl]):bat[:dbl] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:dbl, X_1:bat[:dbl], X_2:bat[:oid]):bat[:dbl] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:flt, X_1:bat[:flt]):bat[:flt] 
CMDscience_bat_pow;
(empty)
batmmath
pow
pattern batmmath.pow(X_0:flt, X_1:bat[:flt], X_2:bat[:oid]):bat[:flt] 
CMDscience_bat_pow;
(empty)
batmmath
radians
pattern batmmath.radians(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_radians;
(empty)
batmmath
radians
pattern batmmath.radians(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_radians;
(empty)
batmmath
radians
pattern batmmath.radians(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_radians;
(empty)
batmmath
radians
pattern batmmath.radians(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_radians;
(empty)
batmmath
rand
unsafe pattern batmmath.rand(X_0:bat[:int]):bat[:int] 
CMDscience_bat_randintarg;
(empty)
batmmath
rand
unsafe pattern batmmath.rand(X_0:bat[:int], X_1:bat[:oid]):bat[:int] 
CMDscience_bat_randintarg;
(empty)
batmmath
rand
unsafe pattern batmmath.rand(X_0:lng):bat[:int] 
CMDscience_bat_randintarg;
(empty)
batmmath
sin
pattern batmmath.sin(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_sin;
(empty)
batmmath
sin
pattern batmmath.sin(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_sin;
(empty)
batmmath
sin
pattern batmmath.sin(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_sin;
(empty)
batmmath
sin
pattern batmmath.sin(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_sin;
(empty)
batmmath
sinh
pattern batmmath.sinh(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_sinh;
(empty)
batmmath
sinh
pattern batmmath.sinh(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_sinh;
(empty)
batmmath
sinh
pattern batmmath.sinh(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_sinh;
(empty)
batmmath
sinh
pattern batmmath.sinh(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_sinh;
(empty)
batmmath
sqrt
pattern batmmath.sqrt(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_sqrt;
(empty)
batmmath
sqrt
pattern batmmath.sqrt(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_sqrt;
(empty)
batmmath
sqrt
pattern batmmath.sqrt(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_sqrt;
(empty)
batmmath
sqrt
pattern batmmath.sqrt(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_sqrt;
(empty)
batmmath
tan
pattern batmmath.tan(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_tan;
(empty)
batmmath
tan
pattern batmmath.tan(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_tan;
(empty)
batmmath
tan
pattern batmmath.tan(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_tan;
(empty)
batmmath
tan
pattern batmmath.tan(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_tan;
(empty)
batmmath
tanh
pattern batmmath.tanh(X_0:bat[:dbl]):bat[:dbl] 
CMDscience_bat_tanh;
(empty)
batmmath
tanh
pattern batmmath.tanh(X_0:bat[:dbl], X_1:bat[:oid]):bat[:dbl] 
CMDscience_bat_tanh;
(empty)
batmmath
tanh
pattern batmmath.tanh(X_0:bat[:flt]):bat[:flt] 
CMDscience_bat_tanh;
(empty)
batmmath
tanh
pattern batmmath.tanh(X_0:bat[:flt], X_1:bat[:oid]):bat[:flt] 
CMDscience_bat_tanh;
(empty)
batmtime
addmonths
pattern batmtime.addmonths(X_0:bat[:date], X_1:bat[:int]):bat[:date] 
MTIMEdate_addmonths_bulk;
(empty)
batmtime
addmonths
pattern batmtime.addmonths(X_0:bat[:date], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:date] 
MTIMEdate_addmonths_bulk;
(empty)
batmtime
addmonths
pattern batmtime.addmonths(X_0:date, X_1:bat[:int]):bat[:date] 
MTIMEdate_addmonths_bulk_p1;
(empty)
batmtime
addmonths
pattern batmtime.addmonths(X_0:date, X_1:bat[:int], X_2:bat[:oid]):bat[:date] 
MTIMEdate_addmonths_bulk_p1;
(empty)
batmtime
addmonths
pattern batmtime.addmonths(X_0:bat[:date], X_1:int):bat[:date] 
MTIMEdate_addmonths_bulk_p2;
(empty)
batmtime
addmonths
pattern batmtime.addmonths(X_0:bat[:date], X_1:int, X_2:bat[:oid]):bat[:date] 
MTIMEdate_addmonths_bulk_p2;
(empty)
batmtime
century
pattern batmtime.century(X_0:bat[:date]):bat[:int] 
MTIMEdate_extract_century_bulk;
(empty)
batmtime
century
pattern batmtime.century(X_0:bat[:date], X_1:bat[:oid]):bat[:int] 
MTIMEdate_extract_century_bulk;
(empty)
batmtime
century
pattern batmtime.century(X_0:bat[:timestamp]):bat[:int] 
MTIMEtimestamp_century_bulk;
(empty)
batmtime
century
pattern batmtime.century(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:int] 
MTIMEtimestamp_century_bulk;
(empty)
batmtime
date_add_msec_interval
pattern batmtime.date_add_msec_interval(X_0:bat[:date], X_1:bat[:lng]):bat[:date] 
MTIMEdate_add_msec_interval_bulk;
(empty)
batmtime
date_add_msec_interval
pattern batmtime.date_add_msec_interval(X_0:bat[:date], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:date] 
MTIMEdate_add_msec_interval_bulk;
(empty)
batmtime
date_add_msec_interval
pattern batmtime.date_add_msec_interval(X_0:date, X_1:bat[:lng]):bat[:date] 
MTIMEdate_add_msec_interval_bulk_p1;
(empty)
batmtime
date_add_msec_interval
pattern batmtime.date_add_msec_interval(X_0:date, X_1:bat[:lng], X_2:bat[:oid]):bat[:date] 
MTIMEdate_add_msec_interval_bulk_p1;
(empty)
batmtime
date_add_msec_interval
pattern batmtime.date_add_msec_interval(X_0:bat[:date], X_1:lng):bat[:date] 
MTIMEdate_add_msec_interval_bulk_p2;
(empty)
batmtime
date_add_msec_interval
pattern batmtime.date_add_msec_interval(X_0:bat[:date], X_1:lng, X_2:bat[:oid]):bat[:date] 
MTIMEdate_add_msec_interval_bulk_p2;
(empty)
batmtime
date_sub_month_interval
pattern batmtime.date_sub_month_interval(X_0:bat[:date], X_1:bat[:int]):bat[:date] 
MTIMEdate_submonths_bulk;
(empty)
batmtime
date_sub_month_interval
pattern batmtime.date_sub_month_interval(X_0:bat[:date], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:date] 
MTIMEdate_submonths_bulk;
(empty)
batmtime
date_sub_month_interval
pattern batmtime.date_sub_month_interval(X_0:date, X_1:bat[:int]):bat[:date] 
MTIMEdate_submonths_bulk_p1;
(empty)
batmtime
date_sub_month_interval
pattern batmtime.date_sub_month_interval(X_0:date, X_1:bat[:int], X_2:bat[:oid]):bat[:date] 
MTIMEdate_submonths_bulk_p1;
(empty)
batmtime
date_sub_month_interval
pattern batmtime.date_sub_month_interval(X_0:bat[:date], X_1:int):bat[:date] 
MTIMEdate_submonths_bulk_p2;
(empty)
batmtime
date_sub_month_interval
pattern batmtime.date_sub_month_interval(X_0:bat[:date], X_1:int, X_2:bat[:oid]):bat[:date] 
MTIMEdate_submonths_bulk_p2;
(empty)
batmtime
date_sub_msec_interval
pattern batmtime.date_sub_msec_interval(X_0:bat[:date], X_1:bat[:lng]):bat[:date] 
MTIMEdate_sub_msec_interval_bulk;
(empty)
batmtime
date_sub_msec_interval
pattern batmtime.date_sub_msec_interval(X_0:bat[:date], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:date] 
MTIMEdate_sub_msec_interval_bulk;
(empty)
batmtime
date_sub_msec_interval
pattern batmtime.date_sub_msec_interval(X_0:date, X_1:bat[:lng]):bat[:date] 
MTIMEdate_sub_msec_interval_bulk_p1;
(empty)
batmtime
date_sub_msec_interval
pattern batmtime.date_sub_msec_interval(X_0:date, X_1:bat[:lng], X_2:bat[:oid]):bat[:date] 
MTIMEdate_sub_msec_interval_bulk_p1;
(empty)
batmtime
date_sub_msec_interval
pattern batmtime.date_sub_msec_interval(X_0:bat[:date], X_1:lng):bat[:date] 
MTIMEdate_sub_msec_interval_bulk_p2;
(empty)
batmtime
date_sub_msec_interval
pattern batmtime.date_sub_msec_interval(X_0:bat[:date], X_1:lng, X_2:bat[:oid]):bat[:date] 
MTIMEdate_sub_msec_interval_bulk_p2;
(empty)
batmtime
date_to_str
pattern batmtime.date_to_str(X_0:bat[:str], X_1:bat[:str]):bat[:str] 
MTIMEdate_to_str_bulk;
(empty)
batmtime
date_to_str
pattern batmtime.date_to_str(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
MTIMEdate_to_str_bulk;
(empty)
batmtime
date_to_str
pattern batmtime.date_to_str(X_0:date, X_1:bat[:str]):bat[:str] 
MTIMEdate_to_str_bulk_p1;
(empty)
batmtime
date_to_str
pattern batmtime.date_to_str(X_0:date, X_1:bat[:str], X_2:bat[:oid]):bat[:str] 
MTIMEdate_to_str_bulk_p1;
(empty)
batmtime
date_to_str
pattern batmtime.date_to_str(X_0:bat[:date], X_1:str):bat[:str] 
MTIMEdate_to_str_bulk_p2;
(empty)
batmtime
date_to_str
pattern batmtime.date_to_str(X_0:bat[:date], X_1:str, X_2:bat[:oid]):bat[:str] 
MTIMEdate_to_str_bulk_p2;
(empty)
batmtime
day
pattern batmtime.day(X_0:bat[:date]):bat[:int] 
MTIMEdate_extract_day_bulk;
(empty)
batmtime
day
pattern batmtime.day(X_0:bat[:date], X_1:bat[:oid]):bat[:int] 
MTIMEdate_extract_day_bulk;
(empty)
batmtime
day
pattern batmtime.day(X_0:bat[:lng]):bat[:lng] 
MTIMEsql_day_bulk;
(empty)
batmtime
day
pattern batmtime.day(X_0:bat[:lng], X_1:bat[:oid]):bat[:lng] 
MTIMEsql_day_bulk;
(empty)
batmtime
day
pattern batmtime.day(X_0:bat[:timestamp]):bat[:int] 
MTIMEtimestamp_day_bulk;
(empty)
batmtime
day
pattern batmtime.day(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:int] 
MTIMEtimestamp_day_bulk;
(empty)
batmtime
dayofweek
pattern batmtime.dayofweek(X_0:bat[:date]):bat[:int] 
MTIMEdate_extract_dayofweek_bulk;
(empty)
batmtime
dayofweek
pattern batmtime.dayofweek(X_0:bat[:date], X_1:bat[:oid]):bat[:int] 
MTIMEdate_extract_dayofweek_bulk;
(empty)
batmtime
dayofyear
pattern batmtime.dayofyear(X_0:bat[:date]):bat[:int] 
MTIMEdate_extract_dayofyear_bulk;
(empty)
batmtime
dayofyear
pattern batmtime.dayofyear(X_0:bat[:date], X_1:bat[:oid]):bat[:int] 
MTIMEdate_extract_dayofyear_bulk;
(empty)
batmtime
decade
pattern batmtime.decade(X_0:bat[:date]):bat[:int] 
MTIMEdate_extract_decade_bulk;
(empty)
batmtime
decade
pattern batmtime.decade(X_0:bat[:date], X_1:bat[:oid]):bat[:int] 
MTIMEdate_extract_decade_bulk;
(empty)
batmtime
decade
pattern batmtime.decade(X_0:bat[:timestamp]):bat[:int] 
MTIMEtimestamp_decade_bulk;
(empty)
batmtime
decade
pattern batmtime.decade(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:int] 
MTIMEtimestamp_decade_bulk;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:date], X_1:bat[:date]):bat[:lng] 
MTIMEdate_diff_bulk;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:date], X_1:bat[:date], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
MTIMEdate_diff_bulk;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:date, X_1:bat[:date]):bat[:lng] 
MTIMEdate_diff_bulk_p1;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:date, X_1:bat[:date], X_2:bat[:oid]):bat[:lng] 
MTIMEdate_diff_bulk_p1;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:date], X_1:date):bat[:lng] 
MTIMEdate_diff_bulk_p2;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:date], X_1:date, X_2:bat[:oid]):bat[:lng] 
MTIMEdate_diff_bulk_p2;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:daytime], X_1:bat[:daytime]):bat[:lng] 
MTIMEdaytime_diff_msec_bulk;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:daytime], X_1:bat[:daytime], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
MTIMEdaytime_diff_msec_bulk;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:daytime, X_1:bat[:daytime]):bat[:lng] 
MTIMEdaytime_diff_msec_bulk_p1;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:daytime, X_1:bat[:daytime], X_2:bat[:oid]):bat[:lng] 
MTIMEdaytime_diff_msec_bulk_p1;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:daytime], X_1:daytime):bat[:lng] 
MTIMEdaytime_diff_msec_bulk_p2;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:daytime], X_1:daytime, X_2:bat[:oid]):bat[:lng] 
MTIMEdaytime_diff_msec_bulk_p2;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:timestamp], X_1:bat[:timestamp]):bat[:lng] 
MTIMEtimestamp_diff_msec_bulk;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:timestamp], X_1:bat[:timestamp], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
MTIMEtimestamp_diff_msec_bulk;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:timestamp, X_1:bat[:timestamp]):bat[:lng] 
MTIMEtimestamp_diff_msec_bulk_p1;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:timestamp, X_1:bat[:timestamp], X_2:bat[:oid]):bat[:lng] 
MTIMEtimestamp_diff_msec_bulk_p1;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:timestamp], X_1:timestamp):bat[:lng] 
MTIMEtimestamp_diff_msec_bulk_p2;
(empty)
batmtime
diff
pattern batmtime.diff(X_0:bat[:timestamp], X_1:timestamp, X_2:bat[:oid]):bat[:lng] 
MTIMEtimestamp_diff_msec_bulk_p2;
(empty)
batmtime
epoch
pattern batmtime.epoch(X_0:bat[:timestamp]):bat[:int] 
MTIMEseconds_since_epoch_bulk;
(empty)
batmtime
epoch
pattern batmtime.epoch(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:int] 
MTIMEseconds_since_epoch_bulk;
(empty)
batmtime
epoch
pattern batmtime.epoch(X_0:bat[:lng]):bat[:timestamp] 
MTIMEtimestamp_frommsec_epoch_bulk;
(empty)
batmtime
epoch
pattern batmtime.epoch(X_0:bat[:lng], X_1:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_frommsec_epoch_bulk;
(empty)
batmtime
epoch
pattern batmtime.epoch(X_0:bat[:int]):bat[:timestamp] 
MTIMEtimestamp_fromsecond_epoch_bulk;
(empty)
batmtime
epoch
pattern batmtime.epoch(X_0:bat[:int], X_1:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_fromsecond_epoch_bulk;
(empty)
batmtime
epoch_ms
pattern batmtime.epoch_ms(X_0:bat[:date]):bat[:lng] 
MTIMEdate_extract_epoch_ms_bulk;
(empty)
batmtime
epoch_ms
pattern batmtime.epoch_ms(X_0:bat[:date], X_1:bat[:oid]):bat[:lng] 
MTIMEdate_extract_epoch_ms_bulk;
(empty)
batmtime
epoch_ms
pattern batmtime.epoch_ms(X_0:bat[:daytime]):bat[:lng] 
MTIMEdaytime_extract_epoch_ms_bulk;
(empty)
batmtime
epoch_ms
pattern batmtime.epoch_ms(X_0:bat[:daytime], X_1:bat[:oid]):bat[:lng] 
MTIMEdaytime_extract_epoch_ms_bulk;
(empty)
batmtime
epoch_ms
pattern batmtime.epoch_ms(X_0:bat[:lng]):bat[:lng] 
MTIMEmsec_extract_epoch_ms_bulk;
(empty)
batmtime
epoch_ms
pattern batmtime.epoch_ms(X_0:bat[:lng], X_1:bat[:oid]):bat[:lng] 
MTIMEmsec_extract_epoch_ms_bulk;
(empty)
batmtime
epoch_ms
pattern batmtime.epoch_ms(X_0:bat[:timestamp]):bat[:lng] 
MTIMEtimestamp_extract_epoch_ms_bulk;
(empty)
batmtime
epoch_ms
pattern batmtime.epoch_ms(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:lng] 
MTIMEtimestamp_extract_epoch_ms_bulk;
(empty)
batmtime
hours
pattern batmtime.hours(X_0:bat[:daytime]):bat[:int] 
MTIMEdaytime_extract_hours_bulk;
(empty)
batmtime
hours
pattern batmtime.hours(X_0:bat[:daytime], X_1:bat[:oid]):bat[:int] 
MTIMEdaytime_extract_hours_bulk;
(empty)
batmtime
hours
pattern batmtime.hours(X_0:bat[:lng]):bat[:int] 
MTIMEsql_hours_bulk;
(empty)
batmtime
hours
pattern batmtime.hours(X_0:bat[:lng], X_1:bat[:oid]):bat[:int] 
MTIMEsql_hours_bulk;
(empty)
batmtime
hours
pattern batmtime.hours(X_0:bat[:timestamp]):bat[:int] 
MTIMEtimestamp_hours_bulk;
(empty)
batmtime
hours
pattern batmtime.hours(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:int] 
MTIMEtimestamp_hours_bulk;
(empty)
batmtime
minutes
pattern batmtime.minutes(X_0:bat[:daytime]):bat[:int] 
MTIMEdaytime_extract_minutes_bulk;
(empty)
batmtime
minutes
pattern batmtime.minutes(X_0:bat[:daytime], X_1:bat[:oid]):bat[:int] 
MTIMEdaytime_extract_minutes_bulk;
(empty)
batmtime
minutes
pattern batmtime.minutes(X_0:bat[:lng]):bat[:int] 
MTIMEsql_minutes_bulk;
(empty)
batmtime
minutes
pattern batmtime.minutes(X_0:bat[:lng], X_1:bat[:oid]):bat[:int] 
MTIMEsql_minutes_bulk;
(empty)
batmtime
minutes
pattern batmtime.minutes(X_0:bat[:timestamp]):bat[:int] 
MTIMEtimestamp_minutes_bulk;
(empty)
batmtime
minutes
pattern batmtime.minutes(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:int] 
MTIMEtimestamp_minutes_bulk;
(empty)
batmtime
month
pattern batmtime.month(X_0:bat[:date]):bat[:int] 
MTIMEdate_extract_month_bulk;
(empty)
batmtime
month
pattern batmtime.month(X_0:bat[:date], X_1:bat[:oid]):bat[:int] 
MTIMEdate_extract_month_bulk;
(empty)
batmtime
month
pattern batmtime.month(X_0:bat[:int]):bat[:int] 
MTIMEsql_month_bulk;
(empty)
batmtime
month
pattern batmtime.month(X_0:bat[:int], X_1:bat[:oid]):bat[:int] 
MTIMEsql_month_bulk;
(empty)
batmtime
month
pattern batmtime.month(X_0:bat[:timestamp]):bat[:int] 
MTIMEtimestamp_month_bulk;
(empty)
batmtime
month
pattern batmtime.month(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:int] 
MTIMEtimestamp_month_bulk;
(empty)
batmtime
quarter
pattern batmtime.quarter(X_0:bat[:date]):bat[:int] 
MTIMEdate_extract_quarter_bulk;
(empty)
batmtime
quarter
pattern batmtime.quarter(X_0:bat[:date], X_1:bat[:oid]):bat[:int] 
MTIMEdate_extract_quarter_bulk;
(empty)
batmtime
quarter
pattern batmtime.quarter(X_0:bat[:timestamp]):bat[:int] 
MTIMEtimestamp_quarter_bulk;
(empty)
batmtime
quarter
pattern batmtime.quarter(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:int] 
MTIMEtimestamp_quarter_bulk;
(empty)
batmtime
seconds
pattern batmtime.seconds(X_0:bat[:lng]):bat[:int] 
MTIMEsql_seconds_bulk;
(empty)
batmtime
seconds
pattern batmtime.seconds(X_0:bat[:lng], X_1:bat[:oid]):bat[:int] 
MTIMEsql_seconds_bulk;
(empty)
batmtime
sql_seconds
pattern batmtime.sql_seconds(X_0:bat[:daytime]):bat[:int] 
MTIMEdaytime_extract_sql_seconds_bulk;
(empty)
batmtime
sql_seconds
pattern batmtime.sql_seconds(X_0:bat[:daytime], X_1:bat[:oid]):bat[:int] 
MTIMEdaytime_extract_sql_seconds_bulk;
(empty)
batmtime
sql_seconds
pattern batmtime.sql_seconds(X_0:bat[:timestamp]):bat[:int] 
MTIMEtimestamp_sql_seconds_bulk;
(empty)
batmtime
sql_seconds
pattern batmtime.sql_seconds(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:int] 
MTIMEtimestamp_sql_seconds_bulk;
(empty)
batmtime
str_to_date
pattern batmtime.str_to_date(X_0:bat[:str], X_1:bat[:str]):bat[:date] 
MTIMEstr_to_date_bulk;
(empty)
batmtime
str_to_date
pattern batmtime.str_to_date(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:date] 
MTIMEstr_to_date_bulk;
(empty)
batmtime
str_to_date
pattern batmtime.str_to_date(X_0:str, X_1:bat[:str]):bat[:date] 
MTIMEstr_to_date_bulk_p1;
(empty)
batmtime
str_to_date
pattern batmtime.str_to_date(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:date] 
MTIMEstr_to_date_bulk_p1;
(empty)
batmtime
str_to_date
pattern batmtime.str_to_date(X_0:bat[:str], X_1:str):bat[:date] 
MTIMEstr_to_date_bulk_p2;
(empty)
batmtime
str_to_date
pattern batmtime.str_to_date(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:date] 
MTIMEstr_to_date_bulk_p2;
(empty)
batmtime
str_to_time
pattern batmtime.str_to_time(X_0:bat[:str], X_1:bat[:str]):bat[:daytime] 
MTIMEstr_to_time_bulk;
(empty)
batmtime
str_to_time
pattern batmtime.str_to_time(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:daytime] 
MTIMEstr_to_time_bulk;
(empty)
batmtime
str_to_time
pattern batmtime.str_to_time(X_0:str, X_1:bat[:str]):bat[:daytime] 
MTIMEstr_to_time_bulk_p1;
(empty)
batmtime
str_to_time
pattern batmtime.str_to_time(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:daytime] 
MTIMEstr_to_time_bulk_p1;
(empty)
batmtime
str_to_time
pattern batmtime.str_to_time(X_0:bat[:str], X_1:str):bat[:daytime] 
MTIMEstr_to_time_bulk_p2;
(empty)
batmtime
str_to_time
pattern batmtime.str_to_time(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:daytime] 
MTIMEstr_to_time_bulk_p2;
(empty)
batmtime
str_to_timestamp
pattern batmtime.str_to_timestamp(X_0:bat[:str], X_1:bat[:str]):bat[:timestamp] 
MTIMEstr_to_timestamp_bulk;
(empty)
batmtime
str_to_timestamp
pattern batmtime.str_to_timestamp(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:timestamp] 
MTIMEstr_to_timestamp_bulk;
(empty)
batmtime
str_to_timestamp
pattern batmtime.str_to_timestamp(X_0:str, X_1:bat[:str]):bat[:timestamp] 
MTIMEstr_to_timestamp_bulk_p1;
(empty)
batmtime
str_to_timestamp
pattern batmtime.str_to_timestamp(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:timestamp] 
MTIMEstr_to_timestamp_bulk_p1;
(empty)
batmtime
str_to_timestamp
pattern batmtime.str_to_timestamp(X_0:bat[:str], X_1:str):bat[:timestamp] 
MTIMEstr_to_timestamp_bulk_p2;
(empty)
batmtime
str_to_timestamp
pattern batmtime.str_to_timestamp(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:timestamp] 
MTIMEstr_to_timestamp_bulk_p2;
(empty)
batmtime
time_add_msec_interval
pattern batmtime.time_add_msec_interval(X_0:bat[:daytime], X_1:bat[:lng]):bat[:daytime] 
MTIMEtime_add_msec_interval_bulk;
(empty)
batmtime
time_add_msec_interval
pattern batmtime.time_add_msec_interval(X_0:bat[:daytime], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:daytime] 
MTIMEtime_add_msec_interval_bulk;
(empty)
batmtime
time_add_msec_interval
pattern batmtime.time_add_msec_interval(X_0:daytime, X_1:bat[:lng]):bat[:daytime] 
MTIMEtime_add_msec_interval_bulk_p1;
(empty)
batmtime
time_add_msec_interval
pattern batmtime.time_add_msec_interval(X_0:daytime, X_1:bat[:lng], X_2:bat[:oid]):bat[:daytime] 
MTIMEtime_add_msec_interval_bulk_p1;
(empty)
batmtime
time_add_msec_interval
pattern batmtime.time_add_msec_interval(X_0:bat[:daytime], X_1:lng):bat[:daytime] 
MTIMEtime_add_msec_interval_bulk_p2;
(empty)
batmtime
time_add_msec_interval
pattern batmtime.time_add_msec_interval(X_0:bat[:daytime], X_1:lng, X_2:bat[:oid]):bat[:daytime] 
MTIMEtime_add_msec_interval_bulk_p2;
(empty)
batmtime
time_sub_msec_interval
pattern batmtime.time_sub_msec_interval(X_0:bat[:daytime], X_1:bat[:lng]):bat[:daytime] 
MTIMEtime_sub_msec_interval_bulk;
(empty)
batmtime
time_sub_msec_interval
pattern batmtime.time_sub_msec_interval(X_0:bat[:daytime], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:daytime] 
MTIMEtime_sub_msec_interval_bulk;
(empty)
batmtime
time_sub_msec_interval
pattern batmtime.time_sub_msec_interval(X_0:daytime, X_1:bat[:lng]):bat[:daytime] 
MTIMEtime_sub_msec_interval_bulk_p1;
(empty)
batmtime
time_sub_msec_interval
pattern batmtime.time_sub_msec_interval(X_0:daytime, X_1:bat[:lng], X_2:bat[:oid]):bat[:daytime] 
MTIMEtime_sub_msec_interval_bulk_p1;
(empty)
batmtime
time_sub_msec_interval
pattern batmtime.time_sub_msec_interval(X_0:bat[:daytime], X_1:lng):bat[:daytime] 
MTIMEtime_sub_msec_interval_bulk_p2;
(empty)
batmtime
time_sub_msec_interval
pattern batmtime.time_sub_msec_interval(X_0:bat[:daytime], X_1:lng, X_2:bat[:oid]):bat[:daytime] 
MTIMEtime_sub_msec_interval_bulk_p2;
(empty)
batmtime
time_to_str
pattern batmtime.time_to_str(X_0:bat[:daytime], X_1:bat[:str]):bat[:str] 
MTIMEtime_to_str_bulk;
(empty)
batmtime
time_to_str
pattern batmtime.time_to_str(X_0:bat[:daytime], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
MTIMEtime_to_str_bulk;
(empty)
batmtime
time_to_str
pattern batmtime.time_to_str(X_0:daytime, X_1:bat[:str]):bat[:str] 
MTIMEtime_to_str_bulk_p1;
(empty)
batmtime
time_to_str
pattern batmtime.time_to_str(X_0:daytime, X_1:bat[:str], X_2:bat[:oid]):bat[:str] 
MTIMEtime_to_str_bulk_p1;
(empty)
batmtime
time_to_str
pattern batmtime.time_to_str(X_0:bat[:daytime], X_1:str):bat[:str] 
MTIMEtime_to_str_bulk_p2;
(empty)
batmtime
time_to_str
pattern batmtime.time_to_str(X_0:bat[:daytime], X_1:str, X_2:bat[:oid]):bat[:str] 
MTIMEtime_to_str_bulk_p2;
(empty)
batmtime
timestamp_add_month_interval
pattern batmtime.timestamp_add_month_interval(X_0:bat[:timestamp], X_1:bat[:int]):bat[:timestamp] 
MTIMEtimestamp_add_month_interval_bulk;
(empty)
batmtime
timestamp_add_month_interval
pattern batmtime.timestamp_add_month_interval(X_0:bat[:timestamp], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_add_month_interval_bulk;
(empty)
batmtime
timestamp_add_month_interval
pattern batmtime.timestamp_add_month_interval(X_0:timestamp, X_1:bat[:int]):bat[:timestamp] 
MTIMEtimestamp_add_month_interval_bulk_p1;
(empty)
batmtime
timestamp_add_month_interval
pattern batmtime.timestamp_add_month_interval(X_0:timestamp, X_1:bat[:int], X_2:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_add_month_interval_bulk_p1;
(empty)
batmtime
timestamp_add_month_interval
pattern batmtime.timestamp_add_month_interval(X_0:bat[:timestamp], X_1:int):bat[:timestamp] 
MTIMEtimestamp_add_month_interval_bulk_p2;
(empty)
batmtime
timestamp_add_month_interval
pattern batmtime.timestamp_add_month_interval(X_0:bat[:timestamp], X_1:int, X_2:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_add_month_interval_bulk_p2;
(empty)
batmtime
timestamp_add_msec_interval
pattern batmtime.timestamp_add_msec_interval(X_0:bat[:timestamp], X_1:bat[:lng]):bat[:timestamp] 
MTIMEtimestamp_add_msec_interval_bulk;
(empty)
batmtime
timestamp_add_msec_interval
pattern batmtime.timestamp_add_msec_interval(X_0:bat[:timestamp], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_add_msec_interval_bulk;
(empty)
batmtime
timestamp_add_msec_interval
pattern batmtime.timestamp_add_msec_interval(X_0:timestamp, X_1:bat[:lng]):bat[:timestamp] 
MTIMEtimestamp_add_msec_interval_bulk_p1;
(empty)
batmtime
timestamp_add_msec_interval
pattern batmtime.timestamp_add_msec_interval(X_0:timestamp, X_1:bat[:lng], X_2:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_add_msec_interval_bulk_p1;
(empty)
batmtime
timestamp_add_msec_interval
pattern batmtime.timestamp_add_msec_interval(X_0:bat[:timestamp], X_1:lng):bat[:timestamp] 
MTIMEtimestamp_add_msec_interval_bulk_p2;
(empty)
batmtime
timestamp_add_msec_interval
pattern batmtime.timestamp_add_msec_interval(X_0:bat[:timestamp], X_1:lng, X_2:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_add_msec_interval_bulk_p2;
(empty)
batmtime
timestamp_sub_month_interval
pattern batmtime.timestamp_sub_month_interval(X_0:bat[:timestamp], X_1:bat[:int]):bat[:timestamp] 
MTIMEtimestamp_sub_month_interval_bulk;
(empty)
batmtime
timestamp_sub_month_interval
pattern batmtime.timestamp_sub_month_interval(X_0:bat[:timestamp], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_sub_month_interval_bulk;
(empty)
batmtime
timestamp_sub_month_interval
pattern batmtime.timestamp_sub_month_interval(X_0:timestamp, X_1:bat[:int]):bat[:timestamp] 
MTIMEtimestamp_sub_month_interval_bulk_p1;
(empty)
batmtime
timestamp_sub_month_interval
pattern batmtime.timestamp_sub_month_interval(X_0:timestamp, X_1:bat[:int], X_2:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_sub_month_interval_bulk_p1;
(empty)
batmtime
timestamp_sub_month_interval
pattern batmtime.timestamp_sub_month_interval(X_0:bat[:timestamp], X_1:int):bat[:timestamp] 
MTIMEtimestamp_sub_month_interval_bulk_p2;
(empty)
batmtime
timestamp_sub_month_interval
pattern batmtime.timestamp_sub_month_interval(X_0:bat[:timestamp], X_1:int, X_2:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_sub_month_interval_bulk_p2;
(empty)
batmtime
timestamp_sub_msec_interval
pattern batmtime.timestamp_sub_msec_interval(X_0:bat[:timestamp], X_1:bat[:lng]):bat[:timestamp] 
MTIMEtimestamp_sub_msec_interval_bulk;
(empty)
batmtime
timestamp_sub_msec_interval
pattern batmtime.timestamp_sub_msec_interval(X_0:bat[:timestamp], X_1:bat[:lng], X_2:bat[:oid], X_3:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_sub_msec_interval_bulk;
(empty)
batmtime
timestamp_sub_msec_interval
pattern batmtime.timestamp_sub_msec_interval(X_0:timestamp, X_1:bat[:lng]):bat[:timestamp] 
MTIMEtimestamp_sub_msec_interval_bulk_p1;
(empty)
batmtime
timestamp_sub_msec_interval
pattern batmtime.timestamp_sub_msec_interval(X_0:timestamp, X_1:bat[:lng], X_2:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_sub_msec_interval_bulk_p1;
(empty)
batmtime
timestamp_sub_msec_interval
pattern batmtime.timestamp_sub_msec_interval(X_0:bat[:timestamp], X_1:lng):bat[:timestamp] 
MTIMEtimestamp_sub_msec_interval_bulk_p2;
(empty)
batmtime
timestamp_sub_msec_interval
pattern batmtime.timestamp_sub_msec_interval(X_0:bat[:timestamp], X_1:lng, X_2:bat[:oid]):bat[:timestamp] 
MTIMEtimestamp_sub_msec_interval_bulk_p2;
(empty)
batmtime
timestamp_to_str
pattern batmtime.timestamp_to_str(X_0:bat[:timestamp], X_1:bat[:str]):bat[:str] 
MTIMEtimestamp_to_str_bulk;
(empty)
batmtime
timestamp_to_str
pattern batmtime.timestamp_to_str(X_0:bat[:timestamp], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
MTIMEtimestamp_to_str_bulk;
(empty)
batmtime
timestamp_to_str
pattern batmtime.timestamp_to_str(X_0:timestamp, X_1:bat[:str]):bat[:str] 
MTIMEtimestamp_to_str_bulk_p1;
(empty)
batmtime
timestamp_to_str
pattern batmtime.timestamp_to_str(X_0:timestamp, X_1:bat[:str], X_2:bat[:oid]):bat[:str] 
MTIMEtimestamp_to_str_bulk_p1;
(empty)
batmtime
timestamp_to_str
pattern batmtime.timestamp_to_str(X_0:bat[:timestamp], X_1:str):bat[:str] 
MTIMEtimestamp_to_str_bulk_p2;
(empty)
batmtime
timestamp_to_str
pattern batmtime.timestamp_to_str(X_0:bat[:timestamp], X_1:str, X_2:bat[:oid]):bat[:str] 
MTIMEtimestamp_to_str_bulk_p2;
(empty)
batmtime
usweekofyear
pattern batmtime.usweekofyear(X_0:bat[:date]):bat[:int] 
MTIMEdate_extract_usweekofyear_bulk;
(empty)
batmtime
usweekofyear
pattern batmtime.usweekofyear(X_0:bat[:date], X_1:bat[:oid]):bat[:int] 
MTIMEdate_extract_usweekofyear_bulk;
(empty)
batmtime
weekofyear
pattern batmtime.weekofyear(X_0:bat[:date]):bat[:int] 
MTIMEdate_extract_weekofyear_bulk;
(empty)
batmtime
weekofyear
pattern batmtime.weekofyear(X_0:bat[:date], X_1:bat[:oid]):bat[:int] 
MTIMEdate_extract_weekofyear_bulk;
(empty)
batmtime
year
pattern batmtime.year(X_0:bat[:date]):bat[:int] 
MTIMEdate_extract_year_bulk;
(empty)
batmtime
year
pattern batmtime.year(X_0:bat[:date], X_1:bat[:oid]):bat[:int] 
MTIMEdate_extract_year_bulk;
(empty)
batmtime
year
pattern batmtime.year(X_0:bat[:int]):bat[:int] 
MTIMEsql_year_bulk;
(empty)
batmtime
year
pattern batmtime.year(X_0:bat[:int], X_1:bat[:oid]):bat[:int] 
MTIMEsql_year_bulk;
(empty)
batmtime
year
pattern batmtime.year(X_0:bat[:timestamp]):bat[:int] 
MTIMEtimestamp_year_bulk;
(empty)
batmtime
year
pattern batmtime.year(X_0:bat[:timestamp], X_1:bat[:oid]):bat[:int] 
MTIMEtimestamp_year_bulk;
(empty)
batpcre
replace
command batpcre.replace(X_0:bat[:str], X_1:str, X_2:str, X_3:str):bat[:str] 
PCREreplace_bat_wrap;
(empty)
batpcre
replace_first
command batpcre.replace_first(X_0:bat[:str], X_1:str, X_2:str, X_3:str):bat[:str] 
PCREreplacefirst_bat_wrap;
(empty)
batpyapi3
eval
unsafe pattern batpyapi3.eval(X_0:lng, X_1:ptr, X_2:str):any... 
PYAPI3PyAPIevalStd;
Execute a simple Python script value
batpyapi3
eval
unsafe pattern batpyapi3.eval(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalStd;
Execute a simple Python script value
batpyapi3
eval_aggr
unsafe pattern batpyapi3.eval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalAggr;
grouped aggregates through Python
batpyapi3
eval_loader
unsafe pattern batpyapi3.eval_loader(X_0:ptr, X_1:str):any... 
PYAPI3PyAPIevalLoader;
loader functions through Python
batpyapi3
eval_loader
unsafe pattern batpyapi3.eval_loader(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalLoader;
loader functions through Python
batpyapi3
subeval_aggr
unsafe pattern batpyapi3.subeval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalAggr;
grouped aggregates through Python
batpyapi3map
eval
pattern batpyapi3map.eval(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalStdMap;
Execute a simple Python script value
batpyapi3map
eval_aggr
pattern batpyapi3map.eval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalAggrMap;
grouped aggregates through Python
batpyapi3map
subeval_aggr
pattern batpyapi3map.subeval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalAggrMap;
grouped aggregates through Python
batrapi
eval
pattern batrapi.eval(X_0:lng, X_1:ptr, X_2:str):any... 
RAPIevalStd;
Execute a simple R script value
batrapi
eval
pattern batrapi.eval(X_0:ptr, X_1:str, X_2:any...):any... 
RAPIevalStd;
Execute a simple R script value
batrapi
eval_aggr
pattern batrapi.eval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
RAPIevalAggr;
grouped aggregates through R
batrapi
subeval_aggr
pattern batrapi.subeval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
RAPIevalAggr;
grouped aggregates through R
batsql
all
pattern batsql.all(X_0:bat[:bit], X_1:bat[:bit], X_2:bat[:bit]):bat[:bit] 
SQLall_cmp;
if !cmp then false, (nl or nr) then nil, else true
batsql
all
pattern batsql.all(X_0:bat[:bit], X_1:bat[:bit], X_2:bit):bat[:bit] 
SQLall_cmp;
if !cmp then false, (nl or nr) then nil, else true
batsql
all
pattern batsql.all(X_0:bat[:bit], X_1:bit, X_2:bat[:bit]):bat[:bit] 
SQLall_cmp;
if !cmp then false, (nl or nr) then nil, else true
batsql
all
pattern batsql.all(X_0:bat[:bit], X_1:bit, X_2:bit):bat[:bit] 
SQLall_cmp;
if !cmp then false, (nl or nr) then nil, else true
batsql
all
pattern batsql.all(X_0:bit, X_1:bat[:bit], X_2:bat[:bit]):bat[:bit] 
SQLall_cmp;
if !cmp then false, (nl or nr) then nil, else true
batsql
all
pattern batsql.all(X_0:bit, X_1:bat[:bit], X_2:bit):bat[:bit] 
SQLall_cmp;
if !cmp then false, (nl or nr) then nil, else true
batsql
all
pattern batsql.all(X_0:bit, X_1:bit, X_2:bat[:bit]):bat[:bit] 
SQLall_cmp;
if !cmp then false, (nl or nr) then nil, else true
batsql
alpha
command batsql.alpha(X_0:bat[:dbl], X_1:dbl):bat[:dbl] 
SQLbat_alpha_cst;
BAT implementation of astronomy alpha function
batsql
alpha
command batsql.alpha(X_0:dbl, X_1:bat[:dbl]):bat[:dbl] 
SQLcst_alpha_bat;
BAT implementation of astronomy alpha function
batsql
any
pattern batsql.any(X_0:bat[:bit], X_1:bat[:bit], X_2:bat[:bit]):bat[:bit] 
SQLany_cmp;
if cmp then true, (nl or nr) nil then nil, else false
batsql
any
pattern batsql.any(X_0:bat[:bit], X_1:bat[:bit], X_2:bit):bat[:bit] 
SQLany_cmp;
if cmp then true, (nl or nr) nil then nil, else false
batsql
any
pattern batsql.any(X_0:bat[:bit], X_1:bit, X_2:bat[:bit]):bat[:bit] 
SQLany_cmp;
if cmp then true, (nl or nr) nil then nil, else false
batsql
any
pattern batsql.any(X_0:bat[:bit], X_1:bit, X_2:bit):bat[:bit] 
SQLany_cmp;
if cmp then true, (nl or nr) nil then nil, else false
batsql
any
pattern batsql.any(X_0:bit, X_1:bat[:bit], X_2:bat[:bit]):bat[:bit] 
SQLany_cmp;
if cmp then true, (nl or nr) nil then nil, else false
batsql
any
pattern batsql.any(X_0:bit, X_1:bat[:bit], X_2:bit):bat[:bit] 
SQLany_cmp;
if cmp then true, (nl or nr) nil then nil, else false
batsql
any
pattern batsql.any(X_0:bit, X_1:bit, X_2:bat[:bit]):bat[:bit] 
SQLany_cmp;
if cmp then true, (nl or nr) nil then nil, else false
batsql
avg
pattern batsql.avg(X_0:bat[:bte], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLavg;
return the average of groups
batsql
avg
pattern batsql.avg(X_0:bat[:dbl], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLavg;
return the average of groups
batsql
avg
pattern batsql.avg(X_0:bat[:flt], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLavg;
return the average of groups
batsql
avg
pattern batsql.avg(X_0:bat[:int], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLavg;
return the average of groups
batsql
avg
pattern batsql.avg(X_0:bat[:lng], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLavg;
return the average of groups
batsql
avg
pattern batsql.avg(X_0:bat[:sht], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLavg;
return the average of groups
batsql
avg
pattern batsql.avg(X_0:bat[:bte], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:bte] 
SQLavginteger;
return the average of groups
batsql
avg
pattern batsql.avg(X_0:bat[:int], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:int] 
SQLavginteger;
return the average of groups
batsql
avg
pattern batsql.avg(X_0:bat[:lng], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:lng] 
SQLavginteger;
return the average of groups
batsql
avg
pattern batsql.avg(X_0:bat[:sht], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:sht] 
SQLavginteger;
return the average of groups
batsql
corr
pattern batsql.corr(X_0:bat[:bte], X_1:bat[:bte], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:bte], X_1:bte, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:dbl], X_1:bat[:dbl], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:dbl], X_1:dbl, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:flt], X_1:bat[:flt], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:flt], X_1:flt, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:int], X_1:bat[:int], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:int], X_1:int, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:lng], X_1:bat[:lng], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:lng], X_1:lng, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:sht], X_1:bat[:sht], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bat[:sht], X_1:sht, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:bte, X_1:bat[:bte], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:dbl, X_1:bat[:dbl], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:flt, X_1:bat[:flt], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:int, X_1:bat[:int], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:lng, X_1:bat[:lng], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
corr
pattern batsql.corr(X_0:sht, X_1:bat[:sht], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcorr;
return the correlation value of groups
batsql
count
pattern batsql.count(X_0:bat[:any_1], X_1:bit, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:lng] 
SQLcount;
return count of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:bte], X_1:bat[:bte], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:bte], X_1:bte, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:dbl], X_1:bat[:dbl], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:dbl], X_1:dbl, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:flt], X_1:bat[:flt], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:flt], X_1:flt, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:int], X_1:bat[:int], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:int], X_1:int, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:lng], X_1:bat[:lng], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:lng], X_1:lng, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:sht], X_1:bat[:sht], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bat[:sht], X_1:sht, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:bte, X_1:bat[:bte], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:dbl, X_1:bat[:dbl], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:flt, X_1:bat[:flt], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:int, X_1:bat[:int], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:lng, X_1:bat[:lng], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariance
pattern batsql.covariance(X_0:sht, X_1:bat[:sht], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_samp;
return the covariance sample value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:bte], X_1:bat[:bte], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:bte], X_1:bte, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:dbl], X_1:bat[:dbl], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:dbl], X_1:dbl, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:flt], X_1:bat[:flt], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:flt], X_1:flt, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:int], X_1:bat[:int], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:int], X_1:int, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:lng], X_1:bat[:lng], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:lng], X_1:lng, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:sht], X_1:bat[:sht], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bat[:sht], X_1:sht, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:bte, X_1:bat[:bte], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:dbl, X_1:bat[:dbl], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:flt, X_1:bat[:flt], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:int, X_1:bat[:int], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:lng, X_1:bat[:lng], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
covariancep
pattern batsql.covariancep(X_0:sht, X_1:bat[:sht], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:dbl] 
SQLcovar_pop;
return the covariance population value of groups
batsql
cume_dist
pattern batsql.cume_dist(X_0:bat[:any_1], X_1:any_2, X_2:any_3):bat[:dbl] 
SQLcume_dist;
return the accumulated distribution of the number of rows per group to the total number of partition rows
batsql
dense_rank
pattern batsql.dense_rank(X_0:bat[:any_1], X_1:any_2, X_2:any_3):bat[:int] 
SQLdense_rank;
return the densely ranked groups
batsql
diff
pattern batsql.diff(X_0:bat[:any_1]):bat[:bit] 
SQLdiff;
return true if cur != prev row
batsql
diff
pattern batsql.diff(X_0:bat[:bit], X_1:any_1):bat[:bit] 
SQLdiff;
return true if cur != prev row
batsql
diff
pattern batsql.diff(X_0:bat[:bit], X_1:bat[:any_1]):bat[:bit] 
SQLdiff;
return true if cur != prev row
batsql
diff
pattern batsql.diff(X_0:bit, X_1:bat[:any_1]):bat[:bit] 
SQLdiff;
return true if cur != prev row
batsql
first_value
pattern batsql.first_value(X_0:bat[:any_1], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:any_1] 
SQLfirst_value;
return the first value of groups
batsql
get_value
pattern batsql.get_value(X_0:bat[:str], X_1:bat[:str]):bat[:lng] 
mvc_get_value_bulk;
return the current value of the sequence (ie the next to be used value)
batsql
get_value
pattern batsql.get_value(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:lng] 
mvc_get_value_bulk;
return the current value of the sequence (ie the next to be used value)
batsql
index
command batsql.index(X_0:bat[:str], X_1:bit):bat[:bte] 
BATSTRindex_bte;
Return the offsets as an index bat
batsql
index
command batsql.index(X_0:bat[:str], X_1:bit):bat[:int] 
BATSTRindex_int;
Return the offsets as an index bat
batsql
index
command batsql.index(X_0:bat[:str], X_1:bit):bat[:sht] 
BATSTRindex_sht;
Return the offsets as an index bat
batsql
lag
pattern batsql.lag(X_0:any_1, X_1:any, X_2:bat[:any_1], X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlag;
return the value in the previous 'l' row in the partition or 'd' if non existent
batsql
lag
pattern batsql.lag(X_0:any_1, X_1:bat[:any], X_2:any_1, X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlag;
return the value in the previous 'l' row in the partition or 'd' if non existent
batsql
lag
pattern batsql.lag(X_0:any_1, X_1:bat[:any], X_2:any_2, X_3:any_3):bat[:any_1] 
SQLlag;
return the value in the previous 'l' row in the partition or NULL if non existent
batsql
lag
pattern batsql.lag(X_0:any_1, X_1:bat[:any], X_2:bat[:any_1], X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlag;
return the value in the previous 'l' row in the partition or 'd' if non existent
batsql
lag
pattern batsql.lag(X_0:bat[:any_1], X_1:any, X_2:any_1, X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlag;
return the value in the previous 'l' row in the partition or 'd' if non existent
batsql
lag
pattern batsql.lag(X_0:bat[:any_1], X_1:any, X_2:any_2, X_3:any_3):bat[:any_1] 
SQLlag;
return the value in the previous 'l' row in the partition or NULL if non existent
batsql
lag
pattern batsql.lag(X_0:bat[:any_1], X_1:any, X_2:bat[:any_1], X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlag;
return the value in the previous 'l' row in the partition or 'd' if non existent
batsql
lag
pattern batsql.lag(X_0:bat[:any_1], X_1:any_2, X_2:any_3):bat[:any_1] 
SQLlag;
return the value in the previous row in the partition or NULL if non existent
batsql
lag
pattern batsql.lag(X_0:bat[:any_1], X_1:bat[:any], X_2:any_1, X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlag;
return the value in the previous 'l' row in the partition or 'd' if non existent
batsql
lag
pattern batsql.lag(X_0:bat[:any_1], X_1:bat[:any], X_2:any_2, X_3:any_3):bat[:any_1] 
SQLlag;
return the value in the previous 'l' row in the partition or NULL if non existent
batsql
lag
pattern batsql.lag(X_0:bat[:any_1], X_1:bat[:any], X_2:bat[:any_1], X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlag;
return the value in the previous 'l' row in the partition or 'd' if non existent
batsql
last_value
pattern batsql.last_value(X_0:bat[:any_1], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:any_1] 
SQLlast_value;
return the last value of groups
batsql
lead
pattern batsql.lead(X_0:any_1, X_1:any, X_2:bat[:any_1], X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlead;
return the value in the next 'l' row in the partition or 'd' if non existent
batsql
lead
pattern batsql.lead(X_0:any_1, X_1:bat[:any], X_2:any_1, X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlead;
return the value in the next 'l' row in the partition or 'd' if non existent
batsql
lead
pattern batsql.lead(X_0:any_1, X_1:bat[:any], X_2:any_2, X_3:any_3):bat[:any_1] 
SQLlead;
return the value in the next 'l' row in the partition or NULL if non existent
batsql
lead
pattern batsql.lead(X_0:any_1, X_1:bat[:any], X_2:bat[:any_1], X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlead;
return the value in the next 'l' row in the partition or 'd' if non existent
batsql
lead
pattern batsql.lead(X_0:bat[:any_1], X_1:any, X_2:any_1, X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlead;
return the value in the next 'l' row in the partition or 'd' if non existent
batsql
lead
pattern batsql.lead(X_0:bat[:any_1], X_1:any, X_2:any_2, X_3:any_3):bat[:any_1] 
SQLlead;
return the value in the next 'l' row in the partition or NULL if non existent
batsql
lead
pattern batsql.lead(X_0:bat[:any_1], X_1:any, X_2:bat[:any_1], X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlead;
return the value in the next 'l' row in the partition or 'd' if non existent
batsql
lead
pattern batsql.lead(X_0:bat[:any_1], X_1:any_2, X_2:any_3):bat[:any_1] 
SQLlead;
return the value in the next row in the partition or NULL if non existent
batsql
lead
pattern batsql.lead(X_0:bat[:any_1], X_1:bat[:any], X_2:any_1, X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlead;
return the value in the next 'l' row in the partition or 'd' if non existent
batsql
lead
pattern batsql.lead(X_0:bat[:any_1], X_1:bat[:any], X_2:any_2, X_3:any_3):bat[:any_1] 
SQLlead;
return the value in the next 'l' row in the partition or NULL if non existent
batsql
lead
pattern batsql.lead(X_0:bat[:any_1], X_1:bat[:any], X_2:bat[:any_1], X_3:any_2, X_4:any_3):bat[:any_1] 
SQLlead;
return the value in the next 'l' row in the partition or 'd' if non existent
batsql
max
pattern batsql.max(X_0:bat[:any_1], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:any_1] 
SQLmax;
return the maximum of groups
batsql
min
pattern batsql.min(X_0:bat[:any_1], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:any_1] 
SQLmin;
return the minimum of groups
batsql
next_value
unsafe pattern batsql.next_value(X_0:lng, X_1:str, X_2:str):bat[:lng] 
mvc_next_value_bulk;
return the next value of the sequence
batsql
nth_value
pattern batsql.nth_value(X_0:any_1, X_1:bat[:lng], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:any_1] 
SQLnth_value;
return the nth value of each group
batsql
nth_value
pattern batsql.nth_value(X_0:bat[:any_1], X_1:bat[:lng], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:any_1] 
SQLnth_value;
return the nth value of each group
batsql
nth_value
pattern batsql.nth_value(X_0:bat[:any_1], X_1:lng, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:any_1] 
SQLnth_value;
return the nth value of each group
batsql
ntile
pattern batsql.ntile(X_0:any, X_1:bat[:any_1], X_2:any_2, X_3:any_3):bat[:any_1] 
SQLntile;
return the groups divided as equally as possible
batsql
ntile
pattern batsql.ntile(X_0:bat[:any], X_1:any_1, X_2:any_2, X_3:any_3):bat[:any_1] 
SQLntile;
return the groups divided as equally as possible
batsql
ntile
pattern batsql.ntile(X_0:bat[:any], X_1:bat[:any_1], X_2:any_2, X_3:any_3):bat[:any_1] 
SQLntile;
return the groups divided as equally as possible
batsql
password
pattern batsql.password(X_0:bat[:str]):bat[:str] 
db_password_wrap;
Return password hash of user
batsql
percent_rank
pattern batsql.percent_rank(X_0:bat[:any_1], X_1:any_2, X_2:any_3):bat[:dbl] 
SQLpercent_rank;
return the percentage into the total number of groups for each row
batsql
prod
pattern batsql.prod(X_0:bat[:bte], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:lng] 
SQLprod;
return the product of groups
batsql
prod
pattern batsql.prod(X_0:bat[:dbl], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLprod;
return the product of groups
batsql
prod
pattern batsql.prod(X_0:bat[:flt], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLprod;
return the product of groups
batsql
prod
pattern batsql.prod(X_0:bat[:flt], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:flt] 
SQLprod;
return the product of groups
batsql
prod
pattern batsql.prod(X_0:bat[:int], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:lng] 
SQLprod;
return the product of groups
batsql
prod
pattern batsql.prod(X_0:bat[:lng], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:lng] 
SQLprod;
return the product of groups
batsql
prod
pattern batsql.prod(X_0:bat[:sht], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:lng] 
SQLprod;
return the product of groups
batsql
rank
pattern batsql.rank(X_0:bat[:any_1], X_1:any_2, X_2:any_3):bat[:int] 
SQLrank;
return the ranked groups
batsql
row_number
pattern batsql.row_number(X_0:bat[:any_1], X_1:any_2, X_2:any_3):bat[:int] 
SQLrow_number;
return the row_numer-ed groups
batsql
stdev
pattern batsql.stdev(X_0:bat[:bte], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_samp;
return the standard deviation sample of groups
batsql
stdev
pattern batsql.stdev(X_0:bat[:dbl], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_samp;
return the standard deviation sample of groups
batsql
stdev
pattern batsql.stdev(X_0:bat[:flt], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_samp;
return the standard deviation sample of groups
batsql
stdev
pattern batsql.stdev(X_0:bat[:int], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_samp;
return the standard deviation sample of groups
batsql
stdev
pattern batsql.stdev(X_0:bat[:lng], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_samp;
return the standard deviation sample of groups
batsql
stdev
pattern batsql.stdev(X_0:bat[:sht], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_samp;
return the standard deviation sample of groups
batsql
stdevp
pattern batsql.stdevp(X_0:bat[:bte], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_pop;
return the standard deviation population of groups
batsql
stdevp
pattern batsql.stdevp(X_0:bat[:dbl], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_pop;
return the standard deviation population of groups
batsql
stdevp
pattern batsql.stdevp(X_0:bat[:flt], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_pop;
return the standard deviation population of groups
batsql
stdevp
pattern batsql.stdevp(X_0:bat[:int], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_pop;
return the standard deviation population of groups
batsql
stdevp
pattern batsql.stdevp(X_0:bat[:lng], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_pop;
return the standard deviation population of groups
batsql
stdevp
pattern batsql.stdevp(X_0:bat[:sht], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLstddev_pop;
return the standard deviation population of groups
batsql
str_group_concat
pattern batsql.str_group_concat(X_0:bat[:str], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:str] 
SQLstrgroup_concat;
return the string concatenation of groups
batsql
str_group_concat
pattern batsql.str_group_concat(X_0:bat[:str], X_1:bat[:str], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:str] 
SQLstrgroup_concat;
return the string concatenation of groups with a custom separator
batsql
str_group_concat
pattern batsql.str_group_concat(X_0:bat[:str], X_1:str, X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:str] 
SQLstrgroup_concat;
return the string concatenation of groups with a custom separator
batsql
str_group_concat
pattern batsql.str_group_concat(X_0:str, X_1:bat[:str], X_2:any, X_3:any, X_4:int, X_5:any, X_6:any):bat[:str] 
SQLstrgroup_concat;
return the string concatenation of groups with a custom separator
batsql
strings
command batsql.strings(X_0:bat[:str]):bat[:str] 
BATSTRstrings;
Return the strings
batsql
sum
pattern batsql.sum(X_0:bat[:bte], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:lng] 
SQLsum;
return the sum of groups
batsql
sum
pattern batsql.sum(X_0:bat[:dbl], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLsum;
return the sum of groups
batsql
sum
pattern batsql.sum(X_0:bat[:flt], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLsum;
return the sum of groups
batsql
sum
pattern batsql.sum(X_0:bat[:flt], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:flt] 
SQLsum;
return the sum of groups
batsql
sum
pattern batsql.sum(X_0:bat[:int], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:int] 
SQLsum;
return the sum of groups
batsql
sum
pattern batsql.sum(X_0:bat[:int], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:lng] 
SQLsum;
return the sum of groups
batsql
sum
pattern batsql.sum(X_0:bat[:lng], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:lng] 
SQLsum;
return the sum of groups
batsql
sum
pattern batsql.sum(X_0:bat[:sht], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:lng] 
SQLsum;
return the sum of groups
batsql
variance
pattern batsql.variance(X_0:bat[:bte], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_samp;
return the variance sample of groups
batsql
variance
pattern batsql.variance(X_0:bat[:dbl], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_samp;
return the variance sample of groups
batsql
variance
pattern batsql.variance(X_0:bat[:flt], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_samp;
return the variance sample of groups
batsql
variance
pattern batsql.variance(X_0:bat[:int], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_samp;
return the variance sample of groups
batsql
variance
pattern batsql.variance(X_0:bat[:lng], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_samp;
return the variance sample of groups
batsql
variance
pattern batsql.variance(X_0:bat[:sht], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_samp;
return the variance sample of groups
batsql
variancep
pattern batsql.variancep(X_0:bat[:bte], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_pop;
return the variance population of groups
batsql
variancep
pattern batsql.variancep(X_0:bat[:dbl], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_pop;
return the variance population of groups
batsql
variancep
pattern batsql.variancep(X_0:bat[:flt], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_pop;
return the variance population of groups
batsql
variancep
pattern batsql.variancep(X_0:bat[:int], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_pop;
return the variance population of groups
batsql
variancep
pattern batsql.variancep(X_0:bat[:lng], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_pop;
return the variance population of groups
batsql
variancep
pattern batsql.variancep(X_0:bat[:sht], X_1:any, X_2:any, X_3:int, X_4:any, X_5:any):bat[:dbl] 
SQLvar_pop;
return the variance population of groups
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:bat[:bte]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:bat[:dbl]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:bat[:flt]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:bat[:int]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:bat[:lng]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:bat[:sht]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:bte):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:dbl):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:flt):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:int):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:lng):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:any_1], X_1:int, X_2:int, X_3:int, X_4:sht):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:bat[:bte]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:bat[:dbl]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:bat[:flt]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:bat[:int]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:bat[:lng]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:bat[:sht]):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:bte):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:dbl):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:flt):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:int):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:lng):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batsql
window_bound
pattern batsql.window_bound(X_0:bat[:bit], X_1:bat[:any_1], X_2:int, X_3:int, X_4:int, X_5:sht):bat[:oid] 
SQLwindow_bound;
computes window ranges for each row
batstr
ascii
pattern batstr.ascii(X_0:bat[:str]):bat[:int] 
STRbatAscii;
Return unicode of head of string
batstr
ascii
pattern batstr.ascii(X_0:bat[:str], X_1:bat[:oid]):bat[:int] 
STRbatAscii;
Return unicode of head of string
batstr
endsWith
pattern batstr.endsWith(X_0:bat[:str], X_1:bat[:str]):bat[:bit] 
STRbatSuffix;
Suffix check.
batstr
endsWith
pattern batstr.endsWith(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
STRbatSuffix;
Suffix check.
batstr
endsWith
pattern batstr.endsWith(X_0:str, X_1:bat[:str]):bat[:bit] 
STRbatSuffix_strcst;
Suffix check.
batstr
endsWith
pattern batstr.endsWith(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:bit] 
STRbatSuffix_strcst;
Suffix check.
batstr
endsWith
pattern batstr.endsWith(X_0:bat[:str], X_1:str):bat[:bit] 
STRbatSuffixcst;
Suffix check.
batstr
endsWith
pattern batstr.endsWith(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:bit] 
STRbatSuffixcst;
Suffix check.
batstr
insert
pattern batstr.insert(X_0:bat[:str], X_1:bat[:int], X_2:bat[:int], X_3:bat[:str]):bat[:str] 
STRbatInsert;
Insert a string into another
batstr
insert
pattern batstr.insert(X_0:bat[:str], X_1:int, X_2:int, X_3:str):bat[:str] 
STRbatInsertcst;
Insert a string into another
batstr
length
pattern batstr.length(X_0:bat[:str]):bat[:int] 
STRbatLength;
Return the length of a string.
batstr
length
pattern batstr.length(X_0:bat[:str], X_1:bat[:oid]):bat[:int] 
STRbatLength;
Return the length of a string.
batstr
locate
pattern batstr.locate(X_0:bat[:str], X_1:bat[:str]):bat[:int] 
STRbatstrLocate;
Locate the start position of a string
batstr
locate
pattern batstr.locate(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
STRbatstrLocate;
Locate the start position of a string
batstr
locate
pattern batstr.locate(X_0:str, X_1:bat[:str]):bat[:int] 
STRbatstrLocate_strcst;
Locate the start position of a string
batstr
locate
pattern batstr.locate(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:int] 
STRbatstrLocate_strcst;
Locate the start position of a string
batstr
locate
pattern batstr.locate(X_0:bat[:str], X_1:str):bat[:int] 
STRbatstrLocatecst;
Locate the start position of a string
batstr
locate
pattern batstr.locate(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:int] 
STRbatstrLocatecst;
Locate the start position of a string
batstr
locate3
pattern batstr.locate3(X_0:bat[:str], X_1:bat[:str], X_2:bat[:int]):bat[:int] 
STRbatstrLocate3;
Locate the start position of a string
batstr
locate3
pattern batstr.locate3(X_0:bat[:str], X_1:str, X_2:int):bat[:int] 
STRbatstrLocate3cst;
Locate the start position of a string
batstr
lpad
pattern batstr.lpad(X_0:str, X_1:bat[:int]):bat[:str] 
STRbatLpad_1st_const;
Prepend whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.
batstr
lpad
pattern batstr.lpad(X_0:str, X_1:bat[:int], X_2:bat[:oid]):bat[:str] 
STRbatLpad_1st_const;
Prepend whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.
batstr
lpad
pattern batstr.lpad(X_0:bat[:str], X_1:bat[:int]):bat[:str] 
STRbatLpad_bat;
Prepend whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.
batstr
lpad
pattern batstr.lpad(X_0:bat[:str], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
STRbatLpad_bat;
Prepend whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.
batstr
lpad
pattern batstr.lpad(X_0:bat[:str], X_1:int):bat[:str] 
STRbatLpad_const;
Prepend whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length.
batstr
lpad
pattern batstr.lpad(X_0:bat[:str], X_1:int, X_2:bat[:oid]):bat[:str] 
STRbatLpad_const;
Prepend whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length.
batstr
lpad3
pattern batstr.lpad3(X_0:bat[:str], X_1:bat[:int], X_2:bat[:str]):bat[:str] 
STRbatLpad3_bat_bat;
Prepend the second strings to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.
batstr
lpad3
pattern batstr.lpad3(X_0:bat[:str], X_1:bat[:int], X_2:str):bat[:str] 
STRbatLpad3_bat_const;
Prepend the second string to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.
batstr
lpad3
pattern batstr.lpad3(X_0:bat[:str], X_1:int, X_2:bat[:str]):bat[:str] 
STRbatLpad3_const_bat;
Prepend the second strings to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.
batstr
lpad3
pattern batstr.lpad3(X_0:bat[:str], X_1:int, X_2:str):bat[:str] 
STRbatLpad3_const_const;
Prepend the second string to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.
batstr
ltrim
pattern batstr.ltrim(X_0:bat[:str]):bat[:str] 
STRbatLtrim;
Strip whitespaces from start of a string.
batstr
ltrim
pattern batstr.ltrim(X_0:bat[:str], X_1:bat[:oid]):bat[:str] 
STRbatLtrim;
Strip whitespaces from start of a string.
batstr
ltrim2
pattern batstr.ltrim2(X_0:str, X_1:bat[:str]):bat[:str] 
STRbatLtrim2_1st_const;
Strip characters in the second string from start of the first strings.
batstr
ltrim2
pattern batstr.ltrim2(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:str] 
STRbatLtrim2_1st_const;
Strip characters in the second string from start of the first strings.
batstr
ltrim2
pattern batstr.ltrim2(X_0:bat[:str], X_1:bat[:str]):bat[:str] 
STRbatLtrim2_bat;
Strip characters in the second strings from start of the first strings.
batstr
ltrim2
pattern batstr.ltrim2(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
STRbatLtrim2_bat;
Strip characters in the second strings from start of the first strings.
batstr
ltrim2
pattern batstr.ltrim2(X_0:bat[:str], X_1:str):bat[:str] 
STRbatLtrim2_const;
Strip characters in the second string from start of the first strings.
batstr
ltrim2
pattern batstr.ltrim2(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:str] 
STRbatLtrim2_const;
Strip characters in the second string from start of the first strings.
batstr
nbytes
pattern batstr.nbytes(X_0:bat[:str]):bat[:int] 
STRbatBytes;
Return the string length in bytes.
batstr
nbytes
pattern batstr.nbytes(X_0:bat[:str], X_1:bat[:oid]):bat[:int] 
STRbatBytes;
Return the string length in bytes.
batstr
r_search
pattern batstr.r_search(X_0:bat[:str], X_1:bat[:str]):bat[:int] 
STRbatRstrSearch;
Reverse search for a substring. Returns position, -1 if not found.
batstr
r_search
pattern batstr.r_search(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
STRbatRstrSearch;
Reverse search for a substring. Returns position, -1 if not found.
batstr
r_search
pattern batstr.r_search(X_0:str, X_1:bat[:str]):bat[:int] 
STRbatRstrSearch_strcst;
Reverse search for a substring. Returns position, -1 if not found.
batstr
r_search
pattern batstr.r_search(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:int] 
STRbatRstrSearch_strcst;
Reverse search for a substring. Returns position, -1 if not found.
batstr
r_search
pattern batstr.r_search(X_0:bat[:str], X_1:str):bat[:int] 
STRbatRstrSearchcst;
Reverse search for a substring. Returns position, -1 if not found.
batstr
r_search
pattern batstr.r_search(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:int] 
STRbatRstrSearchcst;
Reverse search for a substring. Returns position, -1 if not found.
batstr
repeat
pattern batstr.repeat(X_0:bat[:str], X_1:bat[:int]):bat[:str] 
STRbatrepeat;
(empty)
batstr
repeat
pattern batstr.repeat(X_0:bat[:str], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
STRbatrepeat;
(empty)
batstr
repeat
pattern batstr.repeat(X_0:str, X_1:bat[:int]):bat[:str] 
STRbatrepeat_strcst;
(empty)
batstr
repeat
pattern batstr.repeat(X_0:str, X_1:bat[:int], X_2:bat[:oid]):bat[:str] 
STRbatrepeat_strcst;
(empty)
batstr
repeat
pattern batstr.repeat(X_0:bat[:str], X_1:int):bat[:str] 
STRbatrepeatcst;
(empty)
batstr
repeat
pattern batstr.repeat(X_0:bat[:str], X_1:int, X_2:bat[:oid]):bat[:str] 
STRbatrepeatcst;
(empty)
batstr
replace
pattern batstr.replace(X_0:bat[:str], X_1:bat[:str], X_2:bat[:str]):bat[:str] 
STRbatReplace;
Insert a string into another
batstr
replace
pattern batstr.replace(X_0:bat[:str], X_1:str, X_2:str):bat[:str] 
STRbatReplacecst;
Insert a string into another
batstr
rpad
pattern batstr.rpad(X_0:str, X_1:bat[:int]):bat[:str] 
STRbatRpad_1st_const;
Append whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.
batstr
rpad
pattern batstr.rpad(X_0:str, X_1:bat[:int], X_2:bat[:oid]):bat[:str] 
STRbatRpad_1st_const;
Append whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.
batstr
rpad
pattern batstr.rpad(X_0:bat[:str], X_1:bat[:int]):bat[:str] 
STRbatRpad_bat;
Append whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.
batstr
rpad
pattern batstr.rpad(X_0:bat[:str], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
STRbatRpad_bat;
Append whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.
batstr
rpad
pattern batstr.rpad(X_0:bat[:str], X_1:int):bat[:str] 
STRbatRpad_const;
Append whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length.
batstr
rpad
pattern batstr.rpad(X_0:bat[:str], X_1:int, X_2:bat[:oid]):bat[:str] 
STRbatRpad_const;
Append whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length.
batstr
rpad3
pattern batstr.rpad3(X_0:bat[:str], X_1:bat[:int], X_2:bat[:str]):bat[:str] 
STRbatRpad3_bat_bat;
Append the second strings to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.
batstr
rpad3
pattern batstr.rpad3(X_0:bat[:str], X_1:bat[:int], X_2:str):bat[:str] 
STRbatRpad3_bat_const;
Append the second string to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.
batstr
rpad3
pattern batstr.rpad3(X_0:bat[:str], X_1:int, X_2:bat[:str]):bat[:str] 
STRbatRpad3_const_bat;
Append the second strings to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.
batstr
rpad3
pattern batstr.rpad3(X_0:bat[:str], X_1:int, X_2:str):bat[:str] 
STRbatRpad3_const_const;
Append the second string to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.
batstr
rtrim
pattern batstr.rtrim(X_0:bat[:str]):bat[:str] 
STRbatRtrim;
Strip whitespaces from end of a string.
batstr
rtrim
pattern batstr.rtrim(X_0:bat[:str], X_1:bat[:oid]):bat[:str] 
STRbatRtrim;
Strip whitespaces from end of a string.
batstr
rtrim2
pattern batstr.rtrim2(X_0:str, X_1:bat[:str]):bat[:str] 
STRbatRtrim2_1st_const;
Strip characters in the second string from end of the first strings.
batstr
rtrim2
pattern batstr.rtrim2(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:str] 
STRbatRtrim2_1st_const;
Strip characters in the second string from end of the first strings.
batstr
rtrim2
pattern batstr.rtrim2(X_0:bat[:str], X_1:bat[:str]):bat[:str] 
STRbatRtrim2_bat;
Strip characters in the second strings from end of the first strings.
batstr
rtrim2
pattern batstr.rtrim2(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
STRbatRtrim2_bat;
Strip characters in the second strings from end of the first strings.
batstr
rtrim2
pattern batstr.rtrim2(X_0:bat[:str], X_1:str):bat[:str] 
STRbatRtrim2_const;
Strip characters in the second string from end of the first strings.
batstr
rtrim2
pattern batstr.rtrim2(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:str] 
STRbatRtrim2_const;
Strip characters in the second string from end of the first strings.
batstr
search
pattern batstr.search(X_0:bat[:str], X_1:bat[:str]):bat[:int] 
STRbatstrSearch;
Search for a substring. Returns position, -1 if not found.
batstr
search
pattern batstr.search(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
STRbatstrSearch;
Search for a substring. Returns position, -1 if not found.
batstr
search
pattern batstr.search(X_0:str, X_1:bat[:str]):bat[:int] 
STRbatstrSearch_strcst;
Search for a substring. Returns position, -1 if not found.
batstr
search
pattern batstr.search(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:int] 
STRbatstrSearch_strcst;
Search for a substring. Returns position, -1 if not found.
batstr
search
pattern batstr.search(X_0:bat[:str], X_1:str):bat[:int] 
STRbatstrSearchcst;
Search for a substring. Returns position, -1 if not found.
batstr
search
pattern batstr.search(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:int] 
STRbatstrSearchcst;
Search for a substring. Returns position, -1 if not found.
batstr
space
pattern batstr.space(X_0:bat[:int]):bat[:str] 
STRbatSpace;
(empty)
batstr
space
pattern batstr.space(X_0:bat[:int], X_1:bat[:oid]):bat[:str] 
STRbatSpace;
(empty)
batstr
splitpart
pattern batstr.splitpart(X_0:bat[:str], X_1:bat[:str], X_2:bat[:int]):bat[:str] 
STRbatsplitpart;
Split string on delimiter. Returns@given field (counting from one.)
batstr
splitpart
pattern batstr.splitpart(X_0:bat[:str], X_1:bat[:str], X_2:int):bat[:str] 
STRbatsplitpart_fieldcst;
Split string on delimiter. Returns@given field (counting from one.)
batstr
splitpart
pattern batstr.splitpart(X_0:bat[:str], X_1:str, X_2:bat[:int]):bat[:str] 
STRbatsplitpart_needlecst;
Split string on delimiter. Returns@given field (counting from one.)
batstr
splitpart
pattern batstr.splitpart(X_0:bat[:str], X_1:str, X_2:int):bat[:str] 
STRbatsplitpartcst;
Split string on delimiter. Returns@given field (counting from one.)
batstr
startsWith
pattern batstr.startsWith(X_0:bat[:str], X_1:bat[:str]):bat[:bit] 
STRbatPrefix;
Prefix check.
batstr
startsWith
pattern batstr.startsWith(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:bit] 
STRbatPrefix;
Prefix check.
batstr
startsWith
pattern batstr.startsWith(X_0:str, X_1:bat[:str]):bat[:bit] 
STRbatPrefix_strcst;
Prefix check.
batstr
startsWith
pattern batstr.startsWith(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:bit] 
STRbatPrefix_strcst;
Prefix check.
batstr
startsWith
pattern batstr.startsWith(X_0:bat[:str], X_1:str):bat[:bit] 
STRbatPrefixcst;
Prefix check.
batstr
startsWith
pattern batstr.startsWith(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:bit] 
STRbatPrefixcst;
Prefix check.
batstr
string
pattern batstr.string(X_0:bat[:str], X_1:bat[:int]):bat[:str] 
STRbatTail;
Return the tail s[offset..n] of a string s[0..n].
batstr
string
pattern batstr.string(X_0:bat[:str], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
STRbatTail;
Return the tail s[offset..n] of a string s[0..n].
batstr
string
pattern batstr.string(X_0:str, X_1:bat[:int]):bat[:str] 
STRbatTail_strcst;
Return the tail s[offset..n] of a string s[0..n].
batstr
string
pattern batstr.string(X_0:str, X_1:bat[:int], X_2:bat[:oid]):bat[:str] 
STRbatTail_strcst;
Return the tail s[offset..n] of a string s[0..n].
batstr
string
pattern batstr.string(X_0:bat[:str], X_1:int):bat[:str] 
STRbatTailcst;
Return the tail s[offset..n] of a string s[0..n].
batstr
string
pattern batstr.string(X_0:bat[:str], X_1:int, X_2:bat[:oid]):bat[:str] 
STRbatTailcst;
Return the tail s[offset..n] of a string s[0..n].
batstr
stringleft
pattern batstr.stringleft(X_0:bat[:str], X_1:bat[:int]):bat[:str] 
STRbatprefix;
(empty)
batstr
stringleft
pattern batstr.stringleft(X_0:bat[:str], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
STRbatprefix;
(empty)
batstr
stringleft
pattern batstr.stringleft(X_0:str, X_1:bat[:int]):bat[:str] 
STRbatprefix_strcst;
(empty)
batstr
stringleft
pattern batstr.stringleft(X_0:str, X_1:bat[:int], X_2:bat[:oid]):bat[:str] 
STRbatprefix_strcst;
(empty)
batstr
stringleft
pattern batstr.stringleft(X_0:bat[:str], X_1:int):bat[:str] 
STRbatprefixcst;
(empty)
batstr
stringleft
pattern batstr.stringleft(X_0:bat[:str], X_1:int, X_2:bat[:oid]):bat[:str] 
STRbatprefixcst;
(empty)
batstr
stringright
pattern batstr.stringright(X_0:bat[:str], X_1:bat[:int]):bat[:str] 
STRbatsuffix;
(empty)
batstr
stringright
pattern batstr.stringright(X_0:bat[:str], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
STRbatsuffix;
(empty)
batstr
stringright
pattern batstr.stringright(X_0:str, X_1:bat[:int]):bat[:str] 
STRbatsuffix_strcst;
(empty)
batstr
stringright
pattern batstr.stringright(X_0:str, X_1:bat[:int], X_2:bat[:oid]):bat[:str] 
STRbatsuffix_strcst;
(empty)
batstr
stringright
pattern batstr.stringright(X_0:bat[:str], X_1:int):bat[:str] 
STRbatsuffixcst;
(empty)
batstr
stringright
pattern batstr.stringright(X_0:bat[:str], X_1:int, X_2:bat[:oid]):bat[:str] 
STRbatsuffixcst;
(empty)
batstr
substitute
pattern batstr.substitute(X_0:bat[:str], X_1:bat[:str], X_2:bat[:str], X_3:bat[:bit]):bat[:str] 
STRbatSubstitute;
Substitute first occurrence of 'src' by@'dst'. Iff repeated = true this is@repeated while 'src' can be found in the@result string. In order to prevent@recursion and result strings of unlimited@size, repeating is only done iff src is@not a substring of dst.
batstr
substitute
pattern batstr.substitute(X_0:bat[:str], X_1:str, X_2:str, X_3:bit):bat[:str] 
STRbatSubstitutecst;
Substitute first occurrence of 'src' by@'dst'. Iff repeated = true this is@repeated while 'src' can be found in the@result string. In order to prevent@recursion and result strings of unlimited@size, repeating is only done iff src is@not a substring of dst.
batstr
substring
pattern batstr.substring(X_0:bat[:str], X_1:bat[:int]):bat[:str] 
STRbatsubstringTail;
Extract the tail of a string
batstr
substring
pattern batstr.substring(X_0:bat[:str], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
STRbatsubstringTail;
Extract the tail of a string
batstr
substring
pattern batstr.substring(X_0:str, X_1:bat[:int]):bat[:str] 
STRbatsubstringTail_strcst;
Extract the tail of a string
batstr
substring
pattern batstr.substring(X_0:str, X_1:bat[:int], X_2:bat[:oid]):bat[:str] 
STRbatsubstringTail_strcst;
Extract the tail of a string
batstr
substring
pattern batstr.substring(X_0:bat[:str], X_1:int):bat[:str] 
STRbatsubstringTailcst;
Extract the tail of a string
batstr
substring
pattern batstr.substring(X_0:bat[:str], X_1:int, X_2:bat[:oid]):bat[:str] 
STRbatsubstringTailcst;
Extract the tail of a string
batstr
substring3
pattern batstr.substring3(X_0:bat[:str], X_1:bat[:int], X_2:bat[:int]):bat[:str] 
STRbatsubstring;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:bat[:str], X_1:bat[:int], X_2:bat[:int], X_3:bat[:oid], X_4:bat[:oid], X_5:bat[:oid]):bat[:str] 
STRbatsubstring;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:str, X_1:int, X_2:bat[:int]):bat[:str] 
STRbatsubstring_1st_2nd_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:str, X_1:int, X_2:bat[:int], X_3:bat[:oid]):bat[:str] 
STRbatsubstring_1st_2nd_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:str, X_1:bat[:int], X_2:int):bat[:str] 
STRbatsubstring_1st_3rd_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:str, X_1:bat[:int], X_2:int, X_3:bat[:oid]):bat[:str] 
STRbatsubstring_1st_3rd_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:str, X_1:bat[:int], X_2:bat[:int]):bat[:str] 
STRbatsubstring_1st_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:str, X_1:bat[:int], X_2:bat[:int], X_3:bat[:oid], X_4:bat[:oid]):bat[:str] 
STRbatsubstring_1st_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:bat[:str], X_1:int, X_2:int):bat[:str] 
STRbatsubstring_2nd_3rd_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:bat[:str], X_1:int, X_2:int, X_3:bat[:oid]):bat[:str] 
STRbatsubstring_2nd_3rd_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:bat[:str], X_1:int, X_2:bat[:int]):bat[:str] 
STRbatsubstring_2nd_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:bat[:str], X_1:int, X_2:bat[:int], X_3:bat[:oid], X_4:bat[:oid]):bat[:str] 
STRbatsubstring_2nd_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:bat[:str], X_1:bat[:int], X_2:int):bat[:str] 
STRbatsubstring_3rd_cst;
Substring extraction using [start,start+length]
batstr
substring3
pattern batstr.substring3(X_0:bat[:str], X_1:bat[:int], X_2:int, X_3:bat[:oid], X_4:bat[:oid]):bat[:str] 
STRbatsubstring_3rd_cst;
Substring extraction using [start,start+length]
batstr
toLower
pattern batstr.toLower(X_0:bat[:str]):bat[:str] 
STRbatLower;
Convert a string to lower case.
batstr
toLower
pattern batstr.toLower(X_0:bat[:str], X_1:bat[:oid]):bat[:str] 
STRbatLower;
Convert a string to lower case.
batstr
toUpper
pattern batstr.toUpper(X_0:bat[:str]):bat[:str] 
STRbatUpper;
Convert a string to upper case.
batstr
toUpper
pattern batstr.toUpper(X_0:bat[:str], X_1:bat[:oid]):bat[:str] 
STRbatUpper;
Convert a string to upper case.
batstr
trim
pattern batstr.trim(X_0:bat[:str]):bat[:str] 
STRbatStrip;
Strip whitespaces around a string.
batstr
trim
pattern batstr.trim(X_0:bat[:str], X_1:bat[:oid]):bat[:str] 
STRbatStrip;
Strip whitespaces around a string.
batstr
trim2
pattern batstr.trim2(X_0:str, X_1:bat[:str]):bat[:str] 
STRbatStrip2_1st_const;
Strip characters in the second string around the first strings.
batstr
trim2
pattern batstr.trim2(X_0:str, X_1:bat[:str], X_2:bat[:oid]):bat[:str] 
STRbatStrip2_1st_const;
Strip characters in the second string around the first strings.
batstr
trim2
pattern batstr.trim2(X_0:bat[:str], X_1:bat[:str]):bat[:str] 
STRbatStrip2_bat;
Strip characters in the second strings around the first strings.
batstr
trim2
pattern batstr.trim2(X_0:bat[:str], X_1:bat[:str], X_2:bat[:oid], X_3:bat[:oid]):bat[:str] 
STRbatStrip2_bat;
Strip characters in the second strings around the first strings.
batstr
trim2
pattern batstr.trim2(X_0:bat[:str], X_1:str):bat[:str] 
STRbatStrip2_const;
Strip characters in the second string around the first strings.
batstr
trim2
pattern batstr.trim2(X_0:bat[:str], X_1:str, X_2:bat[:oid]):bat[:str] 
STRbatStrip2_const;
Strip characters in the second string around the first strings.
batstr
unicode
pattern batstr.unicode(X_0:bat[:int]):bat[:str] 
STRbatFromWChr;
convert a unicode to a character.
batstr
unicode
pattern batstr.unicode(X_0:bat[:int], X_1:bat[:oid]):bat[:str] 
STRbatFromWChr;
convert a unicode to a character.
batstr
unicodeAt
pattern batstr.unicodeAt(X_0:bat[:str], X_1:bat[:int]):bat[:int] 
STRbatWChrAt;
get a unicode character (as an int) from a string position.
batstr
unicodeAt
pattern batstr.unicodeAt(X_0:bat[:str], X_1:bat[:int], X_2:bat[:oid], X_3:bat[:oid]):bat[:int] 
STRbatWChrAt;
get a unicode character (as an int) from a string position.
batstr
unicodeAt
pattern batstr.unicodeAt(X_0:str, X_1:bat[:int]):bat[:int] 
STRbatWChrAt_strcst;
get a unicode character (as an int) from a string position.
batstr
unicodeAt
pattern batstr.unicodeAt(X_0:str, X_1:bat[:int], X_2:bat[:oid]):bat[:int] 
STRbatWChrAt_strcst;
get a unicode character (as an int) from a string position.
batstr
unicodeAt
pattern batstr.unicodeAt(X_0:bat[:str], X_1:int):bat[:int] 
STRbatWChrAtcst;
get a unicode character (as an int) from a string position.
batstr
unicodeAt
pattern batstr.unicodeAt(X_0:bat[:str], X_1:int, X_2:bat[:oid]):bat[:int] 
STRbatWChrAtcst;
get a unicode character (as an int) from a string position.
battxtsim
similarity
command battxtsim.similarity(X_0:bat[:str], X_1:bat[:str]):bat[:dbl] 
fstrcmp0_impl_bulk;
Normalized edit distance between two strings
batuuid
isaUUID
command batuuid.isaUUID(X_0:bat[:str]):bat[:bit] 
UUIDisaUUID_bulk;
Test a string for a UUID format
batuuid
new
pattern batuuid.new(X_0:bat[:int]):bat[:uuid] 
UUIDgenerateUuidInt_bulk;
Generate a new uuid (dummy version for side effect free multiplex loop)
batuuid
new
pattern batuuid.new(X_0:lng):bat[:uuid] 
UUIDgenerateUuidInt_bulk;
Generate a new uuid (dummy version for side effect free multiplex loop)
batxml
attribute
command batxml.attribute(X_0:str, X_1:bat[:str]):bat[:xml] 
BATXMLattribute;
Construct an attribute value pair.
batxml
comment
command batxml.comment(X_0:bat[:str]):bat[:xml] 
BATXMLcomment;
Create an XML comment element.
batxml
concat
command batxml.concat(X_0:bat[:xml], X_1:bat[:xml]):bat[:xml] 
BATXMLconcat;
Concatenate the XML values.
batxml
content
command batxml.content(X_0:bat[:str]):bat[:xml] 
BATXMLcontent;
Parse the string as XML element content.
batxml
document
command batxml.document(X_0:bat[:str]):bat[:xml] 
BATXMLdocument;
Parse the string as an XML document.
batxml
element
command batxml.element(X_0:str, X_1:xml, X_2:xml, X_3:bat[:xml]):bat[:xml] 
BATXMLelement;
The basic building block for XML elements are namespaces, attributes and a sequence of XML elements. The name space and the attributes may be left unspecified(=nil).
batxml
element
command batxml.element(X_0:str, X_1:bat[:xml]):bat[:xml] 
BATXMLelementSmall;
The basic building block for XML elements are namespaces, attributes and a sequence of XML elements. The name space and the attributes may be left unspecified.
batxml
forest
pattern batxml.forest(X_0:bat[:xml]...):bat[:xml] 
BATXMLforest;
Construct an element list.
batxml
isdocument
command batxml.isdocument(X_0:bat[:str]):bat[:bit] 
BATXMLisdocument;
Validate the string as a XML document.
batxml
options
command batxml.options(X_0:str, X_1:str, X_2:bat[:xml]):bat[:xml] 
BATXMLoptions;
Create the components including NULL conversions.
batxml
parse
command batxml.parse(X_0:str, X_1:bat[:str], X_2:str):bat[:xml] 
BATXMLparse;
Parse the XML document or element string values.
batxml
pi
command batxml.pi(X_0:str, X_1:bat[:xml]):bat[:xml] 
BATXMLpi;
Construct a processing instruction.
batxml
root
command batxml.root(X_0:bat[:xml], X_1:str, X_2:str):bat[:xml] 
BATXMLroot;
Contruct the root nodes.
batxml
serialize
command batxml.serialize(X_0:bat[:xml]):bat[:str] 
BATXMLxml2str;
Serialize the XML object to a string.
batxml
str
command batxml.str(X_0:bat[:xml]):bat[:str] 
BATXMLxml2str;
Cast the xml to a string.
batxml
text
command batxml.text(X_0:bat[:xml]):bat[:str] 
BATXMLxmltext;
Serialize the XML object to a string.
batxml
xml
command batxml.xml(X_0:bat[:str]):bat[:xml] 
BATXMLstr2xml;
Cast the string to an xml compliant string.
batxml
xquery
command batxml.xquery(X_0:bat[:str], X_1:str):bat[:xml] 
BATXMLxquery;
Execute the XQuery against the elements.
bbp
bind
pattern bbp.bind(X_0:str):bat[:any_2] 
CMDbbpbind;
Locate the BAT using its logical name
bbp
get
command bbp.get() (X_0:bat[:int], X_1:bat[:str], X_2:bat[:str], X_3:bat[:lng], X_4:bat[:int], X_5:bat[:int], X_6:bat[:str], X_7:bat[:int], X_8:bat[:str], X_9:bat[:str], X_10:bat[:str]) 
CMDbbp;
bpp
bbp
getCount
command bbp.getCount():bat[:lng] 
CMDbbpCount;
Create a BAT with the cardinalities of all known BATs
bbp
getDirty
command bbp.getDirty():bat[:str] 
CMDbbpDirty;
Create a BAT with the dirty/ diffs/clean status
bbp
getDiskSpace
command bbp.getDiskSpace():lng 
CMDbbpDiskSpace;
Estimate the amount of disk space occupied by dbpath
bbp
getIndex
command bbp.getIndex(X_0:bat[:any_2]):int 
CMDbbpgetIndex;
Retrieve the index in the BBP
bbp
getKind
command bbp.getKind():bat[:str] 
CMDbbpKind;
Create a BAT with the persistency status
bbp
getLRefCount
command bbp.getLRefCount():bat[:int] 
CMDbbpLRefCount;
Create a BAT with the logical reference counts
bbp
getLRefCount
command bbp.getLRefCount(X_0:bat[:any_1]):int 
CMDgetBATlrefcnt;
Utility for debugging MAL interpreter
bbp
getLocation
command bbp.getLocation():bat[:str] 
CMDbbpLocation;
Create a BAT with their disk locations
bbp
getName
command bbp.getName(X_0:bat[:any_1]):str 
CMDbbpName;
Map a BAT into its internal name
bbp
getNames
command bbp.getNames():bat[:str] 
CMDbbpNames;
Map BAT into its bbp name
bbp
getPageSize
command bbp.getPageSize():int 
CMDgetPageSize;
Obtain the memory page size
bbp
getRefCount
command bbp.getRefCount():bat[:int] 
CMDbbpRefCount;
Create a BAT with the (hard) reference counts
bbp
getRefCount
command bbp.getRefCount(X_0:bat[:any_1]):int 
CMDgetBATrefcnt;
Utility for debugging MAL interpreter
bbp
getStatus
command bbp.getStatus():bat[:str] 
CMDbbpStatus;
Create a BAT with the disk/load status
bbp
setName
command bbp.setName(X_0:bat[:any_1], X_1:str):str 
CMDsetName;
Rename a BAT
blob
blob
command blob.blob(X_0:blob):blob 
BLOBblob_blob;
Noop routine.
blob
blob
command blob.blob(X_0:str):blob 
BLOBblob_fromstr;
(empty)
blob
nitems
command blob.nitems(X_0:blob):int 
BLOBnitems;
get the number of bytes in this blob.
blob
prelude
command blob.prelude():void 
BLOBprelude;
(empty)
blob
toblob
command blob.toblob(X_0:str):blob 
BLOBtoblob;
store a string as a blob.
calc
!=
pattern calc.!=(X_0:bit, X_1:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bit, X_1:bit, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:blob, X_1:blob):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:blob, X_1:blob, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:bte):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:bte, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:dbl):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:dbl, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:flt):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:flt, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:int):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:int, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:lng):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:lng, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:sht):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:bte, X_1:sht, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:date, X_1:date):bit 
CMDvarNE;
Equality of two dates
calc
!=
pattern calc.!=(X_0:date, X_1:date, X_2:bit):bit 
CMDvarNE;
Equality of two dates
calc
!=
pattern calc.!=(X_0:daytime, X_1:daytime):bit 
CMDvarNE;
Equality of two daytimes
calc
!=
pattern calc.!=(X_0:daytime, X_1:daytime, X_2:bit):bit 
CMDvarNE;
Equality of two daytimes
calc
!=
pattern calc.!=(X_0:dbl, X_1:bte):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:bte, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:dbl):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:dbl, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:flt):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:flt, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:int):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:int, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:lng):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:lng, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:sht):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:dbl, X_1:sht, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:bte):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:bte, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:dbl):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:dbl, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:flt):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:flt, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:int):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:int, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:lng):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:lng, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:sht):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:flt, X_1:sht, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:inet, X_1:inet):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:inet, X_1:inet, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:bte):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:bte, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:dbl):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:dbl, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:flt):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:flt, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:int):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:int, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:lng):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:lng, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:sht):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:int, X_1:sht, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:json, X_1:json):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:json, X_1:json, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:bte):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:bte, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:dbl):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:dbl, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:flt):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:flt, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:int):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:int, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:lng):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:lng, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:sht):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:lng, X_1:sht, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:oid, X_1:oid):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:oid, X_1:oid, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:bte):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:bte, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:dbl):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:dbl, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:flt):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:flt, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:int):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:int, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:lng):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:lng, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:sht):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:sht, X_1:sht, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:str, X_1:str):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:str, X_1:str, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:timestamp, X_1:timestamp):bit 
CMDvarNE;
Equality of two timestamps
calc
!=
pattern calc.!=(X_0:timestamp, X_1:timestamp, X_2:bit):bit 
CMDvarNE;
Equality of two timestamps
calc
!=
pattern calc.!=(X_0:uuid, X_1:uuid):bit 
CMDvarNE;
Return V1 != V2
calc
!=
pattern calc.!=(X_0:uuid, X_1:uuid, X_2:bit):bit 
CMDvarNE;
Return V1 != V2
calc
%
pattern calc.%(X_0:bte, X_1:bte):bte 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:bte):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:bte):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:bte):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:dbl):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:flt):flt 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:int):bte 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:int):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:int):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:int):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:lng):bte 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:lng):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:lng):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:lng):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:sht):bte 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:sht):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:sht):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:bte, X_1:sht):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:dbl, X_1:bte):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:dbl, X_1:dbl):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:dbl, X_1:flt):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:dbl, X_1:int):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:dbl, X_1:lng):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:dbl, X_1:sht):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:flt, X_1:bte):flt 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:flt, X_1:dbl):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:flt, X_1:flt):flt 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:flt, X_1:int):flt 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:flt, X_1:lng):flt 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:flt, X_1:sht):flt 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:bte):bte 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:bte):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:bte):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:bte):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:dbl):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:flt):flt 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:int):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:int):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:lng):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:lng):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:sht):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:sht):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:int, X_1:sht):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:bte):bte 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:bte):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:bte):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:bte):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:dbl):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:flt):flt 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:int):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:int):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:lng):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:sht):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:sht):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:lng, X_1:sht):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:bte):bte 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:bte):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:bte):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:bte):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:dbl):dbl 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:flt):flt 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:int):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:int):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:int):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:lng):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:lng):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:lng):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:sht):int 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:sht):lng 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
%
pattern calc.%(X_0:sht, X_1:sht):sht 
CMDvarMODsignal;
Return V1 % V2, signal error on divide by zero
calc
*
pattern calc.*(X_0:bte, X_1:bte):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:bte):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:bte):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:bte):int 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:bte):lng 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:bte):sht 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:dbl):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:dbl):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:dbl):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:dbl):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:dbl):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:flt):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:flt):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:flt):flt 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:flt):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:flt):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:flt):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:int):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:int):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:int):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:int):lng 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:lng):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:lng):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:lng):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:bte, X_1:sht):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:sht):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:sht):int 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:sht):lng 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:bte, X_1:sht):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:bte):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:bte):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:bte):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:bte):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:bte):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:dbl):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:flt):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:int):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:int):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:int):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:int):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:int):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:lng):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:lng):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:lng):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:lng):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:lng):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:sht):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:sht):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:sht):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:sht):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:dbl, X_1:sht):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:bte):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:bte):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:flt, X_1:bte):flt 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:bte):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:bte):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:bte):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:dbl):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:flt):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:flt, X_1:flt):flt 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:int):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:int):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:flt, X_1:int):flt 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:int):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:int):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:int):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:lng):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:lng):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:flt, X_1:lng):flt 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:lng):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:lng):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:lng):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:sht):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:sht):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:flt, X_1:sht):flt 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:sht):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:sht):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:flt, X_1:sht):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:bte):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:bte):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:bte):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:bte):lng 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:dbl):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:dbl):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:dbl):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:dbl):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:dbl):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:flt):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:flt):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:flt):flt 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:flt):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:flt):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:flt):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:int):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:int):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:int):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:int):lng 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:lng):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:lng):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:lng):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:sht):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:sht):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:int, X_1:sht):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:int, X_1:sht):lng 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:lng, X_1:bte):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:lng, X_1:bte):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:lng, X_1:bte):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:dbl):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:dbl):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:dbl):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:dbl):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:dbl):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:flt):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:flt):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:lng, X_1:flt):flt 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:flt):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:flt):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:flt):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:int):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:lng, X_1:int):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:lng, X_1:int):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:lng):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:lng, X_1:lng):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:lng, X_1:lng):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:lng, X_1:sht):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:lng, X_1:sht):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:lng, X_1:sht):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:bte):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:bte):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:bte):int 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:bte):lng 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:bte):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:dbl):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:dbl):dbl 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:dbl):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:dbl):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:dbl):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:flt):bte 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:flt):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:flt):flt 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:flt):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:flt):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:flt):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:int):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:int):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:int):int 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:int):lng 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:lng):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:lng):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:lng):lng 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
*
pattern calc.*(X_0:sht, X_1:sht):dbl 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:sht):flt 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:sht):int 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:sht):lng 
CMDvarMULsignal;
Return V1 * V2, guarantee no overflow by returning larger type
calc
*
pattern calc.*(X_0:sht, X_1:sht):sht 
CMDvarMULsignal;
Return V1 * V2, signal error on overflow
calc
+
pattern calc.+(X_0:bte, X_1:bte):bte 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:bte, X_1:bte):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:bte):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:bte):int 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:bte):lng 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:bte):sht 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:dbl):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:bte, X_1:flt):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:flt):flt 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:bte, X_1:int):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:int):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:int):int 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:bte, X_1:int):lng 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:lng):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:lng):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:lng):lng 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:bte, X_1:sht):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:sht):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:sht):int 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:sht):lng 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:bte, X_1:sht):sht 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:dbl, X_1:bte):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:dbl, X_1:dbl):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:dbl, X_1:flt):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:dbl, X_1:int):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:dbl, X_1:lng):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:dbl, X_1:sht):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:flt, X_1:bte):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:flt, X_1:bte):flt 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:flt, X_1:dbl):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:flt, X_1:flt):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:flt, X_1:flt):flt 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:flt, X_1:int):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:flt, X_1:int):flt 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:flt, X_1:lng):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:flt, X_1:lng):flt 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:flt, X_1:sht):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:flt, X_1:sht):flt 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:int, X_1:bte):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:bte):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:bte):int 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:int, X_1:bte):lng 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:dbl):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:int, X_1:flt):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:flt):flt 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:int, X_1:int):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:int):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:int):int 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:int, X_1:int):lng 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:lng):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:lng):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:lng):lng 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:int, X_1:sht):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:sht):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:int, X_1:sht):int 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:int, X_1:sht):lng 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:lng, X_1:bte):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:lng, X_1:bte):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:lng, X_1:bte):lng 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:lng, X_1:dbl):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:lng, X_1:flt):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:lng, X_1:flt):flt 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:lng, X_1:int):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:lng, X_1:int):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:lng, X_1:int):lng 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:lng, X_1:lng):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:lng, X_1:lng):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:lng, X_1:lng):lng 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:lng, X_1:sht):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:lng, X_1:sht):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:lng, X_1:sht):lng 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:sht, X_1:bte):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:bte):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:bte):int 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:bte):lng 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:bte):sht 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:sht, X_1:dbl):dbl 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:sht, X_1:flt):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:flt):flt 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:sht, X_1:int):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:int):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:int):int 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:sht, X_1:int):lng 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:lng):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:lng):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:lng):lng 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
pattern calc.+(X_0:sht, X_1:sht):dbl 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:sht):flt 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:sht):int 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:sht):lng 
CMDvarADDsignal;
Return V1 + V2, guarantee no overflow by returning larger type
calc
+
pattern calc.+(X_0:sht, X_1:sht):sht 
CMDvarADDsignal;
Return V1 + V2, signal error on overflow
calc
+
command calc.+(X_0:str, X_1:str):str 
CMDvarADDstr;
Concatenate LEFT and RIGHT
calc
+
command calc.+(X_0:str, X_1:int):str 
CMDvarADDstrint;
Concatenate LEFT and string representation of RIGHT
calc
++
pattern calc.++(X_0:bte):bte 
CMDvarINCRsignal;
Unary V + 1
calc
++
pattern calc.++(X_0:dbl):dbl 
CMDvarINCRsignal;
Unary V + 1
calc
++
pattern calc.++(X_0:flt):flt 
CMDvarINCRsignal;
Unary V + 1
calc
++
pattern calc.++(X_0:int):int 
CMDvarINCRsignal;
Unary V + 1
calc
++
pattern calc.++(X_0:lng):lng 
CMDvarINCRsignal;
Unary V + 1
calc
++
pattern calc.++(X_0:sht):sht 
CMDvarINCRsignal;
Unary V + 1
calc
-
pattern calc.-(X_0:bte):bte 
CMDvarNEG;
Unary negation of V
calc
-
pattern calc.-(X_0:dbl):dbl 
CMDvarNEG;
Unary negation of V
calc
-
pattern calc.-(X_0:flt):flt 
CMDvarNEG;
Unary negation of V
calc
-
pattern calc.-(X_0:int):int 
CMDvarNEG;
Unary negation of V
calc
-
pattern calc.-(X_0:lng):lng 
CMDvarNEG;
Unary negation of V
calc
-
pattern calc.-(X_0:sht):sht 
CMDvarNEG;
Unary negation of V
calc
-
pattern calc.-(X_0:bte, X_1:bte):bte 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:bte, X_1:bte):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:bte):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:bte):int 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:bte):lng 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:bte):sht 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:dbl):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:bte, X_1:flt):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:flt):flt 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:bte, X_1:int):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:int):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:int):int 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:bte, X_1:int):lng 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:lng):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:lng):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:lng):lng 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:bte, X_1:sht):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:sht):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:sht):int 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:sht):lng 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:bte, X_1:sht):sht 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:dbl, X_1:bte):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:dbl, X_1:dbl):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:dbl, X_1:flt):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:dbl, X_1:int):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:dbl, X_1:lng):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:dbl, X_1:sht):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:flt, X_1:bte):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:flt, X_1:bte):flt 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:flt, X_1:dbl):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:flt, X_1:flt):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:flt, X_1:flt):flt 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:flt, X_1:int):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:flt, X_1:int):flt 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:flt, X_1:lng):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:flt, X_1:lng):flt 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:flt, X_1:sht):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:flt, X_1:sht):flt 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:int, X_1:bte):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:bte):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:bte):int 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:int, X_1:bte):lng 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:dbl):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:int, X_1:flt):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:flt):flt 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:int, X_1:int):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:int):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:int):int 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:int, X_1:int):lng 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:lng):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:lng):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:lng):lng 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:int, X_1:sht):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:sht):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:int, X_1:sht):int 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:int, X_1:sht):lng 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:lng, X_1:bte):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:lng, X_1:bte):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:lng, X_1:bte):lng 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:lng, X_1:dbl):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:lng, X_1:flt):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:lng, X_1:flt):flt 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:lng, X_1:int):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:lng, X_1:int):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:lng, X_1:int):lng 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:lng, X_1:lng):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:lng, X_1:lng):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:lng, X_1:lng):lng 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:lng, X_1:sht):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:lng, X_1:sht):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:lng, X_1:sht):lng 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:sht, X_1:bte):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:bte):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:bte):int 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:bte):lng 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:bte):sht 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:sht, X_1:dbl):dbl 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:sht, X_1:flt):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:flt):flt 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:sht, X_1:int):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:int):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:int):int 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:sht, X_1:int):lng 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:lng):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:lng):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:lng):lng 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
-
pattern calc.-(X_0:sht, X_1:sht):dbl 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:sht):flt 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:sht):int 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:sht):lng 
CMDvarSUBsignal;
Return V1 - V2, guarantee no overflow by returning larger type
calc
-
pattern calc.-(X_0:sht, X_1:sht):sht 
CMDvarSUBsignal;
Return V1 - V2, signal error on overflow
calc
--
pattern calc.--(X_0:bte):bte 
CMDvarDECRsignal;
Unary V - 1
calc
--
pattern calc.--(X_0:dbl):dbl 
CMDvarDECRsignal;
Unary V - 1
calc
--
pattern calc.--(X_0:flt):flt 
CMDvarDECRsignal;
Unary V - 1
calc
--
pattern calc.--(X_0:int):int 
CMDvarDECRsignal;
Unary V - 1
calc
--
pattern calc.--(X_0:lng):lng 
CMDvarDECRsignal;
Unary V - 1
calc
--
pattern calc.--(X_0:sht):sht 
CMDvarDECRsignal;
Unary V - 1
calc
/
pattern calc./(X_0:bte, X_1:bte):bte 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:bte):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:bte):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:bte):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:bte):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:bte):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:dbl):bte 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:dbl):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:dbl):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:dbl):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:dbl):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:dbl):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:flt):bte 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:flt):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:flt):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:flt):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:flt):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:flt):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:int):bte 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:int):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:int):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:int):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:int):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:int):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:lng):bte 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:lng):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:lng):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:lng):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:lng):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:lng):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:sht):bte 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:sht):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:sht):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:sht):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:sht):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:bte, X_1:sht):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:dbl, X_1:bte):bte 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:dbl, X_1:bte):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:dbl, X_1:dbl):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:dbl, X_1:flt):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:dbl, X_1:int):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:dbl, X_1:int):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:dbl, X_1:lng):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:dbl, X_1:lng):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:dbl, X_1:sht):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:dbl, X_1:sht):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:bte):bte 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:bte):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:bte):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:dbl):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:dbl):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:flt):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:flt):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:int):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:int):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:int):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:lng):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:lng):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:lng):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:sht):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:sht):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:flt, X_1:sht):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:bte):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:bte):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:bte):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:bte):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:dbl):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:dbl):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:dbl):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:dbl):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:flt):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:flt):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:flt):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:flt):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:int):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:int):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:int):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:int):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:lng):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:lng):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:lng):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:lng):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:sht):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:sht):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:sht):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:int, X_1:sht):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:bte):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:bte):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:bte):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:dbl):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:dbl):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:dbl):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:flt):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:flt):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:flt):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:int):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:int):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:int):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:lng):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:lng):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:lng):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:sht):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:sht):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:lng, X_1:sht):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:bte):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:bte):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:bte):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:bte):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:bte):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:dbl):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:dbl):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:dbl):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:dbl):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:dbl):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:flt):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:flt):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:flt):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:flt):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:flt):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:int):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:int):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:int):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:int):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:int):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:lng):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:lng):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:lng):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:lng):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:lng):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:sht):dbl 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:sht):flt 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:sht):int 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:sht):lng 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
/
pattern calc./(X_0:sht, X_1:sht):sht 
CMDvarDIVsignal;
Return V1 / V2, signal error on divide by zero
calc
<
pattern calc.<(X_0:bit, X_1:bit):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:blob, X_1:blob):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:bte, X_1:bte):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:bte, X_1:dbl):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:bte, X_1:flt):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:bte, X_1:int):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:bte, X_1:lng):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:bte, X_1:sht):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:date, X_1:date):bit 
CMDvarLT;
Equality of two dates
calc
<
pattern calc.<(X_0:daytime, X_1:daytime):bit 
CMDvarLT;
Equality of two daytimes
calc
<
pattern calc.<(X_0:dbl, X_1:bte):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:dbl, X_1:dbl):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:dbl, X_1:flt):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:dbl, X_1:int):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:dbl, X_1:lng):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:dbl, X_1:sht):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:flt, X_1:bte):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:flt, X_1:dbl):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:flt, X_1:flt):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:flt, X_1:int):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:flt, X_1:lng):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:flt, X_1:sht):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:inet, X_1:inet):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:int, X_1:bte):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:int, X_1:dbl):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:int, X_1:flt):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:int, X_1:int):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:int, X_1:lng):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:int, X_1:sht):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:json, X_1:json):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:lng, X_1:bte):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:lng, X_1:dbl):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:lng, X_1:flt):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:lng, X_1:int):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:lng, X_1:lng):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:lng, X_1:sht):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:oid, X_1:oid):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:sht, X_1:bte):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:sht, X_1:dbl):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:sht, X_1:flt):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:sht, X_1:int):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:sht, X_1:lng):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:sht, X_1:sht):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:str, X_1:str):bit 
CMDvarLT;
Return V1 < V2
calc
<
pattern calc.<(X_0:timestamp, X_1:timestamp):bit 
CMDvarLT;
Equality of two timestamps
calc
<
pattern calc.<(X_0:uuid, X_1:uuid):bit 
CMDvarLT;
Return V1 < V2
calc
<<
pattern calc.<<(X_0:bte, X_1:bte):bte 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:bte, X_1:int):bte 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:bte, X_1:lng):bte 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:bte, X_1:sht):bte 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:int, X_1:bte):int 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:int, X_1:int):int 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:int, X_1:lng):int 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:int, X_1:sht):int 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:lng, X_1:bte):lng 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:lng, X_1:int):lng 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:lng, X_1:lng):lng 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:lng, X_1:sht):lng 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:sht, X_1:bte):sht 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:sht, X_1:int):sht 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:sht, X_1:lng):sht 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<<
pattern calc.<<(X_0:sht, X_1:sht):sht 
CMDvarLSHsignal;
Return V1 << V2, raise error on out of range second operand
calc
<=
pattern calc.<=(X_0:bit, X_1:bit):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:blob, X_1:blob):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:bte, X_1:bte):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:bte, X_1:dbl):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:bte, X_1:flt):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:bte, X_1:int):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:bte, X_1:lng):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:bte, X_1:sht):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:date, X_1:date):bit 
CMDvarLE;
Equality of two dates
calc
<=
pattern calc.<=(X_0:daytime, X_1:daytime):bit 
CMDvarLE;
Equality of two daytimes
calc
<=
pattern calc.<=(X_0:dbl, X_1:bte):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:dbl, X_1:dbl):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:dbl, X_1:flt):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:dbl, X_1:int):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:dbl, X_1:lng):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:dbl, X_1:sht):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:flt, X_1:bte):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:flt, X_1:dbl):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:flt, X_1:flt):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:flt, X_1:int):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:flt, X_1:lng):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:flt, X_1:sht):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:inet, X_1:inet):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:int, X_1:bte):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:int, X_1:dbl):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:int, X_1:flt):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:int, X_1:int):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:int, X_1:lng):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:int, X_1:sht):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:json, X_1:json):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:lng, X_1:bte):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:lng, X_1:dbl):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:lng, X_1:flt):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:lng, X_1:int):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:lng, X_1:lng):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:lng, X_1:sht):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:oid, X_1:oid):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:sht, X_1:bte):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:sht, X_1:dbl):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:sht, X_1:flt):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:sht, X_1:int):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:sht, X_1:lng):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:sht, X_1:sht):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:str, X_1:str):bit 
CMDvarLE;
Return V1 <= V2
calc
<=
pattern calc.<=(X_0:timestamp, X_1:timestamp):bit 
CMDvarLE;
Equality of two timestamps
calc
<=
pattern calc.<=(X_0:uuid, X_1:uuid):bit 
CMDvarLE;
Return V1 <= V2
calc
==
pattern calc.==(X_0:bit, X_1:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bit, X_1:bit, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:blob, X_1:blob):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:blob, X_1:blob, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:bte):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:bte, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:dbl):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:dbl, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:flt):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:flt, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:int):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:int, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:lng):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:lng, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:sht):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:bte, X_1:sht, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:date, X_1:date):bit 
CMDvarEQ;
Equality of two dates
calc
==
pattern calc.==(X_0:date, X_1:date, X_2:bit):bit 
CMDvarEQ;
Equality of two dates
calc
==
pattern calc.==(X_0:daytime, X_1:daytime):bit 
CMDvarEQ;
Equality of two daytimes
calc
==
pattern calc.==(X_0:daytime, X_1:daytime, X_2:bit):bit 
CMDvarEQ;
Equality of two daytimes
calc
==
pattern calc.==(X_0:dbl, X_1:bte):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:bte, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:dbl):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:dbl, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:flt):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:flt, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:int):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:int, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:lng):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:lng, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:sht):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:dbl, X_1:sht, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:bte):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:bte, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:dbl):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:dbl, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:flt):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:flt, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:int):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:int, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:lng):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:lng, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:sht):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:flt, X_1:sht, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:inet, X_1:inet):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:inet, X_1:inet, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:bte):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:bte, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:dbl):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:dbl, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:flt):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:flt, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:int):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:int, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:lng):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:lng, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:sht):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:int, X_1:sht, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:json, X_1:json):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:json, X_1:json, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:bte):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:bte, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:dbl):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:dbl, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:flt):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:flt, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:int):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:int, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:lng):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:lng, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:sht):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:lng, X_1:sht, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:oid, X_1:oid):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:oid, X_1:oid, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:bte):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:bte, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:dbl):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:dbl, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:flt):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:flt, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:int):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:int, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:lng):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:lng, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:sht):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:sht, X_1:sht, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:str, X_1:str):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:str, X_1:str, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:timestamp, X_1:timestamp):bit 
CMDvarEQ;
Equality of two timestamps
calc
==
pattern calc.==(X_0:timestamp, X_1:timestamp, X_2:bit):bit 
CMDvarEQ;
Equality of two timestamps
calc
==
pattern calc.==(X_0:uuid, X_1:uuid):bit 
CMDvarEQ;
Return V1 == V2
calc
==
pattern calc.==(X_0:uuid, X_1:uuid, X_2:bit):bit 
CMDvarEQ;
Return V1 == V2
calc
>
pattern calc.>(X_0:bit, X_1:bit):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:blob, X_1:blob):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:bte, X_1:bte):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:bte, X_1:dbl):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:bte, X_1:flt):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:bte, X_1:int):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:bte, X_1:lng):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:bte, X_1:sht):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:date, X_1:date):bit 
CMDvarGT;
Equality of two dates
calc
>
pattern calc.>(X_0:daytime, X_1:daytime):bit 
CMDvarGT;
Equality of two daytimes
calc
>
pattern calc.>(X_0:dbl, X_1:bte):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:dbl, X_1:dbl):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:dbl, X_1:flt):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:dbl, X_1:int):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:dbl, X_1:lng):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:dbl, X_1:sht):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:flt, X_1:bte):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:flt, X_1:dbl):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:flt, X_1:flt):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:flt, X_1:int):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:flt, X_1:lng):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:flt, X_1:sht):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:inet, X_1:inet):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:int, X_1:bte):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:int, X_1:dbl):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:int, X_1:flt):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:int, X_1:int):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:int, X_1:lng):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:int, X_1:sht):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:json, X_1:json):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:lng, X_1:bte):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:lng, X_1:dbl):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:lng, X_1:flt):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:lng, X_1:int):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:lng, X_1:lng):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:lng, X_1:sht):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:oid, X_1:oid):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:sht, X_1:bte):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:sht, X_1:dbl):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:sht, X_1:flt):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:sht, X_1:int):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:sht, X_1:lng):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:sht, X_1:sht):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:str, X_1:str):bit 
CMDvarGT;
Return V1 > V2
calc
>
pattern calc.>(X_0:timestamp, X_1:timestamp):bit 
CMDvarGT;
Equality of two timestamps
calc
>
pattern calc.>(X_0:uuid, X_1:uuid):bit 
CMDvarGT;
Return V1 > V2
calc
>=
pattern calc.>=(X_0:bit, X_1:bit):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:blob, X_1:blob):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:bte, X_1:bte):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:bte, X_1:dbl):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:bte, X_1:flt):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:bte, X_1:int):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:bte, X_1:lng):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:bte, X_1:sht):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:date, X_1:date):bit 
CMDvarGE;
Equality of two dates
calc
>=
pattern calc.>=(X_0:daytime, X_1:daytime):bit 
CMDvarGE;
Equality of two daytimes
calc
>=
pattern calc.>=(X_0:dbl, X_1:bte):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:dbl, X_1:dbl):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:dbl, X_1:flt):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:dbl, X_1:int):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:dbl, X_1:lng):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:dbl, X_1:sht):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:flt, X_1:bte):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:flt, X_1:dbl):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:flt, X_1:flt):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:flt, X_1:int):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:flt, X_1:lng):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:flt, X_1:sht):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:inet, X_1:inet):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:int, X_1:bte):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:int, X_1:dbl):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:int, X_1:flt):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:int, X_1:int):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:int, X_1:lng):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:int, X_1:sht):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:json, X_1:json):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:lng, X_1:bte):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:lng, X_1:dbl):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:lng, X_1:flt):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:lng, X_1:int):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:lng, X_1:lng):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:lng, X_1:sht):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:oid, X_1:oid):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:sht, X_1:bte):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:sht, X_1:dbl):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:sht, X_1:flt):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:sht, X_1:int):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:sht, X_1:lng):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:sht, X_1:sht):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:str, X_1:str):bit 
CMDvarGE;
Return V1 >= V2
calc
>=
pattern calc.>=(X_0:timestamp, X_1:timestamp):bit 
CMDvarGE;
Equality of two timestamps
calc
>=
pattern calc.>=(X_0:uuid, X_1:uuid):bit 
CMDvarGE;
Return V1 >= V2
calc
>>
pattern calc.>>(X_0:bte, X_1:bte):bte 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:bte, X_1:int):bte 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:bte, X_1:lng):bte 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:bte, X_1:sht):bte 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:int, X_1:bte):int 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:int, X_1:int):int 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:int, X_1:lng):int 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:int, X_1:sht):int 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:lng, X_1:bte):lng 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:lng, X_1:int):lng 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:lng, X_1:lng):lng 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:lng, X_1:sht):lng 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:sht, X_1:bte):sht 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:sht, X_1:int):sht 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:sht, X_1:lng):sht 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
>>
pattern calc.>>(X_0:sht, X_1:sht):sht 
CMDvarRSHsignal;
Return V1 >> V2, raise error on out of range second operand
calc
abs
pattern calc.abs(X_0:bte):bte 
CMDvarABS;
Unary absolute value of V
calc
abs
pattern calc.abs(X_0:dbl):dbl 
CMDvarABS;
Unary absolute value of V
calc
abs
pattern calc.abs(X_0:flt):flt 
CMDvarABS;
Unary absolute value of V
calc
abs
pattern calc.abs(X_0:int):int 
CMDvarABS;
Unary absolute value of V
calc
abs
pattern calc.abs(X_0:lng):lng 
CMDvarABS;
Unary absolute value of V
calc
abs
pattern calc.abs(X_0:sht):sht 
CMDvarABS;
Unary absolute value of V
calc
add_noerror
pattern calc.add_noerror(X_0:bte, X_1:bte):bte 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:bte, X_1:dbl):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:bte, X_1:flt):flt 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:bte, X_1:int):int 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:bte, X_1:lng):lng 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:bte, X_1:sht):sht 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:dbl, X_1:bte):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:dbl, X_1:dbl):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:dbl, X_1:flt):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:dbl, X_1:int):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:dbl, X_1:lng):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:dbl, X_1:sht):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:flt, X_1:bte):flt 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:flt, X_1:dbl):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:flt, X_1:flt):flt 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:flt, X_1:int):flt 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:flt, X_1:lng):flt 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:flt, X_1:sht):flt 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:int, X_1:bte):int 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:int, X_1:dbl):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:int, X_1:flt):flt 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:int, X_1:int):int 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:int, X_1:lng):lng 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:int, X_1:sht):int 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:lng, X_1:bte):lng 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:lng, X_1:dbl):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:lng, X_1:flt):flt 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:lng, X_1:int):lng 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:lng, X_1:lng):lng 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:lng, X_1:sht):lng 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:sht, X_1:bte):sht 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:sht, X_1:dbl):dbl 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:sht, X_1:flt):flt 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:sht, X_1:int):int 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:sht, X_1:lng):lng 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
add_noerror
pattern calc.add_noerror(X_0:sht, X_1:sht):sht 
CMDvarADD;
Return V1 + V2, overflow results in NIL value
calc
and
pattern calc.and(X_0:bit, X_1:bit):bit 
CMDvarAND;
Return V1 AND V2
calc
and
pattern calc.and(X_0:bte, X_1:bte):bte 
CMDvarAND;
Return V1 AND V2
calc
and
pattern calc.and(X_0:int, X_1:int):int 
CMDvarAND;
Return V1 AND V2
calc
and
pattern calc.and(X_0:lng, X_1:lng):lng 
CMDvarAND;
Return V1 AND V2
calc
and
pattern calc.and(X_0:sht, X_1:sht):sht 
CMDvarAND;
Return V1 AND V2
calc
between
pattern calc.between(X_0:any_1, X_1:any_1, X_2:any_1, X_3:bit, X_4:bit, X_5:bit, X_6:bit, X_7:bit):bit 
CMDvarBETWEEN;
B between LO and HI inclusive
calc
bit
pattern calc.bit(X_0:bit):bit 
CMDvarCONVERT;
Cast VALUE to bit
calc
bit
pattern calc.bit(X_0:bte):bit 
CMDvarCONVERT;
Cast VALUE to bit
calc
bit
pattern calc.bit(X_0:dbl):bit 
CMDvarCONVERT;
Cast VALUE to bit
calc
bit
pattern calc.bit(X_0:flt):bit 
CMDvarCONVERT;
Cast VALUE to bit
calc
bit
pattern calc.bit(X_0:int):bit 
CMDvarCONVERT;
Cast VALUE to bit
calc
bit
pattern calc.bit(X_0:lng):bit 
CMDvarCONVERT;
Cast VALUE to bit
calc
bit
pattern calc.bit(X_0:oid):bit 
CMDvarCONVERT;
Cast VALUE to bit
calc
bit
pattern calc.bit(X_0:sht):bit 
CMDvarCONVERT;
Cast VALUE to bit
calc
bit
pattern calc.bit(X_0:str):bit 
CMDvarCONVERT;
Cast VALUE to bit
calc
bit
pattern calc.bit(X_0:void):bit 
CMDvarCONVERT;
Cast VALUE to bit
calc
blob
command calc.blob(X_0:blob):blob 
BLOBblob_blob;
(empty)
calc
blob
command calc.blob(X_0:str):blob 
BLOBblob_fromstr;
(empty)
calc
blob
command calc.blob(X_0:str):blob 
str_2_blob;
cast to blob
calc
bte
pattern calc.bte(X_0:bit):bte 
CMDvarCONVERT;
Cast VALUE to bte
calc
bte
pattern calc.bte(X_0:bte):bte 
CMDvarCONVERT;
Cast VALUE to bte
calc
bte
pattern calc.bte(X_0:dbl):bte 
CMDvarCONVERT;
Cast VALUE to bte
calc
bte
pattern calc.bte(X_0:flt):bte 
CMDvarCONVERT;
Cast VALUE to bte
calc
bte
pattern calc.bte(X_0:int):bte 
CMDvarCONVERT;
Cast VALUE to bte
calc
bte
pattern calc.bte(X_0:lng):bte 
CMDvarCONVERT;
Cast VALUE to bte
calc
bte
pattern calc.bte(X_0:oid):bte 
CMDvarCONVERT;
Cast VALUE to bte
calc
bte
pattern calc.bte(X_0:sht):bte 
CMDvarCONVERT;
Cast VALUE to bte
calc
bte
pattern calc.bte(X_0:str):bte 
CMDvarCONVERT;
Cast VALUE to bte
calc
bte
pattern calc.bte(X_0:void):bte 
CMDvarCONVERT;
Cast VALUE to bte
calc
bte
command calc.bte(X_0:int, X_1:bte):bte 
bte_dec2_bte;
cast decimal(bte) to bte and check for overflow
calc
bte
command calc.bte(X_0:int, X_1:bte, X_2:int, X_3:int):bte 
bte_dec2dec_bte;
cast decimal(bte) to decimal(bte) and check for overflow
calc
bte
command calc.bte(X_0:bte, X_1:int, X_2:int):bte 
bte_num2dec_bte;
cast number to decimal(bte) and check for overflow
calc
bte
command calc.bte(X_0:dbl, X_1:int, X_2:int):bte 
dbl_num2dec_bte;
cast number to decimal(bte) and check for overflow
calc
bte
command calc.bte(X_0:flt, X_1:int, X_2:int):bte 
flt_num2dec_bte;
cast number to decimal(bte) and check for overflow
calc
bte
command calc.bte(X_0:int, X_1:int):bte 
int_dec2_bte;
cast decimal(int) to bte and check for overflow
calc
bte
command calc.bte(X_0:int, X_1:int, X_2:int, X_3:int):bte 
int_dec2dec_bte;
cast decimal(int) to decimal(bte) and check for overflow
calc
bte
command calc.bte(X_0:int, X_1:int, X_2:int):bte 
int_num2dec_bte;
cast number to decimal(bte) and check for overflow
calc
bte
command calc.bte(X_0:int, X_1:lng):bte 
lng_dec2_bte;
cast decimal(lng) to bte and check for overflow
calc
bte
command calc.bte(X_0:int, X_1:lng, X_2:int, X_3:int):bte 
lng_dec2dec_bte;
cast decimal(lng) to decimal(bte) and check for overflow
calc
bte
command calc.bte(X_0:lng, X_1:int, X_2:int):bte 
lng_num2dec_bte;
cast number to decimal(bte) and check for overflow
calc
bte
command calc.bte(X_0:void, X_1:int, X_2:int):bte 
nil_2dec_bte;
cast to dec(bte) and check for overflow
calc
bte
command calc.bte(X_0:int, X_1:sht):bte 
sht_dec2_bte;
cast decimal(sht) to bte and check for overflow
calc
bte
command calc.bte(X_0:int, X_1:sht, X_2:int, X_3:int):bte 
sht_dec2dec_bte;
cast decimal(sht) to decimal(bte) and check for overflow
calc
bte
command calc.bte(X_0:sht, X_1:int, X_2:int):bte 
sht_num2dec_bte;
cast number to decimal(bte) and check for overflow
calc
bte
command calc.bte(X_0:str, X_1:int, X_2:int):bte 
str_2dec_bte;
cast to dec(bte) and check for overflow
calc
cmp
pattern calc.cmp(X_0:bit, X_1:bit):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:bte, X_1:bte):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:bte, X_1:dbl):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:bte, X_1:flt):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:bte, X_1:int):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:bte, X_1:lng):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:bte, X_1:sht):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:dbl, X_1:bte):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:dbl, X_1:dbl):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:dbl, X_1:flt):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:dbl, X_1:int):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:dbl, X_1:lng):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:dbl, X_1:sht):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:flt, X_1:bte):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:flt, X_1:dbl):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:flt, X_1:flt):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:flt, X_1:int):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:flt, X_1:lng):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:flt, X_1:sht):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:int, X_1:bte):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:int, X_1:dbl):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:int, X_1:flt):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:int, X_1:int):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:int, X_1:lng):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:int, X_1:sht):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:lng, X_1:bte):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:lng, X_1:dbl):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:lng, X_1:flt):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:lng, X_1:int):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:lng, X_1:lng):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:lng, X_1:sht):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:oid, X_1:oid):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:sht, X_1:bte):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:sht, X_1:dbl):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:sht, X_1:flt):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:sht, X_1:int):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:sht, X_1:lng):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:sht, X_1:sht):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
cmp
pattern calc.cmp(X_0:str, X_1:str):bte 
CMDvarCMP;
Return -1/0/1 if V1 </==/> V2
calc
date
command calc.date(X_0:date):date 
MTIMEdate_date;
(empty)
calc
date
command calc.date(X_0:str):date 
MTIMEdate_fromstr;
(empty)
calc
date
command calc.date(X_0:timestamp):date 
MTIMEtimestamp_extract_date;
(empty)
calc
date
pattern calc.date(X_0:void):date 
nil_2_date;
cast to date
calc
date
pattern calc.date(X_0:str):date 
str_2_date;
cast to date
calc
daytime
command calc.daytime(X_0:daytime):daytime 
MTIMEdaytime_daytime;
(empty)
calc
daytime
command calc.daytime(X_0:lng):daytime 
MTIMEdaytime_fromseconds;
(empty)
calc
daytime
command calc.daytime(X_0:str):daytime 
MTIMEdaytime_fromstr;
(empty)
calc
daytime
command calc.daytime(X_0:timestamp):daytime 
MTIMEtimestamp_extract_daytime;
(empty)
calc
daytime
pattern calc.daytime(X_0:daytime, X_1:int):daytime 
daytime_2time_daytime;
cast daytime to daytime and check for overflow
calc
daytime
pattern calc.daytime(X_0:lng, X_1:int):daytime 
second_interval_2_daytime;
cast second_interval to a daytime and check for overflow
calc
daytime
pattern calc.daytime(X_0:str, X_1:int):daytime 
str_2time_daytime;
cast to daytime and check for overflow
calc
daytime
pattern calc.daytime(X_0:str, X_1:int, X_2:int):daytime 
str_2time_daytimetz;
cast to daytime and check for overflow
calc
daytime
pattern calc.daytime(X_0:timestamp, X_1:int):daytime 
timestamp_2_daytime;
cast timestamp to a daytime and check for overflow
calc
dbl
pattern calc.dbl(X_0:bit):dbl 
CMDvarCONVERT;
Cast VALUE to dbl
calc
dbl
pattern calc.dbl(X_0:bte):dbl 
CMDvarCONVERT;
Cast VALUE to dbl
calc
dbl
pattern calc.dbl(X_0:dbl):dbl 
CMDvarCONVERT;
Cast VALUE to dbl
calc
dbl
pattern calc.dbl(X_0:flt):dbl 
CMDvarCONVERT;
Cast VALUE to dbl
calc
dbl
pattern calc.dbl(X_0:int):dbl 
CMDvarCONVERT;
Cast VALUE to dbl
calc
dbl
pattern calc.dbl(X_0:lng):dbl 
CMDvarCONVERT;
Cast VALUE to dbl
calc
dbl
pattern calc.dbl(X_0:oid):dbl 
CMDvarCONVERT;
Cast VALUE to dbl
calc
dbl
pattern calc.dbl(X_0:sht):dbl 
CMDvarCONVERT;
Cast VALUE to dbl
calc
dbl
pattern calc.dbl(X_0:str):dbl 
CMDvarCONVERT;
Cast VALUE to dbl
calc
dbl
pattern calc.dbl(X_0:void):dbl 
CMDvarCONVERT;
Cast VALUE to dbl
calc
dbl
command calc.dbl(X_0:int, X_1:bte):dbl 
bte_dec2_dbl;
cast decimal(bte) to dbl and check for overflow
calc
dbl
command calc.dbl(X_0:int, X_1:bte, X_2:int, X_3:int):dbl 
bte_dec2dec_dbl;
cast decimal(bte) to decimal(dbl) and check for overflow
calc
dbl
command calc.dbl(X_0:bte, X_1:int, X_2:int):dbl 
bte_num2dec_dbl;
cast number to decimal(dbl) and check for overflow
calc
dbl
command calc.dbl(X_0:int, X_1:int):dbl 
int_dec2_dbl;
cast decimal(int) to dbl and check for overflow
calc
dbl
command calc.dbl(X_0:int, X_1:int, X_2:int, X_3:int):dbl 
int_dec2dec_dbl;
cast decimal(int) to decimal(dbl) and check for overflow
calc
dbl
command calc.dbl(X_0:int, X_1:int, X_2:int):dbl 
int_num2dec_dbl;
cast number to decimal(dbl) and check for overflow
calc
dbl
command calc.dbl(X_0:int, X_1:lng):dbl 
lng_dec2_dbl;
cast decimal(lng) to dbl and check for overflow
calc
dbl
command calc.dbl(X_0:int, X_1:lng, X_2:int, X_3:int):dbl 
lng_dec2dec_dbl;
cast decimal(lng) to decimal(dbl) and check for overflow
calc
dbl
command calc.dbl(X_0:lng, X_1:int, X_2:int):dbl 
lng_num2dec_dbl;
cast number to decimal(dbl) and check for overflow
calc
dbl
command calc.dbl(X_0:int, X_1:sht):dbl 
sht_dec2_dbl;
cast decimal(sht) to dbl and check for overflow
calc
dbl
command calc.dbl(X_0:int, X_1:sht, X_2:int, X_3:int):dbl 
sht_dec2dec_dbl;
cast decimal(sht) to decimal(dbl) and check for overflow
calc
dbl
command calc.dbl(X_0:sht, X_1:int, X_2:int):dbl 
sht_num2dec_dbl;
cast number to decimal(dbl) and check for overflow
calc
dec_round
command calc.dec_round(X_0:bte, X_1:bte):bte 
bte_dec_round_wrap;
round off the value v to nearests multiple of r
calc
dec_round
command calc.dec_round(X_0:dbl, X_1:dbl):dbl 
dbl_dec_round_wrap;
round off the value v to nearests multiple of r
calc
dec_round
command calc.dec_round(X_0:flt, X_1:flt):flt 
flt_dec_round_wrap;
round off the value v to nearests multiple of r
calc
dec_round
command calc.dec_round(X_0:int, X_1:int):int 
int_dec_round_wrap;
round off the value v to nearests multiple of r
calc
dec_round
command calc.dec_round(X_0:lng, X_1:lng):lng 
lng_dec_round_wrap;
round off the value v to nearests multiple of r
calc
dec_round
command calc.dec_round(X_0:sht, X_1:sht):sht 
sht_dec_round_wrap;
round off the value v to nearests multiple of r
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:bte):bte 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:bte):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:bte):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:bte):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:bte):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:bte):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:dbl):bte 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:dbl):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:dbl):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:dbl):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:dbl):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:dbl):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:flt):bte 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:flt):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:flt):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:flt):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:flt):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:flt):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:int):bte 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:int):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:int):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:int):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:int):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:int):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:lng):bte 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:lng):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:lng):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:lng):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:lng):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:lng):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:sht):bte 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:sht):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:sht):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:sht):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:sht):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:bte, X_1:sht):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:dbl, X_1:bte):bte 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:dbl, X_1:bte):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:dbl, X_1:dbl):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:dbl, X_1:flt):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:dbl, X_1:int):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:dbl, X_1:int):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:dbl, X_1:lng):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:dbl, X_1:lng):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:dbl, X_1:sht):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:dbl, X_1:sht):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:bte):bte 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:bte):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:bte):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:dbl):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:dbl):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:flt):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:flt):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:int):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:int):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:int):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:lng):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:lng):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:lng):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:sht):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:sht):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:flt, X_1:sht):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:bte):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:bte):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:bte):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:bte):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:dbl):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:dbl):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:dbl):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:dbl):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:flt):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:flt):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:flt):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:flt):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:int):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:int):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:int):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:int):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:lng):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:lng):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:lng):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:lng):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:sht):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:sht):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:sht):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:int, X_1:sht):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:bte):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:bte):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:bte):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:dbl):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:dbl):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:dbl):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:flt):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:flt):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:flt):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:int):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:int):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:int):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:lng):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:lng):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:lng):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:sht):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:sht):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:lng, X_1:sht):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:bte):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:bte):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:bte):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:bte):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:bte):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:dbl):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:dbl):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:dbl):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:dbl):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:dbl):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:flt):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:flt):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:flt):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:flt):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:flt):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:int):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:int):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:int):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:int):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:int):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:lng):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:lng):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:lng):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:lng):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:lng):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:sht):dbl 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:sht):flt 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:sht):int 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:sht):lng 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
div_noerror
pattern calc.div_noerror(X_0:sht, X_1:sht):sht 
CMDvarDIV;
Return V1 / V2, divide by zero results in NIL value
calc
flt
pattern calc.flt(X_0:bit):flt 
CMDvarCONVERT;
Cast VALUE to flt
calc
flt
pattern calc.flt(X_0:bte):flt 
CMDvarCONVERT;
Cast VALUE to flt
calc
flt
pattern calc.flt(X_0:dbl):flt 
CMDvarCONVERT;
Cast VALUE to flt
calc
flt
pattern calc.flt(X_0:flt):flt 
CMDvarCONVERT;
Cast VALUE to flt
calc
flt
pattern calc.flt(X_0:int):flt 
CMDvarCONVERT;
Cast VALUE to flt
calc
flt
pattern calc.flt(X_0:lng):flt 
CMDvarCONVERT;
Cast VALUE to flt
calc
flt
pattern calc.flt(X_0:oid):flt 
CMDvarCONVERT;
Cast VALUE to flt
calc
flt
pattern calc.flt(X_0:sht):flt 
CMDvarCONVERT;
Cast VALUE to flt
calc
flt
pattern calc.flt(X_0:str):flt 
CMDvarCONVERT;
Cast VALUE to flt
calc
flt
pattern calc.flt(X_0:void):flt 
CMDvarCONVERT;
Cast VALUE to flt
calc
flt
command calc.flt(X_0:int, X_1:bte):flt 
bte_dec2_flt;
cast decimal(bte) to flt and check for overflow
calc
flt
command calc.flt(X_0:int, X_1:bte, X_2:int, X_3:int):flt 
bte_dec2dec_flt;
cast decimal(bte) to decimal(flt) and check for overflow
calc
flt
command calc.flt(X_0:bte, X_1:int, X_2:int):flt 
bte_num2dec_flt;
cast number to decimal(flt) and check for overflow
calc
flt
command calc.flt(X_0:int, X_1:int):flt 
int_dec2_flt;
cast decimal(int) to flt and check for overflow
calc
flt
command calc.flt(X_0:int, X_1:int, X_2:int, X_3:int):flt 
int_dec2dec_flt;
cast decimal(int) to decimal(flt) and check for overflow
calc
flt
command calc.flt(X_0:int, X_1:int, X_2:int):flt 
int_num2dec_flt;
cast number to decimal(flt) and check for overflow
calc
flt
command calc.flt(X_0:int, X_1:lng):flt 
lng_dec2_flt;
cast decimal(lng) to flt and check for overflow
calc
flt
command calc.flt(X_0:int, X_1:lng, X_2:int, X_3:int):flt 
lng_dec2dec_flt;
cast decimal(lng) to decimal(flt) and check for overflow
calc
flt
command calc.flt(X_0:lng, X_1:int, X_2:int):flt 
lng_num2dec_flt;
cast number to decimal(flt) and check for overflow
calc
flt
command calc.flt(X_0:int, X_1:sht):flt 
sht_dec2_flt;
cast decimal(sht) to flt and check for overflow
calc
flt
command calc.flt(X_0:int, X_1:sht, X_2:int, X_3:int):flt 
sht_dec2dec_flt;
cast decimal(sht) to decimal(flt) and check for overflow
calc
flt
command calc.flt(X_0:sht, X_1:int, X_2:int):flt 
sht_num2dec_flt;
cast number to decimal(flt) and check for overflow
calc
hash
pattern calc.hash(X_0:any):lng 
MKEYhash;
(empty)
calc
hash
pattern calc.hash(X_0:bte):lng 
MKEYhash;
(empty)
calc
hash
pattern calc.hash(X_0:dbl):lng 
MKEYhash;
(empty)
calc
hash
pattern calc.hash(X_0:flt):lng 
MKEYhash;
(empty)
calc
hash
pattern calc.hash(X_0:int):lng 
MKEYhash;
(empty)
calc
hash
pattern calc.hash(X_0:lng):lng 
MKEYhash;
(empty)
calc
hash
pattern calc.hash(X_0:lng):lng 
MKEYhash;
(empty)
calc
hash
pattern calc.hash(X_0:oid):lng 
MKEYhash;
(empty)
calc
hash
pattern calc.hash(X_0:sht):lng 
MKEYhash;
(empty)
calc
identity
command calc.identity(X_0:any):oid 
SQLidentity;
Returns a unique row identitfier.
calc
ifthenelse
pattern calc.ifthenelse(X_0:bit, X_1:any_1, X_2:any_1):any_1 
CALCswitchbit;
If VALUE is true return MIDDLE else RIGHT
calc
inet
command calc.inet(X_0:str):inet 
INET_fromstr;
Convert a string to an inet
calc
inet
command calc.inet(X_0:inet):inet 
INET_inet;
Convert a inet to an inet
calc
int
pattern calc.int(X_0:bit):int 
CMDvarCONVERT;
Cast VALUE to int
calc
int
pattern calc.int(X_0:bte):int 
CMDvarCONVERT;
Cast VALUE to int
calc
int
pattern calc.int(X_0:dbl):int 
CMDvarCONVERT;
Cast VALUE to int
calc
int
pattern calc.int(X_0:flt):int 
CMDvarCONVERT;
Cast VALUE to int
calc
int
pattern calc.int(X_0:int):int 
CMDvarCONVERT;
Cast VALUE to int
calc
int
pattern calc.int(X_0:lng):int 
CMDvarCONVERT;
Cast VALUE to int
calc
int
pattern calc.int(X_0:oid):int 
CMDvarCONVERT;
Cast VALUE to int
calc
int
pattern calc.int(X_0:sht):int 
CMDvarCONVERT;
Cast VALUE to int
calc
int
pattern calc.int(X_0:str):int 
CMDvarCONVERT;
Cast VALUE to int
calc
int
pattern calc.int(X_0:void):int 
CMDvarCONVERT;
Cast VALUE to int
calc
int
command calc.int(X_0:int, X_1:bte):int 
bte_dec2_int;
cast decimal(bte) to int and check for overflow
calc
int
command calc.int(X_0:int, X_1:bte, X_2:int, X_3:int):int 
bte_dec2dec_int;
cast decimal(bte) to decimal(int) and check for overflow
calc
int
command calc.int(X_0:bte, X_1:int, X_2:int):int 
bte_num2dec_int;
cast number to decimal(int) and check for overflow
calc
int
command calc.int(X_0:dbl, X_1:int, X_2:int):int 
dbl_num2dec_int;
cast number to decimal(int) and check for overflow
calc
int
command calc.int(X_0:flt, X_1:int, X_2:int):int 
flt_num2dec_int;
cast number to decimal(int) and check for overflow
calc
int
command calc.int(X_0:int, X_1:int):int 
int_dec2_int;
cast decimal(int) to int and check for overflow
calc
int
command calc.int(X_0:int, X_1:int, X_2:int, X_3:int):int 
int_dec2dec_int;
cast decimal(int) to decimal(int) and check for overflow
calc
int
command calc.int(X_0:int, X_1:int, X_2:int):int 
int_num2dec_int;
cast number to decimal(int) and check for overflow
calc
int
command calc.int(X_0:int, X_1:lng):int 
lng_dec2_int;
cast decimal(lng) to int and check for overflow
calc
int
command calc.int(X_0:int, X_1:lng, X_2:int, X_3:int):int 
lng_dec2dec_int;
cast decimal(lng) to decimal(int) and check for overflow
calc
int
command calc.int(X_0:lng, X_1:int, X_2:int):int 
lng_num2dec_int;
cast number to decimal(int) and check for overflow
calc
int
command calc.int(X_0:void, X_1:int, X_2:int):int 
nil_2dec_int;
cast to dec(int) and check for overflow
calc
int
command calc.int(X_0:int, X_1:sht):int 
sht_dec2_int;
cast decimal(sht) to int and check for overflow
calc
int
command calc.int(X_0:int, X_1:sht, X_2:int, X_3:int):int 
sht_dec2dec_int;
cast decimal(sht) to decimal(int) and check for overflow
calc
int
command calc.int(X_0:sht, X_1:int, X_2:int):int 
sht_num2dec_int;
cast number to decimal(int) and check for overflow
calc
int
command calc.int(X_0:str, X_1:int, X_2:int):int 
str_2dec_int;
cast to dec(int) and check for overflow
calc
isnil
pattern calc.isnil(X_0:any):bit 
CMDvarISNIL;
Unary check for nil of V
calc
isnotnil
pattern calc.isnotnil(X_0:any):bit 
CMDvarISNOTNIL;
Unary check for notnil of V
calc
iszero
pattern calc.iszero(X_0:bte):bit 
CMDvarISZERO;
Unary check for zero of V
calc
iszero
pattern calc.iszero(X_0:dbl):bit 
CMDvarISZERO;
Unary check for zero of V
calc
iszero
pattern calc.iszero(X_0:flt):bit 
CMDvarISZERO;
Unary check for zero of V
calc
iszero
pattern calc.iszero(X_0:int):bit 
CMDvarISZERO;
Unary check for zero of V
calc
iszero
pattern calc.iszero(X_0:lng):bit 
CMDvarISZERO;
Unary check for zero of V
calc
iszero
pattern calc.iszero(X_0:sht):bit 
CMDvarISZERO;
Unary check for zero of V
calc
json
command calc.json(X_0:json):json 
JSON2json;
Convert JSON to JSON
calc
json
command calc.json(X_0:str):json 
JSONstr2json;
Convert string to its JSON. Dealing with escape characters
calc
length
command calc.length(X_0:str):int 
CMDstrlength;
Length of STRING
calc
lng
pattern calc.lng(X_0:bit):lng 
CMDvarCONVERT;
Cast VALUE to lng
calc
lng
pattern calc.lng(X_0:bte):lng 
CMDvarCONVERT;
Cast VALUE to lng
calc
lng
pattern calc.lng(X_0:dbl):lng 
CMDvarCONVERT;
Cast VALUE to lng
calc
lng
pattern calc.lng(X_0:flt):lng 
CMDvarCONVERT;
Cast VALUE to lng
calc
lng
pattern calc.lng(X_0:int):lng 
CMDvarCONVERT;
Cast VALUE to lng
calc
lng
pattern calc.lng(X_0:lng):lng 
CMDvarCONVERT;
Cast VALUE to lng
calc
lng
pattern calc.lng(X_0:oid):lng 
CMDvarCONVERT;
Cast VALUE to lng
calc
lng
pattern calc.lng(X_0:sht):lng 
CMDvarCONVERT;
Cast VALUE to lng
calc
lng
pattern calc.lng(X_0:str):lng 
CMDvarCONVERT;
Cast VALUE to lng
calc
lng
pattern calc.lng(X_0:void):lng 
CMDvarCONVERT;
Cast VALUE to lng
calc
lng
command calc.lng(X_0:int, X_1:bte):lng 
bte_dec2_lng;
cast decimal(bte) to lng and check for overflow
calc
lng
command calc.lng(X_0:int, X_1:bte, X_2:int, X_3:int):lng 
bte_dec2dec_lng;
cast decimal(bte) to decimal(lng) and check for overflow
calc
lng
command calc.lng(X_0:bte, X_1:int, X_2:int):lng 
bte_num2dec_lng;
cast number to decimal(lng) and check for overflow
calc
lng
command calc.lng(X_0:dbl, X_1:int, X_2:int):lng 
dbl_num2dec_lng;
cast number to decimal(lng) and check for overflow
calc
lng
command calc.lng(X_0:flt, X_1:int, X_2:int):lng 
flt_num2dec_lng;
cast number to decimal(lng) and check for overflow
calc
lng
command calc.lng(X_0:int, X_1:int):lng 
int_dec2_lng;
cast decimal(int) to lng and check for overflow
calc
lng
command calc.lng(X_0:int, X_1:int, X_2:int, X_3:int):lng 
int_dec2dec_lng;
cast decimal(int) to decimal(lng) and check for overflow
calc
lng
command calc.lng(X_0:int, X_1:int, X_2:int):lng 
int_num2dec_lng;
cast number to decimal(lng) and check for overflow
calc
lng
command calc.lng(X_0:int, X_1:lng):lng 
lng_dec2_lng;
cast decimal(lng) to lng and check for overflow
calc
lng
command calc.lng(X_0:int, X_1:lng, X_2:int, X_3:int):lng 
lng_dec2dec_lng;
cast decimal(lng) to decimal(lng) and check for overflow
calc
lng
command calc.lng(X_0:lng, X_1:int, X_2:int):lng 
lng_num2dec_lng;
cast number to decimal(lng) and check for overflow
calc
lng
command calc.lng(X_0:void, X_1:int, X_2:int):lng 
nil_2dec_lng;
cast to dec(lng) and check for overflow
calc
lng
command calc.lng(X_0:int, X_1:sht):lng 
sht_dec2_lng;
cast decimal(sht) to lng and check for overflow
calc
lng
command calc.lng(X_0:int, X_1:sht, X_2:int, X_3:int):lng 
sht_dec2dec_lng;
cast decimal(sht) to decimal(lng) and check for overflow
calc
lng
command calc.lng(X_0:sht, X_1:int, X_2:int):lng 
sht_num2dec_lng;
cast number to decimal(lng) and check for overflow
calc
lng
command calc.lng(X_0:str, X_1:int, X_2:int):lng 
str_2dec_lng;
cast to dec(lng) and check for overflow
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:bte, X_1:bte):bte 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:bte, X_1:int):bte 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:bte, X_1:lng):bte 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:bte, X_1:sht):bte 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:int, X_1:bte):int 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:int, X_1:int):int 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:int, X_1:lng):int 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:int, X_1:sht):int 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:lng, X_1:bte):lng 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:lng, X_1:int):lng 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:lng, X_1:lng):lng 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:lng, X_1:sht):lng 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:sht, X_1:bte):sht 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:sht, X_1:int):sht 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:sht, X_1:lng):sht 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
lsh_noerror
pattern calc.lsh_noerror(X_0:sht, X_1:sht):sht 
CMDvarLSH;
Return V1 << V2, out of range second operand results in NIL value
calc
max
pattern calc.max(X_0:any_1, X_1:any_1):any_1 
CALCmax;
Return max of V1 and V2
calc
max_no_nil
pattern calc.max_no_nil(X_0:any_1, X_1:any_1):any_1 
CALCmax_no_nil;
Return max of V1 and V2, ignoring nil values
calc
mbr
command calc.mbr(X_0:mbr):mbr 
mbrFromMBR;
(empty)
calc
mbr
command calc.mbr(X_0:str):mbr 
mbrFromString;
(empty)
calc
min
pattern calc.min(X_0:any_1, X_1:any_1):any_1 
CALCmin;
Return min of V1 and V2
calc
min_no_nil
pattern calc.min_no_nil(X_0:any_1, X_1:any_1):any_1 
CALCmin_no_nil;
Return min of V1 and V2, ignoring nil values
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:bte):bte 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:bte):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:bte):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:bte):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:dbl):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:flt):flt 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:int):bte 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:int):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:int):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:int):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:lng):bte 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:lng):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:lng):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:lng):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:sht):bte 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:sht):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:sht):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:bte, X_1:sht):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:dbl, X_1:bte):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:dbl, X_1:dbl):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:dbl, X_1:flt):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:dbl, X_1:int):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:dbl, X_1:lng):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:dbl, X_1:sht):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:flt, X_1:bte):flt 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:flt, X_1:dbl):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:flt, X_1:flt):flt 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:flt, X_1:int):flt 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:flt, X_1:lng):flt 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:flt, X_1:sht):flt 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:bte):bte 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:bte):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:bte):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:bte):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:dbl):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:flt):flt 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:int):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:int):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:lng):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:lng):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:sht):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:sht):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:int, X_1:sht):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:bte):bte 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:bte):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:bte):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:bte):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:dbl):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:flt):flt 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:int):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:int):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:lng):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:sht):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:sht):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:lng, X_1:sht):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:bte):bte 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:bte):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:bte):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:bte):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:dbl):dbl 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:flt):flt 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:int):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:int):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:int):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:lng):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:lng):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:lng):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:sht):int 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:sht):lng 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
mod_noerror
pattern calc.mod_noerror(X_0:sht, X_1:sht):sht 
CMDvarMOD;
Return V1 % V2, divide by zero results in NIL value
calc
month_interval
pattern calc.month_interval(X_0:bte, X_1:int, X_2:int):int 
month_interval;
cast bte to a month_interval and check for overflow
calc
month_interval
pattern calc.month_interval(X_0:int, X_1:int, X_2:int):int 
month_interval;
cast int to a month_interval and check for overflow
calc
month_interval
pattern calc.month_interval(X_0:lng, X_1:int, X_2:int):int 
month_interval;
cast lng to a month_interval and check for overflow
calc
month_interval
pattern calc.month_interval(X_0:sht, X_1:int, X_2:int):int 
month_interval;
cast sht to a month_interval and check for overflow
calc
month_interval
pattern calc.month_interval(X_0:str, X_1:int, X_2:int):int 
month_interval_str;
cast str to a month_interval and check for overflow
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:bte):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:dbl):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:dbl):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:dbl):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:dbl):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:dbl):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:flt):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:flt):flt 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:flt):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:flt):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:flt):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:int):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:lng):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:bte, X_1:sht):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:bte):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:bte):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:bte):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:bte):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:bte):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:dbl):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:flt):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:int):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:int):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:int):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:int):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:int):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:lng):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:lng):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:lng):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:lng):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:lng):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:sht):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:sht):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:sht):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:sht):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:dbl, X_1:sht):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:bte):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:bte):flt 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:bte):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:bte):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:bte):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:dbl):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:flt):flt 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:int):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:int):flt 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:int):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:int):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:int):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:lng):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:lng):flt 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:lng):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:lng):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:lng):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:sht):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:sht):flt 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:sht):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:sht):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:flt, X_1:sht):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:bte):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:dbl):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:dbl):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:dbl):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:dbl):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:dbl):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:flt):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:flt):flt 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:flt):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:flt):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:flt):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:int):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:lng):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:int, X_1:sht):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:bte):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:dbl):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:dbl):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:dbl):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:dbl):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:dbl):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:flt):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:flt):flt 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:flt):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:flt):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:flt):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:int):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:lng):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:lng, X_1:sht):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:bte):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:dbl):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:dbl):dbl 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:dbl):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:dbl):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:dbl):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:flt):bte 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:flt):flt 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:flt):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:flt):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:flt):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:int):int 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:lng):lng 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
mul_noerror
pattern calc.mul_noerror(X_0:sht, X_1:sht):sht 
CMDvarMUL;
Return V1 * V2, overflow results in NIL value
calc
not
pattern calc.not(X_0:bit):bit 
CMDvarNOT;
Return the Boolean inverse
calc
not
pattern calc.not(X_0:bte):bte 
CMDvarNOT;
Unary bitwise not of V
calc
not
pattern calc.not(X_0:int):int 
CMDvarNOT;
Unary bitwise not of V
calc
not
pattern calc.not(X_0:lng):lng 
CMDvarNOT;
Unary bitwise not of V
calc
not
pattern calc.not(X_0:sht):sht 
CMDvarNOT;
Unary bitwise not of V
calc
oid
pattern calc.oid(X_0:bit):oid 
CMDvarCONVERT;
Cast VALUE to oid
calc
oid
pattern calc.oid(X_0:bte):oid 
CMDvarCONVERT;
Cast VALUE to oid
calc
oid
pattern calc.oid(X_0:dbl):oid 
CMDvarCONVERT;
Cast VALUE to oid
calc
oid
pattern calc.oid(X_0:flt):oid 
CMDvarCONVERT;
Cast VALUE to oid
calc
oid
pattern calc.oid(X_0:int):oid 
CMDvarCONVERT;
Cast VALUE to oid
calc
oid
pattern calc.oid(X_0:lng):oid 
CMDvarCONVERT;
Cast VALUE to oid
calc
oid
pattern calc.oid(X_0:oid):oid 
CMDvarCONVERT;
Cast VALUE to oid
calc
oid
pattern calc.oid(X_0:sht):oid 
CMDvarCONVERT;
Cast VALUE to oid
calc
oid
pattern calc.oid(X_0:str):oid 
CMDvarCONVERT;
Cast VALUE to oid
calc
oid
pattern calc.oid(X_0:void):oid 
CMDvarCONVERT;
Cast VALUE to oid
calc
or
pattern calc.or(X_0:bit, X_1:bit):bit 
CMDvarOR;
Return V1 OR V2
calc
or
pattern calc.or(X_0:bte, X_1:bte):bte 
CMDvarOR;
Return V1 OR V2
calc
or
pattern calc.or(X_0:int, X_1:int):int 
CMDvarOR;
Return V1 OR V2
calc
or
pattern calc.or(X_0:lng, X_1:lng):lng 
CMDvarOR;
Return V1 OR V2
calc
or
pattern calc.or(X_0:sht, X_1:sht):sht 
CMDvarOR;
Return V1 OR V2
calc
ptr
command calc.ptr(X_0:ptr):ptr 
CMDvarCONVERTptr;
Cast VALUE to ptr
calc
rotate_xor_hash
pattern calc.rotate_xor_hash(X_0:lng, X_1:int, X_2:any_1):lng 
MKEYrotate_xor_hash;
(empty)
calc
round
command calc.round(X_0:bte, X_1:bte, X_2:int, X_3:int):bte 
bte_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
calc
round
command calc.round(X_0:dbl, X_1:bte):dbl 
dbl_round_wrap;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
calc
round
command calc.round(X_0:flt, X_1:bte):flt 
flt_round_wrap;
round off the floating point v to r digits behind the dot (if r < 0, before the dot)
calc
round
command calc.round(X_0:int, X_1:bte, X_2:int, X_3:int):int 
int_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
calc
round
command calc.round(X_0:lng, X_1:bte, X_2:int, X_3:int):lng 
lng_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
calc
round
command calc.round(X_0:sht, X_1:bte, X_2:int, X_3:int):sht 
sht_round_wrap;
round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)
calc
rowid
pattern calc.rowid(X_0:any_1, X_1:str, X_2:str):oid 
sql_rowid;
return the next rowid
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:bte, X_1:bte):bte 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:bte, X_1:int):bte 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:bte, X_1:lng):bte 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:bte, X_1:sht):bte 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:int, X_1:bte):int 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:int, X_1:int):int 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:int, X_1:lng):int 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:int, X_1:sht):int 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:lng, X_1:bte):lng 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:lng, X_1:int):lng 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:lng, X_1:lng):lng 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:lng, X_1:sht):lng 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:sht, X_1:bte):sht 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:sht, X_1:int):sht 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:sht, X_1:lng):sht 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
rsh_noerror
pattern calc.rsh_noerror(X_0:sht, X_1:sht):sht 
CMDvarRSH;
Return V1 >> V2, out of range second operand results in NIL value
calc
second_interval
command calc.second_interval(X_0:int, X_1:bte, X_2:int, X_3:int):lng 
bte_dec2second_interval;
cast bte decimal to a second_interval
calc
second_interval
command calc.second_interval(X_0:int, X_1:int, X_2:int, X_3:int):lng 
int_dec2second_interval;
cast int decimal to a second_interval
calc
second_interval
command calc.second_interval(X_0:int, X_1:lng, X_2:int, X_3:int):lng 
lng_dec2second_interval;
cast lng decimal to a second_interval
calc
second_interval
pattern calc.second_interval(X_0:bte, X_1:int, X_2:int):lng 
second_interval;
cast bte to a second_interval and check for overflow
calc
second_interval
pattern calc.second_interval(X_0:int, X_1:int, X_2:int):lng 
second_interval;
cast int to a second_interval and check for overflow
calc
second_interval
pattern calc.second_interval(X_0:lng, X_1:int, X_2:int):lng 
second_interval;
cast lng to a second_interval and check for overflow
calc
second_interval
pattern calc.second_interval(X_0:sht, X_1:int, X_2:int):lng 
second_interval;
cast sht to a second_interval and check for overflow
calc
second_interval
pattern calc.second_interval(X_0:daytime, X_1:int, X_2:int):lng 
second_interval_daytime;
cast daytime to a second_interval and check for overflow
calc
second_interval
pattern calc.second_interval(X_0:str, X_1:int, X_2:int):lng 
second_interval_str;
cast str to a second_interval and check for overflow
calc
second_interval
command calc.second_interval(X_0:int, X_1:sht, X_2:int, X_3:int):lng 
sht_dec2second_interval;
cast sht decimal to a second_interval
calc
sht
pattern calc.sht(X_0:bit):sht 
CMDvarCONVERT;
Cast VALUE to sht
calc
sht
pattern calc.sht(X_0:bte):sht 
CMDvarCONVERT;
Cast VALUE to sht
calc
sht
pattern calc.sht(X_0:dbl):sht 
CMDvarCONVERT;
Cast VALUE to sht
calc
sht
pattern calc.sht(X_0:flt):sht 
CMDvarCONVERT;
Cast VALUE to sht
calc
sht
pattern calc.sht(X_0:int):sht 
CMDvarCONVERT;
Cast VALUE to sht
calc
sht
pattern calc.sht(X_0:lng):sht 
CMDvarCONVERT;
Cast VALUE to sht
calc
sht
pattern calc.sht(X_0:oid):sht 
CMDvarCONVERT;
Cast VALUE to sht
calc
sht
pattern calc.sht(X_0:sht):sht 
CMDvarCONVERT;
Cast VALUE to sht
calc
sht
pattern calc.sht(X_0:str):sht 
CMDvarCONVERT;
Cast VALUE to sht
calc
sht
pattern calc.sht(X_0:void):sht 
CMDvarCONVERT;
Cast VALUE to sht
calc
sht
command calc.sht(X_0:int, X_1:bte):sht 
bte_dec2_sht;
cast decimal(bte) to sht and check for overflow
calc
sht
command calc.sht(X_0:int, X_1:bte, X_2:int, X_3:int):sht 
bte_dec2dec_sht;
cast decimal(bte) to decimal(sht) and check for overflow
calc
sht
command calc.sht(X_0:bte, X_1:int, X_2:int):sht 
bte_num2dec_sht;
cast number to decimal(sht) and check for overflow
calc
sht
command calc.sht(X_0:dbl, X_1:int, X_2:int):sht 
dbl_num2dec_sht;
cast number to decimal(sht) and check for overflow
calc
sht
command calc.sht(X_0:flt, X_1:int, X_2:int):sht 
flt_num2dec_sht;
cast number to decimal(sht) and check for overflow
calc
sht
command calc.sht(X_0:int, X_1:int):sht 
int_dec2_sht;
cast decimal(int) to sht and check for overflow
calc
sht
command calc.sht(X_0:int, X_1:int, X_2:int, X_3:int):sht 
int_dec2dec_sht;
cast decimal(int) to decimal(sht) and check for overflow
calc
sht
command calc.sht(X_0:int, X_1:int, X_2:int):sht 
int_num2dec_sht;
cast number to decimal(sht) and check for overflow
calc
sht
command calc.sht(X_0:int, X_1:lng):sht 
lng_dec2_sht;
cast decimal(lng) to sht and check for overflow
calc
sht
command calc.sht(X_0:int, X_1:lng, X_2:int, X_3:int):sht 
lng_dec2dec_sht;
cast decimal(lng) to decimal(sht) and check for overflow
calc
sht
command calc.sht(X_0:lng, X_1:int, X_2:int):sht 
lng_num2dec_sht;
cast number to decimal(sht) and check for overflow
calc
sht
command calc.sht(X_0:void, X_1:int, X_2:int):sht 
nil_2dec_sht;
cast to dec(sht) and check for overflow
calc
sht
command calc.sht(X_0:int, X_1:sht):sht 
sht_dec2_sht;
cast decimal(sht) to sht and check for overflow
calc
sht
command calc.sht(X_0:int, X_1:sht, X_2:int, X_3:int):sht 
sht_dec2dec_sht;
cast decimal(sht) to decimal(sht) and check for overflow
calc
sht
command calc.sht(X_0:sht, X_1:int, X_2:int):sht 
sht_num2dec_sht;
cast number to decimal(sht) and check for overflow
calc
sht
command calc.sht(X_0:str, X_1:int, X_2:int):sht 
str_2dec_sht;
cast to dec(sht) and check for overflow
calc
sign
pattern calc.sign(X_0:bte):bte 
CMDvarSIGN;
Unary sign (-1,0,1) of V
calc
sign
pattern calc.sign(X_0:dbl):bte 
CMDvarSIGN;
Unary sign (-1,0,1) of V
calc
sign
pattern calc.sign(X_0:flt):bte 
CMDvarSIGN;
Unary sign (-1,0,1) of V
calc
sign
pattern calc.sign(X_0:int):bte 
CMDvarSIGN;
Unary sign (-1,0,1) of V
calc
sign
pattern calc.sign(X_0:lng):bte 
CMDvarSIGN;
Unary sign (-1,0,1) of V
calc
sign
pattern calc.sign(X_0:sht):bte 
CMDvarSIGN;
Unary sign (-1,0,1) of V
calc
str
pattern calc.str(X_0:any):str 
CMDvarCONVERT;
Cast VALUE to str
calc
str
pattern calc.str(X_0:int, X_1:int, X_2:int, X_3:int, X_4:any_1, X_5:int):str 
SQLstr_cast;
cast to string and check for overflow
calc
str
command calc.str(X_0:uuid):str 
UUIDuuid2str;
Coerce a uuid to a string type
calc
sub_noerror
pattern calc.sub_noerror(X_0:bte, X_1:bte):bte 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:bte, X_1:dbl):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:bte, X_1:flt):flt 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:bte, X_1:int):int 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:bte, X_1:lng):lng 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:bte, X_1:sht):sht 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:dbl, X_1:bte):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:dbl, X_1:dbl):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:dbl, X_1:flt):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:dbl, X_1:int):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:dbl, X_1:lng):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:dbl, X_1:sht):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:flt, X_1:bte):flt 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:flt, X_1:dbl):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:flt, X_1:flt):flt 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:flt, X_1:int):flt 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:flt, X_1:lng):flt 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:flt, X_1:sht):flt 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:int, X_1:bte):int 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:int, X_1:dbl):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:int, X_1:flt):flt 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:int, X_1:int):int 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:int, X_1:lng):lng 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:int, X_1:sht):int 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:lng, X_1:bte):lng 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:lng, X_1:dbl):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:lng, X_1:flt):flt 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:lng, X_1:int):lng 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:lng, X_1:lng):lng 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:lng, X_1:sht):lng 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:sht, X_1:bte):sht 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:sht, X_1:dbl):dbl 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:sht, X_1:flt):flt 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:sht, X_1:int):int 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:sht, X_1:lng):lng 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
sub_noerror
pattern calc.sub_noerror(X_0:sht, X_1:sht):sht 
CMDvarSUB;
Return V1 - V2, overflow results in NIL value
calc
timestamp
command calc.timestamp(X_0:date):timestamp 
MTIMEtimestamp_fromdate;
(empty)
calc
timestamp
command calc.timestamp(X_0:lng):timestamp 
MTIMEtimestamp_frommsec;
(empty)
calc
timestamp
command calc.timestamp(X_0:int):timestamp 
MTIMEtimestamp_fromsecond;
(empty)
calc
timestamp
command calc.timestamp(X_0:str):timestamp 
MTIMEtimestamp_fromstr;
(empty)
calc
timestamp
command calc.timestamp(X_0:timestamp):timestamp 
MTIMEtimestamp_timestamp;
(empty)
calc
timestamp
pattern calc.timestamp(X_0:date, X_1:int):timestamp 
date_2_timestamp;
cast date to a timestamp and check for overflow
calc
timestamp
pattern calc.timestamp(X_0:void, X_1:int):timestamp 
nil_2time_timestamp;
cast to timestamp and check for overflow
calc
timestamp
pattern calc.timestamp(X_0:str, X_1:int):timestamp 
str_2time_timestamp;
cast to timestamp and check for overflow
calc
timestamp
pattern calc.timestamp(X_0:str, X_1:int, X_2:int):timestamp 
str_2time_timestamptz;
cast to timestamp and check for overflow
calc
timestamp
pattern calc.timestamp(X_0:timestamp, X_1:int):timestamp 
timestamp_2time_timestamp;
cast timestamp to timestamp and check for overflow
calc
url
command calc.url(X_0:str):url 
URLnew;
Create an URL from a string literal
calc
url
command calc.url(X_0:url):url 
URLnoop;
Create an URL from a string literal
calc
uuid
command calc.uuid(X_0:str):uuid 
UUIDstr2uuid;
Coerce a string to a uuid, validating its format
calc
uuid
command calc.uuid(X_0:uuid):uuid 
UUIDuuid2uuid;
(empty)
calc
void
pattern calc.void(X_0:bit):void 
CMDvarCONVERT;
Cast VALUE to void
calc
void
pattern calc.void(X_0:bte):void 
CMDvarCONVERT;
Cast VALUE to void
calc
void
pattern calc.void(X_0:dbl):void 
CMDvarCONVERT;
Cast VALUE to void
calc
void
pattern calc.void(X_0:flt):void 
CMDvarCONVERT;
Cast VALUE to void
calc
void
pattern calc.void(X_0:int):void 
CMDvarCONVERT;
Cast VALUE to void
calc
void
pattern calc.void(X_0:lng):void 
CMDvarCONVERT;
Cast VALUE to void
calc
void
pattern calc.void(X_0:oid):void 
CMDvarCONVERT;
Cast VALUE to void
calc
void
pattern calc.void(X_0:sht):void 
CMDvarCONVERT;
Cast VALUE to void
calc
void
pattern calc.void(X_0:str):void 
CMDvarCONVERT;
Cast VALUE to void
calc
void
pattern calc.void(X_0:void):void 
CMDvarCONVERT;
Cast VALUE to void
calc
wkb
function calc.wkb(wkt:str, srid:int, type:int):wkb;
(empty)
(empty)
calc
wkb
command calc.wkb(X_0:wkb, X_1:int, X_2:int):wkb 
geom_2_geom;
Called when inserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition
calc
wkb
command calc.wkb(X_0:wkb):wkb 
wkbFromWKB;
It is called when adding a new geometry column to an existing table
calc
xml
command calc.xml(X_0:str):xml 
XMLstr2xml;
(empty)
calc
xml
command calc.xml(X_0:xml):xml 
XMLxml2xml;
(empty)
calc
xor
pattern calc.xor(X_0:bit, X_1:bit):bit 
CMDvarXOR;
Return V1 XOR V2
calc
xor
pattern calc.xor(X_0:bte, X_1:bte):bte 
CMDvarXOR;
Return V1 XOR V2
calc
xor
pattern calc.xor(X_0:int, X_1:int):int 
CMDvarXOR;
Return V1 XOR V2
calc
xor
pattern calc.xor(X_0:lng, X_1:lng):lng 
CMDvarXOR;
Return V1 XOR V2
calc
xor
pattern calc.xor(X_0:sht, X_1:sht):sht 
CMDvarXOR;
Return V1 XOR V2
capi
eval
pattern capi.eval(X_0:ptr, X_1:bit, X_2:str):any 
CUDFevalStd;
Execute a simple CUDF script returning a single value
capi
eval
pattern capi.eval(X_0:ptr, X_1:bit, X_2:str, X_3:any...):any... 
CUDFevalStd;
Execute a simple CUDF script value
capi
eval_aggr
pattern capi.eval_aggr(X_0:ptr, X_1:bit, X_2:str, X_3:any...):any... 
CUDFevalAggr;
grouped aggregates through CUDF
capi
prelude
command capi.prelude():void 
CUDFprelude;
(empty)
capi
subeval_aggr
pattern capi.subeval_aggr(X_0:ptr, X_1:bit, X_2:str, X_3:any...):any... 
CUDFevalAggr;
grouped aggregates through CUDF
clients
addUser
unsafe pattern clients.addUser(X_0:str, X_1:str):oid 
CLTaddUser;
Allow user with password access to the given scenarios
clients
backendsum
command clients.backendsum(X_0:str):str 
CLTbackendsum;
Return hex string representation of the currently used hash of the given string
clients
changePassword
unsafe pattern clients.changePassword(X_0:str, X_1:str):void 
CLTchangePassword;
Change the password for the current user
clients
changeUsername
unsafe pattern clients.changeUsername(X_0:str, X_1:str):void 
CLTchangeUsername;
Change the username of the user into the new string
clients
checkPermission
pattern clients.checkPermission(X_0:str, X_1:str):void 
CLTcheckPermission;
Check permission for a user, requires hashed password (backendsum)
clients
current_sessionid
pattern clients.current_sessionid():int 
CLTgetSessionID;
return current session ID
clients
getId
pattern clients.getId():int 
CLTgetClientId;
Return a number that uniquely represents the current client.
clients
getInfo
pattern clients.getInfo() (X_0:bat[:str], X_1:bat[:str]) 
CLTInfo;
Pseudo bat with client attributes.
clients
getLogins
command clients.getLogins() (X_0:bat[:oid], X_1:bat[:str]) 
CLTLogin;
Pseudo bat of client id and login time.
clients
getPasswordHash
pattern clients.getPasswordHash(X_0:str):str 
CLTgetPasswordHash;
Return the password hash of the given user
clients
getScenario
pattern clients.getScenario():str 
CLTgetScenario;
Retrieve current scenario name.
clients
getUsername
pattern clients.getUsername():str 
CLTgetUsername;
Return the username of the currently logged in user
clients
getUsers
pattern clients.getUsers() (X_0:bat[:oid], X_1:bat[:str]) 
CLTgetUsers;
return a BAT with user id and one with name available in the system
clients
getprofile
pattern clients.getprofile() (X_0:str, X_1:int, X_2:int, X_3:int, X_4:int) 
CLTgetProfile;
Retrieve the profile settings for a client
clients
md5sum
command clients.md5sum(X_0:str):str 
CLTmd5sum;
Return hex string representation of the MD5 hash of the given string
clients
quit
unsafe pattern clients.quit():void 
CLTquit;
Terminate the client session.
clients
quit
unsafe pattern clients.quit(X_0:int):void 
CLTquit;
Terminate the session for a single client using a soft error.@It is the privilege of the console user.
clients
removeUser
unsafe pattern clients.removeUser(X_0:str):void 
CLTremoveUser;
Remove the given user from the system
clients
ripemd160sum
command clients.ripemd160sum(X_0:str):str 
CLTripemd160sum;
Return hex string representation of the RIPEMD160 hash of the given string
clients
setListing
unsafe pattern clients.setListing(X_0:int):int 
CLTsetListing;
Turn on/off echo of MAL instructions:@1 - echo input,@2 - show mal instruction,@4 - show details of type resolutoin, @8 - show binding information.
clients
setPassword
unsafe pattern clients.setPassword(X_0:str, X_1:str):void 
CLTsetPassword;
Set the password for the given user
clients
setQryTimeoutMicro
unsafe pattern clients.setQryTimeoutMicro(X_0:lng):void 
CLTqueryTimeoutMicro;
(empty)
clients
setScenario
unsafe pattern clients.setScenario(X_0:str):str 
CLTsetScenario;
Switch to other scenario handler, return previous one.
clients
setmemorylimit
unsafe pattern clients.setmemorylimit(X_0:int):void 
CLTsetmemorylimit;
(empty)
clients
setmemorylimit
unsafe pattern clients.setmemorylimit(X_0:int, X_1:int):void 
CLTsetmemorylimit;
Limit the memory claim in MB per query
clients
setoptimizer
unsafe pattern clients.setoptimizer(X_0:int, X_1:str):void 
CLTsetoptimizer;
Set the session optimizer
clients
setoptimizer
unsafe pattern clients.setoptimizer(X_0:str):void 
CLTsetoptimizer;
(empty)
clients
setprinttimeout
unsafe command clients.setprinttimeout(X_0:int):void 
CLTsetPrintTimeout;
Print running query every so many seconds.
clients
setquerytimeout
unsafe pattern clients.setquerytimeout(X_0:bte, X_1:int):void 
CLTqueryTimeout;
(empty)
clients
setquerytimeout
unsafe pattern clients.setquerytimeout(X_0:int):void 
CLTqueryTimeout;
(empty)
clients
setquerytimeout
unsafe pattern clients.setquerytimeout(X_0:int, X_1:int):void 
CLTqueryTimeout;
A query is aborted after q seconds (q=0 means run undisturbed).
clients
setquerytimeout
unsafe pattern clients.setquerytimeout(X_0:sht, X_1:int):void 
CLTqueryTimeout;
(empty)
clients
setsession
unsafe pattern clients.setsession(X_0:lng):void 
CLTsetSessionTimeout;
Abort a session after  n seconds.
clients
setsessiontimeout
unsafe pattern clients.setsessiontimeout(X_0:bte, X_1:int):void 
CLTsessionTimeout;
(empty)
clients
setsessiontimeout
unsafe pattern clients.setsessiontimeout(X_0:int):void 
CLTsessionTimeout;
(empty)
clients
setsessiontimeout
unsafe pattern clients.setsessiontimeout(X_0:int, X_1:int):void 
CLTsessionTimeout;
Set the session timeout for a particulat session id
clients
setsessiontimeout
unsafe pattern clients.setsessiontimeout(X_0:sht, X_1:int):void 
CLTsessionTimeout;
(empty)
clients
settimeout
unsafe pattern clients.settimeout(X_0:lng):void 
CLTsetTimeout;
Abort a query after  n seconds.
clients
settimeout
unsafe pattern clients.settimeout(X_0:lng, X_1:lng):void 
CLTsetTimeout;
Abort a query after q seconds (q=0 means run undisturbed).@The session timeout aborts the connection after spending too@many seconds on query processing.
clients
setworkerlimit
unsafe pattern clients.setworkerlimit(X_0:int):void 
CLTsetworkerlimit;
(empty)
clients
setworkerlimit
unsafe pattern clients.setworkerlimit(X_0:int, X_1:int):void 
CLTsetworkerlimit;
Limit the number of worker threads per query
clients
sha1sum
command clients.sha1sum(X_0:str):str 
CLTsha1sum;
Return hex string representation of the SHA-1 hash of the given string
clients
sha2sum
command clients.sha2sum(X_0:str, X_1:int):str 
CLTsha2sum;
Return hex string representation of the SHA-2 hash with bits of the given string
clients
shutdown
unsafe pattern clients.shutdown(X_0:int):str 
CLTshutdown;
(empty)
clients
shutdown
unsafe pattern clients.shutdown(X_0:int, X_1:bit):str 
CLTshutdown;
Close all other client connections. Return if it succeeds.@If forced is set then always stop the system the hard way
clients
stop
unsafe pattern clients.stop(X_0:int):void 
CLTstop;
Stop the query execution at the next eligble statement.
clients
stopsession
unsafe pattern clients.stopsession(X_0:bte):void 
CLTstopSession;
(empty)
clients
stopsession
unsafe pattern clients.stopsession(X_0:int):void 
CLTstopSession;
Stop a particular session
clients
stopsession
unsafe pattern clients.stopsession(X_0:sht):void 
CLTstopSession;
(empty)
clients
suspend
unsafe pattern clients.suspend(X_0:int):void 
CLTsuspend;
Put a client process to sleep for some time.@It will simple sleep for a second at a time, until@the awake bit has been set in its descriptor
clients
wakeup
unsafe pattern clients.wakeup(X_0:int):void 
CLTwakeup;
Wakeup a client process
color
blue
command color.blue(X_0:color):int 
CLRblue;
Extracts blue component from a color atom
color
cb
command color.cb(X_0:color):int 
CLRcb;
Extracts Cb(blue color) component from a color atom
color
color
command color.color(X_0:str):color 
CLRcolor;
Converts string to color
color
cr
command color.cr(X_0:color):int 
CLRcr;
Extracts Cr(red color) component from a color atom
color
green
command color.green(X_0:color):int 
CLRgreen;
Extracts green component from a color atom
color
hsv
command color.hsv(X_0:flt, X_1:flt, X_2:flt):color 
CLRhsv;
Converts an HSV triplets to a color atom
color
hue
command color.hue(X_0:color):flt 
CLRhue;
Extracts hue component from a color atom
color
hue
command color.hue(X_0:color):int 
CLRhueInt;
Extracts hue component from a color atom
color
luminance
command color.luminance(X_0:color):int 
CLRluminance;
Extracts Y(luminance) component from a color atom
color
red
command color.red(X_0:color):int 
CLRred;
Extracts red component from a color atom
color
rgb
command color.rgb(X_0:int, X_1:int, X_2:int):color 
CLRrgb;
Converts an RGB triplets to a color atom
color
saturation
command color.saturation(X_0:color):flt 
CLRsaturation;
Extracts saturation component from a color atom
color
saturation
command color.saturation(X_0:color):int 
CLRsaturationInt;
Extracts saturation component from a color atom
color
str
command color.str(X_0:color):str 
CLRstr;
Converts color to string 
color
value
command color.value(X_0:color):flt 
CLRvalue;
Extracts value component from a color atom
color
value
command color.value(X_0:color):int 
CLRvalueInt;
Extracts value component from a color atom
color
ycc
command color.ycc(X_0:int, X_1:int, X_2:int):color 
CLRycc;
Converts an YCC triplets to a color atom
dict
compress
pattern dict.compress(X_0:bat[:any_1]) (X_1:bat[:any], X_2:bat[:any_1]) 
DICTcompress;
dict compress a bat
dict
compress
pattern dict.compress(X_0:str, X_1:str, X_2:str):void 
DICTcompress_col;
compress a sql column
dict
compress
pattern dict.compress(X_0:str, X_1:str, X_2:str, X_3:bit):void 
DICTcompress_col;
compress a sql column
dict
convert
pattern dict.convert(X_0:bat[:any]):bat[:any_1] 
DICTconvert;
convert candidate list into compressed offsets
dict
decompress
pattern dict.decompress(X_0:bat[:any], X_1:bat[:any_1]):bat[:any_1] 
DICTdecompress;
decompress a dictionary compressed (sub)column
dict
join
pattern dict.join(X_0:bat[:any], X_1:bat[:any_1], X_2:bat[:any], X_3:bat[:any_1], X_4:bat[:oid], X_5:bat[:oid], X_6:bit, X_7:lng) (X_8:bat[:oid], X_9:bat[:oid]) 
DICTjoin;
join 2 dictionaries
dict
renumber
pattern dict.renumber(X_0:bat[:any_1], X_1:bat[:any_1]):bat[:any_1] 
DICTrenumber;
renumber offsets
dict
select
pattern dict.select(X_0:bat[:any], X_1:bat[:oid], X_2:bat[:any_1], X_3:any_1, X_4:any_1, X_5:bit, X_6:bit, X_7:bit, X_8:bit):bat[:oid] 
DICTselect;
value - range select on a dictionary
dict
thetaselect
pattern dict.thetaselect(X_0:bat[:any], X_1:bat[:oid], X_2:bat[:any_1], X_3:any_1, X_4:str):bat[:oid] 
DICTthetaselect;
thetaselect on a dictionary
factories
getArrival
command factories.getArrival():bat[:timestamp] 
FCTgetArrival;
Retrieve the time stamp the last call was made.
factories
getCaller
command factories.getCaller():int 
FCTgetCaller;
Retrieve the unique identity of the factory caller.
factories
getDeparture
command factories.getDeparture():bat[:timestamp] 
FCTgetDeparture;
Retrieve the time stamp the last answer was returned.
factories
getOwners
command factories.getOwners():bat[:str] 
FCTgetOwners;
Retrieve the factory owners table.
factories
getPlants
command factories.getPlants() (X_0:bat[:str], X_1:bat[:str]) 
FCTgetPlants;
Retrieve the names for all active factories.
factories
shutdown
pattern factories.shutdown(X_0:str, X_1:str):void 
FCTshutdown;
Close a factory.
fits
attach
unsafe pattern fits.attach(X_0:str):void 
FITSattach;
Open a FITS file and return catalog of the table HDUs
fits
export
pattern fits.export(X_0:str):void 
FITSexportTable;
Export a table to a FITS file
fits
fitstest
command fits.fitstest(X_0:str):int 
FITStest;
Returns the type of first extension in the FITS file filename
fits
listdir
unsafe pattern fits.listdir(X_0:str):void 
FITSdir;
Attach all FITS files in the directory
fits
listdirpattern
unsafe pattern fits.listdirpattern(X_0:str, X_1:str):void 
FITSdirpat;
Attach all FITS file in the directory, giving a pattern
fits
load
unsafe pattern fits.load(X_0:str):void 
FITSloadTable;
Load a FITS table from an attached file
for
compress
pattern for.compress(X_0:str, X_1:str, X_2:str):void 
FORcompress_col;
compress a sql column
for
decompress
pattern for.decompress(X_0:bat[:any], X_1:any_1):bat[:any_1] 
FORdecompress;
decompress a for compressed (sub)column
generator
join
pattern generator.join(X_0:bat[:bte], X_1:bat[:bte]) (X_2:bat[:oid], X_3:bat[:oid]) 
VLTgenerator_join;
(empty)
generator
join
pattern generator.join(X_0:bat[:dbl], X_1:bat[:dbl]) (X_2:bat[:oid], X_3:bat[:oid]) 
VLTgenerator_join;
Overloaded join operation
generator
join
pattern generator.join(X_0:bat[:flt], X_1:bat[:flt]) (X_2:bat[:oid], X_3:bat[:oid]) 
VLTgenerator_join;
(empty)
generator
join
pattern generator.join(X_0:bat[:int], X_1:bat[:int]) (X_2:bat[:oid], X_3:bat[:oid]) 
VLTgenerator_join;
(empty)
generator
join
pattern generator.join(X_0:bat[:lng], X_1:bat[:lng]) (X_2:bat[:oid], X_3:bat[:oid]) 
VLTgenerator_join;
(empty)
generator
join
pattern generator.join(X_0:bat[:sht], X_1:bat[:sht]) (X_2:bat[:oid], X_3:bat[:oid]) 
VLTgenerator_join;
(empty)
generator
join
pattern generator.join(X_0:bat[:bte], X_1:bat[:bte], X_2:bat[:bte], X_3:bit, X_4:bit) (X_5:bat[:oid], X_6:bat[:oid]) 
VLTgenerator_rangejoin;
(empty)
generator
join
pattern generator.join(X_0:bat[:dbl], X_1:bat[:dbl], X_2:bat[:dbl], X_3:bit, X_4:bit) (X_5:bat[:oid], X_6:bat[:oid]) 
VLTgenerator_rangejoin;
Overloaded range join operation
generator
join
pattern generator.join(X_0:bat[:flt], X_1:bat[:flt], X_2:bat[:flt], X_3:bit, X_4:bit) (X_5:bat[:oid], X_6:bat[:oid]) 
VLTgenerator_rangejoin;
(empty)
generator
join
pattern generator.join(X_0:bat[:int], X_1:bat[:int], X_2:bat[:int], X_3:bit, X_4:bit) (X_5:bat[:oid], X_6:bat[:oid]) 
VLTgenerator_rangejoin;
(empty)
generator
join
pattern generator.join(X_0:bat[:lng], X_1:bat[:lng], X_2:bat[:lng], X_3:bit, X_4:bit) (X_5:bat[:oid], X_6:bat[:oid]) 
VLTgenerator_rangejoin;
(empty)
generator
join
pattern generator.join(X_0:bat[:sht], X_1:bat[:sht], X_2:bat[:sht], X_3:bit, X_4:bit) (X_5:bat[:oid], X_6:bat[:oid]) 
VLTgenerator_rangejoin;
(empty)
generator
parameters
pattern generator.parameters(X_0:bte, X_1:bte):bat[:bte] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:bte, X_1:bte, X_2:bte):bat[:bte] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:dbl, X_1:dbl):bat[:dbl] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:dbl, X_1:dbl, X_2:dbl):bat[:dbl] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:flt, X_1:flt):bat[:flt] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:flt, X_1:flt, X_2:flt):bat[:flt] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:int, X_1:int):bat[:int] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:int, X_1:int, X_2:int):bat[:int] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:lng, X_1:lng):bat[:lng] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:lng, X_1:lng, X_2:lng):bat[:lng] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:sht, X_1:sht):bat[:sht] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:sht, X_1:sht, X_2:sht):bat[:sht] 
VLTgenerator_noop;
(empty)
generator
parameters
pattern generator.parameters(X_0:timestamp, X_1:timestamp, X_2:lng):bat[:timestamp] 
VLTgenerator_noop;
Retain the table definition, but don't materialize
generator
projection
pattern generator.projection(X_0:bat[:oid], X_1:bat[:bte]):bat[:bte] 
VLTgenerator_projection;
(empty)
generator
projection
pattern generator.projection(X_0:bat[:oid], X_1:bat[:dbl]):bat[:dbl] 
VLTgenerator_projection;
(empty)
generator
projection
pattern generator.projection(X_0:bat[:oid], X_1:bat[:flt]):bat[:flt] 
VLTgenerator_projection;
(empty)
generator
projection
pattern generator.projection(X_0:bat[:oid], X_1:bat[:int]):bat[:int] 
VLTgenerator_projection;
(empty)
generator
projection
pattern generator.projection(X_0:bat[:oid], X_1:bat[:lng]):bat[:lng] 
VLTgenerator_projection;
(empty)
generator
projection
pattern generator.projection(X_0:bat[:oid], X_1:bat[:sht]):bat[:sht] 
VLTgenerator_projection;
(empty)
generator
projection
pattern generator.projection(X_0:bat[:oid], X_1:bat[:timestamp]):bat[:timestamp] 
VLTgenerator_projection;
Overloaded projection operation
generator
select
pattern generator.select(X_0:bat[:bte], X_1:bat[:oid], X_2:bte, X_3:bte, X_4:bit, X_5:bit, X_6:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:bte], X_1:bte, X_2:bte, X_3:bit, X_4:bit, X_5:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:dbl], X_1:bat[:oid], X_2:dbl, X_3:dbl, X_4:bit, X_5:bit, X_6:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:dbl], X_1:dbl, X_2:dbl, X_3:bit, X_4:bit, X_5:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:flt], X_1:bat[:oid], X_2:flt, X_3:flt, X_4:bit, X_5:bit, X_6:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:flt], X_1:flt, X_2:flt, X_3:bit, X_4:bit, X_5:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:int], X_1:bat[:oid], X_2:int, X_3:int, X_4:bit, X_5:bit, X_6:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:int], X_1:int, X_2:int, X_3:bit, X_4:bit, X_5:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:lng], X_1:bat[:oid], X_2:lng, X_3:lng, X_4:bit, X_5:bit, X_6:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:lng], X_1:lng, X_2:lng, X_3:bit, X_4:bit, X_5:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:sht], X_1:bat[:oid], X_2:sht, X_3:sht, X_4:bit, X_5:bit, X_6:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:sht], X_1:sht, X_2:sht, X_3:bit, X_4:bit, X_5:bit):bat[:oid] 
VLTgenerator_subselect;
(empty)
generator
select
pattern generator.select(X_0:bat[:timestamp], X_1:bat[:oid], X_2:timestamp, X_3:timestamp, X_4:bit, X_5:bit, X_6:bit):bat[:oid] 
VLTgenerator_subselect;
Overloaded selection routine
generator
select
pattern generator.select(X_0:bat[:timestamp], X_1:timestamp, X_2:timestamp, X_3:bit, X_4:bit, X_5:bit):bat[:oid] 
VLTgenerator_subselect;
Overloaded selection routine
generator
series
pattern generator.series(X_0:bte, X_1:bte):bat[:bte] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:bte, X_1:bte, X_2:bte):bat[:bte] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:dbl, X_1:dbl):bat[:dbl] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:dbl, X_1:dbl, X_2:dbl):bat[:dbl] 
VLTgenerator_table;
Create and materialize a generator table
generator
series
pattern generator.series(X_0:flt, X_1:flt):bat[:flt] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:flt, X_1:flt, X_2:flt):bat[:flt] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:int, X_1:int):bat[:int] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:int, X_1:int, X_2:int):bat[:int] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:lng, X_1:lng):bat[:lng] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:lng, X_1:lng, X_2:lng):bat[:lng] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:sht, X_1:sht):bat[:sht] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:sht, X_1:sht, X_2:sht):bat[:sht] 
VLTgenerator_table;
(empty)
generator
series
pattern generator.series(X_0:timestamp, X_1:timestamp, X_2:lng):bat[:timestamp] 
VLTgenerator_table;
(empty)
generator
thetaselect
pattern generator.thetaselect(X_0:bat[:bte], X_1:bat[:oid], X_2:bte, X_3:str):bat[:oid] 
VLTgenerator_thetasubselect;
(empty)
generator
thetaselect
pattern generator.thetaselect(X_0:bat[:dbl], X_1:bat[:oid], X_2:dbl, X_3:str):bat[:oid] 
VLTgenerator_thetasubselect;
(empty)
generator
thetaselect
pattern generator.thetaselect(X_0:bat[:flt], X_1:bat[:oid], X_2:flt, X_3:str):bat[:oid] 
VLTgenerator_thetasubselect;
(empty)
generator
thetaselect
pattern generator.thetaselect(X_0:bat[:int], X_1:bat[:oid], X_2:int, X_3:str):bat[:oid] 
VLTgenerator_thetasubselect;
(empty)
generator
thetaselect
pattern generator.thetaselect(X_0:bat[:lng], X_1:bat[:oid], X_2:lng, X_3:str):bat[:oid] 
VLTgenerator_thetasubselect;
(empty)
generator
thetaselect
pattern generator.thetaselect(X_0:bat[:sht], X_1:bat[:oid], X_2:sht, X_3:str):bat[:oid] 
VLTgenerator_thetasubselect;
(empty)
generator
thetaselect
pattern generator.thetaselect(X_0:bat[:timestamp], X_1:bat[:oid], X_2:timestamp, X_3:str):bat[:oid] 
VLTgenerator_thetasubselect;
Overloaded selection routine
geom
Area
command geom.Area(X_0:wkb):dbl 
wkbArea;
Returns the area of the surface if it is a polygon or multi-polygon
geom
AsBinary
command geom.AsBinary(X_0:wkb):str 
wkbAsBinary;
Returns the wkb representation into HEX format
geom
AsEWKT
function geom.AsEWKT(w:wkb):str;
(empty)
(empty)
geom
AsText
function geom.AsText(w:wkb):str;
(empty)
(empty)
geom
BdMPolyFromText
function geom.BdMPolyFromText(wkt:str, srid:int):wkb;
(empty)
(empty)
geom
BdPolyFromText
function geom.BdPolyFromText(wkt:str, srid:int):wkb;
(empty)
(empty)
geom
Boundary
command geom.Boundary(X_0:wkb):wkb 
wkbBoundary;
Returns the closure of the combinatorial boundary of the Geometry.
geom
Buffer
command geom.Buffer(X_0:wkb, X_1:dbl):wkb 
wkbBuffer;
Returns a geometry that represents all points whose distance from this geometry is less than or equal to distance. Calculations are in the Spatial Reference System of this Geometry.
geom
Centroid
command geom.Centroid(X_0:wkb):wkb 
wkbCentroid;
Computes the geometric center of a geometry, or equivalently, the center of mass of the geometry as a POINT.
geom
Contains
command geom.Contains(X_0:wkb, X_1:wkb):bit 
wkbContains;
Returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A.
geom
Contains
command geom.Contains(X_0:wkb, X_1:dbl, X_2:dbl):bit 
wkbContains_point;
Returns true if the Geometry a 'spatially contains' Geometry b
geom
Contains
command geom.Contains(X_0:wkb, X_1:bat[:dbl], X_2:bat[:dbl]):bat[:bit] 
wkbContains_point_bat;
Returns true if the Geometry-BAT a 'spatially contains' Geometry-B b
geom
ConvexHull
command geom.ConvexHull(X_0:wkb):wkb 
wkbConvexHull;
Returns a geometry that represents the convex hull of this geometry. The convex hull of a geometry represents the minimum convex geometry that encloses all geometries within the set.
geom
CoordDim
command geom.CoordDim(X_0:wkb):int 
wkbCoordDim;
Return the coordinate dimension of the geometry
geom
CoveredBy
command geom.CoveredBy(X_0:wkb, X_1:wkb):bit 
wkbCoveredBy;
Returns TRUE if no point of geometry A is outside geometry B
geom
Covers
command geom.Covers(X_0:wkb, X_1:wkb):bit 
wkbCovers;
Returns TRUE if no point of geometry B is outside geometry A
geom
Crosses
command geom.Crosses(X_0:wkb, X_1:wkb):bit 
wkbCrosses;
Returns TRUE if the supplied geometries have some, but not all, interior points in common.
geom
DWithin
command geom.DWithin(X_0:wkb, X_1:wkb, X_2:dbl):bit 
wkbDWithin;
Returns true if the two geometries are within the specifies distance from each other
geom
DelaunayTriangles
command geom.DelaunayTriangles(X_0:wkb, X_1:dbl, X_2:int):wkb 
wkbDelaunayTriangles;
Returns a Delaunay triangulation, flag=0 => collection of polygons, flag=1 => multilinestring
geom
Difference
command geom.Difference(X_0:wkb, X_1:wkb):wkb 
wkbDifference;
Returns a geometry that represents that part of geometry A that does not intersect with geometry B
geom
Dimension
command geom.Dimension(X_0:wkb):int 
wkbDimension;
The inherent dimension of this Geometry object, which must be less than or equal to the coordinate dimension.
geom
Disjoint
command geom.Disjoint(X_0:wkb, X_1:wkb):bit 
wkbDisjoint;
Returns true if these Geometries are 'spatially disjoint'
geom
Distance
command geom.Distance(X_0:wkb, X_1:wkb):dbl 
wkbDistance;
Returns the 2-dimensional minimum cartesian distance between the two geometries in projected units (spatial ref units.
geom
Dump
command geom.Dump(X_0:wkb) (X_1:bat[:str], X_2:bat[:wkb]) 
wkbDump;
Gets a MultiPolygon and returns the Polygons in it
geom
DumpPoints
command geom.DumpPoints(X_0:wkb) (X_1:bat[:str], X_2:bat[:wkb]) 
wkbDumpPoints;
Gets a Geometry and returns the Points in it
geom
EndPoint
command geom.EndPoint(X_0:wkb):wkb 
wkbEndPoint;
Returns the last point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING.
geom
Envelope
command geom.Envelope(X_0:wkb):wkb 
wkbEnvelope;
The minimum bounding box for this Geometry, returned as a Geometry. The polygon is defined by the corner points of the bounding box ((MINX,MINY),(MAXX,MINY),(MAXX,MAXY),(MINX,MAXY)).
geom
EnvelopeFromCoordinates
command geom.EnvelopeFromCoordinates(X_0:dbl, X_1:dbl, X_2:dbl, X_3:dbl, X_4:int):wkb 
wkbEnvelopeFromCoordinates;
A polygon created by the provided coordinates
geom
Equals
command geom.Equals(X_0:wkb, X_1:wkb):bit 
wkbEquals;
Returns true if the given geometries represent the same geometry. Directionality is ignored.
geom
ExteriorRing
command geom.ExteriorRing(X_0:wkb):wkb 
wkbExteriorRing;
Returns a line string representing the exterior ring of the POLYGON geometry. Return NULL if the geometry is not a polygon.
geom
Force2D
function geom.Force2D(g:wkb):wkb;
(empty)
(empty)
geom
Force3D
function geom.Force3D(g:wkb):wkb;
(empty)
(empty)
geom
ForceDimensions
command geom.ForceDimensions(X_0:wkb, X_1:int):wkb 
wkbForceDim;
Removes or Adds additional coordinates in the geometry to make it d dimensions
geom
FromBinary
command geom.FromBinary(X_0:str):wkb 
wkbFromBinary;
Creates a wkb using the HEX representation
geom
FromText
command geom.FromText(X_0:str, X_1:int, X_2:int):wkb 
wkbFromText;
(empty)
geom
GeomCollFromText
function geom.GeomCollFromText(wkt:str):wkb;
(empty)
(empty)
geom
GeomCollFromText
function geom.GeomCollFromText(wkt:str, srid:int):wkb;
(empty)
(empty)
geom
GeomFromText
function geom.GeomFromText(wkt:str):wkb;
(empty)
(empty)
geom
GeomFromText
function geom.GeomFromText(wkt:str, srid:int):wkb;
(empty)
(empty)
geom
GeometryN
command geom.GeometryN(X_0:wkb, X_1:int):wkb 
wkbGeometryN;
Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON. Otherwise, return NULL
geom
GeometryType
command geom.GeometryType(X_0:wkb, X_1:int):str 
wkbGeometryType;
(empty)
geom
GeometryType1
function geom.GeometryType1(w:wkb):str;
(empty)
(empty)
geom
GeometryType2
function geom.GeometryType2(w:wkb):str;
(empty)
(empty)
geom
GetCoordinate
command geom.GetCoordinate(X_0:wkb, X_1:int):dbl 
wkbGetCoordinate;
Returns the coordinate at position idx of a point, or NULL if not available. idx=0 -> X, idx=1 -> Y, idx=2 -> Z. Input must be point
geom
InteriorRingN
command geom.InteriorRingN(X_0:wkb, X_1:int):wkb 
wkbInteriorRingN;
Return the Nth interior linestring ring of the polygon geometry. Return NULL if the geometry is not a polygon or the given N is out of range.
geom
InteriorRings
command geom.InteriorRings(X_0:wkb):wkba 
wkbInteriorRings;
Returns an 'array' with all the interior rings of the polygon
geom
Intersection
command geom.Intersection(X_0:wkb, X_1:wkb):wkb 
wkbIntersection;
Returns a geometry that represents the point set intersection of the Geometries a, b
geom
Intersects
command geom.Intersects(X_0:wkb, X_1:wkb):bit 
wkbIntersects;
Returns true if these Geometries 'spatially intersect in 2D'
geom
IsClosed
command geom.IsClosed(X_0:wkb):bit 
wkbIsClosed;
Returns TRUE if the LINESTRING's start and end points are coincident.
geom
IsEmpty
command geom.IsEmpty(X_0:wkb):bit 
wkbIsEmpty;
Returns true if this Geometry is an empty geometry.
geom
IsRing
command geom.IsRing(X_0:wkb):bit 
wkbIsRing;
Returns TRUE if this LINESTRING is both closed and simple.
geom
IsSimple
command geom.IsSimple(X_0:wkb):bit 
wkbIsSimple;
Returns (TRUE) if this Geometry has no anomalous geometric points, such as self intersection or self tangency.
geom
IsValid
command geom.IsValid(X_0:wkb):bit 
wkbIsValid;
Returns true if the ST_Geometry is well formed.
geom
IsValidDetail
command geom.IsValidDetail(X_0:wkb):str 
wkbIsValidDetail;
Returns a valid_detail (valid,reason,location) row stating if a geometry is valid or not and if not valid, a reason why and a location where.
geom
IsValidReason
command geom.IsValidReason(X_0:wkb):str 
wkbIsValidReason;
Returns text stating if a geometry is valid or not and if not valid, a reason why.
geom
Length
command geom.Length(X_0:wkb):dbl 
wkbLength;
Returns the cartesian 2D length of the geometry if it is a linestrin or multilinestring
geom
LineFromText
function geom.LineFromText(wkt:str):wkb;
(empty)
(empty)
geom
LineFromText
function geom.LineFromText(wkt:str, srid:int):wkb;
(empty)
(empty)
geom
MLineFromText
function geom.MLineFromText(wkt:str):wkb;
(empty)
(empty)
geom
MLineFromText
function geom.MLineFromText(wkt:str, srid:int):wkb;
(empty)
(empty)
geom
MLineStringToPolygon
command geom.MLineStringToPolygon(X_0:str, X_1:int, X_2:int):wkb 
wkbMLineStringToPolygon;
Creates polygons using the MultiLineString provided as WKT. Depending on the flag creates one (flag=0) or multiple (flag=1) polygons
geom
MPointFromText
function geom.MPointFromText(wkt:str):wkb;
(empty)
(empty)
geom
MPointFromText
function geom.MPointFromText(wkt:str, srid:int):wkb;
(empty)
(empty)
geom
MPolyFromText
function geom.MPolyFromText(wkt:str):wkb;
(empty)
(empty)
geom
MPolyFromText
function geom.MPolyFromText(wkt:str, srid:int):wkb;
(empty)
(empty)
geom
MakeBox2D
command geom.MakeBox2D(X_0:wkb, X_1:wkb):mbr 
wkbBox2D;
Creates an mbr from the two 2D points
geom
MakeEnvelope
function geom.MakeEnvelope(xmin:dbl, ymin:dbl, xmax:dbl, ymax:dbl):wkb;
(empty)
(empty)
geom
MakeEnvelope
function geom.MakeEnvelope(xmin:dbl, ymin:dbl, xmax:dbl, ymax:dbl, srid:int):wkb;
(empty)
(empty)
geom
MakeLine
command geom.MakeLine(X_0:wkb, X_1:wkb):wkb 
wkbMakeLine;
Gets two point or linestring geometries and returns a linestring geometry
geom
MakeLine
command geom.MakeLine(X_0:bat[:wkb]):wkb 
wkbMakeLineAggr;
Gets a BAT with point or linestring geometries and returns a single linestring geometry
geom
MakePoint
function geom.MakePoint(x:dbl, y:dbl):wkb;
(empty)
(empty)
geom
MakePoint
function geom.MakePoint(x:dbl, y:dbl, z:dbl):wkb;
(empty)
(empty)
geom
MakePoint
function geom.MakePoint(x:dbl, y:dbl, z:dbl, m:dbl):wkb;
(empty)
(empty)
geom
MakePointM
function geom.MakePointM(x:dbl, y:dbl, m:dbl):wkb;
(empty)
(empty)
geom
MakePointXYZM
command geom.MakePointXYZM(X_0:dbl, X_1:dbl, X_2:dbl, X_3:dbl, X_4:int):wkb 
wkbMakePoint;
creates a point using the coordinates
geom
MakePolygon
function geom.MakePolygon(external:wkb):wkb;
(empty)
(empty)
geom
MakePolygon
function geom.MakePolygon(external:wkb, srid:int):wkb;
(empty)
(empty)
geom
NPoints
function geom.NPoints(w:wkb):int;
(empty)
(empty)
geom
NRings
function geom.NRings(w:wkb):int;
(empty)
(empty)
geom
NumGeometries
command geom.NumGeometries(X_0:wkb):int 
wkbNumGeometries;
Returns the number of geometries
geom
NumInteriorRings
function geom.NumInteriorRings(w:wkb):int;
(empty)
(empty)
geom
NumPoints
function geom.NumPoints(w:wkb):int;
(empty)
(empty)
geom
NumRings
command geom.NumRings(X_0:wkb, X_1:int):int 
wkbNumRings;
Returns the number of interior rings+exterior on the first polygon of the geometry
geom
Overlaps
command geom.Overlaps(X_0:wkb, X_1:wkb):bit 
wkbOverlaps;
Returns TRUE if the Geometries intersect but are not completely contained by each other.
geom
PointFromText
function geom.PointFromText(wkt:str):wkb;
(empty)
(empty)
geom
PointFromText
function geom.PointFromText(wkt:str, srid:int):wkb;
(empty)
(empty)
geom
PointN
command geom.PointN(X_0:wkb, X_1:int):wkb 
wkbPointN;
Returns the n-th point of the Geometry. Argument w should be Linestring.
geom
PointOnSurface
command geom.PointOnSurface(X_0:wkb):wkb 
wkbPointOnSurface;
Returns a point guaranteed to lie on the surface. Similar to postGIS it works for points and lines in addition to surfaces and for 3d geometries.
geom
PointsNum
command geom.PointsNum(X_0:wkb, X_1:int):int 
wkbNumPoints;
The number of points in the Geometry. If check=1, the geometry should be a linestring
geom
Polygon
command geom.Polygon(X_0:wkb, X_1:bat[:wkb], X_2:int):wkb 
wkbMakePolygon;
Returns a Polygon created from the provided LineStrings
geom
PolygonFromText
function geom.PolygonFromText(wkt:str):wkb;
(empty)
(empty)
geom
PolygonFromText
function geom.PolygonFromText(wkt:str, srid:int):wkb;
(empty)
(empty)
geom
Relate
command geom.Relate(X_0:wkb, X_1:wkb, X_2:str):bit 
wkbRelate;
Returns true if the Geometry a 'spatially related' to Geometry b, by testing for intersection between the Interior, Boundary and Exterior of the two geometries as specified by the values in the intersectionPatternMatrix.
geom
Segmentize
command geom.Segmentize(X_0:wkb, X_1:dbl):wkb 
wkbSegmentize;
It creates a new geometry with all segments on it smaller or equal to sz
geom
StartPoint
command geom.StartPoint(X_0:wkb):wkb 
wkbStartPoint;
Returns the first point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING
geom
SymDifference
command geom.SymDifference(X_0:wkb, X_1:wkb):wkb 
wkbSymDifference;
Returns a geometry that represents the portions of A and B that do not intersect
geom
ToText
command geom.ToText(X_0:wkb, X_1:int):str 
wkbAsText;
(empty)
geom
Touches
command geom.Touches(X_0:wkb, X_1:wkb):bit 
wkbTouches;
Returns TRUE if the geometries have at least one point in common, but their interiors do not intersect.
geom
Transform
command geom.Transform(X_0:wkb, X_1:int, X_2:int, X_3:str, X_4:str):wkb 
wkbTransform;
Transforms a geometry from one srid to another
geom
Translate
function geom.Translate(g:wkb, dx:dbl, dy:dbl):wkb;
(empty)
(empty)
geom
Translate
function geom.Translate(g:wkb, dx:dbl, dy:dbl, dz:dbl):wkb;
(empty)
(empty)
geom
Translate3D
command geom.Translate3D(X_0:wkb, X_1:dbl, X_2:dbl, X_3:dbl):wkb 
wkbTranslate;
Moves all points of the geometry by dx, dy, dz
geom
Union
command geom.Union(X_0:wkb, X_1:wkb):wkb 
wkbUnion;
Returns a geometry that represents the point set union of the Geometries a, b
geom
Union
command geom.Union(X_0:bat[:wkb]):wkb 
wkbUnionAggr;
Gets a BAT with geometries and returns their union
geom
Within
command geom.Within(X_0:wkb, X_1:wkb):bit 
wkbWithin;
Returns TRUE if the geometry A is completely inside geometry B
geom
X
function geom.X(w:wkb):dbl;
(empty)
(empty)
geom
XMaxFromMBR
function geom.XMaxFromMBR(b:mbr):dbl;
(empty)
(empty)
geom
XMaxFromWKB
function geom.XMaxFromWKB(g:wkb):dbl;
(empty)
(empty)
geom
XMinFromMBR
function geom.XMinFromMBR(b:mbr):dbl;
(empty)
(empty)
geom
XMinFromWKB
function geom.XMinFromWKB(g:wkb):dbl;
(empty)
(empty)
geom
Y
function geom.Y(w:wkb):dbl;
(empty)
(empty)
geom
YMaxFromMBR
function geom.YMaxFromMBR(b:mbr):dbl;
(empty)
(empty)
geom
YMaxFromWKB
function geom.YMaxFromWKB(g:wkb):dbl;
(empty)
(empty)
geom
YMinFromMBR
function geom.YMinFromMBR(b:mbr):dbl;
(empty)
(empty)
geom
YMinFromWKB
function geom.YMinFromWKB(g:wkb):dbl;
(empty)
(empty)
geom
Z
function geom.Z(w:wkb):dbl;
(empty)
(empty)
geom
coordinateFromMBR
command geom.coordinateFromMBR(X_0:mbr, X_1:int):dbl 
wkbCoordinateFromMBR;
returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided mbr
geom
coordinateFromWKB
command geom.coordinateFromWKB(X_0:wkb, X_1:int):dbl 
wkbCoordinateFromWKB;
returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided geometry
geom
epilogue
command geom.epilogue():void 
geom_epilogue;
(empty)
geom
getSRID
command geom.getSRID(X_0:wkb):int 
wkbGetSRID;
Returns the Spatial Reference System ID for this Geometry.
geom
getType
command geom.getType(X_0:int, X_1:int):str 
geoGetType;
returns the str representation of the geometry type
geom
hasM
command geom.hasM(X_0:int):int 
geoHasM;
returns 1 if the geometry has m coordinate
geom
hasZ
command geom.hasZ(X_0:int):int 
geoHasZ;
returns 1 if the geometry has z coordinate
geom
mbr
command geom.mbr(X_0:wkb):mbr 
wkbMBR;
Creates the mbr for the given wkb.
geom
mbrAbove
command geom.mbrAbove(X_0:mbr, X_1:mbr):bit 
mbrAbove;
Returns true if box1 is above box2
geom
mbrAbove
command geom.mbrAbove(X_0:wkb, X_1:wkb):bit 
mbrAbove_wkb;
Returns true if the mbr of geom1 is above the mbr of geom2
geom
mbrBelow
command geom.mbrBelow(X_0:mbr, X_1:mbr):bit 
mbrBelow;
Returns true if box1 is below box2
geom
mbrBelow
command geom.mbrBelow(X_0:wkb, X_1:wkb):bit 
mbrBelow_wkb;
Returns true if the mbr of geom1 is below the mbr of geom2
geom
mbrContained
command geom.mbrContained(X_0:mbr, X_1:mbr):bit 
mbrContained;
Returns true if box1 is contained by box2
geom
mbrContained
command geom.mbrContained(X_0:wkb, X_1:wkb):bit 
mbrContained_wkb;
Returns true if the mbr of geom1 is contained by the mbr of geom2
geom
mbrContains
command geom.mbrContains(X_0:mbr, X_1:mbr):bit 
mbrContains;
Returns true if box1 contains box2
geom
mbrContains
command geom.mbrContains(X_0:wkb, X_1:wkb):bit 
mbrContains_wkb;
Returns true if the mbr of geom1 contains the mbr of geom2
geom
mbrDistance
command geom.mbrDistance(X_0:mbr, X_1:mbr):dbl 
mbrDistance;
Returns the distance of the centroids of the two boxes
geom
mbrDistance
command geom.mbrDistance(X_0:wkb, X_1:wkb):dbl 
mbrDistance_wkb;
Returns the distance of the centroids of the mbrs of the two geometries
geom
mbrEqual
command geom.mbrEqual(X_0:mbr, X_1:mbr):bit 
mbrEqual;
Returns true if box1 is the same as box2
geom
mbrEqual
command geom.mbrEqual(X_0:wkb, X_1:wkb):bit 
mbrEqual_wkb;
Returns true if the mbr of geom1 is the same as the mbr of geom2
geom
mbrLeft
command geom.mbrLeft(X_0:mbr, X_1:mbr):bit 
mbrLeft;
Returns true if box1 is left of box2
geom
mbrLeft
command geom.mbrLeft(X_0:wkb, X_1:wkb):bit 
mbrLeft_wkb;
Returns true if the mbr of geom1 is left of the mbr of geom2
geom
mbrOverlapOrAbove
command geom.mbrOverlapOrAbove(X_0:mbr, X_1:mbr):bit 
mbrOverlapOrAbove;
Returns true if box1 overlaps or is above box2
geom
mbrOverlapOrAbove
command geom.mbrOverlapOrAbove(X_0:wkb, X_1:wkb):bit 
mbrOverlapOrAbove_wkb;
Returns true if the mbr of geom1 overlaps or is above the mbr of geom2
geom
mbrOverlapOrBelow
command geom.mbrOverlapOrBelow(X_0:mbr, X_1:mbr):bit 
mbrOverlapOrBelow;
Returns true if box1 overlaps or is below box2
geom
mbrOverlapOrBelow
command geom.mbrOverlapOrBelow(X_0:wkb, X_1:wkb):bit 
mbrOverlapOrBelow_wkb;
Returns true if the mbr of geom1 overlaps or is below the mbr of geom2
geom
mbrOverlapOrLeft
command geom.mbrOverlapOrLeft(X_0:mbr, X_1:mbr):bit 
mbrOverlapOrLeft;
Returns true if box1 overlaps or is to the left of box2
geom
mbrOverlapOrLeft
command geom.mbrOverlapOrLeft(X_0:wkb, X_1:wkb):bit 
mbrOverlapOrLeft_wkb;
Returns true if the mbr of geom1 overlaps or is to the left of thr mbr of geom2
geom
mbrOverlapOrRight
command geom.mbrOverlapOrRight(X_0:mbr, X_1:mbr):bit 
mbrOverlapOrRight;
Returns true if box1 overlalps or is right of box2
geom
mbrOverlapOrRight
command geom.mbrOverlapOrRight(X_0:wkb, X_1:wkb):bit 
mbrOverlapOrRight_wkb;
Returns true if the mbr of geom1 overlalps or is right of the mbr of geom2
geom
mbrOverlaps
command geom.mbrOverlaps(X_0:mbr, X_1:mbr):bit 
mbrOverlaps;
Returns true if box1 overlaps box2
geom
mbrOverlaps
command geom.mbrOverlaps(X_0:wkb, X_1:wkb):bit 
mbrOverlaps_wkb;
Returns true if the mbr of geom1 overlaps the mbr of geom2
geom
mbrRight
command geom.mbrRight(X_0:mbr, X_1:mbr):bit 
mbrRight;
Returns true if box1 is right of box2
geom
mbrRight
command geom.mbrRight(X_0:wkb, X_1:wkb):bit 
mbrRight_wkb;
Returns true if the mbr of geom1 is right of the mbr of geom2
geom
prelude
command geom.prelude():void 
geom_prelude;
(empty)
geom
setSRID
command geom.setSRID(X_0:wkb, X_1:int):wkb 
wkbSetSRID;
Sets the Reference System ID for this Geometry.
group
group
command group.group(X_0:bat[:any_1]):bat[:oid] 
GRPgroup11;
(empty)
group
group
command group.group(X_0:bat[:any_1]) (X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:lng]) 
GRPgroup1;
(empty)
group
group
command group.group(X_0:bat[:any_1], X_1:bat[:oid]):bat[:oid] 
GRPgroup21;
(empty)
group
group
command group.group(X_0:bat[:any_1], X_1:bat[:oid]) (X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:lng]) 
GRPgroup2;
(empty)
group
group
command group.group(X_0:bat[:any_1]) (X_1:bat[:oid], X_2:bat[:oid]) 
GRPgroup3;
(empty)
group
group
command group.group(X_0:bat[:any_1], X_1:bat[:oid]) (X_2:bat[:oid], X_3:bat[:oid]) 
GRPgroup4;
(empty)
group
groupdone
command group.groupdone(X_0:bat[:any_1]):bat[:oid] 
GRPgroup11;
(empty)
group
groupdone
command group.groupdone(X_0:bat[:any_1]) (X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:lng]) 
GRPgroup1;
(empty)
group
groupdone
command group.groupdone(X_0:bat[:any_1], X_1:bat[:oid]):bat[:oid] 
GRPgroup21;
(empty)
group
groupdone
command group.groupdone(X_0:bat[:any_1], X_1:bat[:oid]) (X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:lng]) 
GRPgroup2;
(empty)
group
groupdone
command group.groupdone(X_0:bat[:any_1]) (X_1:bat[:oid], X_2:bat[:oid]) 
GRPgroup3;
(empty)
group
groupdone
command group.groupdone(X_0:bat[:any_1], X_1:bat[:oid]) (X_2:bat[:oid], X_3:bat[:oid]) 
GRPgroup4;
(empty)
group
multicolumn
pattern group.multicolumn(X_0:bat[:any]...) (X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:any]) 
GROUPmulticolumngroup;
Derivation of a group index over multiple columns.
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid]):bat[:oid] 
GRPsubgroup21;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid]) (X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:lng]) 
GRPsubgroup2;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid]):bat[:oid] 
GRPsubgroup31;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid]) (X_3:bat[:oid], X_4:bat[:oid], X_5:bat[:lng]) 
GRPsubgroup3;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:lng]):bat[:oid] 
GRPsubgroup41;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:lng]) (X_4:bat[:oid], X_5:bat[:oid], X_6:bat[:lng]) 
GRPsubgroup4;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:lng]):bat[:oid] 
GRPsubgroup51;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:lng]) (X_5:bat[:oid], X_6:bat[:oid], X_7:bat[:lng]) 
GRPsubgroup5;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid]) (X_2:bat[:oid], X_3:bat[:oid]) 
GRPsubgroup6;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid]) (X_3:bat[:oid], X_4:bat[:oid]) 
GRPsubgroup7;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:lng]) (X_4:bat[:oid], X_5:bat[:oid]) 
GRPsubgroup8;
(empty)
group
subgroup
command group.subgroup(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:lng]) (X_5:bat[:oid], X_6:bat[:oid]) 
GRPsubgroup9;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid]):bat[:oid] 
GRPsubgroup21;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid]) (X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:lng]) 
GRPsubgroup2;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid]):bat[:oid] 
GRPsubgroup31;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid]) (X_3:bat[:oid], X_4:bat[:oid], X_5:bat[:lng]) 
GRPsubgroup3;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:lng]):bat[:oid] 
GRPsubgroup41;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:lng]) (X_4:bat[:oid], X_5:bat[:oid], X_6:bat[:lng]) 
GRPsubgroup4;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:lng]):bat[:oid] 
GRPsubgroup51;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:lng]) (X_5:bat[:oid], X_6:bat[:oid], X_7:bat[:lng]) 
GRPsubgroup5;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid]) (X_2:bat[:oid], X_3:bat[:oid]) 
GRPsubgroup6;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid]) (X_3:bat[:oid], X_4:bat[:oid]) 
GRPsubgroup7;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:lng]) (X_4:bat[:oid], X_5:bat[:oid]) 
GRPsubgroup8;
(empty)
group
subgroupdone
command group.subgroupdone(X_0:bat[:any_1], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid], X_4:bat[:lng]) (X_5:bat[:oid], X_6:bat[:oid]) 
GRPsubgroup9;
(empty)
identifier
identifier
command identifier.identifier(X_0:str):identifier 
IDentifier;
Cast a string to an identifer 
identifier
prelude
command identifier.prelude():void 
IDprelude;
Initialize the module
inet
!=
command inet.!=(X_0:inet, X_1:inet):bit 
INET_comp_NEQ;
Inequality of two inets
inet
<
command inet.<(X_0:inet, X_1:inet):bit 
INET_comp_LT;
Whether v is less than w
inet
<<
command inet.<<(X_0:inet, X_1:inet):bit 
INET_comp_CW;
Whether v is contained within w
inet
<<=
command inet.<<=(X_0:inet, X_1:inet):bit 
INET_comp_CWE;
Whether v is contained within or is equal to w
inet
<=
command inet.<=(X_0:inet, X_1:inet):bit 
INET_comp_LE;
Whether v is less than or equal to w
inet
=
command inet.=(X_0:inet, X_1:inet):bit 
INET_comp_EQ;
Equality of two inets
inet
>
command inet.>(X_0:inet, X_1:inet):bit 
INET_comp_GT;
Whether v is greater than w
inet
>=
command inet.>=(X_0:inet, X_1:inet):bit 
INET_comp_GE;
Whether v is equal to or greater than w
inet
>>
command inet.>>(X_0:inet, X_1:inet):bit 
INET_comp_CS;
Whether v contains w
inet
>>=
command inet.>>=(X_0:inet, X_1:inet):bit 
INET_comp_CSE;
Whether v contains or is equal to w
inet
abbrev
command inet.abbrev(X_0:inet):str 
INETabbrev;
Abbreviated display format as text
inet
broadcast
command inet.broadcast(X_0:inet):inet 
INETbroadcast;
Returns the broadcast address for network
inet
host
command inet.host(X_0:inet):str 
INEThost;
Extract IP address as text
inet
hostmask
command inet.hostmask(X_0:inet):inet 
INEThostmask;
Construct host mask for network
inet
isnil
command inet.isnil(X_0:inet):bit 
INET_isnil;
Nil test for inet value
inet
masklen
command inet.masklen(X_0:inet):int 
INETmasklen;
Extract netmask length
inet
netmask
command inet.netmask(X_0:inet):inet 
INETnetmask;
Construct netmask for network
inet
network
command inet.network(X_0:inet):inet 
INETnetwork;
Extract network part of address
inet
new
command inet.new(X_0:str):inet 
INETnew;
Create an inet from a string literal
inet
setmasklen
command inet.setmasklen(X_0:inet, X_1:int):inet 
INETsetmasklen;
Set netmask length for inet value
inet
text
command inet.text(X_0:inet):str 
INETtext;
Extract IP address and netmask length as text
inspect
equalType
pattern inspect.equalType(X_0:any, X_1:any):bit 
INSPECTequalType;
Return true if both operands are of the same type
inspect
getAtomNames
command inspect.getAtomNames():bat[:str] 
INSPECTatom_names;
Collect a BAT with the atom names.
inspect
getAtomSizes
command inspect.getAtomSizes():bat[:int] 
INSPECTatom_sizes;
Collect a BAT with the atom sizes.
inspect
getAtomSuper
command inspect.getAtomSuper():bat[:str] 
INSPECTatom_sup_names;
Collect a BAT with the atom names.
inspect
getComment
pattern inspect.getComment(X_0:str, X_1:str):bat[:str] 
INSPECTgetComment;
Returns the function help information.
inspect
getDefinition
pattern inspect.getDefinition(X_0:str, X_1:str):bat[:str] 
INSPECTgetDefinition;
Returns a string representation of a specific function.
inspect
getEnvironment
command inspect.getEnvironment() (X_0:bat[:str], X_1:bat[:str]) 
INSPECTgetEnvironment;
Collect the environment variables.
inspect
getEnvironment
command inspect.getEnvironment(X_0:str):str 
INSPECTgetEnvironmentKey;
Get the value of an environemnt variable
inspect
getExistence
pattern inspect.getExistence(X_0:str, X_1:str):bit 
INSPECTgetExistence;
Returns a boolean indicating existence of a definition of a specific function.
inspect
getFunction
pattern inspect.getFunction():bat[:str] 
INSPECTgetAllFunctions;
Obtain the function name.
inspect
getKind
pattern inspect.getKind():bat[:str] 
INSPECTgetkind;
Obtain the instruction kind.
inspect
getModule
pattern inspect.getModule():bat[:str] 
INSPECTgetAllModules;
Obtain the function name.
inspect
getSignature
pattern inspect.getSignature(X_0:str, X_1:str):bat[:str] 
INSPECTgetSignature;
Returns the function signature(s).
inspect
getSignatures
pattern inspect.getSignatures():bat[:str] 
INSPECTgetAllSignatures;
Obtain the function signatures.
inspect
getSize
pattern inspect.getSize(X_0:str, X_1:str):lng 
INSPECTgetFunctionSize;
Return the storage size for a function (in bytes).
inspect
getSize
pattern inspect.getSize():lng 
INSPECTgetSize;
Return the storage size for the current function (in bytes).
inspect
getSource
pattern inspect.getSource(X_0:str, X_1:str):str 
INSPECTgetSource;
Return the original input for a function.
inspect
getType
pattern inspect.getType(X_0:any_1):str 
INSPECTtypeName;
Return the concrete type of a variable (expression).
inspect
optimizer_stats
pattern inspect.optimizer_stats() (X_0:bat[:str], X_1:bat[:int], X_2:bat[:lng]) 
OPTstatistics;
Get optimizer use statistics, i.e. calls and total time
io
export
command io.export(X_0:bat[:any_2], X_1:str):void 
IOexport;
Export a BAT as ASCII to a file. If the 'filepath' is not absolute, it@is put into the $DBPATH directory. Success of failure is indicated.
io
import
command io.import(X_0:bat[:any_2], X_1:str):void 
IOimport;
Import a BAT from an ASCII dump. The tuples are appended to the@first argument. Its signature must match the dump,@else parsing errors will occur as an exception.
io
print
pattern io.print(X_0:any_1):void 
IOprint_val;
Print a MAL value.
io
print
pattern io.print(X_0:any_1, X_1:any...):void 
IOprint_val;
Print a MAL value tuple .
io
print
pattern io.print(X_0:bat[:any_1]):void 
IOprint_val;
Print a MAL value column .
io
print
pattern io.print(X_0:bat[:any]...):void 
IOtable;
BATs are printed with '#' for legend @lines, and the BUNs on seperate lines @between brackets, containing each to @comma separated values (head and tail). @If multiple BATs are passed for printing, @print() performs an implicit natural @join on the void head, producing a multi attribute table.
io
printf
pattern io.printf(X_0:str):void 
IOprintf;
Select default format 
io
printf
pattern io.printf(X_0:str, X_1:any...):void 
IOprintf;
Select default format 
io
printf
pattern io.printf(X_0:streams, X_1:str):void 
IOprintfStream;
Select default format 
io
printf
pattern io.printf(X_0:streams, X_1:str, X_2:any...):void 
IOprintfStream;
Select default format 
io
setmallocsuccesscount
command io.setmallocsuccesscount(X_0:lng):void 
IOsetmallocsuccesscount;
Set number of mallocs that are allowed to succeed.
io
stdin
pattern io.stdin():bstream 
io_stdin;
return the input stream to the database client
io
stdout
pattern io.stdout():streams 
io_stdout;
return the output stream for the database client
iterator
new
pattern iterator.new(X_0:bat[:any_2]) (X_1:oid, X_2:any_2) 
ITRbunIterator;
Process the buns one by one extracted from a void table.
iterator
new
command iterator.new(X_0:bat[:any_2], X_1:lng) (X_2:lng, X_3:bat[:any_2]) 
ITRnewChunk;
Create an iterator with fixed granule size.@The result is a view.
iterator
next
pattern iterator.next(X_0:bat[:any_2]) (X_1:oid, X_2:any_2) 
ITRbunNext;
Produce the next bun for processing.
iterator
next
command iterator.next(X_0:bat[:any_2], X_1:lng) (X_2:lng, X_3:bat[:any_2]) 
ITRnextChunk;
Produce the next chunk for processing.
iterator
next
command iterator.next(X_0:dbl, X_1:dbl):dbl 
ITRnext_dbl;
Advances the iterator with a fixed value
iterator
next
command iterator.next(X_0:flt, X_1:flt):flt 
ITRnext_flt;
(empty)
iterator
next
command iterator.next(X_0:int, X_1:int):int 
ITRnext_int;
(empty)
iterator
next
command iterator.next(X_0:lng, X_1:lng):lng 
ITRnext_lng;
(empty)
iterator
next
command iterator.next(X_0:oid, X_1:oid):oid 
ITRnext_oid;
(empty)
iterator
next
command iterator.next(X_0:sht, X_1:sht):sht 
ITRnext_sht;
(empty)
json
dump
pattern json.dump(X_0:json):bat[:str] 
JSONdump;
(empty)
json
filter
command json.filter(X_0:json, X_1:str):json 
JSONfilter;
Filter all members of an object by a path expression, returning an array.@Non-matching elements are skipped.
json
filter
command json.filter(X_0:json, X_1:bte, X_2:str):json 
JSONfilterArrayDefault_bte;
(empty)
json
filter
command json.filter(X_0:json, X_1:int, X_2:str):json 
JSONfilterArrayDefault_int;
(empty)
json
filter
command json.filter(X_0:json, X_1:lng, X_2:str):json 
JSONfilterArrayDefault_lng;
Extract a single array element
json
filter
command json.filter(X_0:json, X_1:sht, X_2:str):json 
JSONfilterArrayDefault_sht;
(empty)
json
filter
command json.filter(X_0:json, X_1:bte):json 
JSONfilterArray_bte;
(empty)
json
filter
command json.filter(X_0:json, X_1:int):json 
JSONfilterArray_int;
(empty)
json
filter
command json.filter(X_0:json, X_1:lng):json 
JSONfilterArray_lng;
(empty)
json
filter
command json.filter(X_0:json, X_1:sht):json 
JSONfilterArray_sht;
(empty)
json
fold
pattern json.fold(X_0:bat[:any]):json 
JSONfold;
Combine the value list into a single json array object.
json
fold
pattern json.fold(X_0:bat[:oid], X_1:bat[:str], X_2:bat[:any]):json 
JSONfold;
Combine the key-value pairs into a single json object list.
json
fold
pattern json.fold(X_0:bat[:str], X_1:bat[:any]):json 
JSONfold;
Combine the key-value pairs into a single json object list.
json
integer
command json.integer(X_0:json):lng 
JSONjson2integer;
Convert simple JSON values to an integer, return nil upon error.
json
isarray
command json.isarray(X_0:json):bit 
JSONisarray;
Validate the string as a valid JSON array
json
isobject
command json.isobject(X_0:json):bit 
JSONisobject;
Validate the string as a valid JSON object
json
isvalid
command json.isvalid(X_0:str):bit 
JSONisvalid;
Validate the string as a valid JSON document
json
keyarray
command json.keyarray(X_0:json):json 
JSONkeyArray;
Expands the outermost JSON object keys into a JSON value array.
json
keys
command json.keys(X_0:json):bat[:str] 
JSONkeyTable;
Expands the outermost JSON object names.
json
length
command json.length(X_0:json):int 
JSONlength;
Returns the number of elements in the outermost JSON object.
json
new
command json.new(X_0:str):json 
JSONstr2json;
Convert string to its JSON. Dealing with escape characters
json
number
command json.number(X_0:json):dbl 
JSONjson2number;
Convert simple JSON values to a double, return nil upon error.
json
prelude
command json.prelude():void 
JSONprelude;
(empty)
json
renderarray
pattern json.renderarray(X_0:any...):json 
JSONrenderarray;
(empty)
json
renderobject
pattern json.renderobject(X_0:any...):json 
JSONrenderobject;
(empty)
json
resultSet
command json.resultSet(X_0:bat[:uuid], X_1:bat[:lng], X_2:bat[:json]):json 
JSONresultSet;
Converts the json store into a single json string:
json
str
command json.str(X_0:json):str 
JSONjson2str;
Convert JSON to its string equivalent. Dealing with escape characters
json
text
command json.text(X_0:json):str 
JSONjson2text;
Convert JSON values to their plain string equivalent.
json
text
command json.text(X_0:json, X_1:str):str 
JSONjson2textSeparator;
Convert JSON values to their plain string equivalent, injecting a separator.
json
unfold
pattern json.unfold(X_0:json) (X_1:bat[:oid], X_2:bat[:str], X_3:bat[:json]) 
JSONunfold;
Expands the outermost JSON object into key-value pairs.
json
unfold
pattern json.unfold(X_0:json) (X_1:bat[:str], X_2:bat[:json]) 
JSONunfold;
Expands the outermost JSON object into key-value pairs.
json
valuearray
command json.valuearray(X_0:json):json 
JSONvalueArray;
Expands the outermost JSON object values into a JSON value array.
json
values
command json.values(X_0:json):bat[:json] 
JSONvalueTable;
Expands the outermost JSON values.
language
assert
unsafe command language.assert(X_0:bit, X_1:str):void 
MALassertBit;
(empty)
language
assert
unsafe command language.assert(X_0:int, X_1:str):void 
MALassertInt;
(empty)
language
assert
unsafe command language.assert(X_0:lng, X_1:str):void 
MALassertLng;
(empty)
language
assert
unsafe command language.assert(X_0:oid, X_1:str):void 
MALassertOid;
(empty)
language
assert
unsafe command language.assert(X_0:sht, X_1:str):void 
MALassertSht;
(empty)
language
assert
unsafe command language.assert(X_0:str, X_1:str):void 
MALassertStr;
(empty)
language
assert
unsafe pattern language.assert(X_0:any_1, X_1:str, X_2:str, X_3:any_2):void 
MALassertTriple;
Assertion test.
language
block
pattern language.block(X_0:int, X_1:any...):int 
deblockdataflow;
Block on availability of all variables w, and then pass on v
language
call
pattern language.call(X_0:bat[:str]):void 
CMDcallBAT;
Evaluate a program stored in a BAT.
language
call
pattern language.call(X_0:str, X_1:str):void 
CMDcallFunction;
(empty)
language
call
pattern language.call(X_0:str):void 
CMDcallString;
Evaluate a MAL string program.
language
dataflow
pattern language.dataflow():bit 
MALstartDataflow;
The current guarded block is executed using dataflow control. 
language
pass
pattern language.pass(X_0:any_1):void 
MALpass;
Cheap instruction to disgard storage while retaining the dataflow dependency
language
raise
unsafe command language.raise(X_0:str):str 
CMDraise;
Raise an exception labeled @with a specific message.
language
register
pattern language.register(X_0:str, X_1:str, X_2:str, X_3:str):void 
CMDregisterFunction;
Compile the code string to MAL and register it as a function.
language
sink
pattern language.sink(X_0:any...):void 
MALgarbagesink;
Variables to be considered together when triggering garbage collection.@Used in the dataflow blocks to avoid early release of values.
language
source
pattern language.source(X_0:str):void 
CMDevalFile;
Merge the instructions stored in the file with the current program.
logging
compinfo
pattern logging.compinfo() (X_0:bat[:int], X_1:bat[:str], X_2:bat[:str]) 
TRACERcomp_info;
Returns in the form of a SQL result-set all the components along with their ID@and the their current logging level being set
logging
flush
unsafe command logging.flush():void 
TRACERflush_buffer;
Flush the buffer
logging
resetadapter
unsafe command logging.resetadapter():void 
TRACERreset_adapter;
Resets the adapter back to the default
logging
resetcomplevel
unsafe command logging.resetcomplevel(X_0:str):void 
TRACERreset_component_level;
Resets the log level for a specific component back to the default
logging
resetflushlevel
unsafe command logging.resetflushlevel():void 
TRACERreset_flush_level;
Resets the flush level back to the default
logging
resetlayerlevel
unsafe command logging.resetlayerlevel(X_0:str):void 
TRACERreset_layer_level;
Resets the log level for a specific layer back to the default
logging
setadapter
unsafe command logging.setadapter(X_0:str):void 
TRACERset_adapter;
Sets the adapter
logging
setcomplevel
unsafe command logging.setcomplevel(X_0:str, X_1:str):void 
TRACERset_component_level;
Sets the log level for a specific component
logging
setflushlevel
unsafe command logging.setflushlevel(X_0:str):void 
TRACERset_flush_level;
Sets the flush level
logging
setlayerlevel
unsafe command logging.setlayerlevel(X_0:str, X_1:str):void 
TRACERset_layer_level;
Sets the log level for a specific layer
mal
manifold
pattern mal.manifold(X_0:str, X_1:str, X_2:any...):bat[:any] 
MANIFOLDevaluate;
(empty)
mal
multiplex
pattern mal.multiplex(X_0:lng, X_1:str, X_2:str):any... 
MANIFOLDremapMultiplex;
(empty)
mal
multiplex
pattern mal.multiplex(X_0:lng, X_1:str, X_2:str, X_3:any...):any... 
MANIFOLDremapMultiplex;
(empty)
mal
multiplex
pattern mal.multiplex(X_0:str, X_1:str, X_2:any...):any... 
MANIFOLDremapMultiplex;
(empty)
manual
functions
pattern manual.functions() (X_0:bat[:str], X_1:bat[:str], X_2:bat[:str], X_3:bat[:str], X_4:bat[:str]) 
MANUALcreateOverview;
Produces a table with all MAL functions known
mapi
bind
pattern mapi.bind(X_0:int, X_1:str):bat[:any_2] 
SERVERbindBAT;
Bind a remote variable to a local one.
mapi
bind
pattern mapi.bind(X_0:int, X_1:str, X_2:str, X_3:int):bat[:any_2] 
SERVERbindBAT;
Bind a remote variable to a local one.
mapi
bind
pattern mapi.bind(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int):bat[:any_2] 
SERVERbindBAT;
Bind a remote variable to a local one.
mapi
connect
pattern mapi.connect(X_0:str, X_1:int, X_2:str, X_3:str, X_4:str):int 
SERVERconnect;
Establish connection with a remote mserver.
mapi
destroy
command mapi.destroy(X_0:int):void 
SERVERdestroy;
Destroy the handle for an Mserver.
mapi
disconnect
command mapi.disconnect(X_0:int):void 
SERVERdisconnect;
Terminate the session.
mapi
disconnect
command mapi.disconnect():int 
SERVERdisconnectALL;
Close connections with all remote Mserver.
mapi
disconnect
command mapi.disconnect(X_0:str):int 
SERVERdisconnectWithAlias;
Close connection with a remote Mserver.
mapi
error
command mapi.error(X_0:int):int 
SERVERerror;
Check for an error in the communication.
mapi
explain
command mapi.explain(X_0:int):str 
SERVERexplain;
Turn the error seen into a string.
mapi
fetch_all_rows
command mapi.fetch_all_rows(X_0:int):lng 
SERVERfetch_all_rows;
Retrieve all rows into the cache.
mapi
fetch_field
command mapi.fetch_field(X_0:int, X_1:int):bte 
SERVERfetch_field_bte;
Retrieve a single bte field.
mapi
fetch_field
command mapi.fetch_field(X_0:int, X_1:int):int 
SERVERfetch_field_int;
Retrieve a single int field.
mapi
fetch_field
command mapi.fetch_field(X_0:int, X_1:int):lng 
SERVERfetch_field_lng;
Retrieve a single lng field.
mapi
fetch_field
command mapi.fetch_field(X_0:int, X_1:int):oid 
SERVERfetch_field_oid;
Retrieve a single void field.
mapi
fetch_field
command mapi.fetch_field(X_0:int, X_1:int):sht 
SERVERfetch_field_sht;
Retrieve a single sht field.
mapi
fetch_field
command mapi.fetch_field(X_0:int, X_1:int):str 
SERVERfetch_field_str;
Retrieve a single field.
mapi
fetch_field
command mapi.fetch_field(X_0:int, X_1:int):void 
SERVERfetch_field_void;
Retrieve a single void field.
mapi
fetch_field_array
command mapi.fetch_field_array(X_0:int):bat[:str] 
SERVERfetch_field_bat;
Retrieve all fields for a row.
mapi
fetch_line
command mapi.fetch_line(X_0:int):str 
SERVERfetch_line;
Retrieve a complete line.
mapi
fetch_reset
command mapi.fetch_reset(X_0:int):int 
SERVERfetch_reset;
Reset the cache read line.
mapi
fetch_row
command mapi.fetch_row(X_0:int):int 
SERVERfetch_row;
Retrieve the next row for analysis.
mapi
finish
command mapi.finish(X_0:int):int 
SERVERfinish;
Remove all remaining answers.
mapi
getError
command mapi.getError(X_0:int):str 
SERVERgetError;
Get error message.
mapi
get_field_count
command mapi.get_field_count(X_0:int):int 
SERVERget_field_count;
Return number of fields.
mapi
get_row_count
command mapi.get_row_count(X_0:int):lng 
SERVERget_row_count;
Return number of rows.
mapi
listen
command mapi.listen():int 
SERVERlisten_default;
Start a Mapi server with the default settings.
mapi
listen
command mapi.listen(X_0:int):int 
SERVERlisten_port;
Start a Mapi listener on the port given.
mapi
listen
command mapi.listen(X_0:str):int 
SERVERlisten_usock;
Start a Mapi listener on the unix socket file given.
mapi
lookup
command mapi.lookup(X_0:str):int 
SERVERlookup;
Retrieve the connection identifier.
mapi
malclient
command mapi.malclient(X_0:streams, X_1:streams):void 
SERVERclient;
Start a Mapi client for a particular stream pair.
mapi
next_result
command mapi.next_result(X_0:int):int 
SERVERnext_result;
Go to next result set.
mapi
ping
command mapi.ping(X_0:int):int 
SERVERping;
Test availability of an Mserver.
mapi
prelude
command mapi.prelude():int 
SERVERlisten_default;
(empty)
mapi
prepare
command mapi.prepare(X_0:int, X_1:str):int 
SERVERprepare;
Prepare a query for execution.
mapi
put
pattern mapi.put(X_0:int, X_1:str, X_2:any_1):void 
SERVERput;
Send a value to a remote site.
mapi
put
pattern mapi.put(X_0:str, X_1:any_1):str 
SERVERputLocal;
Prepare sending a value to a remote site.
mapi
query
command mapi.query(X_0:int, X_1:str):int 
SERVERquery;
Send the query for execution
mapi
query_array
pattern mapi.query_array(X_0:int, X_1:str, X_2:str...):int 
SERVERquery_array;
Send the query for execution replacing '?' by arguments.
mapi
query_handle
command mapi.query_handle(X_0:int, X_1:str):int 
SERVERquery_handle;
Send the query for execution.
mapi
reconnect
command mapi.reconnect(X_0:int):void 
SERVERreconnect;
Re-establish a connection.
mapi
reconnect
pattern mapi.reconnect(X_0:str, X_1:int, X_2:str, X_3:str, X_4:str, X_5:str):int 
SERVERreconnectAlias;
Re-establish connection with a remote mserver.
mapi
reconnect
pattern mapi.reconnect(X_0:str, X_1:int, X_2:str, X_3:str, X_4:str):int 
SERVERreconnectWithoutAlias;
Re-establish connection with a remote mserver.
mapi
resume
command mapi.resume():void 
SERVERresume;
Resume connection listeners.
mapi
rows_affected
command mapi.rows_affected(X_0:int):lng 
SERVERrows_affected;
Return number of affected rows.
mapi
rpc
pattern mapi.rpc(X_0:int, X_1:str):bat[:any_2] 
SERVERmapi_rpc_bat;
(empty)
mapi
rpc
pattern mapi.rpc(X_0:int, X_1:str...):any 
SERVERmapi_rpc_single_row;
Send a simple query for execution and fetch result.
mapi
rpc
command mapi.rpc(X_0:int, X_1:str):int 
SERVERquery;
Send a simple query for execution.
mapi
setAlias
command mapi.setAlias(X_0:int, X_1:str):void 
SERVERsetAlias;
Give the channel a logical name.
mapi
stop
command mapi.stop():void 
SERVERstop;
Terminate connection listeners.
mapi
suspend
command mapi.suspend():void 
SERVERsuspend;
Suspend accepting connections.
mapi
trace
command mapi.trace(X_0:int, X_1:int):void 
SERVERtrace;
Toggle the Mapi library debug tracer.
mask
mask
pattern mask.mask(X_0:bat[:oid]):bat[:msk] 
MSKmask;
(empty)
mask
umask
pattern mask.umask(X_0:bat[:msk]):bat[:oid] 
MSKumask;
(empty)
mat
new
pattern mat.new(X_0:bat[:any_2]...):bat[:any_2] 
MATpack;
Define a Merge Association Table (MAT). Fall back to the pack operation@when this is called 
mat
pack
pattern mat.pack(X_0:bat[:any_2]...):bat[:any_2] 
MATpack;
Materialize the MAT into a BAT
mat
pack
pattern mat.pack(X_0:any_2...):bat[:any_2] 
MATpackValues;
Materialize the MAT (of values) into a BAT
mat
packIncrement
pattern mat.packIncrement(X_0:bat[:any_2], X_1:bat[:any_2]):bat[:any_2] 
MATpackIncrement;
Prepare incremental mat pack
mat
packIncrement
pattern mat.packIncrement(X_0:bat[:any_2], X_1:int):bat[:any_2] 
MATpackIncrement;
Prepare incremental mat pack
mdb
List
pattern mdb.List(X_0:str, X_1:str):void 
MDBlist3Detail;
Dump the routine M.F on standard out.
mdb
List
pattern mdb.List():void 
MDBlistDetail;
Dump the current routine on standard out.
mdb
dump
pattern mdb.dump():void 
MDBdump;
Dump instruction, stacktrace, and stack
mdb
getContext
command mdb.getContext(X_0:str):str 
MDBgetExceptionContext;
Extract the context string from the exception message
mdb
getDebug
pattern mdb.getDebug():int 
MDBgetDebug;
Get the kernel debugging bit-set.@See the MonetDB configuration file for details
mdb
getDebugFlags
pattern mdb.getDebugFlags() (X_0:bat[:str], X_1:bat[:bit]) 
MDBgetDebugFlags;
Get the kernel debugging flags bit-set
mdb
getDefinition
pattern mdb.getDefinition():bat[:str] 
MDBgetDefinition;
Returns a string representation of the current function @with typing information attached
mdb
getException
command mdb.getException(X_0:str):str 
MDBgetExceptionVariable;
Extract the variable name from the exception message
mdb
getReason
command mdb.getReason(X_0:str):str 
MDBgetExceptionReason;
Extract the reason from the exception message
mdb
getStackDepth
pattern mdb.getStackDepth():int 
MDBStkDepth;
Return the depth of the calling stack.
mdb
getStackFrame
pattern mdb.getStackFrame() (X_0:bat[:str], X_1:bat[:str]) 
MDBgetStackFrame;
Collect variable binding of current (n-th) stack frame.
mdb
getStackFrame
pattern mdb.getStackFrame(X_0:int) (X_1:bat[:str], X_2:bat[:str]) 
MDBgetStackFrameN;
(empty)
mdb
getStackTrace
pattern mdb.getStackTrace() (X_0:bat[:int], X_1:bat[:str]) 
MDBStkTrace;
(empty)
mdb
getVMsize
pattern mdb.getVMsize():lng 
MDBgetVMsize;
Retrieve the max VM size
mdb
inspect
pattern mdb.inspect(X_0:str, X_1:str):void 
MDBinspect;
Run the debugger on a specific function
mdb
list
pattern mdb.list(X_0:str, X_1:str):void 
MDBlist3;
Dump the routine M.F on standard out.
mdb
list
pattern mdb.list():void 
MDBlist;
Dump the current routine on standard out.
mdb
listMapi
pattern mdb.listMapi():void 
MDBlistMapi;
Dump the current routine on standard out with Mapi prefix.
mdb
modules
command mdb.modules():bat[:str] 
CMDmodules;
List available modules
mdb
setCatch
pattern mdb.setCatch(X_0:bit):void 
MDBsetCatch;
Turn on/off catching exceptions
mdb
setDebug
pattern mdb.setDebug(X_0:int):int 
MDBsetDebug;
Set the kernel debugging bit-set and return its previous value.
mdb
setDebug
pattern mdb.setDebug(X_0:str):int 
MDBsetDebugStr;
Set the kernel debugging bit-set and return its previous value.@The recognized options are: threads, memory, properties,@io, transactions, modules, algorithms, estimates.
mdb
setTrace
pattern mdb.setTrace(X_0:bit):void 
MDBsetTrace;
Turn on/off tracing of current routine
mdb
setTrace
pattern mdb.setTrace(X_0:str):void 
MDBsetVarTrace;
Turn on/off tracing of a variable 
mdb
setVMsize
pattern mdb.setVMsize(X_0:lng):lng 
MDBsetVMsize;
Manipulate the VM max size in MBs
mdb
start
pattern mdb.start():void 
MDBstart;
Start interactive debugger
mdb
start
pattern mdb.start(X_0:int):void 
MDBstart;
Start interactive debugger on a client
mdb
start
pattern mdb.start(X_0:str, X_1:str):void 
MDBstartFactory;
Start interactive debugger on a running factory
mdb
stop
pattern mdb.stop():void 
MDBstop;
Stop the interactive debugger
mdb
var
pattern mdb.var(X_0:str, X_1:str):void 
MDBvar3;
Dump the symboltable of routine M.F on standard out.
mdb
var
pattern mdb.var():void 
MDBvar;
Dump the symboltable of current routine on standard out.
mkey
bulk_rotate_xor_hash
command mkey.bulk_rotate_xor_hash(X_0:bat[:lng], X_1:int, X_2:bat[:any_1]):bat[:lng] 
MKEYbulk_rotate_xor_hash;
pre:  h and b should be synced on head@post: [:xor=]([:rotate=](h, nbits), [hash](b))
mkey
bulk_rotate_xor_hash
pattern mkey.bulk_rotate_xor_hash(X_0:bat[:lng], X_1:int, X_2:any):bat[:lng] 
MKEYbulkconst_rotate_xor_hash;
pre:  h and b should be synced on head@post: [:xor=]([:rotate=](h, nbits), [hash](b))
mkey
bulk_rotate_xor_hash
command mkey.bulk_rotate_xor_hash(X_0:lng, X_1:int, X_2:bat[:any_1]):bat[:lng] 
MKEYconstbulk_rotate_xor_hash;
pre:  h and b should be synced on head@post: [:xor=]([:rotate=](h, nbits), [hash](b))
mkey
bulk_rotate_xor_hash
pattern mkey.bulk_rotate_xor_hash(X_0:lng, X_1:int, X_2:any):lng 
MKEYrotate_xor_hash;
post: [:xor=]([:rotate=](h, nbits), [hash](b))
mkey
hash
pattern mkey.hash(X_0:any):lng 
MKEYhash;
calculate a hash value
mkey
hash
pattern mkey.hash(X_0:bit):lng 
MKEYhash;
calculate a hash value
mkey
hash
pattern mkey.hash(X_0:bte):lng 
MKEYhash;
calculate a hash value
mkey
hash
pattern mkey.hash(X_0:dbl):lng 
MKEYhash;
calculate a hash value
mkey
hash
pattern mkey.hash(X_0:flt):lng 
MKEYhash;
calculate a hash value
mkey
hash
pattern mkey.hash(X_0:int):lng 
MKEYhash;
calculate a hash value
mkey
hash
pattern mkey.hash(X_0:lng):lng 
MKEYhash;
calculate a hash value
mkey
hash
pattern mkey.hash(X_0:sht):lng 
MKEYhash;
calculate a hash value
mkey
hash
pattern mkey.hash(X_0:str):lng 
MKEYhash;
calculate a hash value
mkey
rotate
command mkey.rotate(X_0:lng, X_1:int):lng 
MKEYrotate;
left-rotate an int by nbits
mmath
acos
command mmath.acos(X_0:dbl):dbl 
MATHunary_ACOSdbl;
The acos(x) function calculates the arc cosine of x, that is the @value whose cosine is x. The value is returned in radians and is @mathematically defined to be between 0 and PI (inclusive).
mmath
acos
command mmath.acos(X_0:flt):flt 
MATHunary_ACOSflt;
(empty)
mmath
asin
command mmath.asin(X_0:dbl):dbl 
MATHunary_ASINdbl;
The asin(x) function calculates the arc sine of x, that is the value @whose sine is x. The value is returned in radians and is mathematically @defined to be between -PI/20 and -PI/2 (inclusive).
mmath
asin
command mmath.asin(X_0:flt):flt 
MATHunary_ASINflt;
(empty)
mmath
atan
command mmath.atan(X_0:dbl):dbl 
MATHunary_ATANdbl;
The atan(x) function calculates the arc tangent of x, that is the value @whose tangent is x. The value is returned in radians and is mathematically @defined to be between -PI/2 and PI/2 (inclusive).
mmath
atan
command mmath.atan(X_0:flt):flt 
MATHunary_ATANflt;
(empty)
mmath
atan2
command mmath.atan2(X_0:dbl, X_1:dbl):dbl 
MATHbinary_ATAN2dbl;
The atan2(x,y) function calculates the arc tangent of the two @variables x and y.  It is similar to calculating the arc@tangent of y / x, except that the signs of both arguments are @used to determine the quadrant of the result.  The value is @returned in radians and is mathematically defined to be between @-PI/2 and PI/2 (inclusive).
mmath
atan2
command mmath.atan2(X_0:flt, X_1:flt):flt 
MATHbinary_ATAN2flt;
(empty)
mmath
cbrt
command mmath.cbrt(X_0:dbl):dbl 
MATHunary_CBRTdbl;
The cbrt(x) function returns the cube root of x.
mmath
cbrt
command mmath.cbrt(X_0:flt):flt 
MATHunary_CBRTflt;
(empty)
mmath
ceil
command mmath.ceil(X_0:dbl):dbl 
MATHunary_CEILdbl;
The ceil(x) function rounds x upwards to the nearest integer.
mmath
ceil
command mmath.ceil(X_0:flt):flt 
MATHunary_CEILflt;
(empty)
mmath
cos
command mmath.cos(X_0:dbl):dbl 
MATHunary_COSdbl;
The cos(x) function returns the cosine of x, where x is given in @radians. The return value is between -1 and 1.
mmath
cos
command mmath.cos(X_0:flt):flt 
MATHunary_COSflt;
(empty)
mmath
cosh
command mmath.cosh(X_0:dbl):dbl 
MATHunary_COSHdbl;
The cosh() function  returns the hyperbolic cosine of x, which is @defined mathematically as (exp(x) + exp(-x)) / 2.
mmath
cosh
command mmath.cosh(X_0:flt):flt 
MATHunary_COSHflt;
(empty)
mmath
cot
command mmath.cot(X_0:dbl):dbl 
MATHunary_COTdbl;
The cot(x) function returns the Cotangent of x,@where x is given in radians
mmath
cot
command mmath.cot(X_0:flt):flt 
MATHunary_COTflt;
(empty)
mmath
degrees
command mmath.degrees(X_0:dbl):dbl 
MATHunary_DEGREESdbl;
The degrees() function converts radians into degrees
mmath
degrees
command mmath.degrees(X_0:flt):flt 
MATHunary_DEGREESflt;
(empty)
mmath
exp
command mmath.exp(X_0:dbl):dbl 
MATHunary_EXPdbl;
The exp(x) function returns the value of e (the base of @natural logarithms) raised to the power of x.
mmath
exp
command mmath.exp(X_0:flt):flt 
MATHunary_EXPflt;
(empty)
mmath
fabs
command mmath.fabs(X_0:dbl):dbl 
MATHunary_FABSdbl;
The fabs(x) function  returns  the  absolute value of the @floating-point number x.
mmath
finite
command mmath.finite(X_0:dbl):bit 
MATHunary_FINITE;
The finite(x) function returns true if x is neither infinite @nor a 'not-a-number' (NaN) value, and false otherwise.
mmath
floor
command mmath.floor(X_0:dbl):dbl 
MATHunary_FLOORdbl;
The floor(x) function rounds x downwards to the nearest integer.
mmath
floor
command mmath.floor(X_0:flt):flt 
MATHunary_FLOORflt;
(empty)
mmath
fmod
pattern mmath.fmod(X_0:dbl, X_1:dbl):dbl 
CMDvarMODsignal;
The fmod(x,y) function computes the remainder of dividing x by y.@The return value is x - n * y, where n is the quotient of x / y,@rounded towards zero to an integer.
mmath
fmod
pattern mmath.fmod(X_0:flt, X_1:flt):flt 
CMDvarMODsignal;
(empty)
mmath
isinf
command mmath.isinf(X_0:dbl):int 
MATHunary_ISINF;
The isinf(x) function returns -1 if x represents negative @infinity, 1 if x represents positive infinity, and 0 otherwise.
mmath
isnan
command mmath.isnan(X_0:dbl):bit 
MATHunary_ISNAN;
The isnan(x) function returns true if x is 'not-a-number' @(NaN), and false otherwise.
mmath
log
command mmath.log(X_0:dbl):dbl 
MATHunary_LOGdbl;
The log(x) function returns the natural logarithm of x.
mmath
log
command mmath.log(X_0:flt):flt 
MATHunary_LOGflt;
(empty)
mmath
log10
command mmath.log10(X_0:dbl):dbl 
MATHunary_LOG10dbl;
The log10(x) function returns the base-10 logarithm of x.
mmath
log10
command mmath.log10(X_0:flt):flt 
MATHunary_LOG10flt;
(empty)
mmath
log2
command mmath.log2(X_0:dbl):dbl 
MATHunary_LOG2dbl;
The log2(x) function returns the base-2 logarithm of x.
mmath
log2
command mmath.log2(X_0:flt):flt 
MATHunary_LOG2flt;
(empty)
mmath
log2arg
command mmath.log2arg(X_0:dbl, X_1:dbl):dbl 
MATHbinary_LOGdbl;
The log(x) function returns the logarithm of x in the given base.
mmath
log2arg
command mmath.log2arg(X_0:flt, X_1:flt):flt 
MATHbinary_LOGflt;
The log(x) function returns the logarithm of x in the given base.
mmath
pi
command mmath.pi():dbl 
MATHpi;
return an important mathematical value
mmath
pow
command mmath.pow(X_0:dbl, X_1:dbl):dbl 
MATHbinary_POWdbl;
The pow(x,y) function  returns the value of x raised to the power of y.
mmath
pow
command mmath.pow(X_0:flt, X_1:flt):flt 
MATHbinary_POWflt;
(empty)
mmath
prelude
command mmath.prelude():void 
MATHprelude;
initilize mmath module
mmath
radians
command mmath.radians(X_0:dbl):dbl 
MATHunary_RADIANSdbl;
The radians() function converts degrees into radians
mmath
radians
command mmath.radians(X_0:flt):flt 
MATHunary_RADIANSflt;
(empty)
mmath
rand
unsafe command mmath.rand():int 
MATHrandint;
return a random number
mmath
rand
unsafe command mmath.rand(X_0:int):int 
MATHrandintarg;
return a random number
mmath
round
command mmath.round(X_0:dbl, X_1:int):dbl 
MATHbinary_ROUNDdbl;
The round(n, m) returns n rounded to m places to the right @of the decimal point; if m is omitted, to 0 places. m can be @negative to round off digits left of the decimal point. @m must be an integer.
mmath
round
command mmath.round(X_0:flt, X_1:int):flt 
MATHbinary_ROUNDflt;
(empty)
mmath
sin
command mmath.sin(X_0:dbl):dbl 
MATHunary_SINdbl;
The sin(x) function returns the cosine of x, where x is given in @radians. The return value is between -1 and 1.
mmath
sin
command mmath.sin(X_0:flt):flt 
MATHunary_SINflt;
(empty)
mmath
sinh
command mmath.sinh(X_0:dbl):dbl 
MATHunary_SINHdbl;
The sinh() function  returns  the  hyperbolic sine of x, which @is defined mathematically as (exp(x) - exp(-x)) / 2.
mmath
sinh
command mmath.sinh(X_0:flt):flt 
MATHunary_SINHflt;
(empty)
mmath
sqlrand
command mmath.sqlrand(X_0:int):int 
MATHsqlrandint;
initialize the rand() function with a seed and call rand()
mmath
sqrt
command mmath.sqrt(X_0:dbl):dbl 
MATHunary_SQRTdbl;
The sqrt(x) function returns the non-negative root of x.
mmath
sqrt
command mmath.sqrt(X_0:flt):flt 
MATHunary_SQRTflt;
(empty)
mmath
srand
command mmath.srand(X_0:int):void 
MATHsrandint;
initialize the rand() function with a seed
mmath
tan
command mmath.tan(X_0:dbl):dbl 
MATHunary_TANdbl;
The tan(x) function returns the tangent of x,@where x is given in radians
mmath
tan
command mmath.tan(X_0:flt):flt 
MATHunary_TANflt;
(empty)
mmath
tanh
command mmath.tanh(X_0:dbl):dbl 
MATHunary_TANHdbl;
The tanh() function returns the hyperbolic tangent of x, which is @defined mathematically as sinh(x) / cosh(x).
mmath
tanh
command mmath.tanh(X_0:flt):flt 
MATHunary_TANHflt;
(empty)
mtime
addmonths
command mtime.addmonths(X_0:date, X_1:int):date 
MTIMEdate_addmonths;
returns the date after a number of@months (possibly negative).
mtime
century
command mtime.century(X_0:date):int 
MTIMEdate_extract_century;
extracts century from date.
mtime
century
command mtime.century(X_0:timestamp):int 
MTIMEtimestamp_century;
(empty)
mtime
current_date
command mtime.current_date():date 
MTIMEcurrent_date;
(empty)
mtime
current_time
command mtime.current_time():daytime 
MTIMEcurrent_time;
(empty)
mtime
current_timestamp
command mtime.current_timestamp():timestamp 
MTIMEcurrent_timestamp;
(empty)
mtime
date_add_msec_interval
command mtime.date_add_msec_interval(X_0:date, X_1:lng):date 
MTIMEdate_add_msec_interval;
(empty)
mtime
date_sub_month_interval
command mtime.date_sub_month_interval(X_0:date, X_1:int):date 
MTIMEdate_submonths;
Subtract months from a date
mtime
date_sub_msec_interval
command mtime.date_sub_msec_interval(X_0:date, X_1:lng):date 
MTIMEdate_sub_msec_interval;
(empty)
mtime
date_to_str
command mtime.date_to_str(X_0:date, X_1:str):str 
MTIMEdate_to_str;
create a string from the date, using the specified format (see man strftime)
mtime
day
command mtime.day(X_0:date):int 
MTIMEdate_extract_day;
extracts day from date 
mtime
day
command mtime.day(X_0:lng):lng 
MTIMEsql_day;
(empty)
mtime
day
command mtime.day(X_0:timestamp):int 
MTIMEtimestamp_day;
(empty)
mtime
dayofweek
command mtime.dayofweek(X_0:date):int 
MTIMEdate_extract_dayofweek;
Returns the current day of the week@where 1=monday, .., 7=sunday
mtime
dayofyear
command mtime.dayofyear(X_0:date):int 
MTIMEdate_extract_dayofyear;
Returns N where d is the Nth day@of the year (january 1 returns 1)
mtime
decade
command mtime.decade(X_0:date):int 
MTIMEdate_extract_decade;
extracts decade from date.
mtime
decade
command mtime.decade(X_0:timestamp):int 
MTIMEtimestamp_decade;
(empty)
mtime
diff
command mtime.diff(X_0:date, X_1:date):lng 
MTIMEdate_diff;
returns the number of days@between 'val1' and 'val2'.
mtime
diff
command mtime.diff(X_0:daytime, X_1:daytime):lng 
MTIMEdaytime_diff_msec;
returns the number of msec between 'val1' and 'val2'.
mtime
diff
command mtime.diff(X_0:timestamp, X_1:timestamp):lng 
MTIMEtimestamp_diff_msec;
returns the number of milliseconds@between 'val1' and 'val2'.
mtime
epoch
command mtime.epoch(X_0:timestamp):int 
MTIMEseconds_since_epoch;
unix-time (epoch) support: seconds since epoch
mtime
epoch
command mtime.epoch(X_0:lng):timestamp 
MTIMEtimestamp_frommsec_epoch;
convert milli seconds since epoch into a timestamp
mtime
epoch
command mtime.epoch(X_0:int):timestamp 
MTIMEtimestamp_fromsecond_epoch;
convert seconds since epoch into a timestamp
mtime
epoch_ms
command mtime.epoch_ms(X_0:date):lng 
MTIMEdate_extract_epoch_ms;
(empty)
mtime
epoch_ms
command mtime.epoch_ms(X_0:daytime):lng 
MTIMEdaytime_extract_epoch_ms;
(empty)
mtime
epoch_ms
command mtime.epoch_ms(X_0:lng):lng 
MTIMEmsec_extract_epoch_ms;
(empty)
mtime
epoch_ms
command mtime.epoch_ms(X_0:timestamp):lng 
MTIMEtimestamp_extract_epoch_ms;
(empty)
mtime
hours
command mtime.hours(X_0:daytime):int 
MTIMEdaytime_extract_hours;
extracts hour from daytime
mtime
hours
command mtime.hours(X_0:lng):int 
MTIMEsql_hours;
(empty)
mtime
hours
command mtime.hours(X_0:timestamp):int 
MTIMEtimestamp_hours;
(empty)
mtime
local_timezone
command mtime.local_timezone():lng 
MTIMElocal_timezone_msec;
get the local timezone in seconds
mtime
minutes
command mtime.minutes(X_0:daytime):int 
MTIMEdaytime_extract_minutes;
extracts minutes from daytime
mtime
minutes
command mtime.minutes(X_0:lng):int 
MTIMEsql_minutes;
(empty)
mtime
minutes
command mtime.minutes(X_0:timestamp):int 
MTIMEtimestamp_minutes;
(empty)
mtime
month
command mtime.month(X_0:date):int 
MTIMEdate_extract_month;
extracts month from date
mtime
month
command mtime.month(X_0:int):int 
MTIMEsql_month;
(empty)
mtime
month
command mtime.month(X_0:timestamp):int 
MTIMEtimestamp_month;
(empty)
mtime
quarter
command mtime.quarter(X_0:date):int 
MTIMEdate_extract_quarter;
extracts quarter from date
mtime
quarter
command mtime.quarter(X_0:timestamp):int 
MTIMEtimestamp_quarter;
(empty)
mtime
seconds
command mtime.seconds(X_0:lng):int 
MTIMEsql_seconds;
(empty)
mtime
sql_seconds
command mtime.sql_seconds(X_0:daytime):int 
MTIMEdaytime_extract_sql_seconds;
extracts seconds (with fractional milliseconds) from daytime
mtime
sql_seconds
command mtime.sql_seconds(X_0:timestamp):int 
MTIMEtimestamp_sql_seconds;
(empty)
mtime
str_to_date
command mtime.str_to_date(X_0:str, X_1:str):date 
MTIMEstr_to_date;
create a date from the string, using the specified format (see man strptime)
mtime
str_to_time
command mtime.str_to_time(X_0:str, X_1:str):daytime 
MTIMEstr_to_time;
create a time from the string, using the specified format (see man strptime)
mtime
str_to_timestamp
command mtime.str_to_timestamp(X_0:str, X_1:str):timestamp 
MTIMEstr_to_timestamp;
create a timestamp from the string, using the specified format (see man strptime)
mtime
time_add_msec_interval
command mtime.time_add_msec_interval(X_0:daytime, X_1:lng):daytime 
MTIMEtime_add_msec_interval;
Add seconds to a time
mtime
time_sub_msec_interval
command mtime.time_sub_msec_interval(X_0:daytime, X_1:lng):daytime 
MTIMEtime_sub_msec_interval;
Subtract seconds from a time
mtime
time_to_str
command mtime.time_to_str(X_0:daytime, X_1:str):str 
MTIMEtime_to_str;
create a string from the time, using the specified format (see man strftime)
mtime
timestamp_add_month_interval
command mtime.timestamp_add_month_interval(X_0:timestamp, X_1:int):timestamp 
MTIMEtimestamp_add_month_interval;
Add months to a timestamp
mtime
timestamp_add_msec_interval
command mtime.timestamp_add_msec_interval(X_0:timestamp, X_1:lng):timestamp 
MTIMEtimestamp_add_msec_interval;
(empty)
mtime
timestamp_sub_month_interval
command mtime.timestamp_sub_month_interval(X_0:timestamp, X_1:int):timestamp 
MTIMEtimestamp_sub_month_interval;
Subtract months from a timestamp
mtime
timestamp_sub_msec_interval
command mtime.timestamp_sub_msec_interval(X_0:timestamp, X_1:lng):timestamp 
MTIMEtimestamp_sub_msec_interval;
(empty)
mtime
timestamp_to_str
command mtime.timestamp_to_str(X_0:timestamp, X_1:str):str 
MTIMEtimestamp_to_str;
create a string from the time, using the specified format (see man strftime)
mtime
usweekofyear
command mtime.usweekofyear(X_0:date):int 
MTIMEdate_extract_usweekofyear;
Returns the week number in the year, US style.
mtime
weekofyear
command mtime.weekofyear(X_0:date):int 
MTIMEdate_extract_weekofyear;
Returns the week number in the year.
mtime
year
command mtime.year(X_0:date):int 
MTIMEdate_extract_year;
extracts year from date.
mtime
year
command mtime.year(X_0:int):int 
MTIMEsql_year;
(empty)
mtime
year
command mtime.year(X_0:timestamp):int 
MTIMEtimestamp_year;
(empty)
netcdf
attach
unsafe pattern netcdf.attach(X_0:str):void 
NCDFattach;
Register a NetCDF file in the vault
netcdf
importvar
unsafe command netcdf.importvar(X_0:str, X_1:int):str 
NCDFimportVarStmt;
Import variable: compose create array string
netcdf
importvariable
unsafe pattern netcdf.importvariable(X_0:int, X_1:str):void 
NCDFimportVariable;
Import variable: create array and load data from variable varname of file fileid
netcdf
test
command netcdf.test(X_0:str):int 
NCDFtest;
Returns number of variables in a given NetCDF dataset (file)
optimizer
aliases
pattern optimizer.aliases():str 
OPTwrapper;
(empty)
optimizer
aliases
pattern optimizer.aliases(X_0:str, X_1:str):str 
OPTwrapper;
Alias removal optimizer
optimizer
bincopyfrom
pattern optimizer.bincopyfrom():str 
OPTwrapper;
(empty)
optimizer
bincopyfrom
pattern optimizer.bincopyfrom(X_0:str, X_1:str):str 
OPTwrapper;
Parallellize column loading
optimizer
candidates
pattern optimizer.candidates():str 
OPTwrapper;
(empty)
optimizer
candidates
pattern optimizer.candidates(X_0:str, X_1:str):str 
OPTwrapper;
Mark candidate list variables
optimizer
coercions
pattern optimizer.coercions():str 
OPTwrapper;
(empty)
optimizer
coercions
pattern optimizer.coercions(X_0:str, X_1:str):str 
OPTwrapper;
Handle simple type coercions
optimizer
commonTerms
pattern optimizer.commonTerms():str 
OPTwrapper;
(empty)
optimizer
commonTerms
pattern optimizer.commonTerms(X_0:str, X_1:str):str 
OPTwrapper;
Common sub-expression optimizer
optimizer
constants
pattern optimizer.constants():str 
OPTwrapper;
(empty)
optimizer
constants
pattern optimizer.constants(X_0:str, X_1:str):str 
OPTwrapper;
Duplicate constant removal optimizer
optimizer
costModel
pattern optimizer.costModel():str 
OPTwrapper;
(empty)
optimizer
costModel
pattern optimizer.costModel(X_0:str, X_1:str):str 
OPTwrapper;
Estimate the cost of a relational expression
optimizer
dataflow
pattern optimizer.dataflow():str 
OPTwrapper;
(empty)
optimizer
dataflow
pattern optimizer.dataflow(X_0:str, X_1:str):str 
OPTwrapper;
Dataflow bracket code injection
optimizer
deadcode
pattern optimizer.deadcode():str 
OPTwrapper;
(empty)
optimizer
deadcode
pattern optimizer.deadcode(X_0:str, X_1:str):str 
OPTwrapper;
Dead code optimizer
optimizer
default_fast
function optimizer.default_fast():void;
(empty)
(empty)
optimizer
default_pipe
function optimizer.default_pipe():void;
(empty)
(empty)
optimizer
defaultfast
pattern optimizer.defaultfast():str 
OPTwrapper;
(empty)
optimizer
defaultfast
pattern optimizer.defaultfast(X_0:str, X_1:str):str 
OPTwrapper;
Fast compound default optimizer pipe
optimizer
dict
pattern optimizer.dict():str 
OPTwrapper;
(empty)
optimizer
dict
pattern optimizer.dict(X_0:str, X_1:str):str 
OPTwrapper;
Push dict decompress down
optimizer
emptybind
pattern optimizer.emptybind():str 
OPTwrapper;
(empty)
optimizer
emptybind
pattern optimizer.emptybind(X_0:str, X_1:str):str 
OPTwrapper;
Evaluate empty set expressions
optimizer
epilogue
command optimizer.epilogue():void 
optimizer_epilogue;
release the resources held by the optimizer module
optimizer
evaluate
pattern optimizer.evaluate():str 
OPTwrapper;
(empty)
optimizer
evaluate
pattern optimizer.evaluate(X_0:str, X_1:str):str 
OPTwrapper;
Evaluate constant expressions once
optimizer
for
pattern optimizer.for():str 
OPTwrapper;
(empty)
optimizer
for
pattern optimizer.for(X_0:str, X_1:str):str 
OPTwrapper;
Push for decompress down
optimizer
garbageCollector
pattern optimizer.garbageCollector():str 
OPTwrapper;
(empty)
optimizer
garbageCollector
pattern optimizer.garbageCollector(X_0:str, X_1:str):str 
OPTwrapper;
Garbage collector optimizer
optimizer
generator
pattern optimizer.generator():str 
OPTwrapper;
(empty)
optimizer
generator
pattern optimizer.generator(X_0:str, X_1:str):str 
OPTwrapper;
Sequence generator optimizer
optimizer
inline
pattern optimizer.inline():str 
OPTwrapper;
(empty)
optimizer
inline
pattern optimizer.inline(X_0:str, X_1:str):str 
OPTwrapper;
Expand inline functions
optimizer
jit
pattern optimizer.jit():str 
OPTwrapper;
(empty)
optimizer
jit
pattern optimizer.jit(X_0:str, X_1:str):str 
OPTwrapper;
Propagate candidate lists in just-in-time optimization
optimizer
json
pattern optimizer.json():str 
OPTwrapper;
(empty)
optimizer
json
pattern optimizer.json(X_0:str, X_1:str):str 
OPTwrapper;
Unroll the mat.pack operation
optimizer
macro
pattern optimizer.macro(X_0:str, X_1:str):void 
OPTmacro;
Inline the code of the target function.
optimizer
macro
pattern optimizer.macro(X_0:str, X_1:str, X_2:str, X_3:str):void 
OPTmacro;
Inline a target function used in a specific function.
optimizer
mask
pattern optimizer.mask():str 
OPTwrapper;
(empty)
optimizer
mask
pattern optimizer.mask(X_0:str, X_1:str):str 
OPTwrapper;
Manipulate the MSK objects
optimizer
matpack
pattern optimizer.matpack():str 
OPTwrapper;
(empty)
optimizer
matpack
pattern optimizer.matpack(X_0:str, X_1:str):str 
OPTwrapper;
Unroll the mat.pack operation
optimizer
mergetable
pattern optimizer.mergetable():str 
OPTwrapper;
(empty)
optimizer
mergetable
pattern optimizer.mergetable(X_0:str, X_1:str):str 
OPTwrapper;
Resolve the multi-table definitions
optimizer
minimal_fast
function optimizer.minimal_fast():void;
(empty)
(empty)
optimizer
minimal_pipe
function optimizer.minimal_pipe():void;
(empty)
(empty)
optimizer
minimalfast
pattern optimizer.minimalfast():str 
OPTwrapper;
(empty)
optimizer
minimalfast
pattern optimizer.minimalfast(X_0:str, X_1:str):str 
OPTwrapper;
Fast compound minimal optimizer pipe
optimizer
mitosis
pattern optimizer.mitosis():str 
OPTwrapper;
(empty)
optimizer
mitosis
pattern optimizer.mitosis(X_0:str, X_1:str):str 
OPTwrapper;
Modify the plan to exploit parallel processing on multiple cores
optimizer
multiplex
pattern optimizer.multiplex():str 
OPTwrapper;
(empty)
optimizer
multiplex
pattern optimizer.multiplex(X_0:str, X_1:str):str 
OPTwrapper;
Compiler for multiplexed instructions
optimizer
no_mitosis_pipe
function optimizer.no_mitosis_pipe():void;
(empty)
(empty)
optimizer
optimize
pattern optimizer.optimize(X_0:str, X_1:str):void 
QOToptimize;
Optimize a specific operation
optimizer
orcam
pattern optimizer.orcam(X_0:str, X_1:str):void 
OPTorcam;
Inverse macro processor for current function
optimizer
orcam
pattern optimizer.orcam(X_0:str, X_1:str, X_2:str, X_3:str):void 
OPTorcam;
Inverse macro, find pattern and replace with a function call.
optimizer
postfix
pattern optimizer.postfix():str 
OPTwrapper;
(empty)
optimizer
postfix
pattern optimizer.postfix(X_0:str, X_1:str):str 
OPTwrapper;
Postfix the plan,e.g. pushing projections
optimizer
prelude
pattern optimizer.prelude():void 
optimizer_prelude;
Initialize the optimizer
optimizer
profiler
pattern optimizer.profiler():str 
OPTwrapper;
(empty)
optimizer
profiler
pattern optimizer.profiler(X_0:str, X_1:str):str 
OPTwrapper;
Collect properties for the profiler
optimizer
projectionpath
pattern optimizer.projectionpath():str 
OPTwrapper;
(empty)
optimizer
projectionpath
pattern optimizer.projectionpath(X_0:str, X_1:str):str 
OPTwrapper;
Join path constructor
optimizer
pushselect
pattern optimizer.pushselect():str 
OPTwrapper;
(empty)
optimizer
pushselect
pattern optimizer.pushselect(X_0:str, X_1:str):str 
OPTwrapper;
Push selects down projections
optimizer
querylog
pattern optimizer.querylog():str 
OPTwrapper;
(empty)
optimizer
querylog
pattern optimizer.querylog(X_0:str, X_1:str):str 
OPTwrapper;
Collect SQL query statistics
optimizer
reduce
pattern optimizer.reduce():str 
OPTwrapper;
(empty)
optimizer
reduce
pattern optimizer.reduce(X_0:str, X_1:str):str 
OPTwrapper;
Reduce the stack space claims
optimizer
remap
pattern optimizer.remap():str 
OPTwrapper;
(empty)
optimizer
remap
pattern optimizer.remap(X_0:str, X_1:str):str 
OPTwrapper;
Remapping function calls to a their multiplex variant
optimizer
remoteQueries
pattern optimizer.remoteQueries():str 
OPTwrapper;
(empty)
optimizer
remoteQueries
pattern optimizer.remoteQueries(X_0:str, X_1:str):str 
OPTwrapper;
Resolve the multi-table definitions
optimizer
reorder
pattern optimizer.reorder():str 
OPTwrapper;
(empty)
optimizer
reorder
pattern optimizer.reorder(X_0:str, X_1:str):str 
OPTwrapper;
Reorder by dataflow dependencies
optimizer
sequential_pipe
function optimizer.sequential_pipe():void;
(empty)
(empty)
optimizer
strimps
pattern optimizer.strimps():str 
OPTwrapper;
(empty)
optimizer
strimps
pattern optimizer.strimps(X_0:str, X_1:str):str 
OPTwrapper;
Use strimps index if appropriate
optimizer
volcano
pattern optimizer.volcano():str 
OPTwrapper;
(empty)
optimizer
volcano
pattern optimizer.volcano(X_0:str, X_1:str):str 
OPTwrapper;
Simulate volcano style execution
optimizer
volcano_pipe
function optimizer.volcano_pipe():void;
(empty)
(empty)
optimizer
wlc
pattern optimizer.wlc():str 
OPTwrapper;
(empty)
optimizer
wlc
pattern optimizer.wlc(X_0:str, X_1:str):str 
OPTwrapper;
Inject the workload capture-replay primitives
optimizer
wrapper
pattern optimizer.wrapper():str 
OPTwrapper;
(empty)
optimizer
wrapper
pattern optimizer.wrapper(X_0:str, X_1:str):str 
OPTwrapper;
Fake optimizer
pcre
imatch
command pcre.imatch(X_0:str, X_1:str):bit 
PCREimatch;
Caseless Perl Compatible Regular Expression pattern matching against a string
pcre
index
command pcre.index(X_0:pcre, X_1:str):int 
PCREindex;
match a pattern, return matched position (or 0 when not found)
pcre
match
command pcre.match(X_0:str, X_1:str):bit 
PCREmatch;
Perl Compatible Regular Expression pattern matching against a string
pcre
patindex
command pcre.patindex(X_0:str, X_1:str):int 
PCREpatindex;
Location of the first POSIX pattern matching against a string
pcre
pcre_quote
command pcre.pcre_quote(X_0:str):str 
PCREquote;
Return a PCRE pattern string that matches the argument exactly.
pcre
prelude
command pcre.prelude():void 
pcre_init;
Initialize pcre
pcre
replace
command pcre.replace(X_0:str, X_1:str, X_2:str, X_3:str):str 
PCREreplace_wrap;
Replace _all_ matches of "pattern" in "origin_str" with "replacement".@Parameter "flags" accept these flags: 'i', 'm', 's', and 'x'.@'e': if present, an empty string is considered to be a valid match@'i': if present, the match operates in case-insensitive mode.@Otherwise, in case-sensitive mode.@'m': if present, the match operates in multi-line mode.@'s': if present, the match operates in "dot-all"@The specifications of the flags can be found in "man pcreapi"@The flag letters may be repeated.@No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in "flags".@Returns the replaced string, or if no matches found, the original string.
pcre
replace_first
command pcre.replace_first(X_0:str, X_1:str, X_2:str, X_3:str):str 
PCREreplacefirst_wrap;
Replace _the first_ match of "pattern" in "origin_str" with "replacement".@Parameter "flags" accept these flags: 'i', 'm', 's', and 'x'.@'e': if present, an empty string is considered to be a valid match@'i': if present, the match operates in case-insensitive mode.@Otherwise, in case-sensitive mode.@'m': if present, the match operates in multi-line mode.@'s': if present, the match operates in "dot-all"@The specifications of the flags can be found in "man pcreapi"@The flag letters may be repeated.@No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in "flags".@Returns the replaced string, or if no matches found, the original string.
pcre
sql2pcre
command pcre.sql2pcre(X_0:str, X_1:str):str 
PCREsql2pcre;
Convert a SQL like pattern with the given escape character into a PCRE pattern.
profiler
cleanup
unsafe pattern profiler.cleanup():void 
CMDcleanupTraces;
Remove the temporary tables for profiling
profiler
closestream
pattern profiler.closestream():void 
CMDcloseProfilerStream;
Stop offline proviling
profiler
cpuload
command profiler.cpuload(X_0:lng, X_1:lng, X_2:lng, X_3:lng, X_4:lng) (X_5:int, X_6:int) 
CMDcpuloadPercentage;
Calculate the average cpu load percentage and io waiting times
profiler
cpustats
command profiler.cpustats() (X_0:lng, X_1:lng, X_2:lng, X_3:lng, X_4:lng) 
CMDcpustats;
Extract cpu statistics from the kernel
profiler
getDiskReads
command profiler.getDiskReads():lng 
CMDgetDiskReads;
Obtain the number of physical reads
profiler
getDiskWrites
command profiler.getDiskWrites():lng 
CMDgetDiskWrites;
Obtain the number of physical reads
profiler
getSystemTime
command profiler.getSystemTime():lng 
CMDgetSystemTime;
Obtain the user timing information.
profiler
getTrace
pattern profiler.getTrace(X_0:str):bat[:any_1] 
CMDgetTrace;
Get the trace details of a specific event
profiler
getUserTime
command profiler.getUserTime():lng 
CMDgetUserTime;
Obtain the user timing information.
profiler
getlimit
command profiler.getlimit():int 
CMDgetprofilerlimit;
Get profiler limit
profiler
noop
command profiler.noop():void 
CMDnoopProfiler;
Fetch any pending performance events
profiler
openstream
pattern profiler.openstream():void 
CMDopenProfilerStream;
Start profiling the events, send to output stream
profiler
setheartbeat
unsafe command profiler.setheartbeat(X_0:int):void 
CMDsetHeartbeat;
Set heart beat performance tracing
profiler
setlimit
unsafe command profiler.setlimit(X_0:int):void 
CMDsetprofilerlimit;
Set profiler limit
profiler
start
unsafe pattern profiler.start():void 
CMDstartProfiler;
Start offline performance profiling
profiler
starttrace
unsafe pattern profiler.starttrace():void 
CMDstartTrace;
Start collecting trace information
profiler
stop
unsafe pattern profiler.stop():void 
CMDstopProfiler;
Stop offline performance profiling
profiler
stoptrace
unsafe pattern profiler.stoptrace():void 
CMDstopTrace;
Stop collecting trace information
pyapi3
eval
unsafe pattern pyapi3.eval(X_0:ptr, X_1:str):any 
PYAPI3PyAPIevalStd;
Execute a simple Python script returning a single value
pyapi3
eval
unsafe pattern pyapi3.eval(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalStd;
Execute a simple Python script value
pyapi3
eval_aggr
unsafe pattern pyapi3.eval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalAggr;
grouped aggregates through Python
pyapi3
eval_loader
unsafe pattern pyapi3.eval_loader(X_0:ptr, X_1:str):any... 
PYAPI3PyAPIevalLoader;
loader functions through Python
pyapi3
eval_loader
unsafe pattern pyapi3.eval_loader(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalLoader;
loader functions through Python
pyapi3
prelude
command pyapi3.prelude():void 
PYAPI3PyAPIprelude;
(empty)
pyapi3
subeval_aggr
unsafe pattern pyapi3.subeval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalAggr;
grouped aggregates through Python
pyapi3map
eval
pattern pyapi3map.eval(X_0:ptr, X_1:str):any 
PYAPI3PyAPIevalStdMap;
Execute a simple Python script returning a single value
pyapi3map
eval
pattern pyapi3map.eval(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalStdMap;
Execute a simple Python script value
pyapi3map
eval_aggr
pattern pyapi3map.eval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalAggrMap;
grouped aggregates through Python
pyapi3map
subeval_aggr
pattern pyapi3map.subeval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
PYAPI3PyAPIevalAggrMap;
grouped aggregates through Python
querylog
append
pattern querylog.append(X_0:str, X_1:str, X_2:str, X_3:timestamp):void 
QLOGappend;
Add a new query call to the query log
querylog
call
pattern querylog.call(X_0:timestamp, X_1:timestamp, X_2:str, X_3:lng, X_4:lng, X_5:lng, X_6:int, X_7:int):void 
QLOGcall;
Add a new query call to the query log
querylog
context
command querylog.context(X_0:str, X_1:str, X_2:str, X_3:str):void 
QLOGcontextNaive;
Noop operation, just marking the query
querylog
define
command querylog.define(X_0:str, X_1:str, X_2:int):void 
QLOGdefineNaive;
Noop operation, just marking the query
querylog
disable
command querylog.disable():void 
QLOGdisable;
Turn off the query logger
querylog
empty
command querylog.empty():void 
QLOGempty;
Clear the query log tables
querylog
enable
command querylog.enable():void 
QLOGenable;
Turn on the query logger
querylog
enable
command querylog.enable(X_0:int):void 
QLOGenableThreshold;
Turn on the query logger
querylog
isset
command querylog.isset():int 
QLOGissetFcn;
Return status of query logger
rapi
eval
pattern rapi.eval(X_0:ptr, X_1:str):any 
RAPIevalStd;
Execute a simple R script returning a single value
rapi
eval
pattern rapi.eval(X_0:ptr, X_1:str, X_2:any...):any... 
RAPIevalStd;
Execute a simple R script value
rapi
eval_aggr
pattern rapi.eval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
RAPIevalAggr;
grouped aggregates through R
rapi
prelude
command rapi.prelude():void 
RAPIprelude;
(empty)
rapi
subeval_aggr
pattern rapi.subeval_aggr(X_0:ptr, X_1:str, X_2:any...):any... 
RAPIevalAggr;
grouped aggregates through R
remote
batbincopy
pattern remote.batbincopy():bat[:any] 
RMTbincopyfrom;
store the binary BAT data in the BBP and return as BAT
remote
batbincopy
pattern remote.batbincopy(X_0:bat[:any]):void 
RMTbincopyto;
dump BAT b in binary form to the stream
remote
batload
pattern remote.batload(X_0:any_1, X_1:int):bat[:any_1] 
RMTbatload;
create a BAT of the given type and size, and load values from the input stream
remote
bintype
pattern remote.bintype():void 
RMTbintype;
print the binary type of this mserver5
remote
connect
pattern remote.connect(X_0:str, X_1:str, X_2:str, X_3:str):str 
RMTconnect;
returns a newly created connection for uri, using user name and password
remote
connect
command remote.connect(X_0:str, X_1:str, X_2:str, X_3:str, X_4:bit):str 
RMTconnectScen;
returns a newly created connection for uri, using user name, password and scenario
remote
connect
pattern remote.connect(X_0:str, X_1:str):str 
RMTconnectTable;
return a newly created connection for a table. username and password should be in the vault
remote
disconnect
command remote.disconnect(X_0:str):void 
RMTdisconnect;
disconnects the connection pointed to by handle (received from a call to connect()
remote
epilogue
command remote.epilogue():void 
RMTepilogue;
release the resources held by the remote module
remote
exec
pattern remote.exec(X_0:str, X_1:str, X_2:str):str 
RMTexec;
remotely executes <mod>.<func> and returns the handle to its result
remote
exec
pattern remote.exec(X_0:str, X_1:str, X_2:str):str... 
RMTexec;
remotely executes <mod>.<func> and returns the handle to its result
remote
exec
pattern remote.exec(X_0:str, X_1:str, X_2:str, X_3:ptr, X_4:str...):void 
RMTexec;
remotely executes <mod>.<func> using the argument list of remote objects and applying function pointer rcb as callback to handle any results.
remote
exec
pattern remote.exec(X_0:str, X_1:str, X_2:str, X_3:str...):str 
RMTexec;
remotely executes <mod>.<func> using the argument list of remote objects and returns the handle to its result
remote
exec
pattern remote.exec(X_0:str, X_1:str, X_2:str, X_3:str...):str... 
RMTexec;
remotely executes <mod>.<func> using the argument list of remote objects and returns the handle to its result
remote
exec
pattern remote.exec(X_0:str, X_1:str, X_2:str, X_3:str...):void 
RMTexec;
remotely executes <mod>.<func> using the argument list of remote objects and ignoring results.
remote
get
pattern remote.get(X_0:str, X_1:str):any 
RMTget;
retrieves a copy of remote object ident
remote
isalive
command remote.isalive(X_0:str):int 
RMTisalive;
check if conn is still valid and connected
remote
prelude
command remote.prelude():void 
RMTprelude;
initialise the remote module
remote
put
pattern remote.put(X_0:str, X_1:any):str 
RMTput;
copies object to the remote site and returns its identifier
remote
register
pattern remote.register(X_0:str, X_1:str, X_2:str):str 
RMTregister;
register <mod>.<fcn> at the remote site
remote
register_supervisor
command remote.register_supervisor(X_0:str, X_1:str):int 
RMTregisterSupervisor;
Register the supervisor uuid at a remote site
remote
resolve
command remote.resolve(X_0:str):bat[:str] 
RMTresolve;
resolve a pattern against Merovingian and return the URIs
sample
subuniform
pattern sample.subuniform(X_0:bat[:any], X_1:dbl):bat[:oid] 
SAMPLEuniform;
Returns the oids of a uniform sample of size = (p x count(b)), where 0 <= p <= 1.0
sample
subuniform
pattern sample.subuniform(X_0:bat[:any], X_1:dbl, X_2:int):bat[:oid] 
SAMPLEuniform;
Returns the oids of a uniform sample of size = (p x count(b)), where 0 <= p <= 1.0 and where the prg is seeded with sample_seed
sample
subuniform
pattern sample.subuniform(X_0:bat[:any], X_1:lng):bat[:oid] 
SAMPLEuniform;
Returns the oids of a uniform sample of size s
sample
subuniform
pattern sample.subuniform(X_0:bat[:any], X_1:lng, X_2:int):bat[:oid] 
SAMPLEuniform;
Returns the oids of a uniform sample of size s and where the prg is seeded with sample_seed
shp
attach
unsafe pattern shp.attach(X_0:str):void 
SHPattach;
Register an ESRI Shapefile in the vault catalog
shp
import
unsafe pattern shp.import(X_0:int):void 
SHPimport;
Import an ESRI Shapefile with given id into the vault
shp
import
unsafe pattern shp.import(X_0:int, X_1:wkb):void 
SHPpartialimport;
Partially import an ESRI Shapefile with given id into the vault
sql
affectedRows
unsafe pattern sql.affectedRows(X_0:int, X_1:lng):int 
mvc_affected_rows_wrap;
export the number of affected rows by the current query
sql
all
pattern sql.all(X_0:bit, X_1:bit, X_2:bit):bit 
SQLall_cmp;
if !cmp then false, (nl or nr) then nil, else true
sql
alpha
command sql.alpha(X_0:dbl, X_1:dbl):dbl 
SQLcst_alpha_cst;
Implementation of astronomy alpha function: expands the radius theta depending on the declination
sql
analyze
unsafe pattern sql.analyze():void 
sql_analyze;
Update statistics for every column in the database
sql
analyze
unsafe pattern sql.analyze(X_0:str):void 
sql_analyze;
Update statistics for schema
sql
analyze
unsafe pattern sql.analyze(X_0:str, X_1:str):void 
sql_analyze;
Update statistics for table
sql
analyze
unsafe pattern sql.analyze(X_0:str, X_1:str, X_2:str):void 
sql_analyze;
Update statistics for column
sql
any
pattern sql.any(X_0:bit, X_1:bit, X_2:bit):bit 
SQLany_cmp;
if cmp then true, (nl or nr) nil then nil, else false
sql
append
pattern sql.append(X_0:int, X_1:str, X_2:str, X_3:str, X_4:oid, X_5:bat[:oid], X_6:any):int 
mvc_append_wrap;
Append to the column tname.cname (possibly optimized to replace the insert bat of tname.cname. Returns sequence number for order dependence.
sql
argRecord
pattern sql.argRecord():str 
SQLargRecord;
Glue together the calling sequence
sql
argRecord
pattern sql.argRecord(X_0:any...):str 
SQLargRecord;
Glue together the calling sequence
sql
assert
pattern sql.assert(X_0:bit, X_1:str):void 
SQLassert;
Generate an exception when b==true
sql
assert
pattern sql.assert(X_0:int, X_1:str):void 
SQLassertInt;
Generate an exception when b!=0
sql
assert
pattern sql.assert(X_0:lng, X_1:str):void 
SQLassertLng;
Generate an exception when b!=0
sql
avg
pattern sql.avg(X_0:bte, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLavg;
return the average of groups
sql
avg
pattern sql.avg(X_0:dbl, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLavg;
return the average of groups
sql
avg
pattern sql.avg(X_0:flt, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLavg;
return the average of groups
sql
avg
pattern sql.avg(X_0:int, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLavg;
return the average of groups
sql
avg
pattern sql.avg(X_0:lng, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLavg;
return the average of groups
sql
avg
pattern sql.avg(X_0:sht, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLavg;
return the average of groups
sql
avg
pattern sql.avg(X_0:bte, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):bte 
SQLavginteger;
return the average of groups
sql
avg
pattern sql.avg(X_0:int, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):int 
SQLavginteger;
return the average of groups
sql
avg
pattern sql.avg(X_0:lng, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):lng 
SQLavginteger;
return the average of groups
sql
avg
pattern sql.avg(X_0:sht, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):sht 
SQLavginteger;
return the average of groups
sql
bind
pattern sql.bind(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int) (X_5:bat[:oid], X_6:bat[:any_1]) 
mvc_bind_wrap;
Bind the 'schema.table.column' BAT with access kind:@0 - base table@1 - inserts@2 - updates
sql
bind
pattern sql.bind(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int):bat[:any_1] 
mvc_bind_wrap;
Bind the 'schema.table.column' BAT with access kind:@0 - base table@1 - inserts@2 - updates
sql
bind
pattern sql.bind(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int, X_5:int, X_6:int) (X_7:bat[:oid], X_8:bat[:any_1]) 
mvc_bind_wrap;
Bind the 'schema.table.column' BAT with access kind:@0 - base table@1 - inserts@2 - updates
sql
bind
pattern sql.bind(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int, X_5:int, X_6:int):bat[:any_1] 
mvc_bind_wrap;
Bind the 'schema.table.column' BAT partition with access kind:@0 - base table@1 - inserts@2 - updates
sql
bind_idxbat
pattern sql.bind_idxbat(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int) (X_5:bat[:oid], X_6:bat[:any_1]) 
mvc_bind_idxbat_wrap;
Bind the 'schema.table.index' BAT with access kind:@0 - base table@1 - inserts@2 - updates
sql
bind_idxbat
pattern sql.bind_idxbat(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int):bat[:any_1] 
mvc_bind_idxbat_wrap;
Bind the 'schema.table.index' BAT with access kind:@0 - base table@1 - inserts@2 - updates
sql
bind_idxbat
pattern sql.bind_idxbat(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int, X_5:int, X_6:int) (X_7:bat[:oid], X_8:bat[:any_1]) 
mvc_bind_idxbat_wrap;
Bind the 'schema.table.index' BAT with access kind:@0 - base table@1 - inserts@2 - updates
sql
bind_idxbat
pattern sql.bind_idxbat(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int, X_5:int, X_6:int):bat[:any_1] 
mvc_bind_idxbat_wrap;
Bind the 'schema.table.index' BAT with access kind:@0 - base table@1 - inserts@2 - updates
sql
claim
unsafe pattern sql.claim(X_0:int, X_1:str, X_2:str, X_3:lng) (X_4:oid, X_5:bat[:oid]) 
mvc_claim_wrap;
Claims slots for appending rows.
sql
clear_table
unsafe pattern sql.clear_table(X_0:str, X_1:str, X_2:int):lng 
mvc_clear_table_wrap;
Clear the table sname.tname.
sql
copy_from
unsafe pattern sql.copy_from(X_0:ptr, X_1:str, X_2:str, X_3:str, X_4:str, X_5:str, X_6:lng, X_7:lng, X_8:int, X_9:str, X_10:int, X_11:int):bat[:any]... 
mvc_import_table_wrap;
Import a table from bstream s with the @given tuple and seperators (sep/rsep)
sql
copy_rejects
pattern sql.copy_rejects() (X_0:bat[:lng], X_1:bat[:int], X_2:bat[:str], X_3:bat[:str]) 
COPYrejects;
(empty)
sql
copy_rejects_clear
unsafe pattern sql.copy_rejects_clear():void 
COPYrejects_clear;
(empty)
sql
corr
pattern sql.corr(X_0:bte, X_1:bte, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcorr;
return the correlation value of groups
sql
corr
pattern sql.corr(X_0:dbl, X_1:dbl, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcorr;
return the correlation value of groups
sql
corr
pattern sql.corr(X_0:flt, X_1:flt, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcorr;
return the correlation value of groups
sql
corr
pattern sql.corr(X_0:int, X_1:int, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcorr;
return the correlation value of groups
sql
corr
pattern sql.corr(X_0:lng, X_1:lng, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcorr;
return the correlation value of groups
sql
corr
pattern sql.corr(X_0:sht, X_1:sht, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcorr;
return the correlation value of groups
sql
count
pattern sql.count(X_0:str, X_1:str):lng 
SQLbasecount;
return count of basetable
sql
count
pattern sql.count(X_0:any_1, X_1:bit, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):lng 
SQLcount;
return count of groups
sql
covariance
pattern sql.covariance(X_0:bte, X_1:bte, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_samp;
return the covariance sample value of groups
sql
covariance
pattern sql.covariance(X_0:dbl, X_1:dbl, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_samp;
return the covariance sample value of groups
sql
covariance
pattern sql.covariance(X_0:flt, X_1:flt, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_samp;
return the covariance sample value of groups
sql
covariance
pattern sql.covariance(X_0:int, X_1:int, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_samp;
return the covariance sample value of groups
sql
covariance
pattern sql.covariance(X_0:lng, X_1:lng, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_samp;
return the covariance sample value of groups
sql
covariance
pattern sql.covariance(X_0:sht, X_1:sht, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_samp;
return the covariance sample value of groups
sql
covariancep
pattern sql.covariancep(X_0:bte, X_1:bte, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_pop;
return the covariance population value of groups
sql
covariancep
pattern sql.covariancep(X_0:dbl, X_1:dbl, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_pop;
return the covariance population value of groups
sql
covariancep
pattern sql.covariancep(X_0:flt, X_1:flt, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_pop;
return the covariance population value of groups
sql
covariancep
pattern sql.covariancep(X_0:int, X_1:int, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_pop;
return the covariance population value of groups
sql
covariancep
pattern sql.covariancep(X_0:lng, X_1:lng, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_pop;
return the covariance population value of groups
sql
covariancep
pattern sql.covariancep(X_0:sht, X_1:sht, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):dbl 
SQLcovar_pop;
return the covariance population value of groups
sql
createorderindex
unsafe pattern sql.createorderindex(X_0:str, X_1:str, X_2:str):void 
sql_createorderindex;
Instantiate the order index on a column
sql
createstrimps
unsafe pattern sql.createstrimps(X_0:str, X_1:str, X_2:str):void 
sql_createstrimps;
Instantiate the strimps index on a column
sql
cume_dist
pattern sql.cume_dist(X_0:any_1, X_1:bit, X_2:bit):dbl 
SQLcume_dist;
return the accumulated distribution of the number of rows per group to the total number of partition rows
sql
current_time
pattern sql.current_time():daytime 
SQLcurrent_daytime;
Get the clients current daytime
sql
current_timestamp
pattern sql.current_timestamp():timestamp 
SQLcurrent_timestamp;
Get the clients current timestamp
sql
date_trunc
command sql.date_trunc(X_0:str, X_1:bat[:timestamp]):bat[:timestamp] 
bat_date_trunc;
Truncate a timestamp to (millennium, century,decade,year,quarter,month,week,day,hour,minute,second, milliseconds,microseconds)
sql
date_trunc
command sql.date_trunc(X_0:str, X_1:timestamp):timestamp 
date_trunc;
Truncate a timestamp to (millennium, century,decade,year,quarter,month,week,day,hour,minute,second, milliseconds,microseconds)
sql
db_users
pattern sql.db_users():bat[:str] 
db_users_wrap;
return table of users with sql scenario
sql
delete
unsafe pattern sql.delete(X_0:int, X_1:str, X_2:str, X_3:any):int 
mvc_delete_wrap;
Delete a row from a table. Returns sequence number for order dependence.
sql
delta
command sql.delta(X_0:bat[:any_3], X_1:bat[:oid], X_2:bat[:any_3]):bat[:any_3] 
DELTAbat;
Return column bat with delta's applied.
sql
deltas
pattern sql.deltas(X_0:str) (X_1:bat[:int], X_2:bat[:lng], X_3:bat[:lng], X_4:bat[:lng], X_5:bat[:lng], X_6:bat[:lng], X_7:bat[:int]) 
mvc_delta_values;
Return the delta values sizes of all columns of the schema's tables, plus the current transaction level
sql
deltas
pattern sql.deltas(X_0:str, X_1:str) (X_2:bat[:int], X_3:bat[:lng], X_4:bat[:lng], X_5:bat[:lng], X_6:bat[:lng], X_7:bat[:lng], X_8:bat[:int]) 
mvc_delta_values;
Return the delta values sizes from the table's columns, plus the current transaction level
sql
deltas
pattern sql.deltas(X_0:str, X_1:str, X_2:str) (X_3:bat[:int], X_4:bat[:lng], X_5:bat[:lng], X_6:bat[:lng], X_7:bat[:lng], X_8:bat[:lng], X_9:bat[:int]) 
mvc_delta_values;
Return the delta values sizes of a column, plus the current transaction level
sql
dense_rank
pattern sql.dense_rank(X_0:any_1, X_1:bit, X_2:bit):int 
SQLdense_rank;
return the densely ranked groups
sql
depend
unsafe pattern sql.depend(X_0:str, X_1:str, X_2:lng):void 
mvc_add_dependency_change;
Set dml dependency on current transaction for a table.
sql
deregister
unsafe pattern sql.deregister():int 
RAstatementEnd;
Finish running transaction
sql
diff
pattern sql.diff(X_0:any_1):bit 
SQLdiff;
return true if cur != prev row
sql
diff
pattern sql.diff(X_0:bit, X_1:any_1):bit 
SQLdiff;
return true if cur != prev row
sql
drop_hash
unsafe pattern sql.drop_hash(X_0:str, X_1:str):void 
SQLdrop_hash;
Drop hash indices for the given table
sql
droporderindex
unsafe pattern sql.droporderindex(X_0:str, X_1:str, X_2:str):void 
sql_droporderindex;
Drop the order index on a column
sql
dump_cache
pattern sql.dump_cache() (X_0:bat[:str], X_1:bat[:int]) 
dump_cache;
dump the content of the query cache
sql
dump_opt_stats
pattern sql.dump_opt_stats() (X_0:bat[:str], X_1:bat[:int]) 
dump_opt_stats;
dump the optimizer rewrite statistics
sql
dump_trace
pattern sql.dump_trace() (X_0:bat[:lng], X_1:bat[:str], X_2:bat[:str]) 
dump_trace;
dump the trace statistics
sql
emptybind
pattern sql.emptybind(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int) (X_5:bat[:oid], X_6:bat[:any_1]) 
mvc_bind_wrap;
(empty)
sql
emptybind
pattern sql.emptybind(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int):bat[:any_1] 
mvc_bind_wrap;
(empty)
sql
emptybind
pattern sql.emptybind(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int, X_5:int, X_6:int) (X_7:bat[:oid], X_8:bat[:any_1]) 
mvc_bind_wrap;
(empty)
sql
emptybind
pattern sql.emptybind(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int, X_5:int, X_6:int):bat[:any_1] 
mvc_bind_wrap;
(empty)
sql
emptybindidx
pattern sql.emptybindidx(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int) (X_5:bat[:oid], X_6:bat[:any_1]) 
mvc_bind_idxbat_wrap;
(empty)
sql
emptybindidx
pattern sql.emptybindidx(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int):bat[:any_1] 
mvc_bind_idxbat_wrap;
(empty)
sql
emptybindidx
pattern sql.emptybindidx(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int, X_5:int, X_6:int) (X_7:bat[:oid], X_8:bat[:any_1]) 
mvc_bind_idxbat_wrap;
(empty)
sql
emptybindidx
pattern sql.emptybindidx(X_0:int, X_1:str, X_2:str, X_3:str, X_4:int, X_5:int, X_6:int):bat[:any_1] 
mvc_bind_idxbat_wrap;
(empty)
sql
epilogue
command sql.epilogue():void 
SQLepilogue;
(empty)
sql
eval
unsafe pattern sql.eval(X_0:str):void 
SQLstatement;
Compile and execute a single sql statement
sql
eval
unsafe pattern sql.eval(X_0:str, X_1:bit):void 
SQLstatement;
Compile and execute a single sql statement (and optionaly set the output to columnar format)
sql
evalAlgebra
unsafe pattern sql.evalAlgebra(X_0:str, X_1:bit):void 
RAstatement;
Compile and execute a single 'relational algebra' statement
sql
exportChunk
unsafe pattern sql.exportChunk(X_0:streams, X_1:int):void 
mvc_export_chunk_wrap;
Export a chunk of the result set (in order) to stream s
sql
exportChunk
unsafe pattern sql.exportChunk(X_0:streams, X_1:int, X_2:int, X_3:int):void 
mvc_export_chunk_wrap;
Export a chunk of the result set (in order) to stream s
sql
exportHead
unsafe pattern sql.exportHead(X_0:streams, X_1:int):void 
mvc_export_head_wrap;
Export a result (in order) to stream s
sql
exportOperation
unsafe pattern sql.exportOperation():void 
mvc_export_operation_wrap;
Export result of schema/transaction queries
sql
exportResult
unsafe pattern sql.exportResult(X_0:streams, X_1:int):void 
mvc_export_result_wrap;
Export a result (in order) to stream s
sql
export_table
unsafe pattern sql.export_table(X_0:str, X_1:str, X_2:str, X_3:str, X_4:str, X_5:str, X_6:int, X_7:bat[:str], X_8:bat[:str], X_9:bat[:str], X_10:bat[:int], X_11:bat[:int], X_12:any...):int 
mvc_export_row_wrap;
Prepare a table result set for the COPY INTO stream
sql
export_table
unsafe pattern sql.export_table(X_0:str, X_1:str, X_2:str, X_3:str, X_4:str, X_5:str, X_6:int, X_7:bat[:str], X_8:bat[:str], X_9:bat[:str], X_10:bat[:int], X_11:bat[:int], X_12:bat[:any]...):int 
mvc_export_table_wrap;
Prepare a table result set for the COPY INTO stream
sql
first_value
pattern sql.first_value(X_0:any_1, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):any_1 
SQLfirst_value;
return the first value of groups
sql
getVariable
pattern sql.getVariable(X_0:int, X_1:str, X_2:str):any_1 
getVariable;
Get the value of a session variable
sql
getVersion
command sql.getVersion(X_0:int):lng 
mvc_getVersion;
Return the database version identifier for a client.
sql
get_value
pattern sql.get_value(X_0:str, X_1:str):lng 
mvc_get_value;
return the current value of the sequence (ie the next to be used value)
sql
grow
pattern sql.grow(X_0:bat[:oid], X_1:any_1):int 
mvc_grow_wrap;
Resize the tid column of a declared table.
sql
hot_snapshot
unsafe pattern sql.hot_snapshot(X_0:str):void 
SQLhot_snapshot;
Write db snapshot to the given tar(.gz) file
sql
hot_snapshot
unsafe pattern sql.hot_snapshot(X_0:str, X_1:bit):void 
SQLhot_snapshot_wrap;
Write db snapshot to the given tar(.gz/.lz4/.bz/.xz) file on either server or client
sql
importColumn
pattern sql.importColumn(X_0:str, X_1:bit, X_2:str, X_3:int, X_4:oid) (X_5:bat[:any], X_6:oid) 
mvc_bin_import_column_wrap;
Import a column from the given file
sql
importTable
unsafe pattern sql.importTable(X_0:str, X_1:str, X_2:int, X_3:bit, X_4:str...):bat[:any]... 
mvc_bin_import_table_wrap;
Import a table from the files (fname)
sql
include
unsafe pattern sql.include(X_0:str):void 
SQLinclude;
Compile and execute a sql statements on the file
sql
index
command sql.index(X_0:str, X_1:bit):bte 
STRindex_bte;
Return the offsets as an index bat
sql
index
command sql.index(X_0:str, X_1:bit):int 
STRindex_int;
Return the offsets as an index bat
sql
index
command sql.index(X_0:str, X_1:bit):sht 
STRindex_sht;
Return the offsets as an index bat
sql
lag
pattern sql.lag(X_0:any_1, X_1:any, X_2:any_1, X_3:bit, X_4:bit):any_1 
SQLlag;
return the value in the previous 'l' row in the partition or 'd' if non existent
sql
lag
pattern sql.lag(X_0:any_1, X_1:any, X_2:bit, X_3:bit):any_1 
SQLlag;
return the value in the previous 'l' row in the partition or NULL if non existent
sql
lag
pattern sql.lag(X_0:any_1, X_1:bit, X_2:bit):any_1 
SQLlag;
return the value in the previous row in the partition or NULL if non existent
sql
last_value
pattern sql.last_value(X_0:any_1, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):any_1 
SQLlast_value;
return the last value of groups
sql
lead
pattern sql.lead(X_0:any_1, X_1:any, X_2:any_1, X_3:bit, X_4:bit):any_1 
SQLlead;
return the value in the next 'l' row in the partition or 'd' if non existent
sql
lead
pattern sql.lead(X_0:any_1, X_1:any, X_2:bit, X_3:bit):any_1 
SQLlead;
return the value in the next 'l' row in the partition or NULL if non existent
sql
lead
pattern sql.lead(X_0:any_1, X_1:bit, X_2:bit):any_1 
SQLlead;
return the value in the next row in the partition or NULL if non existent
sql
logfile
unsafe pattern sql.logfile(X_0:str):void 
mvc_logfile;
Enable/disable saving the sql statement traces
sql
max
pattern sql.max(X_0:any_1, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):any_1 
SQLmax;
return the maximum of groups
sql
min
pattern sql.min(X_0:any_1, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):any_1 
SQLmin;
return the minimum of groups
sql
ms_trunc
command sql.ms_trunc(X_0:dbl, X_1:int):dbl 
dbl_trunc_wrap;
truncate the floating point v to r digits behind the dot (if r < 0, before the dot)
sql
ms_trunc
command sql.ms_trunc(X_0:flt, X_1:int):flt 
flt_trunc_wrap;
truncate the floating point v to r digits behind the dot (if r < 0, before the dot)
sql
mvc
pattern sql.mvc():int 
SQLmvc;
Get the multiversion catalog context. @Needed for correct statement dependencies@(ie sql.update, should be after sql.bind in concurrent execution)
sql
next_value
unsafe pattern sql.next_value(X_0:str, X_1:str):lng 
mvc_next_value;
return the next value of the sequence
sql
nth_value
pattern sql.nth_value(X_0:any_1, X_1:lng, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):any_1 
SQLnth_value;
return the nth value of each group
sql
ntile
pattern sql.ntile(X_0:any, X_1:any_1, X_2:bit, X_3:bit):any_1 
SQLntile;
return the groups divided as equally as possible
sql
optimizer_updates
pattern sql.optimizer_updates():void 
SQLoptimizersUpdate;
(empty)
sql
optimizers
command sql.optimizers() (X_0:bat[:str], X_1:bat[:str], X_2:bat[:str]) 
getPipeCatalog;
(empty)
sql
password
pattern sql.password(X_0:str):str 
db_password_wrap;
Return password hash of user
sql
percent_rank
pattern sql.percent_rank(X_0:any_1, X_1:bit, X_2:bit):dbl 
SQLpercent_rank;
return the percentage into the total number of groups for each row
sql
predicate
unsafe pattern sql.predicate(X_0:str, X_1:str, X_2:str):void 
mvc_add_column_predicate;
Add predicate on current transaction for a table column.
sql
prelude
pattern sql.prelude():void 
SQLprelude;
(empty)
sql
prepared_statements
pattern sql.prepared_statements() (X_0:bat[:int], X_1:bat[:str], X_2:bat[:int], X_3:bat[:str], X_4:bat[:timestamp]) 
SQLsession_prepared_statements;
Available prepared statements in the current session
sql
prepared_statements_args
pattern sql.prepared_statements_args() (X_0:bat[:int], X_1:bat[:str], X_2:bat[:int], X_3:bat[:int], X_4:bat[:bte], X_5:bat[:int], X_6:bat[:str], X_7:bat[:str], X_8:bat[:str]) 
SQLsession_prepared_statements_args;
Available prepared statements' arguments in the current session
sql
prod
pattern sql.prod(X_0:bte, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):lng 
SQLprod;
return the product of groups
sql
prod
pattern sql.prod(X_0:dbl, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLprod;
return the product of groups
sql
prod
pattern sql.prod(X_0:flt, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLprod;
return the product of groups
sql
prod
pattern sql.prod(X_0:flt, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):flt 
SQLprod;
return the product of groups
sql
prod
pattern sql.prod(X_0:int, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):lng 
SQLprod;
return the product of groups
sql
prod
pattern sql.prod(X_0:lng, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):lng 
SQLprod;
return the product of groups
sql
prod
pattern sql.prod(X_0:sht, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):lng 
SQLprod;
return the product of groups
sql
project
command sql.project(X_0:bat[:oid], X_1:bat[:oid], X_2:bat[:oid]):bat[:oid] 
BATleftproject;
Last step of a left outer join, ie project the inner join (l,r) over the left input side (col)
sql
projectdelta
command sql.projectdelta(X_0:bat[:oid], X_1:bat[:any_3], X_2:bat[:oid], X_3:bat[:any_3]):bat[:any_3] 
DELTAproject;
Return column bat with delta's applied.
sql
querylog_calls
pattern sql.querylog_calls() (X_0:bat[:oid], X_1:bat[:timestamp], X_2:bat[:timestamp], X_3:bat[:str], X_4:bat[:lng], X_5:bat[:lng], X_6:bat[:lng], X_7:bat[:int], X_8:bat[:int]) 
sql_querylog_calls;
Obtain the query log calls
sql
querylog_catalog
pattern sql.querylog_catalog() (X_0:bat[:oid], X_1:bat[:str], X_2:bat[:timestamp], X_3:bat[:str], X_4:bat[:str], X_5:bat[:str], X_6:bat[:int], X_7:bat[:lng]) 
sql_querylog_catalog;
Obtain the query log catalog
sql
querylog_disable
unsafe command sql.querylog_disable():void 
QLOGdisable;
(empty)
sql
querylog_empty
unsafe pattern sql.querylog_empty():void 
sql_querylog_empty;
(empty)
sql
querylog_enable
unsafe command sql.querylog_enable():void 
QLOGenable;
(empty)
sql
querylog_enable
unsafe command sql.querylog_enable(X_0:int):void 
QLOGenableThreshold;
(empty)
sql
rank
pattern sql.rank(X_0:any_1, X_1:bit, X_2:bit):int 
SQLrank;
return the ranked groups
sql
register
unsafe pattern sql.register(X_0:str, X_1:str, X_2:str, X_3:str):int 
RAstatement2;
(empty)
sql
register
unsafe pattern sql.register(X_0:str, X_1:str, X_2:str, X_3:str, X_4:str):int 
RAstatement2;
Compile the relational statement (rel_smt) and register it as mal function, mod.fname(signature)
sql
restart
unsafe pattern sql.restart(X_0:str, X_1:str, X_2:lng):lng 
mvc_restart_seq;
restart the sequence with value start
sql
resultSet
unsafe pattern sql.resultSet(X_0:bat[:str], X_1:bat[:str], X_2:bat[:str], X_3:bat[:int], X_4:bat[:int], X_5:any...):int 
mvc_row_result_wrap;
Prepare a table result set for the client front-end
sql
resultSet
unsafe pattern sql.resultSet(X_0:str, X_1:str, X_2:str, X_3:int, X_4:int, X_5:int, X_6:any):int 
mvc_scalar_value_wrap;
Prepare a table result set for the client front-end.
sql
resultSet
unsafe pattern sql.resultSet(X_0:bat[:str], X_1:bat[:str], X_2:bat[:str], X_3:bat[:int], X_4:bat[:int], X_5:bat[:any]...):int 
mvc_table_result_wrap;
Prepare a table result set for the client in default CSV format
sql
resume_log_flushing
unsafe pattern sql.resume_log_flushing():void 
SQLresume_log_flushing;
Resume WAL log flushing
sql
row_number
pattern sql.row_number(X_0:any_1, X_1:bit, X_2:bit):int 
SQLrow_number;
return the row_numer-ed groups
sql
rt_credentials
pattern sql.rt_credentials(X_0:str) (X_1:bat[:str], X_2:bat[:str], X_3:bat[:str]) 
sql_rt_credentials_wrap;
Return the remote table credentials for the given table
sql
sessions
pattern sql.sessions() (X_0:bat[:int], X_1:bat[:str], X_2:bat[:timestamp], X_3:bat[:timestamp], X_4:bat[:str], X_5:bat[:int], X_6:bat[:int], X_7:bat[:int], X_8:bat[:int]) 
sql_sessions_wrap;
SQL export table of active sessions, their timeouts and idle status
sql
setVariable
unsafe pattern sql.setVariable(X_0:int, X_1:str, X_2:str, X_3:any_1):int 
setVariable;
Set the value of a session variable
sql
set_protocol
unsafe pattern sql.set_protocol(X_0:int):int 
SQLset_protocol;
Configures the result set protocol
sql
shutdown
unsafe pattern sql.shutdown(X_0:bte):str 
SQLshutdown_wrap;
(empty)
sql
shutdown
unsafe pattern sql.shutdown(X_0:bte, X_1:bit):str 
SQLshutdown_wrap;
(empty)
sql
shutdown
unsafe pattern sql.shutdown(X_0:int):str 
SQLshutdown_wrap;
(empty)
sql
shutdown
unsafe pattern sql.shutdown(X_0:int, X_1:bit):str 
SQLshutdown_wrap;
(empty)
sql
shutdown
unsafe pattern sql.shutdown(X_0:sht):str 
SQLshutdown_wrap;
(empty)
sql
shutdown
unsafe pattern sql.shutdown(X_0:sht, X_1:bit):str 
SQLshutdown_wrap;
(empty)
sql
sql_variables
pattern sql.sql_variables() (X_0:bat[:str], X_1:bat[:str], X_2:bat[:str], X_3:bat[:str]) 
sql_variables;
return the table with session variables
sql
statistics
pattern sql.statistics() (X_0:bat[:int], X_1:bat[:str], X_2:bat[:str], X_3:bat[:str], X_4:bat[:str], X_5:bat[:int], X_6:bat[:lng], X_7:bat[:bit], X_8:bat[:bit], X_9:bat[:str], X_10:bat[:str], X_11:bat[:bit], X_12:bat[:bit]) 
sql_statistics;
return a table with statistics information
sql
statistics
pattern sql.statistics(X_0:str) (X_1:bat[:int], X_2:bat[:str], X_3:bat[:str], X_4:bat[:str], X_5:bat[:str], X_6:bat[:int], X_7:bat[:lng], X_8:bat[:bit], X_9:bat[:bit], X_10:bat[:str], X_11:bat[:str], X_12:bat[:bit], X_13:bat[:bit]) 
sql_statistics;
return a table with statistics information for a particular schema
sql
statistics
pattern sql.statistics(X_0:str, X_1:str) (X_2:bat[:int], X_3:bat[:str], X_4:bat[:str], X_5:bat[:str], X_6:bat[:str], X_7:bat[:int], X_8:bat[:lng], X_9:bat[:bit], X_10:bat[:bit], X_11:bat[:str], X_12:bat[:str], X_13:bat[:bit], X_14:bat[:bit]) 
sql_statistics;
return a table with statistics information for a particular table
sql
statistics
pattern sql.statistics(X_0:str, X_1:str, X_2:str) (X_3:bat[:int], X_4:bat[:str], X_5:bat[:str], X_6:bat[:str], X_7:bat[:str], X_8:bat[:int], X_9:bat[:lng], X_10:bat[:bit], X_11:bat[:bit], X_12:bat[:str], X_13:bat[:str], X_14:bat[:bit], X_15:bat[:bit]) 
sql_statistics;
return a table with statistics information for a particular column
sql
stdev
pattern sql.stdev(X_0:bte, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_samp;
return the standard deviation sample of groups
sql
stdev
pattern sql.stdev(X_0:dbl, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_samp;
return the standard deviation sample of groups
sql
stdev
pattern sql.stdev(X_0:flt, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_samp;
return the standard deviation sample of groups
sql
stdev
pattern sql.stdev(X_0:int, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_samp;
return the standard deviation sample of groups
sql
stdev
pattern sql.stdev(X_0:lng, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_samp;
return the standard deviation sample of groups
sql
stdev
pattern sql.stdev(X_0:sht, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_samp;
return the standard deviation sample of groups
sql
stdevp
pattern sql.stdevp(X_0:bte, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_pop;
return the standard deviation population of groups
sql
stdevp
pattern sql.stdevp(X_0:dbl, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_pop;
return the standard deviation population of groups
sql
stdevp
pattern sql.stdevp(X_0:flt, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_pop;
return the standard deviation population of groups
sql
stdevp
pattern sql.stdevp(X_0:int, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_pop;
return the standard deviation population of groups
sql
stdevp
pattern sql.stdevp(X_0:lng, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_pop;
return the standard deviation population of groups
sql
stdevp
pattern sql.stdevp(X_0:sht, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLstddev_pop;
return the standard deviation population of groups
sql
stop_vacuum
unsafe pattern sql.stop_vacuum(X_0:str, X_1:str, X_2:str):void 
SQLstr_column_stop_vacuum;
stop auto vacuum
sql
storage
pattern sql.storage() (X_0:bat[:str], X_1:bat[:str], X_2:bat[:str], X_3:bat[:str], X_4:bat[:str], X_5:bat[:str], X_6:bat[:lng], X_7:bat[:int], X_8:bat[:lng], X_9:bat[:lng], X_10:bat[:lng], X_11:bat[:bit], X_12:bat[:lng], X_13:bat[:bit], X_14:bat[:bit], X_15:bat[:bit], X_16:bat[:lng]) 
sql_storage;
return a table with storage information 
sql
storage
pattern sql.storage(X_0:str) (X_1:bat[:str], X_2:bat[:str], X_3:bat[:str], X_4:bat[:str], X_5:bat[:str], X_6:bat[:str], X_7:bat[:lng], X_8:bat[:int], X_9:bat[:lng], X_10:bat[:lng], X_11:bat[:lng], X_12:bat[:bit], X_13:bat[:lng], X_14:bat[:bit], X_15:bat[:bit], X_16:bat[:bit], X_17:bat[:lng]) 
sql_storage;
return a table with storage information for a particular schema 
sql
storage
pattern sql.storage(X_0:str, X_1:str) (X_2:bat[:str], X_3:bat[:str], X_4:bat[:str], X_5:bat[:str], X_6:bat[:str], X_7:bat[:str], X_8:bat[:lng], X_9:bat[:int], X_10:bat[:lng], X_11:bat[:lng], X_12:bat[:lng], X_13:bat[:bit], X_14:bat[:lng], X_15:bat[:bit], X_16:bat[:bit], X_17:bat[:bit], X_18:bat[:lng]) 
sql_storage;
return a table with storage information for a particular table
sql
storage
pattern sql.storage(X_0:str, X_1:str, X_2:str) (X_3:bat[:str], X_4:bat[:str], X_5:bat[:str], X_6:bat[:str], X_7:bat[:str], X_8:bat[:str], X_9:bat[:lng], X_10:bat[:int], X_11:bat[:lng], X_12:bat[:lng], X_13:bat[:lng], X_14:bat[:bit], X_15:bat[:lng], X_16:bat[:bit], X_17:bat[:bit], X_18:bat[:bit], X_19:bat[:lng]) 
sql_storage;
return a table with storage information for a particular column
sql
str_group_concat
pattern sql.str_group_concat(X_0:str, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):str 
SQLstrgroup_concat;
return the string concatenation of groups
sql
str_group_concat
pattern sql.str_group_concat(X_0:str, X_1:str, X_2:bit, X_3:bit, X_4:int, X_5:oid, X_6:oid):str 
SQLstrgroup_concat;
return the string concatenation of groups with a custom separator
sql
strings
command sql.strings(X_0:str):str 
STRstrings;
Return the strings
sql
subdelta
command sql.subdelta(X_0:bat[:oid], X_1:bat[:oid], X_2:bat[:oid], X_3:bat[:oid]):bat[:oid] 
DELTAsub;
Return a single bat of selected delta.
sql
sum
pattern sql.sum(X_0:bte, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):lng 
SQLsum;
return the sum of groups
sql
sum
pattern sql.sum(X_0:dbl, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLsum;
return the sum of groups
sql
sum
pattern sql.sum(X_0:flt, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLsum;
return the sum of groups
sql
sum
pattern sql.sum(X_0:flt, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):flt 
SQLsum;
return the sum of groups
sql
sum
pattern sql.sum(X_0:int, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):int 
SQLsum;
return the sum of groups
sql
sum
pattern sql.sum(X_0:int, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):lng 
SQLsum;
return the sum of groups
sql
sum
pattern sql.sum(X_0:lng, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):lng 
SQLsum;
return the sum of groups
sql
sum
pattern sql.sum(X_0:sht, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):lng 
SQLsum;
return the sum of groups
sql
suspend_log_flushing
unsafe pattern sql.suspend_log_flushing():void 
SQLsuspend_log_flushing;
Suspend WAL log flushing
sql
tid
pattern sql.tid(X_0:int, X_1:str, X_2:str):bat[:oid] 
SQLtid;
Return a column with the valid tuple identifiers associated with the table sname.tname.
sql
tid
pattern sql.tid(X_0:int, X_1:str, X_2:str, X_3:int, X_4:int):bat[:oid] 
SQLtid;
Return the tables tid column.
sql
transaction_begin
unsafe pattern sql.transaction_begin(X_0:int, X_1:str):void 
SQLtransaction_begin;
A transaction statement (type can be commit,release,rollback or start)
sql
transaction_commit
unsafe pattern sql.transaction_commit(X_0:int, X_1:str):void 
SQLtransaction_commit;
A transaction statement (type can be commit,release,rollback or start)
sql
transaction_release
unsafe pattern sql.transaction_release(X_0:int, X_1:str):void 
SQLtransaction_release;
A transaction statement (type can be commit,release,rollback or start)
sql
transaction_rollback
unsafe pattern sql.transaction_rollback(X_0:int, X_1:str):void 
SQLtransaction_rollback;
A transaction statement (type can be commit,release,rollback or start)
sql
unionfunc
pattern sql.unionfunc(X_0:str, X_1:str, X_2:any...):any... 
SQLunionfunc;
(empty)
sql
update
pattern sql.update(X_0:int, X_1:str, X_2:str, X_3:str, X_4:any, X_5:any):int 
mvc_update_wrap;
Update the values of the column tname.cname. Returns sequence number for order dependence)
sql
update_schemas
unsafe pattern sql.update_schemas():void 
SYSupdate_schemas;
Procedure triggered on update of the sys.schemas table
sql
update_tables
unsafe pattern sql.update_tables():void 
SYSupdate_tables;
Procedure triggered on update of the sys._tables table
sql
vacuum
unsafe pattern sql.vacuum(X_0:str, X_1:str, X_2:str, X_3:int):void 
SQLstr_column_auto_vacuum;
auto vacuum string column with interval(sec)
sql
vacuum
unsafe pattern sql.vacuum(X_0:str, X_1:str, X_2:str):void 
SQLstr_column_vacuum;
vacuum a string column
sql
variance
pattern sql.variance(X_0:bte, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_samp;
return the variance sample of groups
sql
variance
pattern sql.variance(X_0:dbl, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_samp;
return the variance sample of groups
sql
variance
pattern sql.variance(X_0:flt, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_samp;
return the variance sample of groups
sql
variance
pattern sql.variance(X_0:int, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_samp;
return the variance sample of groups
sql
variance
pattern sql.variance(X_0:lng, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_samp;
return the variance sample of groups
sql
variance
pattern sql.variance(X_0:sht, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_samp;
return the variance sample of groups
sql
variancep
pattern sql.variancep(X_0:bte, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_pop;
return the variance population of groups
sql
variancep
pattern sql.variancep(X_0:dbl, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_pop;
return the variance population of groups
sql
variancep
pattern sql.variancep(X_0:flt, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_pop;
return the variance population of groups
sql
variancep
pattern sql.variancep(X_0:int, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_pop;
return the variance population of groups
sql
variancep
pattern sql.variancep(X_0:lng, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_pop;
return the variance population of groups
sql
variancep
pattern sql.variancep(X_0:sht, X_1:bit, X_2:bit, X_3:int, X_4:oid, X_5:oid):dbl 
SQLvar_pop;
return the variance population of groups
sql
window_bound
pattern sql.window_bound(X_0:any_1, X_1:int, X_2:int, X_3:int, X_4:bte):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:any_1, X_1:int, X_2:int, X_3:int, X_4:dbl):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:any_1, X_1:int, X_2:int, X_3:int, X_4:flt):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:any_1, X_1:int, X_2:int, X_3:int, X_4:int):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:any_1, X_1:int, X_2:int, X_3:int, X_4:lng):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:any_1, X_1:int, X_2:int, X_3:int, X_4:sht):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:bit, X_1:any_1, X_2:int, X_3:int, X_4:int, X_5:bte):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:bit, X_1:any_1, X_2:int, X_3:int, X_4:int, X_5:dbl):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:bit, X_1:any_1, X_2:int, X_3:int, X_4:int, X_5:flt):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:bit, X_1:any_1, X_2:int, X_3:int, X_4:int, X_5:int):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:bit, X_1:any_1, X_2:int, X_3:int, X_4:int, X_5:lng):oid 
SQLwindow_bound;
computes window ranges for each row
sql
window_bound
pattern sql.window_bound(X_0:bit, X_1:any_1, X_2:int, X_3:int, X_4:int, X_5:sht):oid 
SQLwindow_bound;
computes window ranges for each row
sqlcatalog
alter_add_range_partition
pattern sqlcatalog.alter_add_range_partition(X_0:str, X_1:str, X_2:str, X_3:str, X_4:any_1, X_5:any_1, X_6:bit, X_7:int):void 
SQLalter_add_range_partition;
Catalog operation alter_add_range_partition
sqlcatalog
alter_add_table
pattern sqlcatalog.alter_add_table(X_0:str, X_1:str, X_2:str, X_3:str, X_4:int):void 
SQLalter_add_table;
Catalog operation alter_add_table
sqlcatalog
alter_add_value_partition
pattern sqlcatalog.alter_add_value_partition(X_0:str, X_1:str, X_2:str, X_3:str, X_4:bit, X_5:int):void 
SQLalter_add_value_partition;
Catalog operation alter_add_value_partition
sqlcatalog
alter_add_value_partition
pattern sqlcatalog.alter_add_value_partition(X_0:str, X_1:str, X_2:str, X_3:str, X_4:bit, X_5:int, X_6:any...):void 
SQLalter_add_value_partition;
Catalog operation alter_add_value_partition
sqlcatalog
alter_del_table
pattern sqlcatalog.alter_del_table(X_0:str, X_1:str, X_2:str, X_3:str, X_4:int):void 
SQLalter_del_table;
Catalog operation alter_del_table
sqlcatalog
alter_seq
pattern sqlcatalog.alter_seq(X_0:str, X_1:str, X_2:ptr, X_3:bat[:lng]):void 
SQLalter_seq;
Catalog operation alter_seq
sqlcatalog
alter_seq
pattern sqlcatalog.alter_seq(X_0:str, X_1:str, X_2:ptr, X_3:lng):void 
SQLalter_seq;
Catalog operation alter_seq
sqlcatalog
alter_set_table
pattern sqlcatalog.alter_set_table(X_0:str, X_1:str, X_2:int):void 
SQLalter_set_table;
Catalog operation alter_set_table
sqlcatalog
alter_table
pattern sqlcatalog.alter_table(X_0:str, X_1:str, X_2:ptr, X_3:int):void 
SQLalter_table;
Catalog operation alter_table
sqlcatalog
alter_user
pattern sqlcatalog.alter_user(X_0:str, X_1:str, X_2:int, X_3:str, X_4:str, X_5:str):void 
SQLalter_user;
Catalog operation alter_user
sqlcatalog
comment_on
pattern sqlcatalog.comment_on(X_0:int, X_1:str):void 
SQLcomment_on;
Catalog operation comment_on
sqlcatalog
create_function
pattern sqlcatalog.create_function(X_0:str, X_1:str, X_2:ptr, X_3:int):void 
SQLcreate_function;
Catalog operation create_function
sqlcatalog
create_role
pattern sqlcatalog.create_role(X_0:str, X_1:str, X_2:int):void 
SQLcreate_role;
Catalog operation create_role
sqlcatalog
create_schema
pattern sqlcatalog.create_schema(X_0:str, X_1:str, X_2:int):void 
SQLcreate_schema;
Catalog operation create_schema
sqlcatalog
create_seq
pattern sqlcatalog.create_seq(X_0:str, X_1:str, X_2:ptr, X_3:int):void 
SQLcreate_seq;
Catalog operation create_seq
sqlcatalog
create_table
pattern sqlcatalog.create_table(X_0:str, X_1:str, X_2:ptr, X_3:int):void 
SQLcreate_table;
Catalog operation create_table
sqlcatalog
create_trigger
pattern sqlcatalog.create_trigger(X_0:str, X_1:str, X_2:str, X_3:int, X_4:int, X_5:int, X_6:str, X_7:str, X_8:str, X_9:str, X_10:int):void 
SQLcreate_trigger;
Catalog operation create_trigger
sqlcatalog
create_type
pattern sqlcatalog.create_type(X_0:str, X_1:str, X_2:str):void 
SQLcreate_type;
Catalog operation create_type
sqlcatalog
create_user
pattern sqlcatalog.create_user(X_0:str, X_1:str, X_2:int, X_3:str, X_4:str, X_5:str):void 
SQLcreate_user;
Catalog operation create_user
sqlcatalog
create_view
pattern sqlcatalog.create_view(X_0:str, X_1:str, X_2:ptr, X_3:int, X_4:int):void 
SQLcreate_view;
Catalog operation create_view
sqlcatalog
drop_constraint
pattern sqlcatalog.drop_constraint(X_0:str, X_1:str, X_2:str, X_3:int, X_4:int):void 
SQLdrop_constraint;
Catalog operation drop_constraint
sqlcatalog
drop_function
pattern sqlcatalog.drop_function(X_0:str, X_1:str, X_2:int, X_3:int, X_4:int):void 
SQLdrop_function;
Catalog operation drop_function
sqlcatalog
drop_index
pattern sqlcatalog.drop_index(X_0:str, X_1:str, X_2:int):void 
SQLdrop_index;
Catalog operation drop_index
sqlcatalog
drop_role
pattern sqlcatalog.drop_role(X_0:str, X_1:int):void 
SQLdrop_role;
Catalog operation drop_role
sqlcatalog
drop_role
pattern sqlcatalog.drop_role(X_0:str, X_1:str, X_2:int):void 
SQLdrop_role;
Catalog operation drop_role
sqlcatalog
drop_schema
pattern sqlcatalog.drop_schema(X_0:str, X_1:int, X_2:int):void 
SQLdrop_schema;
Catalog operation drop_schema
sqlcatalog
drop_seq
pattern sqlcatalog.drop_seq(X_0:str, X_1:str, X_2:int):void 
SQLdrop_seq;
Catalog operation drop_seq
sqlcatalog
drop_table
pattern sqlcatalog.drop_table(X_0:str, X_1:str, X_2:int, X_3:int):void 
SQLdrop_table;
Catalog operation drop_table
sqlcatalog
drop_trigger
pattern sqlcatalog.drop_trigger(X_0:str, X_1:str, X_2:int):void 
SQLdrop_trigger;
Catalog operation drop_trigger
sqlcatalog
drop_type
pattern sqlcatalog.drop_type(X_0:str, X_1:str, X_2:int):void 
SQLdrop_type;
Catalog operation drop_type
sqlcatalog
drop_user
pattern sqlcatalog.drop_user(X_0:str, X_1:int):void 
SQLdrop_user;
Catalog operation drop_user
sqlcatalog
drop_user
pattern sqlcatalog.drop_user(X_0:str, X_1:str, X_2:int):void 
SQLdrop_user;
Catalog operation drop_user
sqlcatalog
drop_view
pattern sqlcatalog.drop_view(X_0:str, X_1:str, X_2:int, X_3:int):void 
SQLdrop_view;
Catalog operation drop_view
sqlcatalog
grant
pattern sqlcatalog.grant(X_0:str, X_1:str, X_2:str, X_3:int, X_4:str, X_5:int, X_6:int):void 
SQLgrant;
Catalog operation grant
sqlcatalog
grant_function
pattern sqlcatalog.grant_function(X_0:str, X_1:int, X_2:str, X_3:int, X_4:int, X_5:int):void 
SQLgrant_function;
Catalog operation grant_function
sqlcatalog
grant_roles
pattern sqlcatalog.grant_roles(X_0:str, X_1:str, X_2:int, X_3:int):void 
SQLgrant_roles;
Catalog operation grant_roles
sqlcatalog
rename_column
pattern sqlcatalog.rename_column(X_0:str, X_1:str, X_2:str, X_3:str):void 
SQLrename_column;
Catalog operation rename_column
sqlcatalog
rename_schema
pattern sqlcatalog.rename_schema(X_0:str, X_1:str):void 
SQLrename_schema;
Catalog operation rename_schema
sqlcatalog
rename_table
pattern sqlcatalog.rename_table(X_0:str, X_1:str, X_2:str, X_3:str):void 
SQLrename_table;
Catalog operation rename_table
sqlcatalog
rename_user
pattern sqlcatalog.rename_user(X_0:str, X_1:str, X_2:int):void 
SQLrename_user;
Catalog operation rename_user
sqlcatalog
revoke
pattern sqlcatalog.revoke(X_0:str, X_1:str, X_2:str, X_3:int, X_4:str, X_5:int, X_6:int):void 
SQLrevoke;
Catalog operation revoke
sqlcatalog
revoke_function
pattern sqlcatalog.revoke_function(X_0:str, X_1:int, X_2:str, X_3:int, X_4:int, X_5:int):void 
SQLrevoke_function;
Catalog operation revoke_function
sqlcatalog
revoke_roles
pattern sqlcatalog.revoke_roles(X_0:str, X_1:str, X_2:int, X_3:int):void 
SQLrevoke_roles;
Catalog operation revoke_roles
status
batStatistics
command status.batStatistics() (X_0:bat[:str], X_1:bat[:str]) 
SYSgdkEnv;
Show distribution of bats by kind
status
cpuStatistics
command status.cpuStatistics() (X_0:bat[:str], X_1:bat[:lng]) 
SYScpuStatistics;
Global cpu usage information
status
getThreads
command status.getThreads() (X_0:bat[:int], X_1:bat[:str]) 
SYSgdkThread;
Produce overview of active threads
status
ioStatistics
command status.ioStatistics() (X_0:bat[:str], X_1:bat[:lng]) 
SYSioStatistics;
Global IO activity information
status
memStatistics
command status.memStatistics() (X_0:bat[:str], X_1:bat[:lng]) 
SYSmemStatistics;
Global memory usage information
status
memUsage
command status.memUsage(X_0:lng) (X_1:bat[:str], X_2:bat[:lng]) 
SYSmem_usage;
Get a split-up of how much memory blocks are in use
status
mem_cursize
command status.mem_cursize():lng 
SYSgetmem_cursize;
The amount of physical swapspace in KB that is currently in use
status
mem_maxsize
command status.mem_maxsize():lng 
SYSgetmem_maxsize;
The maximum usable amount of physical swapspace in KB (target only)
status
mem_maxsize
command status.mem_maxsize(X_0:lng):void 
SYSsetmem_maxsize;
Set the maximum usable amount of physical swapspace in KB
status
vmStatistics
command status.vmStatistics(X_0:lng) (X_1:bat[:str], X_2:bat[:lng]) 
SYSvm_usage;
Get a split-up of how much virtual memory blocks are in use
status
vm_cursize
command status.vm_cursize():lng 
SYSgetvm_cursize;
The amount of logical VM space in KB that is currently in use
status
vm_maxsize
command status.vm_maxsize():lng 
SYSgetvm_maxsize;
The maximum usable amount of logical VM space in KB (target only)
status
vm_maxsize
command status.vm_maxsize(X_0:lng):void 
SYSsetvm_maxsize;
Set the maximum usable amount of physical swapspace in KB
str
ascii
command str.ascii(X_0:str):int 
STRascii;
Return unicode of head of string
str
endsWith
command str.endsWith(X_0:str, X_1:str):bit 
STRSuffix;
Suffix check.
str
epilogue
command str.epilogue():void 
STRepilogue;
(empty)
str
insert
command str.insert(X_0:str, X_1:int, X_2:int, X_3:str):str 
STRinsert;
Insert a string into another
str
length
command str.length(X_0:str):int 
STRLength;
Return the length of a string.
str
like
command str.like(X_0:str, X_1:str):bit 
STRlikewrap;
SQL pattern match function
str
like3
command str.like3(X_0:str, X_1:str, X_2:str):bit 
STRlikewrap3;
SQL pattern match function
str
locate
command str.locate(X_0:str, X_1:str):int 
STRlocate;
Locate the start position of a string
str
locate3
command str.locate3(X_0:str, X_1:str, X_2:int):int 
STRlocate3;
Locate the start position of a string
str
lpad
command str.lpad(X_0:str, X_1:int):str 
STRLpad;
Fill up a string to the given length prepending the whitespace character.
str
lpad3
command str.lpad3(X_0:str, X_1:int, X_2:str):str 
STRLpad3;
Fill up the first string to the given length prepending characters of the second string.
str
ltrim
command str.ltrim(X_0:str):str 
STRLtrim;
Strip whitespaces from start of a string.
str
ltrim2
command str.ltrim2(X_0:str, X_1:str):str 
STRLtrim2;
Remove the longest string containing only characters from the second string from the start of the first string.
str
nbytes
command str.nbytes(X_0:str):int 
STRBytes;
Return the string length in bytes.
str
prefix
command str.prefix(X_0:str, X_1:int):str 
STRprefix;
Extract the prefix of a given length
str
prelude
command str.prelude():void 
STRprelude;
(empty)
str
r_search
command str.r_search(X_0:str, X_1:str):int 
STRReverseStrSearch;
Reverse search for a substring. Returns@position, -1 if not found.
str
repeat
command str.repeat(X_0:str, X_1:int):str 
STRrepeat;
(empty)
str
replace
command str.replace(X_0:str, X_1:str, X_2:str, X_3:str):str 
PCREreplace_wrap;
(empty)
str
replace
command str.replace(X_0:str, X_1:str, X_2:str):str 
STRreplace;
Insert a string into another
str
rpad
command str.rpad(X_0:str, X_1:int):str 
STRRpad;
Fill up a string to the given length appending the whitespace character.
str
rpad3
command str.rpad3(X_0:str, X_1:int, X_2:str):str 
STRRpad3;
Fill up the first string to the given length appending characters of the second string.
str
rtrim
command str.rtrim(X_0:str):str 
STRRtrim;
Strip whitespaces from end of a string.
str
rtrim2
command str.rtrim2(X_0:str, X_1:str):str 
STRRtrim2;
Remove the longest string containing only characters from the second string from the end of the first string.
str
search
command str.search(X_0:str, X_1:str):int 
STRstrSearch;
Search for a substring. Returns@position, -1 if not found.
str
space
command str.space(X_0:int):str 
STRspace;
(empty)
str
splitpart
command str.splitpart(X_0:str, X_1:str, X_2:int):str 
STRsplitpart;
Split string on delimiter. Returns@given field (counting from one.)
str
startsWith
command str.startsWith(X_0:str, X_1:str):bit 
STRPrefix;
Prefix check.
str
str
command str.str(X_0:str):str 
STRtostr;
Noop routine.
str
string
command str.string(X_0:str, X_1:int):str 
STRTail;
Return the tail s[offset..n]@of a string s[0..n].
str
string3
command str.string3(X_0:str, X_1:int, X_2:int):str 
STRSubString;
Return substring s[offset..offset+count] of a string s[0..n]
str
stringleft
command str.stringleft(X_0:str, X_1:int):str 
STRprefix;
(empty)
str
stringright
command str.stringright(X_0:str, X_1:int):str 
STRsuffix;
(empty)
str
substitute
command str.substitute(X_0:str, X_1:str, X_2:str, X_3:bit):str 
STRSubstitute;
Substitute first occurrence of 'src' by@'dst'.  Iff repeated = true this is@repeated while 'src' can be found in the@result string. In order to prevent@recursion and result strings of unlimited@size, repeating is only done iff src is@not a substring of dst.
str
substring
command str.substring(X_0:str, X_1:int):str 
STRsubstringTail;
Extract the tail of a string
str
substring3
command str.substring3(X_0:str, X_1:int, X_2:int):str 
STRsubstring;
Extract a substring from str starting at start, for length len
str
suffix
command str.suffix(X_0:str, X_1:int):str 
STRsuffix;
Extract the suffix of a given length
str
toLower
command str.toLower(X_0:str):str 
STRLower;
Convert a string to lower case.
str
toUpper
command str.toUpper(X_0:str):str 
STRUpper;
Convert a string to upper case.
str
trim
command str.trim(X_0:str):str 
STRStrip;
Strip whitespaces around a string.
str
trim2
command str.trim2(X_0:str, X_1:str):str 
STRStrip2;
Remove the longest string containing only characters from the second string around the first string.
str
unicode
command str.unicode(X_0:int):str 
STRFromWChr;
convert a unicode to a character.
str
unicodeAt
command str.unicodeAt(X_0:str, X_1:int):int 
STRWChrAt;
get a unicode character@(as an int) from a string position.
streams
blocked
unsafe command streams.blocked(X_0:streams):streams 
open_block_streamwrap;
open a block based stream
streams
close
unsafe command streams.close(X_0:streams):void 
mnstr_close_streamwrap;
close and destroy the stream s
streams
create
unsafe command streams.create(X_0:streams, X_1:int):bstream 
bstream_create_wrapwrap;
create a buffered stream
streams
destroy
unsafe command streams.destroy(X_0:bstream):void 
bstream_destroy_wrapwrap;
destroy bstream
streams
flush
unsafe command streams.flush(X_0:streams):void 
mnstr_flush_streamwrap;
flush the stream
streams
openRead
unsafe command streams.openRead(X_0:str):streams 
mnstr_open_rastreamwrap;
open ascii file stream for reading
streams
openReadBytes
unsafe command streams.openReadBytes(X_0:str):streams 
mnstr_open_rstreamwrap;
open a file stream for reading
streams
openWrite
unsafe command streams.openWrite(X_0:str):streams 
mnstr_open_wastreamwrap;
open ascii file stream for writing
streams
openWriteBytes
unsafe command streams.openWriteBytes(X_0:str):streams 
mnstr_open_wstreamwrap;
open a file stream for writing
streams
read
unsafe command streams.read(X_0:bstream, X_1:int):int 
bstream_read_wrapwrap;
read at least size bytes into the buffer of s
streams
readInt
unsafe command streams.readInt(X_0:streams):int 
mnstr_readIntwrap;
read integer data from the stream
streams
readStr
unsafe command streams.readStr(X_0:streams):str 
mnstr_read_stringwrap;
read string data from the stream
streams
writeInt
unsafe command streams.writeInt(X_0:streams, X_1:int):void 
mnstr_writeIntwrap;
write data on the stream
streams
writeStr
unsafe command streams.writeStr(X_0:streams, X_1:str):void 
mnstr_write_stringwrap;
write data on the stream
sysmon
pause
unsafe pattern sysmon.pause(X_0:int):void 
SYSMONpause;
Suspend a running query
sysmon
pause
unsafe pattern sysmon.pause(X_0:lng):void 
SYSMONpause;
Suspend a running query
sysmon
pause
unsafe pattern sysmon.pause(X_0:sht):void 
SYSMONpause;
Suspend a running query
sysmon
queue
pattern sysmon.queue() (X_0:bat[:lng], X_1:bat[:int], X_2:bat[:str], X_3:bat[:timestamp], X_4:bat[:str], X_5:bat[:str], X_6:bat[:timestamp], X_7:bat[:int], X_8:bat[:int]) 
SYSMONqueue;
A queue of queries that are currently being executed or recently finished
sysmon
resume
unsafe pattern sysmon.resume(X_0:int):void 
SYSMONresume;
Resume processing of a query 
sysmon
resume
unsafe pattern sysmon.resume(X_0:lng):void 
SYSMONresume;
Resume processing of a query 
sysmon
resume
unsafe pattern sysmon.resume(X_0:sht):void 
SYSMONresume;
Resume processing of a query 
sysmon
stop
unsafe pattern sysmon.stop(X_0:int):void 
SYSMONstop;
Stop a single query a.s.a.p.
sysmon
stop
unsafe pattern sysmon.stop(X_0:lng):void 
SYSMONstop;
Stop a single query a.s.a.p.
sysmon
stop
unsafe pattern sysmon.stop(X_0:sht):void 
SYSMONstop;
Stop a single query a.s.a.p.
sysmon
user_statistics
pattern sysmon.user_statistics() (X_0:bat[:str], X_1:bat[:lng], X_2:bat[:lng], X_3:bat[:timestamp], X_4:bat[:timestamp], X_5:bat[:lng], X_6:bat[:str]) 
SYSMONstatistics;
(empty)
tokenizer
append
command tokenizer.append(X_0:str):oid 
TKNZRappend;
tokenize a new string and append it to the tokenizer (duplicate elimination is performed)
tokenizer
close
command tokenizer.close():void 
TKNZRclose;
close the current tokenizer store
tokenizer
depositFile
command tokenizer.depositFile(X_0:str):void 
TKNZRdepositFile;
batch insertion from a file of strings to tokenize, each string is separated by a new line
tokenizer
getCardinality
command tokenizer.getCardinality():bat[:lng] 
TKNZRgetCardinality;
debugging function that returns the unique tokens at each level
tokenizer
getCount
command tokenizer.getCount():bat[:lng] 
TKNZRgetCount;
debugging function that returns the size of the bats at each level
tokenizer
getIndex
command tokenizer.getIndex():bat[:oid] 
TKNZRgetIndex;
administrative function that returns the INDEX bat
tokenizer
getLevel
command tokenizer.getLevel(X_0:int):bat[:str] 
TKNZRgetLevel;
administrative function that returns the bat on level i
tokenizer
locate
pattern tokenizer.locate(X_0:str):oid 
TKNZRlocate;
if the given string is in the store returns its oid, otherwise oid_nil
tokenizer
open
command tokenizer.open(X_0:str):void 
TKNZRopen;
open the named tokenizer store, a new one is created if the specified name does not exist
tokenizer
take
pattern tokenizer.take(X_0:oid):str 
TKNZRtakeOid;
reconstruct and returns the i-th string
txtsim
editdistance
command txtsim.editdistance(X_0:str, X_1:str):int 
levenshteinbasic_impl;
Alias for Levenshtein(str,str)
txtsim
editdistance2
command txtsim.editdistance2(X_0:str, X_1:str):int 
levenshteinbasic2_impl;
Calculates Levenshtein distance (edit distance) between two strings. Cost of transposition is 1 instead of 2
txtsim
levenshtein
command txtsim.levenshtein(X_0:str, X_1:str, X_2:int, X_3:int, X_4:int):int 
levenshtein_impl;
Calculates Levenshtein distance (edit distance) between two strings, variable operation costs (ins/del, replacement, transposition)
txtsim
levenshtein
command txtsim.levenshtein(X_0:str, X_1:str):int 
levenshteinbasic_impl;
Calculates Levenshtein distance (edit distance) between two strings
txtsim
qgramnormalize
command txtsim.qgramnormalize(X_0:str):str 
CMDqgramnormalize;
'Normalizes' strings (eg. toUpper and replaces non-alphanumerics with one space
txtsim
qgramselfjoin
command txtsim.qgramselfjoin(X_0:bat[:oid], X_1:bat[:oid], X_2:bat[:int], X_3:bat[:int], X_4:flt, X_5:int) (X_6:bat[:int], X_7:bat[:int]) 
CMDqgramselfjoin;
QGram self-join on ordered(!) qgram tables and sub-ordered q-gram positions
txtsim
similarity
command txtsim.similarity(X_0:str, X_1:str):dbl 
fstrcmp0_impl;
Normalized edit distance between two strings
txtsim
similarity
command txtsim.similarity(X_0:str, X_1:str, X_2:dbl):dbl 
fstrcmp_impl;
Normalized edit distance between two strings
txtsim
soundex
command txtsim.soundex(X_0:str):str 
soundex_impl;
Soundex function for phonetic matching
txtsim
str2qgrams
command txtsim.str2qgrams(X_0:str):bat[:str] 
CMDstr2qgrams;
Break the string into 4-grams
txtsim
stringdiff
command txtsim.stringdiff(X_0:str, X_1:str):int 
stringdiff_impl;
calculate the soundexed editdistance
url
getAnchor
command url.getAnchor(X_0:url):str 
URLgetAnchor;
Extract the URL anchor (reference)
url
getBasename
command url.getBasename(X_0:url):str 
URLgetBasename;
Extract the URL base file name
url
getContext
command url.getContext(X_0:url):str 
URLgetContext;
Get the path context of a URL
url
getDomain
command url.getDomain(X_0:url):str 
URLgetDomain;
Extract Internet domain from the URL
url
getExtension
command url.getExtension(X_0:url):str 
URLgetExtension;
Extract the file extension of the URL
url
getFile
command url.getFile(X_0:url):str 
URLgetFile;
Extract the last file name of the URL
url
getHost
command url.getHost(X_0:url):str 
URLgetHost;
Extract the server name from the URL
url
getPort
command url.getPort(X_0:url):str 
URLgetPort;
Extract the port id from the URL
url
getProtocol
command url.getProtocol(X_0:url):str 
URLgetProtocol;
Extract the protocol from the URL
url
getQuery
command url.getQuery(X_0:url):str 
URLgetQuery;
Extract the query string from the URL
url
getRobotURL
command url.getRobotURL(X_0:url):str 
URLgetRobotURL;
Extract the location of the robot control file
url
getUser
command url.getUser(X_0:url):str 
URLgetUser;
Extract the user identity from the URL
url
isaURL
command url.isaURL(X_0:str):bit 
URLisaURL;
Check conformity of the URL syntax
url
new
command url.new(X_0:str, X_1:str, X_2:str):url 
URLnew3;
Construct URL from protocol, host,and file
url
new
command url.new(X_0:str, X_1:str, X_2:int, X_3:str):url 
URLnew4;
Construct URL from protocol, host, port, and file
url
url
command url.url(X_0:str):url 
URLnew;
Create an URL from a string literal
url
url
command url.url(X_0:url):url 
URLnoop;
Create an URL from a string literal
user
main
function user.main():void;
(empty)
(empty)
uuid
isaUUID
command uuid.isaUUID(X_0:str):bit 
UUIDisaUUID;
Test a string for a UUID format
uuid
new
unsafe command uuid.new():uuid 
UUIDgenerateUuid;
Generate a new uuid
uuid
new
command uuid.new(X_0:int):uuid 
UUIDgenerateUuidInt;
Generate a new uuid (dummy version for side effect free multiplex loop)
uuid
str
command uuid.str(X_0:uuid):str 
UUIDuuid2str;
Coerce a uuid to its string type
uuid
uuid
command uuid.uuid(X_0:str):uuid 
UUIDstr2uuid;
Coerce a string to a uuid, validating its format
wlc
action
pattern wlc.action(X_0:str):void 
WLCaction;
Keep the database changing queries for replay. 
wlc
alter_add_range_partition
pattern wlc.alter_add_range_partition(X_0:str, X_1:str, X_2:str, X_3:str, X_4:str, X_5:str, X_6:bit, X_7:int):void 
WLCgeneric;
Catalog operation alter_add_range_partition
wlc
alter_add_table
pattern wlc.alter_add_table(X_0:str, X_1:str, X_2:str, X_3:str, X_4:int):void 
WLCgeneric;
Catalog operation alter_add_table
wlc
alter_add_value_partition
pattern wlc.alter_add_value_partition(X_0:str, X_1:str, X_2:str, X_3:str, X_4:bit, X_5:int):void 
WLCgeneric;
Catalog operation alter_add_value_partition
wlc
alter_add_value_partition
pattern wlc.alter_add_value_partition(X_0:str, X_1:str, X_2:str, X_3:str, X_4:bit, X_5:int, X_6:str...):void 
WLCgeneric;
Catalog operation alter_add_value_partition
wlc
alter_del_table
pattern wlc.alter_del_table(X_0:str, X_1:str, X_2:str, X_3:str, X_4:int):void 
WLCgeneric;
Catalog operation alter_del_table
wlc
alter_seq
pattern wlc.alter_seq(X_0:str, X_1:str, X_2:lng):void 
WLCgeneric;
Catalog operation alter_seq
wlc
alter_seq
pattern wlc.alter_seq(X_0:str, X_1:str, X_2:ptr, X_3:bat[:lng]):void 
WLCgeneric;
Catalog operation alter_seq
wlc
alter_set_table
pattern wlc.alter_set_table(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation alter_set_table
wlc
alter_table
pattern wlc.alter_table(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation alter_table
wlc
alter_user
pattern wlc.alter_user(X_0:str, X_1:str, X_2:int, X_3:str, X_4:str):void 
WLCgeneric;
Catalog operation alter_user
wlc
append
pattern wlc.append(X_0:str, X_1:str, X_2:str, X_3:any):int 
WLCappend;
Keep the insertions in the workload-capture-replay list
wlc
catalog
pattern wlc.catalog(X_0:str):void 
WLCcatalog;
Keep the catalog changing queries for replay. 
wlc
clear_table
pattern wlc.clear_table(X_0:str, X_1:str, X_2:int):int 
WLCclear_table;
Keep the deletions in the workload-capture-replay list
wlc
comment_on
pattern wlc.comment_on(X_0:int, X_1:str):void 
WLCgeneric;
Catalog operation comment_on
wlc
commit
pattern wlc.commit():void 
WLCcommitCmd;
Commit the workload-capture-replay record
wlc
commit
pattern wlc.commit():void 
WLCcommitCmd;
Mark the end of the work unit
wlc
create_function
pattern wlc.create_function(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation create_function
wlc
create_role
pattern wlc.create_role(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation create_role
wlc
create_schema
pattern wlc.create_schema(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation create_schema
wlc
create_seq
pattern wlc.create_seq(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation create_seq
wlc
create_table
pattern wlc.create_table(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation create_table
wlc
create_trigger
pattern wlc.create_trigger(X_0:str, X_1:str, X_2:str, X_3:int, X_4:int, X_5:int, X_6:str, X_7:str, X_8:str, X_9:str, X_10:int):void 
WLCgeneric;
Catalog operation create_trigger
wlc
create_type
pattern wlc.create_type(X_0:str, X_1:str, X_2:str):void 
WLCgeneric;
Catalog operation create_type
wlc
create_user
pattern wlc.create_user(X_0:str, X_1:str, X_2:int, X_3:str, X_4:str):void 
WLCgeneric;
Catalog operation create_user
wlc
create_view
pattern wlc.create_view(X_0:str, X_1:str, X_2:int, X_3:int):void 
WLCgeneric;
Catalog operation create_view
wlc
delete
pattern wlc.delete(X_0:str, X_1:str, X_2:any):int 
WLCdelete;
Keep the deletions in the workload-capture-replay list
wlc
drop_constraint
pattern wlc.drop_constraint(X_0:str, X_1:str, X_2:str, X_3:int, X_4:int):void 
WLCgeneric;
Catalog operation drop_constraint
wlc
drop_function
pattern wlc.drop_function(X_0:str, X_1:str, X_2:int, X_3:int, X_4:int):void 
WLCgeneric;
Catalog operation drop_function
wlc
drop_index
pattern wlc.drop_index(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation drop_index
wlc
drop_role
pattern wlc.drop_role(X_0:str, X_1:int):void 
WLCgeneric;
Catalog operation drop_role
wlc
drop_role
pattern wlc.drop_role(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation drop_role
wlc
drop_schema
pattern wlc.drop_schema(X_0:str, X_1:int, X_2:int):void 
WLCgeneric;
Catalog operation drop_schema
wlc
drop_seq
pattern wlc.drop_seq(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation drop_seq
wlc
drop_table
pattern wlc.drop_table(X_0:str, X_1:str, X_2:int, X_3:int):void 
WLCgeneric;
Catalog operation drop_table
wlc
drop_trigger
pattern wlc.drop_trigger(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation drop_trigger
wlc
drop_type
pattern wlc.drop_type(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation drop_type
wlc
drop_user
pattern wlc.drop_user(X_0:str, X_1:int):void 
WLCgeneric;
Catalog operation drop_user
wlc
drop_user
pattern wlc.drop_user(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation drop_user
wlc
drop_view
pattern wlc.drop_view(X_0:str, X_1:str, X_2:int, X_3:int):void 
WLCgeneric;
Catalog operation drop_view
wlc
epilogue
command wlc.epilogue():void 
WLCepilogue;
release the resources held by the wlc module
wlc
flush
unsafe pattern wlc.flush():void 
WLCflush;
Flush current log buffer
wlc
getbeat
pattern wlc.getbeat(X_0:int):str 
WLCgetbeat;
Maximal delay for transaction log flushing
wlc
getclock
pattern wlc.getclock():str 
WLCgetclock;
Timestamp of last update transaction
wlc
gettick
pattern wlc.gettick():lng 
WLCgettick;
Transaction identifier of the last committed transaction
wlc
grant
pattern wlc.grant(X_0:str, X_1:str, X_2:str, X_3:int, X_4:str, X_5:int, X_6:int):void 
WLCgeneric;
Catalog operation grant
wlc
grant_function
pattern wlc.grant_function(X_0:str, X_1:int, X_2:str, X_3:int, X_4:int, X_5:int):void 
WLCgeneric;
Catalog operation grant_function
wlc
grant_roles
pattern wlc.grant_roles(X_0:str, X_1:str, X_2:int, X_3:int):void 
WLCgeneric;
Catalog operation grant_roles
wlc
init
pattern wlc.init():void 
WLCinitCmd;
Test for running as master
wlc
master
unsafe pattern wlc.master():void 
WLCmaster;
Activate the workload-capture-replay process
wlc
master
unsafe pattern wlc.master(X_0:str):void 
WLCmaster;
Activate the workload-capture-replay process. Use a different location for the logs.
wlc
query
pattern wlc.query(X_0:str):void 
WLCquery;
Keep the queries for replay.
wlc
rename_column
pattern wlc.rename_column(X_0:str, X_1:str, X_2:str, X_3:str):void 
WLCgeneric;
Catalog operation rename_column
wlc
rename_schema
pattern wlc.rename_schema(X_0:str, X_1:str):void 
WLCgeneric;
Catalog operation rename_schema
wlc
rename_table
pattern wlc.rename_table(X_0:str, X_1:str, X_2:str, X_3:str):void 
WLCgeneric;
Catalog operation rename_table
wlc
rename_user
pattern wlc.rename_user(X_0:str, X_1:str, X_2:int):void 
WLCgeneric;
Catalog operation rename_user
wlc
revoke
pattern wlc.revoke(X_0:str, X_1:str, X_2:str, X_3:int, X_4:str, X_5:int, X_6:int):void 
WLCgeneric;
Catalog operation revoke
wlc
revoke_function
pattern wlc.revoke_function(X_0:str, X_1:int, X_2:str, X_3:int, X_4:int, X_5:int):void 
WLCgeneric;
Catalog operation revoke_function
wlc
revoke_roles
pattern wlc.revoke_roles(X_0:str, X_1:str, X_2:int, X_3:int):void 
WLCgeneric;
Catalog operation revoke_roles
wlc
rollback
pattern wlc.rollback():void 
WLCcommitCmd;
Rollback the workload-capture-replay record
wlc
rollback
pattern wlc.rollback():void 
WLCrollbackCmd;
Mark the end of the work unit
wlc
setbeat
unsafe pattern wlc.setbeat(X_0:int):void 
WLCsetbeat;
Maximal delay for transaction log flushing
wlc
stop
unsafe pattern wlc.stop():void 
WLCstop;
Stop capturing the logs
wlc
transaction
unsafe pattern wlc.transaction():void 
WLCgeneric;
Start an autocommit transaction
wlc
transaction_begin
pattern wlc.transaction_begin(X_0:int, X_1:str):void 
WLCgeneric;
A transaction statement (type can be commit,release,rollback or start)
wlc
transaction_commit
pattern wlc.transaction_commit(X_0:int, X_1:str):void 
WLCgeneric;
A transaction statement (type can be commit,release,rollback or start)
wlc
transaction_release
pattern wlc.transaction_release(X_0:int, X_1:str):void 
WLCgeneric;
A transaction statement (type can be commit,release,rollback or start)
wlc
transaction_rollback
pattern wlc.transaction_rollback(X_0:int, X_1:str):void 
WLCgeneric;
A transaction statement (type can be commit,release,rollback or start)
wlc
update
pattern wlc.update(X_0:str, X_1:str, X_2:str, X_3:any, X_4:any):int 
WLCupdate;
Keep the update in the workload-capture-replay list
wlr
accept
unsafe pattern wlr.accept():void 
WLRaccept;
Accept failing transaction
wlr
action
pattern wlr.action(X_0:str):void 
WLRaction;
A query producing updates
wlr
alter_add_range_partition
pattern wlr.alter_add_range_partition(X_0:str, X_1:str, X_2:str, X_3:str, X_4:str, X_5:str, X_6:bit, X_7:int):void 
WLRgeneric;
Catalog operation alter_add_range_partition
wlr
alter_add_table
pattern wlr.alter_add_table(X_0:str, X_1:str, X_2:str, X_3:str, X_4:int):void 
WLRgeneric;
Catalog operation alter_add_table
wlr
alter_add_value_partition
pattern wlr.alter_add_value_partition(X_0:str, X_1:str, X_2:str, X_3:str, X_4:bit, X_5:int):void 
WLRgeneric;
Catalog operation alter_add_value_partition
wlr
alter_add_value_partition
pattern wlr.alter_add_value_partition(X_0:str, X_1:str, X_2:str, X_3:str, X_4:bit, X_5:int, X_6:str...):void 
WLRgeneric;
Catalog operation alter_add_value_partition
wlr
alter_del_table
pattern wlr.alter_del_table(X_0:str, X_1:str, X_2:str, X_3:str, X_4:int):void 
WLRgeneric;
Catalog operation alter_del_table
wlr
alter_seq
pattern wlr.alter_seq(X_0:str, X_1:str, X_2:lng):void 
WLRgeneric;
Catalog operation alter_seq
wlr
alter_seq
pattern wlr.alter_seq(X_0:str, X_1:str, X_2:ptr, X_3:bat[:lng]):void 
WLRgeneric;
Catalog operation alter_seq
wlr
alter_set_table
pattern wlr.alter_set_table(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation alter_set_table
wlr
alter_table
pattern wlr.alter_table(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation alter_table
wlr
alter_user
pattern wlr.alter_user(X_0:str, X_1:str, X_2:int, X_3:str, X_4:str):void 
WLRgeneric;
Catalog operation alter_user
wlr
append
pattern wlr.append(X_0:str, X_1:str, X_2:str, X_3:oid, X_4:bat[:oid], X_5:any...):int 
WLRappend;
Apply the insertions in the workload-capture-replay list
wlr
catalog
pattern wlr.catalog(X_0:str):void 
WLRcatalog;
A catalog changing query
wlr
clear_table
pattern wlr.clear_table(X_0:str, X_1:str, X_2:int):int 
WLRclear_table;
Destroy the tuples in the table
wlr
comment_on
pattern wlr.comment_on(X_0:int, X_1:str):void 
WLRgeneric;
Catalog operation comment_on
wlr
commit
pattern wlr.commit():void 
WLRcommit;
Mark the end of the work unit
wlr
create_function
pattern wlr.create_function(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation create_function
wlr
create_role
pattern wlr.create_role(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation create_role
wlr
create_schema
pattern wlr.create_schema(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation create_schema
wlr
create_seq
pattern wlr.create_seq(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation create_seq
wlr
create_table
pattern wlr.create_table(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation create_table
wlr
create_trigger
pattern wlr.create_trigger(X_0:str, X_1:str, X_2:str, X_3:int, X_4:int, X_5:int, X_6:str, X_7:str, X_8:str, X_9:str, X_10:int):void 
WLRgeneric;
Catalog operation create_trigger
wlr
create_type
pattern wlr.create_type(X_0:str, X_1:str, X_2:str):void 
WLRgeneric;
Catalog operation create_type
wlr
create_user
pattern wlr.create_user(X_0:str, X_1:str, X_2:int, X_3:str, X_4:str):void 
WLRgeneric;
Catalog operation create_user
wlr
create_view
pattern wlr.create_view(X_0:str, X_1:str, X_2:int, X_3:int):void 
WLRgeneric;
Catalog operation create_view
wlr
delete
pattern wlr.delete(X_0:str, X_1:str, X_2:oid...):int 
WLRdelete;
Apply the deletions in the workload-capture-replay list
wlr
drop_constraint
pattern wlr.drop_constraint(X_0:str, X_1:str, X_2:str, X_3:int, X_4:int):void 
WLRgeneric;
Catalog operation drop_constraint
wlr
drop_function
pattern wlr.drop_function(X_0:str, X_1:str, X_2:int, X_3:int, X_4:int):void 
WLRgeneric;
Catalog operation drop_function
wlr
drop_index
pattern wlr.drop_index(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation drop_index
wlr
drop_role
pattern wlr.drop_role(X_0:str, X_1:int):void 
WLRgeneric;
Catalog operation drop_role
wlr
drop_role
pattern wlr.drop_role(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation drop_role
wlr
drop_schema
pattern wlr.drop_schema(X_0:str, X_1:int, X_2:int):void 
WLRgeneric;
Catalog operation drop_schema
wlr
drop_seq
pattern wlr.drop_seq(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation drop_seq
wlr
drop_table
pattern wlr.drop_table(X_0:str, X_1:str, X_2:int, X_3:int):void 
WLRgeneric;
Catalog operation drop_table
wlr
drop_trigger
pattern wlr.drop_trigger(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation drop_trigger
wlr
drop_type
pattern wlr.drop_type(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation drop_type
wlr
drop_user
pattern wlr.drop_user(X_0:str, X_1:int):void 
WLRgeneric;
Catalog operation drop_user
wlr
drop_user
pattern wlr.drop_user(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation drop_user
wlr
drop_view
pattern wlr.drop_view(X_0:str, X_1:str, X_2:int, X_3:int):void 
WLRgeneric;
Catalog operation drop_view
wlr
getMaster
pattern wlr.getMaster():str 
WLRgetmaster;
What is the current master database
wlr
getclock
pattern wlr.getclock():str 
WLRgetclock;
Timestamp of last replicated transaction.
wlr
gettick
pattern wlr.gettick():lng 
WLRgettick;
Transaction identifier of the last replicated transaction.
wlr
grant
pattern wlr.grant(X_0:str, X_1:str, X_2:str, X_3:int, X_4:str, X_5:int, X_6:int):void 
WLRgeneric;
Catalog operation grant
wlr
grant_function
pattern wlr.grant_function(X_0:str, X_1:int, X_2:str, X_3:int, X_4:int, X_5:int):void 
WLRgeneric;
Catalog operation grant_function
wlr
grant_roles
pattern wlr.grant_roles(X_0:str, X_1:str, X_2:int, X_3:int):void 
WLRgeneric;
Catalog operation grant_roles
wlr
master
unsafe pattern wlr.master(X_0:str):void 
WLRmaster;
Initialize the replicator thread
wlr
rename_column
pattern wlr.rename_column(X_0:str, X_1:str, X_2:str, X_3:str):void 
WLRgeneric;
Catalog operation rename_column
wlr
rename_schema
pattern wlr.rename_schema(X_0:str, X_1:str):void 
WLRgeneric;
Catalog operation rename_schema
wlr
rename_table
pattern wlr.rename_table(X_0:str, X_1:str, X_2:str, X_3:str):void 
WLRgeneric;
Catalog operation rename_table
wlr
rename_user
pattern wlr.rename_user(X_0:str, X_1:str, X_2:int):void 
WLRgeneric;
Catalog operation rename_user
wlr
replicate
unsafe pattern wlr.replicate():void 
WLRreplicate;
Continue to keep the replica in sink
wlr
replicate
unsafe pattern wlr.replicate(X_0:bte):void 
WLRreplicate;
Roll the snapshot forward to a specific transaction id
wlr
replicate
unsafe pattern wlr.replicate(X_0:int):void 
WLRreplicate;
Roll the snapshot forward to a specific transaction id
wlr
replicate
unsafe pattern wlr.replicate(X_0:lng):void 
WLRreplicate;
Roll the snapshot forward to a specific transaction id
wlr
replicate
unsafe pattern wlr.replicate(X_0:sht):void 
WLRreplicate;
Roll the snapshot forward to a specific transaction id
wlr
replicate
unsafe pattern wlr.replicate(X_0:timestamp):void 
WLRreplicate;
Roll the snapshot forward to an up-to-date clone
wlr
revoke
pattern wlr.revoke(X_0:str, X_1:str, X_2:str, X_3:int, X_4:str, X_5:int, X_6:int):void 
WLRgeneric;
Catalog operation revoke
wlr
revoke_function
pattern wlr.revoke_function(X_0:str, X_1:int, X_2:str, X_3:int, X_4:int, X_5:int):void 
WLRgeneric;
Catalog operation revoke_function
wlr
revoke_roles
pattern wlr.revoke_roles(X_0:str, X_1:str, X_2:int, X_3:int):void 
WLRgeneric;
Catalog operation revoke_roles
wlr
rollback
pattern wlr.rollback():void 
WLRrollback;
Mark the end of the work unit
wlr
setbeat
unsafe pattern wlr.setbeat(X_0:int):void 
WLRsetbeat;
Threshold (in seconds) for re-running queries
wlr
stop
unsafe pattern wlr.stop():void 
WLRstop;
Stop the replicator thread
wlr
transaction
unsafe pattern wlr.transaction():void 
WLRgeneric;
Start an autocommit transaction
wlr
transaction
pattern wlr.transaction(X_0:lng, X_1:str, X_2:str):void 
WLRtransaction;
Mark the beginning of the work unit which can be a compound transaction
wlr
transaction_begin
pattern wlr.transaction_begin(X_0:int, X_1:str):void 
WLRgeneric;
A transaction statement (type can be commit,release,rollback or start)
wlr
transaction_commit
pattern wlr.transaction_commit(X_0:int, X_1:str):void 
WLRgeneric;
A transaction statement (type can be commit,release,rollback or start)
wlr
transaction_release
pattern wlr.transaction_release(X_0:int, X_1:str):void 
WLRgeneric;
A transaction statement (type can be commit,release,rollback or start)
wlr
transaction_rollback
pattern wlr.transaction_rollback(X_0:int, X_1:str):void 
WLRgeneric;
A transaction statement (type can be commit,release,rollback or start)
wlr
update
pattern wlr.update(X_0:str, X_1:str, X_2:str, X_3:oid, X_4:any):int 
WLRupdate;
Apply the update in the workload-capture-replay list
xml
aggr
command xml.aggr(X_0:bat[:xml]):xml 
BATXMLgroup;
Aggregate the XML values.
xml
attribute
command xml.attribute(X_0:str, X_1:str):xml 
XMLattribute;
Construct an attribute value pair
xml
comment
command xml.comment(X_0:str):xml 
XMLcomment;
Construct an comment struction 
xml
concat
command xml.concat(X_0:xml, X_1:xml):xml 
XMLconcat;
Concatenate the xml values
xml
content
command xml.content(X_0:str):xml 
XMLcontent;
Check the value for compliance as content, i.e.  it may contain multiple roots and character data.
xml
document
command xml.document(X_0:str):xml 
XMLdocument;
Check the value for compliance as XML document
xml
element
command xml.element(X_0:str, X_1:xml, X_2:xml, X_3:xml):xml 
XMLelement;
The basic building block for XML elements are namespaces, attributes and a sequence of xml elements. The name space and the attributes may be left unspecified(=nil:bat).
xml
element
command xml.element(X_0:str, X_1:xml):xml 
XMLelementSmall;
The basic building block for XML elements are namespaces, attributes and a sequence of xml elements. The name space and the attributes may be left unspecified(=nil:bat).
xml
epilogue
command xml.epilogue():void 
XMLepilogue;
(empty)
xml
forest
pattern xml.forest(X_0:xml...):xml 
XMLforest;
Construct an element list
xml
isdocument
command xml.isdocument(X_0:str):bit 
XMLisdocument;
Validate the string as a document
xml
parse
command xml.parse(X_0:str, X_1:str, X_2:str):xml 
XMLparse;
Parse the XML document or element string values 
xml
pi
command xml.pi(X_0:str, X_1:str):xml 
XMLpi;
Construct a processing instruction
xml
prelude
command xml.prelude():void 
XMLprelude;
(empty)
xml
root
command xml.root(X_0:xml, X_1:str, X_2:str):xml 
XMLroot;
Construct the root nodes
xml
str
command xml.str(X_0:xml):str 
XMLxml2str;
Cast the string to an xml compliant string
xml
subaggr
command xml.subaggr(X_0:bat[:xml], X_1:bat[:oid], X_2:bat[:any_1], X_3:bit):bat[:xml] 
AGGRsubxml;
Grouped aggregation of XML values.
xml
subaggr
command xml.subaggr(X_0:bat[:xml], X_1:bat[:oid], X_2:bat[:any_1], X_3:bat[:oid], X_4:bit):bat[:xml] 
AGGRsubxmlcand;
Grouped aggregation of XML values with candidates list.
xml
text
command xml.text(X_0:xml):str 
XMLxmltext;
Extract text from an xml atom
xml
xml
command xml.xml(X_0:str):xml 
XMLstr2xml;
Cast the string to an xml compliant string

