stdout of test 'MAL-signatures` in directory 'clients` itself:


# 21:33:47 >  
# 21:33:47 >  "mserver5" "--debug=10" "--set" "gdk_nr_threads=0" "--set" "mapi_open=true" "--set" "mapi_port=35607" "--set" "mapi_usock=/var/tmp/mtest-19610/.s.monetdb.35607" "--set" "monet_prompt=" "--forcemito" "--set" "mal_listing=2" "--dbpath=/home/sjoerd/Monet-stable/var/MonetDB/mTests_clients" "--set" "mal_listing=2"
# 21:33:47 >  

# MonetDB 5 server v11.17.22 (hg id: 570fbe10eb64+)
# This is an unreleased version
# Serving database 'mTests_clients', using 8 threads
# Compiled for x86_64-unknown-linux-gnu/64bit with 64bit OIDs dynamically linked
# Found 7.734 GiB available main-memory.
# Copyright (c) 1993-July 2008 CWI.
# Copyright (c) August 2008-2015 MonetDB B.V., all rights reserved
# Visit http://www.monetdb.org/ for further information
# Listening for connection requests on mapi:monetdb://gaai.mullender.nl:35607/
# Listening for UNIX domain connection requests on mapi:monetdb:///var/tmp/mtest-19610/.s.monetdb.35607
# MonetDB/GIS module loaded
# MonetDB/JAQL module loaded
# MonetDB/SQL module loaded

Ready.

# 21:33:48 >  
# 21:33:48 >  "mclient" "-lmal" "-ftest" "-Eutf-8" "-i" "-e" "--host=/var/tmp/mtest-19610" "--port=35607"
# 21:33:48 >  

command aggr.avg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]) (X_4:bat[:dbl],X_5:bat[:wrd]) 
address AGGRavg23_dbl;
comment Grouped tail average on dbl, also returns count

command aggr.avg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRavg13_dbl;
comment Grouped tail average on dbl

command aggr.avg(b:bat[:flt],g:bat[:oid],e:bat[:any_1]) (X_4:bat[:dbl],X_5:bat[:wrd]) 
address AGGRavg23_dbl;
comment Grouped tail average on flt, also returns count

command aggr.avg(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRavg13_dbl;
comment Grouped tail average on flt

command aggr.avg(b:bat[:lng],g:bat[:oid],e:bat[:any_1]) (X_4:bat[:dbl],X_5:bat[:wrd]) 
address AGGRavg23_dbl;
comment Grouped tail average on lng, also returns count

command aggr.avg(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRavg13_dbl;
comment Grouped tail average on lng

command aggr.avg(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]) (X_4:bat[:dbl],X_5:bat[:wrd]) 
address AGGRavg23_dbl;
comment Grouped tail average on wrd, also returns count

command aggr.avg(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRavg13_dbl;
comment Grouped tail average on wrd

command aggr.avg(b:bat[:int],g:bat[:oid],e:bat[:any_1]) (X_4:bat[:dbl],X_5:bat[:wrd]) 
address AGGRavg23_dbl;
comment Grouped tail average on int, also returns count

command aggr.avg(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRavg13_dbl;
comment Grouped tail average on int

command aggr.avg(b:bat[:sht],g:bat[:oid],e:bat[:any_1]) (X_4:bat[:dbl],X_5:bat[:wrd]) 
address AGGRavg23_dbl;
comment Grouped tail average on sht, also returns count

command aggr.avg(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRavg13_dbl;
comment Grouped tail average on sht

command aggr.avg(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) (X_4:bat[:dbl],X_5:bat[:wrd]) 
address AGGRavg23_dbl;
comment Grouped tail average on bte, also returns count

command aggr.avg(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRavg13_dbl;
comment Grouped tail average on bte

pattern aggr.avg(b:bat[:any_2]):dbl 
address CMDcalcavg;
comment Gives the avg of all tail values

function aggr.corr(e1:bat[:dbl],e2:bat[:dbl],g:bat[:oid],e:bat[:any_2]):bat[:dbl];
function aggr.covar(e1:bat[:dbl],e2:bat[:dbl],g:bat[:oid],e:bat[:any_2]):bat[:dbl];
function aggr.corr(e1:bat[:dbl],e2:bat[:dbl]):dbl;
function aggr.covar(e1:bat[:dbl],e2:bat[:dbl]):dbl;
function aggr.corr(e1:bat[:flt],e2:bat[:flt],g:bat[:oid],e:bat[:any_2]):bat[:flt];
function aggr.covar(e1:bat[:flt],e2:bat[:flt],g:bat[:oid],e:bat[:any_2]):bat[:flt];
function aggr.corr(e1:bat[:flt],e2:bat[:flt]):flt;
function aggr.covar(e1:bat[:flt],e2:bat[:flt]):flt;
function aggr.corr(e1:bat[:lng],e2:bat[:lng],g:bat[:oid],e:bat[:any_2]):bat[:lng];
function aggr.covar(e1:bat[:lng],e2:bat[:lng],g:bat[:oid],e:bat[:any_2]):bat[:lng];
function aggr.corr(e1:bat[:lng],e2:bat[:lng]):lng;
function aggr.covar(e1:bat[:lng],e2:bat[:lng]):lng;
function aggr.corr(e1:bat[:wrd],e2:bat[:wrd],g:bat[:oid],e:bat[:any_2]):bat[:wrd];
function aggr.covar(e1:bat[:wrd],e2:bat[:wrd],g:bat[:oid],e:bat[:any_2]):bat[:wrd];
function aggr.corr(e1:bat[:wrd],e2:bat[:wrd]):wrd;
function aggr.covar(e1:bat[:wrd],e2:bat[:wrd]):wrd;
function aggr.corr(e1:bat[:int],e2:bat[:int],g:bat[:oid],e:bat[:any_2]):bat[:int];
function aggr.covar(e1:bat[:int],e2:bat[:int],g:bat[:oid],e:bat[:any_2]):bat[:int];
function aggr.corr(e1:bat[:int],e2:bat[:int]):int;
function aggr.covar(e1:bat[:int],e2:bat[:int]):int;
function aggr.corr(e1:bat[:sht],e2:bat[:sht],g:bat[:oid],e:bat[:any_2]):bat[:sht];
function aggr.covar(e1:bat[:sht],e2:bat[:sht],g:bat[:oid],e:bat[:any_2]):bat[:sht];
function aggr.corr(e1:bat[:sht],e2:bat[:sht]):sht;
function aggr.covar(e1:bat[:sht],e2:bat[:sht]):sht;
function aggr.corr(e1:bat[:bte],e2:bat[:bte],g:bat[:oid],e:bat[:any_2]):bat[:bte];
function aggr.covar(e1:bat[:bte],e2:bat[:bte],g:bat[:oid],e:bat[:any_2]):bat[:bte];
function aggr.corr(e1:bat[:bte],e2:bat[:bte]):bte;
function aggr.covar(e1:bat[:bte],e2:bat[:bte]):bte;
command aggr.count_no_nil(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:wrd] 
address AGGRcount3nonils;
command aggr.count(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:wrd] 
address AGGRcount3nils;
comment Grouped count

command aggr.count(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],ignorenils:bit):bat[:wrd] 
address AGGRcount3;
command aggr.cardinality(b:bat[:any_2]):lng 
address ALGcard;
comment Return the cardinality of the BAT tail values.

command aggr.count_no_nil(b:bat[:any_2]):wrd 
address ALGcount_no_nil;
comment Return the number of elements currently	in a BAT ignoring BUNs with nil-tail

command aggr.count(b:bat[:any],ignore_nils:bit):wrd 
address ALGcount_nil;
comment Return the number of elements currently in a BAT ignores		BUNs with nil-tail iff ignore_nils==TRUE.

command aggr.count(b:bat[:any]):wrd 
address ALGcount_bat;
comment Return the current size (in number of elements) in a BAT.

command aggr.exist(b:bat[:any_2],h:any_1):bit 
address ALGexist;
command aggr.jsonaggr(val:bat[:dbl]):str 
address JSONgroupStr;
comment Aggregate the double values to array.

command aggr.jsonaggr(val:bat[:str]):str 
address JSONgroupStr;
comment Aggregate the string values to array.

function aggr.median(b:bat[:any_1]):any_1;
command aggr.median(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:any_1] 
address AGGRmedian3;
comment Grouped median aggregate

command aggr.max(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:any_1] 
address AGGRmax3;
command aggr.min(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:any_1] 
address AGGRmin3;
command aggr.max(b:bat[:any_2]):any_2 
address ALGmaxany;
comment Return the highest tail value or nil.

command aggr.min(b:bat[:any_2]):any_2 
address ALGminany;
comment Return the lowest tail value or nil.

pattern aggr.prod(b:bat[:dbl],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:dbl],s:bat[:oid]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:dbl],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:dbl]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:flt],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:flt],s:bat[:oid]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:flt],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:flt]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:flt],s:bat[:oid],nil_if_empty:bit):flt 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:flt],s:bat[:oid]):flt 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:flt],nil_if_empty:bit):flt 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:flt]):flt 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:lng],s:bat[:oid]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:lng],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:lng]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit):lng 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:lng],s:bat[:oid]):lng 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:lng],nil_if_empty:bit):lng 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:lng]):lng 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:wrd],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:wrd],s:bat[:oid]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:wrd],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:wrd]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:wrd],s:bat[:oid],nil_if_empty:bit):lng 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:wrd],s:bat[:oid]):lng 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:wrd],nil_if_empty:bit):lng 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:wrd]):lng 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:wrd],s:bat[:oid],nil_if_empty:bit):wrd 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:wrd],s:bat[:oid]):wrd 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:wrd],nil_if_empty:bit):wrd 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:wrd]):wrd 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:int],s:bat[:oid]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:int],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:int]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit):lng 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:int],s:bat[:oid]):lng 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:int],nil_if_empty:bit):lng 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:int]):lng 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit):wrd 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:int],s:bat[:oid]):wrd 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:int],nil_if_empty:bit):wrd 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:int]):wrd 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit):int 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:int],s:bat[:oid]):int 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:int],nil_if_empty:bit):int 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:int]):int 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:sht],s:bat[:oid]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:sht],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:sht]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):lng 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:sht],s:bat[:oid]):lng 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:sht],nil_if_empty:bit):lng 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:sht]):lng 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):wrd 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:sht],s:bat[:oid]):wrd 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:sht],nil_if_empty:bit):wrd 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:sht]):wrd 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):int 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:sht],s:bat[:oid]):int 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:sht],nil_if_empty:bit):int 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:sht]):int 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):sht 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:sht],s:bat[:oid]):sht 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:sht],nil_if_empty:bit):sht 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:sht]):sht 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],s:bat[:oid]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte]):dbl 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):lng 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],s:bat[:oid]):lng 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):lng 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte]):lng 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):wrd 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],s:bat[:oid]):wrd 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):wrd 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte]):wrd 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):int 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],s:bat[:oid]):int 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):int 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte]):int 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):sht 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],s:bat[:oid]):sht 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):sht 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte]):sht 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):bte 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],s:bat[:oid]):bte 
address CMDBATprod;
comment Calculate aggregate product of B with candidate list.

pattern aggr.prod(b:bat[:bte],nil_if_empty:bit):bte 
address CMDBATprod;
comment Calculate aggregate product of B.

pattern aggr.prod(b:bat[:bte]):bte 
address CMDBATprod;
comment Calculate aggregate product of B.

command aggr.prod(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRprod3_dbl;
comment Grouped tail product on dbl

command aggr.prod(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRprod3_dbl;
comment Grouped tail product on flt

command aggr.prod(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:flt] 
address AGGRprod3_flt;
comment Grouped tail product on flt

command aggr.prod(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:lng] 
address AGGRprod3_lng;
comment Grouped tail product on lng

command aggr.prod(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]):bat[:lng] 
address AGGRprod3_lng;
comment Grouped tail product on wrd

command aggr.prod(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]):bat[:wrd] 
address AGGRprod3_wrd;
comment Grouped tail product on wrd

command aggr.prod(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:lng] 
address AGGRprod3_lng;
comment Grouped tail product on int

command aggr.prod(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:wrd] 
address AGGRprod3_wrd;
comment Grouped tail product on int

command aggr.prod(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:int] 
address AGGRprod3_int;
comment Grouped tail product on int

command aggr.prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:lng] 
address AGGRprod3_lng;
comment Grouped tail product on sht

command aggr.prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:wrd] 
address AGGRprod3_wrd;
comment Grouped tail product on sht

command aggr.prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:int] 
address AGGRprod3_int;
comment Grouped tail product on sht

command aggr.prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:sht] 
address AGGRprod3_sht;
comment Grouped tail product on sht

command aggr.prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:lng] 
address AGGRprod3_lng;
comment Grouped tail product on bte

command aggr.prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:wrd] 
address AGGRprod3_wrd;
comment Grouped tail product on bte

command aggr.prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:int] 
address AGGRprod3_int;
comment Grouped tail product on bte

command aggr.prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:sht] 
address AGGRprod3_sht;
comment Grouped tail product on bte

command aggr.prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:bte] 
address AGGRprod3_bte;
comment Grouped tail product on bte

function aggr.quantile(b:bat[:any_1],q:bat[:dbl]):any_1;
command aggr.quantile(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],q:bat[:dbl]):bat[:any_1] 
address AGGRquantile3;
comment Grouped quantile aggregate

pattern aggr.sum(b:bat[:dbl],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:dbl],s:bat[:oid]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:dbl],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:dbl]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:flt],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:flt],s:bat[:oid]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:flt],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:flt]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:flt],s:bat[:oid],nil_if_empty:bit):flt 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:flt],s:bat[:oid]):flt 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:flt],nil_if_empty:bit):flt 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:flt]):flt 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:lng],s:bat[:oid]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:lng],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:lng]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit):lng 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:lng],s:bat[:oid]):lng 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:lng],nil_if_empty:bit):lng 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:lng]):lng 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:wrd],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:wrd],s:bat[:oid]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:wrd],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:wrd]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:wrd],s:bat[:oid],nil_if_empty:bit):lng 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:wrd],s:bat[:oid]):lng 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:wrd],nil_if_empty:bit):lng 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:wrd]):lng 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:wrd],s:bat[:oid],nil_if_empty:bit):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:wrd],s:bat[:oid]):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:wrd],nil_if_empty:bit):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:wrd]):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:int],s:bat[:oid]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:int],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:int]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit):lng 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:int],s:bat[:oid]):lng 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:int],nil_if_empty:bit):lng 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:int]):lng 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:int],s:bat[:oid]):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:int],nil_if_empty:bit):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:int]):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit):int 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:int],s:bat[:oid]):int 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:int],nil_if_empty:bit):int 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:int]):int 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:sht],s:bat[:oid]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:sht],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:sht]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):lng 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:sht],s:bat[:oid]):lng 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:sht],nil_if_empty:bit):lng 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:sht]):lng 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:sht],s:bat[:oid]):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:sht],nil_if_empty:bit):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:sht]):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):int 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:sht],s:bat[:oid]):int 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:sht],nil_if_empty:bit):int 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:sht]):int 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit):sht 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:sht],s:bat[:oid]):sht 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:sht],nil_if_empty:bit):sht 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:sht]):sht 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],s:bat[:oid]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte]):dbl 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):lng 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],s:bat[:oid]):lng 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):lng 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte]):lng 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],s:bat[:oid]):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte]):wrd 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):int 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],s:bat[:oid]):int 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):int 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte]):int 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):sht 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],s:bat[:oid]):sht 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):sht 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte]):sht 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit):bte 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],s:bat[:oid]):bte 
address CMDBATsum;
comment Calculate aggregate sum of B with candidate list.

pattern aggr.sum(b:bat[:bte],nil_if_empty:bit):bte 
address CMDBATsum;
comment Calculate aggregate sum of B.

pattern aggr.sum(b:bat[:bte]):bte 
address CMDBATsum;
comment Calculate aggregate sum of B.

command aggr.subjsonaggr(val:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit):bat[:str] 
address JSONsubjsoncand;
comment Grouped aggregation of values with candidates list.

command aggr.subjsonaggr(val:bat[:str],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit):bat[:str] 
address JSONsubjsoncand;
comment Grouped aggregation of values with candidates list.

command aggr.subjsonaggr(val:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit):bat[:str] 
address JSONsubjson;
comment Grouped aggregation of values.

command aggr.subjsonaggr(val:bat[:str],g:bat[:oid],e:bat[:any_1],skip_nils:bit):bat[:str] 
address JSONsubjson;
comment Grouped aggregation of values.

command aggr.subquantile(b:bat[:any_1],q:bat[:dbl],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:any_1] 
address AGGRsubquantilecand;
comment Grouped median quantile with candidate list

command aggr.subquantile(b:bat[:any_1],q:bat[:dbl],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:any_1] 
address AGGRsubquantile;
comment Grouped quantile aggregate

command aggr.subquantile(b:bat[:any_1],q:bat[:dbl],skip_nils:bit):bat[:any_1] 
address AGGRquantile;
comment Quantile aggregate

command aggr.submedian(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:any_1] 
address AGGRsubmediancand;
comment Grouped median aggregate with candidate list

command aggr.submedian(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:any_1] 
address AGGRsubmedian;
comment Grouped median aggregate

command aggr.submedian(b:bat[:any_1],skip_nils:bit):bat[:any_1] 
address AGGRmedian;
comment Median aggregate

command aggr.subcount(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:wrd] 
address AGGRsubcountcand;
comment Grouped count aggregate with candidates list

command aggr.subcount(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:wrd] 
address AGGRsubcount;
comment Grouped count aggregate

command aggr.submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:any_1] 
address AGGRsubmaxcand_val;
comment Grouped maximum aggregate with candidates list

command aggr.submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:any_1] 
address AGGRsubmax_val;
comment Grouped maximum aggregate

command aggr.submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:any_1] 
address AGGRsubmincand_val;
comment Grouped minimum aggregate with candidates list

command aggr.submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:any_1] 
address AGGRsubmin_val;
comment Grouped minimum aggregate

command aggr.submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:oid] 
address AGGRsubmaxcand;
comment Grouped maximum aggregate with candidates list

command aggr.submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:oid] 
address AGGRsubmax;
comment Grouped maximum aggregate

command aggr.submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit):bat[:oid] 
address AGGRsubmincand;
comment Grouped minimum aggregate with candidates list

command aggr.submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit):bat[:oid] 
address AGGRsubmin;
comment Grouped minimum aggregate

command aggr.subvariancep(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancepcand_dbl;
comment Grouped variance (population/biased) aggregate with candidates list

command aggr.subvariancep(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancep_dbl;
comment Grouped variance (population/biased) aggregate

command aggr.subvariance(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancecand_dbl;
comment Grouped variance (sample/non-biased) aggregate with candidates list

command aggr.subvariance(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariance_dbl;
comment Grouped variance (sample/non-biased) aggregate

command aggr.substdevp(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevpcand_dbl;
comment Grouped standard deviation (population/biased) aggregate with candidates list

command aggr.substdevp(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevp_dbl;
comment Grouped standard deviation (population/biased) aggregate

command aggr.stdevp(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdevp3_dbl;
comment Grouped tail standard deviation (population/biased) on dbl

command aggr.substdev(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevcand_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate with candidates list

command aggr.substdev(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdev_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate

command aggr.stdev(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdev3_dbl;
comment Grouped tail standard deviation (sample/non-biased) on dbl

command aggr.subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_7:bat[:dbl],X_8:bat[:wrd]) 
address AGGRsubavg2cand_dbl;
comment Grouped average aggregate with candidates list, also returns count

command aggr.subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_6:bat[:dbl],X_7:bat[:wrd]) 
address AGGRsubavg2_dbl;
comment Grouped average aggregate, also returns count

command aggr.subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1cand_dbl;
comment Grouped average aggregate with candidates list

command aggr.subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1_dbl;
comment Grouped average aggregate

command aggr.subvariancep(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancepcand_dbl;
comment Grouped variance (population/biased) aggregate with candidates list

command aggr.subvariancep(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancep_dbl;
comment Grouped variance (population/biased) aggregate

command aggr.subvariance(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancecand_dbl;
comment Grouped variance (sample/non-biased) aggregate with candidates list

command aggr.subvariance(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariance_dbl;
comment Grouped variance (sample/non-biased) aggregate

command aggr.substdevp(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevpcand_dbl;
comment Grouped standard deviation (population/biased) aggregate with candidates list

command aggr.substdevp(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevp_dbl;
comment Grouped standard deviation (population/biased) aggregate

command aggr.stdevp(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdevp3_dbl;
comment Grouped tail standard deviation (population/biased) on flt

command aggr.substdev(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevcand_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate with candidates list

command aggr.substdev(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdev_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate

command aggr.stdev(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdev3_dbl;
comment Grouped tail standard deviation (sample/non-biased) on flt

command aggr.subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_7:bat[:dbl],X_8:bat[:wrd]) 
address AGGRsubavg2cand_dbl;
comment Grouped average aggregate with candidates list, also returns count

command aggr.subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_6:bat[:dbl],X_7:bat[:wrd]) 
address AGGRsubavg2_dbl;
comment Grouped average aggregate, also returns count

command aggr.subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1cand_dbl;
comment Grouped average aggregate with candidates list

command aggr.subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1_dbl;
comment Grouped average aggregate

command aggr.subvariancep(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancepcand_dbl;
comment Grouped variance (population/biased) aggregate with candidates list

command aggr.subvariancep(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancep_dbl;
comment Grouped variance (population/biased) aggregate

command aggr.subvariance(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancecand_dbl;
comment Grouped variance (sample/non-biased) aggregate with candidates list

command aggr.subvariance(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariance_dbl;
comment Grouped variance (sample/non-biased) aggregate

command aggr.substdevp(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevpcand_dbl;
comment Grouped standard deviation (population/biased) aggregate with candidates list

command aggr.substdevp(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevp_dbl;
comment Grouped standard deviation (population/biased) aggregate

command aggr.stdevp(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdevp3_dbl;
comment Grouped tail standard deviation (population/biased) on lng

command aggr.substdev(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevcand_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate with candidates list

command aggr.substdev(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdev_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate

command aggr.stdev(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdev3_dbl;
comment Grouped tail standard deviation (sample/non-biased) on lng

command aggr.subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_7:bat[:dbl],X_8:bat[:wrd]) 
address AGGRsubavg2cand_dbl;
comment Grouped average aggregate with candidates list, also returns count

command aggr.subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_6:bat[:dbl],X_7:bat[:wrd]) 
address AGGRsubavg2_dbl;
comment Grouped average aggregate, also returns count

command aggr.subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1cand_dbl;
comment Grouped average aggregate with candidates list

command aggr.subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1_dbl;
comment Grouped average aggregate

command aggr.subvariancep(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancepcand_dbl;
comment Grouped variance (population/biased) aggregate with candidates list

command aggr.subvariancep(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancep_dbl;
comment Grouped variance (population/biased) aggregate

command aggr.subvariance(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancecand_dbl;
comment Grouped variance (sample/non-biased) aggregate with candidates list

command aggr.subvariance(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariance_dbl;
comment Grouped variance (sample/non-biased) aggregate

command aggr.substdevp(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevpcand_dbl;
comment Grouped standard deviation (population/biased) aggregate with candidates list

command aggr.substdevp(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevp_dbl;
comment Grouped standard deviation (population/biased) aggregate

command aggr.stdevp(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdevp3_dbl;
comment Grouped tail standard deviation (population/biased) on wrd

command aggr.substdev(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevcand_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate with candidates list

command aggr.substdev(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdev_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate

command aggr.stdev(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdev3_dbl;
comment Grouped tail standard deviation (sample/non-biased) on wrd

command aggr.subavg(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_7:bat[:dbl],X_8:bat[:wrd]) 
address AGGRsubavg2cand_dbl;
comment Grouped average aggregate with candidates list, also returns count

command aggr.subavg(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_6:bat[:dbl],X_7:bat[:wrd]) 
address AGGRsubavg2_dbl;
comment Grouped average aggregate, also returns count

command aggr.subavg(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1cand_dbl;
comment Grouped average aggregate with candidates list

command aggr.subavg(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1_dbl;
comment Grouped average aggregate

command aggr.subvariancep(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancepcand_dbl;
comment Grouped variance (population/biased) aggregate with candidates list

command aggr.subvariancep(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancep_dbl;
comment Grouped variance (population/biased) aggregate

command aggr.subvariance(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancecand_dbl;
comment Grouped variance (sample/non-biased) aggregate with candidates list

command aggr.subvariance(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariance_dbl;
comment Grouped variance (sample/non-biased) aggregate

command aggr.substdevp(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevpcand_dbl;
comment Grouped standard deviation (population/biased) aggregate with candidates list

command aggr.substdevp(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevp_dbl;
comment Grouped standard deviation (population/biased) aggregate

command aggr.stdevp(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdevp3_dbl;
comment Grouped tail standard deviation (population/biased) on int

command aggr.substdev(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevcand_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate with candidates list

command aggr.substdev(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdev_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate

command aggr.stdev(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdev3_dbl;
comment Grouped tail standard deviation (sample/non-biased) on int

command aggr.subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_7:bat[:dbl],X_8:bat[:wrd]) 
address AGGRsubavg2cand_dbl;
comment Grouped average aggregate with candidates list, also returns count

command aggr.subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_6:bat[:dbl],X_7:bat[:wrd]) 
address AGGRsubavg2_dbl;
comment Grouped average aggregate, also returns count

command aggr.subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1cand_dbl;
comment Grouped average aggregate with candidates list

command aggr.subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1_dbl;
comment Grouped average aggregate

command aggr.subvariancep(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancepcand_dbl;
comment Grouped variance (population/biased) aggregate with candidates list

command aggr.subvariancep(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancep_dbl;
comment Grouped variance (population/biased) aggregate

command aggr.subvariance(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancecand_dbl;
comment Grouped variance (sample/non-biased) aggregate with candidates list

command aggr.subvariance(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariance_dbl;
comment Grouped variance (sample/non-biased) aggregate

command aggr.substdevp(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevpcand_dbl;
comment Grouped standard deviation (population/biased) aggregate with candidates list

command aggr.substdevp(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevp_dbl;
comment Grouped standard deviation (population/biased) aggregate

command aggr.stdevp(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdevp3_dbl;
comment Grouped tail standard deviation (population/biased) on sht

command aggr.substdev(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevcand_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate with candidates list

command aggr.substdev(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdev_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate

command aggr.stdev(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdev3_dbl;
comment Grouped tail standard deviation (sample/non-biased) on sht

command aggr.subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_7:bat[:dbl],X_8:bat[:wrd]) 
address AGGRsubavg2cand_dbl;
comment Grouped average aggregate with candidates list, also returns count

command aggr.subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_6:bat[:dbl],X_7:bat[:wrd]) 
address AGGRsubavg2_dbl;
comment Grouped average aggregate, also returns count

command aggr.subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1cand_dbl;
comment Grouped average aggregate with candidates list

command aggr.subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1_dbl;
comment Grouped average aggregate

command aggr.subvariancep(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancepcand_dbl;
comment Grouped variance (population/biased) aggregate with candidates list

command aggr.subvariancep(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancep_dbl;
comment Grouped variance (population/biased) aggregate

command aggr.subvariance(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariancecand_dbl;
comment Grouped variance (sample/non-biased) aggregate with candidates list

command aggr.subvariance(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubvariance_dbl;
comment Grouped variance (sample/non-biased) aggregate

command aggr.substdevp(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevpcand_dbl;
comment Grouped standard deviation (population/biased) aggregate with candidates list

command aggr.substdevp(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevp_dbl;
comment Grouped standard deviation (population/biased) aggregate

command aggr.stdevp(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdevp3_dbl;
comment Grouped tail standard deviation (population/biased) on bte

command aggr.substdev(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdevcand_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate with candidates list

command aggr.substdev(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubstdev_dbl;
comment Grouped standard deviation (sample/non-biased) aggregate

command aggr.stdev(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRstdev3_dbl;
comment Grouped tail standard deviation (sample/non-biased) on bte

command aggr.subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (X_7:bat[:dbl],X_8:bat[:wrd]) 
address AGGRsubavg2cand_dbl;
comment Grouped average aggregate with candidates list, also returns count

command aggr.subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (X_6:bat[:dbl],X_7:bat[:wrd]) 
address AGGRsubavg2_dbl;
comment Grouped average aggregate, also returns count

command aggr.subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1cand_dbl;
comment Grouped average aggregate with candidates list

command aggr.subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubavg1_dbl;
comment Grouped average aggregate

command aggr.subprod(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubprodcand_dbl;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubprod_dbl;
comment Grouped product aggregate

command aggr.subsum(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubsumcand_dbl;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubsum_dbl;
comment Grouped sum aggregate

command aggr.sum(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRsum3_dbl;
comment Grouped tail sum on dbl

command aggr.subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubprodcand_dbl;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubprod_dbl;
comment Grouped product aggregate

command aggr.subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubsumcand_dbl;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:dbl] 
address AGGRsubsum_dbl;
comment Grouped sum aggregate

command aggr.sum(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRsum3_dbl;
comment Grouped tail sum on flt

command aggr.subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:flt] 
address AGGRsubprodcand_flt;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:flt] 
address AGGRsubprod_flt;
comment Grouped product aggregate

command aggr.subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:flt] 
address AGGRsubsumcand_flt;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:flt] 
address AGGRsubsum_flt;
comment Grouped sum aggregate

command aggr.sum(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:flt] 
address AGGRsum3_flt;
comment Grouped tail sum on flt

command aggr.subprod(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubprodcand_lng;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubprod_lng;
comment Grouped product aggregate

command aggr.subsum(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubsumcand_lng;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubsum_lng;
comment Grouped sum aggregate

command aggr.sum(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:lng] 
address AGGRsum3_lng;
comment Grouped tail sum on lng

command aggr.sum(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRsum3_dbl;
comment Grouped tail sum on lng

command aggr.subprod(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubprodcand_lng;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubprod_lng;
comment Grouped product aggregate

command aggr.subsum(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubsumcand_lng;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubsum_lng;
comment Grouped sum aggregate

command aggr.sum(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]):bat[:lng] 
address AGGRsum3_lng;
comment Grouped tail sum on wrd

command aggr.subprod(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubprodcand_wrd;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubprod_wrd;
comment Grouped product aggregate

command aggr.subsum(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubsumcand_wrd;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:wrd],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubsum_wrd;
comment Grouped sum aggregate

command aggr.sum(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]):bat[:wrd] 
address AGGRsum3_wrd;
comment Grouped tail sum on wrd

command aggr.sum(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRsum3_dbl;
comment Grouped tail sum on wrd

command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubprodcand_lng;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubprod_lng;
comment Grouped product aggregate

command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubsumcand_lng;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubsum_lng;
comment Grouped sum aggregate

command aggr.sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:lng] 
address AGGRsum3_lng;
comment Grouped tail sum on int

command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubprodcand_wrd;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubprod_wrd;
comment Grouped product aggregate

command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubsumcand_wrd;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubsum_wrd;
comment Grouped sum aggregate

command aggr.sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:wrd] 
address AGGRsum3_wrd;
comment Grouped tail sum on int

command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubprodcand_int;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubprod_int;
comment Grouped product aggregate

command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubsumcand_int;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubsum_int;
comment Grouped sum aggregate

command aggr.sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:int] 
address AGGRsum3_int;
comment Grouped tail sum on int

command aggr.sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRsum3_dbl;
comment Grouped tail sum on int

command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubprodcand_lng;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubprod_lng;
comment Grouped product aggregate

command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubsumcand_lng;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubsum_lng;
comment Grouped sum aggregate

command aggr.sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:lng] 
address AGGRsum3_lng;
comment Grouped tail sum on sht

command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubprodcand_wrd;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubprod_wrd;
comment Grouped product aggregate

command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubsumcand_wrd;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubsum_wrd;
comment Grouped sum aggregate

command aggr.sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:wrd] 
address AGGRsum3_wrd;
comment Grouped tail sum on sht

command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubprodcand_int;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubprod_int;
comment Grouped product aggregate

command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubsumcand_int;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubsum_int;
comment Grouped sum aggregate

command aggr.sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:int] 
address AGGRsum3_int;
comment Grouped tail sum on sht

command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:sht] 
address AGGRsubprodcand_sht;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:sht] 
address AGGRsubprod_sht;
comment Grouped product aggregate

command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:sht] 
address AGGRsubsumcand_sht;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:sht] 
address AGGRsubsum_sht;
comment Grouped sum aggregate

command aggr.sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:sht] 
address AGGRsum3_sht;
comment Grouped tail sum on sht

command aggr.sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRsum3_dbl;
comment Grouped tail sum on sht

command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubprodcand_lng;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubprod_lng;
comment Grouped product aggregate

command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubsumcand_lng;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:lng] 
address AGGRsubsum_lng;
comment Grouped sum aggregate

command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:lng] 
address AGGRsum3_lng;
comment Grouped tail sum on bte

command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubprodcand_wrd;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubprod_wrd;
comment Grouped product aggregate

command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubsumcand_wrd;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:wrd] 
address AGGRsubsum_wrd;
comment Grouped sum aggregate

command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:wrd] 
address AGGRsum3_wrd;
comment Grouped tail sum on bte

command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubprodcand_int;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubprod_int;
comment Grouped product aggregate

command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubsumcand_int;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:int] 
address AGGRsubsum_int;
comment Grouped sum aggregate

command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:int] 
address AGGRsum3_int;
comment Grouped tail sum on bte

command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:sht] 
address AGGRsubprodcand_sht;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:sht] 
address AGGRsubprod_sht;
comment Grouped product aggregate

command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:sht] 
address AGGRsubsumcand_sht;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:sht] 
address AGGRsubsum_sht;
comment Grouped sum aggregate

command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:sht] 
address AGGRsum3_sht;
comment Grouped tail sum on bte

command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:bte] 
address AGGRsubprodcand_bte;
comment Grouped product aggregate with candidates list

command aggr.subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:bte] 
address AGGRsubprod_bte;
comment Grouped product aggregate

command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit):bat[:bte] 
address AGGRsubsumcand_bte;
comment Grouped sum aggregate with candidates list

command aggr.subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit):bat[:bte] 
address AGGRsubsum_bte;
comment Grouped sum aggregate

command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:bte] 
address AGGRsum3_bte;
comment Grouped tail sum on bte

command aggr.sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRsum3_dbl;
comment Grouped tail sum on bte

command aggr.stdevp(b:bat[:any_2]):dbl 
address ALGstdevp;
comment Gives the standard deviation of all tail values

command aggr.stdev(b:bat[:any_2]):dbl 
address ALGstdev;
comment Gives the standard deviation of all tail values

command aggr.variancep(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariancep3_dbl;
comment Grouped tail variance (population/biased) on dbl

command aggr.variance(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariance3_dbl;
comment Grouped tail variance (sample/non-biased) on dbl

command aggr.variancep(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariancep3_dbl;
comment Grouped tail variance (population/biased) on flt

command aggr.variance(b:bat[:flt],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariance3_dbl;
comment Grouped tail variance (sample/non-biased) on flt

command aggr.variancep(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariancep3_dbl;
comment Grouped tail variance (population/biased) on lng

command aggr.variance(b:bat[:lng],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariance3_dbl;
comment Grouped tail variance (sample/non-biased) on lng

command aggr.variancep(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariancep3_dbl;
comment Grouped tail variance (population/biased) on wrd

command aggr.variance(b:bat[:wrd],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariance3_dbl;
comment Grouped tail variance (sample/non-biased) on wrd

command aggr.variancep(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariancep3_dbl;
comment Grouped tail variance (population/biased) on int

command aggr.variance(b:bat[:int],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariance3_dbl;
comment Grouped tail variance (sample/non-biased) on int

command aggr.variancep(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariancep3_dbl;
comment Grouped tail variance (population/biased) on sht

command aggr.variance(b:bat[:sht],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariance3_dbl;
comment Grouped tail variance (sample/non-biased) on sht

command aggr.variancep(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariancep3_dbl;
comment Grouped tail variance (population/biased) on bte

command aggr.variance(b:bat[:bte],g:bat[:oid],e:bat[:any_1]):bat[:dbl] 
address AGGRvariance3_dbl;
comment Grouped tail variance (sample/non-biased) on bte

command aggr.variancep(b:bat[:any_2]):dbl 
address ALGvariancep;
comment Gives the variance of all tail values

command aggr.variance(b:bat[:any_2]):dbl 
address ALGvariance;
comment Gives the variance of all tail values

command algebra.crossproduct(left:bat[:any_1],right:bat[:any_2]) (l:bat[:oid],r:bat[:oid]) 
address ALGcrossproduct2;
comment Returns 2 columns with all BUNs, consisting of the head-oids	  from 'left' and 'right' for which there are BUNs in 'left'	  and 'right' with equal tails

command algebra.copy(b:bat[:any_1]):bat[:any_1] 
address ALGcopy;
comment Returns physical copy of a BAT.

command algebra.exist(b:bat[:any_1],val:any_1):bit 
address ALGexist;
comment Returns whether 'val' occurs in b.

pattern algebra.firstn(b:bat[:any],s:bat[:oid],g:bat[:oid],n:wrd,asc:bit,distinct:bit) (X_7:bat[:oid],X_8:bat[:oid]) 
address ALGfirstn;
comment Calculate first N values of B with candidate list S

pattern algebra.firstn(b:bat[:any],s:bat[:oid],n:wrd,asc:bit,distinct:bit) (X_6:bat[:oid],X_7:bat[:oid]) 
address ALGfirstn;
comment Calculate first N values of B with candidate list S

pattern algebra.firstn(b:bat[:any],n:wrd,asc:bit,distinct:bit) (X_5:bat[:oid],X_6:bat[:oid]) 
address ALGfirstn;
comment Calculate first N values of B

pattern algebra.firstn(b:bat[:any],s:bat[:oid],g:bat[:oid],n:wrd,asc:bit,distinct:bit):bat[:oid] 
address ALGfirstn;
comment Calculate first N values of B with candidate list S

pattern algebra.firstn(b:bat[:any],s:bat[:oid],n:wrd,asc:bit,distinct:bit):bat[:oid] 
address ALGfirstn;
comment Calculate first N values of B with candidate list S

pattern algebra.firstn(b:bat[:any],n:wrd,asc:bit,distinct:bit):bat[:oid] 
address ALGfirstn;
comment Calculate first N values of B

command algebra.fetch(b:bat[:any_1],x:oid):any_1 
address ALGfetchoid;
comment Returns the value of the BUN at x-th position with 0 <= x < b.count

command algebra.find(b:bat[:any_1],t:any_1):oid 
address ALGfind;
comment Returns the index position of a value.  If no such BUN exists return OID-nil.

command algebra.groupby(gids:bat[:oid],cnts:bat[:wrd]):bat[:oid] 
address ALGgroupby;
comment Produces a new BAT with groups identified by the head column. The result contains tail times the head value, ie the tail contains the result group sizes.

command algebra.ilikesubjoin(l:bat[:str],r:bat[:str],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_7:bat[:oid],X_8:bat[:oid]) 
address ILIKEsubjoin1;
command algebra.ilikesubjoin(l:bat[:str],r:bat[:str],esc:str,sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_8:bat[:oid],X_9:bat[:oid]) 
address ILIKEsubjoin;
comment Join the string bat L with the pattern bat Rwith optional candidate lists SL and SR using pattern escape string ESCand doing a case insensitive match.The result is two aligned bats with oids of matching rows.

command algebra.ilikesubselect(b:bat[:str],cand:bat[:oid],pat:str,anti:bit):bat[:oid] 
address PCRElikesubselect4;
command algebra.ilikesubselect(b:bat[:str],cand:bat[:oid],pat:str,esc:str,anti:bit):bat[:oid] 
address PCRElikesubselect1;
command algebra.ilike(s:str,pat:str):bit 
address PCREilike2;
command algebra.ilike(s:str,pat:str,esc:str):bit 
address PCREilike3;
command algebra.likesubjoin(l:bat[:str],r:bat[:str],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_7:bat[:oid],X_8:bat[:oid]) 
address LIKEsubjoin1;
command algebra.likesubjoin(l:bat[:str],r:bat[:str],esc:str,sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_8:bat[:oid],X_9:bat[:oid]) 
address LIKEsubjoin;
comment Join the string bat L with the pattern bat Rwith optional candidate lists SL and SR using pattern escape string ESCand doing a case sensitive match.The result is two aligned bats with oids of matching rows.

command algebra.likesubselect(b:bat[:str],cand:bat[:oid],pat:str,anti:bit):bat[:oid] 
address PCRElikesubselect5;
command algebra.likesubselect(b:bat[:str],cand:bat[:oid],pat:str,esc:str,anti:bit):bat[:oid] 
address PCRElikesubselect3;
command algebra.likesubselect(b:bat[:str],s:bat[:oid],pat:str,esc:str,caseignore:bit,anti:bit):bat[:oid] 
address PCRElikesubselect2;
comment Select all head values of the first input BAT for which the	tail value is "like" the given (SQL-style) pattern and for	which the head value occurs in the tail of the second input	BAT.	Input is a dense-headed BAT, output is a dense-headed BAT with in	the tail the head value of the input BAT for which the	relationship holds.  The output BAT is sorted on the tail value.

command algebra.like(s:str,pat:str):bit 
address PCRElike2;
command algebra.like(s:str,pat:str,esc:str):bit 
address PCRElike3;
command algebra.not_ilike(s:str,pat:str):bit 
address PCREnotilike2;
command algebra.not_ilike(s:str,pat:str,esc:str):bit 
address PCREnotilike3;
command algebra.not_like(s:str,pat:str):bit 
address PCREnotlike2;
command algebra.not_like(s:str,pat:str,esc:str):bit 
address PCREnotlike3;
pattern algebra.projectionpath(l:bat[:any]...):bat[:any] 
address ALGprojectionpath;
comment Routine to handle join paths.  The type analysis is rather tricky.

command algebra.projection(left:bat[:oid],right:bat[:any_3]):bat[:any_3] 
address ALGprojection;
comment Project left input onto right input.

pattern algebra.project(b:bat[:any_1],v:any_3):bat[:any_3] 
address ALGprojecttail;
comment Fill the tail with a constant

command algebra.reuse(b:bat[:any_1]):bat[:any_1] 
address ALGreuse;
comment Reuse a temporary BAT if you can. Otherwise,	allocate enough storage to accept result of an 	operation (not involving the heap)

command algebra.subslice(b:bat[:any_1],x:wrd,y:wrd):bat[:oid] 
address ALGsubslice_wrd;
comment Return the oids of the slice with the BUNs at position x till y.

command algebra.slice(b:bat[:any_1],x:wrd,y:wrd):bat[:any_1] 
address ALGslice_wrd;
comment Return the slice with the BUNs at position x till y.

command algebra.slice(b:bat[:any_1],x:int,y:int):bat[:any_1] 
address ALGslice_int;
comment Return the slice with the BUNs at position x till y.

command algebra.slice(b:bat[:any_1],x:lng,y:lng):bat[:any_1] 
address ALGslice;
comment Return the slice with the BUNs at position x till y.

command algebra.slice(b:bat[:any_1],x:oid,y:oid):bat[:any_1] 
address ALGslice_oid;
comment Return the slice based on head oid x till y (exclusive).

command algebra.subinter(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng):bat[:oid] 
address ALGsubinter;
comment Intersection of l and r with candidate lists (i.e. half of semi-join)

command algebra.subdiff(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng):bat[:oid] 
address ALGsubdiff;
comment Difference of l and r with candidate lists

command algebra.subrangejoin(l:bat[:any_1],r1:bat[:any_1],r2:bat[:any_1],sl:bat[:oid],sr:bat[:oid],li:bit,hi:bit,estimate:lng) (X_9:bat[:oid],X_10:bat[:oid]) 
address ALGsubrangejoin;
comment Range join: values in l and r1/r2 match if r1 <[=] l <[=] r2

command algebra.subbandjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],c1:any_1,c2:any_1,li:bit,hi:bit,estimate:lng) (X_10:bat[:oid],X_11:bat[:oid]) 
address ALGsubbandjoin;
comment Band join: values in l and r match if r - c1 <[=] l <[=] r + c2

function algebra.subantijoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_7:bat[:oid],X_8:bat[:oid]);
command algebra.subthetajoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],op:int,nil_matches:bit,estimate:lng) (X_8:bat[:oid],X_9:bat[:oid]) 
address ALGsubthetajoin;
comment Theta join with candidate lists

command algebra.subsemijoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_7:bat[:oid],X_8:bat[:oid]) 
address ALGsubsemijoin;
comment Semi join with candidate lists

command algebra.subouterjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_7:bat[:oid],X_8:bat[:oid]) 
address ALGsubouterjoin;
comment Left outer join with candidate lists

command algebra.subleftjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_7:bat[:oid],X_8:bat[:oid]) 
address ALGsubleftjoin;
comment Left join with candidate lists

command algebra.subjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (X_7:bat[:oid],X_8:bat[:oid]) 
address ALGsubjoin;
comment Join

command algebra.subunique(b:bat[:any_1]):bat[:oid] 
address ALGsubunique1;
comment Select all unique values from the tail of the input.	Input is a dense-headed BAT, output is a dense-headed BAT with	in the tail the head value of the input BAT that was selected.	The output BAT is sorted on the tail value.

command algebra.subunique(b:bat[:any_1],s:bat[:oid]):bat[:oid] 
address ALGsubunique2;
comment Select all unique values from the tail of the first input.	Input is a dense-headed BAT, the second input is a	dense-headed BAT with sorted tail, output is a dense-headed	BAT with in the tail the head value of the input BAT that was	selected.  The output BAT is sorted on the tail value.  The	second input BAT is a list of candidates.

command algebra.subsort(b:bat[:any_1],o:bat[:oid],g:bat[:oid],reverse:bit,stable:bit) (X_6:bat[:any_1],X_7:bat[:oid],X_8:bat[:oid]) 
address ALGsubsort33;
comment Returns a copy of the BAT sorted on tail values, a BAT that specifies         how the input was reordered, and a BAT with group information.         The input and output are (must be) dense headed.         The order is descending if the reverse bit is set.		 This is a stable sort if the stable bit is set.

command algebra.subsort(b:bat[:any_1],o:bat[:oid],g:bat[:oid],reverse:bit,stable:bit) (X_6:bat[:any_1],X_7:bat[:oid]) 
address ALGsubsort32;
comment Returns a copy of the BAT sorted on tail values and a BAT that         specifies how the input was reordered.         The input and output are (must be) dense headed.         The order is descending if the reverse bit is set.		 This is a stable sort if the stable bit is set.

command algebra.subsort(b:bat[:any_1],o:bat[:oid],g:bat[:oid],reverse:bit,stable:bit):bat[:any_1] 
address ALGsubsort31;
comment Returns a copy of the BAT sorted on tail values.         The input and output are (must be) dense headed.         The order is descending if the reverse bit is set.		 This is a stable sort if the stable bit is set.

command algebra.subsort(b:bat[:any_1],o:bat[:oid],reverse:bit,stable:bit) (X_5:bat[:any_1],X_6:bat[:oid],X_7:bat[:oid]) 
address ALGsubsort23;
comment Returns a copy of the BAT sorted on tail values, a BAT that specifies         how the input was reordered, and a BAT with group information.         The input and output are (must be) dense headed.         The order is descending if the reverse bit is set.		 This is a stable sort if the stable bit is set.

command algebra.subsort(b:bat[:any_1],o:bat[:oid],reverse:bit,stable:bit) (X_5:bat[:any_1],X_6:bat[:oid]) 
address ALGsubsort22;
comment Returns a copy of the BAT sorted on tail values and a BAT that         specifies how the input was reordered.         The input and output are (must be) dense headed.         The order is descending if the reverse bit is set.		 This is a stable sort if the stable bit is set.

command algebra.subsort(b:bat[:any_1],o:bat[:oid],reverse:bit,stable:bit):bat[:any_1] 
address ALGsubsort21;
comment Returns a copy of the BAT sorted on tail values.         The input and output are (must be) dense headed.         The order is descending if the reverse bit is set.		 This is a stable sort if the stable bit is set.

command algebra.subsort(b:bat[:any_1],reverse:bit,stable:bit) (X_4:bat[:any_1],X_5:bat[:oid],X_6:bat[:oid]) 
address ALGsubsort13;
comment Returns a copy of the BAT sorted on tail values, a BAT that specifies         how the input was reordered, and a BAT with group information.         The input and output are (must be) dense headed.         The order is descending if the reverse bit is set.		 This is a stable sort if the stable bit is set.

command algebra.subsort(b:bat[:any_1],reverse:bit,stable:bit) (X_4:bat[:any_1],X_5:bat[:oid]) 
address ALGsubsort12;
comment Returns a copy of the BAT sorted on tail values and a BAT that         specifies how the input was reordered.         The input and output are (must be) dense headed.         The order is descending if the reverse bit is set.		 This is a stable sort if the stable bit is set.

command algebra.subsort(b:bat[:any_1],reverse:bit,stable:bit):bat[:any_1] 
address ALGsubsort11;
comment Returns a copy of the BAT sorted on tail values.         The input and output are (must be) dense headed.         The order is descending if the reverse bit is set.		 This is a stable sort if the stable bit is set.

command algebra.selectNotNil(b:bat[:any_2]):bat[:any_2] 
address ALGselectNotNil;
comment Select all not-nil values

command algebra.subselect(b:bat[:any_1],s:bat[:oid],low:any_1,high:any_1,li:bit,hi:bit,anti:bit):bat[:oid] 
address ALGsubselect2;
comment Select all head values of the first input BAT for which the tail value	is in range and for which the head value occurs in the tail of the	second input BAT.	The first input is a dense-headed BAT, the second input is a	dense-headed BAT with sorted tail, output is a dense-headed BAT	with in the tail the head value of the input BAT for which the	tail value is between the values low and high (inclusive if li	respectively hi is set).  The output BAT is sorted on the tail	value.  If low or high is nil, the boundary is not considered	(effectively - and + infinity).  If anti is set, the result is the	complement.  Nil values in the tail are never matched, unless	low=nil, high=nil, li=1, hi=1, anti=0.  All non-nil values are	returned if low=nil, high=nil, and li, hi are not both 1, or anti=1.	Note that the output is suitable as second input for this	function.

command algebra.subselect(b:bat[:any_1],low:any_1,high:any_1,li:bit,hi:bit,anti:bit):bat[:oid] 
address ALGsubselect1;
comment Select all head values for which the tail value is in range.	Input is a dense-headed BAT, output is a dense-headed BAT with in	the tail the head value of the input BAT for which the tail value	is between the values low and high (inclusive if li respectively	hi is set).  The output BAT is sorted on the tail value.  If low	or high is nil, the boundary is not considered (effectively - and	+ infinity).  If anti is set, the result is the complement.  Nil	values in the tail are never matched, unless low=nil, high=nil,	li=1, hi=1, anti=0.  All non-nil values are returned if low=nil,	high=nil, and li, hi are not both 1, or anti=1.	Note that the output is suitable as second input for the other	version of this function.

command algebra.thetasubselect(b:bat[:any_1],s:bat[:oid],val:any_1,op:str):bat[:oid] 
address ALGthetasubselect2;
comment Select all head values of the first input BAT for which the tail value	obeys the relation value OP VAL and for which the head value occurs in	the tail of the second input BAT.	Input is a dense-headed BAT, output is a dense-headed BAT with in	the tail the head value of the input BAT for which the	relationship holds.  The output BAT is sorted on the tail value.

command algebra.thetasubselect(b:bat[:any_1],val:any_1,op:str):bat[:oid] 
address ALGthetasubselect1;
comment Select all head values for which the tail value obeys the relation	value OP VAL.	Input is a dense-headed BAT, output is a dense-headed BAT with in	the tail the head value of the input BAT for which the	relationship holds.  The output BAT is sorted on the tail value.

command alarm.ctime():str 
address ALARMctime;
comment Return the current time as a C-time string.

command alarm.epilogue():void 
address ALARMepilogue;
comment Finalize alarm module.

command alarm.epoch():int 
address ALARMepoch;
comment Return the current time as UNIX epoch.

command alarm.prelude():void 
address ALARMprelude;
comment Initialize alarm module.

command alarm.sleep(secs:int):void 
address ALARMsleep;
comment Sleep a few seconds

command alarm.time():int 
address ALARMtime;
comment Return time in milliseconds.

command alarm.usec():lng 
address ALARMusec;
comment Return time in microseconds.

command batbam.bam_flag(flags:bat[:sht],name:str):bat[:bit] 
address bam_flag_bat;
comment Get bat of bam flags by name.

command batbam.reverse_qual(seqs:bat[:str]):bat[:str] 
address reverse_qual_bat;
comment Reverse a bat of DNA Quality strings.

command batbam.reverse_seq(seqs:bat[:str]):bat[:str] 
address reverse_seq_bat;
comment Reverse a bat of DNA sequences.

command batbam.seq_char(ref_pos:int,alg_seq:bat[:str],alg_pos:bat[:int],alg_cigar:bat[:str]):bat[:str] 
address seq_char_bat;
comment Calculate the character in the alignment string (alg_str) that is aligned to position 'ref_pos', conforming to the given cigar string (bat based version)

command batbam.seq_length(cigars:bat[:str]):bat[:int] 
address seq_length_bat;
comment Calculate the real length of a bat of DNA sequences, given their CIGAR string.

pattern bam.bam_export(output_path:str):void 
address bam_exportf;
comment Export results in the bam.export table to a BAM file

command bam.bam_flag(flag:sht,name:str):bit 
address bam_flag;
comment Get bam flag by name.

pattern bam.bam_drop_file(file_id:lng,dbschema:sht):void 
address bam_drop_file;
comment Drop alignment tables and header data for the bam file with the given file_id

pattern bam.bam_loader_file(bam_file:str,dbschema:sht):void 
address bam_loader_file;
comment Read bam_file and store it in the given dbschema

pattern bam.bam_loader_files(bam_files:str,dbschema:sht):void 
address bam_loader_files;
comment Read all bam files in the file list stored in the file bam_files (separated by a newline) and store them in the given dbschema

pattern bam.bam_loader_repos(bam_repos:str,dbschema:sht):void 
address bam_loader_repos;
comment Read all bam files in the given bam_repos directory (non-recursive) and store them in the given dbschema

command bam.reverse_qual(qual:str):str 
address reverse_qual;
comment Reverse a DNA Quality string.

command bam.reverse_seq(seq:str):str 
address reverse_seq;
comment Reverse a DNA sequence.

pattern bam.sam_export(output_path:str):void 
address sam_exportf;
comment Export results in the bam.export table to a SAM file

command bam.seq_char(ref_pos:int,alg_seq:str,alg_pos:int,alg_cigar:str):str 
address seq_char;
comment Calculate the character in the alignment string (alg_str) that is aligned to position 'ref_pos', conforming to the given cigar string

command bam.seq_length(cigar:str):int 
address seq_length;
comment Calculate the real length of a DNA sequence, given its CIGAR string.

command batudf.fuse(one:bat[:int],two:bat[:int]):bat[:lng] 
address UDFBATfuse;
comment fuse two (4-byte) int values into one (8-byte) lng value

command batudf.fuse(one:bat[:sht],two:bat[:sht]):bat[:int] 
address UDFBATfuse;
comment fuse two (2-byte) sht values into one (4-byte) int value

command batudf.fuse(one:bat[:bte],two:bat[:bte]):bat[:sht] 
address UDFBATfuse;
comment fuse two (1-byte) bte values into one (2-byte) sht value

command batudf.reverse(b:bat[:str]):bat[:str] 
address UDFBATreverse;
comment Reverse a BAT of strings

command batgsl.chi2prob(d:bat[:dbl],i:bat[:dbl]):bat[:dbl] 
address GSLbat_chisqProb_bat;
comment Chi Squared probability

command batgsl.chi2prob(d:dbl,i:bat[:dbl]):bat[:dbl] 
address GSLcst_chisqProb_bat;
comment Chi Squared probability

command batgsl.chi2prob(d:bat[:dbl],i:dbl):bat[:dbl] 
address GSLbat_chisqProb_cst;
comment Chi Squared probability

pattern batrapi.eval_aggr(fptr:ptr,expr:str,arg:any...):any... 
address RAPIevalAggr;
comment grouped aggregates through R

pattern batrapi.eval(fptr:ptr,expr:str,arg:any...):any... 
address RAPIevalStd;
comment Execute a simple R script value

pattern batrapi.subeval_aggr(fptr:ptr,expr:str,arg:any...):any... 
address RAPIevalAggr;
comment grouped aggregates through R

command batsql.alpha(dec:dbl,theta:bat[:dbl]):bat[:dbl] 
address SQLcst_alpha_bat;
comment BAT implementation of astronomy alpha function

command batsql.alpha(dec:bat[:dbl],theta:dbl):bat[:dbl] 
address SQLbat_alpha_cst;
comment BAT implementation of astronomy alpha function

pattern batsql.dense_rank(b:bat[:any_1],p:any_2,o:any_3):bat[:int] 
address SQLdense_rank;
comment return the densely ranked groups

pattern batsql.diff(p:bat[:bit],b:bat[:any_1]):bat[:bit] 
address SQLdiff;
comment return true if cur != prev row

pattern batsql.diff(b:bat[:any_1]):bat[:bit] 
address SQLdiff;
comment return true if cur != prev row

command batsql.dec_round(v:bat[:dbl],r:dbl):bat[:dbl] 
address dbl_bat_dec_round_wrap;
comment round off the value v to nearests multiple of r

command batsql.dec_round(v:bat[:flt],r:flt):bat[:flt] 
address flt_bat_dec_round_wrap;
comment round off the value v to nearests multiple of r

command batsql.dec_round(v:bat[:lng],r:lng):bat[:lng] 
address lng_bat_dec_round_wrap;
comment round off the value v to nearests multiple of r

command batsql.dec_round(v:bat[:wrd],r:wrd):bat[:wrd] 
address wrd_bat_dec_round_wrap;
comment round off the value v to nearests multiple of r

command batsql.dec_round(v:bat[:int],r:int):bat[:int] 
address int_bat_dec_round_wrap;
comment round off the value v to nearests multiple of r

command batsql.dec_round(v:bat[:sht],r:sht):bat[:sht] 
address sht_bat_dec_round_wrap;
comment round off the value v to nearests multiple of r

command batsql.dec_round(v:bat[:bte],r:bte):bat[:bte] 
address bte_bat_dec_round_wrap;
comment round off the value v to nearests multiple of r

pattern batsql.next_value(sname:bat[:str],sequence:str):bat[:lng] 
address mvc_bat_next_value;
comment return the next value of the sequence

pattern batsql.rank(b:bat[:any_1],p:any_2,o:any_3):bat[:int] 
address SQLrank;
comment return the ranked groups

pattern batsql.row_number(b:bat[:any_1],p:any_2,o:any_3):bat[:int] 
address SQLrow_number;
comment return the row_numer-ed groups

command batsql.round(v:bat[:dbl],r:bte):bat[:dbl] 
address dbl_bat_round_wrap;
comment round off the floating point v to r digits behind the dot (if r < 0, before the dot)

command batsql.round(v:bat[:flt],r:bte):bat[:flt] 
address flt_bat_round_wrap;
comment round off the floating point v to r digits behind the dot (if r < 0, before the dot)

command batsql.round(v:bat[:lng],d:int,s:int,r:bte):bat[:lng] 
address lng_bat_round_wrap;
comment round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)

command batsql.round(v:bat[:wrd],d:int,s:int,r:bte):bat[:wrd] 
address wrd_bat_round_wrap;
comment round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)

command batsql.round(v:bat[:int],d:int,s:int,r:bte):bat[:int] 
address int_bat_round_wrap;
comment round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)

command batsql.round(v:bat[:sht],d:int,s:int,r:bte):bat[:sht] 
address sht_bat_round_wrap;
comment round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)

command batsql.round(v:bat[:bte],d:int,s:int,r:bte):bat[:bte] 
address bte_bat_round_wrap;
comment round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)

function batgeom.AsEWKT(w:bat[:wkb]):bat[:str];
function batgeom.AsText(w:bat[:wkb]):bat[:str];
command batgeom.Boundary(w:bat[:wkb]):bat[:wkb] 
address wkbBoundary_bat;
command batgeom.Contains(a:bat[:wkb],b:wkb):bat[:bit] 
address wkbContains_bat_geom;
command batgeom.Contains(a:wkb,b:bat[:wkb]):bat[:bit] 
address wkbContains_geom_bat;
command batgeom.Contains(a:bat[:wkb],b:bat[:wkb]):bat[:bit] 
address wkbContains_bat;
command batgeom.Distance(a:bat[:wkb],b:wkb):bat[:dbl] 
address wkbDistance_bat_geom;
command batgeom.Distance(a:wkb,b:bat[:wkb]):bat[:dbl] 
address wkbDistance_geom_bat;
command batgeom.Distance(a:bat[:wkb],b:bat[:wkb]):bat[:dbl] 
address wkbDistance_bat;
command batgeom.Dimension(w:bat[:wkb]):bat[:int] 
address wkbDimension_bat;
command batgeom.Filter(a:bat[:wkb],b:wkb):bat[:wkb] 
address wkbFilter_bat_geom;
command batgeom.Filter(a:wkb,b:bat[:wkb]):bat[:wkb] 
address wkbFilter_geom_bat;
comment Filters the points in the bats according to the MBR of the other bat.

command batgeom.FromText(wkt:bat[:str],srid:int,type:int):bat[:wkb] 
address wkbFromText_bat;
command batgeom.GeometryN(w:bat[:wkb],n:int):bat[:wkb] 
address wkbGeometryN_bat;
comment Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON. Otherwise, return NULL

command batgeom.GetCoordinate(w:bat[:wkb],idx:int):bat[:dbl] 
address wkbGetCoordinate_bat;
comment Returns the coordinate at position idx of a point, or NULL if not available. idx=0 -> X, idx=1 -> Y, idx=2 -> Z. Input must be point

function batgeom.GeometryType2(w:bat[:wkb]):bat[:str];
function batgeom.GeometryType1(w:bat[:wkb]):bat[:str];
command batgeom.GeometryType(w:bat[:wkb],flag:int):bat[:str] 
address wkbGeometryType_bat;
function batgeom.GeomCollFromText(wkt:bat[:str]):bat[:wkb];
function batgeom.GeomFromText(wkt:bat[:str]):bat[:wkb];
function batgeom.GeomCollFromText(wkt:bat[:str],srid:int):bat[:wkb];
function batgeom.GeomFromText(wkt:bat[:str],srid:int):bat[:wkb];
command batgeom.IsValid(w:bat[:wkb]):bat[:bit] 
address wkbIsValid_bat;
command batgeom.IsRing(w:bat[:wkb]):bat[:bit] 
address wkbIsRing_bat;
command batgeom.IsSimple(w:bat[:wkb]):bat[:bit] 
address wkbIsSimple_bat;
command batgeom.IsEmpty(w:bat[:wkb]):bat[:bit] 
address wkbIsEmpty_bat;
command batgeom.IsClosed(w:bat[:wkb]):bat[:bit] 
address wkbIsClosed_bat;
function batgeom.LineFromText(wkt:bat[:str]):bat[:wkb];
function batgeom.LineFromText(wkt:bat[:str],srid:int):bat[:wkb];
command batgeom.MakeLine(a:bat[:wkb],b:bat[:wkb]):bat[:wkb] 
address wkbMakeLine_bat;
comment Gets two BATS of point or linestring geometries and returns a bat with linestring geometries

command batgeom.MakeBox2D(p1:bat[:wkb],p2:bat[:wkb]):bat[:mbr] 
address wkbBox2D_bat;
function batgeom.MakePoint(x:bat[:dbl],y:bat[:dbl],z:bat[:dbl],m:bat[:dbl]):bat[:wkb];
function batgeom.MakePointM(x:bat[:dbl],y:bat[:dbl],m:bat[:dbl]):bat[:wkb];
function batgeom.MakePoint(x:bat[:dbl],y:bat[:dbl],z:bat[:dbl]):bat[:wkb];
function batgeom.MakePoint(x:bat[:dbl],y:bat[:dbl]):bat[:wkb];
command batgeom.MakePointXYZM(x:bat[:dbl],y:bat[:dbl],z:bat[:dbl],m:bat[:dbl],zmFlag:int):bat[:wkb] 
address wkbMakePoint_bat;
comment creates a point using the coordinates

function batgeom.MPolyFromText(wkt:bat[:str]):bat[:wkb];
function batgeom.MLineFromText(wkt:bat[:str]):bat[:wkb];
function batgeom.MPointFromText(wkt:bat[:str]):bat[:wkb];
function batgeom.MPolyFromText(wkt:bat[:str],srid:int):bat[:wkb];
function batgeom.MLineFromText(wkt:bat[:str],srid:int):bat[:wkb];
function batgeom.MPointFromText(wkt:bat[:str],srid:int):bat[:wkb];
function batgeom.NRings(w:bat[:wkb]):bat[:int];
function batgeom.NumInteriorRings(w:bat[:wkb]):bat[:int];
command batgeom.NumRings(w:bat[:wkb],exterior:int):bat[:int] 
address wkbNumRings_bat;
comment Returns the number of interior rings+exterior on the first polygon of the geometry

command batgeom.NumGeometries(w:bat[:wkb]):bat[:int] 
address wkbNumGeometries_bat;
comment Returns the number of geometries

function batgeom.NPoints(w:bat[:wkb]):bat[:int];
function batgeom.NumPoints(w:bat[:wkb]):bat[:int];
command batgeom.PointsNum(w:bat[:wkb],check:int):bat[:int] 
address wkbNumPoints_bat;
comment The number of points in the Geometry. If check=1, the geometry should be a linestring

function batgeom.PolygonFromText(wkt:bat[:str]):bat[:wkb];
function batgeom.PointFromText(wkt:bat[:str]):bat[:wkb];
function batgeom.PolygonFromText(wkt:bat[:str],srid:int):bat[:wkb];
function batgeom.PointFromText(wkt:bat[:str],srid:int):bat[:wkb];
command batgeom.ToText(w:bat[:wkb],withSRID:int):bat[:str] 
address wkbAsText_bat;
command batgeom.Union(a:bat[:wkb],b:bat[:wkb]):bat[:wkb] 
address wkbUnion_bat;
comment Gets two BATS of geometries and returns the pairwise unions

function batgeom.XMaxFromMBR(b:bat[:mbr]):bat[:dbl];
function batgeom.XMinFromMBR(b:bat[:mbr]):bat[:dbl];
function batgeom.XMaxFromWKB(g:bat[:wkb]):bat[:dbl];
function batgeom.XMinFromWKB(g:bat[:wkb]):bat[:dbl];
function batgeom.X(w:bat[:wkb]):bat[:dbl];
function batgeom.YMaxFromMBR(b:bat[:mbr]):bat[:dbl];
function batgeom.YMinFromMBR(b:bat[:mbr]):bat[:dbl];
function batgeom.YMaxFromWKB(g:bat[:wkb]):bat[:dbl];
function batgeom.YMinFromWKB(g:bat[:wkb]):bat[:dbl];
function batgeom.Y(w:bat[:wkb]):bat[:dbl];
function batgeom.Z(w:bat[:wkb]):bat[:dbl];
command batgeom.coordinateFromMBR(X_1:bat[:mbr],X_2:int):bat[:dbl] 
address wkbCoordinateFromMBR_bat;
comment returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided mbr

command batgeom.coordinateFromWKB(X_1:bat[:wkb],X_2:int):bat[:dbl] 
address wkbCoordinateFromWKB_bat;
comment returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided geometry

command batgeom.mbr(X_1:bat[:wkb]):bat[:mbr] 
address wkbMBR_bat;
comment Creates the mbr for the given wkb.

command batgeom.setSRID(w:bat[:wkb],srid:int):bat[:wkb] 
address wkbSetSRID_bat;
comment Sets the Reference System ID for this Geometry.

pattern batmal.multiplex(mod:str,fcn:str,a:any...):any... 
address MANIFOLDremapMultiplex;
command batalgebra.ilike(s:bat[:str],pat:str):bat[:bit] 
address BATPCREilike2;
command batalgebra.ilike(s:bat[:str],pat:str,esc:str):bat[:bit] 
address BATPCREilike;
command batalgebra.like(s:bat[:str],pat:str):bat[:bit] 
address BATPCRElike2;
command batalgebra.like(s:bat[:str],pat:str,esc:str):bat[:bit] 
address BATPCRElike;
command batalgebra.not_ilike(s:bat[:str],pat:str):bat[:bit] 
address BATPCREnotilike2;
command batalgebra.not_ilike(s:bat[:str],pat:str,esc:str):bat[:bit] 
address BATPCREnotilike;
command batalgebra.not_like(s:bat[:str],pat:str):bat[:bit] 
address BATPCREnotlike2;
command batalgebra.not_like(s:bat[:str],pat:str,esc:str):bat[:bit] 
address BATPCREnotlike;
command batcolor.blue(c:bat[:color]):bat[:int] 
address CLRbatBlue;
comment Extracts blue component from a color atom

command batcolor.cb(c:bat[:color]):bat[:int] 
address CLRbatCb;
comment Extracts Cb(blue color) component from a color atom

command batcolor.cr(c:bat[:color]):bat[:int] 
address CLRbatCr;
comment Extracts Cr(red color) component from a color atom

command batcolor.color(s:bat[:str]):bat[:color] 
address CLRbatColor;
comment Converts string to color

command batcolor.green(c:bat[:color]):bat[:int] 
address CLRbatGreen;
comment Extracts green component from a color atom

command batcolor.hue(c:bat[:color]):bat[:flt] 
address CLRbatHue;
comment Extracts hue component from a color atom

command batcolor.hsv(h:bat[:flt],s:bat[:flt],v:bat[:flt]):bat[:color] 
address CLRbatHsv;
comment Converts an HSV triplets to a color atom

command batcolor.hue(c:bat[:color]):bat[:int] 
address CLRbatHueInt;
comment Extracts hue component from a color atom

command batcolor.luminance(c:bat[:color]):bat[:int] 
address CLRbatLuminance;
comment Extracts Y(luminance) component from a color atom

command batcolor.red(c:bat[:color]):bat[:int] 
address CLRbatRed;
comment Extracts red component from a color atom

command batcolor.rgb(r:bat[:int],g:bat[:int],b:bat[:int]):bat[:color] 
address CLRbatRgb;
comment Converts an RGB triplets to a color atom

command batcolor.saturation(c:bat[:color]):bat[:flt] 
address CLRbatSaturation;
comment Extracts saturation component from a color atom

command batcolor.saturation(c:bat[:color]):bat[:int] 
address CLRbatSaturationInt;
comment Extracts saturation component from a color atom

command batcolor.str(b:bat[:color]):bat[:str] 
address CLRbatStr;
comment Identity mapping for string bats

command batcolor.value(c:bat[:color]):bat[:flt] 
address CLRbatValue;
comment Extracts value component from a color atom

command batcolor.value(c:bat[:color]):bat[:int] 
address CLRbatValueInt;
comment Extracts value component from a color atom

command batcolor.ycc(y:bat[:flt],cr:bat[:flt],cb:bat[:flt]):bat[:color] 
address CLRbatycc;
comment Converts an YCC triplets to a color atom

command batstr.endsWith(s:bat[:str],suffix:str):bat[:bit] 
address STRbatSuffixcst;
comment Suffix check.

command batstr.endsWith(s:bat[:str],suffix:bat[:str]):bat[:bit] 
address STRbatSuffix;
comment Suffix check.

command batstr.lpad(s:bat[:str],n:bat[:int],s2:bat[:str]):bat[:str] 
address STRbatLpad2_bat_bat;
comment Prepend the second strings to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.

command batstr.lpad(s:bat[:str],n:int,s2:bat[:str]):bat[:str] 
address STRbatLpad2_const_bat;
comment Prepend the second strings to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.

command batstr.lpad(s:bat[:str],n:bat[:int],s2:str):bat[:str] 
address STRbatLpad2_bat_const;
comment Prepend the second string to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.

command batstr.lpad(s:bat[:str],n:int,s2:str):bat[:str] 
address STRbatLpad2_const_const;
comment Prepend the second string to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.

command batstr.lpad(s:bat[:str],n:bat[:int]):bat[:str] 
address STRbatLpad_bat;
comment Prepend whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.

command batstr.lpad(s:bat[:str],n:int):bat[:str] 
address STRbatLpad_const;
comment Prepend whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length.

command batstr.ltrim(s:bat[:str],s2:bat[:str]):bat[:str] 
address STRbatLtrim2_bat;
comment Strip characters in the second strings from start of the first strings.

command batstr.ltrim(s:bat[:str],s2:str):bat[:str] 
address STRbatLtrim2_const;
comment Strip characters in the second string from start of the first strings.

command batstr.ltrim(s:bat[:str]):bat[:str] 
address STRbatLtrim;
comment Strip whitespaces from start of a string.

command batstr.length(s:bat[:str]):bat[:int] 
address STRbatLength;
comment Return the length of a string.

command batstr.nbytes(s:bat[:str]):bat[:int] 
address STRbatBytes;
comment Return the string length in bytes.

command batstr.r_search(s:bat[:str],c:str):bat[:int] 
address STRbatRstrSearchcst;
comment Reverse search for a substring. Returns position, -1 if not found.

command batstr.r_search(s:bat[:str],c:bat[:str]):bat[:int] 
address STRbatRstrSearch;
comment Reverse search for a substring. Returns position, -1 if not found.

command batstr.rpad(s:bat[:str],n:bat[:int],s2:bat[:str]):bat[:str] 
address STRbatRpad2_bat_bat;
comment Append the second strings to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.

command batstr.rpad(s:bat[:str],n:int,s2:bat[:str]):bat[:str] 
address STRbatRpad2_const_bat;
comment Append the second strings to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.

command batstr.rpad(s:bat[:str],n:bat[:int],s2:str):bat[:str] 
address STRbatRpad2_bat_const;
comment Append the second string to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.

command batstr.rpad(s:bat[:str],n:int,s2:str):bat[:str] 
address STRbatRpad2_const_const;
comment Append the second string to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.

command batstr.rpad(s:bat[:str],n:bat[:int]):bat[:str] 
address STRbatRpad_bat;
comment Append whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.

command batstr.rpad(s:bat[:str],n:int):bat[:str] 
address STRbatRpad_const;
comment Append whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length.

command batstr.rtrim(s:bat[:str],s2:bat[:str]):bat[:str] 
address STRbatRtrim2_bat;
comment Strip characters in the second strings from end of the first strings.

command batstr.rtrim(s:bat[:str],s2:str):bat[:str] 
address STRbatRtrim2_const;
comment Strip characters in the second string from end of the first strings.

command batstr.rtrim(s:bat[:str]):bat[:str] 
address STRbatRtrim;
comment Strip whitespaces from end of a string.

command batstr.substitute(s:bat[:str],src:str,dst:str,rep:bit):bat[:str] 
address STRbatSubstitutecst;
comment Substitute first occurrence of 'src' by	'dst'.  Iff repeated = true this is	repeated while 'src' can be found in the	result string. In order to prevent	recursion and result strings of unlimited	size, repeating is only done iff src is	not a substring of dst.

command batstr.substring(s:bat[:str],start:int,index:int):bat[:str] 
address STRbatsubstringcst;
comment Substring extraction using [start,start+length]

command batstr.substring(s:bat[:str],start:bat[:int],index:bat[:int]):bat[:str] 
address STRbatsubstring;
comment Substring extraction using [start,start+length]

command batstr.string(b:bat[:str],offset:int):bat[:str] 
address STRbatTailcst;
comment Return the tail s[offset..n] of a string s[0..n].

command batstr.string(b:bat[:str],offset:bat[:int]):bat[:str] 
address STRbatTail;
comment Return the tail s[offset..n] of a string s[0..n].

command batstr.search(s:bat[:str],c:str):bat[:int] 
address STRbatstrSearchcst;
comment Search for a substring. Returns position, -1 if not found.

command batstr.search(s:bat[:str],c:bat[:str]):bat[:int] 
address STRbatstrSearch;
comment Search for a substring. Returns position, -1 if not found.

command batstr.startsWith(s:bat[:str],prefix:str):bat[:bit] 
address STRbatPrefixcst;
comment Prefix check.

command batstr.startsWith(s:bat[:str],prefix:bat[:str]):bat[:bit] 
address STRbatPrefix;
comment Prefix check.

command batstr.stringlength(s:bat[:str]):bat[:int] 
address STRbatstringLength;
comment Return the length of a right trimed string.

command batstr.trim(s:bat[:str],s2:bat[:str]):bat[:str] 
address STRbatStrip2_bat;
comment Strip characters in the second strings around the first strings.

command batstr.trim(s:bat[:str],s2:str):bat[:str] 
address STRbatStrip2_const;
comment Strip characters in the second string around the first strings.

command batstr.trim(s:bat[:str]):bat[:str] 
address STRbatStrip;
comment Strip whitespaces around a string.

command batstr.toUpper(s:bat[:str]):bat[:str] 
address STRbatUpper;
comment Convert a string to upper case.

command batstr.toLower(s:bat[:str]):bat[:str] 
address STRbatLower;
comment Convert a string to lower case.

command batstr.unicodeAt(s:bat[:str],index:int):bat[:int] 
address STRbatWChrAtcst;
comment get a unicode character (as an int) from a string position.

command batstr.unicodeAt(s:bat[:str],index:bat[:int]):bat[:int] 
address STRbatWChrAt;
comment get a unicode character (as an int) from a string position.

command batmmath.atan2(x:bat[:flt],y:flt):bat[:flt] 
address CMDscience_bat_cst_atan2_flt;
command batmmath.atan2(x:bat[:dbl],y:dbl):bat[:dbl] 
address CMDscience_bat_cst_atan2_dbl;
command batmmath.atan(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_atan;
command batmmath.atan(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_atan;
command batmmath.acos(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_acos;
command batmmath.acos(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_acos;
command batmmath.asin(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_asin;
command batmmath.asin(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_asin;
command batmmath.ceil(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_ceil;
command batmmath.ceil(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_ceil;
command batmmath.cosh(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_cosh;
command batmmath.cosh(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_cosh;
command batmmath.cos(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_cos;
command batmmath.cos(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_cos;
command batmmath.degrees(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_degrees;
command batmmath.degrees(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_degrees;
command batmmath.exp(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_exp;
command batmmath.exp(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_exp;
pattern batmmath.fmod(x:bat[:flt],y:flt):bat[:flt] 
address CMDbatMODsignal;
pattern batmmath.fmod(x:bat[:dbl],y:dbl):bat[:dbl] 
address CMDbatMODsignal;
command batmmath.floor(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_floor;
command batmmath.floor(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_floor;
command batmmath.fabs(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_fabs;
command batmmath.fabs(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_fabs;
command batmmath.log10(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_log10;
command batmmath.log10(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_log10;
command batmmath.log(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_log;
command batmmath.log(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_log;
command batmmath.pow(x:bat[:flt],y:flt):bat[:flt] 
address CMDscience_bat_cst_pow_flt;
command batmmath.pow(x:bat[:dbl],y:dbl):bat[:dbl] 
address CMDscience_bat_cst_pow_dbl;
command batmmath.radians(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_radians;
command batmmath.radians(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_radians;
command batmmath.sqrt(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_sqrt;
command batmmath.sqrt(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_sqrt;
command batmmath.sinh(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_sinh;
command batmmath.sinh(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_sinh;
command batmmath.sin(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_sin;
command batmmath.sin(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_sin;
command batmmath.tanh(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_tanh;
command batmmath.tanh(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_tanh;
command batmmath.tan(x:bat[:flt]):bat[:flt] 
address CMDscience_bat_flt_tan;
command batmmath.tan(x:bat[:dbl]):bat[:dbl] 
address CMDscience_bat_dbl_tan;
command batxml.attribute(name:str,val:bat[:str]):bat[:xml] 
address BATXMLattribute;
comment Construct an attribute value pair.

command batxml.concat(left:bat[:xml],right:bat[:xml]):bat[:xml] 
address BATXMLconcat;
comment Concatenate the XML values.

command batxml.comment(val:bat[:str]):bat[:xml] 
address BATXMLcomment;
comment Create an XML comment element.

command batxml.content(src:bat[:str]):bat[:xml] 
address BATXMLcontent;
comment Parse the string as XML element content.

command batxml.document(src:bat[:str]):bat[:xml] 
address BATXMLdocument;
comment Parse the string as an XML document.

command batxml.element(name:str,ns:xml,attr:xml,s:bat[:xml]):bat[:xml] 
address BATXMLelement;
comment The basic building block for XML elements are namespaces, attributes and a sequence of XML elements. The name space and the attributes may be left unspecified(=nil).

command batxml.element(name:str,s:bat[:xml]):bat[:xml] 
address BATXMLelementSmall;
comment The basic building block for XML elements are namespaces, attributes and a sequence of XML elements. The name space and the attributes may be left unspecified.

pattern batxml.forest(val:bat[:xml]...):bat[:xml] 
address BATXMLforest;
comment Construct an element list.

command batxml.isdocument(val:bat[:str]):bat[:bit] 
address BATXMLisdocument;
comment Validate the string as a XML document.

command batxml.options(tag:str,option:str,left:bat[:xml]):bat[:xml] 
address BATXMLoptions;
comment Create the components including NULL conversions.

command batxml.pi(target:str,val:bat[:xml]):bat[:xml] 
address BATXMLpi;
comment Construct a processing instruction.

command batxml.parse(doccont:str,val:bat[:str],option:str):bat[:xml] 
address BATXMLparse;
comment Parse the XML document or element string values.

command batxml.root(val:bat[:xml],version:str,standalone:str):bat[:xml] 
address BATXMLroot;
comment Contruct the root nodes.

command batxml.serialize(val:bat[:xml]):bat[:str] 
address BATXMLxml2str;
comment Serialize the XML object to a string.

command batxml.str(src:bat[:xml]):bat[:str] 
address BATXMLxml2str;
comment Cast the xml to a string.

command batxml.text(val:bat[:xml]):bat[:str] 
address BATXMLxmltext;
comment Serialize the XML object to a string.

command batxml.xquery(val:bat[:str],expr:str):bat[:xml] 
address BATXMLxquery;
comment Execute the XQuery against the elements.

command batxml.xml(src:bat[:str]):bat[:xml] 
address BATXMLstr2xml;
comment Cast the string to an xml compliant string.

command batmtime.diff(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:lng] 
address MTIMEtimestamp_diff_bulk;
comment Difference of two sets of timestamp.

command batmtime.diff(b1:bat[:date],b2:bat[:date]):bat[:int] 
address MTIMEdate_diff_bulk;
comment Difference of two sets of date.

command batmtime.day(d:bat[:date]):bat[:int] 
address MTIMEdate_extract_day_bulk;
command batmtime.hours(d:bat[:daytime]):bat[:int] 
address MTIMEdaytime_extract_hours_bulk;
command batmtime.milliseconds(d:bat[:daytime]):bat[:int] 
address MTIMEdaytime_extract_milliseconds_bulk;
command batmtime.minutes(d:bat[:daytime]):bat[:int] 
address MTIMEdaytime_extract_minutes_bulk;
command batmtime.month(d:bat[:date]):bat[:int] 
address MTIMEdate_extract_month_bulk;
command batmtime.sql_seconds(d:bat[:daytime]):bat[:int] 
address MTIMEdaytime_extract_sql_seconds_bulk;
command batmtime.seconds(d:bat[:daytime]):bat[:int] 
address MTIMEdaytime_extract_seconds_bulk;
command batmtime.year(d:bat[:date]):bat[:int] 
address MTIMEdate_extract_year_bulk;
pattern batcalc.!=(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:dbl,b:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:dbl],v:dbl):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:dbl,b:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:dbl],v:flt):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:dbl,b:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:dbl],v:lng):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:dbl,b:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:dbl],v:wrd):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:dbl,b:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:dbl],v:int):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:dbl,b:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:dbl],v:sht):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:dbl,b:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:dbl],v:bte):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:flt,b:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:flt],v:dbl):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:flt,b:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:flt],v:flt):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:flt],b2:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:flt,b:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:flt],v:lng):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:flt],b2:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:flt,b:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:flt],v:wrd):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:flt],b2:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:flt,b:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:flt],v:int):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:flt],b2:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:flt,b:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:flt],v:sht):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:flt],b2:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:flt,b:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:flt],v:bte):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:flt],b2:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:lng,b:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:lng],v:dbl):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:lng,b:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:lng],v:flt):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:lng],b2:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:lng,b:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:lng],v:lng):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:lng],b2:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:lng,b:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:lng],v:wrd):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:lng],b2:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:lng,b:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:lng],v:int):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:lng],b2:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:lng,b:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:lng],v:sht):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:lng],b2:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:lng,b:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:lng],v:bte):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:lng],b2:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:wrd,b:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:wrd],v:dbl):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:wrd,b:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:wrd],v:flt):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:wrd,b:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:wrd],v:lng):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:wrd,b:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:wrd],v:wrd):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:wrd,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:wrd,b:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:wrd],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:wrd],v:int):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:wrd,b:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:wrd],v:sht):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:wrd,b:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:wrd],v:bte):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:wrd],b2:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:int,b:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:int],v:dbl):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:int],b2:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:int,b:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:int],v:flt):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:int],b2:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:int,b:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:int],v:lng):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:int],b2:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:int,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:int,b:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:int],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:int],v:wrd):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:int],b2:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:int,b:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:int],v:int):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:int],b2:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:int,b:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:int],v:sht):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:int],b2:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:int,b:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:int],v:bte):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:int],b2:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:sht,b:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:sht],v:dbl):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:sht,b:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:sht],v:flt):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:sht],b2:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:sht,b:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:sht],v:lng):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:sht],b2:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:sht,b:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:sht],v:wrd):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:sht],b2:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:sht,b:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:sht],v:int):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:sht],b2:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:sht,b:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:sht],v:sht):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:sht],b2:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:sht,b:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:sht],v:bte):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:sht],b2:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:bte,b:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:bte],v:dbl):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:bte,b:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:bte],v:flt):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:bte],b2:bat[:flt]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:bte,b:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:bte],v:lng):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:bte],b2:bat[:lng]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:bte,b:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:bte],v:wrd):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:bte],b2:bat[:wrd]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:bte,b:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:bte],v:int):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:bte],b2:bat[:int]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:bte,b:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:bte],v:sht):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:bte],b2:bat[:sht]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:bte,b:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:bte],v:bte):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:bte],b2:bat[:bte]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:oid,b:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:oid],v:oid):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:oid],b2:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:str,b:bat[:str]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:str],v:str):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:str],b2:bat[:str]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:bit,b:bat[:bit]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:bit],v:bit):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:bit],b2:bat[:bit]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:timestamp,b:bat[:timestamp]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:timestamp],v:timestamp):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:daytime,b:bat[:daytime]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:daytime],v:daytime):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return V != B with candidates list

pattern batcalc.!=(v:date,b:bat[:date]):bat[:bit] 
address CMDbatNE;
comment Return V != B

pattern batcalc.!=(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B != V with candidates list

pattern batcalc.!=(b:bat[:date],v:date):bat[:bit] 
address CMDbatNE;
comment Return B != V

pattern batcalc.!=(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2 with candidates list

pattern batcalc.!=(b1:bat[:date],b2:bat[:date]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(b1:bat[:json],b2:bat[:json]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.!=(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] 
address CMDbatNE;
comment Return B1 != B2

pattern batcalc.%(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:dbl):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:flt]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:flt):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:lng]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:lng):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:wrd]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:wrd):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:wrd]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:int]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:int):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:sht]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:sht):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:dbl,b:bat[:bte]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:dbl],v:bte):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:dbl):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:flt):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:lng]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:lng):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:lng]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:wrd]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:wrd):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:wrd]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:int]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:int):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:int]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:sht]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:sht):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:sht]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:flt,b:bat[:bte]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:flt],v:bte):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:flt],b2:bat[:bte]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:dbl):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:flt):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:wrd]):bat[:wrd] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:wrd):bat[:wrd] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:int]):bat[:int] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:int):bat[:int] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:int]):bat[:int] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:sht]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:sht):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:sht]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:lng,b:bat[:bte]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:lng],v:bte):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:lng],b2:bat[:bte]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:dbl):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:flt):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:lng]):bat[:wrd] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:wrd] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:lng):bat[:wrd] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:lng]):bat[:wrd] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:int]):bat[:int] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:int):bat[:int] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:int]):bat[:int] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:sht]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:sht):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:sht]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:wrd,b:bat[:bte]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:wrd],v:bte):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:wrd],b2:bat[:bte]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:dbl):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:flt):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:lng]):bat[:int] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:lng):bat[:int] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:lng]):bat[:int] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:wrd]):bat[:int] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:wrd,s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:wrd):bat[:int] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:wrd]):bat[:int] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:int]):bat[:int] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:int):bat[:int] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:sht]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:sht):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:sht]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:int,b:bat[:bte]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:int],v:bte):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:int],b2:bat[:bte]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:dbl):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:flt):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:lng]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:lng):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:lng]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:wrd]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:wrd):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:wrd]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:int]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:int):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:int]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:sht,b:bat[:bte]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:sht],v:bte):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:sht],b2:bat[:bte]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:dbl):bat[:dbl] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:flt):bat[:flt] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:flt]):bat[:flt] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:lng]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:lng):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:lng]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:wrd]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:wrd):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:wrd]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:int]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:int):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:int]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:sht]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:sht):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:sht]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B with candidates list, signal error on divide by zero

pattern batcalc.%(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatMODsignal;
comment Return V % B, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V with candidates list, signal error on divide by zero

pattern batcalc.%(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatMODsignal;
comment Return B % V, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2 with candidates list, signal error on divide by zero

pattern batcalc.%(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatMODsignal;
comment Return B1 % B2, signal error on divide by zero

pattern batcalc.*(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:dbl):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:flt]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:flt):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:lng]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:lng):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:wrd]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:wrd):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:wrd]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:int]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:int):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:sht]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:sht):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:dbl,b:bat[:bte]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:dbl],v:bte):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:dbl):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:flt):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:lng]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:lng):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:lng]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:wrd]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:wrd):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:wrd]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:int]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:int):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:int]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:sht]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:sht):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:sht]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:bte]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:flt],v:bte):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:flt],b2:bat[:bte]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:dbl):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:flt):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:int):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:dbl):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:flt):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:lng]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:lng):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:lng]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:int,b:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:int],v:dbl):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:int,b:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:int],v:flt):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:int,b:bat[:lng]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:int],v:lng):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:lng]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:int,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:int,b:bat[:wrd]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:int],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:int],v:wrd):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:int,b:bat[:int]):bat[:int] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:int],v:int):bat[:int] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:int,b:bat[:sht]):bat[:int] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:int],v:sht):bat[:int] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:int,b:bat[:bte]):bat[:int] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:int],v:bte):bat[:int] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:dbl):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:flt):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:lng]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:lng):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:lng]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:wrd]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:wrd):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:int]):bat[:int] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:int):bat[:int] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:int]):bat[:int] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:dbl):bat[:dbl] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:flt):bat[:flt] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:flt]):bat[:flt] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:lng]):bat[:lng] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:lng):bat[:lng] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:lng]):bat[:lng] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:wrd]):bat[:wrd] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:wrd):bat[:wrd] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:int]):bat[:int] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:int):bat[:int] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:int]):bat[:int] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:sht]):bat[:sht] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:sht):bat[:sht] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:sht]):bat[:sht] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMULsignal;
comment Return V * B with candidates list, signal error on overflow

pattern batcalc.*(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatMULsignal;
comment Return V * B, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMULsignal;
comment Return B * V with candidates list, signal error on overflow

pattern batcalc.*(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatMULsignal;
comment Return B * V, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMULsignal;
comment Return B1 * B2 with candidates list, signal error on overflow

pattern batcalc.*(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatMULsignal;
comment Return B1 * B2, signal error on overflow

pattern batcalc.*(v:flt,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:flt,b:bat[:flt]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:flt],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:flt],v:flt):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:flt],b2:bat[:flt]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:flt,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:flt,b:bat[:lng]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:flt],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:flt],v:lng):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:flt],b2:bat[:lng]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:flt,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:flt,b:bat[:int]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:flt],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:flt],v:int):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:flt],b2:bat[:int]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:flt,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:flt,b:bat[:sht]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:flt],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:flt],v:sht):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:flt],b2:bat[:sht]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:flt,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:flt,b:bat[:bte]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:flt],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:flt],v:bte):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:flt],b2:bat[:bte]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:lng,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:lng,b:bat[:flt]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:lng],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:lng],v:flt):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:lng],b2:bat[:flt]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:int,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:int,b:bat[:flt]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:int],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:int],v:flt):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:int],b2:bat[:flt]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:int,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:int,b:bat[:int]):bat[:lng] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:int],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:int],v:int):bat[:lng] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:int],b2:bat[:int]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:int,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:int,b:bat[:sht]):bat[:lng] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:int],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:int],v:sht):bat[:lng] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:int],b2:bat[:sht]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:int,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:int,b:bat[:bte]):bat[:lng] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:int],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:int],v:bte):bat[:lng] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:int],b2:bat[:bte]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:sht,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:sht,b:bat[:flt]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:sht],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:sht],v:flt):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:sht],b2:bat[:flt]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:sht,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:sht,b:bat[:int]):bat[:lng] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:sht],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:sht],v:int):bat[:lng] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:sht],b2:bat[:int]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:sht,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:sht,b:bat[:sht]):bat[:int] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:sht],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:sht],v:sht):bat[:int] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:sht],b2:bat[:sht]):bat[:int] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:sht,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:sht,b:bat[:bte]):bat[:int] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:sht],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:sht],v:bte):bat[:int] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:sht],b2:bat[:bte]):bat[:int] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:bte,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:bte,b:bat[:flt]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:bte],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:bte],v:flt):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:bte],b2:bat[:flt]):bat[:dbl] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:bte,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:bte,b:bat[:int]):bat[:lng] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:bte],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:bte],v:int):bat[:lng] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:bte],b2:bat[:int]):bat[:lng] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:bte,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:bte,b:bat[:sht]):bat[:int] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:bte],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:bte],v:sht):bat[:int] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:bte],b2:bat[:sht]):bat[:int] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.*(v:bte,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatMULenlarge;
comment Return V * B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(v:bte,b:bat[:bte]):bat[:sht] 
address CMDbatMULenlarge;
comment Return V * B, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:bte],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatMULenlarge;
comment Return B * V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b:bat[:bte],v:bte):bat[:sht] 
address CMDbatMULenlarge;
comment Return B * V, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatMULenlarge;
comment Return B1 * B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.*(b1:bat[:bte],b2:bat[:bte]):bat[:sht] 
address CMDbatMULenlarge;
comment Return B1 * B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:str,b:bat[:str],s:bat[:oid]):bat[:str] 
address CMDbatADD;
comment Return concatenation of V and B with candidates list

pattern batcalc.+(v:str,b:bat[:str]):bat[:str] 
address CMDbatADD;
comment Return concatenation of V and B

pattern batcalc.+(b:bat[:str],v:str,s:bat[:oid]):bat[:str] 
address CMDbatADD;
comment Return concatenation of B and V with candidates list

pattern batcalc.+(b:bat[:str],v:str):bat[:str] 
address CMDbatADD;
comment Return concatenation of B and V

pattern batcalc.+(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:str] 
address CMDbatADD;
comment Return concatenation of B1 and B2 with candidates list

pattern batcalc.+(b1:bat[:str],b2:bat[:str]):bat[:str] 
address CMDbatADD;
comment Return concatenation of B1 and B2

pattern batcalc.+(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:dbl):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:flt]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:flt):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:lng]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:lng):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:wrd]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:wrd):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:wrd]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:int]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:int):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:sht]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:sht):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:dbl,b:bat[:bte]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:dbl],v:bte):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:dbl):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:flt):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:lng]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:lng):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:lng]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:wrd]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:wrd):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:wrd]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:int]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:int):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:int]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:sht]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:sht):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:sht]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:bte]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:flt],v:bte):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:flt],b2:bat[:bte]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:dbl):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:flt):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:int):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:dbl):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:flt):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:lng]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:lng):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:lng]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:int,b:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:int],v:dbl):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:int,b:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:int],v:flt):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:int,b:bat[:lng]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:int],v:lng):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:lng]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:int,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:int,b:bat[:wrd]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:int],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:int],v:wrd):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:wrd]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:int,b:bat[:int]):bat[:int] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:int],v:int):bat[:int] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:int,b:bat[:sht]):bat[:int] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:int],v:sht):bat[:int] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:int,b:bat[:bte]):bat[:int] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:int],v:bte):bat[:int] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:dbl):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:flt):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:lng]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:lng):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:lng]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:wrd]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:wrd):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:wrd]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:int]):bat[:int] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:int):bat[:int] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:int]):bat[:int] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:dbl):bat[:dbl] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:flt):bat[:flt] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:flt]):bat[:flt] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:lng]):bat[:lng] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:lng):bat[:lng] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:lng]):bat[:lng] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:wrd]):bat[:wrd] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:wrd):bat[:wrd] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:wrd]):bat[:wrd] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:int]):bat[:int] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:int):bat[:int] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:int]):bat[:int] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:sht]):bat[:sht] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:sht):bat[:sht] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:sht]):bat[:sht] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatADDsignal;
comment Return V + B with candidates list, signal error on overflow

pattern batcalc.+(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatADDsignal;
comment Return V + B, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatADDsignal;
comment Return B + V with candidates list, signal error on overflow

pattern batcalc.+(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatADDsignal;
comment Return B + V, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatADDsignal;
comment Return B1 + B2 with candidates list, signal error on overflow

pattern batcalc.+(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatADDsignal;
comment Return B1 + B2, signal error on overflow

pattern batcalc.+(v:flt,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:flt,b:bat[:flt]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:flt],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:flt],v:flt):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:flt],b2:bat[:flt]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:flt,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:flt,b:bat[:lng]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:flt],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:flt],v:lng):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:flt],b2:bat[:lng]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:flt,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:flt,b:bat[:int]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:flt],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:flt],v:int):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:flt],b2:bat[:int]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:flt,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:flt,b:bat[:sht]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:flt],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:flt],v:sht):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:flt],b2:bat[:sht]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:flt,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:flt,b:bat[:bte]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:flt],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:flt],v:bte):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:flt],b2:bat[:bte]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:lng,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:lng,b:bat[:flt]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:lng],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:lng],v:flt):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:lng],b2:bat[:flt]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:int,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:int,b:bat[:flt]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:int],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:int],v:flt):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:int],b2:bat[:flt]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:int,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:int,b:bat[:int]):bat[:lng] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:int],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:int],v:int):bat[:lng] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:int],b2:bat[:int]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:int,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:int,b:bat[:sht]):bat[:lng] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:int],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:int],v:sht):bat[:lng] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:int],b2:bat[:sht]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:int,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:int,b:bat[:bte]):bat[:lng] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:int],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:int],v:bte):bat[:lng] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:int],b2:bat[:bte]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:sht,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:sht,b:bat[:flt]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:sht],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:sht],v:flt):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:sht],b2:bat[:flt]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:sht,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:sht,b:bat[:int]):bat[:lng] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:sht],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:sht],v:int):bat[:lng] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:sht],b2:bat[:int]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:sht,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:sht,b:bat[:sht]):bat[:int] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:sht],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:sht],v:sht):bat[:int] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:sht],b2:bat[:sht]):bat[:int] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:sht,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:sht,b:bat[:bte]):bat[:int] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:sht],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:sht],v:bte):bat[:int] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:sht],b2:bat[:bte]):bat[:int] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:bte,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:bte,b:bat[:flt]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:bte],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:bte],v:flt):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:bte],b2:bat[:flt]):bat[:dbl] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:bte,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:bte,b:bat[:int]):bat[:lng] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:bte],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:bte],v:int):bat[:lng] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:bte],b2:bat[:int]):bat[:lng] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:bte,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:bte,b:bat[:sht]):bat[:int] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:bte],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:bte],v:sht):bat[:int] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:bte],b2:bat[:sht]):bat[:int] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.+(v:bte,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatADDenlarge;
comment Return V + B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(v:bte,b:bat[:bte]):bat[:sht] 
address CMDbatADDenlarge;
comment Return V + B, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:bte],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatADDenlarge;
comment Return B + V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b:bat[:bte],v:bte):bat[:sht] 
address CMDbatADDenlarge;
comment Return B + V, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatADDenlarge;
comment Return B1 + B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.+(b1:bat[:bte],b2:bat[:bte]):bat[:sht] 
address CMDbatADDenlarge;
comment Return B1 + B2, guarantee no overflow by returning larger type

pattern batcalc.++(b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatINCR;
comment Unary increment over the tail of the bat with candidates list

pattern batcalc.++(b:bat[:dbl]):bat[:dbl] 
address CMDbatINCR;
comment Unary increment over the tail of the bat

pattern batcalc.++(b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatINCR;
comment Unary increment over the tail of the bat with candidates list

pattern batcalc.++(b:bat[:flt]):bat[:flt] 
address CMDbatINCR;
comment Unary increment over the tail of the bat

pattern batcalc.++(b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatINCR;
comment Unary increment over the tail of the bat with candidates list

pattern batcalc.++(b:bat[:lng]):bat[:lng] 
address CMDbatINCR;
comment Unary increment over the tail of the bat

pattern batcalc.++(b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatINCR;
comment Unary increment over the tail of the bat with candidates list

pattern batcalc.++(b:bat[:wrd]):bat[:wrd] 
address CMDbatINCR;
comment Unary increment over the tail of the bat

pattern batcalc.++(b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatINCR;
comment Unary increment over the tail of the bat with candidates list

pattern batcalc.++(b:bat[:int]):bat[:int] 
address CMDbatINCR;
comment Unary increment over the tail of the bat

pattern batcalc.++(b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatINCR;
comment Unary increment over the tail of the bat with candidates list

pattern batcalc.++(b:bat[:sht]):bat[:sht] 
address CMDbatINCR;
comment Unary increment over the tail of the bat

pattern batcalc.++(b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatINCR;
comment Unary increment over the tail of the bat with candidates list

pattern batcalc.++(b:bat[:bte]):bat[:bte] 
address CMDbatINCR;
comment Unary increment over the tail of the bat

pattern batcalc.-(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:dbl):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:flt]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:flt):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:lng]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:lng):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:wrd]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:wrd):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:wrd]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:int]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:int):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:sht]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:sht):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:dbl,b:bat[:bte]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:dbl],v:bte):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:dbl):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:flt):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:lng]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:lng):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:lng]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:wrd]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:wrd):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:wrd]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:int]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:int):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:int]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:sht]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:sht):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:sht]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:bte]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:flt],v:bte):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:flt],b2:bat[:bte]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:dbl):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:flt):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:int):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:dbl):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:flt):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:lng]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:lng):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:lng]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:int,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:int],v:dbl):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:int,b:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:int],v:flt):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:int,b:bat[:lng]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:int],v:lng):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:lng]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:int,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:int,b:bat[:wrd]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:int],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:int],v:wrd):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:wrd]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:int,b:bat[:int]):bat[:int] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:int],v:int):bat[:int] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:int,b:bat[:sht]):bat[:int] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:int],v:sht):bat[:int] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:int,b:bat[:bte]):bat[:int] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:int],v:bte):bat[:int] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:dbl):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:flt):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:lng]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:lng):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:lng]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:wrd]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:wrd):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:wrd]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:int]):bat[:int] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:int):bat[:int] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:int]):bat[:int] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:dbl):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:flt):bat[:flt] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:flt]):bat[:flt] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:lng]):bat[:lng] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:lng):bat[:lng] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:lng]):bat[:lng] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:wrd]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:wrd):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:wrd]):bat[:wrd] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:int]):bat[:int] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:int):bat[:int] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:int]):bat[:int] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:sht]):bat[:sht] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:sht):bat[:sht] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:sht]):bat[:sht] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatSUBsignal;
comment Return V - B with candidates list, signal error on overflow

pattern batcalc.-(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatSUBsignal;
comment Return V - B, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatSUBsignal;
comment Return B - V with candidates list, signal error on overflow

pattern batcalc.-(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatSUBsignal;
comment Return B - V, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatSUBsignal;
comment Return B1 - B2 with candidates list, signal error on overflow

pattern batcalc.-(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatSUBsignal;
comment Return B1 - B2, signal error on overflow

pattern batcalc.-(v:flt,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:flt,b:bat[:flt]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:flt],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:flt],v:flt):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:flt],b2:bat[:flt]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:flt,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:flt,b:bat[:lng]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:flt],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:flt],v:lng):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:flt],b2:bat[:lng]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:flt,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:flt,b:bat[:int]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:flt],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:flt],v:int):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:flt],b2:bat[:int]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:flt,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:flt,b:bat[:sht]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:flt],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:flt],v:sht):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:flt],b2:bat[:sht]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:flt,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:flt,b:bat[:bte]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:flt],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:flt],v:bte):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:flt],b2:bat[:bte]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:lng,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:lng,b:bat[:flt]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:lng],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:lng],v:flt):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:lng],b2:bat[:flt]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:int,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:int,b:bat[:flt]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:int],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:int],v:flt):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:int],b2:bat[:flt]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:int,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:int,b:bat[:int]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:int],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:int],v:int):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:int],b2:bat[:int]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:int,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:int,b:bat[:sht]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:int],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:int],v:sht):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:int],b2:bat[:sht]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:int,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:int,b:bat[:bte]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:int],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:int],v:bte):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:int],b2:bat[:bte]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:sht,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:sht,b:bat[:flt]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:sht],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:sht],v:flt):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:sht],b2:bat[:flt]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:sht,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:sht,b:bat[:int]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:sht],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:sht],v:int):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:sht],b2:bat[:int]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:sht,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:sht,b:bat[:sht]):bat[:int] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:sht],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:sht],v:sht):bat[:int] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:sht],b2:bat[:sht]):bat[:int] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:sht,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:sht,b:bat[:bte]):bat[:int] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:sht],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:sht],v:bte):bat[:int] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:sht],b2:bat[:bte]):bat[:int] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:bte,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:bte,b:bat[:flt]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:bte],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:bte],v:flt):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:bte],b2:bat[:flt]):bat[:dbl] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:bte,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:bte,b:bat[:int]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:bte],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:bte],v:int):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:bte],b2:bat[:int]):bat[:lng] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:bte,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:bte,b:bat[:sht]):bat[:int] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:bte],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:bte],v:sht):bat[:int] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:bte],b2:bat[:sht]):bat[:int] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.-(v:bte,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatSUBenlarge;
comment Return V - B with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(v:bte,b:bat[:bte]):bat[:sht] 
address CMDbatSUBenlarge;
comment Return V - B, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:bte],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatSUBenlarge;
comment Return B - V with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b:bat[:bte],v:bte):bat[:sht] 
address CMDbatSUBenlarge;
comment Return B - V, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatSUBenlarge;
comment Return B1 - B2 with candidates list, guarantee no overflow by returning larger type

pattern batcalc.-(b1:bat[:bte],b2:bat[:bte]):bat[:sht] 
address CMDbatSUBenlarge;
comment Return B1 - B2, guarantee no overflow by returning larger type

pattern batcalc.--(b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat with candidates list

pattern batcalc.--(b:bat[:dbl]):bat[:dbl] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat

pattern batcalc.--(b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat with candidates list

pattern batcalc.--(b:bat[:flt]):bat[:flt] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat

pattern batcalc.--(b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat with candidates list

pattern batcalc.--(b:bat[:lng]):bat[:lng] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat

pattern batcalc.--(b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat with candidates list

pattern batcalc.--(b:bat[:wrd]):bat[:wrd] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat

pattern batcalc.--(b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat with candidates list

pattern batcalc.--(b:bat[:int]):bat[:int] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat

pattern batcalc.--(b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat with candidates list

pattern batcalc.--(b:bat[:sht]):bat[:sht] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat

pattern batcalc.--(b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat with candidates list

pattern batcalc.--(b:bat[:bte]):bat[:bte] 
address CMDbatDECR;
comment Unary decrement over the tail of the bat

pattern batcalc.-(b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatNEG;
comment Unary neg over the tail of the bat with candidates list

pattern batcalc.-(b:bat[:dbl]):bat[:dbl] 
address CMDbatNEG;
comment Unary neg over the tail of the bat

pattern batcalc.-(b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatNEG;
comment Unary neg over the tail of the bat with candidates list

pattern batcalc.-(b:bat[:flt]):bat[:flt] 
address CMDbatNEG;
comment Unary neg over the tail of the bat

pattern batcalc.-(b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatNEG;
comment Unary neg over the tail of the bat with candidates list

pattern batcalc.-(b:bat[:lng]):bat[:lng] 
address CMDbatNEG;
comment Unary neg over the tail of the bat

pattern batcalc.-(b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatNEG;
comment Unary neg over the tail of the bat with candidates list

pattern batcalc.-(b:bat[:wrd]):bat[:wrd] 
address CMDbatNEG;
comment Unary neg over the tail of the bat

pattern batcalc.-(b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatNEG;
comment Unary neg over the tail of the bat with candidates list

pattern batcalc.-(b:bat[:int]):bat[:int] 
address CMDbatNEG;
comment Unary neg over the tail of the bat

pattern batcalc.-(b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatNEG;
comment Unary neg over the tail of the bat with candidates list

pattern batcalc.-(b:bat[:sht]):bat[:sht] 
address CMDbatNEG;
comment Unary neg over the tail of the bat

pattern batcalc.-(b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatNEG;
comment Unary neg over the tail of the bat with candidates list

pattern batcalc.-(b:bat[:bte]):bat[:bte] 
address CMDbatNEG;
comment Unary neg over the tail of the bat

pattern batcalc./(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:dbl):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:flt]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:flt):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:lng]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:lng):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:wrd]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:wrd):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:wrd]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:int]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:int):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:sht]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:sht):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:dbl,b:bat[:bte]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:dbl],v:bte):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:flt,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:flt],v:dbl):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:flt,b:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:flt],v:flt):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:flt,b:bat[:lng]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:flt],v:lng):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:lng]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:flt,b:bat[:wrd]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:flt],v:wrd):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:wrd]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:flt,b:bat[:int]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:flt],v:int):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:int]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:flt,b:bat[:sht]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:flt],v:sht):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:sht]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:flt,b:bat[:bte]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:flt],v:bte):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:flt],b2:bat[:bte]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:lng,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:lng],v:dbl):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:lng,b:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:lng],v:flt):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:lng],v:int):bat[:lng] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:dbl):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:flt):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:lng]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:lng):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:lng]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:int,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:int],v:dbl):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:int,b:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:int],v:flt):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:int,b:bat[:lng]):bat[:int] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:int],v:lng):bat[:int] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:lng]):bat[:int] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:int,b:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:int,b:bat[:wrd]):bat[:int] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:int],v:wrd,s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:int],v:wrd):bat[:int] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:wrd]):bat[:int] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:int,b:bat[:int]):bat[:int] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:int],v:int):bat[:int] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:int,b:bat[:sht]):bat[:int] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:int],v:sht):bat[:int] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:int,b:bat[:bte]):bat[:int] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:int],v:bte):bat[:int] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:sht,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:sht],v:dbl):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:sht,b:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:sht],v:flt):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:sht,b:bat[:lng]):bat[:sht] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:sht],v:lng):bat[:sht] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:lng]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:sht,b:bat[:wrd]):bat[:sht] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:sht],v:wrd):bat[:sht] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:wrd]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:sht,b:bat[:int]):bat[:sht] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:sht],v:int):bat[:sht] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:int]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:bte,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:bte],v:dbl):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:bte,b:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:bte],v:flt):bat[:flt] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:flt]):bat[:flt] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:bte,b:bat[:lng]):bat[:bte] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:bte],v:lng):bat[:bte] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:lng]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:bte,b:bat[:wrd]):bat[:bte] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:bte],v:wrd):bat[:bte] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:wrd]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:bte,b:bat[:int]):bat[:bte] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:bte],v:int):bat[:bte] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:int]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:bte,b:bat[:sht]):bat[:bte] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:bte],v:sht):bat[:bte] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:sht]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc./(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return V / B with candidates list, signal error on overflow

pattern batcalc./(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatDIVsignal;
comment Return V / B, signal error on overflow

pattern batcalc./(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B / V with candidates list, signal error on overflow

pattern batcalc./(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatDIVsignal;
comment Return B / V, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B1 / B2 with candidates list, signal error on overflow

pattern batcalc./(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatDIVsignal;
comment Return B1 / B2, signal error on overflow

pattern batcalc.<=(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:dbl,b:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:dbl],v:dbl):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:dbl,b:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:dbl],v:flt):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:dbl,b:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:dbl],v:lng):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:dbl,b:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:dbl],v:wrd):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:dbl,b:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:dbl],v:int):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:dbl,b:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:dbl],v:sht):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:dbl,b:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:dbl],v:bte):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:flt,b:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:flt],v:dbl):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:flt,b:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:flt],v:flt):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:flt],b2:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:flt,b:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:flt],v:lng):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:flt],b2:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:flt,b:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:flt],v:wrd):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:flt],b2:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:flt,b:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:flt],v:int):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:flt],b2:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:flt,b:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:flt],v:sht):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:flt],b2:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:flt,b:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:flt],v:bte):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:flt],b2:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:lng,b:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:lng],v:dbl):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:lng,b:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:lng],v:flt):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:lng],b2:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:lng,b:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:lng],v:lng):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:lng],b2:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:lng,b:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:lng],v:wrd):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:lng],b2:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:lng,b:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:lng],v:int):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:lng],b2:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:lng,b:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:lng],v:sht):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:lng],b2:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:lng,b:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:lng],v:bte):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:lng],b2:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:wrd,b:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:wrd],v:dbl):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:wrd,b:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:wrd],v:flt):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:wrd,b:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:wrd],v:lng):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:wrd,b:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:wrd],v:wrd):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:wrd,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:wrd,b:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:wrd],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:wrd],v:int):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:wrd,b:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:wrd],v:sht):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:wrd,b:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:wrd],v:bte):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:wrd],b2:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:int,b:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:int],v:dbl):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:int],b2:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:int,b:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:int],v:flt):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:int],b2:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:int,b:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:int],v:lng):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:int],b2:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:int,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:int,b:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:int],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:int],v:wrd):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:int],b2:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:int,b:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:int],v:int):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:int],b2:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:int,b:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:int],v:sht):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:int],b2:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:int,b:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:int],v:bte):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:int],b2:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:sht,b:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:sht],v:dbl):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:sht,b:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:sht],v:flt):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:sht],b2:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:sht,b:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:sht],v:lng):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:sht],b2:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:sht,b:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:sht],v:wrd):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:sht],b2:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:sht,b:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:sht],v:int):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:sht],b2:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:sht,b:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:sht],v:sht):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:sht],b2:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:sht,b:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:sht],v:bte):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:sht],b2:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:bte,b:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:bte],v:dbl):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:bte,b:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:bte],v:flt):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:bte],b2:bat[:flt]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:bte,b:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:bte],v:lng):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:bte],b2:bat[:lng]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:bte,b:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:bte],v:wrd):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:bte],b2:bat[:wrd]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:bte,b:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:bte],v:int):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:bte],b2:bat[:int]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:bte,b:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:bte],v:sht):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:bte],b2:bat[:sht]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:bte,b:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:bte],v:bte):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:bte],b2:bat[:bte]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:oid,b:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:oid],v:oid):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:oid],b2:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:str,b:bat[:str]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:str],v:str):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:str],b2:bat[:str]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:bit,b:bat[:bit]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:bit],v:bit):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:bit],b2:bat[:bit]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:dbl,b:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:dbl],v:dbl):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:dbl,b:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:dbl],v:flt):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:dbl,b:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:dbl],v:lng):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:dbl,b:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:dbl],v:wrd):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:dbl],b2:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:dbl,b:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:dbl],v:int):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:dbl],b2:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:dbl,b:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:dbl],v:sht):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:dbl,b:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:dbl],v:bte):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:flt,b:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:flt],v:dbl):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:flt,b:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:flt],v:flt):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:flt],b2:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:flt,b:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:flt],v:lng):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:flt],b2:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:flt,b:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:flt],v:wrd):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:flt],b2:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:flt,b:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:flt],v:int):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:flt],b2:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:flt,b:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:flt],v:sht):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:flt],b2:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:flt,b:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:flt],v:bte):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:flt],b2:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:lng,b:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:lng],v:dbl):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:lng,b:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:lng],v:flt):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:lng],b2:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:lng,b:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:lng],v:lng):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:lng],b2:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:lng,b:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:lng],v:wrd):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:lng],b2:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:lng,b:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:lng],v:int):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:lng],b2:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:lng,b:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:lng],v:sht):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:lng],b2:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:lng,b:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:lng],v:bte):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:lng],b2:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:wrd,b:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:wrd],v:dbl):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:wrd],b2:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:wrd,b:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:wrd],v:flt):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:wrd],b2:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:wrd,b:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:wrd],v:lng):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:wrd],b2:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:wrd,b:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:wrd],v:wrd):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:wrd],b2:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:wrd,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:wrd,b:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:wrd],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:wrd],v:int):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:wrd],b2:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:wrd,b:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:wrd],v:sht):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:wrd],b2:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:wrd,b:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:wrd],v:bte):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:wrd],b2:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:int,b:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:int],v:dbl):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:int],b2:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:int,b:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:int],v:flt):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:int],b2:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:int,b:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:int],v:lng):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:int],b2:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:int,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:int,b:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:int],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:int],v:wrd):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:int],b2:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:int,b:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:int],v:int):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:int],b2:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:int,b:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:int],v:sht):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:int],b2:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:int,b:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:int],v:bte):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:int],b2:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:sht,b:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:sht],v:dbl):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:sht,b:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:sht],v:flt):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:sht],b2:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:sht,b:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:sht],v:lng):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:sht],b2:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:sht,b:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:sht],v:wrd):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:sht],b2:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:sht,b:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:sht],v:int):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:sht],b2:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:sht,b:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:sht],v:sht):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:sht],b2:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:sht,b:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:sht],v:bte):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:sht],b2:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:bte,b:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:bte],v:dbl):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:bte,b:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:bte],v:flt):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:bte],b2:bat[:flt]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:bte,b:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:bte],v:lng):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:bte],b2:bat[:lng]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:bte,b:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:bte],v:wrd):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:bte],b2:bat[:wrd]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:bte,b:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:bte],v:int):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:bte],b2:bat[:int]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:bte,b:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:bte],v:sht):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:bte],b2:bat[:sht]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:bte,b:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:bte],v:bte):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:bte],b2:bat[:bte]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:oid,b:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:oid],v:oid):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:oid],b2:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:str,b:bat[:str]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:str],v:str):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:str],b2:bat[:str]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:bit,b:bat[:bit]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:bit],v:bit):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:bit],b2:bat[:bit]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<<(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:lng],v:int):bat[:lng] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:wrd,b:bat[:lng]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:wrd],v:lng):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:wrd],b2:bat[:lng]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:int,b:bat[:lng]):bat[:int] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:int],v:lng):bat[:int] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:int],b2:bat[:lng]):bat[:int] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:int,b:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:int,b:bat[:wrd]):bat[:int] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:int],v:wrd,s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:int],v:wrd):bat[:int] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:int],b2:bat[:wrd]):bat[:int] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:int,b:bat[:int]):bat[:int] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:int],v:int):bat[:int] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:int,b:bat[:sht]):bat[:int] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:int],v:sht):bat[:int] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:int,b:bat[:bte]):bat[:int] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:int],v:bte):bat[:int] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:sht,b:bat[:lng]):bat[:sht] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:sht],v:lng):bat[:sht] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:sht],b2:bat[:lng]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:sht,b:bat[:wrd]):bat[:sht] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:sht],v:wrd):bat[:sht] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:sht],b2:bat[:wrd]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:sht,b:bat[:int]):bat[:sht] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:sht],v:int):bat[:sht] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:sht],b2:bat[:int]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:bte,b:bat[:lng]):bat[:bte] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:bte],v:lng):bat[:bte] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:bte],b2:bat[:lng]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:bte,b:bat[:wrd]):bat[:bte] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:bte],v:wrd):bat[:bte] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:bte],b2:bat[:wrd]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:bte,b:bat[:int]):bat[:bte] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:bte],v:int):bat[:bte] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:bte],b2:bat[:int]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:bte,b:bat[:sht]):bat[:bte] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:bte],v:sht):bat[:bte] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:bte],b2:bat[:sht]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<<(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return V << B with candidates list, raise error on out of range second operand

pattern batcalc.<<(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatLSHsignal;
comment Return V << B, raise error on out of range second operand

pattern batcalc.<<(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B << V with candidates list, raise error on out of range second operand

pattern batcalc.<<(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatLSHsignal;
comment Return B << V, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B1 << B2 with candidates list, raise error on out of range second operand

pattern batcalc.<<(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatLSHsignal;
comment Return B1 << B2, raise error on out of range second operand

pattern batcalc.<=(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:timestamp,b:bat[:timestamp]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:timestamp],v:timestamp):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:daytime,b:bat[:daytime]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:daytime],v:daytime):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<=(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return V <= B with candidates list

pattern batcalc.<=(v:date,b:bat[:date]):bat[:bit] 
address CMDbatLE;
comment Return V <= B

pattern batcalc.<=(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B <= V with candidates list

pattern batcalc.<=(b:bat[:date],v:date):bat[:bit] 
address CMDbatLE;
comment Return B <= V

pattern batcalc.<=(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2 with candidates list

pattern batcalc.<=(b1:bat[:date],b2:bat[:date]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:timestamp,b:bat[:timestamp]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:timestamp],v:timestamp):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:daytime,b:bat[:daytime]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:daytime],v:daytime):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return V < B with candidates list

pattern batcalc.<(v:date,b:bat[:date]):bat[:bit] 
address CMDbatLT;
comment Return V < B

pattern batcalc.<(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B < V with candidates list

pattern batcalc.<(b:bat[:date],v:date):bat[:bit] 
address CMDbatLT;
comment Return B < V

pattern batcalc.<(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2 with candidates list

pattern batcalc.<(b1:bat[:date],b2:bat[:date]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<=(b1:bat[:json],b2:bat[:json]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<(b1:bat[:json],b2:bat[:json]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.<=(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] 
address CMDbatLE;
comment Return B1 <= B2

pattern batcalc.<(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] 
address CMDbatLT;
comment Return B1 < B2

pattern batcalc.==(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:dbl,b:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:dbl],v:dbl):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:dbl,b:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:dbl],v:flt):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:dbl,b:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:dbl],v:lng):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:dbl,b:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:dbl],v:wrd):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:dbl],b2:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:dbl,b:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:dbl],v:int):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:dbl],b2:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:dbl,b:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:dbl],v:sht):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:dbl,b:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:dbl],v:bte):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:flt,b:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:flt],v:dbl):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:flt,b:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:flt],v:flt):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:flt],b2:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:flt,b:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:flt],v:lng):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:flt],b2:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:flt,b:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:flt],v:wrd):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:flt],b2:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:flt,b:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:flt],v:int):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:flt],b2:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:flt,b:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:flt],v:sht):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:flt],b2:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:flt,b:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:flt],v:bte):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:flt],b2:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:lng,b:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:lng],v:dbl):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:lng,b:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:lng],v:flt):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:lng],b2:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:lng,b:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:lng],v:lng):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:lng],b2:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:lng,b:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:lng],v:wrd):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:lng],b2:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:lng,b:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:lng],v:int):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:lng],b2:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:lng,b:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:lng],v:sht):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:lng],b2:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:lng,b:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:lng],v:bte):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:lng],b2:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:wrd,b:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:wrd],v:dbl):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:wrd],b2:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:wrd,b:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:wrd],v:flt):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:wrd],b2:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:wrd,b:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:wrd],v:lng):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:wrd],b2:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:wrd,b:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:wrd],v:wrd):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:wrd],b2:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:wrd,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:wrd,b:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:wrd],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:wrd],v:int):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:wrd],b2:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:wrd,b:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:wrd],v:sht):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:wrd],b2:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:wrd,b:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:wrd],v:bte):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:wrd],b2:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:int,b:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:int],v:dbl):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:int],b2:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:int,b:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:int],v:flt):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:int],b2:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:int,b:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:int],v:lng):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:int],b2:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:int,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:int,b:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:int],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:int],v:wrd):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:int],b2:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:int,b:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:int],v:int):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:int],b2:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:int,b:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:int],v:sht):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:int],b2:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:int,b:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:int],v:bte):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:int],b2:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:sht,b:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:sht],v:dbl):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:sht,b:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:sht],v:flt):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:sht],b2:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:sht,b:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:sht],v:lng):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:sht],b2:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:sht,b:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:sht],v:wrd):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:sht],b2:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:sht,b:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:sht],v:int):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:sht],b2:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:sht,b:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:sht],v:sht):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:sht],b2:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:sht,b:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:sht],v:bte):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:sht],b2:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:bte,b:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:bte],v:dbl):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:bte,b:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:bte],v:flt):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:bte],b2:bat[:flt]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:bte,b:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:bte],v:lng):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:bte],b2:bat[:lng]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:bte,b:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:bte],v:wrd):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:bte],b2:bat[:wrd]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:bte,b:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:bte],v:int):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:bte],b2:bat[:int]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:bte,b:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:bte],v:sht):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:bte],b2:bat[:sht]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:bte,b:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:bte],v:bte):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:bte],b2:bat[:bte]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:oid,b:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:oid],v:oid):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:oid],b2:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:str,b:bat[:str]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:str],v:str):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:str],b2:bat[:str]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:bit,b:bat[:bit]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:bit],v:bit):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:bit],b2:bat[:bit]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:timestamp,b:bat[:timestamp]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:timestamp],v:timestamp):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:daytime,b:bat[:daytime]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:daytime],v:daytime):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return V == B with candidates list

pattern batcalc.==(v:date,b:bat[:date]):bat[:bit] 
address CMDbatEQ;
comment Return V == B

pattern batcalc.==(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B == V with candidates list

pattern batcalc.==(b:bat[:date],v:date):bat[:bit] 
address CMDbatEQ;
comment Return B == V

pattern batcalc.==(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2 with candidates list

pattern batcalc.==(b1:bat[:date],b2:bat[:date]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(b1:bat[:json],b2:bat[:json]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.==(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] 
address CMDbatEQ;
comment Return B1 == B2

pattern batcalc.>=(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:dbl,b:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:dbl],v:dbl):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:dbl,b:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:dbl],v:flt):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:dbl,b:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:dbl],v:lng):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:dbl,b:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:dbl],v:wrd):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:dbl,b:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:dbl],v:int):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:dbl,b:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:dbl],v:sht):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:dbl,b:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:dbl],v:bte):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:flt,b:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:flt],v:dbl):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:flt,b:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:flt],v:flt):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:flt],b2:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:flt,b:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:flt],v:lng):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:flt],b2:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:flt,b:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:flt],v:wrd):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:flt],b2:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:flt,b:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:flt],v:int):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:flt],b2:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:flt,b:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:flt],v:sht):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:flt],b2:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:flt,b:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:flt],v:bte):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:flt],b2:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:lng,b:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:lng],v:dbl):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:lng,b:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:lng],v:flt):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:lng],b2:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:lng,b:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:lng],v:lng):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:lng],b2:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:lng,b:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:lng],v:wrd):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:lng],b2:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:lng,b:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:lng],v:int):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:lng],b2:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:lng,b:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:lng],v:sht):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:lng],b2:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:lng,b:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:lng],v:bte):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:lng],b2:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:wrd,b:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:wrd],v:dbl):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:wrd,b:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:wrd],v:flt):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:wrd,b:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:wrd],v:lng):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:wrd,b:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:wrd],v:wrd):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:wrd,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:wrd,b:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:wrd],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:wrd],v:int):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:wrd,b:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:wrd],v:sht):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:wrd,b:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:wrd],v:bte):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:wrd],b2:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:int,b:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:int],v:dbl):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:int],b2:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:int,b:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:int],v:flt):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:int],b2:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:int,b:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:int],v:lng):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:int],b2:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:int,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:int,b:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:int],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:int],v:wrd):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:int],b2:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:int,b:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:int],v:int):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:int],b2:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:int,b:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:int],v:sht):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:int],b2:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:int,b:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:int],v:bte):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:int],b2:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:sht,b:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:sht],v:dbl):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:sht,b:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:sht],v:flt):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:sht],b2:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:sht,b:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:sht],v:lng):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:sht],b2:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:sht,b:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:sht],v:wrd):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:sht],b2:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:sht,b:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:sht],v:int):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:sht],b2:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:sht,b:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:sht],v:sht):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:sht],b2:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:sht,b:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:sht],v:bte):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:sht],b2:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:bte,b:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:bte],v:dbl):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:bte,b:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:bte],v:flt):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:bte],b2:bat[:flt]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:bte,b:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:bte],v:lng):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:bte],b2:bat[:lng]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:bte,b:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:bte],v:wrd):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:bte],b2:bat[:wrd]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:bte,b:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:bte],v:int):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:bte],b2:bat[:int]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:bte,b:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:bte],v:sht):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:bte],b2:bat[:sht]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:bte,b:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:bte],v:bte):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:bte],b2:bat[:bte]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:oid,b:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:oid],v:oid):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:oid],b2:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:str,b:bat[:str]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:str],v:str):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:str],b2:bat[:str]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:bit,b:bat[:bit]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:bit],v:bit):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:bit],b2:bat[:bit]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:dbl,b:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:dbl],v:dbl):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:dbl],b2:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:dbl,b:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:dbl],v:flt):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:dbl],b2:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:dbl,b:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:dbl],v:lng):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:dbl],b2:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:dbl,b:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:dbl],v:wrd):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:dbl],b2:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:dbl,b:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:dbl],v:int):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:dbl],b2:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:dbl,b:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:dbl],v:sht):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:dbl],b2:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:dbl,b:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:dbl],v:bte):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:dbl],b2:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:flt,b:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:flt],v:dbl):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:flt],b2:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:flt,b:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:flt],v:flt):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:flt],b2:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:flt,b:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:flt],v:lng):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:flt],b2:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:flt,b:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:flt],v:wrd):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:flt],b2:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:flt,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:flt,b:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:flt],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:flt],v:int):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:flt],b2:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:flt,b:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:flt],v:sht):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:flt],b2:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:flt,b:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:flt],v:bte):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:flt],b2:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:lng,b:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:lng],v:dbl):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:lng],b2:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:lng,b:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:lng],v:flt):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:lng],b2:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:lng,b:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:lng],v:lng):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:lng],b2:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:lng,b:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:lng],v:wrd):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:lng],b2:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:lng,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:lng,b:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:lng],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:lng],v:int):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:lng],b2:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:lng,b:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:lng],v:sht):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:lng],b2:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:lng,b:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:lng],v:bte):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:lng],b2:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:wrd,b:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:wrd],v:dbl):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:wrd],b2:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:wrd,b:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:wrd],v:flt):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:wrd],b2:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:wrd,b:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:wrd],v:lng):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:wrd],b2:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:wrd,b:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:wrd],v:wrd):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:wrd],b2:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:wrd,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:wrd,b:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:wrd],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:wrd],v:int):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:wrd],b2:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:wrd,b:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:wrd],v:sht):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:wrd],b2:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:wrd,b:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:wrd],v:bte):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:wrd],b2:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:int,b:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:int],v:dbl):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:int],b2:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:int,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:int,b:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:int],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:int],v:flt):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:int],b2:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:int,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:int,b:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:int],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:int],v:lng):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:int],b2:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:int,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:int,b:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:int],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:int],v:wrd):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:int],b2:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:int,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:int,b:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:int],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:int],v:int):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:int],b2:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:int,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:int,b:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:int],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:int],v:sht):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:int],b2:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:int,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:int,b:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:int],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:int],v:bte):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:int],b2:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:sht,b:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:sht],v:dbl):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:sht],b2:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:sht,b:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:sht],v:flt):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:sht],b2:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:sht,b:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:sht],v:lng):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:sht],b2:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:sht,b:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:sht],v:wrd):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:sht],b2:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:sht,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:sht,b:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:sht],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:sht],v:int):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:sht],b2:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:sht,b:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:sht],v:sht):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:sht],b2:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:sht,b:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:sht],v:bte):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:sht],b2:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:bte,b:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:bte],v:dbl):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:bte],b2:bat[:dbl]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:bte,b:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:bte],v:flt):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:bte],b2:bat[:flt]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:bte,b:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:bte],v:lng):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:bte],b2:bat[:lng]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:bte,b:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:bte],v:wrd):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:bte],b2:bat[:wrd]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:bte,b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:bte,b:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:bte],v:int,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:bte],v:int):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:bte],b2:bat[:int]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:bte,b:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:bte],v:sht):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:bte],b2:bat[:sht]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:bte,b:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:bte],v:bte):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:bte],b2:bat[:bte]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:oid,b:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:oid],v:oid):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:oid],b2:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:str,b:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:str,b:bat[:str]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:str],v:str,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:str],v:str):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:str],b2:bat[:str]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:bit,b:bat[:bit]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:bit],v:bit):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:bit],b2:bat[:bit]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>>(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:lng],v:int):bat[:lng] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:wrd,b:bat[:lng]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:wrd],v:lng):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:wrd],b2:bat[:lng]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:int,b:bat[:lng]):bat[:int] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:int],v:lng):bat[:int] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:int],b2:bat[:lng]):bat[:int] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:int,b:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:int,b:bat[:wrd]):bat[:int] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:int],v:wrd,s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:int],v:wrd):bat[:int] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:int],b2:bat[:wrd]):bat[:int] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:int,b:bat[:int]):bat[:int] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:int],v:int):bat[:int] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:int,b:bat[:sht]):bat[:int] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:int],v:sht):bat[:int] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:int,b:bat[:bte]):bat[:int] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:int],v:bte):bat[:int] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:sht,b:bat[:lng]):bat[:sht] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:sht],v:lng):bat[:sht] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:sht],b2:bat[:lng]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:sht,b:bat[:wrd]):bat[:sht] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:sht],v:wrd):bat[:sht] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:sht],b2:bat[:wrd]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:sht,b:bat[:int]):bat[:sht] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:sht],v:int):bat[:sht] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:sht],b2:bat[:int]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:bte,b:bat[:lng]):bat[:bte] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:bte],v:lng):bat[:bte] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:bte],b2:bat[:lng]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:bte,b:bat[:wrd]):bat[:bte] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:bte],v:wrd):bat[:bte] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:bte],b2:bat[:wrd]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:bte,b:bat[:int]):bat[:bte] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:bte],v:int):bat[:bte] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:bte],b2:bat[:int]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:bte,b:bat[:sht]):bat[:bte] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:bte],v:sht):bat[:bte] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:bte],b2:bat[:sht]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>>(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return V >> B with candidates list, raise error on out of range second operand

pattern batcalc.>>(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatRSHsignal;
comment Return V >> B, raise error on out of range second operand

pattern batcalc.>>(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B >> V with candidates list, raise error on out of range second operand

pattern batcalc.>>(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatRSHsignal;
comment Return B >> V, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B1 >> B2 with candidates list, raise error on out of range second operand

pattern batcalc.>>(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatRSHsignal;
comment Return B1 >> B2, raise error on out of range second operand

pattern batcalc.>=(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:timestamp,b:bat[:timestamp]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:timestamp],v:timestamp):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:daytime,b:bat[:daytime]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:daytime],v:daytime):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>=(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return V >= B with candidates list

pattern batcalc.>=(v:date,b:bat[:date]):bat[:bit] 
address CMDbatGE;
comment Return V >= B

pattern batcalc.>=(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B >= V with candidates list

pattern batcalc.>=(b:bat[:date],v:date):bat[:bit] 
address CMDbatGE;
comment Return B >= V

pattern batcalc.>=(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2 with candidates list

pattern batcalc.>=(b1:bat[:date],b2:bat[:date]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>(v:timestamp,b:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:timestamp,b:bat[:timestamp]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:timestamp],v:timestamp,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:timestamp],v:timestamp):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:timestamp],b2:bat[:timestamp],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:timestamp],b2:bat[:timestamp]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:daytime,b:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:daytime,b:bat[:daytime]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:daytime],v:daytime,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:daytime],v:daytime):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:daytime],b2:bat[:daytime],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:daytime],b2:bat[:daytime]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>(v:date,b:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return V > B with candidates list

pattern batcalc.>(v:date,b:bat[:date]):bat[:bit] 
address CMDbatGT;
comment Return V > B

pattern batcalc.>(b:bat[:date],v:date,s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B > V with candidates list

pattern batcalc.>(b:bat[:date],v:date):bat[:bit] 
address CMDbatGT;
comment Return B > V

pattern batcalc.>(b1:bat[:date],b2:bat[:date],s:bat[:oid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2 with candidates list

pattern batcalc.>(b1:bat[:date],b2:bat[:date]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>=(b1:bat[:json],b2:bat[:json]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>(b1:bat[:json],b2:bat[:json]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.>=(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] 
address CMDbatGE;
comment Return B1 >= B2

pattern batcalc.>(b1:bat[:uuid],b2:bat[:uuid]):bat[:bit] 
address CMDbatGT;
comment Return B1 > B2

pattern batcalc.avg(b:bat[:dbl],s:bat[:oid]) (X_3:dbl,X_4:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:dbl]) (X_2:dbl,X_3:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B

pattern batcalc.avg(b:bat[:dbl],s:bat[:oid]):dbl 
address CMDcalcavg;
comment average of non-nil values of B

pattern batcalc.avg(b:bat[:dbl]):dbl 
address CMDcalcavg;
comment average of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:flt],s:bat[:oid]) (X_3:dbl,X_4:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:flt]) (X_2:dbl,X_3:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B

pattern batcalc.avg(b:bat[:flt],s:bat[:oid]):dbl 
address CMDcalcavg;
comment average of non-nil values of B

pattern batcalc.avg(b:bat[:flt]):dbl 
address CMDcalcavg;
comment average of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:lng],s:bat[:oid]) (X_3:dbl,X_4:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:lng]) (X_2:dbl,X_3:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B

pattern batcalc.avg(b:bat[:lng],s:bat[:oid]):dbl 
address CMDcalcavg;
comment average of non-nil values of B

pattern batcalc.avg(b:bat[:lng]):dbl 
address CMDcalcavg;
comment average of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:wrd],s:bat[:oid]) (X_3:dbl,X_4:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:wrd]) (X_2:dbl,X_3:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B

pattern batcalc.avg(b:bat[:wrd],s:bat[:oid]):dbl 
address CMDcalcavg;
comment average of non-nil values of B

pattern batcalc.avg(b:bat[:wrd]):dbl 
address CMDcalcavg;
comment average of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:int],s:bat[:oid]) (X_3:dbl,X_4:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:int]) (X_2:dbl,X_3:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B

pattern batcalc.avg(b:bat[:int],s:bat[:oid]):dbl 
address CMDcalcavg;
comment average of non-nil values of B

pattern batcalc.avg(b:bat[:int]):dbl 
address CMDcalcavg;
comment average of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:sht],s:bat[:oid]) (X_3:dbl,X_4:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:sht]) (X_2:dbl,X_3:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B

pattern batcalc.avg(b:bat[:sht],s:bat[:oid]):dbl 
address CMDcalcavg;
comment average of non-nil values of B

pattern batcalc.avg(b:bat[:sht]):dbl 
address CMDcalcavg;
comment average of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:bte],s:bat[:oid]) (X_3:dbl,X_4:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B with candidates list

pattern batcalc.avg(b:bat[:bte]) (X_2:dbl,X_3:lng) 
address CMDcalcavg;
comment average and number of non-nil values of B

pattern batcalc.avg(b:bat[:bte],s:bat[:oid]):dbl 
address CMDcalcavg;
comment average of non-nil values of B

pattern batcalc.avg(b:bat[:bte]):dbl 
address CMDcalcavg;
comment average of non-nil values of B with candidates list

pattern batcalc.and(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatAND;
comment Return V AND B with candidates list

pattern batcalc.and(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatAND;
comment Return V AND B

pattern batcalc.and(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatAND;
comment Return B AND V with candidates list

pattern batcalc.and(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatAND;
comment Return B AND V

pattern batcalc.and(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatAND;
comment Return B1 AND B2 with candidates list

pattern batcalc.and(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatAND;
comment Return B1 AND B2

pattern batcalc.and(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatAND;
comment Return V AND B with candidates list

pattern batcalc.and(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatAND;
comment Return V AND B

pattern batcalc.and(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatAND;
comment Return B AND V with candidates list

pattern batcalc.and(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatAND;
comment Return B AND V

pattern batcalc.and(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatAND;
comment Return B1 AND B2 with candidates list

pattern batcalc.and(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatAND;
comment Return B1 AND B2

pattern batcalc.and(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatAND;
comment Return V AND B with candidates list

pattern batcalc.and(v:int,b:bat[:int]):bat[:int] 
address CMDbatAND;
comment Return V AND B

pattern batcalc.and(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatAND;
comment Return B AND V with candidates list

pattern batcalc.and(b:bat[:int],v:int):bat[:int] 
address CMDbatAND;
comment Return B AND V

pattern batcalc.and(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatAND;
comment Return B1 AND B2 with candidates list

pattern batcalc.and(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatAND;
comment Return B1 AND B2

pattern batcalc.and(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatAND;
comment Return V AND B with candidates list

pattern batcalc.and(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatAND;
comment Return V AND B

pattern batcalc.and(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatAND;
comment Return B AND V with candidates list

pattern batcalc.and(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatAND;
comment Return B AND V

pattern batcalc.and(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatAND;
comment Return B1 AND B2 with candidates list

pattern batcalc.and(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatAND;
comment Return B1 AND B2

pattern batcalc.and(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatAND;
comment Return V AND B with candidates list

pattern batcalc.and(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatAND;
comment Return V AND B

pattern batcalc.and(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatAND;
comment Return B AND V with candidates list

pattern batcalc.and(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatAND;
comment Return B AND V

pattern batcalc.and(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatAND;
comment Return B1 AND B2 with candidates list

pattern batcalc.and(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatAND;
comment Return B1 AND B2

pattern batcalc.and(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatAND;
comment Return V AND B with candidates list

pattern batcalc.and(v:bit,b:bat[:bit]):bat[:bit] 
address CMDbatAND;
comment Return V AND B

pattern batcalc.and(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] 
address CMDbatAND;
comment Return B AND V with candidates list

pattern batcalc.and(b:bat[:bit],v:bit):bat[:bit] 
address CMDbatAND;
comment Return B AND V

pattern batcalc.and(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatAND;
comment Return B1 AND B2 with candidates list

pattern batcalc.and(b1:bat[:bit],b2:bat[:bit]):bat[:bit] 
address CMDbatAND;
comment Return B1 AND B2

pattern batcalc.add_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:dbl):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:flt]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:flt):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:lng]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:lng):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:wrd]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:wrd):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:wrd]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:int]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:int):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:sht]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:sht):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:dbl,b:bat[:bte]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:dbl],v:bte):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:dbl):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:flt):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:lng]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:lng):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:lng]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:wrd]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:wrd):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:wrd]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:int]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:int):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:int]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:sht]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:sht):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:sht]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:flt,b:bat[:bte]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:flt],v:bte):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:flt],b2:bat[:bte]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:dbl):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:flt):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:int):bat[:lng] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:dbl):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:flt):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:lng]):bat[:lng] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:lng):bat[:lng] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:lng]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:dbl):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:flt):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:lng]):bat[:lng] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:lng):bat[:lng] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:lng]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:wrd]):bat[:wrd] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:wrd):bat[:wrd] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:wrd]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:int]):bat[:int] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:int):bat[:int] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:sht]):bat[:int] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:sht):bat[:int] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:int,b:bat[:bte]):bat[:int] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:int],v:bte):bat[:int] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:dbl):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:flt):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:lng]):bat[:lng] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:lng):bat[:lng] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:wrd]):bat[:wrd] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:wrd):bat[:wrd] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:wrd]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:int]):bat[:int] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:int):bat[:int] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:int]):bat[:int] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:dbl):bat[:dbl] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:flt):bat[:flt] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:flt]):bat[:flt] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:lng]):bat[:lng] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:lng):bat[:lng] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:lng] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:wrd]):bat[:wrd] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:wrd):bat[:wrd] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:wrd]):bat[:wrd] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:int]):bat[:int] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:int):bat[:int] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:int]):bat[:int] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:sht]):bat[:sht] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:sht):bat[:sht] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:sht] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatADD;
comment Return V + B with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatADD;
comment Return V + B, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatADD;
comment Return B + V with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatADD;
comment Return B + V, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatADD;
comment Return B1 + B2 with candidates list, overflow causes NIL value

pattern batcalc.add_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatADD;
comment Return B1 + B2, overflow causes NIL value

pattern batcalc.abs(b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatABS;
comment Unary abs over the tail of the bat with candidates list

pattern batcalc.abs(b:bat[:dbl]):bat[:dbl] 
address CMDbatABS;
comment Unary abs over the tail of the bat

pattern batcalc.abs(b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatABS;
comment Unary abs over the tail of the bat with candidates list

pattern batcalc.abs(b:bat[:flt]):bat[:flt] 
address CMDbatABS;
comment Unary abs over the tail of the bat

pattern batcalc.abs(b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatABS;
comment Unary abs over the tail of the bat with candidates list

pattern batcalc.abs(b:bat[:lng]):bat[:lng] 
address CMDbatABS;
comment Unary abs over the tail of the bat

pattern batcalc.abs(b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatABS;
comment Unary abs over the tail of the bat with candidates list

pattern batcalc.abs(b:bat[:wrd]):bat[:wrd] 
address CMDbatABS;
comment Unary abs over the tail of the bat

pattern batcalc.abs(b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatABS;
comment Unary abs over the tail of the bat with candidates list

pattern batcalc.abs(b:bat[:int]):bat[:int] 
address CMDbatABS;
comment Unary abs over the tail of the bat

pattern batcalc.abs(b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatABS;
comment Unary abs over the tail of the bat with candidates list

pattern batcalc.abs(b:bat[:sht]):bat[:sht] 
address CMDbatABS;
comment Unary abs over the tail of the bat

pattern batcalc.abs(b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatABS;
comment Unary abs over the tail of the bat with candidates list

pattern batcalc.abs(b:bat[:bte]):bat[:bte] 
address CMDbatABS;
comment Unary abs over the tail of the bat

command batcalc.bte(s1:int,v:bat[:lng],d2:int,s2:int):bat[:bte] 
address batlng_dec2dec_bte;
comment cast decimal(lng) to decimal(bte) and check for overflow

command batcalc.bte(s1:int,v:bat[:lng]):bat[:bte] 
address batlng_dec2_bte;
comment cast decimal(lng) to bte and check for overflow

command batcalc.bte(v:bat[:lng],digits:int,scale:int):bat[:bte] 
address batlng_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command batcalc.bte(s1:int,v:bat[:wrd],d2:int,s2:int):bat[:bte] 
address batwrd_dec2dec_bte;
comment cast decimal(wrd) to decimal(bte) and check for overflow

command batcalc.bte(s1:int,v:bat[:wrd]):bat[:bte] 
address batwrd_dec2_bte;
comment cast decimal(wrd) to bte and check for overflow

command batcalc.bte(v:bat[:wrd],digits:int,scale:int):bat[:bte] 
address batwrd_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command batcalc.bte(s1:int,v:bat[:int],d2:int,s2:int):bat[:bte] 
address batint_dec2dec_bte;
comment cast decimal(int) to decimal(bte) and check for overflow

command batcalc.bte(s1:int,v:bat[:int]):bat[:bte] 
address batint_dec2_bte;
comment cast decimal(int) to bte and check for overflow

command batcalc.bte(v:bat[:int],digits:int,scale:int):bat[:bte] 
address batint_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command batcalc.bte(s1:int,v:bat[:sht],d2:int,s2:int):bat[:bte] 
address batsht_dec2dec_bte;
comment cast decimal(sht) to decimal(bte) and check for overflow

command batcalc.bte(s1:int,v:bat[:sht]):bat[:bte] 
address batsht_dec2_bte;
comment cast decimal(sht) to bte and check for overflow

command batcalc.bte(v:bat[:sht],digits:int,scale:int):bat[:bte] 
address batsht_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command batcalc.bte(s1:int,v:bat[:bte],d2:int,s2:int):bat[:bte] 
address batbte_dec2dec_bte;
comment cast decimal(bte) to decimal(bte) and check for overflow

command batcalc.bte(s1:int,v:bat[:bte]):bat[:bte] 
address batbte_dec2_bte;
comment cast decimal(bte) to bte and check for overflow

command batcalc.bte(v:bat[:bte],digits:int,scale:int):bat[:bte] 
address batbte_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command batcalc.bte(v:bat[:dbl],digits:int,scale:int):bat[:bte] 
address batdbl_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command batcalc.bte(v:bat[:flt],digits:int,scale:int):bat[:bte] 
address batflt_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command batcalc.bte(v:bat[:str],digits:int,scale:int):bat[:bte] 
address batstr_2dec_bte;
comment cast to dec(bte) and check for overflow

command batcalc.bte(v:bat[:str],digits:int):bat[:bte] 
address batstr_2num_bte;
comment cast to bte and check for overflow

command batcalc.bte(v:bat[:oid],digits:int,scale:int):bat[:bte] 
address batnil_2dec_bte;
comment cast to dec(bte) and check for overflow

command batcalc.bte(v:bat[:oid],digits:int):bat[:bte] 
address batnil_2num_bte;
comment cast to bte and check for overflow

pattern batcalc.bte_noerror(b:bat[:str],s:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from str to bte with candidates list

pattern batcalc.bte_noerror(b:bat[:str]):bat[:bte] 
address CMDconvert_bte;
comment cast from str to bte

pattern batcalc.bte(b:bat[:str],s:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from str to bte with candidates list, signal error on overflow

pattern batcalc.bte(b:bat[:str]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from str to bte, signal error on overflow

pattern batcalc.bte_noerror(b:bat[:oid],s:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from oid to bte with candidates list

pattern batcalc.bte_noerror(b:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from oid to bte

pattern batcalc.bte(b:bat[:oid],s:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from oid to bte with candidates list, signal error on overflow

pattern batcalc.bte(b:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from oid to bte, signal error on overflow

pattern batcalc.bte_noerror(b:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from dbl to bte with candidates list

pattern batcalc.bte_noerror(b:bat[:dbl]):bat[:bte] 
address CMDconvert_bte;
comment cast from dbl to bte

pattern batcalc.bte(b:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from dbl to bte with candidates list, signal error on overflow

pattern batcalc.bte(b:bat[:dbl]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from dbl to bte, signal error on overflow

pattern batcalc.bte_noerror(b:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from flt to bte with candidates list

pattern batcalc.bte_noerror(b:bat[:flt]):bat[:bte] 
address CMDconvert_bte;
comment cast from flt to bte

pattern batcalc.bte(b:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from flt to bte with candidates list, signal error on overflow

pattern batcalc.bte(b:bat[:flt]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from flt to bte, signal error on overflow

pattern batcalc.bte_noerror(b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from lng to bte with candidates list

pattern batcalc.bte_noerror(b:bat[:lng]):bat[:bte] 
address CMDconvert_bte;
comment cast from lng to bte

pattern batcalc.bte(b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from lng to bte with candidates list, signal error on overflow

pattern batcalc.bte(b:bat[:lng]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from lng to bte, signal error on overflow

pattern batcalc.bte_noerror(b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from wrd to bte with candidates list

pattern batcalc.bte_noerror(b:bat[:wrd]):bat[:bte] 
address CMDconvert_bte;
comment cast from wrd to bte

pattern batcalc.bte(b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from wrd to bte with candidates list, signal error on overflow

pattern batcalc.bte(b:bat[:wrd]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from wrd to bte, signal error on overflow

pattern batcalc.bte_noerror(b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from int to bte with candidates list

pattern batcalc.bte_noerror(b:bat[:int]):bat[:bte] 
address CMDconvert_bte;
comment cast from int to bte

pattern batcalc.bte(b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from int to bte with candidates list, signal error on overflow

pattern batcalc.bte(b:bat[:int]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from int to bte, signal error on overflow

pattern batcalc.bte_noerror(b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from sht to bte with candidates list

pattern batcalc.bte_noerror(b:bat[:sht]):bat[:bte] 
address CMDconvert_bte;
comment cast from sht to bte

pattern batcalc.bte(b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from sht to bte with candidates list, signal error on overflow

pattern batcalc.bte(b:bat[:sht]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from sht to bte, signal error on overflow

pattern batcalc.bte_noerror(b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from bte to bte with candidates list

pattern batcalc.bte_noerror(b:bat[:bte]):bat[:bte] 
address CMDconvert_bte;
comment cast from bte to bte

pattern batcalc.bte(b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from bte to bte with candidates list, signal error on overflow

pattern batcalc.bte(b:bat[:bte]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from bte to bte, signal error on overflow

pattern batcalc.bte_noerror(b:bat[:bit],s:bat[:oid]):bat[:bte] 
address CMDconvert_bte;
comment cast from bit to bte with candidates list

pattern batcalc.bte_noerror(b:bat[:bit]):bat[:bte] 
address CMDconvert_bte;
comment cast from bit to bte

pattern batcalc.bte(b:bat[:bit],s:bat[:oid]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from bit to bte with candidates list, signal error on overflow

pattern batcalc.bte(b:bat[:bit]):bat[:bte] 
address CMDconvertsignal_bte;
comment cast from bit to bte, signal error on overflow

pattern batcalc.bit_noerror(b:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from str to bit with candidates list

pattern batcalc.bit_noerror(b:bat[:str]):bat[:bit] 
address CMDconvert_bit;
comment cast from str to bit

pattern batcalc.bit(b:bat[:str],s:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from str to bit with candidates list, signal error on overflow

pattern batcalc.bit(b:bat[:str]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from str to bit, signal error on overflow

pattern batcalc.bit_noerror(b:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from oid to bit with candidates list

pattern batcalc.bit_noerror(b:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from oid to bit

pattern batcalc.bit(b:bat[:oid],s:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from oid to bit with candidates list, signal error on overflow

pattern batcalc.bit(b:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from oid to bit, signal error on overflow

pattern batcalc.bit_noerror(b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from dbl to bit with candidates list

pattern batcalc.bit_noerror(b:bat[:dbl]):bat[:bit] 
address CMDconvert_bit;
comment cast from dbl to bit

pattern batcalc.bit(b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from dbl to bit with candidates list, signal error on overflow

pattern batcalc.bit(b:bat[:dbl]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from dbl to bit, signal error on overflow

pattern batcalc.bit_noerror(b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from flt to bit with candidates list

pattern batcalc.bit_noerror(b:bat[:flt]):bat[:bit] 
address CMDconvert_bit;
comment cast from flt to bit

pattern batcalc.bit(b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from flt to bit with candidates list, signal error on overflow

pattern batcalc.bit(b:bat[:flt]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from flt to bit, signal error on overflow

pattern batcalc.bit_noerror(b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from lng to bit with candidates list

pattern batcalc.bit_noerror(b:bat[:lng]):bat[:bit] 
address CMDconvert_bit;
comment cast from lng to bit

pattern batcalc.bit(b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from lng to bit with candidates list, signal error on overflow

pattern batcalc.bit(b:bat[:lng]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from lng to bit, signal error on overflow

pattern batcalc.bit_noerror(b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from wrd to bit with candidates list

pattern batcalc.bit_noerror(b:bat[:wrd]):bat[:bit] 
address CMDconvert_bit;
comment cast from wrd to bit

pattern batcalc.bit(b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from wrd to bit with candidates list, signal error on overflow

pattern batcalc.bit(b:bat[:wrd]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from wrd to bit, signal error on overflow

pattern batcalc.bit_noerror(b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from int to bit with candidates list

pattern batcalc.bit_noerror(b:bat[:int]):bat[:bit] 
address CMDconvert_bit;
comment cast from int to bit

pattern batcalc.bit(b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from int to bit with candidates list, signal error on overflow

pattern batcalc.bit(b:bat[:int]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from int to bit, signal error on overflow

pattern batcalc.bit_noerror(b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from sht to bit with candidates list

pattern batcalc.bit_noerror(b:bat[:sht]):bat[:bit] 
address CMDconvert_bit;
comment cast from sht to bit

pattern batcalc.bit(b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from sht to bit with candidates list, signal error on overflow

pattern batcalc.bit(b:bat[:sht]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from sht to bit, signal error on overflow

pattern batcalc.bit_noerror(b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from bte to bit with candidates list

pattern batcalc.bit_noerror(b:bat[:bte]):bat[:bit] 
address CMDconvert_bit;
comment cast from bte to bit

pattern batcalc.bit(b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from bte to bit with candidates list, signal error on overflow

pattern batcalc.bit(b:bat[:bte]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from bte to bit, signal error on overflow

pattern batcalc.bit_noerror(b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDconvert_bit;
comment cast from bit to bit with candidates list

pattern batcalc.bit_noerror(b:bat[:bit]):bat[:bit] 
address CMDconvert_bit;
comment cast from bit to bit

pattern batcalc.bit(b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from bit to bit with candidates list, signal error on overflow

pattern batcalc.bit(b:bat[:bit]):bat[:bit] 
address CMDconvertsignal_bit;
comment cast from bit to bit, signal error on overflow

pattern batcalc.between_symmetric(b:bat[:any_1],v1:any_1,v2:any_1,s:bat[:oid]):bat[:bit] 
address CMDbatBETWEENsymmetric;
comment B between V1 and V2 (or vice versa) inclusive with candidates list

pattern batcalc.between_symmetric(b:bat[:any_1],v1:any_1,v2:any_1):bat[:bit] 
address CMDbatBETWEENsymmetric;
comment B between V1 and V2 (or vice versa) inclusive

pattern batcalc.between_symmetric(b:bat[:any_1],v1:any_1,v2:bat[:any_1],s:bat[:oid]):bat[:bit] 
address CMDbatBETWEENsymmetric;
comment B between V1 and V2 (or vice versa) inclusive with candidates list

pattern batcalc.between_symmetric(b:bat[:any_1],v1:any_1,v2:bat[:any_1]):bat[:bit] 
address CMDbatBETWEENsymmetric;
comment B between V1 and V2 (or vice versa) inclusive

pattern batcalc.between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:any_1,s:bat[:oid]):bat[:bit] 
address CMDbatBETWEENsymmetric;
comment B between V1 and V2 (or vice versa) inclusive with candidates list

pattern batcalc.between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:any_1):bat[:bit] 
address CMDbatBETWEENsymmetric;
comment B between V1 and V2 (or vice versa) inclusive

pattern batcalc.between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:bat[:any_1],s:bat[:oid]):bat[:bit] 
address CMDbatBETWEENsymmetric;
comment B between V1 and V2 (or vice versa) inclusive with candidates list

pattern batcalc.between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:bat[:any_1]):bat[:bit] 
address CMDbatBETWEENsymmetric;
comment B between V1 and V2 (or vice versa) inclusive

pattern batcalc.between(b:bat[:any_1],lo:any_1,hi:any_1,s:bat[:oid]):bat[:bit] 
address CMDbatBETWEEN;
comment B between LO and HI inclusive with candidates list

pattern batcalc.between(b:bat[:any_1],lo:any_1,hi:any_1):bat[:bit] 
address CMDbatBETWEEN;
comment B between LO and HI inclusive

pattern batcalc.between(b:bat[:any_1],lo:any_1,hi:bat[:any_1],s:bat[:oid]):bat[:bit] 
address CMDbatBETWEEN;
comment B between LO and HI inclusive with candidates list

pattern batcalc.between(b:bat[:any_1],lo:any_1,hi:bat[:any_1]):bat[:bit] 
address CMDbatBETWEEN;
comment B between LO and HI inclusive

pattern batcalc.between(b:bat[:any_1],lo:bat[:any_1],hi:any_1,s:bat[:oid]):bat[:bit] 
address CMDbatBETWEEN;
comment B between LO and HI inclusive with candidates list

pattern batcalc.between(b:bat[:any_1],lo:bat[:any_1],hi:any_1):bat[:bit] 
address CMDbatBETWEEN;
comment B between LO and HI inclusive

pattern batcalc.between(b:bat[:any_1],lo:bat[:any_1],hi:bat[:any_1],s:bat[:oid]):bat[:bit] 
address CMDbatBETWEEN;
comment B between LO and HI inclusive with candidates list

pattern batcalc.between(b:bat[:any_1],lo:bat[:any_1],hi:bat[:any_1]):bat[:bit] 
address CMDbatBETWEEN;
comment B between LO and HI inclusive

pattern batcalc.cmp(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:dbl,b:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:dbl],v:dbl):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:dbl,b:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:dbl],v:flt):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:dbl,b:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:dbl],v:lng):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:dbl,b:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:dbl],v:wrd):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:dbl,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:dbl],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:dbl,b:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:dbl],v:int):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:dbl,b:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:dbl],v:sht):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:dbl,b:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:dbl],v:bte):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:dbl],b2:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:flt,b:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:flt],v:dbl):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:flt,b:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:flt],v:flt,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:flt,b:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:flt],v:flt):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:flt,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:flt],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:flt,b:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:flt],v:lng):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:flt,b:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:flt],v:wrd):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:flt,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:flt],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:flt,b:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:flt],v:int):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:flt,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:flt],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:flt,b:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:flt],v:sht):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:flt,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:flt],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:flt,b:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:flt],v:bte):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:flt],b2:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:lng,b:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:lng],v:dbl):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:lng,b:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:lng],v:flt,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:lng,b:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:lng],v:flt):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:lng,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:lng],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:lng,b:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:lng],v:lng):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:lng,b:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:lng],v:wrd):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:lng,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:lng],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:lng,b:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:lng],v:int):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:lng,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:lng],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:lng,b:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:lng],v:sht):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:lng,b:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:lng],v:bte):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:lng],b2:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:wrd,b:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:wrd],v:dbl):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:wrd,b:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:wrd],v:flt):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:wrd,b:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:wrd],v:lng):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:wrd,b:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:wrd],v:wrd):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:wrd,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:wrd],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:wrd,b:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:wrd],v:int):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:wrd,b:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:wrd],v:sht):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:wrd,b:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:wrd],v:bte):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:wrd],b2:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:int,b:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:int],v:dbl,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:int,b:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:int],v:dbl):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:int],b2:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:int,b:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:int],v:flt,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:int,b:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:int],v:flt):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:int],b2:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:int,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:int],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:int,b:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:int],v:lng):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:int],b2:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:int,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:int],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:int,b:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:int],v:wrd):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:int],b2:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:int,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:int],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:int,b:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:int],v:int):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:int],b2:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:int,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:int],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:int,b:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:int],v:sht):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:int],b2:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:int,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:int],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:int,b:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:int],v:bte):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:int],b2:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:sht,b:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:sht],v:dbl):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:sht,b:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:sht],v:flt,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:sht,b:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:sht],v:flt):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:sht,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:sht],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:sht,b:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:sht],v:lng):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:sht,b:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:sht],v:wrd):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:sht,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:sht],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:sht,b:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:sht],v:int):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:sht,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:sht],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:sht,b:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:sht],v:sht):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:sht,b:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:sht],v:bte):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:sht],b2:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:bte,b:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:bte],v:dbl):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:dbl]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:bte,b:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:bte],v:flt,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:bte,b:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:bte],v:flt):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:flt]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:bte,b:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:bte],v:lng):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:lng]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:bte,b:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:bte],v:wrd):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:wrd]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:bte,b:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:bte],v:int):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:int]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:bte,b:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:bte],v:sht):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:sht]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:oid,b:bat[:oid],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:oid],v:oid,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:oid,b:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:oid],v:oid):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:oid],b2:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:str,b:bat[:str],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:str],v:str,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:str,b:bat[:str]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:str],v:str):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:str],b2:bat[:str],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:str],b2:bat[:str]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

pattern batcalc.cmp(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B with candidates list

pattern batcalc.cmp(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V with candidates list

pattern batcalc.cmp(v:bit,b:bat[:bit]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if V </==/> B

pattern batcalc.cmp(b:bat[:bit],v:bit):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B </==/> V

pattern batcalc.cmp(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2 with candidates list

pattern batcalc.cmp(b1:bat[:bit],b2:bat[:bit]):bat[:bte] 
address CMDbatCMP;
comment Return -1/0/1 if B1 </==/> B2

command batcalc.dbl(s1:int,v:bat[:lng],d2:int,s2:int):bat[:dbl] 
address batlng_dec2dec_dbl;
comment cast decimal(lng) to decimal(dbl) and check for overflow

command batcalc.dbl(s1:int,v:bat[:lng]):bat[:dbl] 
address batlng_dec2_dbl;
comment cast decimal(lng) to dbl and check for overflow

command batcalc.dbl(v:bat[:lng],digits:int,scale:int):bat[:dbl] 
address batlng_num2dec_dbl;
comment cast number to decimal(dbl) and check for overflow

command batcalc.dbl(s1:int,v:bat[:wrd],d2:int,s2:int):bat[:dbl] 
address batwrd_dec2dec_dbl;
comment cast decimal(wrd) to decimal(dbl) and check for overflow

command batcalc.dbl(s1:int,v:bat[:wrd]):bat[:dbl] 
address batwrd_dec2_dbl;
comment cast decimal(wrd) to dbl and check for overflow

command batcalc.dbl(v:bat[:wrd],digits:int,scale:int):bat[:dbl] 
address batwrd_num2dec_dbl;
comment cast number to decimal(dbl) and check for overflow

command batcalc.dbl(s1:int,v:bat[:int],d2:int,s2:int):bat[:dbl] 
address batint_dec2dec_dbl;
comment cast decimal(int) to decimal(dbl) and check for overflow

command batcalc.dbl(s1:int,v:bat[:int]):bat[:dbl] 
address batint_dec2_dbl;
comment cast decimal(int) to dbl and check for overflow

command batcalc.dbl(v:bat[:int],digits:int,scale:int):bat[:dbl] 
address batint_num2dec_dbl;
comment cast number to decimal(dbl) and check for overflow

command batcalc.dbl(s1:int,v:bat[:sht],d2:int,s2:int):bat[:dbl] 
address batsht_dec2dec_dbl;
comment cast decimal(sht) to decimal(dbl) and check for overflow

command batcalc.dbl(s1:int,v:bat[:sht]):bat[:dbl] 
address batsht_dec2_dbl;
comment cast decimal(sht) to dbl and check for overflow

command batcalc.dbl(v:bat[:sht],digits:int,scale:int):bat[:dbl] 
address batsht_num2dec_dbl;
comment cast number to decimal(dbl) and check for overflow

command batcalc.dbl(s1:int,v:bat[:bte],d2:int,s2:int):bat[:dbl] 
address batbte_dec2dec_dbl;
comment cast decimal(bte) to decimal(dbl) and check for overflow

command batcalc.dbl(s1:int,v:bat[:bte]):bat[:dbl] 
address batbte_dec2_dbl;
comment cast decimal(bte) to dbl and check for overflow

command batcalc.dbl(v:bat[:bte],digits:int,scale:int):bat[:dbl] 
address batbte_num2dec_dbl;
comment cast number to decimal(dbl) and check for overflow

command batcalc.date(v:bat[:str]):bat[:date] 
address batstr_2_date;
comment cast to date

command batcalc.date(v:bat[:oid]):bat[:date] 
address batnil_2_date;
comment cast to date

command batcalc.daytime(v:bat[:daytime],digits:int):bat[:daytime] 
address batdaytime_2time_daytime;
comment cast daytime to daytime and check for overflow

command batcalc.daytime(v:bat[:str],digits:int,has_tz:int):bat[:daytime] 
address batstr_2time_daytimetz;
comment cast to daytime and check for overflow

command batcalc.daytime(v:bat[:str],digits:int):bat[:daytime] 
address batstr_2time_daytime;
comment cast to daytime and check for overflow

command batcalc.daytime(v:bat[:str]):bat[:daytime] 
address batstr_2_daytime;
comment Cast to daytime

command batcalc.daytime(v:bat[:oid],digits:int):bat[:daytime] 
address batnil_2time_daytime;
comment cast to daytime and check for overflow

command batcalc.daytime(v:bat[:oid]):bat[:daytime] 
address batnil_2_daytime;
comment Cast to daytime

pattern batcalc.dbl_noerror(b:bat[:str],s:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from str to dbl with candidates list

pattern batcalc.dbl_noerror(b:bat[:str]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from str to dbl

pattern batcalc.dbl(b:bat[:str],s:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from str to dbl with candidates list, signal error on overflow

pattern batcalc.dbl(b:bat[:str]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from str to dbl, signal error on overflow

pattern batcalc.dbl_noerror(b:bat[:oid],s:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from oid to dbl with candidates list

pattern batcalc.dbl_noerror(b:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from oid to dbl

pattern batcalc.dbl(b:bat[:oid],s:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from oid to dbl with candidates list, signal error on overflow

pattern batcalc.dbl(b:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from oid to dbl, signal error on overflow

pattern batcalc.dbl_noerror(b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from dbl to dbl with candidates list

pattern batcalc.dbl_noerror(b:bat[:dbl]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from dbl to dbl

pattern batcalc.dbl(b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from dbl to dbl with candidates list, signal error on overflow

pattern batcalc.dbl(b:bat[:dbl]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from dbl to dbl, signal error on overflow

pattern batcalc.dbl_noerror(b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from flt to dbl with candidates list

pattern batcalc.dbl_noerror(b:bat[:flt]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from flt to dbl

pattern batcalc.dbl(b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from flt to dbl with candidates list, signal error on overflow

pattern batcalc.dbl(b:bat[:flt]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from flt to dbl, signal error on overflow

pattern batcalc.dbl_noerror(b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from lng to dbl with candidates list

pattern batcalc.dbl_noerror(b:bat[:lng]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from lng to dbl

pattern batcalc.dbl(b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from lng to dbl with candidates list, signal error on overflow

pattern batcalc.dbl(b:bat[:lng]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from lng to dbl, signal error on overflow

pattern batcalc.dbl_noerror(b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from wrd to dbl with candidates list

pattern batcalc.dbl_noerror(b:bat[:wrd]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from wrd to dbl

pattern batcalc.dbl(b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from wrd to dbl with candidates list, signal error on overflow

pattern batcalc.dbl(b:bat[:wrd]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from wrd to dbl, signal error on overflow

pattern batcalc.dbl_noerror(b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from int to dbl with candidates list

pattern batcalc.dbl_noerror(b:bat[:int]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from int to dbl

pattern batcalc.dbl(b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from int to dbl with candidates list, signal error on overflow

pattern batcalc.dbl(b:bat[:int]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from int to dbl, signal error on overflow

pattern batcalc.dbl_noerror(b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from sht to dbl with candidates list

pattern batcalc.dbl_noerror(b:bat[:sht]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from sht to dbl

pattern batcalc.dbl(b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from sht to dbl with candidates list, signal error on overflow

pattern batcalc.dbl(b:bat[:sht]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from sht to dbl, signal error on overflow

pattern batcalc.dbl_noerror(b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from bte to dbl with candidates list

pattern batcalc.dbl_noerror(b:bat[:bte]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from bte to dbl

pattern batcalc.dbl(b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from bte to dbl with candidates list, signal error on overflow

pattern batcalc.dbl(b:bat[:bte]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from bte to dbl, signal error on overflow

pattern batcalc.dbl_noerror(b:bat[:bit],s:bat[:oid]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from bit to dbl with candidates list

pattern batcalc.dbl_noerror(b:bat[:bit]):bat[:dbl] 
address CMDconvert_dbl;
comment cast from bit to dbl

pattern batcalc.dbl(b:bat[:bit],s:bat[:oid]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from bit to dbl with candidates list, signal error on overflow

pattern batcalc.dbl(b:bat[:bit]):bat[:dbl] 
address CMDconvertsignal_dbl;
comment cast from bit to dbl, signal error on overflow

pattern batcalc.div_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:dbl):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:flt]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:flt):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:lng]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:lng):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:wrd]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:wrd):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:wrd]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:int]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:int):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:sht]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:sht):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:dbl,b:bat[:bte]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:dbl],v:bte):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:dbl):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:flt):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:lng]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:lng):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:lng]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:wrd]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:wrd):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:wrd]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:int]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:int):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:int]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:sht]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:sht):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:sht]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:flt,b:bat[:bte]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:flt],v:bte):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:flt],b2:bat[:bte]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:dbl):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:flt):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:int):bat[:lng] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:dbl):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:flt):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:lng]):bat[:wrd] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:lng):bat[:wrd] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:lng]):bat[:wrd] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:dbl):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:flt):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:lng]):bat[:int] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:lng):bat[:int] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:lng]):bat[:int] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:wrd]):bat[:int] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:wrd,s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:wrd):bat[:int] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:wrd]):bat[:int] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:int]):bat[:int] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:int):bat[:int] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:sht]):bat[:int] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:sht):bat[:int] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:int,b:bat[:bte]):bat[:int] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:int],v:bte):bat[:int] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:dbl):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:flt):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:lng]):bat[:sht] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:lng):bat[:sht] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:sht] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:wrd]):bat[:sht] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:wrd):bat[:sht] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:wrd]):bat[:sht] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:int]):bat[:sht] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:int):bat[:sht] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:int]):bat[:sht] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:dbl):bat[:dbl] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:flt):bat[:flt] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:flt]):bat[:flt] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:lng]):bat[:bte] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:lng):bat[:bte] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:bte] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:wrd]):bat[:bte] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:wrd):bat[:bte] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:wrd]):bat[:bte] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:int]):bat[:bte] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:int):bat[:bte] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:int]):bat[:bte] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:sht]):bat[:bte] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:sht):bat[:bte] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:bte] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return V / B with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatDIV;
comment Return V / B, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return B / V with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatDIV;
comment Return B / V, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatDIV;
comment Return B1 / B2 with candidates list, overflow causes NIL value

pattern batcalc.div_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatDIV;
comment Return B1 / B2, overflow causes NIL value

command batcalc.daytime(t:bat[:timestamp]):bat[:daytime] 
address MTIMEtimestamp_extract_daytime_default_bulk;
command batcalc.daytime(s:bat[:lng]):bat[:daytime] 
address MTIMEsecs2daytime_bulk;
command batcalc.date(t:bat[:timestamp]):bat[:date] 
address MTIMEtimestamp_extract_date_default_bulk;
command batcalc.flt(s1:int,v:bat[:lng],d2:int,s2:int):bat[:flt] 
address batlng_dec2dec_flt;
comment cast decimal(lng) to decimal(flt) and check for overflow

command batcalc.flt(s1:int,v:bat[:lng]):bat[:flt] 
address batlng_dec2_flt;
comment cast decimal(lng) to flt and check for overflow

command batcalc.flt(v:bat[:lng],digits:int,scale:int):bat[:flt] 
address batlng_num2dec_flt;
comment cast number to decimal(flt) and check for overflow

command batcalc.flt(s1:int,v:bat[:wrd],d2:int,s2:int):bat[:flt] 
address batwrd_dec2dec_flt;
comment cast decimal(wrd) to decimal(flt) and check for overflow

command batcalc.flt(s1:int,v:bat[:wrd]):bat[:flt] 
address batwrd_dec2_flt;
comment cast decimal(wrd) to flt and check for overflow

command batcalc.flt(v:bat[:wrd],digits:int,scale:int):bat[:flt] 
address batwrd_num2dec_flt;
comment cast number to decimal(flt) and check for overflow

command batcalc.flt(s1:int,v:bat[:int],d2:int,s2:int):bat[:flt] 
address batint_dec2dec_flt;
comment cast decimal(int) to decimal(flt) and check for overflow

command batcalc.flt(s1:int,v:bat[:int]):bat[:flt] 
address batint_dec2_flt;
comment cast decimal(int) to flt and check for overflow

command batcalc.flt(v:bat[:int],digits:int,scale:int):bat[:flt] 
address batint_num2dec_flt;
comment cast number to decimal(flt) and check for overflow

command batcalc.flt(s1:int,v:bat[:sht],d2:int,s2:int):bat[:flt] 
address batsht_dec2dec_flt;
comment cast decimal(sht) to decimal(flt) and check for overflow

command batcalc.flt(s1:int,v:bat[:sht]):bat[:flt] 
address batsht_dec2_flt;
comment cast decimal(sht) to flt and check for overflow

command batcalc.flt(v:bat[:sht],digits:int,scale:int):bat[:flt] 
address batsht_num2dec_flt;
comment cast number to decimal(flt) and check for overflow

command batcalc.flt(s1:int,v:bat[:bte],d2:int,s2:int):bat[:flt] 
address batbte_dec2dec_flt;
comment cast decimal(bte) to decimal(flt) and check for overflow

command batcalc.flt(s1:int,v:bat[:bte]):bat[:flt] 
address batbte_dec2_flt;
comment cast decimal(bte) to flt and check for overflow

command batcalc.flt(v:bat[:bte],digits:int,scale:int):bat[:flt] 
address batbte_num2dec_flt;
comment cast number to decimal(flt) and check for overflow

pattern batcalc.flt_noerror(b:bat[:str],s:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from str to flt with candidates list

pattern batcalc.flt_noerror(b:bat[:str]):bat[:flt] 
address CMDconvert_flt;
comment cast from str to flt

pattern batcalc.flt(b:bat[:str],s:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from str to flt with candidates list, signal error on overflow

pattern batcalc.flt(b:bat[:str]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from str to flt, signal error on overflow

pattern batcalc.flt_noerror(b:bat[:oid],s:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from oid to flt with candidates list

pattern batcalc.flt_noerror(b:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from oid to flt

pattern batcalc.flt(b:bat[:oid],s:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from oid to flt with candidates list, signal error on overflow

pattern batcalc.flt(b:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from oid to flt, signal error on overflow

pattern batcalc.flt_noerror(b:bat[:dbl],s:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from dbl to flt with candidates list

pattern batcalc.flt_noerror(b:bat[:dbl]):bat[:flt] 
address CMDconvert_flt;
comment cast from dbl to flt

pattern batcalc.flt(b:bat[:dbl],s:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from dbl to flt with candidates list, signal error on overflow

pattern batcalc.flt(b:bat[:dbl]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from dbl to flt, signal error on overflow

pattern batcalc.flt_noerror(b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from flt to flt with candidates list

pattern batcalc.flt_noerror(b:bat[:flt]):bat[:flt] 
address CMDconvert_flt;
comment cast from flt to flt

pattern batcalc.flt(b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from flt to flt with candidates list, signal error on overflow

pattern batcalc.flt(b:bat[:flt]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from flt to flt, signal error on overflow

pattern batcalc.flt_noerror(b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from lng to flt with candidates list

pattern batcalc.flt_noerror(b:bat[:lng]):bat[:flt] 
address CMDconvert_flt;
comment cast from lng to flt

pattern batcalc.flt(b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from lng to flt with candidates list, signal error on overflow

pattern batcalc.flt(b:bat[:lng]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from lng to flt, signal error on overflow

pattern batcalc.flt_noerror(b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from wrd to flt with candidates list

pattern batcalc.flt_noerror(b:bat[:wrd]):bat[:flt] 
address CMDconvert_flt;
comment cast from wrd to flt

pattern batcalc.flt(b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from wrd to flt with candidates list, signal error on overflow

pattern batcalc.flt(b:bat[:wrd]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from wrd to flt, signal error on overflow

pattern batcalc.flt_noerror(b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from int to flt with candidates list

pattern batcalc.flt_noerror(b:bat[:int]):bat[:flt] 
address CMDconvert_flt;
comment cast from int to flt

pattern batcalc.flt(b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from int to flt with candidates list, signal error on overflow

pattern batcalc.flt(b:bat[:int]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from int to flt, signal error on overflow

pattern batcalc.flt_noerror(b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from sht to flt with candidates list

pattern batcalc.flt_noerror(b:bat[:sht]):bat[:flt] 
address CMDconvert_flt;
comment cast from sht to flt

pattern batcalc.flt(b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from sht to flt with candidates list, signal error on overflow

pattern batcalc.flt(b:bat[:sht]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from sht to flt, signal error on overflow

pattern batcalc.flt_noerror(b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from bte to flt with candidates list

pattern batcalc.flt_noerror(b:bat[:bte]):bat[:flt] 
address CMDconvert_flt;
comment cast from bte to flt

pattern batcalc.flt(b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from bte to flt with candidates list, signal error on overflow

pattern batcalc.flt(b:bat[:bte]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from bte to flt, signal error on overflow

pattern batcalc.flt_noerror(b:bat[:bit],s:bat[:oid]):bat[:flt] 
address CMDconvert_flt;
comment cast from bit to flt with candidates list

pattern batcalc.flt_noerror(b:bat[:bit]):bat[:flt] 
address CMDconvert_flt;
comment cast from bit to flt

pattern batcalc.flt(b:bat[:bit],s:bat[:oid]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from bit to flt with candidates list, signal error on overflow

pattern batcalc.flt(b:bat[:bit]):bat[:flt] 
address CMDconvertsignal_flt;
comment cast from bit to flt, signal error on overflow

command batcalc.hash(b:bat[:any_1]):bat[:wrd] 
address MKEYbathash;
command batcalc.hash(b:bat[:dbl]):bat[:wrd] 
address MKEYbathash;
command batcalc.hash(b:bat[:flt]):bat[:wrd] 
address MKEYbathash;
command batcalc.hash(b:bat[:wrd]):bat[:wrd] 
address MKEYbathash;
command batcalc.hash(b:bat[:oid]):bat[:wrd] 
address MKEYbathash;
command batcalc.hash(b:bat[:lng]):bat[:wrd] 
address MKEYbathash;
command batcalc.hash(b:bat[:int]):bat[:wrd] 
address MKEYbathash;
command batcalc.hash(b:bat[:sht]):bat[:wrd] 
address MKEYbathash;
command batcalc.hash(b:bat[:bte]):bat[:wrd] 
address MKEYbathash;
command batcalc.int(s1:int,v:bat[:lng],d2:int,s2:int):bat[:int] 
address batlng_dec2dec_int;
comment cast decimal(lng) to decimal(int) and check for overflow

command batcalc.int(s1:int,v:bat[:lng]):bat[:int] 
address batlng_dec2_int;
comment cast decimal(lng) to int and check for overflow

command batcalc.int(v:bat[:lng],digits:int,scale:int):bat[:int] 
address batlng_num2dec_int;
comment cast number to decimal(int) and check for overflow

command batcalc.int(s1:int,v:bat[:wrd],d2:int,s2:int):bat[:int] 
address batwrd_dec2dec_int;
comment cast decimal(wrd) to decimal(int) and check for overflow

command batcalc.int(s1:int,v:bat[:wrd]):bat[:int] 
address batwrd_dec2_int;
comment cast decimal(wrd) to int and check for overflow

command batcalc.int(v:bat[:wrd],digits:int,scale:int):bat[:int] 
address batwrd_num2dec_int;
comment cast number to decimal(int) and check for overflow

command batcalc.int(s1:int,v:bat[:int],d2:int,s2:int):bat[:int] 
address batint_dec2dec_int;
comment cast decimal(int) to decimal(int) and check for overflow

command batcalc.int(s1:int,v:bat[:int]):bat[:int] 
address batint_dec2_int;
comment cast decimal(int) to int and check for overflow

command batcalc.int(v:bat[:int],digits:int,scale:int):bat[:int] 
address batint_num2dec_int;
comment cast number to decimal(int) and check for overflow

command batcalc.int(s1:int,v:bat[:sht],d2:int,s2:int):bat[:int] 
address batsht_dec2dec_int;
comment cast decimal(sht) to decimal(int) and check for overflow

command batcalc.int(s1:int,v:bat[:sht]):bat[:int] 
address batsht_dec2_int;
comment cast decimal(sht) to int and check for overflow

command batcalc.int(v:bat[:sht],digits:int,scale:int):bat[:int] 
address batsht_num2dec_int;
comment cast number to decimal(int) and check for overflow

command batcalc.int(s1:int,v:bat[:bte],d2:int,s2:int):bat[:int] 
address batbte_dec2dec_int;
comment cast decimal(bte) to decimal(int) and check for overflow

command batcalc.int(s1:int,v:bat[:bte]):bat[:int] 
address batbte_dec2_int;
comment cast decimal(bte) to int and check for overflow

command batcalc.int(v:bat[:bte],digits:int,scale:int):bat[:int] 
address batbte_num2dec_int;
comment cast number to decimal(int) and check for overflow

command batcalc.int(v:bat[:dbl],digits:int,scale:int):bat[:int] 
address batdbl_num2dec_int;
comment cast number to decimal(int) and check for overflow

command batcalc.int(v:bat[:flt],digits:int,scale:int):bat[:int] 
address batflt_num2dec_int;
comment cast number to decimal(int) and check for overflow

command batcalc.index(v:bat[:str],u:bit):bat[:int] 
address BATSTRindex_int;
comment Return the offsets as an index bat

command batcalc.index(v:bat[:str],u:bit):bat[:sht] 
address BATSTRindex_sht;
comment Return the offsets as an index bat

command batcalc.index(v:bat[:str],u:bit):bat[:bte] 
address BATSTRindex_bte;
comment Return the offsets as an index bat

command batcalc.int(v:bat[:str],digits:int,scale:int):bat[:int] 
address batstr_2dec_int;
comment cast to dec(int) and check for overflow

command batcalc.int(v:bat[:str],digits:int):bat[:int] 
address batstr_2num_int;
comment cast to int and check for overflow

command batcalc.int(v:bat[:oid],digits:int,scale:int):bat[:int] 
address batnil_2dec_int;
comment cast to dec(int) and check for overflow

command batcalc.int(v:bat[:oid],digits:int):bat[:int] 
address batnil_2num_int;
comment cast to int and check for overflow

pattern batcalc.identity(b:bat[:any_2],s:oid) (resb:bat[:oid],ns:oid) 
address PBATSQLidentity;
comment Returns the unique row identitfiers.

command batcalc.identity(b:bat[:any_2]):bat[:oid] 
address BATSQLidentity;
comment Returns the unique row identitfiers.

pattern batcalc.ifthenelse(b:bat[:bit],b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] 
address CMDifthen;
comment If-then-else operation to assemble a conditional result

pattern batcalc.ifthenelse(b:bat[:bit],v1:any_1,b2:bat[:any_1]):bat[:any_1] 
address CMDifthen;
comment If-then-else operation to assemble a conditional result

pattern batcalc.ifthenelse(b:bat[:bit],b1:bat[:any_1],v2:any_1):bat[:any_1] 
address CMDifthen;
comment If-then-else operation to assemble a conditional result

pattern batcalc.ifthenelse(b:bat[:bit],v1:any_1,v2:any_1):bat[:any_1] 
address CMDifthen;
comment If-then-else operation to assemble a conditional result

pattern batcalc.int_noerror(b:bat[:str],s:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from str to int with candidates list

pattern batcalc.int_noerror(b:bat[:str]):bat[:int] 
address CMDconvert_int;
comment cast from str to int

pattern batcalc.int(b:bat[:str],s:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from str to int with candidates list, signal error on overflow

pattern batcalc.int(b:bat[:str]):bat[:int] 
address CMDconvertsignal_int;
comment cast from str to int, signal error on overflow

pattern batcalc.int_noerror(b:bat[:oid],s:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from oid to int with candidates list

pattern batcalc.int_noerror(b:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from oid to int

pattern batcalc.int(b:bat[:oid],s:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from oid to int with candidates list, signal error on overflow

pattern batcalc.int(b:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from oid to int, signal error on overflow

pattern batcalc.int_noerror(b:bat[:dbl],s:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from dbl to int with candidates list

pattern batcalc.int_noerror(b:bat[:dbl]):bat[:int] 
address CMDconvert_int;
comment cast from dbl to int

pattern batcalc.int(b:bat[:dbl],s:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from dbl to int with candidates list, signal error on overflow

pattern batcalc.int(b:bat[:dbl]):bat[:int] 
address CMDconvertsignal_int;
comment cast from dbl to int, signal error on overflow

pattern batcalc.int_noerror(b:bat[:flt],s:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from flt to int with candidates list

pattern batcalc.int_noerror(b:bat[:flt]):bat[:int] 
address CMDconvert_int;
comment cast from flt to int

pattern batcalc.int(b:bat[:flt],s:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from flt to int with candidates list, signal error on overflow

pattern batcalc.int(b:bat[:flt]):bat[:int] 
address CMDconvertsignal_int;
comment cast from flt to int, signal error on overflow

pattern batcalc.int_noerror(b:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from lng to int with candidates list

pattern batcalc.int_noerror(b:bat[:lng]):bat[:int] 
address CMDconvert_int;
comment cast from lng to int

pattern batcalc.int(b:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from lng to int with candidates list, signal error on overflow

pattern batcalc.int(b:bat[:lng]):bat[:int] 
address CMDconvertsignal_int;
comment cast from lng to int, signal error on overflow

pattern batcalc.int_noerror(b:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from wrd to int with candidates list

pattern batcalc.int_noerror(b:bat[:wrd]):bat[:int] 
address CMDconvert_int;
comment cast from wrd to int

pattern batcalc.int(b:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from wrd to int with candidates list, signal error on overflow

pattern batcalc.int(b:bat[:wrd]):bat[:int] 
address CMDconvertsignal_int;
comment cast from wrd to int, signal error on overflow

pattern batcalc.int_noerror(b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from int to int with candidates list

pattern batcalc.int_noerror(b:bat[:int]):bat[:int] 
address CMDconvert_int;
comment cast from int to int

pattern batcalc.int(b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from int to int with candidates list, signal error on overflow

pattern batcalc.int(b:bat[:int]):bat[:int] 
address CMDconvertsignal_int;
comment cast from int to int, signal error on overflow

pattern batcalc.int_noerror(b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from sht to int with candidates list

pattern batcalc.int_noerror(b:bat[:sht]):bat[:int] 
address CMDconvert_int;
comment cast from sht to int

pattern batcalc.int(b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from sht to int with candidates list, signal error on overflow

pattern batcalc.int(b:bat[:sht]):bat[:int] 
address CMDconvertsignal_int;
comment cast from sht to int, signal error on overflow

pattern batcalc.int_noerror(b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from bte to int with candidates list

pattern batcalc.int_noerror(b:bat[:bte]):bat[:int] 
address CMDconvert_int;
comment cast from bte to int

pattern batcalc.int(b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from bte to int with candidates list, signal error on overflow

pattern batcalc.int(b:bat[:bte]):bat[:int] 
address CMDconvertsignal_int;
comment cast from bte to int, signal error on overflow

pattern batcalc.int_noerror(b:bat[:bit],s:bat[:oid]):bat[:int] 
address CMDconvert_int;
comment cast from bit to int with candidates list

pattern batcalc.int_noerror(b:bat[:bit]):bat[:int] 
address CMDconvert_int;
comment cast from bit to int

pattern batcalc.int(b:bat[:bit],s:bat[:oid]):bat[:int] 
address CMDconvertsignal_int;
comment cast from bit to int with candidates list, signal error on overflow

pattern batcalc.int(b:bat[:bit]):bat[:int] 
address CMDconvertsignal_int;
comment cast from bit to int, signal error on overflow

pattern batcalc.isnotnil(b:bat[:any],s:bat[:oid]):bat[:bit] 
address CMDbatISNOTNIL;
comment Unary check for notnil over the tail of the bat with candidates list

pattern batcalc.isnotnil(b:bat[:any]):bat[:bit] 
address CMDbatISNOTNIL;
comment Unary check for notnil over the tail of the bat

pattern batcalc.isnil(b:bat[:any],s:bat[:oid]):bat[:bit] 
address CMDbatISNIL;
comment Unary check for nil over the tail of the bat with candidates list

pattern batcalc.isnil(b:bat[:any]):bat[:bit] 
address CMDbatISNIL;
comment Unary check for nil over the tail of the bat

pattern batcalc.iszero(b:bat[:dbl],s:bat[:oid]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat with candidates list

pattern batcalc.iszero(b:bat[:dbl]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat

pattern batcalc.iszero(b:bat[:flt],s:bat[:oid]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat with candidates list

pattern batcalc.iszero(b:bat[:flt]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat

pattern batcalc.iszero(b:bat[:lng],s:bat[:oid]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat with candidates list

pattern batcalc.iszero(b:bat[:lng]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat

pattern batcalc.iszero(b:bat[:wrd],s:bat[:oid]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat with candidates list

pattern batcalc.iszero(b:bat[:wrd]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat

pattern batcalc.iszero(b:bat[:int],s:bat[:oid]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat with candidates list

pattern batcalc.iszero(b:bat[:int]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat

pattern batcalc.iszero(b:bat[:sht],s:bat[:oid]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat with candidates list

pattern batcalc.iszero(b:bat[:sht]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat

pattern batcalc.iszero(b:bat[:bte],s:bat[:oid]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat with candidates list

pattern batcalc.iszero(b:bat[:bte]):bat[:bit] 
address CMDbatISZERO;
comment Unary check for zero over the tail of the bat

command batcalc.lng(s1:int,v:bat[:lng],d2:int,s2:int):bat[:lng] 
address batlng_dec2dec_lng;
comment cast decimal(lng) to decimal(lng) and check for overflow

command batcalc.lng(s1:int,v:bat[:lng]):bat[:lng] 
address batlng_dec2_lng;
comment cast decimal(lng) to lng and check for overflow

command batcalc.lng(v:bat[:lng],digits:int,scale:int):bat[:lng] 
address batlng_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command batcalc.lng(s1:int,v:bat[:wrd],d2:int,s2:int):bat[:lng] 
address batwrd_dec2dec_lng;
comment cast decimal(wrd) to decimal(lng) and check for overflow

command batcalc.lng(s1:int,v:bat[:wrd]):bat[:lng] 
address batwrd_dec2_lng;
comment cast decimal(wrd) to lng and check for overflow

command batcalc.lng(v:bat[:wrd],digits:int,scale:int):bat[:lng] 
address batwrd_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command batcalc.lng(s1:int,v:bat[:int],d2:int,s2:int):bat[:lng] 
address batint_dec2dec_lng;
comment cast decimal(int) to decimal(lng) and check for overflow

command batcalc.lng(s1:int,v:bat[:int]):bat[:lng] 
address batint_dec2_lng;
comment cast decimal(int) to lng and check for overflow

command batcalc.lng(v:bat[:int],digits:int,scale:int):bat[:lng] 
address batint_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command batcalc.lng(s1:int,v:bat[:sht],d2:int,s2:int):bat[:lng] 
address batsht_dec2dec_lng;
comment cast decimal(sht) to decimal(lng) and check for overflow

command batcalc.lng(s1:int,v:bat[:sht]):bat[:lng] 
address batsht_dec2_lng;
comment cast decimal(sht) to lng and check for overflow

command batcalc.lng(v:bat[:sht],digits:int,scale:int):bat[:lng] 
address batsht_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command batcalc.lng(s1:int,v:bat[:bte],d2:int,s2:int):bat[:lng] 
address batbte_dec2dec_lng;
comment cast decimal(bte) to decimal(lng) and check for overflow

command batcalc.lng(s1:int,v:bat[:bte]):bat[:lng] 
address batbte_dec2_lng;
comment cast decimal(bte) to lng and check for overflow

command batcalc.lng(v:bat[:bte],digits:int,scale:int):bat[:lng] 
address batbte_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command batcalc.lng(v:bat[:dbl],digits:int,scale:int):bat[:lng] 
address batdbl_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command batcalc.lng(v:bat[:flt],digits:int,scale:int):bat[:lng] 
address batflt_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command batcalc.lng(v:bat[:str],digits:int,scale:int):bat[:lng] 
address batstr_2dec_lng;
comment cast to dec(lng) and check for overflow

command batcalc.lng(v:bat[:str],digits:int):bat[:lng] 
address batstr_2num_lng;
comment cast to lng and check for overflow

command batcalc.lng(v:bat[:oid],digits:int,scale:int):bat[:lng] 
address batnil_2dec_lng;
comment cast to dec(lng) and check for overflow

command batcalc.lng(v:bat[:oid],digits:int):bat[:lng] 
address batnil_2num_lng;
comment cast to lng and check for overflow

pattern batcalc.lng_noerror(b:bat[:str],s:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from str to lng with candidates list

pattern batcalc.lng_noerror(b:bat[:str]):bat[:lng] 
address CMDconvert_lng;
comment cast from str to lng

pattern batcalc.lng(b:bat[:str],s:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from str to lng with candidates list, signal error on overflow

pattern batcalc.lng(b:bat[:str]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from str to lng, signal error on overflow

pattern batcalc.lng_noerror(b:bat[:oid],s:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from oid to lng with candidates list

pattern batcalc.lng_noerror(b:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from oid to lng

pattern batcalc.lng(b:bat[:oid],s:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from oid to lng with candidates list, signal error on overflow

pattern batcalc.lng(b:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from oid to lng, signal error on overflow

pattern batcalc.lng_noerror(b:bat[:dbl],s:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from dbl to lng with candidates list

pattern batcalc.lng_noerror(b:bat[:dbl]):bat[:lng] 
address CMDconvert_lng;
comment cast from dbl to lng

pattern batcalc.lng(b:bat[:dbl],s:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from dbl to lng with candidates list, signal error on overflow

pattern batcalc.lng(b:bat[:dbl]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from dbl to lng, signal error on overflow

pattern batcalc.lng_noerror(b:bat[:flt],s:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from flt to lng with candidates list

pattern batcalc.lng_noerror(b:bat[:flt]):bat[:lng] 
address CMDconvert_lng;
comment cast from flt to lng

pattern batcalc.lng(b:bat[:flt],s:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from flt to lng with candidates list, signal error on overflow

pattern batcalc.lng(b:bat[:flt]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from flt to lng, signal error on overflow

pattern batcalc.lng_noerror(b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from lng to lng with candidates list

pattern batcalc.lng_noerror(b:bat[:lng]):bat[:lng] 
address CMDconvert_lng;
comment cast from lng to lng

pattern batcalc.lng(b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from lng to lng with candidates list, signal error on overflow

pattern batcalc.lng(b:bat[:lng]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from lng to lng, signal error on overflow

pattern batcalc.lng_noerror(b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from wrd to lng with candidates list

pattern batcalc.lng_noerror(b:bat[:wrd]):bat[:lng] 
address CMDconvert_lng;
comment cast from wrd to lng

pattern batcalc.lng(b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from wrd to lng with candidates list, signal error on overflow

pattern batcalc.lng(b:bat[:wrd]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from wrd to lng, signal error on overflow

pattern batcalc.lng_noerror(b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from int to lng with candidates list

pattern batcalc.lng_noerror(b:bat[:int]):bat[:lng] 
address CMDconvert_lng;
comment cast from int to lng

pattern batcalc.lng(b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from int to lng with candidates list, signal error on overflow

pattern batcalc.lng(b:bat[:int]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from int to lng, signal error on overflow

pattern batcalc.lng_noerror(b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from sht to lng with candidates list

pattern batcalc.lng_noerror(b:bat[:sht]):bat[:lng] 
address CMDconvert_lng;
comment cast from sht to lng

pattern batcalc.lng(b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from sht to lng with candidates list, signal error on overflow

pattern batcalc.lng(b:bat[:sht]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from sht to lng, signal error on overflow

pattern batcalc.lng_noerror(b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from bte to lng with candidates list

pattern batcalc.lng_noerror(b:bat[:bte]):bat[:lng] 
address CMDconvert_lng;
comment cast from bte to lng

pattern batcalc.lng(b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from bte to lng with candidates list, signal error on overflow

pattern batcalc.lng(b:bat[:bte]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from bte to lng, signal error on overflow

pattern batcalc.lng_noerror(b:bat[:bit],s:bat[:oid]):bat[:lng] 
address CMDconvert_lng;
comment cast from bit to lng with candidates list

pattern batcalc.lng_noerror(b:bat[:bit]):bat[:lng] 
address CMDconvert_lng;
comment cast from bit to lng

pattern batcalc.lng(b:bat[:bit],s:bat[:oid]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from bit to lng with candidates list, signal error on overflow

pattern batcalc.lng(b:bat[:bit]):bat[:lng] 
address CMDconvertsignal_lng;
comment cast from bit to lng, signal error on overflow

pattern batcalc.lsh_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:lng],v:int):bat[:lng] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:wrd,b:bat[:lng]):bat[:wrd] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:wrd],v:lng):bat[:wrd] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:wrd],b2:bat[:lng]):bat[:wrd] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:int,b:bat[:lng]):bat[:int] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:int],v:lng):bat[:int] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:lng]):bat[:int] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:int,b:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:int,b:bat[:wrd]):bat[:int] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:int],v:wrd,s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:int],v:wrd):bat[:int] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:wrd]):bat[:int] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:int,b:bat[:int]):bat[:int] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:int],v:int):bat[:int] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:int,b:bat[:sht]):bat[:int] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:int],v:sht):bat[:int] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:int,b:bat[:bte]):bat[:int] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:int],v:bte):bat[:int] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:sht,b:bat[:lng]):bat[:sht] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:sht],v:lng):bat[:sht] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:sht] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:sht,b:bat[:wrd]):bat[:sht] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:sht],v:wrd):bat[:sht] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:wrd]):bat[:sht] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:sht,b:bat[:int]):bat[:sht] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:sht],v:int):bat[:sht] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:int]):bat[:sht] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:bte,b:bat[:lng]):bat[:bte] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:bte],v:lng):bat[:bte] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:bte] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:bte,b:bat[:wrd]):bat[:bte] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:bte],v:wrd):bat[:bte] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:wrd]):bat[:bte] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:bte,b:bat[:int]):bat[:bte] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:bte],v:int):bat[:bte] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:int]):bat[:bte] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:bte,b:bat[:sht]):bat[:bte] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:bte],v:sht):bat[:bte] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:bte] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return V << B with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatLSH;
comment Return V << B, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return B << V with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatLSH;
comment Return B << V, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatLSH;
comment Return B1 << B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.lsh_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatLSH;
comment Return B1 << B2, out of range second operand causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:dbl):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:flt]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:flt):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:lng]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:lng):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:wrd]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:wrd):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:wrd]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:int]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:int):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:sht]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:sht):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:dbl,b:bat[:bte]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:dbl],v:bte):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:dbl):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:flt):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:lng]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:lng):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:lng]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:wrd]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:wrd):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:wrd]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:int]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:int):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:int]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:sht]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:sht):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:sht]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:flt,b:bat[:bte]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:flt],v:bte):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:flt],b2:bat[:bte]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:dbl):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:flt):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:wrd]):bat[:wrd] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:wrd):bat[:wrd] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:int]):bat[:int] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:int):bat[:int] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:int]):bat[:int] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:sht]):bat[:sht] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:sht):bat[:sht] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:lng,b:bat[:bte]):bat[:bte] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:lng],v:bte):bat[:bte] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:dbl):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:flt):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:lng]):bat[:wrd] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:wrd] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:lng):bat[:wrd] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:lng]):bat[:wrd] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:int]):bat[:int] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:int):bat[:int] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:int]):bat[:int] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:sht]):bat[:sht] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:sht):bat[:sht] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:sht]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:wrd,b:bat[:bte]):bat[:bte] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:wrd],v:bte):bat[:bte] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:wrd],b2:bat[:bte]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:dbl):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:flt):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:lng]):bat[:int] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:lng):bat[:int] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:lng]):bat[:int] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:wrd]):bat[:int] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:wrd,s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:wrd):bat[:int] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:wrd]):bat[:int] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:int]):bat[:int] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:int):bat[:int] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:sht]):bat[:sht] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:sht):bat[:sht] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:sht]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:int,b:bat[:bte]):bat[:bte] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:int],v:bte):bat[:bte] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:int],b2:bat[:bte]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:dbl):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:flt):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:lng]):bat[:sht] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:lng):bat[:sht] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:wrd]):bat[:sht] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:wrd):bat[:sht] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:wrd]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:int]):bat[:sht] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:int):bat[:sht] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:int]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:sht,b:bat[:bte]):bat[:bte] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:sht],v:bte):bat[:bte] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:dbl):bat[:dbl] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:flt):bat[:flt] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:flt]):bat[:flt] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:lng]):bat[:bte] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:lng):bat[:bte] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:wrd]):bat[:bte] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:wrd):bat[:bte] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:wrd]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:int]):bat[:bte] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:int):bat[:bte] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:int]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:sht]):bat[:bte] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:sht):bat[:bte] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return V % B with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatMOD;
comment Return V % B, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B % V with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatMOD;
comment Return B % V, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2 with candidates list, divide by zero causes NIL value

pattern batcalc.mod_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatMOD;
comment Return B1 % B2, divide by zero causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:dbl):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:flt]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:flt):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:lng]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:lng):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:wrd]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:wrd):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:wrd]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:int]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:int):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:sht]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:sht):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:dbl,b:bat[:bte]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:dbl],v:bte):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:dbl):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:flt):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:lng]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:lng):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:lng]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:wrd]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:wrd):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:wrd]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:int]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:int):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:int]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:sht]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:sht):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:sht]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:flt,b:bat[:bte]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:flt],v:bte):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:flt],b2:bat[:bte]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:dbl):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:flt):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:int):bat[:lng] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:dbl):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:flt):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:lng]):bat[:lng] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:lng):bat[:lng] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:lng]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:dbl):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:flt):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:lng]):bat[:lng] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:lng):bat[:lng] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:lng]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:wrd]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:wrd):bat[:wrd] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:int]):bat[:int] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:int):bat[:int] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:sht]):bat[:int] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:sht):bat[:int] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:int,b:bat[:bte]):bat[:int] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:int],v:bte):bat[:int] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:dbl):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:flt):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:lng]):bat[:lng] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:lng):bat[:lng] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:wrd]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:wrd):bat[:wrd] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:int]):bat[:int] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:int):bat[:int] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:int]):bat[:int] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:dbl):bat[:dbl] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:flt):bat[:flt] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:flt]):bat[:flt] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:lng]):bat[:lng] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:lng):bat[:lng] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:lng] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:wrd]):bat[:wrd] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:wrd):bat[:wrd] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:wrd]):bat[:wrd] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:int]):bat[:int] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:int):bat[:int] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:int]):bat[:int] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:sht]):bat[:sht] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:sht):bat[:sht] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:sht] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMUL;
comment Return V * B with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatMUL;
comment Return V * B, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatMUL;
comment Return B * V with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatMUL;
comment Return B * V, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatMUL;
comment Return B1 * B2 with candidates list, overflow causes NIL value

pattern batcalc.mul_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatMUL;
comment Return B1 * B2, overflow causes NIL value

pattern batcalc.max_no_nil(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]):bat[:any_1] 
address CMDbatMAX_no_nil;
comment Return bat with maximum value of each pair of inputs, ignoring nil values

pattern batcalc.max_no_nil(b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] 
address CMDbatMAX_no_nil;
comment Return bat with maximum value of each pair of inputs, ignoring nil values

pattern batcalc.max(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]):bat[:any_1] 
address CMDbatMAX;
comment Return bat with maximum value of each pair of inputs

pattern batcalc.max(b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] 
address CMDbatMAX;
comment Return bat with maximum value of each pair of inputs

pattern batcalc.min_no_nil(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]):bat[:any_1] 
address CMDbatMIN_no_nil;
comment Return bat with minimum value of each pair of inputs, ignoring nil values

pattern batcalc.min_no_nil(b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] 
address CMDbatMIN_no_nil;
comment Return bat with minimum value of each pair of inputs, ignoring nil values

pattern batcalc.min(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]):bat[:any_1] 
address CMDbatMIN;
comment Return bat with minimum value of each pair of inputs

pattern batcalc.min(b1:bat[:any_1],b2:bat[:any_1]):bat[:any_1] 
address CMDbatMIN;
comment Return bat with minimum value of each pair of inputs

pattern batcalc.not(b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatNOT;
comment Unary bitwise not over the tail of the bat with candidates list

pattern batcalc.not(b:bat[:lng]):bat[:lng] 
address CMDbatNOT;
comment Unary bitwise not over the tail of the bat

pattern batcalc.not(b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatNOT;
comment Unary bitwise not over the tail of the bat with candidates list

pattern batcalc.not(b:bat[:wrd]):bat[:wrd] 
address CMDbatNOT;
comment Unary bitwise not over the tail of the bat

pattern batcalc.not(b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatNOT;
comment Unary bitwise not over the tail of the bat with candidates list

pattern batcalc.not(b:bat[:int]):bat[:int] 
address CMDbatNOT;
comment Unary bitwise not over the tail of the bat

pattern batcalc.not(b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatNOT;
comment Unary bitwise not over the tail of the bat with candidates list

pattern batcalc.not(b:bat[:sht]):bat[:sht] 
address CMDbatNOT;
comment Unary bitwise not over the tail of the bat

pattern batcalc.not(b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatNOT;
comment Unary bitwise not over the tail of the bat with candidates list

pattern batcalc.not(b:bat[:bte]):bat[:bte] 
address CMDbatNOT;
comment Unary bitwise not over the tail of the bat

pattern batcalc.not(b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatNOT;
comment Return the Boolean inverse with candidates list

pattern batcalc.not(b:bat[:bit]):bat[:bit] 
address CMDbatNOT;
comment Return the Boolean inverse

pattern batcalc.oid_noerror(b:bat[:str],s:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from str to oid with candidates list

pattern batcalc.oid_noerror(b:bat[:str]):bat[:oid] 
address CMDconvert_oid;
comment cast from str to oid

pattern batcalc.oid(b:bat[:str],s:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from str to oid with candidates list, signal error on overflow

pattern batcalc.oid(b:bat[:str]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from str to oid, signal error on overflow

pattern batcalc.oid_noerror(b:bat[:oid],s:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from oid to oid with candidates list

pattern batcalc.oid_noerror(b:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from oid to oid

pattern batcalc.oid(b:bat[:oid],s:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from oid to oid with candidates list, signal error on overflow

pattern batcalc.oid(b:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from oid to oid, signal error on overflow

pattern batcalc.oid_noerror(b:bat[:dbl],s:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from dbl to oid with candidates list

pattern batcalc.oid_noerror(b:bat[:dbl]):bat[:oid] 
address CMDconvert_oid;
comment cast from dbl to oid

pattern batcalc.oid(b:bat[:dbl],s:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from dbl to oid with candidates list, signal error on overflow

pattern batcalc.oid(b:bat[:dbl]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from dbl to oid, signal error on overflow

pattern batcalc.oid_noerror(b:bat[:flt],s:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from flt to oid with candidates list

pattern batcalc.oid_noerror(b:bat[:flt]):bat[:oid] 
address CMDconvert_oid;
comment cast from flt to oid

pattern batcalc.oid(b:bat[:flt],s:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from flt to oid with candidates list, signal error on overflow

pattern batcalc.oid(b:bat[:flt]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from flt to oid, signal error on overflow

pattern batcalc.oid_noerror(b:bat[:lng],s:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from lng to oid with candidates list

pattern batcalc.oid_noerror(b:bat[:lng]):bat[:oid] 
address CMDconvert_oid;
comment cast from lng to oid

pattern batcalc.oid(b:bat[:lng],s:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from lng to oid with candidates list, signal error on overflow

pattern batcalc.oid(b:bat[:lng]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from lng to oid, signal error on overflow

pattern batcalc.oid_noerror(b:bat[:wrd],s:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from wrd to oid with candidates list

pattern batcalc.oid_noerror(b:bat[:wrd]):bat[:oid] 
address CMDconvert_oid;
comment cast from wrd to oid

pattern batcalc.oid(b:bat[:wrd],s:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from wrd to oid with candidates list, signal error on overflow

pattern batcalc.oid(b:bat[:wrd]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from wrd to oid, signal error on overflow

pattern batcalc.oid_noerror(b:bat[:int],s:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from int to oid with candidates list

pattern batcalc.oid_noerror(b:bat[:int]):bat[:oid] 
address CMDconvert_oid;
comment cast from int to oid

pattern batcalc.oid(b:bat[:int],s:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from int to oid with candidates list, signal error on overflow

pattern batcalc.oid(b:bat[:int]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from int to oid, signal error on overflow

pattern batcalc.oid_noerror(b:bat[:sht],s:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from sht to oid with candidates list

pattern batcalc.oid_noerror(b:bat[:sht]):bat[:oid] 
address CMDconvert_oid;
comment cast from sht to oid

pattern batcalc.oid(b:bat[:sht],s:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from sht to oid with candidates list, signal error on overflow

pattern batcalc.oid(b:bat[:sht]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from sht to oid, signal error on overflow

pattern batcalc.oid_noerror(b:bat[:bte],s:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from bte to oid with candidates list

pattern batcalc.oid_noerror(b:bat[:bte]):bat[:oid] 
address CMDconvert_oid;
comment cast from bte to oid

pattern batcalc.oid(b:bat[:bte],s:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from bte to oid with candidates list, signal error on overflow

pattern batcalc.oid(b:bat[:bte]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from bte to oid, signal error on overflow

pattern batcalc.oid_noerror(b:bat[:bit],s:bat[:oid]):bat[:oid] 
address CMDconvert_oid;
comment cast from bit to oid with candidates list

pattern batcalc.oid_noerror(b:bat[:bit]):bat[:oid] 
address CMDconvert_oid;
comment cast from bit to oid

pattern batcalc.oid(b:bat[:bit],s:bat[:oid]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from bit to oid with candidates list, signal error on overflow

pattern batcalc.oid(b:bat[:bit]):bat[:oid] 
address CMDconvertsignal_oid;
comment cast from bit to oid, signal error on overflow

pattern batcalc.or(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatOR;
comment Return V OR B with candidates list

pattern batcalc.or(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatOR;
comment Return V OR B

pattern batcalc.or(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatOR;
comment Return B OR V with candidates list

pattern batcalc.or(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatOR;
comment Return B OR V

pattern batcalc.or(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatOR;
comment Return B1 OR B2 with candidates list

pattern batcalc.or(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatOR;
comment Return B1 OR B2

pattern batcalc.or(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatOR;
comment Return V OR B with candidates list

pattern batcalc.or(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatOR;
comment Return V OR B

pattern batcalc.or(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatOR;
comment Return B OR V with candidates list

pattern batcalc.or(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatOR;
comment Return B OR V

pattern batcalc.or(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatOR;
comment Return B1 OR B2 with candidates list

pattern batcalc.or(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatOR;
comment Return B1 OR B2

pattern batcalc.or(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatOR;
comment Return V OR B with candidates list

pattern batcalc.or(v:int,b:bat[:int]):bat[:int] 
address CMDbatOR;
comment Return V OR B

pattern batcalc.or(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatOR;
comment Return B OR V with candidates list

pattern batcalc.or(b:bat[:int],v:int):bat[:int] 
address CMDbatOR;
comment Return B OR V

pattern batcalc.or(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatOR;
comment Return B1 OR B2 with candidates list

pattern batcalc.or(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatOR;
comment Return B1 OR B2

pattern batcalc.or(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatOR;
comment Return V OR B with candidates list

pattern batcalc.or(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatOR;
comment Return V OR B

pattern batcalc.or(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatOR;
comment Return B OR V with candidates list

pattern batcalc.or(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatOR;
comment Return B OR V

pattern batcalc.or(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatOR;
comment Return B1 OR B2 with candidates list

pattern batcalc.or(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatOR;
comment Return B1 OR B2

pattern batcalc.or(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatOR;
comment Return V OR B with candidates list

pattern batcalc.or(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatOR;
comment Return V OR B

pattern batcalc.or(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatOR;
comment Return B OR V with candidates list

pattern batcalc.or(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatOR;
comment Return B OR V

pattern batcalc.or(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatOR;
comment Return B1 OR B2 with candidates list

pattern batcalc.or(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatOR;
comment Return B1 OR B2

pattern batcalc.or(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatOR;
comment Return V OR B with candidates list

pattern batcalc.or(v:bit,b:bat[:bit]):bat[:bit] 
address CMDbatOR;
comment Return V OR B

pattern batcalc.or(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] 
address CMDbatOR;
comment Return B OR V with candidates list

pattern batcalc.or(b:bat[:bit],v:bit):bat[:bit] 
address CMDbatOR;
comment Return B OR V

pattern batcalc.or(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatOR;
comment Return B1 OR B2 with candidates list

pattern batcalc.or(b1:bat[:bit],b2:bat[:bit]):bat[:bit] 
address CMDbatOR;
comment Return B1 OR B2

command batcalc.rotate_xor_hash(h:bat[:wrd],nbits:int,b:bat[:any_1]):bat[:int] 
address MKEYbulk_rotate_xor_hash;
pattern batcalc.rsh_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:lng],v:int):bat[:lng] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:wrd,b:bat[:lng]):bat[:wrd] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:wrd],v:lng):bat[:wrd] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:wrd],b2:bat[:lng]):bat[:wrd] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:int,b:bat[:lng]):bat[:int] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:int],v:lng):bat[:int] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:lng]):bat[:int] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:int,b:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:int,b:bat[:wrd]):bat[:int] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:int],v:wrd,s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:int],v:wrd):bat[:int] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:wrd]):bat[:int] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:int,b:bat[:int]):bat[:int] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:int],v:int):bat[:int] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:int,b:bat[:sht]):bat[:int] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:int],v:sht):bat[:int] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:int,b:bat[:bte]):bat[:int] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:int],v:bte):bat[:int] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:sht,b:bat[:lng]):bat[:sht] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:sht],v:lng):bat[:sht] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:sht] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:sht,b:bat[:wrd]):bat[:sht] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:sht],v:wrd):bat[:sht] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:wrd]):bat[:sht] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:sht,b:bat[:int]):bat[:sht] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:sht],v:int):bat[:sht] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:int]):bat[:sht] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:bte,b:bat[:lng]):bat[:bte] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:bte],v:lng):bat[:bte] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:bte] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:bte,b:bat[:wrd]):bat[:bte] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:bte],v:wrd):bat[:bte] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:wrd]):bat[:bte] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:bte,b:bat[:int]):bat[:bte] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:bte],v:int):bat[:bte] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:int]):bat[:bte] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:bte,b:bat[:sht]):bat[:bte] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:bte],v:sht):bat[:bte] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:bte] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return V >> B with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatRSH;
comment Return V >> B, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return B >> V with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatRSH;
comment Return B >> V, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatRSH;
comment Return B1 >> B2 with candidates list, out of range second operand causes NIL value

pattern batcalc.rsh_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatRSH;
comment Return B1 >> B2, out of range second operand causes NIL value

command batcalc.sht(s1:int,v:bat[:lng],d2:int,s2:int):bat[:sht] 
address batlng_dec2dec_sht;
comment cast decimal(lng) to decimal(sht) and check for overflow

command batcalc.sht(s1:int,v:bat[:lng]):bat[:sht] 
address batlng_dec2_sht;
comment cast decimal(lng) to sht and check for overflow

command batcalc.sht(v:bat[:lng],digits:int,scale:int):bat[:sht] 
address batlng_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command batcalc.sht(s1:int,v:bat[:wrd],d2:int,s2:int):bat[:sht] 
address batwrd_dec2dec_sht;
comment cast decimal(wrd) to decimal(sht) and check for overflow

command batcalc.sht(s1:int,v:bat[:wrd]):bat[:sht] 
address batwrd_dec2_sht;
comment cast decimal(wrd) to sht and check for overflow

command batcalc.sht(v:bat[:wrd],digits:int,scale:int):bat[:sht] 
address batwrd_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command batcalc.sht(s1:int,v:bat[:int],d2:int,s2:int):bat[:sht] 
address batint_dec2dec_sht;
comment cast decimal(int) to decimal(sht) and check for overflow

command batcalc.sht(s1:int,v:bat[:int]):bat[:sht] 
address batint_dec2_sht;
comment cast decimal(int) to sht and check for overflow

command batcalc.sht(v:bat[:int],digits:int,scale:int):bat[:sht] 
address batint_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command batcalc.sht(s1:int,v:bat[:sht],d2:int,s2:int):bat[:sht] 
address batsht_dec2dec_sht;
comment cast decimal(sht) to decimal(sht) and check for overflow

command batcalc.sht(s1:int,v:bat[:sht]):bat[:sht] 
address batsht_dec2_sht;
comment cast decimal(sht) to sht and check for overflow

command batcalc.sht(v:bat[:sht],digits:int,scale:int):bat[:sht] 
address batsht_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command batcalc.sht(s1:int,v:bat[:bte],d2:int,s2:int):bat[:sht] 
address batbte_dec2dec_sht;
comment cast decimal(bte) to decimal(sht) and check for overflow

command batcalc.sht(s1:int,v:bat[:bte]):bat[:sht] 
address batbte_dec2_sht;
comment cast decimal(bte) to sht and check for overflow

command batcalc.sht(v:bat[:bte],digits:int,scale:int):bat[:sht] 
address batbte_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command batcalc.sht(v:bat[:dbl],digits:int,scale:int):bat[:sht] 
address batdbl_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command batcalc.sht(v:bat[:flt],digits:int,scale:int):bat[:sht] 
address batflt_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command batcalc.strings(v:bat[:str]):bat[:str] 
address BATSTRstrings;
comment Return the strings

pattern batcalc.str(eclass:int,d1:int,s1:int,has_tz:int,v:bat[:any_1],digits:int):bat[:str] 
address SQLbatstr_cast;
comment cast to string and check for overflow

command batcalc.sqlblob(v:bat[:str]):bat[:sqlblob] 
address batstr_2_sqlblob;
comment cast to sqlblob

command batcalc.sht(v:bat[:str],digits:int,scale:int):bat[:sht] 
address batstr_2dec_sht;
comment cast to dec(sht) and check for overflow

command batcalc.sht(v:bat[:str],digits:int):bat[:sht] 
address batstr_2num_sht;
comment cast to sht and check for overflow

command batcalc.sht(v:bat[:oid],digits:int,scale:int):bat[:sht] 
address batnil_2dec_sht;
comment cast to dec(sht) and check for overflow

command batcalc.sht(v:bat[:oid],digits:int):bat[:sht] 
address batnil_2num_sht;
comment cast to sht and check for overflow

pattern batcalc.str_noerror(b:bat[:str],s:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from str to str with candidates list

pattern batcalc.str_noerror(b:bat[:str]):bat[:str] 
address CMDconvert_str;
comment cast from str to str

pattern batcalc.str(b:bat[:str],s:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from str to str with candidates list, signal error on overflow

pattern batcalc.str(b:bat[:str]):bat[:str] 
address CMDconvertsignal_str;
comment cast from str to str, signal error on overflow

pattern batcalc.str_noerror(b:bat[:oid],s:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from oid to str with candidates list

pattern batcalc.str_noerror(b:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from oid to str

pattern batcalc.str(b:bat[:oid],s:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from oid to str with candidates list, signal error on overflow

pattern batcalc.str(b:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from oid to str, signal error on overflow

pattern batcalc.str_noerror(b:bat[:dbl],s:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from dbl to str with candidates list

pattern batcalc.str_noerror(b:bat[:dbl]):bat[:str] 
address CMDconvert_str;
comment cast from dbl to str

pattern batcalc.str(b:bat[:dbl],s:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from dbl to str with candidates list, signal error on overflow

pattern batcalc.str(b:bat[:dbl]):bat[:str] 
address CMDconvertsignal_str;
comment cast from dbl to str, signal error on overflow

pattern batcalc.str_noerror(b:bat[:flt],s:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from flt to str with candidates list

pattern batcalc.str_noerror(b:bat[:flt]):bat[:str] 
address CMDconvert_str;
comment cast from flt to str

pattern batcalc.str(b:bat[:flt],s:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from flt to str with candidates list, signal error on overflow

pattern batcalc.str(b:bat[:flt]):bat[:str] 
address CMDconvertsignal_str;
comment cast from flt to str, signal error on overflow

pattern batcalc.str_noerror(b:bat[:lng],s:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from lng to str with candidates list

pattern batcalc.str_noerror(b:bat[:lng]):bat[:str] 
address CMDconvert_str;
comment cast from lng to str

pattern batcalc.str(b:bat[:lng],s:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from lng to str with candidates list, signal error on overflow

pattern batcalc.str(b:bat[:lng]):bat[:str] 
address CMDconvertsignal_str;
comment cast from lng to str, signal error on overflow

pattern batcalc.str_noerror(b:bat[:wrd],s:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from wrd to str with candidates list

pattern batcalc.str_noerror(b:bat[:wrd]):bat[:str] 
address CMDconvert_str;
comment cast from wrd to str

pattern batcalc.str(b:bat[:wrd],s:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from wrd to str with candidates list, signal error on overflow

pattern batcalc.str(b:bat[:wrd]):bat[:str] 
address CMDconvertsignal_str;
comment cast from wrd to str, signal error on overflow

pattern batcalc.str_noerror(b:bat[:int],s:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from int to str with candidates list

pattern batcalc.str_noerror(b:bat[:int]):bat[:str] 
address CMDconvert_str;
comment cast from int to str

pattern batcalc.str(b:bat[:int],s:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from int to str with candidates list, signal error on overflow

pattern batcalc.str(b:bat[:int]):bat[:str] 
address CMDconvertsignal_str;
comment cast from int to str, signal error on overflow

pattern batcalc.str_noerror(b:bat[:sht],s:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from sht to str with candidates list

pattern batcalc.str_noerror(b:bat[:sht]):bat[:str] 
address CMDconvert_str;
comment cast from sht to str

pattern batcalc.str(b:bat[:sht],s:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from sht to str with candidates list, signal error on overflow

pattern batcalc.str(b:bat[:sht]):bat[:str] 
address CMDconvertsignal_str;
comment cast from sht to str, signal error on overflow

pattern batcalc.str_noerror(b:bat[:bte],s:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from bte to str with candidates list

pattern batcalc.str_noerror(b:bat[:bte]):bat[:str] 
address CMDconvert_str;
comment cast from bte to str

pattern batcalc.str(b:bat[:bte],s:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from bte to str with candidates list, signal error on overflow

pattern batcalc.str(b:bat[:bte]):bat[:str] 
address CMDconvertsignal_str;
comment cast from bte to str, signal error on overflow

pattern batcalc.str_noerror(b:bat[:bit],s:bat[:oid]):bat[:str] 
address CMDconvert_str;
comment cast from bit to str with candidates list

pattern batcalc.str_noerror(b:bat[:bit]):bat[:str] 
address CMDconvert_str;
comment cast from bit to str

pattern batcalc.str(b:bat[:bit],s:bat[:oid]):bat[:str] 
address CMDconvertsignal_str;
comment cast from bit to str with candidates list, signal error on overflow

pattern batcalc.str(b:bat[:bit]):bat[:str] 
address CMDconvertsignal_str;
comment cast from bit to str, signal error on overflow

pattern batcalc.sht_noerror(b:bat[:str],s:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from str to sht with candidates list

pattern batcalc.sht_noerror(b:bat[:str]):bat[:sht] 
address CMDconvert_sht;
comment cast from str to sht

pattern batcalc.sht(b:bat[:str],s:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from str to sht with candidates list, signal error on overflow

pattern batcalc.sht(b:bat[:str]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from str to sht, signal error on overflow

pattern batcalc.sht_noerror(b:bat[:oid],s:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from oid to sht with candidates list

pattern batcalc.sht_noerror(b:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from oid to sht

pattern batcalc.sht(b:bat[:oid],s:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from oid to sht with candidates list, signal error on overflow

pattern batcalc.sht(b:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from oid to sht, signal error on overflow

pattern batcalc.sht_noerror(b:bat[:dbl],s:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from dbl to sht with candidates list

pattern batcalc.sht_noerror(b:bat[:dbl]):bat[:sht] 
address CMDconvert_sht;
comment cast from dbl to sht

pattern batcalc.sht(b:bat[:dbl],s:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from dbl to sht with candidates list, signal error on overflow

pattern batcalc.sht(b:bat[:dbl]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from dbl to sht, signal error on overflow

pattern batcalc.sht_noerror(b:bat[:flt],s:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from flt to sht with candidates list

pattern batcalc.sht_noerror(b:bat[:flt]):bat[:sht] 
address CMDconvert_sht;
comment cast from flt to sht

pattern batcalc.sht(b:bat[:flt],s:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from flt to sht with candidates list, signal error on overflow

pattern batcalc.sht(b:bat[:flt]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from flt to sht, signal error on overflow

pattern batcalc.sht_noerror(b:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from lng to sht with candidates list

pattern batcalc.sht_noerror(b:bat[:lng]):bat[:sht] 
address CMDconvert_sht;
comment cast from lng to sht

pattern batcalc.sht(b:bat[:lng],s:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from lng to sht with candidates list, signal error on overflow

pattern batcalc.sht(b:bat[:lng]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from lng to sht, signal error on overflow

pattern batcalc.sht_noerror(b:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from wrd to sht with candidates list

pattern batcalc.sht_noerror(b:bat[:wrd]):bat[:sht] 
address CMDconvert_sht;
comment cast from wrd to sht

pattern batcalc.sht(b:bat[:wrd],s:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from wrd to sht with candidates list, signal error on overflow

pattern batcalc.sht(b:bat[:wrd]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from wrd to sht, signal error on overflow

pattern batcalc.sht_noerror(b:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from int to sht with candidates list

pattern batcalc.sht_noerror(b:bat[:int]):bat[:sht] 
address CMDconvert_sht;
comment cast from int to sht

pattern batcalc.sht(b:bat[:int],s:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from int to sht with candidates list, signal error on overflow

pattern batcalc.sht(b:bat[:int]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from int to sht, signal error on overflow

pattern batcalc.sht_noerror(b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from sht to sht with candidates list

pattern batcalc.sht_noerror(b:bat[:sht]):bat[:sht] 
address CMDconvert_sht;
comment cast from sht to sht

pattern batcalc.sht(b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from sht to sht with candidates list, signal error on overflow

pattern batcalc.sht(b:bat[:sht]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from sht to sht, signal error on overflow

pattern batcalc.sht_noerror(b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from bte to sht with candidates list

pattern batcalc.sht_noerror(b:bat[:bte]):bat[:sht] 
address CMDconvert_sht;
comment cast from bte to sht

pattern batcalc.sht(b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from bte to sht with candidates list, signal error on overflow

pattern batcalc.sht(b:bat[:bte]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from bte to sht, signal error on overflow

pattern batcalc.sht_noerror(b:bat[:bit],s:bat[:oid]):bat[:sht] 
address CMDconvert_sht;
comment cast from bit to sht with candidates list

pattern batcalc.sht_noerror(b:bat[:bit]):bat[:sht] 
address CMDconvert_sht;
comment cast from bit to sht

pattern batcalc.sht(b:bat[:bit],s:bat[:oid]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from bit to sht with candidates list, signal error on overflow

pattern batcalc.sht(b:bat[:bit]):bat[:sht] 
address CMDconvertsignal_sht;
comment cast from bit to sht, signal error on overflow

pattern batcalc.sub_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:dbl):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:flt]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:flt,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:flt):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:flt]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:lng]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:lng,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:lng):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:lng]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:wrd]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:wrd,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:wrd):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:wrd],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:wrd]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:int]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:int,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:int):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:int]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:sht]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:sht,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:sht):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:sht]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:dbl,b:bat[:bte]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:bte,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:dbl],v:bte):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:dbl],b2:bat[:bte]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:dbl):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:flt):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:lng]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:lng,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:lng):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:lng]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:wrd]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:wrd,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:wrd):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:wrd],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:wrd]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:int]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:int,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:int):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:int]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:sht]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:sht,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:sht):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:sht]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:flt,b:bat[:bte]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:bte,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:flt],v:bte):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:flt],b2:bat[:bte]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:dbl):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:flt):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:wrd]):bat[:lng] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:wrd,s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:wrd):bat[:lng] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:wrd],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:wrd]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:int]):bat[:lng] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:int,s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:int):bat[:lng] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:int]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:sht]):bat[:lng] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:sht,s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:sht):bat[:lng] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:sht]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:lng,b:bat[:bte]):bat[:lng] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:bte,s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:lng],v:bte):bat[:lng] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:lng],b2:bat[:bte]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:dbl):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:flt):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:lng]):bat[:lng] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:lng):bat[:lng] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:lng]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:int]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:int,s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:int):bat[:wrd] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:int]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:sht]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:sht,s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:sht):bat[:wrd] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:sht]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:wrd,b:bat[:bte]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:bte,s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:wrd],v:bte):bat[:wrd] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:wrd],b2:bat[:bte]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:dbl):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:flt):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:lng]):bat[:lng] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:lng):bat[:lng] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:lng]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:wrd]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:wrd):bat[:wrd] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:wrd]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:int]):bat[:int] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:int):bat[:int] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:sht]):bat[:int] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:sht,s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:sht):bat[:int] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:sht]):bat[:int] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:int,b:bat[:bte]):bat[:int] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:bte,s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:int],v:bte):bat[:int] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:int],b2:bat[:bte]):bat[:int] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:dbl):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:flt):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:lng]):bat[:lng] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:lng):bat[:lng] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:lng]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:wrd]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:wrd):bat[:wrd] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:wrd]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:int]):bat[:int] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:int,s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:int):bat[:int] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:int]):bat[:int] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:sht,b:bat[:bte]):bat[:sht] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:bte,s:bat[:oid]):bat[:sht] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:sht],v:bte):bat[:sht] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]):bat[:sht] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:sht],b2:bat[:bte]):bat[:sht] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:dbl,s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:dbl):bat[:dbl] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:dbl]):bat[:dbl] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:flt,s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:flt):bat[:flt] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:flt]):bat[:flt] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:lng]):bat[:lng] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:lng):bat[:lng] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:lng]):bat[:lng] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:wrd]):bat[:wrd] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:wrd):bat[:wrd] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:wrd]):bat[:wrd] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:int]):bat[:int] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:int,s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:int):bat[:int] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:int]):bat[:int] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:sht]):bat[:sht] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:sht):bat[:sht] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:sht]):bat[:sht] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatSUB;
comment Return V - B with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatSUB;
comment Return V - B, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatSUB;
comment Return B - V with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatSUB;
comment Return B - V, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatSUB;
comment Return B1 - B2 with candidates list, overflow causes NIL value

pattern batcalc.sub_noerror(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatSUB;
comment Return B1 - B2, overflow causes NIL value

pattern batcalc.sign(b:bat[:dbl],s:bat[:oid]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat with candidates list

pattern batcalc.sign(b:bat[:dbl]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat

pattern batcalc.sign(b:bat[:flt],s:bat[:oid]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat with candidates list

pattern batcalc.sign(b:bat[:flt]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat

pattern batcalc.sign(b:bat[:lng],s:bat[:oid]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat with candidates list

pattern batcalc.sign(b:bat[:lng]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat

pattern batcalc.sign(b:bat[:wrd],s:bat[:oid]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat with candidates list

pattern batcalc.sign(b:bat[:wrd]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat

pattern batcalc.sign(b:bat[:int],s:bat[:oid]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat with candidates list

pattern batcalc.sign(b:bat[:int]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat

pattern batcalc.sign(b:bat[:sht],s:bat[:oid]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat with candidates list

pattern batcalc.sign(b:bat[:sht]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat

pattern batcalc.sign(b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat with candidates list

pattern batcalc.sign(b:bat[:bte]):bat[:bte] 
address CMDbatSIGN;
comment Unary sign (-1,0,1) over the tail of the bat

command batcalc.timestamp(v:bat[:timestamp],digits:int):bat[:timestamp] 
address battimestamp_2time_timestamp;
comment cast timestamp to timestamp and check for overflow

command batcalc.timestamp(v:bat[:str],digits:int,has_tz:int):bat[:timestamp] 
address batstr_2time_timestamptz;
comment cast to timestamp and check for overflow

command batcalc.timestamp(v:bat[:str],digits:int):bat[:timestamp] 
address batstr_2time_timestamp;
comment cast to timestamp and check for overflow

command batcalc.timestamp(v:bat[:str]):bat[:timestamp] 
address batstr_2_timestamp;
comment Cast to timestamp

command batcalc.timestamp(v:bat[:oid],digits:int):bat[:timestamp] 
address batnil_2time_timestamp;
comment cast to timestamp and check for overflow

command batcalc.timestamp(v:bat[:oid]):bat[:timestamp] 
address batnil_2_timestamp;
comment Cast to timestamp

command batcalc.timestamp(msecs:bat[:lng]):bat[:timestamp] 
address MTIMEtimestamp_lng_bulk;
command batcalc.timestamp(secs:bat[:int]):bat[:timestamp] 
address MTIMEtimestamp_bulk;
command batcalc.timestamp(d:bat[:date]):bat[:timestamp] 
address MTIMEtimestamp_create_from_date_bulk;
function batcalc.uuid(u:bat[:uuid]):bat[:uuid];
command batcalc.wrd(s1:int,v:bat[:lng],d2:int,s2:int):bat[:wrd] 
address batlng_dec2dec_wrd;
comment cast decimal(lng) to decimal(wrd) and check for overflow

command batcalc.wrd(s1:int,v:bat[:lng]):bat[:wrd] 
address batlng_dec2_wrd;
comment cast decimal(lng) to wrd and check for overflow

command batcalc.wrd(v:bat[:lng],digits:int,scale:int):bat[:wrd] 
address batlng_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command batcalc.wrd(s1:int,v:bat[:wrd],d2:int,s2:int):bat[:wrd] 
address batwrd_dec2dec_wrd;
comment cast decimal(wrd) to decimal(wrd) and check for overflow

command batcalc.wrd(s1:int,v:bat[:wrd]):bat[:wrd] 
address batwrd_dec2_wrd;
comment cast decimal(wrd) to wrd and check for overflow

command batcalc.wrd(v:bat[:wrd],digits:int,scale:int):bat[:wrd] 
address batwrd_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command batcalc.wrd(s1:int,v:bat[:int],d2:int,s2:int):bat[:wrd] 
address batint_dec2dec_wrd;
comment cast decimal(int) to decimal(wrd) and check for overflow

command batcalc.wrd(s1:int,v:bat[:int]):bat[:wrd] 
address batint_dec2_wrd;
comment cast decimal(int) to wrd and check for overflow

command batcalc.wrd(v:bat[:int],digits:int,scale:int):bat[:wrd] 
address batint_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command batcalc.wrd(s1:int,v:bat[:sht],d2:int,s2:int):bat[:wrd] 
address batsht_dec2dec_wrd;
comment cast decimal(sht) to decimal(wrd) and check for overflow

command batcalc.wrd(s1:int,v:bat[:sht]):bat[:wrd] 
address batsht_dec2_wrd;
comment cast decimal(sht) to wrd and check for overflow

command batcalc.wrd(v:bat[:sht],digits:int,scale:int):bat[:wrd] 
address batsht_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command batcalc.wrd(s1:int,v:bat[:bte],d2:int,s2:int):bat[:wrd] 
address batbte_dec2dec_wrd;
comment cast decimal(bte) to decimal(wrd) and check for overflow

command batcalc.wrd(s1:int,v:bat[:bte]):bat[:wrd] 
address batbte_dec2_wrd;
comment cast decimal(bte) to wrd and check for overflow

command batcalc.wrd(v:bat[:bte],digits:int,scale:int):bat[:wrd] 
address batbte_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command batcalc.wrd(v:bat[:dbl],digits:int,scale:int):bat[:wrd] 
address batdbl_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command batcalc.wrd(v:bat[:flt],digits:int,scale:int):bat[:wrd] 
address batflt_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command batcalc.wrd(v:bat[:str],digits:int,scale:int):bat[:wrd] 
address batstr_2dec_wrd;
comment cast to dec(wrd) and check for overflow

command batcalc.wrd(v:bat[:str],digits:int):bat[:wrd] 
address batstr_2num_wrd;
comment cast to wrd and check for overflow

command batcalc.wrd(v:bat[:oid],digits:int,scale:int):bat[:wrd] 
address batnil_2dec_wrd;
comment cast to dec(wrd) and check for overflow

command batcalc.wrd(v:bat[:oid],digits:int):bat[:wrd] 
address batnil_2num_wrd;
comment cast to wrd and check for overflow

command batcalc.wkb(geo:bat[:wkb],columnType:int,columnSRID:int):bat[:wkb] 
address geom_2_geom_bat;
comment Called when inserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition

pattern batcalc.wrd_noerror(b:bat[:str],s:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from str to wrd with candidates list

pattern batcalc.wrd_noerror(b:bat[:str]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from str to wrd

pattern batcalc.wrd(b:bat[:str],s:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from str to wrd with candidates list, signal error on overflow

pattern batcalc.wrd(b:bat[:str]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from str to wrd, signal error on overflow

pattern batcalc.wrd_noerror(b:bat[:oid],s:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from oid to wrd with candidates list

pattern batcalc.wrd_noerror(b:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from oid to wrd

pattern batcalc.wrd(b:bat[:oid],s:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from oid to wrd with candidates list, signal error on overflow

pattern batcalc.wrd(b:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from oid to wrd, signal error on overflow

pattern batcalc.wrd_noerror(b:bat[:dbl],s:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from dbl to wrd with candidates list

pattern batcalc.wrd_noerror(b:bat[:dbl]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from dbl to wrd

pattern batcalc.wrd(b:bat[:dbl],s:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from dbl to wrd with candidates list, signal error on overflow

pattern batcalc.wrd(b:bat[:dbl]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from dbl to wrd, signal error on overflow

pattern batcalc.wrd_noerror(b:bat[:flt],s:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from flt to wrd with candidates list

pattern batcalc.wrd_noerror(b:bat[:flt]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from flt to wrd

pattern batcalc.wrd(b:bat[:flt],s:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from flt to wrd with candidates list, signal error on overflow

pattern batcalc.wrd(b:bat[:flt]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from flt to wrd, signal error on overflow

pattern batcalc.wrd_noerror(b:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from lng to wrd with candidates list

pattern batcalc.wrd_noerror(b:bat[:lng]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from lng to wrd

pattern batcalc.wrd(b:bat[:lng],s:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from lng to wrd with candidates list, signal error on overflow

pattern batcalc.wrd(b:bat[:lng]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from lng to wrd, signal error on overflow

pattern batcalc.wrd_noerror(b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from wrd to wrd with candidates list

pattern batcalc.wrd_noerror(b:bat[:wrd]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from wrd to wrd

pattern batcalc.wrd(b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from wrd to wrd with candidates list, signal error on overflow

pattern batcalc.wrd(b:bat[:wrd]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from wrd to wrd, signal error on overflow

pattern batcalc.wrd_noerror(b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from int to wrd with candidates list

pattern batcalc.wrd_noerror(b:bat[:int]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from int to wrd

pattern batcalc.wrd(b:bat[:int],s:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from int to wrd with candidates list, signal error on overflow

pattern batcalc.wrd(b:bat[:int]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from int to wrd, signal error on overflow

pattern batcalc.wrd_noerror(b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from sht to wrd with candidates list

pattern batcalc.wrd_noerror(b:bat[:sht]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from sht to wrd

pattern batcalc.wrd(b:bat[:sht],s:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from sht to wrd with candidates list, signal error on overflow

pattern batcalc.wrd(b:bat[:sht]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from sht to wrd, signal error on overflow

pattern batcalc.wrd_noerror(b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from bte to wrd with candidates list

pattern batcalc.wrd_noerror(b:bat[:bte]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from bte to wrd

pattern batcalc.wrd(b:bat[:bte],s:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from bte to wrd with candidates list, signal error on overflow

pattern batcalc.wrd(b:bat[:bte]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from bte to wrd, signal error on overflow

pattern batcalc.wrd_noerror(b:bat[:bit],s:bat[:oid]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from bit to wrd with candidates list

pattern batcalc.wrd_noerror(b:bat[:bit]):bat[:wrd] 
address CMDconvert_wrd;
comment cast from bit to wrd

pattern batcalc.wrd(b:bat[:bit],s:bat[:oid]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from bit to wrd with candidates list, signal error on overflow

pattern batcalc.wrd(b:bat[:bit]):bat[:wrd] 
address CMDconvertsignal_wrd;
comment cast from bit to wrd, signal error on overflow

pattern batcalc.xor(v:lng,b:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatXOR;
comment Return V XOR B with candidates list

pattern batcalc.xor(v:lng,b:bat[:lng]):bat[:lng] 
address CMDbatXOR;
comment Return V XOR B

pattern batcalc.xor(b:bat[:lng],v:lng,s:bat[:oid]):bat[:lng] 
address CMDbatXOR;
comment Return B XOR V with candidates list

pattern batcalc.xor(b:bat[:lng],v:lng):bat[:lng] 
address CMDbatXOR;
comment Return B XOR V

pattern batcalc.xor(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]):bat[:lng] 
address CMDbatXOR;
comment Return B1 XOR B2 with candidates list

pattern batcalc.xor(b1:bat[:lng],b2:bat[:lng]):bat[:lng] 
address CMDbatXOR;
comment Return B1 XOR B2

pattern batcalc.xor(v:wrd,b:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatXOR;
comment Return V XOR B with candidates list

pattern batcalc.xor(v:wrd,b:bat[:wrd]):bat[:wrd] 
address CMDbatXOR;
comment Return V XOR B

pattern batcalc.xor(b:bat[:wrd],v:wrd,s:bat[:oid]):bat[:wrd] 
address CMDbatXOR;
comment Return B XOR V with candidates list

pattern batcalc.xor(b:bat[:wrd],v:wrd):bat[:wrd] 
address CMDbatXOR;
comment Return B XOR V

pattern batcalc.xor(b1:bat[:wrd],b2:bat[:wrd],s:bat[:oid]):bat[:wrd] 
address CMDbatXOR;
comment Return B1 XOR B2 with candidates list

pattern batcalc.xor(b1:bat[:wrd],b2:bat[:wrd]):bat[:wrd] 
address CMDbatXOR;
comment Return B1 XOR B2

pattern batcalc.xor(v:int,b:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatXOR;
comment Return V XOR B with candidates list

pattern batcalc.xor(v:int,b:bat[:int]):bat[:int] 
address CMDbatXOR;
comment Return V XOR B

pattern batcalc.xor(b:bat[:int],v:int,s:bat[:oid]):bat[:int] 
address CMDbatXOR;
comment Return B XOR V with candidates list

pattern batcalc.xor(b:bat[:int],v:int):bat[:int] 
address CMDbatXOR;
comment Return B XOR V

pattern batcalc.xor(b1:bat[:int],b2:bat[:int],s:bat[:oid]):bat[:int] 
address CMDbatXOR;
comment Return B1 XOR B2 with candidates list

pattern batcalc.xor(b1:bat[:int],b2:bat[:int]):bat[:int] 
address CMDbatXOR;
comment Return B1 XOR B2

pattern batcalc.xor(v:sht,b:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatXOR;
comment Return V XOR B with candidates list

pattern batcalc.xor(v:sht,b:bat[:sht]):bat[:sht] 
address CMDbatXOR;
comment Return V XOR B

pattern batcalc.xor(b:bat[:sht],v:sht,s:bat[:oid]):bat[:sht] 
address CMDbatXOR;
comment Return B XOR V with candidates list

pattern batcalc.xor(b:bat[:sht],v:sht):bat[:sht] 
address CMDbatXOR;
comment Return B XOR V

pattern batcalc.xor(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]):bat[:sht] 
address CMDbatXOR;
comment Return B1 XOR B2 with candidates list

pattern batcalc.xor(b1:bat[:sht],b2:bat[:sht]):bat[:sht] 
address CMDbatXOR;
comment Return B1 XOR B2

pattern batcalc.xor(v:bte,b:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatXOR;
comment Return V XOR B with candidates list

pattern batcalc.xor(v:bte,b:bat[:bte]):bat[:bte] 
address CMDbatXOR;
comment Return V XOR B

pattern batcalc.xor(b:bat[:bte],v:bte,s:bat[:oid]):bat[:bte] 
address CMDbatXOR;
comment Return B XOR V with candidates list

pattern batcalc.xor(b:bat[:bte],v:bte):bat[:bte] 
address CMDbatXOR;
comment Return B XOR V

pattern batcalc.xor(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]):bat[:bte] 
address CMDbatXOR;
comment Return B1 XOR B2 with candidates list

pattern batcalc.xor(b1:bat[:bte],b2:bat[:bte]):bat[:bte] 
address CMDbatXOR;
comment Return B1 XOR B2

pattern batcalc.xor(v:bit,b:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatXOR;
comment Return V XOR B with candidates list

pattern batcalc.xor(v:bit,b:bat[:bit]):bat[:bit] 
address CMDbatXOR;
comment Return V XOR B

pattern batcalc.xor(b:bat[:bit],v:bit,s:bat[:oid]):bat[:bit] 
address CMDbatXOR;
comment Return B XOR V with candidates list

pattern batcalc.xor(b:bat[:bit],v:bit):bat[:bit] 
address CMDbatXOR;
comment Return B XOR V

pattern batcalc.xor(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]):bat[:bit] 
address CMDbatXOR;
comment Return B1 XOR B2 with candidates list

pattern batcalc.xor(b1:bat[:bit],b2:bat[:bit]):bat[:bit] 
address CMDbatXOR;
comment Return B1 XOR B2

command batcalc.xml(src:bat[:str]):bat[:xml] 
address BATXMLstr2xml;
command batmkey.hash(b:bat[:any_1]):bat[:wrd] 
address MKEYbathash;
comment calculate a hash value

command bat.append(i:bat[:any_1],u:any_1):bat[:any_1] 
address BKCappend_val_wrap;
comment append the value u to i

command bat.attach(tt:int,heapfile:str):bat[:any_1] 
address BKCattach;
comment Returns a new BAT with dense head and tail of the given type and uses        the given file to initialize the tail. The file will be owned by the        server.

command bat.append(i:bat[:any_1],u:any_1,force:bit):bat[:any_1] 
address BKCappend_val_force_wrap;
comment append the value u to i

command bat.append(i:bat[:any_1],u:bat[:any_1],force:bit):bat[:any_1] 
address BKCappend_force_wrap;
comment append the content of u to i

command bat.append(i:bat[:any_1],u:bat[:any_1]):bat[:any_1] 
address BKCappend_wrap;
comment append the content of u to i

command bat.densebat(sz:wrd):bat[:oid] 
address BKCdensebat;
comment Creates a new [void,void] BAT of size 'sz'.

command bat.delete(b:bat[:any_1]):bat[:any_1] 
address BKCdelete_all;
comment Delete all entries.

command bat.delete(b:bat[:any_1],d:bat[:oid]):bat[:any_1] 
address BKCdelete_multi;
comment Delete multiple BUN, shifting BUNs up

command bat.delete(b:bat[:any_1],h:oid):bat[:any_1] 
address BKCdelete;
comment Delete BUN indicated by head value, exchanging with last BUN

command bat.getName(b:bat[:any_1]):str 
address BKCgetBBPname;
comment Gives back the logical name of a BAT.

command bat.getSequenceBase(b:bat[:any_1]):oid 
address BKCgetSequenceBase;
comment Get the sequence base for the void column of a BAT.

command bat.getAccess(b:bat[:any_1]):str 
address BKCgetAccess;
comment Return the access mode attached to this BAT as a character.

command bat.getRole(bid:bat[:any_1]):str 
address BKCgetRole;
comment Returns the rolename of the head column of a BAT.

command bat.getColumnType(b:bat[:any_1]):str 
address BKCgetColumnType;
comment Returns the type of the tail column of a BAT, as an integer type number.

command bat.getCapacity(b:bat[:any_1]):lng 
address BKCgetCapacity;
comment Returns the current allocation size (in max number of elements) of a BAT.

command bat.getSize(b:bat[:any_1]):lng 
address BKCgetSize;
comment Calculate the actual size of the BAT descriptor, heaps, hashes and imprint indices in bytes         rounded to the memory page size (see bbp.getPageSize()).

command bat.imprintsize(b:bat[:dbl]):lng 
address CMDBATimprintsize;
comment Return the storage size of the imprints index structure.

command bat.imprintsize(b:bat[:flt]):lng 
address CMDBATimprintsize;
command bat.imprintsize(b:bat[:lng]):lng 
address CMDBATimprintsize;
command bat.imprintsize(b:bat[:int]):lng 
address CMDBATimprintsize;
command bat.imprintsize(b:bat[:sht]):lng 
address CMDBATimprintsize;
command bat.imprintsize(b:bat[:bte]):lng 
address CMDBATimprintsize;
command bat.imprints(b:bat[:dbl]):void 
address CMDBATimprints;
comment Check for existence or create an imprint index on the BAT.

command bat.imprints(b:bat[:flt]):void 
address CMDBATimprints;
command bat.imprints(b:bat[:lng]):void 
address CMDBATimprints;
command bat.imprints(b:bat[:int]):void 
address CMDBATimprints;
command bat.imprints(b:bat[:sht]):void 
address CMDBATimprints;
command bat.imprints(b:bat[:bte]):void 
address CMDBATimprints;
command bat.intersectcand(a:bat[:oid],b:bat[:oid]):bat[:oid] 
address BKCintersectcand;
comment Intersect two candidate lists into one

command bat.isSynced(b1:bat[:any_1],b2:bat[:any_2]):bit 
address BKCisSynced;
comment Tests whether two BATs are synced or not. 

command bat.isPersistent(b:bat[:any_1]):bit 
address BKCisPersistent;
command bat.isTransient(b:bat[:any_1]):bit 
address BKCisTransient;
command bat.isSortedReverse(b:bat[:any_1]):bit 
address BKCisSortedReverse;
comment Returns true if BAT values are reversely ordered.

command bat.isSorted(b:bat[:any_1]):bit 
address BKCisSorted;
comment Returns true if BAT values are ordered.

command bat.isaKey(b:bat[:any_1]):bit 
address BKCgetKey;
comment Return whether the column tail values are unique (key).

command bat.info(b:bat[:any_1]) (X_2:bat[:str],X_3:bat[:str]) 
address BKCinfo;
comment Produce a table containing information about a BAT in [attribute,value] format.         It contains all properties of the BAT record. 

command bat.mergecand(a:bat[:oid],b:bat[:oid]):bat[:oid] 
address BKCmergecand;
comment Merge two candidate lists into one

command bat.mirror(b:bat[:any_2]):bat[:oid] 
address BKCmirror;
comment Returns the head-mirror image of a BAT (two head columns).

pattern bat.new_persistent(ht:oid,tt:any_1,size:lng):bat[:any_1] 
address CMDBATnew_persistent;
comment Creates a new BAT in the persistent farm and allocate space.

pattern bat.new_persistent(ht:oid,tt:any_1,size:int):bat[:any_1] 
address CMDBATnew_persistent;
pattern bat.new_persistent(ht:oid,tt:any_1):bat[:any_1] 
address CMDBATnew_persistent;
comment Creates a new empty transient BAT in the persistent farm, with head- and tail-types as indicated.

pattern bat.new(ht:oid,tt:any_1,size:lng):bat[:any_1] 
address CMDBATnew;
comment Creates a new BAT with sufficient space.

pattern bat.new(ht:oid,tt:any_1,size:int):bat[:any_1] 
address CMDBATnew;
pattern bat.new(ht:oid,tt:any_1):bat[:any_1] 
address CMDBATnew;
comment Creates a new empty transient BAT, with head- and tail-types as indicated.

pattern bat.new(tt:any_1,size:lng):bat[:any_1] 
address CMDBATnewColumn;
comment Creates a new empty transient BAT, with tail-types as indicated.

pattern bat.new(tt:any_1,size:int):bat[:any_1] 
address CMDBATnewColumn;
pattern bat.new(tt:any_1):bat[:any_1] 
address CMDBATnewColumn;
pattern bat.partition(b:bat[:any_1],pieces:int,n:int):bat[:any_1] 
address CMDBATpartition2;
comment Create the n-th slice over the BAT broken into several pieces.

pattern bat.partition(b:bat[:any_1]):bat[:any_1]... 
address CMDBATpartition;
comment Create a serie of slices over the BAT argument. The BUNs are distributed evenly.

command bat.reuseMap(b:bat[:any_1],del:bat[:oid]):bat[:oid] 
address BKCreuseBATmap;
comment Derive the oid mapping for reuse BAT based on list of to-be-deleted

command bat.reuse(b:bat[:any_1],del:bat[:oid]):bat[:any_1] 
address BKCreuseBAT;
comment Shuffle the values around to restore a dense representation of buns.

command bat.replace(b:bat[:any_1],rid:bat[:oid],val:bat[:any_1],force:bit):bat[:any_1] 
address BKCbat_inplace_force;
comment Perform replace for all BUNs of the second BAT into the first.

command bat.replace(b:bat[:any_1],rid:bat[:oid],val:bat[:any_1]):bat[:any_1] 
address BKCbat_inplace;
comment Perform replace for all BUNs of the second BAT into the first.

command bat.replace(b:bat[:any_1],h:oid,t:any_1,force:bit):bat[:any_1] 
address BKCbun_inplace_force;
comment Replace the tail value of one BUN that has some head value.

command bat.replace(b:bat[:any_1],h:oid,t:any_1):bat[:any_1] 
address BKCbun_inplace;
comment Replace the tail value of one BUN that has some head value.

pattern bat.single(val:any_1):bat[:any_1] 
address CMDBATsingle;
comment Create a BAT with a single elemenet

command bat.setImprints(b:bat[:any_1]):bit 
address BKCsetImprints;
comment Create an imprints structure on the column

command bat.setHash(b:bat[:any_1]):bit 
address BKCsetHash;
comment Create a hash structure on the column

command bat.save(nme:str):bit 
address BKCsave;
comment Save a BAT to storage, if it was loaded and dirty.          Returns whether IO was necessary.  Please realize that 	calling this function violates the atomic commit protocol!!

command bat.save(nme:bat[:any_1]):void 
address BKCsave2;
command bat.setPersistent(b:bat[:any_1]):void 
address BKCsetPersistent;
comment Make the BAT persistent.

command bat.setTransient(b:bat[:any_1]):void 
address BKCsetTransient;
comment Make the BAT transient.  Returns 	boolean which indicates if theBAT administration has indeed changed.

command bat.setColumn(b:bat[:any_1],h:str,t:str):void 
address BKCsetColumns;
comment Give both columns of a BAT a new name.

command bat.setColumn(b:bat[:any_1],t:str):void 
address BKCsetColumn;
comment Give a logical name to the tail column of a BAT.

command bat.setRole(b:bat[:any_1],h:str,t:str):void 
address BKCsetRole;
comment Give a logical name to the columns of a BAT.

command bat.setName(b:bat[:any_1],s:str):void 
address BKCsetName;
comment Give a logical name to a BAT. 

command bat.setAccess(b:bat[:any_1],mode:str):bat[:any_1] 
address BKCsetAccess;
comment Try to change the update access priviliges 	to this BAT. Mode:	 r[ead-only]      - allow only read access.	 a[append-only]   - allow reads and update.	 w[riteable]      - allow all operations.	 BATs are updatable by default. On making a BAT read-only,      all subsequent updates fail with an error message.	 Returns the BAT itself.

command bat.setKey(b:bat[:any_1],mode:bit):bat[:any_1] 
address BKCsetkey;
comment Sets the 'key' property of the tail column to 'mode'. In 'key' mode,         the kernel will silently block insertions that cause a duplicate         entries in the head column. KNOWN BUG:when 'key' is set to TRUE, this 		function does not automatically eliminate duplicates. 

pattern bbp.bind(name:str):bat[:any_2] 
address CMDbbpbind;
comment Locate the BAT using its logical name

command bbp.getPageSize():int 
address CMDgetPageSize;
comment Obtain the memory page size

command bbp.getDiskSpace():lng 
address CMDbbpDiskSpace;
comment Estimate the amount of disk space occupied by dbpath

command bbp.getLRefCount(b:bat[:any_1]):int 
address CMDgetBATlrefcnt;
comment Utility for debugging MAL interpreter

command bbp.getRefCount(b:bat[:any_1]):int 
address CMDgetBATrefcnt;
comment Utility for debugging MAL interpreter

command bbp.getKind():bat[:str] 
address CMDbbpKind;
comment Create a BAT with the persistency status

command bbp.getStatus():bat[:str] 
address CMDbbpStatus;
comment Create a BAT with the disk/load status

command bbp.getDirty():bat[:str] 
address CMDbbpDirty;
comment Create a BAT with the dirty/ diffs/clean status

command bbp.getHeat():bat[:int] 
address CMDbbpHeat;
comment Create a BAT with the heat values

command bbp.getLocation():bat[:str] 
address CMDbbpLocation;
comment Create a BAT with their disk locations

command bbp.getLRefCount():bat[:int] 
address CMDbbpLRefCount;
comment Create a BAT with the logical reference counts

command bbp.getRefCount():bat[:int] 
address CMDbbpRefCount;
comment Create a BAT with the (hard) reference counts

command bbp.getCount():bat[:lng] 
address CMDbbpCount;
comment Create a BAT with the cardinalities of all known BATs

command bbp.getName(b:bat[:any_1]):str 
address CMDbbpName;
comment Map a BAT into its internal name

command bbp.get() (id:bat[:int],ns:bat[:str],tt:bat[:str],cnt:bat[:lng],refcnt:bat[:int],lrefcnt:bat[:int],location:bat[:str],heat:bat[:int],dirty:bat[:str],status:bat[:str],kind:bat[:str]) 
address CMDbbp;
comment bpp

command bbp.getNames():bat[:str] 
address CMDbbpNames;
comment Map BAT into its bbp name

command bbp.getIndex(b:bat[:any_2]):int 
address CMDbbpgetIndex;
comment Retrieve the index in the BBP

command bbp.setName(b:bat[:any_1],n:str):str 
address CMDsetName;
comment Rename a BAT

command blob.blob(s:str):blob 
address BLOBblob_fromstr;
command blob.blob(s:blob):blob 
address BLOBblob_blob;
comment Noop routine.

command blob.#del():void 
address BLOBdel;
command blob.#fromstr():void 
address BLOBfromstr;
command blob.#heap():void 
address BLOBheap;
command blob.#hash():void 
address BLOBhash;
command blob.#length():void 
address BLOBlength;
command blob.nitems(b:blob):int 
address BLOBnitems;
comment  get the number of bytes in this blob.

command blob.#null():void 
address BLOBnull;
command blob.#nequal():void 
address BLOBnequal;
command blob.prelude():void 
address BLOBprelude;
command blob.#put():void 
address BLOBput;
command blob.#read():void 
address BLOBread;
command blob.toblob(v:str):blob 
address BLOBtoblob;
comment store a string as a blob.

command blob.tostring(v:blob,index:int):str 
address BLOBfromidx;
comment get the bytes from blob as a string,	 starting at byte 'index' till the first	0 byte or the end of the blob.

command blob.tostring(v:blob):str 
address BLOBfromblob;
comment get the bytes from blob as a string, till	the first 0 byte or the end of the blob

command blob.#tostr():void 
address BLOBtostr;
command blob.#write():void 
address BLOBwrite;
command bstream.create(s:streams,bufsize:int):bstream 
address bstream_create_wrapwrap;
comment create a buffered stream

command bstream.destroy(s:bstream):void 
address bstream_destroy_wrapwrap;
comment destroy bstream

command bstream.read(s:bstream,size:int):int 
address bstream_read_wrapwrap;
comment read at least size bytes into the buffer of s

pattern calc.!=(v1:dbl,v2:dbl):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:dbl,v2:flt):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:dbl,v2:lng):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:dbl,v2:wrd):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:dbl,v2:int):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:dbl,v2:sht):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:dbl,v2:bte):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:flt,v2:dbl):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:flt,v2:flt):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:flt,v2:lng):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:flt,v2:wrd):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:flt,v2:int):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:flt,v2:sht):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:flt,v2:bte):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:lng,v2:dbl):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:lng,v2:flt):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:lng,v2:lng):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:lng,v2:wrd):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:lng,v2:int):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:lng,v2:sht):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:lng,v2:bte):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:wrd,v2:dbl):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:wrd,v2:flt):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:wrd,v2:lng):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:wrd,v2:wrd):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:wrd,v2:int):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:wrd,v2:sht):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:wrd,v2:bte):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:int,v2:dbl):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:int,v2:flt):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:int,v2:lng):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:int,v2:wrd):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:int,v2:int):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:int,v2:sht):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:int,v2:bte):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:sht,v2:dbl):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:sht,v2:flt):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:sht,v2:lng):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:sht,v2:wrd):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:sht,v2:int):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:sht,v2:sht):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:sht,v2:bte):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:bte,v2:dbl):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:bte,v2:flt):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:bte,v2:lng):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:bte,v2:wrd):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:bte,v2:int):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:bte,v2:sht):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:bte,v2:bte):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:oid,v2:oid):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:str,v2:str):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(v1:bit,v2:bit):bit 
address CMDvarNE;
comment Return V1 != V2

command calc.!=(v:inet,w:inet):bit 
address INET_comp_NEQ;
comment Inequality of two inets

pattern calc.!=(v:timestamp,w:timestamp):bit 
address CMDvarNE;
comment Equality of two timestamps

pattern calc.!=(v:daytime,w:daytime):bit 
address CMDvarNE;
comment Equality of two daytimes

pattern calc.!=(v:date,w:date):bit 
address CMDvarNE;
comment Equality of two dates

pattern calc.!=(l:json,r:json):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.!=(l:uuid,r:uuid):bit 
address CMDvarNE;
comment Return V1 != V2

pattern calc.%(v1:dbl,v2:dbl):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:dbl,v2:flt):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:dbl,v2:lng):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:dbl,v2:wrd):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:dbl,v2:int):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:dbl,v2:sht):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:dbl,v2:bte):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:flt,v2:dbl):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:flt,v2:flt):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:flt,v2:lng):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:flt,v2:wrd):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:flt,v2:int):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:flt,v2:sht):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:flt,v2:bte):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:lng,v2:dbl):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:lng,v2:flt):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:lng,v2:lng):lng 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:lng,v2:wrd):wrd 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:lng,v2:int):int 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:lng,v2:sht):sht 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:lng,v2:bte):bte 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:wrd,v2:dbl):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:wrd,v2:flt):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:wrd,v2:lng):wrd 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:wrd,v2:wrd):wrd 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:wrd,v2:int):int 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:wrd,v2:sht):sht 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:wrd,v2:bte):bte 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:int,v2:dbl):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:int,v2:flt):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:int,v2:lng):int 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:int,v2:wrd):int 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:int,v2:int):int 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:int,v2:sht):sht 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:int,v2:bte):bte 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:sht,v2:dbl):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:sht,v2:flt):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:sht,v2:lng):sht 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:sht,v2:wrd):sht 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:sht,v2:int):sht 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:sht,v2:sht):sht 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:sht,v2:bte):bte 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:bte,v2:dbl):dbl 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:bte,v2:flt):flt 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:bte,v2:lng):bte 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:bte,v2:wrd):bte 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:bte,v2:int):bte 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:bte,v2:sht):bte 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.%(v1:bte,v2:bte):bte 
address CMDvarMODsignal;
comment Return V1 % V2, signal error on divide by zero

pattern calc.*(v1:dbl,v2:dbl):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:dbl,v2:flt):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:dbl,v2:lng):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:dbl,v2:wrd):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:dbl,v2:int):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:dbl,v2:sht):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:dbl,v2:bte):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:flt,v2:dbl):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:flt,v2:flt):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:flt,v2:lng):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:flt,v2:wrd):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:flt,v2:int):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:flt,v2:sht):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:flt,v2:bte):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:lng,v2:dbl):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:lng,v2:flt):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:lng,v2:lng):lng 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:lng,v2:wrd):lng 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:lng,v2:int):lng 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:lng,v2:sht):lng 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:lng,v2:bte):lng 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:wrd,v2:dbl):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:wrd,v2:flt):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:wrd,v2:lng):lng 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:wrd,v2:wrd):wrd 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:wrd,v2:int):wrd 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:wrd,v2:sht):wrd 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:wrd,v2:bte):wrd 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:int,v2:dbl):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:int,v2:flt):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:int,v2:lng):lng 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:int,v2:wrd):wrd 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:int,v2:int):int 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:int,v2:sht):int 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:int,v2:bte):int 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:sht,v2:dbl):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:sht,v2:flt):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:sht,v2:lng):lng 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:sht,v2:wrd):wrd 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:sht,v2:int):int 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:sht,v2:sht):sht 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:sht,v2:bte):sht 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:bte,v2:dbl):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:bte,v2:flt):flt 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:bte,v2:lng):lng 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:bte,v2:wrd):wrd 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:bte,v2:int):int 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:bte,v2:sht):sht 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:bte,v2:bte):bte 
address CMDvarMULsignal;
comment Return V1 * V2, signal error on overflow

pattern calc.*(v1:flt,v2:flt):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:flt,v2:lng):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:flt,v2:wrd):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:flt,v2:int):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:flt,v2:sht):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:flt,v2:bte):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:lng,v2:flt):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:wrd,v2:flt):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:int,v2:flt):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:int,v2:int):lng 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:int,v2:sht):lng 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:int,v2:bte):lng 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:sht,v2:flt):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:sht,v2:int):lng 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:sht,v2:sht):int 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:sht,v2:bte):int 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:bte,v2:flt):dbl 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:bte,v2:int):lng 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:bte,v2:sht):int 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

pattern calc.*(v1:bte,v2:bte):sht 
address CMDvarMULsignal;
comment Return V1 * V2, guarantee no overflow by returning larger type

command calc.+(v1:str,i:int):str 
address CMDvarADDstrint;
comment Concatenate LEFT and string representation of RIGHT

command calc.+(v1:str,v2:str):str 
address CMDvarADDstr;
comment Concatenate LEFT and RIGHT

pattern calc.+(v1:dbl,v2:dbl):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:dbl,v2:flt):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:dbl,v2:lng):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:dbl,v2:wrd):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:dbl,v2:int):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:dbl,v2:sht):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:dbl,v2:bte):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:flt,v2:dbl):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:flt,v2:flt):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:flt,v2:lng):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:flt,v2:wrd):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:flt,v2:int):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:flt,v2:sht):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:flt,v2:bte):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:lng,v2:dbl):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:lng,v2:flt):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:lng,v2:lng):lng 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:lng,v2:wrd):lng 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:lng,v2:int):lng 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:lng,v2:sht):lng 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:lng,v2:bte):lng 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:wrd,v2:dbl):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:wrd,v2:flt):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:wrd,v2:lng):lng 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:wrd,v2:wrd):wrd 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:wrd,v2:int):wrd 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:wrd,v2:sht):wrd 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:wrd,v2:bte):wrd 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:int,v2:dbl):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:int,v2:flt):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:int,v2:lng):lng 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:int,v2:wrd):wrd 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:int,v2:int):int 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:int,v2:sht):int 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:int,v2:bte):int 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:sht,v2:dbl):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:sht,v2:flt):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:sht,v2:lng):lng 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:sht,v2:wrd):wrd 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:sht,v2:int):int 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:sht,v2:sht):sht 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:sht,v2:bte):sht 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:bte,v2:dbl):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:bte,v2:flt):flt 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:bte,v2:lng):lng 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:bte,v2:wrd):wrd 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:bte,v2:int):int 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:bte,v2:sht):sht 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:bte,v2:bte):bte 
address CMDvarADDsignal;
comment Return V1 + V2, signal error on overflow

pattern calc.+(v1:flt,v2:flt):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:flt,v2:lng):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:flt,v2:wrd):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:flt,v2:int):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:flt,v2:sht):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:flt,v2:bte):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:lng,v2:flt):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:wrd,v2:flt):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:int,v2:flt):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:int,v2:int):lng 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:int,v2:sht):lng 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:int,v2:bte):lng 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:sht,v2:flt):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:sht,v2:int):lng 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:sht,v2:sht):int 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:sht,v2:bte):int 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:bte,v2:flt):dbl 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:bte,v2:int):lng 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:bte,v2:sht):int 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.+(v1:bte,v2:bte):sht 
address CMDvarADDsignal;
comment Return V1 + V2, guarantee no overflow by returning larger type

pattern calc.++(v:dbl):dbl 
address CMDvarINCRsignal;
comment Unary V + 1

pattern calc.++(v:flt):flt 
address CMDvarINCRsignal;
comment Unary V + 1

pattern calc.++(v:lng):lng 
address CMDvarINCRsignal;
comment Unary V + 1

pattern calc.++(v:wrd):wrd 
address CMDvarINCRsignal;
comment Unary V + 1

pattern calc.++(v:int):int 
address CMDvarINCRsignal;
comment Unary V + 1

pattern calc.++(v:sht):sht 
address CMDvarINCRsignal;
comment Unary V + 1

pattern calc.++(v:bte):bte 
address CMDvarINCRsignal;
comment Unary V + 1

pattern calc.-(v1:dbl,v2:dbl):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:dbl,v2:flt):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:dbl,v2:lng):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:dbl,v2:wrd):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:dbl,v2:int):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:dbl,v2:sht):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:dbl,v2:bte):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:flt,v2:dbl):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:flt,v2:flt):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:flt,v2:lng):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:flt,v2:wrd):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:flt,v2:int):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:flt,v2:sht):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:flt,v2:bte):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:lng,v2:dbl):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:lng,v2:flt):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:lng,v2:lng):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:lng,v2:wrd):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:lng,v2:int):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:lng,v2:sht):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:lng,v2:bte):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:wrd,v2:dbl):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:wrd,v2:flt):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:wrd,v2:lng):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:wrd,v2:wrd):wrd 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:wrd,v2:int):wrd 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:wrd,v2:sht):wrd 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:wrd,v2:bte):wrd 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:int,v2:dbl):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:int,v2:flt):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:int,v2:lng):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:int,v2:wrd):wrd 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:int,v2:int):int 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:int,v2:sht):int 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:int,v2:bte):int 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:sht,v2:dbl):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:sht,v2:flt):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:sht,v2:lng):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:sht,v2:wrd):wrd 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:sht,v2:int):int 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:sht,v2:sht):sht 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:sht,v2:bte):sht 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:bte,v2:dbl):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:bte,v2:flt):flt 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:bte,v2:lng):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:bte,v2:wrd):wrd 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:bte,v2:int):int 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:bte,v2:sht):sht 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:bte,v2:bte):bte 
address CMDvarSUBsignal;
comment Return V1 - V2, signal error on overflow

pattern calc.-(v1:flt,v2:flt):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:flt,v2:lng):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:flt,v2:wrd):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:flt,v2:int):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:flt,v2:sht):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:flt,v2:bte):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:lng,v2:flt):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:wrd,v2:flt):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:int,v2:flt):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:int,v2:int):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:int,v2:sht):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:int,v2:bte):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:sht,v2:flt):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:sht,v2:int):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:sht,v2:sht):int 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:sht,v2:bte):int 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:bte,v2:flt):dbl 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:bte,v2:int):lng 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:bte,v2:sht):int 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.-(v1:bte,v2:bte):sht 
address CMDvarSUBsignal;
comment Return V1 - V2, guarantee no overflow by returning larger type

pattern calc.--(v:dbl):dbl 
address CMDvarDECRsignal;
comment Unary V - 1

pattern calc.--(v:flt):flt 
address CMDvarDECRsignal;
comment Unary V - 1

pattern calc.--(v:lng):lng 
address CMDvarDECRsignal;
comment Unary V - 1

pattern calc.--(v:wrd):wrd 
address CMDvarDECRsignal;
comment Unary V - 1

pattern calc.--(v:int):int 
address CMDvarDECRsignal;
comment Unary V - 1

pattern calc.--(v:sht):sht 
address CMDvarDECRsignal;
comment Unary V - 1

pattern calc.--(v:bte):bte 
address CMDvarDECRsignal;
comment Unary V - 1

pattern calc.-(v:dbl):dbl 
address CMDvarNEG;
comment Unary negation of V

pattern calc.-(v:flt):flt 
address CMDvarNEG;
comment Unary negation of V

pattern calc.-(v:lng):lng 
address CMDvarNEG;
comment Unary negation of V

pattern calc.-(v:wrd):wrd 
address CMDvarNEG;
comment Unary negation of V

pattern calc.-(v:int):int 
address CMDvarNEG;
comment Unary negation of V

pattern calc.-(v:sht):sht 
address CMDvarNEG;
comment Unary negation of V

pattern calc.-(v:bte):bte 
address CMDvarNEG;
comment Unary negation of V

pattern calc./(v1:dbl,v2:dbl):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:dbl,v2:flt):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:dbl,v2:lng):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:dbl,v2:wrd):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:dbl,v2:int):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:dbl,v2:sht):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:dbl,v2:bte):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:dbl):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:flt):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:flt):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:lng):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:lng):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:wrd):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:wrd):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:int):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:int):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:sht):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:sht):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:bte):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:flt,v2:bte):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:dbl):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:flt):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:flt):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:lng):lng 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:lng):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:lng):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:wrd):lng 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:wrd):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:wrd):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:int):lng 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:int):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:int):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:sht):lng 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:sht):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:sht):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:bte):lng 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:bte):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:lng,v2:bte):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:dbl):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:flt):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:flt):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:lng):wrd 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:lng):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:lng):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:wrd):wrd 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:wrd):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:wrd):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:int):wrd 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:int):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:int):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:sht):wrd 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:sht):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:sht):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:bte):wrd 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:bte):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:wrd,v2:bte):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:dbl):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:flt):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:flt):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:lng):int 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:lng):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:lng):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:wrd):int 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:wrd):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:wrd):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:int):int 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:int):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:int):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:sht):int 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:sht):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:sht):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:bte):int 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:bte):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:int,v2:bte):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:dbl):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:flt):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:flt):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:lng):sht 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:lng):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:lng):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:wrd):sht 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:wrd):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:wrd):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:int):sht 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:int):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:int):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:sht):sht 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:sht):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:sht):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:bte):sht 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:bte):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:sht,v2:bte):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:dbl):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:flt):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:flt):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:lng):bte 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:lng):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:lng):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:wrd):bte 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:wrd):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:wrd):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:int):bte 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:int):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:int):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:sht):bte 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:sht):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:sht):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:bte):bte 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:bte):dbl 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc./(v1:bte,v2:bte):flt 
address CMDvarDIVsignal;
comment Return V1 / V2, signal error on overflow

pattern calc.<=(v1:dbl,v2:dbl):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:dbl,v2:flt):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:dbl,v2:lng):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:dbl,v2:wrd):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:dbl,v2:int):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:dbl,v2:sht):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:dbl,v2:bte):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:flt,v2:dbl):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:flt,v2:flt):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:flt,v2:lng):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:flt,v2:wrd):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:flt,v2:int):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:flt,v2:sht):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:flt,v2:bte):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:lng,v2:dbl):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:lng,v2:flt):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:lng,v2:lng):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:lng,v2:wrd):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:lng,v2:int):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:lng,v2:sht):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:lng,v2:bte):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:wrd,v2:dbl):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:wrd,v2:flt):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:wrd,v2:lng):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:wrd,v2:wrd):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:wrd,v2:int):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:wrd,v2:sht):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:wrd,v2:bte):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:int,v2:dbl):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:int,v2:flt):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:int,v2:lng):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:int,v2:wrd):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:int,v2:int):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:int,v2:sht):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:int,v2:bte):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:sht,v2:dbl):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:sht,v2:flt):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:sht,v2:lng):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:sht,v2:wrd):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:sht,v2:int):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:sht,v2:sht):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:sht,v2:bte):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:bte,v2:dbl):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:bte,v2:flt):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:bte,v2:lng):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:bte,v2:wrd):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:bte,v2:int):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:bte,v2:sht):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:bte,v2:bte):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:oid,v2:oid):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:str,v2:str):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<=(v1:bit,v2:bit):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<(v1:dbl,v2:dbl):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:dbl,v2:flt):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:dbl,v2:lng):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:dbl,v2:wrd):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:dbl,v2:int):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:dbl,v2:sht):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:dbl,v2:bte):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:flt,v2:dbl):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:flt,v2:flt):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:flt,v2:lng):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:flt,v2:wrd):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:flt,v2:int):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:flt,v2:sht):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:flt,v2:bte):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:lng,v2:dbl):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:lng,v2:flt):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:lng,v2:lng):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:lng,v2:wrd):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:lng,v2:int):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:lng,v2:sht):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:lng,v2:bte):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:wrd,v2:dbl):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:wrd,v2:flt):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:wrd,v2:lng):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:wrd,v2:wrd):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:wrd,v2:int):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:wrd,v2:sht):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:wrd,v2:bte):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:int,v2:dbl):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:int,v2:flt):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:int,v2:lng):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:int,v2:wrd):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:int,v2:int):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:int,v2:sht):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:int,v2:bte):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:sht,v2:dbl):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:sht,v2:flt):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:sht,v2:lng):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:sht,v2:wrd):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:sht,v2:int):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:sht,v2:sht):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:sht,v2:bte):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:bte,v2:dbl):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:bte,v2:flt):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:bte,v2:lng):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:bte,v2:wrd):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:bte,v2:int):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:bte,v2:sht):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:bte,v2:bte):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:oid,v2:oid):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:str,v2:str):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<(v1:bit,v2:bit):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<<(v1:lng,v2:lng):lng 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:lng,v2:wrd):lng 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:lng,v2:int):lng 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:lng,v2:sht):lng 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:lng,v2:bte):lng 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:wrd,v2:lng):wrd 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:wrd,v2:wrd):wrd 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:wrd,v2:int):wrd 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:wrd,v2:sht):wrd 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:wrd,v2:bte):wrd 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:int,v2:lng):int 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:int,v2:wrd):int 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:int,v2:int):int 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:int,v2:sht):int 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:int,v2:bte):int 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:sht,v2:lng):sht 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:sht,v2:wrd):sht 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:sht,v2:int):sht 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:sht,v2:sht):sht 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:sht,v2:bte):sht 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:bte,v2:lng):bte 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:bte,v2:wrd):bte 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:bte,v2:int):bte 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:bte,v2:sht):bte 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

pattern calc.<<(v1:bte,v2:bte):bte 
address CMDvarLSHsignal;
comment Return V1 << V2, raise error on out of range second operand

command calc.<=(v:inet,w:inet):bit 
address INET_comp_LE;
comment Whether v is less than or equal to w

command calc.<(v:inet,w:inet):bit 
address INET_comp_LT;
comment Whether v is less than w

pattern calc.<=(v:timestamp,w:timestamp):bit 
address CMDvarLE;
comment Equality of two timestamps

pattern calc.<(v:timestamp,w:timestamp):bit 
address CMDvarLT;
comment Equality of two timestamps

pattern calc.<=(v:daytime,w:daytime):bit 
address CMDvarLE;
comment Equality of two daytimes

pattern calc.<(v:daytime,w:daytime):bit 
address CMDvarLT;
comment Equality of two daytimes

pattern calc.<=(v:date,w:date):bit 
address CMDvarLE;
comment Equality of two dates

pattern calc.<(v:date,w:date):bit 
address CMDvarLT;
comment Equality of two dates

pattern calc.<=(l:json,r:json):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<(l:json,r:json):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.<=(l:uuid,r:uuid):bit 
address CMDvarLE;
comment Return V1 <= V2

pattern calc.<(l:uuid,r:uuid):bit 
address CMDvarLT;
comment Return V1 < V2

pattern calc.==(v1:dbl,v2:dbl):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:dbl,v2:flt):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:dbl,v2:lng):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:dbl,v2:wrd):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:dbl,v2:int):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:dbl,v2:sht):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:dbl,v2:bte):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:flt,v2:dbl):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:flt,v2:flt):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:flt,v2:lng):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:flt,v2:wrd):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:flt,v2:int):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:flt,v2:sht):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:flt,v2:bte):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:lng,v2:dbl):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:lng,v2:flt):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:lng,v2:lng):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:lng,v2:wrd):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:lng,v2:int):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:lng,v2:sht):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:lng,v2:bte):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:wrd,v2:dbl):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:wrd,v2:flt):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:wrd,v2:lng):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:wrd,v2:wrd):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:wrd,v2:int):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:wrd,v2:sht):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:wrd,v2:bte):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:int,v2:dbl):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:int,v2:flt):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:int,v2:lng):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:int,v2:wrd):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:int,v2:int):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:int,v2:sht):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:int,v2:bte):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:sht,v2:dbl):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:sht,v2:flt):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:sht,v2:lng):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:sht,v2:wrd):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:sht,v2:int):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:sht,v2:sht):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:sht,v2:bte):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:bte,v2:dbl):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:bte,v2:flt):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:bte,v2:lng):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:bte,v2:wrd):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:bte,v2:int):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:bte,v2:sht):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:bte,v2:bte):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:oid,v2:oid):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:str,v2:str):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(v1:bit,v2:bit):bit 
address CMDvarEQ;
comment Return V1 == V2

command calc.==(v:inet,w:inet):bit 
address INET_comp_EQ;
comment Equality of two inets

pattern calc.==(v:timestamp,w:timestamp):bit 
address CMDvarEQ;
comment Equality of two timestamps

pattern calc.==(v:daytime,w:daytime):bit 
address CMDvarEQ;
comment Equality of two daytimes

pattern calc.==(v:date,w:date):bit 
address CMDvarEQ;
comment Equality of two dates

pattern calc.==(l:json,r:json):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.==(l:uuid,r:uuid):bit 
address CMDvarEQ;
comment Return V1 == V2

pattern calc.>=(v1:dbl,v2:dbl):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:dbl,v2:flt):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:dbl,v2:lng):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:dbl,v2:wrd):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:dbl,v2:int):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:dbl,v2:sht):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:dbl,v2:bte):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:flt,v2:dbl):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:flt,v2:flt):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:flt,v2:lng):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:flt,v2:wrd):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:flt,v2:int):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:flt,v2:sht):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:flt,v2:bte):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:lng,v2:dbl):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:lng,v2:flt):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:lng,v2:lng):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:lng,v2:wrd):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:lng,v2:int):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:lng,v2:sht):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:lng,v2:bte):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:wrd,v2:dbl):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:wrd,v2:flt):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:wrd,v2:lng):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:wrd,v2:wrd):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:wrd,v2:int):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:wrd,v2:sht):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:wrd,v2:bte):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:int,v2:dbl):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:int,v2:flt):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:int,v2:lng):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:int,v2:wrd):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:int,v2:int):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:int,v2:sht):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:int,v2:bte):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:sht,v2:dbl):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:sht,v2:flt):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:sht,v2:lng):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:sht,v2:wrd):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:sht,v2:int):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:sht,v2:sht):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:sht,v2:bte):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:bte,v2:dbl):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:bte,v2:flt):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:bte,v2:lng):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:bte,v2:wrd):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:bte,v2:int):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:bte,v2:sht):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:bte,v2:bte):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:oid,v2:oid):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:str,v2:str):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>=(v1:bit,v2:bit):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>(v1:dbl,v2:dbl):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:dbl,v2:flt):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:dbl,v2:lng):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:dbl,v2:wrd):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:dbl,v2:int):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:dbl,v2:sht):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:dbl,v2:bte):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:flt,v2:dbl):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:flt,v2:flt):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:flt,v2:lng):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:flt,v2:wrd):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:flt,v2:int):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:flt,v2:sht):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:flt,v2:bte):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:lng,v2:dbl):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:lng,v2:flt):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:lng,v2:lng):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:lng,v2:wrd):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:lng,v2:int):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:lng,v2:sht):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:lng,v2:bte):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:wrd,v2:dbl):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:wrd,v2:flt):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:wrd,v2:lng):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:wrd,v2:wrd):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:wrd,v2:int):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:wrd,v2:sht):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:wrd,v2:bte):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:int,v2:dbl):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:int,v2:flt):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:int,v2:lng):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:int,v2:wrd):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:int,v2:int):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:int,v2:sht):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:int,v2:bte):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:sht,v2:dbl):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:sht,v2:flt):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:sht,v2:lng):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:sht,v2:wrd):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:sht,v2:int):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:sht,v2:sht):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:sht,v2:bte):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:bte,v2:dbl):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:bte,v2:flt):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:bte,v2:lng):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:bte,v2:wrd):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:bte,v2:int):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:bte,v2:sht):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:bte,v2:bte):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:oid,v2:oid):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:str,v2:str):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>(v1:bit,v2:bit):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>>(v1:lng,v2:lng):lng 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:lng,v2:wrd):lng 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:lng,v2:int):lng 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:lng,v2:sht):lng 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:lng,v2:bte):lng 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:wrd,v2:lng):wrd 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:wrd,v2:wrd):wrd 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:wrd,v2:int):wrd 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:wrd,v2:sht):wrd 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:wrd,v2:bte):wrd 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:int,v2:lng):int 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:int,v2:wrd):int 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:int,v2:int):int 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:int,v2:sht):int 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:int,v2:bte):int 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:sht,v2:lng):sht 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:sht,v2:wrd):sht 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:sht,v2:int):sht 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:sht,v2:sht):sht 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:sht,v2:bte):sht 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:bte,v2:lng):bte 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:bte,v2:wrd):bte 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:bte,v2:int):bte 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:bte,v2:sht):bte 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

pattern calc.>>(v1:bte,v2:bte):bte 
address CMDvarRSHsignal;
comment Return V1 >> V2, raise error on out of range second operand

command calc.>=(v:inet,w:inet):bit 
address INET_comp_GE;
comment Whether v is equal to or greater than w

command calc.>(v:inet,w:inet):bit 
address INET_comp_GT;
comment Whether v is greater than w

pattern calc.>=(v:timestamp,w:timestamp):bit 
address CMDvarGE;
comment Equality of two timestamps

pattern calc.>(v:timestamp,w:timestamp):bit 
address CMDvarGT;
comment Equality of two timestamps

pattern calc.>=(v:daytime,w:daytime):bit 
address CMDvarGE;
comment Equality of two daytimes

pattern calc.>(v:daytime,w:daytime):bit 
address CMDvarGT;
comment Equality of two daytimes

pattern calc.>=(v:date,w:date):bit 
address CMDvarGE;
comment Equality of two dates

pattern calc.>(v:date,w:date):bit 
address CMDvarGT;
comment Equality of two dates

pattern calc.>=(l:json,r:json):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>(l:json,r:json):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.>=(l:uuid,r:uuid):bit 
address CMDvarGE;
comment Return V1 >= V2

pattern calc.>(l:uuid,r:uuid):bit 
address CMDvarGT;
comment Return V1 > V2

pattern calc.and(v1:lng,v2:lng):lng 
address CMDvarAND;
comment Return V1 AND V2

pattern calc.and(v1:wrd,v2:wrd):wrd 
address CMDvarAND;
comment Return V1 AND V2

pattern calc.and(v1:int,v2:int):int 
address CMDvarAND;
comment Return V1 AND V2

pattern calc.and(v1:sht,v2:sht):sht 
address CMDvarAND;
comment Return V1 AND V2

pattern calc.and(v1:bte,v2:bte):bte 
address CMDvarAND;
comment Return V1 AND V2

pattern calc.and(v1:bit,v2:bit):bit 
address CMDvarAND;
comment Return V1 AND V2

pattern calc.add_noerror(v1:dbl,v2:dbl):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:dbl,v2:flt):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:dbl,v2:lng):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:dbl,v2:wrd):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:dbl,v2:int):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:dbl,v2:sht):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:dbl,v2:bte):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:flt,v2:dbl):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:flt,v2:flt):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:flt,v2:lng):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:flt,v2:wrd):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:flt,v2:int):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:flt,v2:sht):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:flt,v2:bte):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:lng,v2:dbl):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:lng,v2:flt):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:lng,v2:lng):lng 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:lng,v2:wrd):lng 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:lng,v2:int):lng 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:lng,v2:sht):lng 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:lng,v2:bte):lng 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:wrd,v2:dbl):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:wrd,v2:flt):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:wrd,v2:lng):lng 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:wrd,v2:wrd):wrd 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:wrd,v2:int):wrd 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:wrd,v2:sht):wrd 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:wrd,v2:bte):wrd 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:int,v2:dbl):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:int,v2:flt):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:int,v2:lng):lng 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:int,v2:wrd):wrd 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:int,v2:int):int 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:int,v2:sht):int 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:int,v2:bte):int 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:sht,v2:dbl):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:sht,v2:flt):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:sht,v2:lng):lng 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:sht,v2:wrd):wrd 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:sht,v2:int):int 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:sht,v2:sht):sht 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:sht,v2:bte):sht 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:bte,v2:dbl):dbl 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:bte,v2:flt):flt 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:bte,v2:lng):lng 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:bte,v2:wrd):wrd 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:bte,v2:int):int 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:bte,v2:sht):sht 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.add_noerror(v1:bte,v2:bte):bte 
address CMDvarADD;
comment Return V1 + V2, overflow causes NIL value

pattern calc.abs(v:dbl):dbl 
address CMDvarABS;
comment Unary absolute value of V

pattern calc.abs(v:flt):flt 
address CMDvarABS;
comment Unary absolute value of V

pattern calc.abs(v:lng):lng 
address CMDvarABS;
comment Unary absolute value of V

pattern calc.abs(v:wrd):wrd 
address CMDvarABS;
comment Unary absolute value of V

pattern calc.abs(v:int):int 
address CMDvarABS;
comment Unary absolute value of V

pattern calc.abs(v:sht):sht 
address CMDvarABS;
comment Unary absolute value of V

pattern calc.abs(v:bte):bte 
address CMDvarABS;
comment Unary absolute value of V

command calc.bte(s1:int,v:lng,d2:int,s2:int):bte 
address lng_dec2dec_bte;
comment cast decimal(lng) to decimal(bte) and check for overflow

command calc.bte(s1:int,v:lng):bte 
address lng_dec2_bte;
comment cast decimal(lng) to bte and check for overflow

command calc.bte(v:lng,digits:int,scale:int):bte 
address lng_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command calc.bte(s1:int,v:wrd,d2:int,s2:int):bte 
address wrd_dec2dec_bte;
comment cast decimal(wrd) to decimal(bte) and check for overflow

command calc.bte(s1:int,v:wrd):bte 
address wrd_dec2_bte;
comment cast decimal(wrd) to bte and check for overflow

command calc.bte(v:wrd,digits:int,scale:int):bte 
address wrd_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command calc.bte(s1:int,v:int,d2:int,s2:int):bte 
address int_dec2dec_bte;
comment cast decimal(int) to decimal(bte) and check for overflow

command calc.bte(s1:int,v:int):bte 
address int_dec2_bte;
comment cast decimal(int) to bte and check for overflow

command calc.bte(v:int,digits:int,scale:int):bte 
address int_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command calc.bte(s1:int,v:sht,d2:int,s2:int):bte 
address sht_dec2dec_bte;
comment cast decimal(sht) to decimal(bte) and check for overflow

command calc.bte(s1:int,v:sht):bte 
address sht_dec2_bte;
comment cast decimal(sht) to bte and check for overflow

command calc.bte(v:sht,digits:int,scale:int):bte 
address sht_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command calc.bte(s1:int,v:bte,d2:int,s2:int):bte 
address bte_dec2dec_bte;
comment cast decimal(bte) to decimal(bte) and check for overflow

command calc.bte(s1:int,v:bte):bte 
address bte_dec2_bte;
comment cast decimal(bte) to bte and check for overflow

command calc.bte(v:bte,digits:int,scale:int):bte 
address bte_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command calc.bte(v:dbl,digits:int,scale:int):bte 
address dbl_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command calc.bte(v:flt,digits:int,scale:int):bte 
address flt_num2dec_bte;
comment cast number to decimal(bte) and check for overflow

command calc.bte(v:str,digits:int,scale:int):bte 
address str_2dec_bte;
comment cast to dec(bte) and check for overflow

command calc.bte(v:str,digits:int):bte 
address str_2num_bte;
comment cast to bte and check for overflow

command calc.bte(v:void,digits:int,scale:int):bte 
address nil_2dec_bte;
comment cast to dec(bte) and check for overflow

command calc.bte(v:void,digits:int):bte 
address nil_2num_bte;
comment cast to bte and check for overflow

pattern calc.bte(v:str):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bte(v:oid):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bte(v:dbl):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bte(v:flt):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bte(v:lng):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bte(v:wrd):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bte(v:int):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bte(v:sht):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bte(v:bte):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bte(v:bit):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bte(v:void):bte 
address CMDvarCONVERT;
comment Cast VALUE to bte

pattern calc.bit(v:str):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.bit(v:oid):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.bit(v:dbl):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.bit(v:flt):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.bit(v:lng):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.bit(v:wrd):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.bit(v:int):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.bit(v:sht):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.bit(v:bte):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.bit(v:bit):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.bit(v:void):bit 
address CMDvarCONVERT;
comment Cast VALUE to bit

pattern calc.between_symmetric(b:any_1,v1:any_1,v2:any_1):bit 
address CMDvarBETWEENsymmetric;
comment B between V1 and V2 (or vice versa) inclusive

pattern calc.between(b:any_1,lo:any_1,hi:any_1):bit 
address CMDvarBETWEEN;
comment B between LO and HI inclusive

command calc.blob(s:str):blob 
address BLOBblob_fromstr;
command calc.blob(b:blob):blob 
address BLOBblob_blob;
pattern calc.cmp(v1:dbl,v2:dbl):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:dbl,v2:flt):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:dbl,v2:lng):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:dbl,v2:wrd):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:dbl,v2:int):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:dbl,v2:sht):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:dbl,v2:bte):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:flt,v2:dbl):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:flt,v2:flt):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:flt,v2:lng):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:flt,v2:wrd):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:flt,v2:int):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:flt,v2:sht):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:flt,v2:bte):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:lng,v2:dbl):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:lng,v2:flt):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:lng,v2:lng):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:lng,v2:wrd):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:lng,v2:int):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:lng,v2:sht):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:lng,v2:bte):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:wrd,v2:dbl):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:wrd,v2:flt):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:wrd,v2:lng):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:wrd,v2:wrd):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:wrd,v2:int):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:wrd,v2:sht):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:wrd,v2:bte):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:int,v2:dbl):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:int,v2:flt):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:int,v2:lng):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:int,v2:wrd):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:int,v2:int):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:int,v2:sht):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:int,v2:bte):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:sht,v2:dbl):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:sht,v2:flt):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:sht,v2:lng):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:sht,v2:wrd):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:sht,v2:int):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:sht,v2:sht):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:sht,v2:bte):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:bte,v2:dbl):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:bte,v2:flt):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:bte,v2:lng):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:bte,v2:wrd):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:bte,v2:int):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:bte,v2:sht):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:bte,v2:bte):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:oid,v2:oid):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:str,v2:str):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

pattern calc.cmp(v1:bit,v2:bit):bte 
address CMDvarCMP;
comment Return -1/0/1 if V1 </==/> V2

command calc.dbl(s1:int,v:lng,d2:int,s2:int):dbl 
address lng_dec2dec_dbl;
comment cast decimal(lng) to decimal(dbl) and check for overflow

command calc.dbl(s1:int,v:lng):dbl 
address lng_dec2_dbl;
comment cast decimal(lng) to dbl and check for overflow

command calc.dbl(v:lng,digits:int,scale:int):dbl 
address lng_num2dec_dbl;
comment cast number to decimal(dbl) and check for overflow

command calc.dbl(s1:int,v:wrd,d2:int,s2:int):dbl 
address wrd_dec2dec_dbl;
comment cast decimal(wrd) to decimal(dbl) and check for overflow

command calc.dbl(s1:int,v:wrd):dbl 
address wrd_dec2_dbl;
comment cast decimal(wrd) to dbl and check for overflow

command calc.dbl(v:wrd,digits:int,scale:int):dbl 
address wrd_num2dec_dbl;
comment cast number to decimal(dbl) and check for overflow

command calc.dbl(s1:int,v:int,d2:int,s2:int):dbl 
address int_dec2dec_dbl;
comment cast decimal(int) to decimal(dbl) and check for overflow

command calc.dbl(s1:int,v:int):dbl 
address int_dec2_dbl;
comment cast decimal(int) to dbl and check for overflow

command calc.dbl(v:int,digits:int,scale:int):dbl 
address int_num2dec_dbl;
comment cast number to decimal(dbl) and check for overflow

command calc.dbl(s1:int,v:sht,d2:int,s2:int):dbl 
address sht_dec2dec_dbl;
comment cast decimal(sht) to decimal(dbl) and check for overflow

command calc.dbl(s1:int,v:sht):dbl 
address sht_dec2_dbl;
comment cast decimal(sht) to dbl and check for overflow

command calc.dbl(v:sht,digits:int,scale:int):dbl 
address sht_num2dec_dbl;
comment cast number to decimal(dbl) and check for overflow

command calc.dbl(s1:int,v:bte,d2:int,s2:int):dbl 
address bte_dec2dec_dbl;
comment cast decimal(bte) to decimal(dbl) and check for overflow

command calc.dbl(s1:int,v:bte):dbl 
address bte_dec2_dbl;
comment cast decimal(bte) to dbl and check for overflow

command calc.dbl(v:bte,digits:int,scale:int):dbl 
address bte_num2dec_dbl;
comment cast number to decimal(dbl) and check for overflow

command calc.daytime(v:timestamp,d:int):daytime 
address timestamp_2_daytime;
comment cast timestamp to a daytime and check for overflow

command calc.daytime(v:lng,d:int):daytime 
address second_interval_2_daytime;
comment cast second_interval to a daytime and check for overflow

command calc.date(v:str):date 
address str_2_date;
comment cast to date

command calc.date(v:void):date 
address nil_2_date;
comment cast to date

command calc.daytime(v:daytime,digits:int):daytime 
address daytime_2time_daytime;
comment cast daytime to daytime and check for overflow

command calc.daytime(v:str,digits:int,has_tz:int):daytime 
address str_2time_daytimetz;
comment cast to daytime and check for overflow

command calc.daytime(v:str,digits:int):daytime 
address str_2time_daytime;
comment cast to daytime and check for overflow

command calc.daytime(v:str):daytime 
address str_2_daytime;
comment Cast to daytime

command calc.daytime(v:void,digits:int):daytime 
address nil_2time_daytime;
comment cast to daytime and check for overflow

command calc.daytime(v:void):daytime 
address nil_2_daytime;
comment Cast to daytime

pattern calc.dbl(v:str):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.dbl(v:oid):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.dbl(v:dbl):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.dbl(v:flt):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.dbl(v:lng):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.dbl(v:wrd):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.dbl(v:int):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.dbl(v:sht):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.dbl(v:bte):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.dbl(v:bit):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.dbl(v:void):dbl 
address CMDvarCONVERT;
comment Cast VALUE to dbl

pattern calc.div_noerror(v1:dbl,v2:dbl):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:dbl,v2:flt):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:dbl,v2:lng):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:dbl,v2:wrd):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:dbl,v2:int):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:dbl,v2:sht):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:dbl,v2:bte):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:flt,v2:dbl):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:flt,v2:flt):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:flt,v2:lng):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:flt,v2:wrd):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:flt,v2:int):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:flt,v2:sht):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:flt,v2:bte):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:lng,v2:dbl):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:lng,v2:flt):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:lng,v2:lng):lng 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:lng,v2:wrd):lng 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:lng,v2:int):lng 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:lng,v2:sht):lng 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:lng,v2:bte):lng 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:wrd,v2:dbl):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:wrd,v2:flt):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:wrd,v2:lng):wrd 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:wrd,v2:wrd):wrd 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:wrd,v2:int):wrd 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:wrd,v2:sht):wrd 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:wrd,v2:bte):wrd 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:int,v2:dbl):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:int,v2:flt):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:int,v2:lng):int 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:int,v2:wrd):int 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:int,v2:int):int 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:int,v2:sht):int 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:int,v2:bte):int 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:sht,v2:dbl):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:sht,v2:flt):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:sht,v2:lng):sht 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:sht,v2:wrd):sht 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:sht,v2:int):sht 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:sht,v2:sht):sht 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:sht,v2:bte):sht 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:bte,v2:dbl):dbl 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:bte,v2:flt):flt 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:bte,v2:lng):bte 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:bte,v2:wrd):bte 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:bte,v2:int):bte 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:bte,v2:sht):bte 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

pattern calc.div_noerror(v1:bte,v2:bte):bte 
address CMDvarDIV;
comment Return V1 / V2, overflow causes NIL value

command calc.daytime(t:timestamp):daytime 
address MTIMEtimestamp_extract_daytime_default;
command calc.daytime(s:lng):daytime 
address MTIMEsecs2daytime;
command calc.daytime(d:daytime):daytime 
address MTIMEdaytime2daytime;
command calc.daytime(s:str):daytime 
address MTIMEdaytime_fromstr;
command calc.date(t:timestamp):date 
address MTIMEtimestamp_extract_date_default;
command calc.date(d:date):date 
address MTIMEdate_date;
command calc.date(s:str):date 
address MTIMEdate_fromstr;
command calc.flt(s1:int,v:lng,d2:int,s2:int):flt 
address lng_dec2dec_flt;
comment cast decimal(lng) to decimal(flt) and check for overflow

command calc.flt(s1:int,v:lng):flt 
address lng_dec2_flt;
comment cast decimal(lng) to flt and check for overflow

command calc.flt(v:lng,digits:int,scale:int):flt 
address lng_num2dec_flt;
comment cast number to decimal(flt) and check for overflow

command calc.flt(s1:int,v:wrd,d2:int,s2:int):flt 
address wrd_dec2dec_flt;
comment cast decimal(wrd) to decimal(flt) and check for overflow

command calc.flt(s1:int,v:wrd):flt 
address wrd_dec2_flt;
comment cast decimal(wrd) to flt and check for overflow

command calc.flt(v:wrd,digits:int,scale:int):flt 
address wrd_num2dec_flt;
comment cast number to decimal(flt) and check for overflow

command calc.flt(s1:int,v:int,d2:int,s2:int):flt 
address int_dec2dec_flt;
comment cast decimal(int) to decimal(flt) and check for overflow

command calc.flt(s1:int,v:int):flt 
address int_dec2_flt;
comment cast decimal(int) to flt and check for overflow

command calc.flt(v:int,digits:int,scale:int):flt 
address int_num2dec_flt;
comment cast number to decimal(flt) and check for overflow

command calc.flt(s1:int,v:sht,d2:int,s2:int):flt 
address sht_dec2dec_flt;
comment cast decimal(sht) to decimal(flt) and check for overflow

command calc.flt(s1:int,v:sht):flt 
address sht_dec2_flt;
comment cast decimal(sht) to flt and check for overflow

command calc.flt(v:sht,digits:int,scale:int):flt 
address sht_num2dec_flt;
comment cast number to decimal(flt) and check for overflow

command calc.flt(s1:int,v:bte,d2:int,s2:int):flt 
address bte_dec2dec_flt;
comment cast decimal(bte) to decimal(flt) and check for overflow

command calc.flt(s1:int,v:bte):flt 
address bte_dec2_flt;
comment cast decimal(bte) to flt and check for overflow

command calc.flt(v:bte,digits:int,scale:int):flt 
address bte_num2dec_flt;
comment cast number to decimal(flt) and check for overflow

pattern calc.flt(v:str):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.flt(v:oid):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.flt(v:dbl):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.flt(v:flt):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.flt(v:lng):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.flt(v:wrd):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.flt(v:int):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.flt(v:sht):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.flt(v:bte):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.flt(v:bit):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.flt(v:void):flt 
address CMDvarCONVERT;
comment Cast VALUE to flt

pattern calc.hash(v:any):wrd 
address MKEYhash;
pattern calc.hash(v:dbl):wrd 
address MKEYhash;
pattern calc.hash(v:flt):wrd 
address MKEYhash;
pattern calc.hash(v:wrd):wrd 
address MKEYhash;
pattern calc.hash(v:oid):wrd 
address MKEYhash;
pattern calc.hash(v:lng):wrd 
address MKEYhash;
pattern calc.hash(v:int):wrd 
address MKEYhash;
pattern calc.hash(v:sht):wrd 
address MKEYhash;
pattern calc.hash(v:bte):wrd 
address MKEYhash;
command calc.int(s1:int,v:lng,d2:int,s2:int):int 
address lng_dec2dec_int;
comment cast decimal(lng) to decimal(int) and check for overflow

command calc.int(s1:int,v:lng):int 
address lng_dec2_int;
comment cast decimal(lng) to int and check for overflow

command calc.int(v:lng,digits:int,scale:int):int 
address lng_num2dec_int;
comment cast number to decimal(int) and check for overflow

command calc.int(s1:int,v:wrd,d2:int,s2:int):int 
address wrd_dec2dec_int;
comment cast decimal(wrd) to decimal(int) and check for overflow

command calc.int(s1:int,v:wrd):int 
address wrd_dec2_int;
comment cast decimal(wrd) to int and check for overflow

command calc.int(v:wrd,digits:int,scale:int):int 
address wrd_num2dec_int;
comment cast number to decimal(int) and check for overflow

command calc.int(s1:int,v:int,d2:int,s2:int):int 
address int_dec2dec_int;
comment cast decimal(int) to decimal(int) and check for overflow

command calc.int(s1:int,v:int):int 
address int_dec2_int;
comment cast decimal(int) to int and check for overflow

command calc.int(v:int,digits:int,scale:int):int 
address int_num2dec_int;
comment cast number to decimal(int) and check for overflow

command calc.int(s1:int,v:sht,d2:int,s2:int):int 
address sht_dec2dec_int;
comment cast decimal(sht) to decimal(int) and check for overflow

command calc.int(s1:int,v:sht):int 
address sht_dec2_int;
comment cast decimal(sht) to int and check for overflow

command calc.int(v:sht,digits:int,scale:int):int 
address sht_num2dec_int;
comment cast number to decimal(int) and check for overflow

command calc.int(s1:int,v:bte,d2:int,s2:int):int 
address bte_dec2dec_int;
comment cast decimal(bte) to decimal(int) and check for overflow

command calc.int(s1:int,v:bte):int 
address bte_dec2_int;
comment cast decimal(bte) to int and check for overflow

command calc.int(v:bte,digits:int,scale:int):int 
address bte_num2dec_int;
comment cast number to decimal(int) and check for overflow

command calc.int(v:dbl,digits:int,scale:int):int 
address dbl_num2dec_int;
comment cast number to decimal(int) and check for overflow

command calc.int(v:flt,digits:int,scale:int):int 
address flt_num2dec_int;
comment cast number to decimal(int) and check for overflow

command calc.index(v:str,u:bit):int 
address STRindex_int;
comment Return the offsets as an index bat

command calc.index(v:str,u:bit):sht 
address STRindex_sht;
comment Return the offsets as an index bat

command calc.index(v:str,u:bit):bte 
address STRindex_bte;
comment Return the offsets as an index bat

command calc.int(v:str,digits:int,scale:int):int 
address str_2dec_int;
comment cast to dec(int) and check for overflow

command calc.int(v:str,digits:int):int 
address str_2num_int;
comment cast to int and check for overflow

command calc.int(v:void,digits:int,scale:int):int 
address nil_2dec_int;
comment cast to dec(int) and check for overflow

command calc.int(v:void,digits:int):int 
address nil_2num_int;
comment cast to int and check for overflow

command calc.identity(X_1:any_2):oid 
address SQLidentity;
comment Returns a unique row identitfier.

pattern calc.ifthenelse(b:bit,t:any_1,f:any_1):any_1 
address CALCswitchbit;
comment If VALUE is true return MIDDLE else RIGHT

pattern calc.int(v:str):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.int(v:oid):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.int(v:dbl):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.int(v:flt):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.int(v:lng):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.int(v:wrd):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.int(v:int):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.int(v:sht):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.int(v:bte):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.int(v:bit):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.int(v:void):int 
address CMDvarCONVERT;
comment Cast VALUE to int

pattern calc.isnotnil(v:any):bit 
address CMDvarISNOTNIL;
comment Unary check for notnil of V

pattern calc.isnil(v:any):bit 
address CMDvarISNIL;
comment Unary check for nil of V

pattern calc.iszero(v:dbl):bit 
address CMDvarISZERO;
comment Unary check for zero of V

pattern calc.iszero(v:flt):bit 
address CMDvarISZERO;
comment Unary check for zero of V

pattern calc.iszero(v:lng):bit 
address CMDvarISZERO;
comment Unary check for zero of V

pattern calc.iszero(v:wrd):bit 
address CMDvarISZERO;
comment Unary check for zero of V

pattern calc.iszero(v:int):bit 
address CMDvarISZERO;
comment Unary check for zero of V

pattern calc.iszero(v:sht):bit 
address CMDvarISZERO;
comment Unary check for zero of V

pattern calc.iszero(v:bte):bit 
address CMDvarISZERO;
comment Unary check for zero of V

command calc.inet(s:str):inet 
address INET_fromstr;
comment Convert a string to an inet

command calc.inet(s:inet):inet 
address INET_inet;
comment Convert a inet to an inet

command calc.json(j:json):json 
address JSONstr2json;
comment Convert JSON to JSON. Dealing with escape characters

command calc.json(j:str):json 
address JSONstr2json;
comment Convert string to its JSON. Dealing with escape characters

command calc.lng(s1:int,v:lng,d2:int,s2:int):lng 
address lng_dec2dec_lng;
comment cast decimal(lng) to decimal(lng) and check for overflow

command calc.lng(s1:int,v:lng):lng 
address lng_dec2_lng;
comment cast decimal(lng) to lng and check for overflow

command calc.lng(v:lng,digits:int,scale:int):lng 
address lng_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command calc.lng(s1:int,v:wrd,d2:int,s2:int):lng 
address wrd_dec2dec_lng;
comment cast decimal(wrd) to decimal(lng) and check for overflow

command calc.lng(s1:int,v:wrd):lng 
address wrd_dec2_lng;
comment cast decimal(wrd) to lng and check for overflow

command calc.lng(v:wrd,digits:int,scale:int):lng 
address wrd_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command calc.lng(s1:int,v:int,d2:int,s2:int):lng 
address int_dec2dec_lng;
comment cast decimal(int) to decimal(lng) and check for overflow

command calc.lng(s1:int,v:int):lng 
address int_dec2_lng;
comment cast decimal(int) to lng and check for overflow

command calc.lng(v:int,digits:int,scale:int):lng 
address int_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command calc.lng(s1:int,v:sht,d2:int,s2:int):lng 
address sht_dec2dec_lng;
comment cast decimal(sht) to decimal(lng) and check for overflow

command calc.lng(s1:int,v:sht):lng 
address sht_dec2_lng;
comment cast decimal(sht) to lng and check for overflow

command calc.lng(v:sht,digits:int,scale:int):lng 
address sht_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command calc.lng(s1:int,v:bte,d2:int,s2:int):lng 
address bte_dec2dec_lng;
comment cast decimal(bte) to decimal(lng) and check for overflow

command calc.lng(s1:int,v:bte):lng 
address bte_dec2_lng;
comment cast decimal(bte) to lng and check for overflow

command calc.lng(v:bte,digits:int,scale:int):lng 
address bte_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command calc.lng(v:dbl,digits:int,scale:int):lng 
address dbl_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command calc.lng(v:flt,digits:int,scale:int):lng 
address flt_num2dec_lng;
comment cast number to decimal(lng) and check for overflow

command calc.lng(v:str,digits:int,scale:int):lng 
address str_2dec_lng;
comment cast to dec(lng) and check for overflow

command calc.lng(v:str,digits:int):lng 
address str_2num_lng;
comment cast to lng and check for overflow

command calc.lng(v:void,digits:int,scale:int):lng 
address nil_2dec_lng;
comment cast to dec(lng) and check for overflow

command calc.lng(v:void,digits:int):lng 
address nil_2num_lng;
comment cast to lng and check for overflow

command calc.length(s:str):int 
address CMDstrlength;
comment Length of STRING

pattern calc.lng(v:str):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lng(v:oid):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lng(v:dbl):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lng(v:flt):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lng(v:lng):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lng(v:wrd):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lng(v:int):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lng(v:sht):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lng(v:bte):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lng(v:bit):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lng(v:void):lng 
address CMDvarCONVERT;
comment Cast VALUE to lng

pattern calc.lsh_noerror(v1:lng,v2:lng):lng 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:lng,v2:wrd):lng 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:lng,v2:int):lng 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:lng,v2:sht):lng 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:lng,v2:bte):lng 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:wrd,v2:lng):wrd 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:wrd,v2:wrd):wrd 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:wrd,v2:int):wrd 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:wrd,v2:sht):wrd 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:wrd,v2:bte):wrd 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:int,v2:lng):int 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:int,v2:wrd):int 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:int,v2:int):int 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:int,v2:sht):int 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:int,v2:bte):int 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:sht,v2:lng):sht 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:sht,v2:wrd):sht 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:sht,v2:int):sht 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:sht,v2:sht):sht 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:sht,v2:bte):sht 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:bte,v2:lng):bte 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:bte,v2:wrd):bte 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:bte,v2:int):bte 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:bte,v2:sht):bte 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.lsh_noerror(v1:bte,v2:bte):bte 
address CMDvarLSH;
comment Return V1 << V2, out of range second operand causes NIL value

pattern calc.month_interval(v:lng,ek:int,sk:int):int 
address month_interval;
comment cast lng to a month_interval and check for overflow

pattern calc.month_interval(v:wrd,ek:int,sk:int):int 
address month_interval;
comment cast wrd to a month_interval and check for overflow

pattern calc.month_interval(v:int,ek:int,sk:int):int 
address month_interval;
comment cast int to a month_interval and check for overflow

pattern calc.month_interval(v:sht,ek:int,sk:int):int 
address month_interval;
comment cast sht to a month_interval and check for overflow

pattern calc.month_interval(v:bte,ek:int,sk:int):int 
address month_interval;
comment cast bte to a month_interval and check for overflow

command calc.month_interval(v:str,ek:int,sk:int):int 
address month_interval_str;
comment cast str to a month_interval and check for overflow

command calc.mbr(v:mbr):mbr 
address mbrFromMBR;
command calc.mbr(v:str):mbr 
address mbrFromString;
pattern calc.max_no_nil(v1:any_1,v2:any_1):any_1 
address CALCmax_no_nil;
comment Return max of V1 and V2, ignoring nil values

pattern calc.max(v1:any_1,v2:any_1):any_1 
address CALCmax;
comment Return max of V1 and V2

pattern calc.min_no_nil(v1:any_1,v2:any_1):any_1 
address CALCmin_no_nil;
comment Return min of V1 and V2, ignoring nil values

pattern calc.min(v1:any_1,v2:any_1):any_1 
address CALCmin;
comment Return min of V1 and V2

pattern calc.mod_noerror(v1:dbl,v2:dbl):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:dbl,v2:flt):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:dbl,v2:lng):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:dbl,v2:wrd):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:dbl,v2:int):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:dbl,v2:sht):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:dbl,v2:bte):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:flt,v2:dbl):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:flt,v2:flt):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:flt,v2:lng):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:flt,v2:wrd):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:flt,v2:int):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:flt,v2:sht):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:flt,v2:bte):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:lng,v2:dbl):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:lng,v2:flt):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:lng,v2:lng):lng 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:lng,v2:wrd):wrd 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:lng,v2:int):int 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:lng,v2:sht):sht 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:lng,v2:bte):bte 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:wrd,v2:dbl):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:wrd,v2:flt):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:wrd,v2:lng):wrd 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:wrd,v2:wrd):wrd 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:wrd,v2:int):int 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:wrd,v2:sht):sht 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:wrd,v2:bte):bte 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:int,v2:dbl):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:int,v2:flt):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:int,v2:lng):int 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:int,v2:wrd):int 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:int,v2:int):int 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:int,v2:sht):sht 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:int,v2:bte):bte 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:sht,v2:dbl):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:sht,v2:flt):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:sht,v2:lng):sht 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:sht,v2:wrd):sht 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:sht,v2:int):sht 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:sht,v2:sht):sht 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:sht,v2:bte):bte 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:bte,v2:dbl):dbl 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:bte,v2:flt):flt 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:bte,v2:lng):bte 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:bte,v2:wrd):bte 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:bte,v2:int):bte 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:bte,v2:sht):bte 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mod_noerror(v1:bte,v2:bte):bte 
address CMDvarMOD;
comment Return V1 % V2, divide by zero causes NIL value

pattern calc.mul_noerror(v1:dbl,v2:dbl):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:dbl,v2:flt):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:dbl,v2:lng):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:dbl,v2:wrd):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:dbl,v2:int):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:dbl,v2:sht):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:dbl,v2:bte):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:flt,v2:dbl):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:flt,v2:flt):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:flt,v2:lng):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:flt,v2:wrd):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:flt,v2:int):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:flt,v2:sht):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:flt,v2:bte):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:lng,v2:dbl):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:lng,v2:flt):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:lng,v2:lng):lng 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:lng,v2:wrd):lng 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:lng,v2:int):lng 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:lng,v2:sht):lng 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:lng,v2:bte):lng 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:wrd,v2:dbl):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:wrd,v2:flt):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:wrd,v2:lng):lng 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:wrd,v2:wrd):wrd 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:wrd,v2:int):wrd 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:wrd,v2:sht):wrd 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:wrd,v2:bte):wrd 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:int,v2:dbl):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:int,v2:flt):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:int,v2:lng):lng 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:int,v2:wrd):wrd 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:int,v2:int):int 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:int,v2:sht):int 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:int,v2:bte):int 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:sht,v2:dbl):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:sht,v2:flt):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:sht,v2:lng):lng 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:sht,v2:wrd):wrd 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:sht,v2:int):int 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:sht,v2:sht):sht 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:sht,v2:bte):sht 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:bte,v2:dbl):dbl 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:bte,v2:flt):flt 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:bte,v2:lng):lng 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:bte,v2:wrd):wrd 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:bte,v2:int):int 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:bte,v2:sht):sht 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.mul_noerror(v1:bte,v2:bte):bte 
address CMDvarMUL;
comment Return V1 * V2, overflow causes NIL value

pattern calc.not(v:lng):lng 
address CMDvarNOT;
comment Unary bitwise not of V

pattern calc.not(v:wrd):wrd 
address CMDvarNOT;
comment Unary bitwise not of V

pattern calc.not(v:int):int 
address CMDvarNOT;
comment Unary bitwise not of V

pattern calc.not(v:sht):sht 
address CMDvarNOT;
comment Unary bitwise not of V

pattern calc.not(v:bte):bte 
address CMDvarNOT;
comment Unary bitwise not of V

pattern calc.not(v:bit):bit 
address CMDvarNOT;
comment Return the Boolean inverse

pattern calc.oid(v:str):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.oid(v:oid):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.oid(v:dbl):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.oid(v:flt):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.oid(v:lng):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.oid(v:wrd):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.oid(v:int):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.oid(v:sht):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.oid(v:bte):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.oid(v:bit):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.oid(v:void):oid 
address CMDvarCONVERT;
comment Cast VALUE to oid

pattern calc.or(v1:lng,v2:lng):lng 
address CMDvarOR;
comment Return V1 OR V2

pattern calc.or(v1:wrd,v2:wrd):wrd 
address CMDvarOR;
comment Return V1 OR V2

pattern calc.or(v1:int,v2:int):int 
address CMDvarOR;
comment Return V1 OR V2

pattern calc.or(v1:sht,v2:sht):sht 
address CMDvarOR;
comment Return V1 OR V2

pattern calc.or(v1:bte,v2:bte):bte 
address CMDvarOR;
comment Return V1 OR V2

pattern calc.or(v1:bit,v2:bit):bit 
address CMDvarOR;
comment Return V1 OR V2

command calc.ptr(v:ptr):ptr 
address CMDvarCONVERTptr;
comment Cast VALUE to ptr

pattern calc.rowid(v:any_1,schema:str,table:str):oid 
address sql_rowid;
comment return the next rowid

pattern calc.rotate_xor_hash(h:wrd,nbits:int,v:any_1):wrd 
address MKEYrotate_xor_hash;
pattern calc.rsh_noerror(v1:lng,v2:lng):lng 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:lng,v2:wrd):lng 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:lng,v2:int):lng 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:lng,v2:sht):lng 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:lng,v2:bte):lng 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:wrd,v2:lng):wrd 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:wrd,v2:wrd):wrd 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:wrd,v2:int):wrd 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:wrd,v2:sht):wrd 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:wrd,v2:bte):wrd 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:int,v2:lng):int 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:int,v2:wrd):int 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:int,v2:int):int 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:int,v2:sht):int 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:int,v2:bte):int 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:sht,v2:lng):sht 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:sht,v2:wrd):sht 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:sht,v2:int):sht 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:sht,v2:sht):sht 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:sht,v2:bte):sht 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:bte,v2:lng):bte 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:bte,v2:wrd):bte 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:bte,v2:int):bte 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:bte,v2:sht):bte 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

pattern calc.rsh_noerror(v1:bte,v2:bte):bte 
address CMDvarRSH;
comment Return V1 >> V2, out of range second operand causes NIL value

command calc.sht(s1:int,v:lng,d2:int,s2:int):sht 
address lng_dec2dec_sht;
comment cast decimal(lng) to decimal(sht) and check for overflow

command calc.sht(s1:int,v:lng):sht 
address lng_dec2_sht;
comment cast decimal(lng) to sht and check for overflow

command calc.sht(v:lng,digits:int,scale:int):sht 
address lng_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command calc.sht(s1:int,v:wrd,d2:int,s2:int):sht 
address wrd_dec2dec_sht;
comment cast decimal(wrd) to decimal(sht) and check for overflow

command calc.sht(s1:int,v:wrd):sht 
address wrd_dec2_sht;
comment cast decimal(wrd) to sht and check for overflow

command calc.sht(v:wrd,digits:int,scale:int):sht 
address wrd_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command calc.sht(s1:int,v:int,d2:int,s2:int):sht 
address int_dec2dec_sht;
comment cast decimal(int) to decimal(sht) and check for overflow

command calc.sht(s1:int,v:int):sht 
address int_dec2_sht;
comment cast decimal(int) to sht and check for overflow

command calc.sht(v:int,digits:int,scale:int):sht 
address int_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command calc.sht(s1:int,v:sht,d2:int,s2:int):sht 
address sht_dec2dec_sht;
comment cast decimal(sht) to decimal(sht) and check for overflow

command calc.sht(s1:int,v:sht):sht 
address sht_dec2_sht;
comment cast decimal(sht) to sht and check for overflow

command calc.sht(v:sht,digits:int,scale:int):sht 
address sht_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command calc.sht(s1:int,v:bte,d2:int,s2:int):sht 
address bte_dec2dec_sht;
comment cast decimal(bte) to decimal(sht) and check for overflow

command calc.sht(s1:int,v:bte):sht 
address bte_dec2_sht;
comment cast decimal(bte) to sht and check for overflow

command calc.sht(v:bte,digits:int,scale:int):sht 
address bte_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command calc.sht(v:dbl,digits:int,scale:int):sht 
address dbl_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command calc.sht(v:flt,digits:int,scale:int):sht 
address flt_num2dec_sht;
comment cast number to decimal(sht) and check for overflow

command calc.strings(v:str):str 
address STRstrings;
comment Return the strings

command calc.second_interval(v:daytime,ek:int,sk:int):lng 
address second_interval_daytime;
comment cast daytime to a second_interval and check for overflow

pattern calc.second_interval(v:lng,ek:int,sk:int):lng 
address second_interval;
comment cast lng to a second_interval and check for overflow

pattern calc.second_interval(v:wrd,ek:int,sk:int):lng 
address second_interval;
comment cast wrd to a second_interval and check for overflow

pattern calc.second_interval(v:int,ek:int,sk:int):lng 
address second_interval;
comment cast int to a second_interval and check for overflow

pattern calc.second_interval(v:sht,ek:int,sk:int):lng 
address second_interval;
comment cast sht to a second_interval and check for overflow

pattern calc.second_interval(v:bte,ek:int,sk:int):lng 
address second_interval;
comment cast bte to a second_interval and check for overflow

command calc.second_interval(v:str,ek:int,sk:int):lng 
address second_interval_str;
comment cast str to a second_interval and check for overflow

command calc.substring(s:str,offset:int,count:int):str 
address STRsubstring;
command calc.substring(s:str,offset:int):str 
address STRsubstringTail;
pattern calc.str(eclass:int,d1:int,s1:int,has_tz:int,v:any_1,digits:int):str 
address SQLstr_cast;
comment cast to string and check for overflow

command calc.str(v:sqlblob):str 
address SQLsqlblob_2_str;
comment cast sqlblob to str

command calc.sqlblob(v:str):sqlblob 
address str_2_sqlblob;
comment cast to sqlblob

command calc.str(v:date):str 
address SQLdate_2_str;
comment cast date to str

command calc.sht(v:str,digits:int,scale:int):sht 
address str_2dec_sht;
comment cast to dec(sht) and check for overflow

command calc.sht(v:str,digits:int):sht 
address str_2num_sht;
comment cast to sht and check for overflow

command calc.sht(v:void,digits:int,scale:int):sht 
address nil_2dec_sht;
comment cast to dec(sht) and check for overflow

command calc.sht(v:void,digits:int):sht 
address nil_2num_sht;
comment cast to sht and check for overflow

command calc.second_interval(sc:int,v:lng,ek:int,sk:int):lng 
address lng_dec2second_interval;
comment cast lng decimal to a second_interval

command calc.second_interval(sc:int,v:wrd,ek:int,sk:int):lng 
address wrd_dec2second_interval;
comment cast wrd decimal to a second_interval

command calc.second_interval(sc:int,v:int,ek:int,sk:int):lng 
address int_dec2second_interval;
comment cast int decimal to a second_interval

command calc.second_interval(sc:int,v:sht,ek:int,sk:int):lng 
address sht_dec2second_interval;
comment cast sht decimal to a second_interval

command calc.second_interval(sc:int,v:bte,ek:int,sk:int):lng 
address bte_dec2second_interval;
comment cast bte decimal to a second_interval

pattern calc.setoid(v:lng):void 
address CMDsetoid;
pattern calc.setoid(v:oid):void 
address CMDsetoid;
pattern calc.setoid(v:int):void 
address CMDsetoid;
pattern calc.str(v:str):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.str(v:oid):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.str(v:dbl):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.str(v:flt):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.str(v:lng):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.str(v:wrd):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.str(v:int):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.str(v:sht):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.str(v:bte):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.str(v:bit):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.str(v:void):str 
address CMDvarCONVERT;
comment Cast VALUE to str

pattern calc.sht(v:str):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sht(v:oid):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sht(v:dbl):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sht(v:flt):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sht(v:lng):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sht(v:wrd):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sht(v:int):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sht(v:sht):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sht(v:bte):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sht(v:bit):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sht(v:void):sht 
address CMDvarCONVERT;
comment Cast VALUE to sht

pattern calc.sub_noerror(v1:dbl,v2:dbl):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:dbl,v2:flt):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:dbl,v2:lng):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:dbl,v2:wrd):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:dbl,v2:int):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:dbl,v2:sht):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:dbl,v2:bte):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:flt,v2:dbl):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:flt,v2:flt):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:flt,v2:lng):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:flt,v2:wrd):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:flt,v2:int):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:flt,v2:sht):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:flt,v2:bte):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:lng,v2:dbl):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:lng,v2:flt):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:lng,v2:lng):lng 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:lng,v2:wrd):lng 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:lng,v2:int):lng 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:lng,v2:sht):lng 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:lng,v2:bte):lng 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:wrd,v2:dbl):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:wrd,v2:flt):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:wrd,v2:lng):lng 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:wrd,v2:wrd):wrd 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:wrd,v2:int):wrd 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:wrd,v2:sht):wrd 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:wrd,v2:bte):wrd 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:int,v2:dbl):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:int,v2:flt):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:int,v2:lng):lng 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:int,v2:wrd):wrd 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:int,v2:int):int 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:int,v2:sht):int 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:int,v2:bte):int 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:sht,v2:dbl):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:sht,v2:flt):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:sht,v2:lng):lng 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:sht,v2:wrd):wrd 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:sht,v2:int):int 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:sht,v2:sht):sht 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:sht,v2:bte):sht 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:bte,v2:dbl):dbl 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:bte,v2:flt):flt 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:bte,v2:lng):lng 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:bte,v2:wrd):wrd 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:bte,v2:int):int 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:bte,v2:sht):sht 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sub_noerror(v1:bte,v2:bte):bte 
address CMDvarSUB;
comment Return V1 - V2, overflow causes NIL value

pattern calc.sign(v:dbl):bte 
address CMDvarSIGN;
comment Unary sign (-1,0,1) of V

pattern calc.sign(v:flt):bte 
address CMDvarSIGN;
comment Unary sign (-1,0,1) of V

pattern calc.sign(v:lng):bte 
address CMDvarSIGN;
comment Unary sign (-1,0,1) of V

pattern calc.sign(v:wrd):bte 
address CMDvarSIGN;
comment Unary sign (-1,0,1) of V

pattern calc.sign(v:int):bte 
address CMDvarSIGN;
comment Unary sign (-1,0,1) of V

pattern calc.sign(v:sht):bte 
address CMDvarSIGN;
comment Unary sign (-1,0,1) of V

pattern calc.sign(v:bte):bte 
address CMDvarSIGN;
comment Unary sign (-1,0,1) of V

command calc.str(s:uuid):str 
address UUIDuuid2str;
comment Coerce a uuid to a string type

command calc.sqlblob(s:str):sqlblob 
address BLOBsqlblob_fromstr;
command calc.sqlblob(b:sqlblob):sqlblob 
address BLOBblob_blob;
command calc.timestamp(v:date,d:int):timestamp 
address date_2_timestamp;
comment cast date to a timestamp and check for overflow

command calc.timestamp(v:timestamp,digits:int):timestamp 
address timestamp_2time_timestamp;
comment cast timestamp to timestamp and check for overflow

command calc.timestamp(v:str,digits:int,has_tz:int):timestamp 
address str_2time_timestamptz;
comment cast to timestamp and check for overflow

command calc.timestamp(v:str,digits:int):timestamp 
address str_2time_timestamp;
comment cast to timestamp and check for overflow

command calc.timestamp(v:str):timestamp 
address str_2_timestamp;
comment Cast to timestamp

command calc.timestamp(v:void,digits:int):timestamp 
address nil_2time_timestamp;
comment cast to timestamp and check for overflow

command calc.timestamp(v:void):timestamp 
address nil_2_timestamp;
comment Cast to timestamp

command calc.timestamp(msecs:lng):timestamp 
address MTIMEtimestamp_lng;
command calc.timestamp(secs:int):timestamp 
address MTIMEtimestamp;
command calc.timestamp(d:date):timestamp 
address MTIMEtimestamp_create_from_date;
command calc.timestamp(t:timestamp):timestamp 
address MTIMEtimestamp2timestamp;
command calc.timestamp(s:str):timestamp 
address MTIMEtimestamp_fromstr;
function calc.uuid(u:uuid):uuid;
command calc.uuid(s:str):uuid 
address UUIDstr2uuid;
comment Coerce a string to a uuid, validating its format

command calc.url(s:url):url 
address URLnoop;
comment Create an URL from a string literal

command calc.url(s:str):url 
address URLnew;
comment Create an URL from a string literal

pattern calc.void(v:str):void 
address CMDvarCONVERT;
comment Cast VALUE to void

pattern calc.void(v:oid):void 
address CMDvarCONVERT;
comment Cast VALUE to void

pattern calc.void(v:dbl):void 
address CMDvarCONVERT;
comment Cast VALUE to void

pattern calc.void(v:flt):void 
address CMDvarCONVERT;
comment Cast VALUE to void

pattern calc.void(v:lng):void 
address CMDvarCONVERT;
comment Cast VALUE to void

pattern calc.void(v:wrd):void 
address CMDvarCONVERT;
comment Cast VALUE to void

pattern calc.void(v:int):void 
address CMDvarCONVERT;
comment Cast VALUE to void

pattern calc.void(v:sht):void 
address CMDvarCONVERT;
comment Cast VALUE to void

pattern calc.void(v:bte):void 
address CMDvarCONVERT;
comment Cast VALUE to void

pattern calc.void(v:bit):void 
address CMDvarCONVERT;
comment Cast VALUE to void

pattern calc.void(v:void):void 
address CMDvarCONVERT;
comment Cast VALUE to void

command calc.wrd(s1:int,v:lng,d2:int,s2:int):wrd 
address lng_dec2dec_wrd;
comment cast decimal(lng) to decimal(wrd) and check for overflow

command calc.wrd(s1:int,v:lng):wrd 
address lng_dec2_wrd;
comment cast decimal(lng) to wrd and check for overflow

command calc.wrd(v:lng,digits:int,scale:int):wrd 
address lng_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command calc.wrd(s1:int,v:wrd,d2:int,s2:int):wrd 
address wrd_dec2dec_wrd;
comment cast decimal(wrd) to decimal(wrd) and check for overflow

command calc.wrd(s1:int,v:wrd):wrd 
address wrd_dec2_wrd;
comment cast decimal(wrd) to wrd and check for overflow

command calc.wrd(v:wrd,digits:int,scale:int):wrd 
address wrd_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command calc.wrd(s1:int,v:int,d2:int,s2:int):wrd 
address int_dec2dec_wrd;
comment cast decimal(int) to decimal(wrd) and check for overflow

command calc.wrd(s1:int,v:int):wrd 
address int_dec2_wrd;
comment cast decimal(int) to wrd and check for overflow

command calc.wrd(v:int,digits:int,scale:int):wrd 
address int_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command calc.wrd(s1:int,v:sht,d2:int,s2:int):wrd 
address sht_dec2dec_wrd;
comment cast decimal(sht) to decimal(wrd) and check for overflow

command calc.wrd(s1:int,v:sht):wrd 
address sht_dec2_wrd;
comment cast decimal(sht) to wrd and check for overflow

command calc.wrd(v:sht,digits:int,scale:int):wrd 
address sht_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command calc.wrd(s1:int,v:bte,d2:int,s2:int):wrd 
address bte_dec2dec_wrd;
comment cast decimal(bte) to decimal(wrd) and check for overflow

command calc.wrd(s1:int,v:bte):wrd 
address bte_dec2_wrd;
comment cast decimal(bte) to wrd and check for overflow

command calc.wrd(v:bte,digits:int,scale:int):wrd 
address bte_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command calc.wrd(v:dbl,digits:int,scale:int):wrd 
address dbl_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command calc.wrd(v:flt,digits:int,scale:int):wrd 
address flt_num2dec_wrd;
comment cast number to decimal(wrd) and check for overflow

command calc.wrd(v:str,digits:int,scale:int):wrd 
address str_2dec_wrd;
comment cast to dec(wrd) and check for overflow

command calc.wrd(v:str,digits:int):wrd 
address str_2num_wrd;
comment cast to wrd and check for overflow

command calc.wrd(v:void,digits:int,scale:int):wrd 
address nil_2dec_wrd;
comment cast to dec(wrd) and check for overflow

command calc.wrd(v:void,digits:int):wrd 
address nil_2num_wrd;
comment cast to wrd and check for overflow

function calc.wkb(wkt:str,srid:int,type:int):wkb;
command calc.wkb(geo:wkb,columnType:int,columnSRID:int):wkb 
address geom_2_geom;
comment Called when inserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition

command calc.wkb(v:wkb):wkb 
address wkbFromWKB;
comment It is called when adding a new geometry column to an existing table

pattern calc.wrd(v:str):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.wrd(v:oid):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.wrd(v:dbl):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.wrd(v:flt):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.wrd(v:lng):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.wrd(v:wrd):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.wrd(v:int):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.wrd(v:sht):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.wrd(v:bte):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.wrd(v:bit):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.wrd(v:void):wrd 
address CMDvarCONVERT;
comment Cast VALUE to wrd

pattern calc.xor(v1:lng,v2:lng):lng 
address CMDvarXOR;
comment Return V1 XOR V2

pattern calc.xor(v1:wrd,v2:wrd):wrd 
address CMDvarXOR;
comment Return V1 XOR V2

pattern calc.xor(v1:int,v2:int):int 
address CMDvarXOR;
comment Return V1 XOR V2

pattern calc.xor(v1:sht,v2:sht):sht 
address CMDvarXOR;
comment Return V1 XOR V2

pattern calc.xor(v1:bte,v2:bte):bte 
address CMDvarXOR;
comment Return V1 XOR V2

pattern calc.xor(v1:bit,v2:bit):bit 
address CMDvarXOR;
comment Return V1 XOR V2

command calc.xml(src:xml):xml 
address XMLxml2xml;
command calc.xml(src:str):xml 
address XMLstr2xml;
pattern clients.addUser(nme:str,pw:str):oid 
address CLTaddUser;
comment Allow user with password access to the given scenarios

command clients.backendsum(pw:str):str 
address CLTbackendsum;
comment Return hex string representation of the currently used hash of the given string

pattern clients.checkPermission(usr:str,pw:str):void 
address CLTcheckPermission;
comment Check permission for a user, requires hashed password (backendsum)

pattern clients.changePassword(old:str,new:str):void 
address CLTchangePassword;
comment Change the password for the current user

pattern clients.changeUsername(old:str,new:str):void 
address CLTchangeUsername;
comment Change the username of the user into the new string

pattern clients.getUsers() (X_1:bat[:oid],X_2:bat[:str]) 
address CLTgetUsers;
comment return a BAT with user id and one with name available in the system

pattern clients.getPasswordHash(user:str):str 
address CLTgetPasswordHash;
comment Return the password hash of the given user

pattern clients.getUsername():str 
address CLTgetUsername;
comment Return the username of the currently logged in user

pattern clients.getTimeout() (q:lng,s:lng) 
address CLTgetTimeout;
comment A query is aborted after q milliseconds (q=0 means run undisturbed).The session timeout aborts the connection after spending toomany seconds on query processing.

command clients.getUsers():bat[:str] 
address CLTusers;
comment Pseudo bat of users id and name.

command clients.getTime():bat[:lng] 
address CLTTime;
comment Pseudo bat of client's total time usage(in usec).

command clients.getActions():bat[:int] 
address CLTActions;
comment Pseudo bat of client's command counts.

command clients.getLastCommand():bat[:str] 
address CLTLastCommand;
comment Pseudo bat of client's last command time.

command clients.getLogins() (user:bat[:oid],start:bat[:str]) 
address CLTLogin;
comment Pseudo bat of client id and login time.

pattern clients.getScenario():str 
address CLTgetScenario;
comment Retrieve current scenario name.

pattern clients.getInfo() (X_1:bat[:str],X_2:bat[:str]) 
address CLTInfo;
comment Pseudo bat with client attributes.

pattern clients.getId():int 
address CLTgetClientId;
comment Return a number that uniquely represents the current client.

command clients.md5sum(pw:str):str 
address CLTmd5sum;
comment Return hex string representation of the MD5 hash of the given string

pattern clients.quit(idx:int):void 
address CLTquit;
comment Terminate the session for a single client using a soft error.It is the privilige of the console user.

pattern clients.quit():void 
address CLTquit;
comment Terminate the client session.

pattern clients.removeUser(nme:str):void 
address CLTremoveUser;
comment Remove the given user from the system

command clients.ripemd160sum(pw:str):str 
address CLTripemd160sum;
comment Return hex string representation of the RIPEMD160 hash of the given string

pattern clients.setPassword(user:str,pass:str):void 
address CLTsetPassword;
comment Set the password for the given user

command clients.sha2sum(pw:str,bits:int):str 
address CLTsha2sum;
comment Return hex string representation of the SHA-2 hash with bits of the given string

command clients.sha1sum(pw:str):str 
address CLTsha1sum;
comment Return hex string representation of the SHA-1 hash of the given string

pattern clients.shutdown(delay:int,forced:bit):str 
address CLTshutdown;
comment Close all other client connections. Return if it succeeds.If forced is set then always stop the system the hard way

pattern clients.shutdown(delay:int):str 
address CLTshutdown;
pattern clients.setTimeout(q:lng,s:lng):void 
address CLTsetTimeout;
comment Abort a query after q seconds (q=0 means run undisturbed).The session timeout aborts the connection after spending toomany seconds on query processing.

pattern clients.settimeout(n:lng):void 
address CLTsetTimeout;
comment Abort a query after  n seconds.

pattern clients.setsession(n:lng):void 
address CLTsetSessionTimeout;
comment Abort a session after  n seconds.

pattern clients.suspend(id:int):void 
address CLTsuspend;
comment Put a client process to sleep for some time.It will simple sleep for a second at a time, untilthe awake bit has been set in its descriptor

pattern clients.stop(id:int):void 
address CLTstop;
comment Stop the query execution at the next eligble statement.

pattern clients.setScenario(msg:str):str 
address CLTsetScenario;
comment Switch to other scenario handler, return previous one.

pattern clients.setHistory(s:str):void 
address CLTsetHistory;
comment Designate console history file for readline.

pattern clients.setListing(flag:int):int 
address CLTsetListing;
comment Turn on/off echo of MAL instructions:	1 - echo input,	2 - show mal instruction,	4 - show details of type resolutoin, 	8 - show binding information.

command clients.wakeup(id:int):void 
address CLTwakeup;
comment Wakeup a client process

command color.blue(c:color):int 
address CLRblue;
comment Extracts blue component from a color atom

command color.cb(c:color):int 
address CLRcb;
comment Extracts Cb(blue color) component from a color atom

command color.cr(c:color):int 
address CLRcr;
comment Extracts Cr(red color) component from a color atom

command color.color(s:str):color 
address CLRcolor;
comment Converts string to color

command color.#fromstr():void 
address color_fromstr;
command color.green(c:color):int 
address CLRgreen;
comment Extracts green component from a color atom

command color.hue(c:color):flt 
address CLRhue;
comment Extracts hue component from a color atom

command color.hsv(h:flt,s:flt,v:flt):color 
address CLRhsv;
comment Converts an HSV triplets to a color atom

command color.hue(c:color):int 
address CLRhueInt;
comment Extracts hue component from a color atom

command color.luminance(c:color):int 
address CLRluminance;
comment Extracts Y(luminance) component from a color atom

command color.red(c:color):int 
address CLRred;
comment Extracts red component from a color atom

command color.rgb(r:int,g:int,b:int):color 
address CLRrgb;
comment Converts an RGB triplets to a color atom

command color.saturation(c:color):flt 
address CLRsaturation;
comment Extracts saturation component from a color atom

command color.saturation(c:color):int 
address CLRsaturationInt;
comment Extracts saturation component from a color atom

command color.str(s:color):str 
address CLRstr;
comment Converts color to string 

command color.#tostr():void 
address color_tostr;
command color.value(c:color):flt 
address CLRvalue;
comment Extracts value component from a color atom

command color.value(c:color):int 
address CLRvalueInt;
comment Extracts value component from a color atom

command color.ycc(y:int,cr:int,cb:int):color 
address CLRycc;
comment Converts an YCC triplets to a color atom

pattern daytime.!=(v:daytime,w:daytime):bit 
address CMDvarNE;
comment Equality of two daytimes

pattern daytime.<=(v:daytime,w:daytime):bit 
address CMDvarLE;
comment Equality of two daytimes

pattern daytime.<(v:daytime,w:daytime):bit 
address CMDvarLT;
comment Equality of two daytimes

pattern daytime.==(v:daytime,w:daytime):bit 
address CMDvarEQ;
comment Equality of two daytimes

pattern daytime.>=(v:daytime,w:daytime):bit 
address CMDvarGE;
comment Equality of two daytimes

pattern daytime.>(v:daytime,w:daytime):bit 
address CMDvarGT;
comment Equality of two daytimes

command daytime.#fromstr():void 
address daytime_tz_fromstr;
pattern daytime.isnil(v:daytime):bit 
address CMDvarISNIL;
comment Nil test for daytime value

command daytime.#tostr():void 
address daytime_tostr;
pattern date.!=(v:date,w:date):bit 
address CMDvarNE;
comment Equality of two dates

pattern date.<=(v:date,w:date):bit 
address CMDvarLE;
comment Equality of two dates

pattern date.<(v:date,w:date):bit 
address CMDvarLT;
comment Equality of two dates

pattern date.==(v:date,w:date):bit 
address CMDvarEQ;
comment Equality of two dates

pattern date.>=(v:date,w:date):bit 
address CMDvarGE;
comment Equality of two dates

pattern date.>(v:date,w:date):bit 
address CMDvarGT;
comment Equality of two dates

command date.date(s:date):date 
address MTIMEdate_date;
comment Noop routine.

command date.#fromstr():void 
address date_fromstr;
pattern date.isnil(v:date):bit 
address CMDvarISNIL;
comment Nil test for date value

command date.#tostr():void 
address date_tostr;
command factories.getDeparture():bat[:timestamp] 
address FCTgetDeparture;
comment Retrieve the time stamp the last answer was returned.

command factories.getArrival():bat[:timestamp] 
address FCTgetArrival;
comment Retrieve the time stamp the last call was made.

command factories.getOwners():bat[:str] 
address FCTgetOwners;
comment Retrieve the factory owners table.

command factories.getCaller():int 
address FCTgetCaller;
comment Retrieve the unique identity of the factory caller.

command factories.getPlants() (mod:bat[:str],fcn:bat[:str]) 
address FCTgetPlants;
comment Retrieve the names for all active factories.

pattern factories.shutdown(m:str,f:str):void 
address FCTshutdown;
comment Close a factory.

pattern fits.attach(fname:str):void 
address FITSattach;
comment Open a FITS file and return catalog of the table HDUs

pattern fits.export(tablename:str):void 
address FITSexportTable;
comment Export a table to a FITS file

command fits.fitstest(filename:str):int 
address FITStest;
comment Returns the type of first extension in the FITS file filename

pattern fits.load(tablename:str):void 
address FITSloadTable;
comment Load a FITS table from an attached file

pattern fits.listdirpattern(dirname:str,pattern:str):void 
address FITSdirpat;
comment Attach all FITS file in the directory, giving a pattern

pattern fits.listdir(dirname:str):void 
address FITSdir;
comment Attach all FITS files in the directory

pattern generator.join(gen:bat[:dbl],low:bat[:dbl],hgh:bat[:dbl],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_rangejoin;
comment Overloaded range join operation

pattern generator.join(gen:bat[:flt],low:bat[:flt],hgh:bat[:flt],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_rangejoin;
pattern generator.join(gen:bat[:lng],low:bat[:lng],hgh:bat[:lng],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_rangejoin;
pattern generator.join(gen:bat[:int],low:bat[:int],hgh:bat[:int],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_rangejoin;
pattern generator.join(gen:bat[:sht],low:bat[:sht],hgh:bat[:sht],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_rangejoin;
pattern generator.join(gen:bat[:bte],low:bat[:bte],hgh:bat[:bte],li:bit,ri:bit) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_rangejoin;
pattern generator.join(b:bat[:dbl],gen:bat[:dbl]) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_join;
comment Overloaded join operation

pattern generator.join(b:bat[:flt],gen:bat[:flt]) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_join;
pattern generator.join(b:bat[:lng],gen:bat[:lng]) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_join;
pattern generator.join(b:bat[:int],gen:bat[:int]) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_join;
pattern generator.join(b:bat[:sht],gen:bat[:sht]) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_join;
pattern generator.join(b:bat[:bte],gen:bat[:bte]) (l:bat[:oid],r:bat[:oid]) 
address VLTgenerator_join;
pattern generator.projection(b:bat[:oid],cand:bat[:timestamp]):bat[:timestamp] 
address VLTgenerator_projection;
comment Overloaded projection operation

pattern generator.projection(b:bat[:oid],cand:bat[:dbl]):bat[:dbl] 
address VLTgenerator_projection;
pattern generator.projection(b:bat[:oid],cand:bat[:flt]):bat[:flt] 
address VLTgenerator_projection;
pattern generator.projection(b:bat[:oid],cand:bat[:lng]):bat[:lng] 
address VLTgenerator_projection;
pattern generator.projection(b:bat[:oid],cand:bat[:int]):bat[:int] 
address VLTgenerator_projection;
pattern generator.projection(b:bat[:oid],cand:bat[:sht]):bat[:sht] 
address VLTgenerator_projection;
pattern generator.projection(b:bat[:oid],cand:bat[:bte]):bat[:bte] 
address VLTgenerator_projection;
pattern generator.parameters(first:dbl,last:dbl):bat[:dbl] 
address VLTgenerator_noop;
pattern generator.parameters(first:flt,last:flt):bat[:flt] 
address VLTgenerator_noop;
pattern generator.parameters(first:lng,last:lng):bat[:lng] 
address VLTgenerator_noop;
pattern generator.parameters(first:int,last:int):bat[:int] 
address VLTgenerator_noop;
pattern generator.parameters(first:sht,last:sht):bat[:sht] 
address VLTgenerator_noop;
pattern generator.parameters(first:bte,last:bte):bat[:bte] 
address VLTgenerator_noop;
pattern generator.parameters(first:timestamp,last:timestamp,step:lng):bat[:timestamp] 
address VLTgenerator_noop;
comment Retain the table definition, but don't materialize

pattern generator.parameters(first:dbl,last:dbl,step:dbl):bat[:dbl] 
address VLTgenerator_noop;
pattern generator.parameters(first:flt,last:flt,step:flt):bat[:flt] 
address VLTgenerator_noop;
pattern generator.parameters(first:lng,last:lng,step:lng):bat[:lng] 
address VLTgenerator_noop;
pattern generator.parameters(first:int,last:int,step:int):bat[:int] 
address VLTgenerator_noop;
pattern generator.parameters(first:sht,last:sht,step:sht):bat[:sht] 
address VLTgenerator_noop;
pattern generator.parameters(first:bte,last:bte,step:bte):bat[:bte] 
address VLTgenerator_noop;
pattern generator.subselect(b:bat[:timestamp],cand:bat[:oid],low:timestamp,high:timestamp,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
comment Overloaded selection routine

pattern generator.subselect(b:bat[:dbl],cand:bat[:oid],low:dbl,high:dbl,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:flt],cand:bat[:oid],low:flt,high:flt,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:lng],cand:bat[:oid],low:lng,high:lng,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:int],cand:bat[:oid],low:int,high:int,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:sht],cand:bat[:oid],low:sht,high:sht,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:bte],cand:bat[:oid],low:bte,high:bte,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:timestamp],low:timestamp,high:timestamp,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
comment Overloaded selection routine

pattern generator.subselect(b:bat[:dbl],low:dbl,high:dbl,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:flt],low:flt,high:flt,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:lng],low:lng,high:lng,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:int],low:int,high:int,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:sht],low:sht,high:sht,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.subselect(b:bat[:bte],low:bte,high:bte,li:bit,hi:bit,anti:bit):bat[:oid] 
address VLTgenerator_subselect;
pattern generator.series(first:timestamp,last:timestamp,step:lng):bat[:timestamp] 
address VLTgenerator_table;
pattern generator.series(first:dbl,last:dbl,step:dbl):bat[:dbl] 
address VLTgenerator_table;
comment Create and materialize a generator table

pattern generator.series(first:flt,last:flt,step:flt):bat[:flt] 
address VLTgenerator_table;
pattern generator.series(first:lng,last:lng,step:lng):bat[:lng] 
address VLTgenerator_table;
pattern generator.series(first:int,last:int,step:int):bat[:int] 
address VLTgenerator_table;
pattern generator.series(first:sht,last:sht,step:sht):bat[:sht] 
address VLTgenerator_table;
pattern generator.series(first:bte,last:bte,step:bte):bat[:bte] 
address VLTgenerator_table;
pattern generator.series(first:dbl,last:dbl):bat[:dbl] 
address VLTgenerator_table;
pattern generator.series(first:flt,last:flt):bat[:flt] 
address VLTgenerator_table;
pattern generator.series(first:lng,last:lng):bat[:lng] 
address VLTgenerator_table;
pattern generator.series(first:int,last:int):bat[:int] 
address VLTgenerator_table;
pattern generator.series(first:sht,last:sht):bat[:sht] 
address VLTgenerator_table;
pattern generator.series(first:bte,last:bte):bat[:bte] 
address VLTgenerator_table;
pattern generator.thetasubselect(b:bat[:timestamp],cnd:bat[:oid],low:timestamp,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
comment Overloaded selection routine

pattern generator.thetasubselect(b:bat[:dbl],cnd:bat[:oid],low:dbl,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:flt],cnd:bat[:oid],low:flt,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:lng],cnd:bat[:oid],low:lng,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:int],cnd:bat[:oid],low:int,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:sht],cnd:bat[:oid],low:sht,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:bte],cnd:bat[:oid],low:bte,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:timestamp],low:timestamp,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
comment Overloaded selection routine

pattern generator.thetasubselect(b:bat[:dbl],low:dbl,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:flt],low:flt,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:lng],low:lng,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:int],low:int,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:sht],low:sht,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
pattern generator.thetasubselect(b:bat[:bte],low:bte,oper:str):bat[:oid] 
address VLTgenerator_thetasubselect;
command geom.Area(w:wkb):dbl 
address wkbArea;
comment Returns the area of the surface if it is a polygon or multi-polygon

function geom.AsEWKT(w:wkb):str;
function geom.AsText(w:wkb):str;
command geom.AsBinary(w:wkb):str 
address wkbAsBinary;
comment Returns the wkb representation into HEX format

command geom.Buffer(a:wkb,distance:dbl):wkb 
address wkbBuffer;
comment Returns a geometry that represents all points whose distance from this geometry is less than or equal to distance. Calculations are in the Spatial Reference System of this Geometry.

command geom.Boundary(w:wkb):wkb 
address wkbBoundary;
comment Returns the closure of the combinatorial boundary of the Geometry.

function geom.BdMPolyFromText(wkt:str,srid:int):wkb;
function geom.BdPolyFromText(wkt:str,srid:int):wkb;
command geom.Contains(a:wkb,px:bat[:dbl],py:bat[:dbl]):bat[:bit] 
address wkbContains_point_bat;
comment Returns true if the Geometry-BAT a 'spatially contains' Geometry-B b

command geom.Contains(a:wkb,x:dbl,y:dbl):bit 
address wkbContains_point;
comment Returns true if the Geometry a 'spatially contains' Geometry b

command geom.CoveredBy(a:wkb,b:wkb):bit 
address wkbCoveredBy;
comment Returns TRUE if no point of geometry A is outside geometry B

command geom.Covers(a:wkb,b:wkb):bit 
address wkbCovers;
comment Returns TRUE if no point of geometry B is outside geometry A

command geom.Crosses(a:wkb,b:wkb):bit 
address wkbCrosses;
comment Returns TRUE if the supplied geometries have some, but not all, interior points in common.

command geom.Contains(a:wkb,b:wkb):bit 
address wkbContains;
comment Returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A.

command geom.ConvexHull(w:wkb):wkb 
address wkbConvexHull;
comment Returns a geometry that represents the convex hull of this geometry. The convex hull of a geometry represents the minimum convex geometry that encloses all geometries within the set.

command geom.Centroid(w:wkb):wkb 
address wkbCentroid;
comment Computes the geometric center of a geometry, or equivalently, the center of mass of the geometry as a POINT.

command geom.CoordDim(w:wkb):int 
address wkbCoordDim;
comment  Return the coordinate dimension of the geometry

command geom.DumpPoints(a:wkb) (id:bat[:str],geom:bat[:wkb]) 
address wkbDumpPoints;
comment Gets a Geometry and returns the Points in it

command geom.Dump(a:wkb) (id:bat[:str],geom:bat[:wkb]) 
address wkbDump;
comment Gets a MultiPolygon and returns the Polygons in it

command geom.DelaunayTriangles(a:wkb,tolerance:dbl,flag:int):wkb 
address wkbDelaunayTriangles;
comment Returns a Delaunay triangulation, flag=0 => collection of polygons, flag=1 => multilinestring

command geom.DWithin(a:wkb,b:wkb,dst:dbl):bit 
address wkbDWithin;
comment Returns true if the two geometries are within the specifies distance from each other

command geom.Disjoint(a:wkb,b:wkb):bit 
address wkbDisjoint;
comment Returns true if these Geometries are 'spatially disjoint'

command geom.Difference(a:wkb,b:wkb):wkb 
address wkbDifference;
comment Returns a geometry that represents that part of geometry A that does not intersect with geometry B

command geom.Distance(a:wkb,b:wkb):dbl 
address wkbDistance;
comment Returns the 2-dimensional minimum cartesian distance between the two geometries in projected units (spatial ref units.

command geom.Dimension(w:wkb):int 
address wkbDimension;
comment The inherent dimension of this Geometry object, which must be less than or equal to the coordinate dimension.

command geom.Equals(a:wkb,b:wkb):bit 
address wkbEquals;
comment Returns true if the given geometries represent the same geometry. Directionality is ignored.

command geom.ExteriorRing(w:wkb):wkb 
address wkbExteriorRing;
comment Returns a line string representing the exterior ring of the POLYGON geometry. Return NULL if the geometry is not a polygon.

command geom.EnvelopeFromCoordinates(X_1:dbl,X_2:dbl,X_3:dbl,X_4:dbl,X_5:int):wkb 
address wkbEnvelopeFromCoordinates;
comment A polygon created by the provided coordinates

command geom.Envelope(w:wkb):wkb 
address wkbEnvelope;
comment The minimum bounding box for this Geometry, returned as a Geometry. The polygon is defined by the corner points of the bounding box ((MINX,MINY),(MAXX,MINY),(MAXX,MAXY),(MINX,MAXY)).

command geom.EndPoint(w:wkb):wkb 
address wkbEndPoint;
comment Returns the last point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING.

function geom.Force3D(g:wkb):wkb;
function geom.Force2D(g:wkb):wkb;
command geom.ForceDimensions(g:wkb,d:int):wkb 
address wkbForceDim;
comment Removes or Adds additional coordinates in the geometry to make it d dimensions

command geom.FromText(wkt:str,srid:int,type:int):wkb 
address wkbFromText;
command geom.FromBinary(w:str):wkb 
address wkbFromBinary;
comment Creates a wkb using the HEX representation

command geom.GeometryN(g:wkb,n:int):wkb 
address wkbGeometryN;
comment Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON. Otherwise, return NULL

command geom.GetCoordinate(w:wkb,idx:int):dbl 
address wkbGetCoordinate;
comment Returns the coordinate at position idx of a point, or NULL if not available. idx=0 -> X, idx=1 -> Y, idx=2 -> Z. Input must be point

function geom.GeometryType2(w:wkb):str;
function geom.GeometryType1(w:wkb):str;
command geom.GeometryType(w:wkb,flag:int):str 
address wkbGeometryType;
function geom.GeomCollFromText(wkt:str):wkb;
function geom.GeomFromText(wkt:str):wkb;
function geom.GeomCollFromText(wkt:str,srid:int):wkb;
function geom.GeomFromText(wkt:str,srid:int):wkb;
command geom.Intersects(a:wkb,b:wkb):bit 
address wkbIntersects;
comment Returns true if these Geometries 'spatially intersect in 2D'

command geom.Intersection(a:wkb,b:wkb):wkb 
address wkbIntersection;
comment Returns a geometry that represents the point set intersection of the Geometries a, b

command geom.IsValidDetail(w:wkb):str 
address wkbIsValidDetail;
comment Returns a valid_detail (valid,reason,location) row stating if a geometry is valid or not and if not valid, a reason why and a location where.

command geom.IsValidReason(w:wkb):str 
address wkbIsValidReason;
comment Returns text stating if a geometry is valid or not and if not valid, a reason why.

command geom.IsValid(w:wkb):bit 
address wkbIsValid;
comment Returns true if the ST_Geometry is well formed.

command geom.IsSimple(w:wkb):bit 
address wkbIsSimple;
comment Returns (TRUE) if this Geometry has no anomalous geometric points, such as self intersection or self tangency.

command geom.IsRing(w:wkb):bit 
address wkbIsRing;
comment Returns TRUE if this LINESTRING is both closed and simple.

command geom.IsEmpty(w:wkb):bit 
address wkbIsEmpty;
comment Returns true if this Geometry is an empty geometry.

command geom.IsClosed(w:wkb):bit 
address wkbIsClosed;
comment Returns TRUE if the LINESTRING's start and end points are coincident.

command geom.InteriorRings(w:wkb):wkba 
address wkbInteriorRings;
comment Returns an 'array' with all the interior rings of the polygon

command geom.InteriorRingN(w:wkb,n:int):wkb 
address wkbInteriorRingN;
comment Return the Nth interior linestring ring of the polygon geometry. Return NULL if the geometry is not a polygon or the given N is out of range.

command geom.Length(w:wkb):dbl 
address wkbLength;
comment Returns the cartesian 2D length of the geometry if it is a linestrin or multilinestring

function geom.LineFromText(wkt:str):wkb;
function geom.LineFromText(wkt:str,srid:int):wkb;
command geom.MakeBox2D(X_1:wkb,X_2:wkb):mbr 
address wkbBox2D;
comment Creates an mbr from the two 2D points

command geom.MakeLine(a:bat[:wkb]):wkb 
address wkbMakeLineAggr;
comment Gets a BAT with point or linestring geometries and returns a single linestring geometry

command geom.MakeLine(a:wkb,b:wkb):wkb 
address wkbMakeLine;
comment Gets two point or linestring geometries and returns a linestring geometry

function geom.MakePolygon(external:wkb,srid:int):wkb;
function geom.MakePolygon(external:wkb):wkb;
function geom.MakeEnvelope(xmin:dbl,ymin:dbl,xmax:dbl,ymax:dbl):wkb;
function geom.MakeEnvelope(xmin:dbl,ymin:dbl,xmax:dbl,ymax:dbl,srid:int):wkb;
function geom.MakePoint(x:dbl,y:dbl,z:dbl,m:dbl):wkb;
function geom.MakePointM(x:dbl,y:dbl,m:dbl):wkb;
function geom.MakePoint(x:dbl,y:dbl,z:dbl):wkb;
function geom.MakePoint(x:dbl,y:dbl):wkb;
command geom.MakePointXYZM(x:dbl,y:dbl,z:dbl,m:dbl,zmFlag:int):wkb 
address wkbMakePoint;
comment creates a point using the coordinates

function geom.MPolyFromText(wkt:str):wkb;
function geom.MLineFromText(wkt:str):wkb;
function geom.MPointFromText(wkt:str):wkb;
function geom.MPolyFromText(wkt:str,srid:int):wkb;
function geom.MLineFromText(wkt:str,srid:int):wkb;
function geom.MPointFromText(wkt:str,srid:int):wkb;
command geom.MLineStringToPolygon(wkt:str,srid:int,flag:int):wkb 
address wkbMLineStringToPolygon;
comment Creates polygons using the MultiLineString provided as WKT. Depending on the flag creates one (flag=0) or multiple (flag=1) polygons

function geom.NPoints(w:wkb):int;
function geom.NumPoints(w:wkb):int;
command geom.NumGeometries(g:wkb):int 
address wkbNumGeometries;
comment Returns the number of geometries

function geom.NRings(w:wkb):int;
function geom.NumInteriorRings(w:wkb):int;
command geom.NumRings(w:wkb,exterior:int):int 
address wkbNumRings;
comment Returns the number of interior rings+exterior on the first polygon of the geometry

command geom.Overlaps(a:wkb,b:wkb):bit 
address wkbOverlaps;
comment  Returns TRUE if the Geometries intersect but are not completely contained by each other.

command geom.PointOnSurface(w:wkb):wkb 
address wkbPointOnSurface;
comment Returns a point guaranteed to lie on the surface. Similar to postGIS it works for points and lines in addition to surfaces and for 3d geometries.

command geom.PointsNum(w:wkb,check:int):int 
address wkbNumPoints;
comment The number of points in the Geometry. If check=1, the geometry should be a linestring

command geom.Polygon(X_1:wkb,X_2:bat[:wkb],X_3:int):wkb 
address wkbMakePolygon;
comment Returns a Polygon created from the provided LineStrings

command geom.PointN(w:wkb,n:int):wkb 
address wkbPointN;
comment Returns the n-th point of the Geometry. Argument w should be Linestring.

function geom.PolygonFromText(wkt:str):wkb;
function geom.PointFromText(wkt:str):wkb;
function geom.PolygonFromText(wkt:str,srid:int):wkb;
function geom.PointFromText(wkt:str,srid:int):wkb;
command geom.Relate(a:wkb,b:wkb,intersection_matrix_pattern:str):bit 
address wkbRelate;
comment Returns true if the Geometry a 'spatially related' to Geometry b, by testing for intersection between the Interior, Boundary and Exterior of the two geometries as specified by the values in the intersectionPatternMatrix.

command geom.Segmentize(g:wkb,sz:dbl):wkb 
address wkbSegmentize;
comment It creates a new geometry with all segments on it smaller or equal to sz

command geom.SymDifference(a:wkb,b:wkb):wkb 
address wkbSymDifference;
comment Returns a geometry that represents the portions of A and B that do not intersect

command geom.StartPoint(w:wkb):wkb 
address wkbStartPoint;
comment Returns the first point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING

function geom.Translate(g:wkb,dx:dbl,dy:dbl,dz:dbl):wkb;
function geom.Translate(g:wkb,dx:dbl,dy:dbl):wkb;
command geom.Translate3D(g:wkb,dx:dbl,dy:dbl,dz:dbl):wkb 
address wkbTranslate;
comment Moves all points of the geometry by dx, dy, dz

command geom.Transform(g:wkb,srid_src:int,srid_dst:int,proj_src:str,proj_dest:str):wkb 
address wkbTransform;
comment Transforms a geometry from one srid to another

command geom.Touches(a:wkb,b:wkb):bit 
address wkbTouches;
comment Returns TRUE if the geometries have at least one point in common, but their interiors do not intersect.

command geom.ToText(w:wkb,withSRID:int):str 
address wkbAsText;
command geom.Union(a:bat[:wkb]):wkb 
address wkbUnionAggr;
comment Gets a BAT with geometries and returns their union

command geom.Union(a:wkb,b:wkb):wkb 
address wkbUnion;
comment Returns a geometry that represents the point set union of the Geometries a, b

command geom.Within(a:wkb,b:wkb):bit 
address wkbWithin;
comment Returns TRUE if the geometry A is completely inside geometry B

function geom.XMaxFromMBR(b:mbr):dbl;
function geom.XMinFromMBR(b:mbr):dbl;
function geom.XMaxFromWKB(g:wkb):dbl;
function geom.XMinFromWKB(g:wkb):dbl;
function geom.X(w:wkb):dbl;
function geom.YMaxFromMBR(b:mbr):dbl;
function geom.YMinFromMBR(b:mbr):dbl;
function geom.YMaxFromWKB(g:wkb):dbl;
function geom.YMinFromWKB(g:wkb):dbl;
function geom.Y(w:wkb):dbl;
function geom.Z(w:wkb):dbl;
command geom.coordinateFromMBR(X_1:mbr,X_2:int):dbl 
address wkbCoordinateFromMBR;
comment returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided mbr

command geom.coordinateFromWKB(X_1:wkb,X_2:int):dbl 
address wkbCoordinateFromWKB;
comment returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided geometry

command geom.epilogue():void 
address geom_epilogue;
command geom.getSRID(w:wkb):int 
address wkbGetSRID;
comment Returns the Spatial Reference System ID for this Geometry.

command geom.getType(flags:int,format:int):str 
address geoGetType;
comment returns the str representation of the geometry type

command geom.hasM(flags:int):int 
address geoHasM;
comment returns 1 if the geometry has m coordinate

command geom.hasZ(flags:int):int 
address geoHasZ;
comment returns 1 if the geometry has z coordinate

command geom.mbrDistance(box1:mbr,box2:mbr):dbl 
address mbrDistance;
comment Returns the distance of the centroids of the two boxes

command geom.mbrDistance(geom1:wkb,geom2:wkb):dbl 
address mbrDistance_wkb;
comment Returns the distance of the centroids of the mbrs of the two geometries

command geom.mbrContains(box1:mbr,box2:mbr):bit 
address mbrContains;
comment Returns true if box1 contains box2

command geom.mbrContains(geom1:wkb,geom2:wkb):bit 
address mbrContains_wkb;
comment Returns true if the mbr of geom1 contains the mbr of geom2

command geom.mbrAbove(box1:mbr,box2:mbr):bit 
address mbrAbove;
comment Returns true if box1 is above box2

command geom.mbrAbove(geom1:wkb,geom2:wkb):bit 
address mbrAbove_wkb;
comment Returns true if the mbr of geom1 is above the mbr of geom2

command geom.mbrOverlapOrAbove(box1:mbr,box2:mbr):bit 
address mbrOverlapOrAbove;
comment Returns true if box1 overlaps or is above box2

command geom.mbrOverlapOrAbove(geom1:wkb,geom2:wkb):bit 
address mbrOverlapOrAbove_wkb;
comment Returns true if the mbr of geom1 overlaps or is above the mbr of geom2

command geom.mbrContained(box1:mbr,box2:mbr):bit 
address mbrContained;
comment Returns true if box1 is contained by box2

command geom.mbrContained(geom1:wkb,geom2:wkb):bit 
address mbrContained_wkb;
comment Returns true if the mbr of geom1 is contained by the mbr of geom2

command geom.mbrRight(box1:mbr,box2:mbr):bit 
address mbrRight;
comment Returns true if box1 is right of box2

command geom.mbrRight(geom1:wkb,geom2:wkb):bit 
address mbrRight_wkb;
comment Returns true if the mbr of geom1 is right of the mbr of geom2

command geom.mbrEqual(box1:mbr,box2:mbr):bit 
address mbrEqual;
comment Returns true if box1 is the same as box2

command geom.mbrEqual(geom1:wkb,geom2:wkb):bit 
address mbrEqual_wkb;
comment Returns true if the mbr of geom1 is the same as the mbr of geom2

command geom.mbrBelow(box1:mbr,box2:mbr):bit 
address mbrBelow;
comment Returns true if box1 is below box2

command geom.mbrBelow(geom1:wkb,geom2:wkb):bit 
address mbrBelow_wkb;
comment Returns true if the mbr of geom1 is below the mbr of geom2

command geom.mbrLeft(box1:mbr,box2:mbr):bit 
address mbrLeft;
comment Returns true if box1 is left of box2

command geom.mbrLeft(geom1:wkb,geom2:wkb):bit 
address mbrLeft_wkb;
comment Returns true if the mbr of geom1 is left of the mbr of geom2

command geom.mbrOverlapOrRight(box1:mbr,box2:mbr):bit 
address mbrOverlapOrRight;
comment Returns true if box1 overlalps or is right of box2

command geom.mbrOverlapOrRight(geom1:wkb,geom2:wkb):bit 
address mbrOverlapOrRight_wkb;
comment Returns true if the mbr of geom1 overlalps or is right of the mbr of geom2

command geom.mbrOverlapOrBelow(box1:mbr,box2:mbr):bit 
address mbrOverlapOrBelow;
comment Returns true if box1 overlaps or is below box2

command geom.mbrOverlapOrBelow(geom1:wkb,geom2:wkb):bit 
address mbrOverlapOrBelow_wkb;
comment Returns true if the mbr of geom1 overlaps or is below the mbr of geom2

command geom.mbrOverlapOrLeft(box1:mbr,box2:mbr):bit 
address mbrOverlapOrLeft;
comment Returns true if box1 overlaps or is to the left of box2

command geom.mbrOverlapOrLeft(geom1:wkb,geom2:wkb):bit 
address mbrOverlapOrLeft_wkb;
comment Returns true if the mbr of geom1 overlaps or is to the left of thr mbr of geom2

command geom.mbrOverlaps(box1:mbr,box2:mbr):bit 
address mbrOverlaps;
comment Returns true if box1 overlaps box2

command geom.mbrOverlaps(geom1:wkb,geom2:wkb):bit 
address mbrOverlaps_wkb;
comment Returns true if the mbr of geom1 overlaps the mbr of geom2

command geom.mbr(X_1:wkb):mbr 
address wkbMBR;
comment Creates the mbr for the given wkb.

command geom.prelude():void 
address geom_prelude;
command geom.setSRID(w:wkb,srid:int):wkb 
address wkbSetSRID;
comment Sets the Reference System ID for this Geometry.

pattern group.multicolumn(b:bat[:any]...) (ref:bat[:oid],grp:bat[:oid],hist:bat[:any]) 
address GROUPmulticolumngroup;
comment Derivation of a group index over multiple columns.

command group.subgroupdone(b:bat[:any_1],g:bat[:oid],e:bat[:oid],h:bat[:wrd]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:wrd]) 
address GRPsubgroup4;
command group.subgroupdone(b:bat[:any_1],g:bat[:oid]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:wrd]) 
address GRPsubgroup2;
command group.subgroupdone(b:bat[:any_1]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:wrd]) 
address GRPsubgroup1;
command group.subgroup(b:bat[:any_1],g:bat[:oid],e:bat[:oid],h:bat[:wrd]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:wrd]) 
address GRPsubgroup4;
command group.subgroup(b:bat[:any_1],g:bat[:oid]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:wrd]) 
address GRPsubgroup2;
command group.subgroup(b:bat[:any_1]) (groups:bat[:oid],extents:bat[:oid],histo:bat[:wrd]) 
address GRPsubgroup1;
command gsl.chi2prob(d:dbl,i:dbl):dbl 
address GSLchisqProb;
comment Chi Squared probability

command identifier.#fromstr():void 
address IDfromString;
comment Convert a string to an identifier without any check

command identifier.identifier(s:str):identifier 
address IDentifier;
comment Cast a string to an identifer 

command identifier.prelude():void 
address IDprelude;
comment Initialize the module

command identifier.#tostr():void 
address IDtoString;
comment Convert identifier to string equivalent

pattern inspect.equalType(l:any,r:any):bit 
address INSPECTequalType;
comment Return true if both operands are of the same type

command inspect.getStatistics(nme:str):bat[:any_2] 
address QOTgetStatistics;
comment Get optimizer property statistics such as #calls, #total actions, #total time

command inspect.getEnvironment(k:str):str 
address INSPECTgetEnvironmentKey;
comment Get the value of an environemnt variable

command inspect.getEnvironment() (k:bat[:str],v:bat[:str]) 
address INSPECTgetEnvironment;
comment Collect the environment variables.

command inspect.getAtomSizes():bat[:int] 
address INSPECTatom_sizes;
comment Collect a BAT with the atom sizes.

command inspect.getAtomSuper():bat[:str] 
address INSPECTatom_sup_names;
comment Collect a BAT with the atom names.

command inspect.getAtomNames():bat[:str] 
address INSPECTatom_names;
comment Collect a BAT with the atom names.

pattern inspect.getType(v:any_1):str 
address INSPECTtypeName;
comment Return the concrete type of a variable (expression).

pattern inspect.getSize(mod:str,fcn:str):lng 
address INSPECTgetFunctionSize;
comment Return the storage size for a function (in bytes).

pattern inspect.getSize():lng 
address INSPECTgetSize;
comment Return the storage size for the current function (in bytes).

pattern inspect.getAddresses():bat[:str] 
address INSPECTgetAllAddresses;
comment Obtain the function address.

pattern inspect.getSignatures():bat[:str] 
address INSPECTgetAllSignatures;
comment Obtain the function signatures.

pattern inspect.getFunction():bat[:str] 
address INSPECTgetAllFunctions;
comment Obtain the function name.

pattern inspect.getModule():bat[:str] 
address INSPECTgetAllModules;
comment Obtain the function name.

pattern inspect.getKind():bat[:str] 
address INSPECTgetkind;
comment Obtain the instruction kind.

pattern inspect.getSource(mod:str,fcn:str):str 
address INSPECTgetSource;
comment Return the original input for a function.

pattern inspect.getComment(mod:str,fcn:str):bat[:str] 
address INSPECTgetComment;
comment Returns the function help information.

pattern inspect.getAddress(mod:str,fcn:str):bat[:str] 
address INSPECTgetAddress;
comment Returns the function signature(s).

pattern inspect.getSignature(mod:str,fcn:str):bat[:str] 
address INSPECTgetSignature;
comment Returns the function signature(s).

pattern inspect.getDefinition(mod:str,fcn:str):bat[:str] 
address INSPECTgetDefinition;
comment Returns a string representation of a specific function.

command inet.!=(v:inet,w:inet):bit 
address INET_comp_NEQ;
comment Inequality of two inets

command inet.<<=(v:inet,w:inet):bit 
address INET_comp_CWE;
comment Whether v is contained within or is equal to w

command inet.<<(v:inet,w:inet):bit 
address INET_comp_CW;
comment Whether v is contained within w

command inet.<=(v:inet,w:inet):bit 
address INET_comp_LE;
comment Whether v is less than or equal to w

command inet.<(v:inet,w:inet):bit 
address INET_comp_LT;
comment Whether v is less than w

command inet.=(v:inet,w:inet):bit 
address INET_comp_EQ;
comment Equality of two inets

command inet.>>=(v:inet,w:inet):bit 
address INET_comp_CSE;
comment Whether v contains or is equal to w

command inet.>>(v:inet,w:inet):bit 
address INET_comp_CS;
comment Whether v contains w

command inet.>=(v:inet,w:inet):bit 
address INET_comp_GE;
comment Whether v is equal to or greater than w

command inet.>(v:inet,w:inet):bit 
address INET_comp_GT;
comment Whether v is greater than w

command inet.abbrev(X_1:inet):str 
address INETabbrev;
comment Abbreviated display format as text

command inet.broadcast(X_1:inet):inet 
address INETbroadcast;
comment Returns the broadcast address for network

command inet.#cmp():void 
address INETcompare;
command inet.#fromstr():void 
address INETfromString;
comment Convert a string to an inet

command inet.hostmask(X_1:inet):inet 
address INEThostmask;
comment Construct host mask for network

command inet.host(X_1:inet):str 
address INEThost;
comment Extract IP address as text

command inet.isnil(v:inet):bit 
address INET_isnil;
comment Nil test for inet value

command inet.masklen(X_1:inet):int 
address INETmasklen;
comment Extract netmask length

command inet.network(X_1:inet):inet 
address INETnetwork;
comment Extract network part of address

command inet.netmask(X_1:inet):inet 
address INETnetmask;
comment Construct netmask for network

command inet.new(s:str):inet 
address INETnew;
comment Create an inet from a string literal

command inet.#null():void 
address INETnull;
command inet.setmasklen(X_1:inet,X_2:int):inet 
address INETsetmasklen;
comment Set netmask length for inet value

command inet.text(X_1:inet):str 
address INETtext;
comment Extract IP address and netmask length as text

command inet.#tostr():void 
address INETtoString;
comment Convert inet to string equivalent

command io.export(b:bat[:any_2],filepath:str):void 
address IOexport;
comment Export a BAT as ASCII to a file. If the 'filepath' is not absolute, it is put into the $DBPATH directory. Success of failure is indicated.

command io.import(b:bat[:any_2],filepath:str):void 
address IOimport;
comment Import a BAT from an ASCII dump. The tuples are appended to the first argument. Its signature must match the dump, else parsing errors will occur as an exception.

pattern io.printf(filep:streams,fmt:str):void 
address IOprintfStream;
comment Select default format 

pattern io.printf(filep:streams,fmt:str,val:any...):void 
address IOprintfStream;
comment Select default format 

pattern io.printf(fmt:str):void 
address IOprintf;
comment Select default format 

pattern io.printf(fmt:str,val:any...):void 
address IOprintf;
comment Select default format 

pattern io.print(val:bat[:any_1]):void 
address IOprint_val;
comment Print a MAL value column .

pattern io.print(val:any_1):void 
address IOprint_val;
comment Print a MAL value.

pattern io.print(b1:bat[:any]...):void 
address IOtable;
comment BATs are printed with '#' for legend 	lines, and the BUNs on seperate lines 	between brackets, containing each to 	comma separated values (head and tail). 	If multiple BATs are passed for printing, 	print() performs an implicit natural 	join on the void head, producing a multi attribute table.

pattern io.print(val:any_1,lst:any...):void 
address IOprint_val;
comment Print a MAL value tuple .

pattern io.stdout():streams 
address io_stdout;
comment return the output stream for the database client

pattern io.stderr():streams 
address io_stderr;
comment return the error stream for the database console

pattern io.stdin():bstream 
address io_stdin;
comment return the input stream to the database client

command iterator.next(step:dbl,last:dbl):dbl 
address ITRnext_dbl;
comment Advances the iterator with a fixed value

command iterator.next(step:flt,last:flt):flt 
address ITRnext_flt;
command iterator.next(step:lng,last:lng):lng 
address ITRnext_lng;
command iterator.next(step:int,last:int):int 
address ITRnext_int;
command iterator.next(step:sht,last:sht):sht 
address ITRnext_sht;
command iterator.next(step:oid,last:oid):oid 
address ITRnext_oid;
pattern iterator.next(b:bat[:any_2]) (h:oid,t:any_2) 
address ITRbunNext;
comment Produce the next bun for processing.

pattern iterator.new(b:bat[:any_2]) (h:oid,t:any_2) 
address ITRbunIterator;
comment Process the buns one by one extracted from a void table.

command iterator.next(b:bat[:any_2],size:lng) (X_3:lng,X_4:bat[:any_2]) 
address ITRnextChunk;
comment Produce the next chunk for processing.

command iterator.new(b:bat[:any_2],size:lng) (X_3:lng,X_4:bat[:any_2]) 
address ITRnewChunk;
comment Create an iterator with fixed granule size.	  The result is a view.

command json.dump(j:json):void 
address JSONdump;
pattern json.fold(v:bat[:any]):json 
address JSONfold;
comment Combine the value list into a single json array object.

pattern json.fold(k:bat[:str],v:bat[:any]):json 
address JSONfold;
comment Combine the key-value pairs into a single json object list.

pattern json.fold(o:bat[:oid],k:bat[:str],v:bat[:any]):json 
address JSONfold;
comment Combine the key-value pairs into a single json object list.

command json.filter(name:json,idx:lng,other:str):json 
address JSONfilterArrayDefault_lng;
comment Extract a single array element

command json.filter(name:json,idx:lng):json 
address JSONfilterArray_lng;
command json.filter(name:json,idx:int,other:str):json 
address JSONfilterArrayDefault_int;
command json.filter(name:json,idx:int):json 
address JSONfilterArray_int;
command json.filter(name:json,idx:sht,other:str):json 
address JSONfilterArrayDefault_sht;
command json.filter(name:json,idx:sht):json 
address JSONfilterArray_sht;
command json.filter(name:json,idx:bte,other:str):json 
address JSONfilterArrayDefault_bte;
command json.filter(name:json,idx:bte):json 
address JSONfilterArray_bte;
command json.filter(name:json,pathexpr:str):json 
address JSONfilter;
comment Filter all members of an object by a path expression, returning an array.Non-matching elements are skipped.

command json.#fromstr():void 
address JSONfromString;
comment Validate a string to be JSON compliant. A NOOP if valid json, NULL otherwise.

command json.isarray(val:str):bit 
address JSONisarray;
comment Validate the string as a valid JSON array

command json.isobject(val:str):bit 
address JSONisobject;
comment Validate the string as a valid JSON object

command json.isvalid(val:str):bit 
address JSONisvalid;
comment Validate the string as a valid JSON document

command json.isarray(val:json):bit 
address JSONisarray;
comment Validate the string as a valid JSON array

command json.isobject(val:json):bit 
address JSONisobject;
comment Validate the string as a valid JSON object

command json.isvalid(val:json):bit 
address JSONisvalid;
comment Validate the string as a valid JSON document

command json.integer(j:json):lng 
address JSONjson2integer;
comment Convert simple JSON values to an integer, return nil upon error.

command json.keys(val:json):bat[:str] 
address JSONkeyTable;
comment Expands the outermost JSON object names.

command json.keyarray(val:json):json 
address JSONkeyArray;
comment Expands the outermost JSON object keys into a JSON value array.

command json.length(val:json):int 
address JSONlength;
comment Returns the number of elements in the outermost JSON object.

command json.number(j:json):dbl 
address JSONjson2number;
comment Convert simple JSON values to a double, return nil upon error.

command json.new(j:str):json 
address JSONstr2json;
comment Convert string to its JSON. Dealing with escape characters

command json.output(b:bat[:any_1]):str 
address JSONtextString;
comment Pack the values into a single json structure

command json.prelude():void 
address JSONprelude;
command json.resultSet(u:bat[:uuid],rev:bat[:lng],js:bat[:json]):json 
address JSONresultSet;
comment Converts the json store into a single json string:

pattern json.renderarray(val:any...):json 
address JSONrenderarray;
pattern json.renderobject(val:any...):json 
address JSONrenderobject;
command json.suboutput(b:bat[:any_1],gid:bat[:oid],ext:bat[:wrd],flg:bit):bat[:str] 
address JSONtextGrouped;
comment Pack the values into a json structure

command json.str(j:json):str 
address JSONjson2str;
comment Convert JSON to its string equivalent. Dealing with escape characters

command json.text(j:json,s:str):str 
address JSONjson2textSeparator;
comment Convert JSON values to their plain string equivalent, injecting a separator.

command json.text(j:json):str 
address JSONjson2text;
comment Convert JSON values to their plain string equivalent.

command json.#tostr():void 
address JSONtoString;
comment Convert JSON to its string equivalent. Dealing with escape characters

pattern json.unfold(val:json) (o:bat[:oid],k:bat[:str],v:bat[:json]) 
address JSONunfold;
comment Expands the outermost JSON object into key-value pairs.

pattern json.unfold(val:json) (k:bat[:str],v:bat[:json]) 
address JSONunfold;
comment Expands the outermost JSON object into key-value pairs.

command json.values(val:json):bat[:json] 
address JSONvalueTable;
comment Expands the outermost JSON values.

command json.valuearray(val:json):json 
address JSONvalueArray;
comment Expands the outermost JSON object values into a JSON value array.

pattern language.assert(v:any_1,pname:str,oper:str,val:any_2):void 
address MALassertTriple;
comment Assertion test.

command language.assert(v:oid,term:str):void 
address MALassertOid;
command language.assert(v:str,term:str):void 
address MALassertStr;
command language.assert(v:lng,term:str):void 
address MALassertLng;
command language.assert(v:int,term:str):void 
address MALassertInt;
command language.assert(v:sht,term:str):void 
address MALassertSht;
command language.assert(v:bit,term:str):void 
address MALassertBit;
pattern language.block(v:int,w:any...):int 
address deblockdataflow;
comment Block on availability of all variables w, and then pass on v

pattern language.call(s:bat[:str]):void 
address CMDcallBAT;
comment Evaluate a program stored in a BAT.

pattern language.call(m:str,f:str):void 
address CMDcallFunction;
pattern language.call(s:str):void 
address CMDcallString;
comment Evaluate a MAL string program.

pattern language.dataflow():bit 
address MALstartDataflow;
comment The current guarded block is executed using dataflow control. 

pattern language.pass(v:any_1):void 
address MALpass;
comment Cheap instruction to disgard storage while retaining the dataflow dependency

pattern language.register(m:str,f:str,code:str,help:str):void 
address CMDregisterFunction;
comment Compile the code string to MAL and register it as a function.

command language.raise(msg:str):str 
address CMDraise;
comment Raise an exception labeled 	with a specific message.

pattern language.sink(v:any...):void 
address MALgarbagesink;
comment Variables to be considered together when triggering garbage collection.Used in the dataflow blocks to avoid early release of values.

pattern language.source(f:str):void 
address CMDevalFile;
comment Merge the instructions stored in the file with the current program.

command lsst.angsep(ra1:dbl,dec1:dbl,ra2:dbl,dec2:dbl):dbl 
address qserv_angSep;
comment Returns the angular separation in degrees between two sphericalcoordinate pairs (ra1,dec1) and (ra2,dec2)

pattern lsst.ptinsphpoly(ra:dbl,dec:dbl,list:dbl...):int 
address qserv_ptInSphPoly;
comment Returns 1 if the given spherical longitude/latitude polyline contains the given position

command lsst.ptinsphellipse(ra:dbl,dec:dbl,ra_cen:dbl,dec_cen:dbl,smaa:dbl,smia:dbl,ang:dbl):int 
address qserv_ptInSphEllipse;
comment Returns 1 if the given spherical longitude/latitude ellipse contains the given position

command lsst.ptinsphcircle(ra:dbl,dec:dbl,ra_cen:dbl,dec_cen:dbl,radius:dbl):int 
address qserv_ptInSphCircle;
comment Returns 1 if the given spherical longitude/latitude circle contains the given position

command lsst.ptinsphbox(ra:dbl,dec:dbl,ra_min:dbl,dec_min:dbl,ra_max:dbl,dec_max:dbl):int 
address qserv_ptInSphBox;
comment Returns 1 if the given spherical longitude/latitude box contains the given position

command lsst.xmatchsubjoin(l:bat[:lng],r:bat[:lng],depth:int,sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (lr:bat[:oid],rr:bat[:oid]) 
address LSSTxmatchsubjoin;
comment Return the HtmID pairs that lie within the same triangle at level depth

command lsst.xmatchsubselect(l:bat[:lng],cand:bat[:oid],r:lng,depth:int,anti:bit):bat[:oid] 
address LSSTxmatchsubselect;
comment Return the HtmID's that lie within the same triangle as r at level depth

command lsst.xmatch(l:lng,r:lng,depth:int):bit 
address LSSTxmatch;
comment Return true when the HtmID pairs that lie within the same triangle at level depth

pattern mapi.bind(key:int,remoteName:str):bat[:any_2] 
address SERVERbindBAT;
comment Bind a remote variable to a local one.

pattern mapi.bind(key:int,rschema:str,rtable:str,i:int):bat[:any_2] 
address SERVERbindBAT;
comment Bind a remote variable to a local one.

pattern mapi.bind(key:int,rschema:str,rtable:str,rcolumn:str,i:int):bat[:any_2] 
address SERVERbindBAT;
comment Bind a remote variable to a local one.

pattern mapi.connect(host:str,port:int,usr:str,passwd:str,lang:str):int 
address SERVERconnect;
comment Establish connection with a remote mserver.

command mapi.destroy(mid:int):void 
address SERVERdestroy;
comment Destroy the handle for an Mserver.

command mapi.disconnect(mid:int):void 
address SERVERdisconnect;
comment Terminate the session.

command mapi.disconnect():int 
address SERVERdisconnectALL;
comment Close connections with all remote Mserver.

command mapi.disconnect(dbalias:str):int 
address SERVERdisconnectWithAlias;
comment Close connection with a remote Mserver.

command mapi.explain(mid:int):str 
address SERVERexplain;
comment Turn the error seen into a string.

command mapi.error(mid:int):int 
address SERVERerror;
comment Check for an error in the communication.

command mapi.fetch_reset(hdl:int):int 
address SERVERfetch_reset;
comment Reset the cache read line.

command mapi.fetch_line(hdl:int):str 
address SERVERfetch_line;
comment Retrieve a complete line.

command mapi.fetch_field_array(hdl:int):bat[:str] 
address SERVERfetch_field_bat;
comment Retrieve all fields for a row.

command mapi.fetch_field(hdl:int,fnr:int):bte 
address SERVERfetch_field_bte;
comment Retrieve a single bte field.

command mapi.fetch_field(hdl:int,fnr:int):oid 
address SERVERfetch_field_oid;
comment Retrieve a single void field.

command mapi.fetch_field(hdl:int,fnr:int):void 
address SERVERfetch_field_void;
comment Retrieve a single void field.

command mapi.fetch_field(hdl:int,fnr:int):sht 
address SERVERfetch_field_sht;
comment Retrieve a single sht field.

command mapi.fetch_field(hdl:int,fnr:int):lng 
address SERVERfetch_field_lng;
comment Retrieve a single lng field.

command mapi.fetch_field(hdl:int,fnr:int):int 
address SERVERfetch_field_int;
comment Retrieve a single int field.

command mapi.fetch_field(hdl:int,fnr:int):str 
address SERVERfetch_field_str;
comment Retrieve a single field.

command mapi.fetch_all_rows(hdl:int):lng 
address SERVERfetch_all_rows;
comment Retrieve all rows into the cache.

command mapi.fetch_row(hdl:int):int 
address SERVERfetch_row;
comment Retrieve the next row for analysis.

command mapi.finish(hdl:int):int 
address SERVERfinish;
comment Remove all remaining answers.

command mapi.getError(mid:int):str 
address SERVERgetError;
comment Get error message.

command mapi.get_row_count(hdl:int):lng 
address SERVERget_row_count;
comment Return number of rows.

command mapi.get_field_count(hdl:int):int 
address SERVERget_field_count;
comment Return number of fields.

command mapi.lookup(dbalias:str):int 
address SERVERlookup;
comment Retrieve the connection identifier.

command mapi.listen(unixsocket:str):int 
address SERVERlisten_usock;
comment Start a Mapi listener on the unix socket file given.

command mapi.listen(port:int):int 
address SERVERlisten_port;
comment Start a Mapi listener on the port given.

command mapi.listen():int 
address SERVERlisten_default;
comment Start a Mapi server with the default settings.

command mapi.malclient(in:streams,out:streams):void 
address SERVERclient;
comment Start a Mapi client for a particular stream pair.

command mapi.next_result(hdl:int):int 
address SERVERnext_result;
comment Go to next result set.

pattern mapi.put(nme:str,val:any_1):str 
address SERVERputLocal;
comment Prepare sending a value to a remote site.

pattern mapi.put(mid:int,nme:str,val:any_1):void 
address SERVERput;
comment Send a value to a remote site.

command mapi.prepare(mid:int,qry:str):int 
address SERVERprepare;
comment Prepare a query for execution.

command mapi.ping(mid:int):int 
address SERVERping;
comment Test availability of an Mserver.

pattern mapi.query_array(mid:int,qry:str,arg:str...):int 
address SERVERquery_array;
comment Send the query for execution replacing '?' by arguments.

command mapi.query_handle(mid:int,qry:str):int 
address SERVERquery_handle;
comment Send the query for execution.

command mapi.query(mid:int,qry:str):int 
address SERVERquery;
comment Send the query for execution

command mapi.rpc(key:int,qry:str):int 
address SERVERquery;
comment Send a simple query for execution.

pattern mapi.rpc(key:int,qry:str):bat[:any_2] 
address SERVERmapi_rpc_bat;
pattern mapi.rpc(key:int,qry:str...):any 
address SERVERmapi_rpc_single_row;
comment Send a simple query for execution and fetch result.

command mapi.rows_affected(hdl:int):lng 
address SERVERrows_affected;
comment Return number of affected rows.

command mapi.reconnect(mid:int):void 
address SERVERreconnect;
comment Re-establish a connection.

pattern mapi.reconnect(host:str,port:int,db_alias:str,usr:str,passwd:str,lang:str):int 
address SERVERreconnectAlias;
comment Re-establish connection with a remote mserver.

pattern mapi.reconnect(host:str,port:int,usr:str,passwd:str,lang:str):int 
address SERVERreconnectWithoutAlias;
comment Re-establish connection with a remote mserver.

command mapi.resume():void 
address SERVERresume;
comment Resume connection listeners.

command mapi.setAlias(key:int,dbalias:str):void 
address SERVERsetAlias;
comment Give the channel a logical name.

command mapi.suspend():void 
address SERVERsuspend;
comment Suspend accepting connections.

command mapi.stop():void 
address SERVERstop;
comment Terminate connection listeners.

command mapi.trace(mid:int,flag:int):void 
address SERVERtrace;
comment Toggle the Mapi library debug tracer.

pattern manual.functions() (sig:bat[:str],adr:bat[:str],com:bat[:str]) 
address MANUALcreateOverview;
comment Produces a table with all MAL functions known

pattern manual.help(text:str):void 
address MANUALhelp;
comment Produces a list of all <module>.<function> that match	the text pattern. The wildcard '*' can be used for <module>and <function>. Using the '(' asks for signature information andusing ')' asks for the complete help record.

pattern mat.new(b:bat[:any_2]...):bat[:any_2] 
address MATpack;
comment Define a Merge Association Table (MAT). Fall back to the pack operationwhen this is called 

pattern mat.packIncrement(b:bat[:any_2],c:bat[:any_2]):bat[:any_2] 
address MATpackIncrement;
comment Prepare incremental mat pack

pattern mat.packIncrement(b:bat[:any_2],pieces:int):bat[:any_2] 
address MATpackIncrement;
comment Prepare incremental mat pack

pattern mat.pack(b:bat[:any_2]...):bat[:any_2] 
address MATpack;
comment Materialize the MAT into a BAT

pattern mat.pack(X_1:any_2...):bat[:any_2] 
address MATpackValues;
comment Materialize the MAT (of values) into a BAT

pattern mal.manifold(mod:str,fcn:str,a:any...):bat[:any] 
address MANIFOLDevaluate;
pattern mal.multiplex(mod:str,fcn:str,a:any...):any... 
address MANIFOLDremapMultiplex;
command mbr.#cmp():void 
address mbrCOMP;
command mbr.#fromstr():void 
address mbrFROMSTR;
command mbr.#hash():void 
address mbrHASH;
command mbr.#null():void 
address mbrNULL;
command mbr.#read():void 
address mbrREAD;
command mbr.#tostr():void 
address mbrTOSTR;
command mbr.#write():void 
address mbrWRITE;
command mcurl.deleterequest(s:str):str 
address CURLdeleteRequest;
comment Perform a http delete request

command mcurl.getrequest(s:str):str 
address CURLgetRequest;
comment Perform a http get request

command mcurl.postrequest(s:str):str 
address CURLpostRequest;
comment Perform a http post request

command mcurl.putrequest(s:str):str 
address CURLputRequest;
comment Perform a http put request

pattern mdb.List(M:str,F:str):void 
address MDBlist3Detail;
comment Dump the routine M.F on standard out.

pattern mdb.List():void 
address MDBlistDetail;
comment Dump the current routine on standard out.

pattern mdb.dump():void 
address MDBdump;
comment Dump instruction, stacktrace, and stack

pattern mdb.dot(M:str,F:str,s:str):void 
address MDBshowFlowGraph;
comment Dump the data flow of the function 	M.F in a format recognizable by the 	command 'dot' on the file s

pattern mdb.dot(s:str):void 
address MDBshowFlowGraph;
comment Dump the data flow of the current routine in a format recognizable by the command 'dot' to the file s

pattern mdb.getDefinition():bat[:str] 
address MDBgetDefinition;
comment Returns a string representation of the current function 	with typing information attached

pattern mdb.getStackTrace() (X_1:bat[:int],X_2:bat[:str]) 
address MDBStkTrace;
pattern mdb.getStackFrame() (X_1:bat[:str],X_2:bat[:str]) 
address MDBgetStackFrame;
comment Collect variable binding of current (n-th) stack frame.

pattern mdb.getStackFrame(i:int) (X_2:bat[:str],X_3:bat[:str]) 
address MDBgetStackFrameN;
pattern mdb.getStackDepth():int 
address MDBStkDepth;
comment Return the depth of the calling stack.

pattern mdb.grab():void 
address mdbGrab;
comment Call debugger for a suspended process.

command mdb.getContext(s:str):str 
address MDBgetExceptionContext;
comment Extract the context string from the exception message

command mdb.getReason(s:str):str 
address MDBgetExceptionReason;
comment Extract the reason from the exception message

command mdb.getException(s:str):str 
address MDBgetExceptionVariable;
comment Extract the variable name from the exception message

command mdb.getDebug():int 
address MDBgetDebug;
comment Get the kernel debugging bit-set.See the MonetDB configuration file for details

pattern mdb.inspect(mod:str,fcn:str):void 
address MDBinspect;
comment Run the debugger on a specific function

pattern mdb.lifespan(M:str,F:str):void 
address MDBlifespan;
comment Dump the current routine lifespan information on standard out.

pattern mdb.list(M:str,F:str):void 
address MDBlist3;
comment Dump the routine M.F on standard out.

pattern mdb.listMapi():void 
address MDBlistMapi;
comment Dump the current routine on standard out with Mapi prefix.

pattern mdb.list():void 
address MDBlist;
comment Dump the current routine on standard out.

command mdb.modules():bat[:str] 
address CMDmodules;
comment List available modules

command mdb.setDebug(flg:int):int 
address MDBsetDebug;
comment Set the kernel debugging bit-set and return its previous value.

command mdb.setDebug(flg:str):int 
address MDBsetDebugStr;
comment Set the kernel debugging bit-set and return its previous value.The recognized options are: threads, memory, properties,io, transactions, modules, algorithms, estimates.

pattern mdb.setCatch(b:bit):void 
address MDBsetCatch;
comment Turn on/off catching exceptions

pattern mdb.setTrace(b:str):void 
address MDBsetVarTrace;
comment Turn on/off tracing of a variable 

pattern mdb.setTrace(b:bit):void 
address MDBsetTrace;
comment Turn on/off tracing of current routine

pattern mdb.setTrap(idx:int):void 
address mdbTrapClient;
comment Call debugger for a specific process.

pattern mdb.setTrap(mod:str,fcn:str,b:bit):void 
address MDBtrapFunction;
comment Suspend upon a call to the MAL function.

pattern mdb.stop():void 
address MDBstop;
comment Stop the interactive debugger

pattern mdb.start(mod:str,fcn:str):void 
address MDBstartFactory;
comment Start interactive debugger on a running factory

pattern mdb.start(clientid:int):void 
address MDBstart;
comment Start interactive debugger on a client

pattern mdb.start():void 
address MDBstart;
comment Start interactive debugger

command mdb.traceOptimizer(flg:str):void 
address OPTsetDebugStr;
comment Otherwise it is considered a request to trace the optimizers,which requires a comma separated list or pipeline name.

pattern mdb.trap():void 
address mdbTrap;
comment A suspended process for debugging.

pattern mdb.var(M:str,F:str):void 
address MDBvar3;
comment Dump the symboltable of routine M.F on standard out.

pattern mdb.var():void 
address MDBvar;
comment Dump the symboltable of current routine on standard out.

command mkey.bulk_rotate_xor_hash(h:bat[:wrd],nbits:int,b:bat[:any_1]):bat[:wrd] 
address MKEYbulk_rotate_xor_hash;
comment pre:  h and b should be synced on head         post: [:xor=]([:rotate=](h, nbits), [hash](b))

pattern mkey.bulk_rotate_xor_hash(h:bat[:wrd],nbits:int,v:any):bat[:wrd] 
address MKEYbulkconst_rotate_xor_hash;
comment pre:  h and b should be synced on head         post: [:xor=]([:rotate=](h, nbits), [hash](b))

command mkey.bulk_rotate_xor_hash(h:wrd,nbits:int,b:bat[:any_1]):bat[:wrd] 
address MKEYconstbulk_rotate_xor_hash;
comment pre:  h and b should be synced on head         post: [:xor=]([:rotate=](h, nbits), [hash](b))

pattern mkey.bulk_rotate_xor_hash(h:wrd,nbits:int,v:any):wrd 
address MKEYrotate_xor_hash;
comment post: [:xor=]([:rotate=](h, nbits), [hash](b))

pattern mkey.hash(v:str):wrd 
address MKEYhash;
comment calculate a hash value

pattern mkey.hash(v:lng):wrd 
address MKEYhash;
comment calculate a hash value

pattern mkey.hash(v:dbl):wrd 
address MKEYhash;
comment calculate a hash value

pattern mkey.hash(v:wrd):wrd 
address MKEYhash;
comment calculate a hash value

pattern mkey.hash(v:flt):wrd 
address MKEYhash;
comment calculate a hash value

pattern mkey.hash(v:int):wrd 
address MKEYhash;
comment calculate a hash value

pattern mkey.hash(v:sht):wrd 
address MKEYhash;
comment calculate a hash value

pattern mkey.hash(v:bte):wrd 
address MKEYhash;
comment calculate a hash value

pattern mkey.hash(v:bit):wrd 
address MKEYhash;
comment calculate a hash value

pattern mkey.hash(v:any):wrd 
address MKEYhash;
comment calculate a hash value

command mkey.rotate(v:wrd,nbits:int):wrd 
address MKEYrotate;
comment left-rotate an int by nbits

command mmath.atan2(x:dbl,y:dbl):dbl 
address MATHbinary_ATAN2dbl;
comment The atan2(x,y) function calculates the arc tangent of the two         variables x and y.  It is similar to calculating the arc	tangent of y / x, except that the signs of both arguments are         used to determine the quadrant of the result.  The value is 	returned in radians and is mathematically defined to be between         -PI/2 and PI/2 (inclusive).

command mmath.atan2(x:flt,y:flt):flt 
address MATHbinary_ATAN2flt;
command mmath.atan(x:dbl):dbl 
address MATHunary_ATANdbl;
comment The atan(x) function calculates the arc tangent of x, that is the value 	whose tangent is x. The value is returned in radians and is mathematically 	defined to be between -PI/2 and PI/2 (inclusive).

command mmath.atan(x:flt):flt 
address MATHunary_ATANflt;
command mmath.asin(x:dbl):dbl 
address MATHunary_ASINdbl;
comment The asin(x) function calculates the arc sine of x, that is the value 	whose sine is x. The value is returned in radians and is mathematically 	defined to be between -PI/20 and -PI/2 (inclusive).

command mmath.asin(x:flt):flt 
address MATHunary_ASINflt;
command mmath.acos(x:dbl):dbl 
address MATHunary_ACOSdbl;
comment The acos(x) function calculates the arc cosine of x, that is the 	value whose cosine is x. The value is returned in radians and is 	mathematically defined to be between 0 and PI (inclusive).

command mmath.acos(x:flt):flt 
address MATHunary_ACOSflt;
command mmath.ceil(y:dbl):dbl 
address MATHunary_CEILdbl;
comment The ceil(x) function rounds x upwards to the nearest integer.

command mmath.ceil(y:flt):flt 
address MATHunary_CEILflt;
command mmath.cosh(x:dbl):dbl 
address MATHunary_COSHdbl;
comment The cosh() function  returns the hyperbolic cosine of x, which is 	defined mathematically as (exp(x) + exp(-x)) / 2.

command mmath.cosh(x:flt):flt 
address MATHunary_COSHflt;
command mmath.cot(x:dbl):dbl 
address MATHunary_COTdbl;
comment The cot(x) function returns the Cotangent of x,        where x is given in radians

command mmath.cot(x:flt):flt 
address MATHunary_COTflt;
command mmath.cos(x:dbl):dbl 
address MATHunary_COSdbl;
comment The cos(x) function returns the cosine of x, where x is given in         radians. The return value is between -1 and 1.

command mmath.cos(x:flt):flt 
address MATHunary_COSflt;
command mmath.degrees(x:dbl):dbl 
address MATHunary_DEGREESdbl;
comment The degrees() function converts radians into degrees

command mmath.degrees(x:flt):flt 
address MATHunary_DEGREESflt;
command mmath.exp(x:dbl):dbl 
address MATHunary_EXPdbl;
comment The exp(x) function returns the value of e (the base of         natural logarithms) raised to the power of x.

command mmath.exp(x:flt):flt 
address MATHunary_EXPflt;
command mmath.finite(d:dbl):bit 
address MATHunary_FINITE;
comment The finite(x) function returns true if x is neither infinite         nor a 'not-a-number' (NaN) value, and false otherwise.

pattern mmath.fmod(y:dbl,x:dbl):dbl 
address CMDvarMODsignal;
comment The fmod(x,y) function computes the remainder of dividing x by y.	The return value is x - n * y, where n is the quotient of x / y,	rounded towards zero to an integer.

pattern mmath.fmod(y:flt,x:flt):flt 
address CMDvarMODsignal;
command mmath.floor(y:dbl):dbl 
address MATHunary_FLOORdbl;
comment The floor(x) function rounds x downwards to the nearest integer.

command mmath.floor(y:flt):flt 
address MATHunary_FLOORflt;
command mmath.fabs(y:dbl):dbl 
address MATHunary_FABSdbl;
comment The fabs(x) function  returns  the  absolute value of the         floating-point number x.

command mmath.isinf(d:dbl):int 
address MATHunary_ISINF;
comment The isinf(x) function returns -1 if x represents negative         infinity, 1 if x represents positive infinity, and 0 otherwise.

command mmath.isnan(d:dbl):bit 
address MATHunary_ISNAN;
comment The isnan(x) function returns true if x is 'not-a-number'         (NaN), and false otherwise.

command mmath.log10(x:dbl):dbl 
address MATHunary_LOG10dbl;
comment The log10(x) function returns the base-10 logarithm of x.

command mmath.log10(x:flt):flt 
address MATHunary_LOG10flt;
command mmath.log(x:dbl):dbl 
address MATHunary_LOGdbl;
comment The log(x) function returns the natural logarithm of x.

command mmath.log(x:flt):flt 
address MATHunary_LOGflt;
command mmath.pi():dbl 
address MATHpi;
comment return an important mathematical value

command mmath.pow(x:dbl,y:dbl):dbl 
address MATHbinary_POWdbl;
comment The pow(x,y) function  returns the value of x raised to the power of y.

command mmath.pow(x:flt,y:flt):flt 
address MATHbinary_POWflt;
command mmath.rand(v:int):int 
address MATHrandintarg;
comment return a random number

command mmath.rand():int 
address MATHrandint;
comment return a random number

command mmath.round(x:dbl,y:int):dbl 
address MATHbinary_ROUNDdbl;
comment The round(n, m) returns n rounded to m places to the right         of the decimal point; if m is omitted, to 0 places. m can be 	negative to round off digits left of the decimal point.         m must be an integer.

command mmath.round(x:flt,y:int):flt 
address MATHbinary_ROUNDflt;
command mmath.radians(x:dbl):dbl 
address MATHunary_RADIANSdbl;
comment The radians() function converts degrees into radians

command mmath.radians(x:flt):flt 
address MATHunary_RADIANSflt;
command mmath.sqlrand(seed:int):int 
address MATHsqlrandint;
comment initialize the rand() function with a seed and call rand()

command mmath.srand(seed:int):void 
address MATHsrandint;
comment initialize the rand() function with a seed

command mmath.sqrt(y:dbl):dbl 
address MATHunary_SQRTdbl;
comment The sqrt(x) function returns the non-negative square root of x.

command mmath.sqrt(y:flt):flt 
address MATHunary_SQRTflt;
command mmath.sinh(x:dbl):dbl 
address MATHunary_SINHdbl;
comment The sinh() function  returns  the  hyperbolic sine of x, which         is defined mathematically as (exp(x) - exp(-x)) / 2.

command mmath.sinh(x:flt):flt 
address MATHunary_SINHflt;
command mmath.sin(x:dbl):dbl 
address MATHunary_SINdbl;
comment The sin(x) function returns the cosine of x, where x is given in         radians. The return value is between -1 and 1.

command mmath.sin(x:flt):flt 
address MATHunary_SINflt;
command mmath.tanh(x:dbl):dbl 
address MATHunary_TANHdbl;
comment The tanh() function returns the hyperbolic tangent of x, which is 	defined mathematically as sinh(x) / cosh(x).

command mmath.tanh(x:flt):flt 
address MATHunary_TANHflt;
command mmath.tan(x:dbl):dbl 
address MATHunary_TANdbl;
comment The tan(x) function returns the tangent of x,        where x is given in radians

command mmath.tan(x:flt):flt 
address MATHunary_TANflt;
command mtime.add(v:timestamp,msecs:lng):timestamp 
address MTIMEtimestamp_add;
comment returns the timestamp that comes 'msecs'	(possibly negative) after 'value'.

command mtime.adddays(value:date,days:int):date 
address MTIMEdate_adddays;
comment returns the date after a number	of days (possibly negative).

command mtime.addmonths(value:date,months:int):date 
address MTIMEdate_addmonths;
comment returns the date after a number of	months (possibly negative).

command mtime.addyears(value:date,years:int):date 
address MTIMEdate_addyears;
comment returns the date after a number	of years (possibly negative).

command mtime.current_time():daytime 
address MTIMEcurrent_time;
command mtime.current_date():date 
address MTIMEcurrent_date;
command mtime.current_timestamp():timestamp 
address MTIMEcurrent_timestamp;
command mtime.compute(r:zrule,year:int):date 
address MTIMEcompute_rule_foryear;
comment compute the date from a rule in a given year

command mtime.day(msecs:lng):lng 
address MTIMEsql_day;
command mtime.day(t:timestamp):int 
address MTIMEtimestamp_day;
command mtime.daytime(h:int,m:int,s:int):daytime 
address MTIMEdaytime3;
comment default time with zeroed components

command mtime.daytime(h:int,m:int):daytime 
address MTIMEdaytime2;
comment default time with zeroed components

command mtime.daytime(h:int):daytime 
address MTIMEdaytime1;
comment default time with zeroed components

command mtime.date_to_str(d:date,format:str):str 
address MTIMEdate_to_str;
comment create a string from the date, using the specified format (see man strftime)

command mtime.dayname(day:int):str 
address MTIMEday_to_str;
comment Returns day name from a number	between [1-7], str(nil) otherwise.

command mtime.daynum(day:str):int 
address MTIMEday_from_str;
comment Returns number of day [1-7] from a	string or nil if does not match any.

command mtime.dst(t:timestamp,v:timezone):bit 
address MTIMEtimestamp_inside_dst;
comment return whether DST holds in the	timezone at a certain point of time.

command mtime.diff(val1:timestamp,val2:timestamp):lng 
address MTIMEtimestamp_diff;
comment returns the number of milliseconds	between 'val1' and 'val2'.

command mtime.dayofweek(d:date):int 
address MTIMEdate_extract_dayofweek;
comment Returns the current day of the week	where 1=monday, .., 7=sunday

command mtime.dayofyear(d:date):int 
address MTIMEdate_extract_dayofyear;
comment Returns N where d is the Nth day	of the year (january 1 returns 1)

command mtime.diff(val1:date,val2:date):int 
address MTIMEdate_diff;
comment returns the number of days	between 'val1' and 'val2'.

command mtime.day(t:zrule):int 
address MTIMErule_extract_day;
comment extract day from rule.

command mtime.date(t:timestamp,v:timezone):date 
address MTIMEtimestamp_extract_date;
comment extracts date from timestamp in a	specific timezone.

command mtime.date(t:timestamp):date 
address MTIMEtimestamp_extract_date_default;
comment extracts date from timestamp	in the local timezone.

command mtime.daytime(t:timestamp,v:timezone):daytime 
address MTIMEtimestamp_extract_daytime;
comment extracts daytime from timestamp	in a specific timezone.

command mtime.daytime(t:timestamp):daytime 
address MTIMEtimestamp_extract_daytime_default;
comment extracts daytime from timestamp	in the local timezone.

command mtime.day(d:date):int 
address MTIMEdate_extract_day;
comment extracts day from date 

command mtime.daytime(h:int,m:int,s:int,mi:int):daytime 
address MTIMEdaytime_create;
comment creates a time from (hours,minutes,	seconds,milliseconds) parameters.

command mtime.daytime(X_1:lng):daytime 
address MTIMEsecs2daytime;
command mtime.daytime(X_1:daytime):daytime 
address MTIMEdaytime2daytime;
command mtime.daytime(s:str):daytime 
address MTIMEdaytime_fromstr;
comment convert the string to a daytime value.

command mtime.date(yr:int,mo:int,day:int):date 
address MTIMEdate_create;
comment creates a date from (year,month,day).

command mtime.date(s:str):date 
address MTIMEdate_fromstr;
comment convert the string to a type date value

command mtime.date(X_1:void):date 
address MTIMEnil2date;
comment generate the nil date

command mtime.date(X_1:date):date 
address MTIMEdate2date;
comment generate the nil date

command mtime.date_sub_month_interval(t:date,s:int):date 
address MTIMEdate_submonths;
comment Subtract months from a date

command mtime.date_add_month_interval(t:date,s:int):date 
address MTIMEdate_addmonths;
comment Add months to a date

command mtime.diff(val1:daytime,val2:daytime):lng 
address MTIMEdaytime_diff;
comment returns the number of msec between 'val1' and 'val2'.

command mtime.date_add_msec_interval(t:date,ms:lng):date 
address MTIMEdate_add_msec_interval_lng_wrap;
command mtime.date_add_sec_interval(t:date,s:int):date 
address MTIMEdate_add_sec_interval_wrap;
comment Add seconds to a date

command mtime.date_sub_msec_interval(t:date,ms:lng):date 
address MTIMEdate_sub_msec_interval_lng_wrap;
command mtime.date_sub_sec_interval(t:date,s:int):date 
address MTIMEdate_sub_sec_interval_wrap;
comment Subtract seconds from a date

command mtime.epilogue():void 
address MTIMEepilogue;
command mtime.end_dst(t:timezone):zrule 
address MTIMEtzone_extract_end;
comment extract rule that determines	end of DST from timezone.

command mtime.hours(msecs:lng):int 
address MTIMEsql_hours;
command mtime.hours(t:timestamp):int 
address MTIMEtimestamp_hours;
command mtime.hours(h:daytime):int 
address MTIMEdaytime_extract_hours;
comment extracts hour from daytime

command mtime.local_timezone():lng 
address MTIMElocal_timezone;
comment get the local timezone in seconds

command mtime.msec():lng 
address MTIMEmsec;
comment get time of day in msec since 1-1-1970.

command mtime.minutes(msecs:lng):int 
address MTIMEsql_minutes;
command mtime.month(months:int):int 
address MTIMEsql_month;
command mtime.milliseconds(t:timestamp):int 
address MTIMEtimestamp_milliseconds;
command mtime.minutes(t:timestamp):int 
address MTIMEtimestamp_minutes;
command mtime.month(t:timestamp):int 
address MTIMEtimestamp_month;
command mtime.msecs(d:int,h:int,m:int,s:int,ms:int):lng 
address MTIMEmsecs;
comment convert date components to milliseconds

command mtime.monthname(month:int):str 
address MTIMEmonth_to_str;
comment Returns month name from a number	between [1-12], str(nil) otherwise.

command mtime.monthnum(month:str):int 
address MTIMEmonth_from_str;
comment Returns month number [1-12] from a string	 or nil if does not match any.

command mtime.minutes(t:zrule):int 
address MTIMErule_extract_minutes;
comment extract minutes from rule.

command mtime.month(t:zrule):int 
address MTIMErule_extract_month;
comment extract month from rule.

command mtime.minutes(t:timezone):int 
address MTIMEtzone_extract_minutes;
comment extract number of minutes that	time zone is offset wrt GMT.

command mtime.milliseconds(d:daytime):int 
address MTIMEdaytime_extract_milliseconds;
comment extracts milliseconds from daytime

command mtime.minutes(d:daytime):int 
address MTIMEdaytime_extract_minutes;
comment extracts minutes from daytime

command mtime.month(d:date):int 
address MTIMEdate_extract_month;
comment extracts month from date

command mtime.prelude():void 
address MTIMEprelude;
command mtime.rule(mo:int,d:int,wkday:int,mi:int):zrule 
address MTIMErule_create;
comment create a DST start/end date rule.

command mtime.rule(s:str):zrule 
address MTIMErule_fromstr;
comment create a rule from a  string.

command mtime.seconds(msecs:lng):int 
address MTIMEsql_seconds;
command mtime.sql_seconds(t:timestamp):int 
address MTIMEtimestamp_sql_seconds;
command mtime.seconds(t:timestamp):int 
address MTIMEtimestamp_seconds;
command mtime.str_to_timestamp(s:str,format:str):timestamp 
address MTIMEstr_to_timestamp;
comment create a timestamp from the string, using the specified format (see man strptime)

command mtime.str_to_time(s:str,format:str):daytime 
address MTIMEstr_to_time;
comment create a time from the string, using the specified format (see man strptime)

command mtime.str_to_date(s:str,format:str):date 
address MTIMEstr_to_date;
comment create a date from the string, using the specified format (see man strptime)

command mtime.start_dst(t:timezone):zrule 
address MTIMEtzone_extract_start;
comment extract rule that determines	start of DST from timezone.

command mtime.setTimezone(name:str):timezone 
address MTIMEtimezone;
comment Test and set the timezone.

command mtime.sql_seconds(d:daytime):int 
address MTIMEdaytime_extract_sql_seconds;
comment extracts seconds (with fractional milliseconds) from daytime

command mtime.seconds(d:daytime):int 
address MTIMEdaytime_extract_seconds;
comment extracts seconds from daytime

command mtime.timestamp_to_str(d:timestamp,format:str):str 
address MTIMEtimestamp_to_str;
comment create a string from the time, using the specified format (see man strftime)

command mtime.time_to_str(d:daytime,format:str):str 
address MTIMEtime_to_str;
comment create a string from the time, using the specified format (see man strftime)

command mtime.time_synonyms(allow:bit):void 
address MTIMEsynonyms;
comment Allow synonyms for the parse format of	date/timestamp.

command mtime.timezone(mi:int,s:zrule,erule:zrule):timezone 
address MTIMEtzone_create_dst;
comment create a timezone as an hour difference	from GMT and a DST.

command mtime.timezone(s:lng):timezone 
address MTIMEtzone_create_lng;
comment Convert the int to a timezone.

command mtime.timezone(s:int):timezone 
address MTIMEtzone_create;
comment Convert the int to a timezone.

command mtime.timezone(s:str):timezone 
address MTIMEtzone_fromstr;
comment Convert the string to a timezone.

command mtime.timestamp(d:date):timestamp 
address MTIMEtimestamp_create_from_date;
comment creates a timestamp from (d,00:00:00) parameters (in the local timezone).

command mtime.timestamp(d:date,dt:daytime):timestamp 
address MTIMEtimestamp_create_default;
comment creates a timestamp from (d,dt) parameters (in the local timezone).

command mtime.timestamp(d:date,dt:daytime,t:timezone):timestamp 
address MTIMEtimestamp_create;
comment creates a timestamp from (date, daytime,timezone) parameters.

command mtime.timezone_local():timezone 
address MTIMEtzone_get_local;
comment get the local timezone; which is used for printing timestamps

command mtime.timezone_local(t:timezone):void 
address MTIMEtzone_set_local;
comment set the local timezone; which is used for printing timestamps

command mtime.time_add_msec_interval(t:daytime,ms:lng):daytime 
address MTIMEtime_add_msec_interval_wrap;
comment Add seconds to a time

command mtime.time_sub_msec_interval(t:daytime,ms:lng):daytime 
address MTIMEtime_sub_msec_interval_wrap;
comment Subtract seconds from a time

command mtime.timestamp(t:timestamp):timestamp 
address MTIMEtimestamp2timestamp;
command mtime.timestamp_add_month_interval(t:timestamp,s:lng):timestamp 
address MTIMEtimestamp_add_month_interval_lng_wrap;
comment Add months to a timestamp

command mtime.timestamp_add_month_interval(t:timestamp,s:int):timestamp 
address MTIMEtimestamp_add_month_interval_wrap;
comment Add months to a timestamp

command mtime.timestamp_sub_month_interval(t:timestamp,s:lng):timestamp 
address MTIMEtimestamp_sub_month_interval_lng_wrap;
comment Subtract months from a timestamp

command mtime.timestamp_sub_month_interval(t:timestamp,s:int):timestamp 
address MTIMEtimestamp_sub_month_interval_wrap;
comment Subtract months from a timestamp

command mtime.timestamp_add_msec_interval(t:timestamp,ms:lng):timestamp 
address MTIMEtimestamp_add;
command mtime.timestamp_sub_msec_interval(t:timestamp,ms:lng):timestamp 
address MTIMEtimestamp_sub_msec_interval_lng_wrap;
command mtime.weekofyear(d:date):int 
address MTIMEdate_extract_weekofyear;
comment Returns the week number in the year.

command mtime.weekday(t:zrule):int 
address MTIMErule_extract_weekday;
comment extract weekday from rule.

command mtime.year(months:int):int 
address MTIMEsql_year;
command mtime.year(t:timestamp):int 
address MTIMEtimestamp_year;
command mtime.year(d:date):int 
address MTIMEdate_extract_year;
comment extracts year from date (nonzero	value between -5867411 and +5867411).

pattern netcdf.attach(filename:str):void 
address NCDFattach;
comment Register a NetCDF file in the vault

pattern netcdf.importvariable(fileid:int,varname:str):void 
address NCDFimportVariable;
comment Import variable: create array and load data from variable varname of file fileid

command netcdf.importvar(filename:str,varid:int):str 
address NCDFimportVarStmt;
comment Import variable: compose create array string

command netcdf.test(filename:str):int 
address NCDFtest;
comment Returns number of variables in a given NetCDF dataset (file)

pattern optimizer.aliases(mod:str,fcn:str):str 
address OPTwrapper;
comment Alias removal optimizer

pattern optimizer.aliases():str 
address OPTwrapper;
pattern optimizer.clrDebug():void 
address QOTclrdebugOptimizers;
pattern optimizer.crackers(mod:str,fcn:str):str 
address OPTwrapper;
comment Replace algebra select with crackers select

pattern optimizer.crackers():str 
address OPTwrapper;
pattern optimizer.costModel(mod:str,fcn:str):str 
address OPTwrapper;
comment Estimate the cost of a relational expression

pattern optimizer.costModel():str 
address OPTwrapper;
pattern optimizer.constants(mod:str,fcn:str):str 
address OPTwrapper;
comment Duplicate constant removal optimizer

pattern optimizer.constants():str 
address OPTwrapper;
pattern optimizer.candidates(mod:str,fcn:str):str 
address OPTwrapper;
comment Mark candidate list variables

pattern optimizer.candidates():str 
address OPTwrapper;
pattern optimizer.commonTerms(mod:any_1,fcn:any_2):str 
address OPTwrapper;
comment Common sub-expression optimizer

pattern optimizer.commonTerms():str 
address OPTwrapper;
pattern optimizer.coercions(mod:str,fcn:str):str 
address OPTwrapper;
comment Handle simple type coercions

pattern optimizer.coercions():str 
address OPTwrapper;
pattern optimizer.dumpQEP(mod:str,fcn:str):str 
address OPTwrapper;
comment Produce an indented tree visualisation

pattern optimizer.dumpQEP():void 
address OPTwrapper;
pattern optimizer.derivePath(mod:str,fcn:str):str 
address OPTwrapper;
comment Join path constructor

pattern optimizer.derivePath():str 
address OPTwrapper;
pattern optimizer.deadcode(mod:str,fcn:str):str 
address OPTwrapper;
comment Dead code optimizer

pattern optimizer.deadcode():str 
address OPTwrapper;
pattern optimizer.dataflow(mod:str,fcn:str):str 
address OPTwrapper;
comment Dataflow bracket code injection

pattern optimizer.dataflow():str 
address OPTwrapper;
pattern optimizer.evaluate(mod:str,fcn:str):str 
address OPTwrapper;
comment Evaluate constant expressions once.

pattern optimizer.evaluate():str 
address OPTwrapper;
pattern optimizer.factorize(mod:str,fcn:str):str 
address OPTwrapper;
comment Turn function into a factory

pattern optimizer.factorize():str 
address OPTwrapper;
pattern optimizer.generator(mod:str,fcn:str):str 
address OPTwrapper;
comment Sequence generator optimizer

pattern optimizer.generator():str 
address OPTwrapper;
pattern optimizer.garbageCollector(mod:str,fcn:str):str 
address OPTwrapper;
comment Garbage collector optimizer

pattern optimizer.garbageCollector():str 
address OPTwrapper;
pattern optimizer.inline(mod:str,fcn:str):str 
address OPTwrapper;
comment Expand inline functions

pattern optimizer.inline():str 
address OPTwrapper;
pattern optimizer.json(mod:str,fcn:str):str 
address OPTwrapper;
comment Unroll the mat.pack operation

pattern optimizer.json():str 
address OPTwrapper;
pattern optimizer.joinselect(mod:str,fcn:str):str 
address OPTwrapper;
comment Replace select with join select

pattern optimizer.joinselect():str 
address OPTwrapper;
pattern optimizer.matpack(mod:str,fcn:str):str 
address OPTwrapper;
comment Unroll the mat.pack operation

pattern optimizer.matpack():str 
address OPTwrapper;
pattern optimizer.multiplex(mod:str,fcn:str):void 
address OPTwrapper;
comment Compiler for multiplexed instructions.

pattern optimizer.multiplex():void 
address OPTwrapper;
comment Compiler for multiplexed instructions.

pattern optimizer.mitosis(mod:str,fcn:str):str 
address OPTwrapper;
comment Modify the plan to exploit parallel processing on multiple cores

pattern optimizer.mitosis():str 
address OPTwrapper;
pattern optimizer.mergetable(mod:str,fcn:str):str 
address OPTwrapper;
comment Resolve the multi-table definitions

pattern optimizer.mergetable():str 
address OPTwrapper;
pattern optimizer.macro(mod:str,fcn:str,targetmod:str,targetfcn:str):void 
address OPTmacro;
comment Inline a target function used in a specific function.

pattern optimizer.macro(targetmod:str,targetfcn:str):void 
address OPTmacro;
comment Inline the code of the target function.

pattern optimizer.origin(mod:str,fcn:str):str 
address OPTwrapper;
comment OID origin tracker

pattern optimizer.origin():str 
address OPTwrapper;
pattern optimizer.orcam(mod:str,fcn:str,targetmod:str,targetfcn:str):void 
address OPTorcam;
comment Inverse macro, find pattern and replace with a function call.

pattern optimizer.orcam(targetmod:str,targetfcn:str):void 
address OPTorcam;
comment Inverse macro processor for current function

pattern optimizer.optimize(mod:str,fcn:str):void 
address QOToptimize;
comment Optimize a specific operation

pattern optimizer.pushselect(mod:str,fcn:str):str 
address OPTwrapper;
comment Push selects down projections

pattern optimizer.pushselect():str 
address OPTwrapper;
pattern optimizer.prejoin(mod:str,fcn:str):str 
address OPTwrapper;
comment Dead code optimizer

pattern optimizer.prejoin():str 
address OPTwrapper;
pattern optimizer.partitions(mod:str,fcn:str):str 
address OPTwrapper;
comment Experiment with partitioned databases

pattern optimizer.partitions():str 
address OPTwrapper;
pattern optimizer.projectionpath(mod:str,fcn:str):str 
address OPTwrapper;
comment Join path constructor

pattern optimizer.projectionpath():str 
address OPTwrapper;
pattern optimizer.prelude():void 
address optimizer_prelude;
comment Initialize the optimizer

pattern optimizer.profiler(mod:str,fcn:str):str 
address OPTwrapper;
comment Collect properties for the profiler

pattern optimizer.profiler():str 
address OPTwrapper;
pattern optimizer.querylog(mod:str,fcn:str):str 
address OPTwrapper;
comment Collect SQL query statistics

pattern optimizer.querylog():str 
address OPTwrapper;
pattern optimizer.reorder(mod:str,fcn:str):str 
address OPTwrapper;
comment Reorder by dataflow dependencies

pattern optimizer.reorder():str 
address OPTwrapper;
pattern optimizer.remoteQueries(mod:str,fcn:str):str 
address OPTwrapper;
comment Resolve the multi-table definitions

pattern optimizer.remoteQueries():str 
address OPTwrapper;
pattern optimizer.remap(mod:str,fcn:str):str 
address OPTwrapper;
comment Remapping function calls to a their multiplex variant

pattern optimizer.remap():str 
address OPTwrapper;
pattern optimizer.reduce(mod:str,fcn:str):str 
address OPTwrapper;
comment Reduce the stack space claims

pattern optimizer.reduce():str 
address OPTwrapper;
pattern optimizer.recycler(mod:str,fcn:str):str 
address OPTwrapper;
comment Recycler marking and code injection

pattern optimizer.recycler():str 
address OPTwrapper;
pattern optimizer.sql_append(mod:str,fcn:str):str 
address OPTsql_append;
comment Avoid extra BAT copy with sql.append() whenever possible.

pattern optimizer.sql_append():str 
address OPTsql_append;
comment Avoid extra BAT copy with sql.append() whenever possible.

pattern optimizer.selcrack(mod:str,fcn:str):str 
address OPTwrapper;
comment Selection cracking

pattern optimizer.selcrack():str 
address OPTwrapper;
pattern optimizer.showPlan():void 
address QOTshowPlan;
comment Illustrate the plan derived so far

pattern optimizer.showPlan(M:str,F:str,s:str):void 
address QOTshowPlan;
pattern optimizer.showFlowGraph(M:str,F:str,s:str):void 
address QOTshowFlowGraph;
comment Dump the data flow of the function 	M.F in a format recognizable by the 	command 'dot' on the file s

pattern optimizer.setDebug():void 
address QOTdebugOptimizers;
pattern optimizer.trace(mod:str,fcn:str):str 
address OPTwrapper;
comment Collect trace of a specific operation

pattern optimizer.trace():str 
address OPTwrapper;
pattern optimizer.volcano(mod:str,fcn:str):str 
address OPTwrapper;
comment Simulate volcano style execution

pattern optimizer.volcano():str 
address OPTwrapper;
command pcre.imatch(s:str,pat:str):bit 
address PCREimatch;
comment Caseless Perl Compatible Regular Expression pattern matching against a string

command pcre.index(pat:pcre,s:str):int 
address PCREindex;
comment match a pattern, return matched position (or 0 when not found)

command pcre.match(s:str,pat:str):bit 
address PCREmatch;
comment Perl Compatible Regular Expression pattern matching against a string

command pcre.prelude():void 
address pcre_init;
comment Initialize pcre

command pcre.pcre_quote(s:str):str 
address PCREquote;
comment Return a PCRE pattern string that matches the argument exactly.

command pcre.patindex(pat:str,s:str):int 
address PCREpatindex;
comment Location of the first POSIX pattern matching against a string

command pcre.replace(orig:bat[:str],pat:str,repl:str,flag:str):bat[:str] 
address PCREreplace_bat_wrap;
command pcre.replace(origin:str,pat:str,repl:str,flags:str):str 
address PCREreplace_wrap;
comment Replace _all_ matches of "pattern" in "origin_str" with "replacement".	 Parameter "flags" accept these flags: 'i', 'm', 's', and 'x'.	   'e': if present, an empty string is considered to be a valid match	   'i': if present, the match operates in case-insensitive mode.		Otherwise, in case-sensitive mode.	   'm': if present, the match operates in multi-line mode.	   's': if present, the match operates in "dot-all"	   The specifications of the flags can be found in "man pcreapi"	   The flag letters may be repeated.	   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in "flags".	   Returns the replaced string, or if no matches found, the original string.

command pcre.sql2pcre(pat:str,esc:str):str 
address PCREsql2pcre;
comment Convert a SQL like pattern with the given escape character into a PCRE pattern.

command profiler.cpuload(user:lng,nice:lng,sys:lng,idle:lng,iowait:lng) (cycles:int,io:int) 
address CMDcpuloadPercentage;
comment Calculate the average cpu load percentage and io waiting times

command profiler.cpustats() (user:lng,nice:lng,sys:lng,idle:lng,iowait:lng) 
address CMDcpustats;
comment Extract cpu statistics from the kernel

command profiler.cleanup():void 
address CMDcleanupTraces;
comment Remove the temporary tables for profiling

command profiler.closestream():void 
address CMDcloseProfilerStream;
comment Stop offline proviling

command profiler.getSystemTime():lng 
address CMDgetSystemTime;
comment Obtain the user timing information.

command profiler.getUserTime():lng 
address CMDgetUserTime;
comment Obtain the user timing information.

command profiler.getDiskWrites():lng 
address CMDgetDiskWrites;
comment Obtain the number of physical reads

command profiler.getDiskReads():lng 
address CMDgetDiskReads;
comment Obtain the number of physical reads

command profiler.getTrace(e:str):bat[:any_1] 
address CMDgetTrace;
comment Get the trace details of a specific event

command profiler.noop():void 
address CMDnoopProfiler;
comment Fetch any pending performance events

pattern profiler.openstream(mode:int):void 
address CMDopenProfilerStream;
comment Start profiling the events, sent to output stream

command profiler.setheartbeat(b:int):void 
address CMDsetHeartbeat;
comment Set heart beat performance tracing

command profiler.stoptrace():void 
address CMDstopTrace;
comment Stop collecting trace information

command profiler.starttrace():void 
address CMDstartTrace;
comment Start collecting trace information

pattern profiler.stop():void 
address CMDstopProfiler;
comment Stop offline performance profiling

pattern profiler.start():void 
address CMDstartProfiler;
comment Start offline performance profiling

pattern querylog.call(tick1:timestamp,tick2:timestamp,arg:str,tuples:wrd,xtime:lng,rtime:lng,cpu:int,iowait:int):void 
address QLOGcall;
comment Add a new query call to the query log

command querylog.define(q:str,pipe:str,size:int):void 
address QLOGdefineNaive;
comment Noop operation, just marking the query

command querylog.disable():void 
address QLOGdisable;
comment Turn off the query logger

command querylog.empty():void 
address QLOGempty;
comment Clear the query log tables

command querylog.enable():void 
address QLOGenable;
comment Turn on the query logger

command querylog.enable(threshold:int):void 
address QLOGenableThreshold;
comment Turn on the query logger

pattern querylog.insert(q:str,pipe:str,usr:str,tick:timestamp):void 
address QLOGinsert;
comment Add a new query call to the query log

command querylog.isset():int 
address QLOGissetFcn;
comment Return status of query logger

pattern rapi.eval_aggr(fptr:ptr,expr:str,arg:any...):any... 
address RAPIevalAggr;
comment grouped aggregates through R

pattern rapi.eval(fptr:ptr,expr:str,arg:any...):any... 
address RAPIevalStd;
comment Execute a simple R script value

pattern rapi.eval(fptr:ptr,expr:str):any 
address RAPIevalStd;
comment Execute a simple R script returning a single value

command rapi.prelude():void 
address RAPIprelude;
pattern rapi.subeval_aggr(fptr:ptr,expr:str,arg:any...):any... 
address RAPIevalAggr;
comment grouped aggregates through R

pattern remote.bintype():void 
address RMTbintype;
comment print the binary type of this mserver5

pattern remote.batbincopy():bat[:any] 
address RMTbincopyfrom;
comment store the binary BAT data in the BBP and return as BAT

pattern remote.batbincopy(b:bat[:any]):void 
address RMTbincopyto;
comment dump BAT b in binary form to the stream

pattern remote.batload(tt:any_1,size:int):bat[:any_1] 
address RMTbatload;
comment create a BAT of the given type and size, and load values from the input stream

command remote.connect(uri:str,user:str,passwd:str,scen:str):str 
address RMTconnectScen;
comment returns a newly created connection for uri, using user name, password and scenario

command remote.connect(uri:str,user:str,passwd:str):str 
address RMTconnect;
comment returns a newly created connection for uri, using user name and password

command remote.disconnect(conn:str):void 
address RMTdisconnect;
comment disconnects the connection pointed to by handle (received from a call to connect()

pattern remote.exec(conn:str,mod:str,func:str,X_4:str...):str... 
address RMTexec;
comment remotely executes <mod>.<func> using the argument list of remote objects and returns the handle to its result

pattern remote.exec(conn:str,mod:str,func:str,X_4:str...):str 
address RMTexec;
comment remotely executes <mod>.<func> using the argument list of remote objects and returns the handle to its result

pattern remote.exec(conn:str,mod:str,func:str):str... 
address RMTexec;
comment remotely executes <mod>.<func> and returns the handle to its result

pattern remote.exec(conn:str,mod:str,func:str):str 
address RMTexec;
comment remotely executes <mod>.<func> and returns the handle to its result

command remote.epilogue():void 
address RMTepilogue;
comment release the resources held by the remote module

pattern remote.get(conn:str,ident:str):any 
address RMTget;
comment retrieves a copy of remote object ident

command remote.isalive(conn:str):int 
address RMTisalive;
comment check if conn is still valid and connected

pattern remote.put(conn:str,object:any):str 
address RMTput;
comment copies object to the remote site and returns its identifier

command remote.prelude():void 
address RMTprelude;
comment initialise the remote module

pattern remote.register(conn:str,mod:str,fcn:str):void 
address RMTregister;
comment register <mod>.<fcn> at the remote site

command remote.resolve(pattern:str):bat[:str] 
address RMTresolve;
comment resolve a pattern against Merovingian and return the URIs

pattern recycle.append(delta:int,sname:str,tbl:str,col:str,val:any):void 
address RECYCLEappendSQL;
comment Correct recycle pool for SQL append statement

pattern recycle.drop():void 
address RECYCLEdropWrap;
comment Remove the recycle cache

pattern recycle.delete(delta:int,sname:str,tbl:str,col:str):void 
address RECYCLEdeleteSQL;
comment Correct recycle pool for SQL delete statement

pattern recycle.dump():void 
address RECYCLEdumpWrap;
comment Dump summary of recycle table

pattern recycle.reset(bid:bat[:any]):void 
address RECYCLEresetBATwrap;
comment Reset a recycled bat variable

pattern recycle.setCache(clines:int):void 
address RECYCLEsetCache;
comment Set recycler cache line parameter

command sample.subuniform(b:bat[:any],p:dbl):bat[:oid] 
address SAMPLEuniform_dbl;
comment Returns the oids of a uniform sample of size = (p x count(b)), where 0 <= p <= 1.0

command sample.subuniform(b:bat[:any],s:wrd):bat[:oid] 
address SAMPLEuniform;
comment Returns the oids of a uniform sample of size s

command sabaoth.epilogue():void 
address SABepilogue;
comment Release the resources held by the sabaoth module

command sabaoth.getLocalConnectionPort():int 
address SABgetLocalConnectionPort;
comment Returns the port this server can be connected to, or 0 if none

command sabaoth.getLocalConnectionHost():str 
address SABgetLocalConnectionHost;
comment Returns the hostname this server can be connected to, or nil if none

command sabaoth.getLocalConnectionURI():str 
address SABgetLocalConnectionURI;
comment Returns the URI this server can be connected to, or nil if none

command sabaoth.marchConnection(host:str,port:int):void 
address SABmarchConnection;
comment Publishes the given host/port as available for connecting to this server

command sabaoth.marchScenario(lang:str):void 
address SABmarchScenario;
comment Publishes the given language as available for this server

command sabaoth.prelude():void 
address SABprelude;
comment Initialise the sabaoth module

command sabaoth.retreatScenario(lang:str):void 
address SABretreatScenario;
comment Unpublishes the given language as available for this server

pattern scheduler.peers(N:int):void 
address SRVsetServers;
comment Simulate N peers

pattern scheduler.pattern(pat:str):void 
address SRVsetServers;
comment Activate the peers matching the pattern and return number found.

pattern scheduler.srvpool():int 
address SRVPOOLscheduler;
comment Run a program block in parallel.

function sphinx.sphinx_searchIndexLimit(q:str,i:str,l:int):bat[:lng];
function sphinx.sphinx_searchIndex(q:str,i:str):bat[:lng];
function sphinx.sphinx_search(q:str):bat[:lng];
function sphinx.searchIndex(q:str,i:str):bat[:lng];
function sphinx.search(q:str):bat[:lng];
command sphinx.searchIndexLimit(q:str,i:str,l:int):bat[:lng] 
address SPHINXsearchIndexLimit;
comment Search the query on the specified index, with limit

command sql.alpha(dec:dbl,theta:dbl):dbl 
address SQLcst_alpha_cst;
comment Implementation of astronomy alpha function: expands the radius theta depending on the declination

pattern sql.analyze(minmax:int,sample:lng,sch:str,tbl:str,col:str):void 
address sql_analyze;
comment Update the database statistics table

pattern sql.analyze(minmax:int,sample:lng,sch:str,tbl:str):void 
address sql_analyze;
pattern sql.analyze(minmax:int,sample:lng,sch:str):void 
address sql_analyze;
pattern sql.analyze(minmax:int,sample:lng):void 
address sql_analyze;
pattern sql.argRecord(a:any...):str 
address SQLargRecord;
comment Glue together the calling sequence

pattern sql.argRecord():str 
address SQLargRecord;
comment Glue together the calling sequence

pattern sql.affectedRows(mvc:int,nr:wrd):int 
address mvc_affected_rows_wrap;
comment export the number of affected rows by the current query

pattern sql.append(mvc:int,sname:str,tname:str,cname:str,ins:any):int 
address mvc_append_wrap;
comment Append b to the column tname.cname (possibly optimized to replace the insert bat of tname.cname (returns sequence number for order dependence)

pattern sql.assert(b:lng,msg:str):void 
address SQLassertLng;
comment Generate an exception when b!=0

pattern sql.assert(b:wrd,msg:str):void 
address SQLassertWrd;
comment Generate an exception when b!=0

pattern sql.assert(b:int,msg:str):void 
address SQLassertInt;
comment Generate an exception when b!=0

pattern sql.assert(b:bit,msg:str):void 
address SQLassert;
comment Generate an exception when b==true

pattern sql.abort():void 
address SQLabort;
comment Trigger the abort operation for a MAL block

pattern sql.bind(mvc:int,schema:str,table:str,column:str,access:int,part_nr:int,nr_parts:int) (uid:bat[:oid],uval:bat[:any_1]) 
address mvc_bind_wrap;
comment Bind the 'schema.table.column' BAT with access kind:	0 - base table	1 - inserts	2 - updates

pattern sql.bind(mvc:int,schema:str,table:str,column:str,access:int,part_nr:int,nr_parts:int):bat[:any_1] 
address mvc_bind_wrap;
comment Bind the 'schema.table.column' BAT partition with access kind:	0 - base table	1 - inserts	2 - updates

pattern sql.bind(mvc:int,schema:str,table:str,column:str,access:int) (uid:bat[:oid],uval:bat[:any_1]) 
address mvc_bind_wrap;
comment Bind the 'schema.table.column' BAT with access kind:	0 - base table	1 - inserts	2 - updates

pattern sql.bind(mvc:int,schema:str,table:str,column:str,access:int):bat[:any_1] 
address mvc_bind_wrap;
comment Bind the 'schema.table.column' BAT with access kind:	0 - base table	1 - inserts	2 - updates

pattern sql.bind_idxbat(mvc:int,schema:str,table:str,index:str,access:int,part_nr:int,nr_parts:int) (uid:bat[:oid],uval:bat[:any_1]) 
address mvc_bind_idxbat_wrap;
comment Bind the 'schema.table.index' BAT with access kind:	0 - base table	1 - inserts	2 - updates

pattern sql.bind_idxbat(mvc:int,schema:str,table:str,index:str,access:int,part_nr:int,nr_parts:int):bat[:any_1] 
address mvc_bind_idxbat_wrap;
comment Bind the 'schema.table.index' BAT with access kind:	0 - base table	1 - inserts	2 - updates

pattern sql.bind_idxbat(mvc:int,schema:str,table:str,index:str,access:int) (uid:bat[:oid],uval:bat[:any_1]) 
address mvc_bind_idxbat_wrap;
comment Bind the 'schema.table.index' BAT with access kind:	0 - base table	1 - inserts	2 - updates

pattern sql.bind_idxbat(mvc:int,schema:str,table:str,index:str,access:int):bat[:any_1] 
address mvc_bind_idxbat_wrap;
comment Bind the 'schema.table.index' BAT with access kind:	0 - base table	1 - inserts	2 - updates

pattern sql.current_timestamp():timestamp 
address SQLcurrent_timestamp;
comment Get the clients current timestamp

pattern sql.current_time():daytime 
address SQLcurrent_daytime;
comment Get the clients current daytime

pattern sql.copy_rejects_clear():void 
address COPYrejects_clear;
pattern sql.copy_rejects() (rowid:bat[:lng],fldid:bat[:int],msg:bat[:str],inp:bat[:str]) 
address COPYrejects;
pattern sql.copy_from(t:ptr,sep:str,rsep:str,ssep:str,ns:str,fname:str,nr:lng,offset:lng,locked:int,best:int):bat[:any]... 
address mvc_import_table_wrap;
comment Import a table from bstream s with the 	given tuple and seperators (sep/rsep)

pattern sql.create_view_upgrade_oct2014(sname:str,v:str):int 
address UPGcreate_view;
comment Create the view described by f, needed for the Oct2014 upgrade

pattern sql.create_func_upgrade_oct2014(sname:str,f:str):int 
address UPGcreate_func;
comment Create the function described by f, needed for the Oct2014 upgrade

pattern sql.clear_table(sname:str,tname:str):wrd 
address mvc_clear_table_wrap;
comment Clear table

pattern sql.catalog(type:int,sname:str,tname:str,impl:str):void 
address SQLcatalog;
comment a create type catalog statement

pattern sql.catalog(type:int,msname:str,mtname:str,psname:str,ptname:str,action:int):void 
address SQLcatalog;
comment a alter table add/del table catalog statement

pattern sql.catalog(type:int,sname:str,tname:str,access:int):void 
address SQLcatalog;
comment a alter table access statement

pattern sql.catalog(type:int,iname:str,itype:int,sname:str,tname:str...):void 
address SQLcatalog;
comment a create index catalog statement

pattern sql.catalog(type:int,sname:str,func:int,grantee:str,privs:int,grant:int,grantor:int):void 
address SQLcatalog;
comment a grant/revoke function privileges statement

pattern sql.catalog(type:int,sname:str,tname:str,grantee:str,privs:int,cname:str,grant:int,grantor:int):void 
address SQLcatalog;
comment a grant/revoke privileges statement

pattern sql.catalog(type:int,user:str,passwd:str,enc:int,schema:str,fullname:str):void 
address SQLcatalog;
comment a user catalog statement

pattern sql.catalog(type:int,grantee:str,role:str,grantor:int,admin:int):void 
address SQLcatalog;
comment a grant/revoke role statement

pattern sql.catalog(type:int,sname:str,tname:str):void 
address SQLcatalog;
comment a catalog trigger statement

pattern sql.catalog(type:int,sname:str,t:ptr,restart:lng):void 
address SQLcatalog;
comment a catalog statement

pattern sql.catalog(type:int,sname:str,t:ptr,temp:int):void 
address SQLcatalog;
comment a catalog statement

pattern sql.catalog(type:int,sname:str,t:ptr):void 
address SQLcatalog;
comment a catalog statement

pattern sql.catalog(type:int,sname:str,name:str,tname:str,time:int,o:int,event:int,oname:str,nname:str,condition:str,query:str):void 
address SQLcatalog;
comment a catalog statement

pattern sql.catalog(type:int,sname:str,name:str,funcid:int,ft:int,action:int):void 
address SQLcatalog;
comment a catalog statement

pattern sql.catalog(type:int,sname:str,name:str,action:int):void 
address SQLcatalog;
comment a catalog statement

pattern sql.commit():void 
address SQLcommit;
comment Trigger the commit operation for a MAL block

pattern sql.dense_rank(b:any_1,p:bit,o:bit):int 
address SQLdense_rank;
comment return the densely ranked groups

pattern sql.diff(p:bit,b:any_1):bit 
address SQLdiff;
comment return true if cur != prev row

pattern sql.diff(b:any_1):bit 
address SQLdiff;
comment return true if cur != prev row

pattern sql.drop_hash(sch:str,tbl:str):void 
address SQLdrop_hash;
comment Drop hash indices for the given table

command sql.dec_round(v:dbl,r:dbl):dbl 
address dbl_dec_round_wrap;
comment round off the value v to nearests multiple of r

command sql.dec_round(v:flt,r:flt):flt 
address flt_dec_round_wrap;
comment round off the value v to nearests multiple of r

command sql.dec_round(v:lng,r:lng):lng 
address lng_dec_round_wrap;
comment round off the value v to nearests multiple of r

command sql.dec_round(v:wrd,r:wrd):wrd 
address wrd_dec_round_wrap;
comment round off the value v to nearests multiple of r

command sql.dec_round(v:int,r:int):int 
address int_dec_round_wrap;
comment round off the value v to nearests multiple of r

command sql.dec_round(v:sht,r:sht):sht 
address sht_dec_round_wrap;
comment round off the value v to nearests multiple of r

command sql.dec_round(v:bte,r:bte):bte 
address bte_dec_round_wrap;
comment round off the value v to nearests multiple of r

pattern sql.dump_trace() (event:bat[:int],clk:bat[:str],pc:bat[:str],thread:bat[:int],ticks:bat[:lng],rssMB:bat[:lng],vmMB:bat[:lng],reads:bat[:lng],writes:bat[:lng],minflt:bat[:lng],majflt:bat[:lng],nvcsw:bat[:lng],stmt:bat[:str]) 
address dump_trace;
comment dump the trace statistics

pattern sql.dump_opt_stats() (rewrite:bat[:str],count:bat[:int]) 
address dump_opt_stats;
comment dump the optimizer rewrite statistics

pattern sql.dump_cache() (query:bat[:str],count:bat[:int]) 
address dump_cache;
comment dump the content of the query cache

pattern sql.db_users():bat[:str] 
address db_users_wrap;
comment return table of users with sql scenario

pattern sql.drop_func_upgrade_oct2014(id:int):int 
address UPGdrop_func;
comment Drop the function identified by id, needed for the Oct2014 upgrade

pattern sql.dropDeclaredTables(nr:int):void 
address mvc_drop_declared_tables_wrap;
comment drop top n declared tables

pattern sql.dropDeclaredTable(name:str):void 
address mvc_drop_declared_table_wrap;
comment drop a declared table

pattern sql.dtColumn(rs:int,tname:str,name:str,typename:str,digits:int,scale:int):void 
address mvc_declared_table_column_wrap;
pattern sql.declaredTable(name:str):int 
address mvc_declared_table_wrap;
comment Prepare a declared table

pattern sql.delete(mvc:int,sname:str,tname:str,b:any):int 
address mvc_delete_wrap;
comment delete from table

command sql.delta(col:bat[:any_3],uid:bat[:oid],uval:bat[:any_3]):bat[:any_3] 
address DELTAbat2;
comment Return column bat with delta's applied.

command sql.delta(col:bat[:any_3],uid:bat[:oid],uval:bat[:any_3],ins:bat[:any_3]):bat[:any_3] 
address DELTAbat;
comment Return column bat with delta's applied.

command sql.epilogue():void 
address SQLepilogue;
pattern sql.exportOperation():void 
address mvc_export_operation_wrap;
comment Export result of schema/transaction queries

pattern sql.exportChunk(s:streams,res_id:int,offset:int,nr:int):void 
address mvc_export_chunk_wrap;
comment Export a chunk of the result set (in order) to stream s

pattern sql.exportChunk(s:streams,res_id:int):void 
address mvc_export_chunk_wrap;
comment Export a chunk of the result set (in order) to stream s

pattern sql.exportResult(s:streams,res_id:int):void 
address mvc_export_result_wrap;
comment Export a result (in order) to stream s

pattern sql.exportHead(s:streams,res_id:int):void 
address mvc_export_head_wrap;
comment Export a result (in order) to stream s

pattern sql.export_table(fname:str,fmt:str,colsep:str,recsep:str,qout:str,nullrep:str,tbl:bat[:str],attr:bat[:str],tpe:bat[:str],len:bat[:int],scale:bat[:int],cols:bat[:any]...):int 
address mvc_export_table_wrap;
comment Prepare a table result set for the COPY INTO stream

pattern sql.export_table(fname:str,fmt:str,colsep:str,recsep:str,qout:str,nullrep:str,tbl:bat[:str],attr:bat[:str],tpe:bat[:str],len:bat[:int],scale:bat[:int],cols:any...):int 
address mvc_export_row_wrap;
comment Prepare a table result set for the COPY INTO stream

pattern sql.evalAlgebra(cmd:str,optimize:bit):void 
address RAstatement;
comment Compile and execute a single 'relational algebra' statement

pattern sql.eval(cmd:str,output:bit):void 
address SQLstatement;
comment Compile and execute a single sql statement (and optionaly send output on the output stream)

pattern sql.eval(cmd:str):void 
address SQLstatement;
comment Compile and execute a single sql statement

command sql.flush_log():void 
address SQLflush_log;
comment flush the log now

command sql.getVersion(clientid:int):lng 
address mvc_getVersion;
comment Return the database version identifier for a client

pattern sql.get_value(sname:str,sequence:str):lng 
address mvc_get_value;
comment return the current value of the sequence

pattern sql.getVariable(mvc:int,varname:str):any_1 
address getVariable;
comment Get the value of a session variable

pattern sql.importTable(sname:str,tname:str,fname:str...):bat[:any]... 
address mvc_bin_import_table_wrap;
comment Import a table from the files (fname)

pattern sql.include(fname:str):void 
address SQLinclude;
comment Compile and execute a sql statements on the file

pattern sql.init():void 
address SQLinitEnvironment;
comment Initialize the environment for MAL

pattern sql.logfile(filename:str):void 
address mvc_logfile;
comment Enable/disable saving the sql statement traces

command sql.ms_trunc(v:dbl,r:int):dbl 
address dbl_trunc_wrap;
comment truncate the floating point v to r digits behind the dot (if r < 0, before the dot)

command sql.ms_trunc(v:flt,r:int):flt 
address flt_trunc_wrap;
comment truncate the floating point v to r digits behind the dot (if r < 0, before the dot)

pattern sql.mvc():int 
address SQLmvc;
comment Get the multiversion catalog context. Needed for correct statement dependencies(ie sql.update, should be after sql.bind in concurrent execution)

command sql.not_unique(b:bat[:oid]):bit 
address not_unique;
comment check if the tail sorted bat b doesn't have unique tail values

pattern sql.next_value(sname:str,sequence:str):lng 
address mvc_next_value;
comment return the next value of the sequence

pattern sql.optimizer_updates():void 
address SQLoptimizersUpdate;
command sql.optimizers() (X_1:bat[:str],X_2:bat[:str],X_3:bat[:str]) 
address getPipeCatalog;
command sql.prelude():void 
address SQLprelude;
pattern sql.password(user:str):str 
address db_password_wrap;
comment Return password hash of user

command sql.project(col:bat[:oid],l:bat[:oid],r:bat[:oid]):bat[:oid] 
address BATleftproject;
comment Last step of a left outer join, ie project the inner join (l,r) over the left input side (col)

command sql.projectdelta(subselect:bat[:oid],col:bat[:any_3],uid:bat[:oid],uval:bat[:any_3]):bat[:any_3] 
address DELTAproject2;
comment Return column bat with delta's applied.

command sql.projectdelta(subselect:bat[:oid],col:bat[:any_3],uid:bat[:oid],uval:bat[:any_3],ins:bat[:any_3]):bat[:any_3] 
address DELTAproject;
comment Return column bat with delta's applied.

command sql.querylog_disable():void 
address QLOGdisable;
command sql.querylog_enable(thres:int):void 
address QLOGenableThreshold;
command sql.querylog_enable():void 
address QLOGenable;
pattern sql.querylog_empty():void 
address sql_querylog_empty;
pattern sql.querylog_calls() (id:bat[:oid],start:bat[:timestamp],stop:bat[:timestamp],arguments:bat[:str],tuples:bat[:wrd],exec:bat[:lng],result:bat[:lng],cpuload:bat[:int],iowait:bat[:int]) 
address sql_querylog_calls;
comment Obtain the query log calls

pattern sql.querylog_catalog() (id:bat[:oid],user:bat[:str],defined:bat[:timestamp],query:bat[:str],pipe:bat[:str],plan:bat[:str],mal:bat[:int],optimize:bat[:lng]) 
address sql_querylog_catalog;
comment Obtain the query log catalog

pattern sql.rank(b:any_1,p:bit,o:bit):int 
address SQLrank;
comment return the ranked groups

pattern sql.row_number(b:any_1,p:bit,o:bit):int 
address SQLrow_number;
comment return the row_numer-ed groups

pattern sql.reuse(sch:str,tbl:str):void 
address SQLreuse;
comment Consolidate the deletion table over all columns reusing deleted slots

command sql.round(v:dbl,r:bte):dbl 
address dbl_round_wrap;
comment round off the floating point v to r digits behind the dot (if r < 0, before the dot)

command sql.round(v:flt,r:bte):flt 
address flt_round_wrap;
comment round off the floating point v to r digits behind the dot (if r < 0, before the dot)

command sql.round(v:lng,d:int,s:int,r:bte):lng 
address lng_round_wrap;
comment round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)

command sql.round(v:wrd,d:int,s:int,r:bte):wrd 
address wrd_round_wrap;
comment round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)

command sql.round(v:int,d:int,s:int,r:bte):int 
address int_round_wrap;
comment round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)

command sql.round(v:sht,d:int,s:int,r:bte):sht 
address sht_round_wrap;
comment round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)

command sql.round(v:bte,d:int,s:int,r:bte):bte 
address bte_round_wrap;
comment round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)

pattern sql.resultSet(tbl:bat[:str],attr:bat[:str],tpe:bat[:str],len:bat[:int],scale:bat[:int],cols:bat[:any]...):int 
address mvc_table_result_wrap;
comment Prepare a table result set for the client in default CSV format

pattern sql.resultSet(tbl:bat[:str],attr:bat[:str],tpe:bat[:str],len:bat[:int],scale:bat[:int],cols:any...):int 
address mvc_row_result_wrap;
comment Prepare a table result set

pattern sql.resultSet(tbl:str,attr:str,tpe:str,len:int,scale:int,eclass:int,val:any):int 
address mvc_scalar_value_wrap;
comment Prepare a table result set

pattern sql.restart(sname:str,sequence:str,start:lng):lng 
address mvc_restart_seq;
comment restart the sequence with value start

pattern sql.register(mod:str,fname:str,rel_stmt:str,sig:str):int 
address RAstatement2;
comment Compile the relational statement (rel_smt) and register it as mal function, mod.fname(signature)

inline function sql.sql_environment() (name:bat[:str],value:bat[:str]);
pattern sql.shrink(sch:str,tbl:str):void 
address SQLshrink;
comment Consolidate the deletion table over all columns using shrinking

pattern sql.sysmon_stop(tag:lng):void 
address SYSMONstop;
pattern sql.sysmon_stop(tag:int):void 
address SYSMONstop;
pattern sql.sysmon_stop(tag:sht):void 
address SYSMONstop;
pattern sql.sysmon_resume(tag:lng):void 
address SYSMONresume;
pattern sql.sysmon_resume(tag:int):void 
address SYSMONresume;
pattern sql.sysmon_resume(tag:sht):void 
address SYSMONresume;
pattern sql.sysmon_pause(tag:lng):void 
address SYSMONpause;
pattern sql.sysmon_pause(tag:int):void 
address SYSMONpause;
pattern sql.sysmon_pause(tag:sht):void 
address SYSMONpause;
pattern sql.sysmon_queue() (qtag:bat[:lng],user:bat[:str],started:bat[:timestamp],estimate:bat[:timestamp],progress:bat[:int],status:bat[:str],tag:bat[:oid],query:bat[:str]) 
address SYSMONqueue;
pattern sql.storage(sname:str,tname:str,cname:str) (schema:bat[:str],table:bat[:str],column:bat[:str],type:bat[:str],mode:bat[:str],location:bat[:str],count:bat[:lng],atomwidth:bat[:int],columnsize:bat[:lng],heap:bat[:lng],hashes:bat[:lng],phash:bat[:bit],imprints:bat[:lng],sorted:bat[:bit]) 
address sql_storage;
comment return a table with storage information for a particular column

pattern sql.storage(sname:str,tname:str) (schema:bat[:str],table:bat[:str],column:bat[:str],type:bat[:str],mode:bat[:str],location:bat[:str],count:bat[:lng],atomwidth:bat[:int],columnsize:bat[:lng],heap:bat[:lng],hashes:bat[:lng],phash:bat[:bit],imprints:bat[:lng],sorted:bat[:bit]) 
address sql_storage;
comment return a table with storage information for a particular table

pattern sql.storage(sname:str) (schema:bat[:str],table:bat[:str],column:bat[:str],type:bat[:str],mode:bat[:str],location:bat[:str],count:bat[:lng],atomwidth:bat[:int],columnsize:bat[:lng],heap:bat[:lng],hashes:bat[:lng],phash:bat[:bit],imprints:bat[:lng],sorted:bat[:bit]) 
address sql_storage;
comment return a table with storage information for a particular schema 

pattern sql.storage() (schema:bat[:str],table:bat[:str],column:bat[:str],type:bat[:str],mode:bat[:str],location:bat[:str],count:bat[:lng],atomwidth:bat[:int],columnsize:bat[:lng],heap:bat[:lng],hashes:bat[:lng],phash:bat[:bit],imprints:bat[:lng],sorted:bat[:bit]) 
address sql_storage;
comment return a table with storage information 

pattern sql.settimeout(s:lng,t:lng):void 
address CLTsetTimeout;
comment Abort query after s and session after t seconds

pattern sql.settimeout(s:lng):void 
address CLTsetTimeout;
comment Abort query after s seconds

pattern sql.sessions() (user:bat[:str],start:bat[:timestamp],stimeout:bat[:lng],lastcmd:bat[:timestamp],qtimeout:bat[:lng],idle:bat[:bit]) 
address sql_sessions_wrap;
comment SQL export table of active sessions, their timeouts and idle status

pattern sql.sql_variables():bat[:str] 
address sql_variables;
comment return the table with session variables

inline function sql.subzero_or_one(b:bat[:any_1],gp:bat[:oid],gpe:bat[:oid],no_nil:bit):bat[:any_1];
pattern sql.single(x:any_2):bat[:any_2] 
address CMDBATsingle;
command sql.subdelta(col:bat[:oid],cand:bat[:oid],uid:bat[:oid],uval:bat[:oid]):bat[:oid] 
address DELTAsub2;
comment Return a single bat of subselected delta.

command sql.subdelta(col:bat[:oid],cand:bat[:oid],uid:bat[:oid],uval:bat[:oid],ins:bat[:oid]):bat[:oid] 
address DELTAsub;
comment Return a single bat of subselected delta.

pattern sql.setVariable(mvc:int,varname:str,value:any_1):int 
address setVariable;
comment Set the value of a session variable

pattern sql.shutdown(delay:int):str 
address SQLshutdown_wrap;
pattern sql.shutdown(delay:sht):str 
address SQLshutdown_wrap;
pattern sql.shutdown(delay:bte):str 
address SQLshutdown_wrap;
pattern sql.shutdown(delay:int,force:bit):str 
address SQLshutdown_wrap;
pattern sql.shutdown(delay:sht,force:bit):str 
address SQLshutdown_wrap;
pattern sql.shutdown(delay:bte,force:bit):str 
address SQLshutdown_wrap;
pattern sql.start2():void 
address SQLsession2;
comment Switch to processing precompiled sql statements

pattern sql.start():void 
address SQLsession;
comment Switch to processing SQL statements

pattern sql.tid(mvc:int,sname:str,tname:str,part_nr:int,nr_parts:int):bat[:oid] 
address SQLtid;
comment Return the tables tid column.

pattern sql.tid(mvc:int,sname:str,tname:str):bat[:oid] 
address SQLtid;
comment Return the tables tid column.

pattern sql.transaction():void 
address SQLtransaction2;
comment Start an autocommit transaction

pattern sql.trans(type:int,chain:int,name:str):void 
address SQLtransaction;
comment A transaction statement (type can be commit,release,rollback or start)

pattern sql.update(mvc:int,sname:str,tname:str,cname:str,rids:any,upd:any):int 
address mvc_update_wrap;
comment Update the values of the column tname.cname

pattern sql.vacuum(sch:str,tbl:str):void 
address SQLvacuum;
comment Choose an approach to consolidate the deletions

command sql.zero_or_one(col:bat[:any_1]):any_1 
address zero_or_one;
comment if col contains exactly one value return this. Incase of more raise an exception else return nil

command sqlblob.#fromstr():void 
address SQLBLOBfromstr;
command sqlblob.sqlblob(s:str):sqlblob 
address BLOBsqlblob_fromstr;
command sqlblob.sqlblob(s:sqlblob):sqlblob 
address BLOBblob_blob;
comment Noop routine.

command sqlblob.#tostr():void 
address SQLBLOBtostr;
command srvpool.connect(dbname:str):str 
address SRVPOOLconnect;
comment Returns the connection to the server dbname.

pattern srvpool.exec(fname:str,arg:any...):any... 
address SRVPOOLexec;
comment Remote execution of the function on dbname if channel is free.

command srvpool.local(b:bit):void 
address SRVPOOLlocal;
comment Change location from remote to local execution

pattern srvpool.query(plan:str):str... 
address SRVPOOLquery;
comment Allocate a list of servers for query execution

pattern srvpool.reset(dbname:str):str 
address SRVPOOLreset;
comment Clear the server cache

command str.+(l:str,r:str):str 
address STRConcat;
comment Concatenate two strings.

command str.STRepilogue():void 
address strEpilogue;
command str.STRprelude():void 
address strPrelude;
command str.ascii(s:str):int 
address STRascii;
comment Return unicode of head of string

command str.endsWith(s:str,suffix:str):bit 
address STRSuffix;
comment Suffix check.

command str.insert(s:str,start:int,l:int,s2:str):str 
address STRinsert;
comment Insert a string into another

command str.locate(s1:str,s2:str,start:int):int 
address STRlocate2;
comment Locate the start position of a string

command str.locate(s1:str,s2:str):int 
address STRlocate;
comment Locate the start position of a string

command str.like(s:str,pat:str,esc:str):bit 
address STRlikewrap;
comment SQL pattern match function

command str.like(s:str,pat:str):bit 
address STRlikewrap2;
comment SQL pattern match function

command str.lpad(s:str,len:int,s2:str):str 
address STRLpad2;
comment Fill up the first string to the given length prepending characters of the second string.

command str.lpad(s:str,len:int):str 
address STRLpad;
comment Fill up a string to the given length prepending the whitespace character.

command str.ltrim(s:str,s2:str):str 
address STRLtrim2;
comment Remove the longest string containing only characters from the second string from the start of the first string.

command str.ltrim(s:str):str 
address STRLtrim;
comment Strip whitespaces from start of a string.

command str.length(s:str):int 
address STRLength;
comment Return the length of a string.

command str.nbytes(s:str):int 
address STRBytes;
comment Return the string length in bytes.

command str.prefix(s:str,l:int):str 
address STRprefix;
comment Extract the prefix of a given length

command str.replace(origin:str,pat:str,repl:str,flags:str):str 
address PCREreplace_wrap;
command str.repeat(s2:str,c:int):str 
address STRrepeat;
command str.replace(s:str,pat:str,s2:str):str 
address STRreplace;
comment Insert a string into another

command str.rpad(s:str,len:int,s2:str):str 
address STRRpad2;
comment Fill up the first string to the given length appending characters of the second string.

command str.rpad(s:str,len:int):str 
address STRRpad;
comment Fill up a string to the given length appending the whitespace character.

command str.rtrim(s:str,s2:str):str 
address STRRtrim2;
comment Remove the longest string containing only characters from the second string from the end of the first string.

command str.rtrim(s:str):str 
address STRRtrim;
comment Strip whitespaces from end of a string.

command str.r_search(s:str,c:str):int 
address STRReverseStrSearch;
comment Reverse search for a substring. Returns	 position, -1 if not found.

command str.space(l:int):str 
address STRspace;
command str.stringright(s:str,l:int):str 
address STRsuffix;
command str.stringleft(s:str,l:int):str 
address STRprefix;
command str.suffix(s:str,l:int):str 
address STRsuffix;
comment Extract the suffix of a given length

command str.substring(s:str,start:int,len:int):str 
address STRsubstring;
comment Extract a substring from str starting at start, for length len

command str.substring(s:str,start:int):str 
address STRsubstringTail;
comment Extract the tail of a string

command str.substitute(s:str,src:str,dst:str,rep:bit):str 
address STRSubstitute;
comment Substitute first occurrence of 'src' by	'dst'.  Iff repeated = true this is	repeated while 'src' can be found in the	result string. In order to prevent	recursion and result strings of unlimited	size, repeating is only done iff src is	not a substring of dst.

command str.splitpart(s:str,needle:str,field:int):str 
address STRsplitpart;
comment Split string on delimiter. Returns	 given field (counting from one.)

command str.search(s:str,c:str):int 
address STRstrSearch;
comment Search for a substring. Returns	 position, -1 if not found.

command str.startsWith(s:str,prefix:str):bit 
address STRPrefix;
comment Prefix check.

command str.stringlength(s:str):int 
address STRSQLLength;
comment Return the length of a right trimed string (SQL semantics).

command str.string(s:str,offset:int,count:int):str 
address STRSubString;
comment Return substring s[offset..offset+count] of a string s[0..n]

command str.string(s:str,offset:int):str 
address STRTail;
comment Return the tail s[offset..n]	 of a string s[0..n].

command str.str(s:str):str 
address STRtostr;
comment Noop routine.

command str.trim(s:str,s2:str):str 
address STRStrip2;
comment Remove the longest string containing only characters from the second string around the first string.

command str.trim(s:str):str 
address STRStrip;
comment Strip whitespaces around a string.

command str.toUpper(s:str):str 
address STRUpper;
comment Convert a string to upper case.

command str.toLower(s:str):str 
address STRLower;
comment Convert a string to lower case.

command str.unicode(wchar:int):str 
address STRFromWChr;
comment convert a unicode to a character.

command str.unicodeAt(s:str,index:int):int 
address STRWChrAt;
comment get a unicode character	(as an int) from a string position.

command status.batStatistics() (X_1:bat[:str],X_2:bat[:str]) 
address SYSgdkEnv;
comment Show distribution of bats by kind

command status.cpuStatistics() (X_1:bat[:str],X_2:bat[:int]) 
address SYScpuStatistics;
comment Global cpu usage information

command status.getThreads() (X_1:bat[:int],X_2:bat[:str]) 
address SYSgdkThread;
comment Produce overview of active threads

command status.ioStatistics() (X_1:bat[:str],X_2:bat[:int]) 
address SYSioStatistics;
comment Global IO activity information

command status.mem_maxsize(v:lng):void 
address SYSsetmem_maxsize;
comment Set the maximum usable amount of physical swapspace in KB

command status.mem_maxsize():lng 
address SYSgetmem_maxsize;
comment The maximum usable amount of physical swapspace in KB (target only)

command status.mem_cursize():lng 
address SYSgetmem_cursize;
comment The amount of physical swapspace in KB that is currently in use

command status.memUsage(minsize:lng) (X_2:bat[:str],X_3:bat[:lng]) 
address SYSmem_usage;
comment Get a split-up of how much memory blocks are in use

command status.memStatistics() (X_1:bat[:str],X_2:bat[:wrd]) 
address SYSmemStatistics;
comment Global memory usage information

command status.vm_maxsize(v:lng):void 
address SYSsetvm_maxsize;
comment Set the maximum usable amount of physical swapspace in KB

command status.vm_maxsize():lng 
address SYSgetvm_maxsize;
comment The maximum usable amount of logical VM space in KB (target only)

command status.vm_cursize():lng 
address SYSgetvm_cursize;
comment The amount of logical VM space in KB that is currently in use

command status.vmStatistics(minsize:lng) (X_2:bat[:str],X_3:bat[:lng]) 
address SYSvm_usage;
comment Get a split-up of how much virtual memory blocks are in use

command streams.blocked(s:streams):streams 
address open_block_streamwrap;
comment open a block based stream

command streams.close(s:streams):void 
address mnstr_close_streamwrap;
comment close and destroy the stream s

command streams.flush(s:streams):void 
address mnstr_flush_streamwrap;
comment flush the stream

command streams.openWrite(s:streams):streams 
address mnstr_stream_wstreamwrap;
comment convert an ascii stream to binary

command streams.openRead(s:streams):streams 
address mnstr_stream_rstreamwrap;
comment convert an ascii stream to binary

command streams.openWrite(filename:str):streams 
address mnstr_open_wastreamwrap;
comment open ascii file stream for writing

command streams.openRead(filename:str):streams 
address mnstr_open_rastreamwrap;
comment open ascii file stream for reading

command streams.openWriteBytes(filename:str):streams 
address mnstr_open_wstreamwrap;
comment open a file stream for writing

command streams.openReadBytes(filename:str):streams 
address mnstr_open_rstreamwrap;
comment open a file stream for reading

command streams.readInt(s:streams):int 
address mnstr_readIntwrap;
comment read integer data from the stream

command streams.readStr(s:streams):str 
address mnstr_read_stringwrap;
comment read string data from the stream

command streams.socketWrite(skt:int,name:str):streams 
address mnstr_socket_wastreamwrap;
comment open ascii socket stream for writing

command streams.socketRead(skt:int,name:str):streams 
address mnstr_socket_rastreamwrap;
comment open ascii socket stream for reading

command streams.socketWriteBytes(skt:int,name:str):streams 
address mnstr_socket_wstreamwrap;
comment open a socket stream for writing

command streams.socketReadBytes(skt:int,name:str):streams 
address mnstr_socket_rstreamwrap;
comment open a socket stream for reading

command streams.writeInt(s:streams,data:int):void 
address mnstr_writeIntwrap;
comment write data on the stream

command streams.writeStr(s:streams,data:str):void 
address mnstr_write_stringwrap;
comment write data on the stream

pattern sysmon.pause(id:lng):void 
address SYSMONpause;
comment Temporary suspend a single query

pattern sysmon.pause(id:int):void 
address SYSMONpause;
pattern sysmon.pause(id:sht):void 
address SYSMONpause;
pattern sysmon.queue() (tag:bat[:lng],user:bat[:str],started:bat[:timestamp],estimate:bat[:timestamp],progress:bat[:int],status:bat[:str],qrytag:bat[:oid],query:bat[:str]) 
address SYSMONqueue;
pattern sysmon.resume(id:lng):void 
address SYSMONresume;
comment Resume processing 

pattern sysmon.resume(id:int):void 
address SYSMONresume;
pattern sysmon.resume(id:sht):void 
address SYSMONresume;
pattern sysmon.stop(id:lng):void 
address SYSMONstop;
comment Stop a single query a.s.a.p.

pattern sysmon.stop(id:int):void 
address SYSMONstop;
pattern sysmon.stop(id:sht):void 
address SYSMONstop;
command timezone.#fromstr():void 
address tzone_fromstr;
command timezone.str(z:timezone):str 
address MTIMEtzone_tostr;
command timezone.timestamp(secs:int):timestamp 
address MTIMEtimestamp;
comment Utility function to create a timestamp from a number of seconds since the Unix epoch

command timezone.timestamp(s:str):timestamp 
address MTIMEtimestamp_fromstr;
command timezone.#tostr():void 
address tzone_tostr;
pattern timestamp.!=(v:timestamp,w:timestamp):bit 
address CMDvarNE;
comment Equality of two timestamps

pattern timestamp.<=(v:timestamp,w:timestamp):bit 
address CMDvarLE;
comment Equality of two timestamps

pattern timestamp.<(v:timestamp,w:timestamp):bit 
address CMDvarLT;
comment Equality of two timestamps

pattern timestamp.==(v:timestamp,w:timestamp):bit 
address CMDvarEQ;
comment Equality of two timestamps

pattern timestamp.>=(v:timestamp,w:timestamp):bit 
address CMDvarGE;
comment Equality of two timestamps

pattern timestamp.>(v:timestamp,w:timestamp):bit 
address CMDvarGT;
comment Equality of two timestamps

command timestamp.epoch(t:lng):timestamp 
address MTIMEtimestamplng;
comment convert seconds since epoch into a timestamp

command timestamp.epoch(t:int):timestamp 
address MTIMEtimestamp;
comment convert seconds since epoch into a timestamp

command timestamp.epoch(t:timestamp):int 
address MTIMEepoch2int;
comment unix-time (epoch) support: seconds since epoch

command timestamp.epoch():timestamp 
address MTIMEcurrent_timestamp;
comment unix-time (epoch) support: seconds since the Unix epoch

command timestamp.#fromstr():void 
address timestamp_fromstr;
pattern timestamp.isnil(v:timestamp):bit 
address CMDvarISNIL;
comment Nil test for timestamp value

command timestamp.#tostr():void 
address timestamp_tostr;
command timestamp.unix_epoch():timestamp 
address MTIMEunix_epoch;
comment The Unix epoch time (00:00:00 UTC on January 1, 1970)

command tokenizer.append(u:str):oid 
address TKNZRappend;
comment tokenize a new string and append it to the tokenizer (duplicate elimination is performed)

command tokenizer.close():void 
address TKNZRclose;
comment close the current tokenizer store

command tokenizer.depositFile(fnme:str):void 
address TKNZRdepositFile;
comment batch insertion from a file of strings to tokenize, each string is separated by a new line

command tokenizer.getCardinality():bat[:wrd] 
address TKNZRgetCardinality;
comment debugging function that returns the unique tokens at each level

command tokenizer.getCount():bat[:wrd] 
address TKNZRgetCount;
comment debugging function that returns the size of the bats at each level

command tokenizer.getIndex():bat[:oid] 
address TKNZRgetIndex;
comment administrative function that returns the INDEX bat

command tokenizer.getLevel(i:int):bat[:str] 
address TKNZRgetLevel;
comment administrative function that returns the bat on level i

pattern tokenizer.locate(s:str):oid 
address TKNZRlocate;
comment if the given string is in the store returns its oid, otherwise oid_nil

command tokenizer.open(name:str):void 
address TKNZRopen;
comment open the named tokenizer store, a new one is created if the specified name does not exist

pattern tokenizer.take(i:oid):str 
address TKNZRtakeOid;
comment reconstruct and returns the i-th string

command txtsim.editdistance2(s:str,t:str):int 
address levenshteinbasic2_impl;
comment Calculates Levenshtein distance (edit distance) between two strings. Cost of transposition is 1 instead of 2

command txtsim.editdistance(s:str,t:str):int 
address levenshteinbasic_impl;
comment Alias for Levenshtein(str,str)

command txtsim.levenshtein(s:str,t:str):int 
address levenshteinbasic_impl;
comment Calculates Levenshtein distance (edit distance) between two strings

command txtsim.levenshtein(s:str,t:str,insdel_cost:int,replace_cost:int,transpose_cost:int):int 
address levenshtein_impl;
comment Calculates Levenshtein distance (edit distance) between two strings, variable operation costs (ins/del, replacement, transposition)

command txtsim.qgramselfjoin(qgram:bat[:oid],id:bat[:oid],pos:bat[:int],len:bat[:int],c:flt,k:int) (X_7:bat[:int],X_8:bat[:int]) 
address CMDqgramselfjoin;
comment QGram self-join on ordered(!) qgram tables and sub-ordered q-gram positions

command txtsim.qgramnormalize(input:str):str 
address CMDqgramnormalize;
comment 'Normalizes' strings (eg. toUpper and replaces non-alphanumerics with one space

command txtsim.str2qgrams(s:str):bat[:str] 
address CMDstr2qgrams;
comment Break the string into 4-grams

command txtsim.stringdiff(s1:str,s2:str):int 
address stringdiff_impl;
comment calculate the soundexed editdistance

command txtsim.soundex(name:str):str 
address soundex_impl;
comment Soundex function for phonetic matching

command txtsim.similarity(string1:str,string2:str):dbl 
address fstrcmp0_impl;
comment Normalized edit distance between two strings

command txtsim.similarity(string1:str,string2:str,minimum:dbl):dbl 
address fstrcmp_impl;
comment Normalized edit distance between two strings

command udf.fuse(one:int,two:int):lng 
address UDFfuse_int_lng;
comment fuse two (4-byte) int values into one (8-byte) lng value

command udf.fuse(one:sht,two:sht):int 
address UDFfuse_sht_int;
comment fuse two (2-byte) sht values into one (4-byte) int value

command udf.fuse(one:bte,two:bte):sht 
address UDFfuse_bte_sht;
comment fuse two (1-byte) bte values into one (2-byte) sht value

command udf.reverse(ra1:str):str 
address UDFreverse;
comment Reverse a string

command url.#fromstr():void 
address URLfromString;
comment Convert a string to an url. 

command url.getRobotURL(u:url):str 
address URLgetRobotURL;
comment Extract the location of the robot control file

command url.getUser(u:url):str 
address URLgetUser;
comment Extract the user identity from the URL

command url.getQuery(u:url):str 
address URLgetQuery;
comment Extract the query string from the URL

command url.getProtocol(u:url):str 
address URLgetProtocol;
comment Extract the protocol from the URL

command url.getPort(u:url):str 
address URLgetPort;
comment Extract the port id from the URL

command url.getHost(u:url):str 
address URLgetHost;
comment Extract the server name from the URL

command url.getFile(u:url):str 
address URLgetFile;
comment Extract the last file name of the URL

command url.getExtension(u:url):str 
address URLgetExtension;
comment Extract the file extension of the URL

command url.getDomain(u:url):str 
address URLgetDomain;
comment Extract Internet domain from the URL

command url.getContext(u:url):str 
address URLgetContext;
comment Get the path context of a URL

command url.getContent(u:url):str 
address URLgetContent;
comment Get the URL resource in a local file

command url.getBasename(u:url):str 
address URLgetBasename;
comment Extract the URL base file name

command url.getAnchor(u:url):str 
address URLgetAnchor;
comment Extract the URL anchor (reference)

command url.isaURL(u:url):bit 
address URLisaURL;
comment Check conformity of the URL syntax

command url.new(prot:str,host:str,fnme:str):url 
address URLnew3;
comment Construct URL from protocol, host,and file

command url.new(p:str,h:str,prt:int,f:str):url 
address URLnew4;
comment Construct URL from protocol, host, port, and file

command url.#tostr():void 
address URLtoString;
comment Convert url to string equivalent

command url.url(s:url):url 
address URLnoop;
comment Create an URL from a string literal

command url.url(s:str):url 
address URLnew;
comment Create an URL from a string literal

command uuid.#cmp():void 
address UUIDcompare;
command uuid.#fromstr():void 
address UUIDfromString;
command uuid.#hash():void 
address UUIDhash;
command uuid.isaUUID(u:str):bit 
address UUIDisaUUID;
comment Test a string for a UUID format

command uuid.new():uuid 
address UUIDgenerateUuid;
comment Generate a new uuid

command uuid.#null():void 
address UUIDnull;
command uuid.prelude():void 
address UUIDprelude;
command uuid.#read():void 
address UUIDread;
command uuid.str(u:uuid):str 
address UUIDuuid2str;
comment Coerce a uuid to its string type

command uuid.#tostr():void 
address UUIDtoString;
command uuid.uuid(s:str):uuid 
address UUIDstr2uuid;
comment Coerce a string to a uuid, validating its format

command uuid.#write():void 
address UUIDwrite;
command wkba.#cmp():void 
address wkbaCOMP;
command wkba.#del():void 
address wkbaDEL;
command wkba.#fromstr():void 
address wkbaFROMSTR;
command wkba.#heap():void 
address wkbaHEAP;
command wkba.#hash():void 
address wkbaHASH;
command wkba.#length():void 
address wkbaLENGTH;
command wkba.#null():void 
address wkbaNULL;
command wkba.#put():void 
address wkbaPUT;
command wkba.#read():void 
address wkbaREAD;
command wkba.#tostr():void 
address wkbaTOSTR;
command wkba.#write():void 
address wkbaWRITE;
command wkb.#cmp():void 
address wkbCOMP;
command wkb.#del():void 
address wkbDEL;
command wkb.#fromstr():void 
address wkbFROMSTR;
command wkb.#heap():void 
address wkbHEAP;
command wkb.#hash():void 
address wkbHASH;
command wkb.#length():void 
address wkbLENGTH;
command wkb.#null():void 
address wkbNULL;
command wkb.#put():void 
address wkbPUT;
command wkb.#read():void 
address wkbREAD;
command wkb.#tostr():void 
address wkbTOSTR;
command wkb.#write():void 
address wkbWRITE;
command xml.aggr(val:bat[:xml]):xml 
address BATXMLgroup;
comment Aggregate the XML values.

command xml.attribute(name:str,val:str):xml 
address XMLattribute;
comment Construct an attribute value pair

command xml.concat(val1:xml,val2:xml):xml 
address XMLconcat;
comment Concatenate the xml values

command xml.content(val:str):xml 
address XMLcontent;
comment Check the value for compliance as content, i.e.  it may contain multiple roots and character data.

command xml.comment(val:str):xml 
address XMLcomment;
comment Construct an comment struction 

command xml.document(val:str):xml 
address XMLdocument;
comment Check the value for compliance as XML document

command xml.element(name:str,s:xml):xml 
address XMLelementSmall;
comment The basic building block for XML elements are namespaces, attributes and a sequence of xml elements. The name space and the attributes may be left unspecified(=nil:bat).

command xml.element(name:str,ns:xml,attr:xml,s:xml):xml 
address XMLelement;
comment The basic building block for XML elements are namespaces, attributes and a sequence of xml elements. The name space and the attributes may be left unspecified(=nil:bat).

pattern xml.forest(val:xml...):xml 
address XMLforest;
comment Construct an element list

command xml.#fromstr():void 
address XMLfromString;
comment Convert a string to an xml.

command xml.isdocument(val:str):bit 
address XMLisdocument;
comment Validate the string as a document

command xml.prelude():void 
address XMLprelude;
command xml.pi(target:str,val:str):xml 
address XMLpi;
comment Construct a processing instruction

command xml.parse(doccont:str,val:str,option:str):xml 
address XMLparse;
comment Parse the XML document or element string values 

command xml.root(val:xml,version:str,standalone:str):xml 
address XMLroot;
comment Construct the root nodes

command xml.subaggr(val:bat[:xml],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit):bat[:xml] 
address AGGRsubxmlcand;
comment Grouped aggregation of XML values with candidates list.

command xml.subaggr(val:bat[:xml],g:bat[:oid],e:bat[:any_1],skip_nils:bit):bat[:xml] 
address AGGRsubxml;
comment Grouped aggregation of XML values.

command xml.str(src:xml):str 
address XMLxml2str;
comment Cast the string to an xml compliant string

command xml.text(src:xml):str 
address XMLxmltext;
comment Extract text from an xml atom

command xml.#tostr():void 
address XMLtoString;
comment Convert xml to string equivalent

command xml.xml(src:str):xml 
address XMLstr2xml;
comment Cast the string to an xml compliant string

command zorder.decode_y(z:bat[:oid]):bat[:int] 
address ZORDbatdecode_int_oid_y;
comment Derive the z-order y-coordinate

command zorder.decode_y(z:oid):int 
address ZORDdecode_int_oid_y;
comment Derive the z-order y-coordinate

command zorder.decode_x(z:bat[:oid]):bat[:int] 
address ZORDbatdecode_int_oid_x;
comment Derive the z-order x-coordinate

command zorder.decode_x(z:oid):int 
address ZORDdecode_int_oid_x;
comment Derive the z-order x-coordinate

command zorder.decode(z:bat[:oid]) (X_2:bat[:int],X_3:bat[:int]) 
address ZORDbatdecode_int_oid;
comment Derive the z-order pair

command zorder.decode(z:oid) (x:int,y:int) 
address ZORDdecode_int_oid;
comment Derive the z-order pair

command zorder.encode(x:bat[:int],y:bat[:int]):bat[:oid] 
address ZORDbatencode_int_oid;
comment Derive the z-order index from a value pair

command zorder.encode(x:int,y:int):oid 
address ZORDencode_int_oid;
comment Derive the z-order index from a value pair

command zorder.slice(xb:int,yb:int,xt:int,yt:int):bat[:oid] 
address ZORDslice_int;
comment Extract the Z-order indices between two points

command zrule.define(m:int,d:str,w:int,min:int):zrule 
address MTIMEruleDef2;
comment Introduce a synomym timezone rule.

command zrule.define(m:int,d:str,w:int,h:int,min:int):zrule 
address MTIMEruleDef1;
comment Introduce a synomym timezone rule.

command zrule.define(m:int,d:int,w:int,h:int,min:int):zrule 
address MTIMEruleDef0;
comment Introduce a synomym timezone rule.

command zrule.#fromstr():void 
address rule_fromstr;
command zrule.#tostr():void 
address rule_tostr;

# 21:33:51 >  
# 21:33:51 >  "Done."
# 21:33:51 >  

