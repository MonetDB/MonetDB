@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@a Sjoerd Mullender, based on code by M. Kersten and Peter Boncz and Niels Nes
@v 5
@f MapiClient
@* The Mapi Client interface 
A textual interface to the Monet server using the Mapi library,
providing command-line access for its users. It is the preferred
interface for non-DBAs.

@+ Manual Page
The @code{MapiClient} program provides a textual
interface to the MonetDB server. Unlike the Mserver console, the
@code{MapiClient} program is intended not only for the database
administrator, but for all users. It is more comfortable than the
console, since it provides a command history and automatic file name
completion. 

@verbatim
MapiClient [options] [inputfile+]
@end verbatim

The following options are supported:

@multitable @columnfractions .25 .25 .25 @verb @verb @verb
@item -b t/f      
@tab --blocked=true/false
@tab blocked mode 
@item -e          
@tab --error          
@tab exit on error 
@item -h hostname 
@tab --host=hostname  
@tab host to connect to 
@item -l language 
@tab --language=lang  
@tab {mal,sql,mil} 
@item -P passwd   
@tab --passwd=passwd  
@tab password 
@item -p portnr   
@tab --port=portnr    
@tab port to connect to 
@item -s stmt     
@tab --statement=stmt 
@tab run single statement 
@item -t          
@tab --trace
@tab trace mapi network interaction
@item -T          
@tab --time           
@tab time commands 
@item -u user     
@tab --user=user      
@tab user id 
@item -H          
@tab --history        
@tab load/save cmdline history (default off) 
@item -?          
@tab --help           
@tab show this usage message 
@end multitable

Calling "MapiClient -l sql" establishes a SQL connection with an
Mserver server running on the local machine. The default user
'monetdb' is used, which provides administrative rights.
To protect your database you may want to introduce another DBA name and
limit the access permisions of 'monetdb' to the level of a guest account.

@{
@+ Implementation
@c
#include "clients_config.h"
#include <monet_options.h>
#include "Mapi.h"
#include <unistd.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#ifdef HAVE_LIBREADLINE
#include <readline/readline.h>
#include <readline/history.h>
#include "ReadlineTools.h"
#endif
#include "msqldump.h"
#include "mprompt.h"

#ifndef S_ISCHR
#define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
#endif

#ifdef NATIVE_WIN32
/* Windows doesn't declare chdir, even though it does provide the function */
extern int chdir(const char *);
#define strdup _strdup
#endif

#ifndef HAVE_GETLOGIN
#define getlogin() "win32"
#endif

static FILE *toConsole;
static char *language = "mil";

char *command = NULL;

static long t0, t1;		/* used for timing */
static char *mark, *mark2;

/* stolen piece */
#ifdef HAVE_FTIME
#include <sys/timeb.h>
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

static long
gettime(void)
{
#ifdef HAVE_GETTIMEOFDAY
	struct timeval tp;

	gettimeofday(&tp, NULL);
	return (long) tp.tv_sec * 1000000 + (long) tp.tv_usec;
#else
#ifdef HAVE_FTIME
	struct timeb tb;

	ftime(&tb);
	return (long) tb.time * 1000000 + (long) tb.millitm * 1000;
#endif
#endif
}

static void
timerStart(void)
{
	t0 = gettime();
}

static void
timerEnd(void)
{
	t1 = gettime();
	if (mark) {
		fprintf(toConsole, "%s % 7ld.%03ld msec %s\n", mark, (t1 - t0) / 1000, (t1 - t0) % 1000, mark2 ? mark2 : "");
		fflush(toConsole);
	}
}

static int
doRequest(Mapi mid, const char *buf, int interactive)
{
	MapiHdl hdl;

	if ((hdl = mapi_quick_query(mid, buf, toConsole)) == NULL) {
		mapi_explain(mid, stderr);
		return 1;
	}
	if (mapi_result_error(hdl)) {
		mapi_explain_result(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	if (! (mapi_get_active(mid) && interactive ))
		mapi_close_handle(hdl);
	return 0;
}

#define CHECK_RESULT(mid, hdl, buf, break_or_continue)			\
		switch (mapi_error(mid)) {				\
		case MOK:						\
			/* everything A OK */				\
			break;						\
		case MERROR:						\
			/* some error, but try to continue */		\
			if (hdl) {					\
				mapi_explain_query(hdl, stderr);	\
				mapi_close_handle(hdl);			\
				hdl = NULL;				\
			} else						\
				mapi_explain(mid, stderr);		\
			break_or_continue;				\
		case MTIMEOUT:						\
			/* lost contact with the server */		\
			if (hdl) {					\
				mapi_explain_query(hdl, stderr);	\
				mapi_close_handle(hdl);			\
				hdl = NULL;				\
			} else						\
				mapi_explain(mid, stderr);		\
			timerEnd();					\
			free(buf);					\
			return 1;					\
		}

static int
doFile(Mapi mid, const char *file, int xquery)
{
	FILE *fp;
	char *buf = NULL;
	size_t length;
	MapiHdl hdl = NULL;
	MapiMsg rc = MOK;
	int bufsize = 0;

	if (file == NULL)
		fp = stdin;
	else if ((fp = fopen(file, "r")) == NULL) {
		fprintf(stderr, "%s: cannot open\n", file);
		return 1;
	}

	bufsize = BUFSIZ;
	buf = malloc(bufsize);
	if (!buf) {
		fprintf(stderr, "cannot allocate memory for send buffer\n");
		if (file != NULL)
			fclose(fp);
		return 1;
	}

	timerStart();
	do {
		if ((length = fread(buf, 1, bufsize, fp)) == 0) {
			/* end of file */
			if (file != NULL) {
				fclose(fp);
				file = NULL;
			}
			if (hdl == NULL) {
				/* nothing more to do */
				timerEnd();
				free(buf);
				return 0;
			}
			/* hdl != NULL, we should finish the current query */
		}

		if (hdl == NULL) {
			hdl = mapi_query_prep(mid);
			CHECK_RESULT(mid, hdl, buf, continue);
		}
		if (length > 0) {
			assert(hdl != NULL);
			mapi_query_part(hdl, buf, length);
			CHECK_RESULT(mid, hdl, buf, continue);

			/* in case of xquery; do the whole file in one go */
			if (xquery && !feof(fp))
				continue;
		}

		assert(hdl != NULL);
		/* If the server wants more but we're at the end of
		   file (length == 0), notify the server that we
		   don't have anything more.  If the server still
		   wants more (shouldn't happen according to the
		   protocol) we break out of the loop (via the
		   continue).  The assertion at the end will then go
		   off. */
		if (mapi_query_done(hdl) == MMORE &&
		    (length > 0 || mapi_query_done(hdl) == MMORE))
			continue;	/* get more data */

		CHECK_RESULT(mid, hdl, buf, continue);

		do {
			char *reply;

			if ((reply = mapi_result_error(hdl)) != NULL)
				mapi_explain_result(hdl, stderr);
			if (mapi_get_querytype(hdl) == Q_UPDATE) {
				fprintf(toConsole, "[ %d\t]\n",
					mapi_rows_affected(hdl));
			} else {
				while ((reply = mapi_fetch_line(hdl)) != NULL) {
					if (xquery && *reply == '=')
						reply++;
					fprintf(toConsole, "%s\n", reply);
				}
			}
		} while ((rc = mapi_needmore(hdl)) == MOK && (rc = mapi_next_result(hdl)) == 1);
		if (rc == MMORE && (length > 0 || mapi_query_done(hdl) != MOK))
			continue;	/* get more data */

		CHECK_RESULT(mid, hdl, buf, continue);

		mapi_close_handle(hdl);
		hdl = NULL;

	} while (length > 0);
	/* reached on end of file */
	assert(hdl == NULL);
	timerEnd();

	free(buf);
	if (file != NULL) fclose(fp);
	fflush(stdout);
	return 0;
}

static void
showCommands(void)
{
	fprintf(toConsole, "?\t - show this message\n");
	fprintf(toConsole, "?text\t - send help message\n");
	fprintf(toConsole, "!\t - shell escape\n");
	fprintf(toConsole, "<file\t - read input from file\n");
	fprintf(toConsole, ">file\t - save response in file\n");
	fprintf(toConsole, ">\t - response to terminal\n");
	fprintf(toConsole, "cd\t - change directory\n");
	fprintf(toConsole, "\\l\t- line is sent immediately\n");
	fprintf(toConsole, "\\q\t- terminate session\n");
	fprintf(toConsole, "\\T\t- toggle timer\n");
	fprintf(toConsole, "\\D\t- dump database\n");
	fprintf(toConsole, "\\Dtable\t- dump table\n");
	fprintf(toConsole, "\\A\t- enable auto commit\n");
	fprintf(toConsole, "\\a\t- disable auto commit\n");
	fprintf(toConsole, "\\t\t- toggle interaction trace\n");
}

static int
doFileByLines(Mapi mid, FILE *fp, const char *prompt, int linemode, int exit_on_error, int xquery)
{
	char *line = NULL;
	char *buf = NULL;
	size_t length;
	MapiHdl hdl = mapi_get_active(mid);
	MapiMsg rc = MOK;
	int sent = 0;		/* whether we sent any data to the server */

#ifdef HAVE_LIBREADLINE
	if (prompt == NULL)
#endif
		buf = malloc(BUFSIZ);

	do {
#ifdef HAVE_LIBREADLINE
		if (prompt) {
			rl_completion_func_t *func = NULL;

			if (buf)
				free(buf);
			if (hdl)
				func = suspend_completion();
			buf = readline(hdl ? "more>" : prompt);
			if (hdl)
				continue_completion(func);
			/* add a newline to the end since that makes
			   further processing easier */
			if (buf) {
				add_history(buf);
				length = strlen(buf);
				buf = realloc(buf, length + 2);
				buf[length++] = '\n';
				buf[length] = 0;
			}
			line = buf;
		} else
#endif
		{
#ifndef HAVE_LIBREADLINE
			if (prompt) {
				fputs(hdl ? "more>" : prompt, stdout);
				fflush(stdout);
			}
#endif
			line = fgets(buf, BUFSIZ, fp);
		}
		if (line == NULL) {
			/* end of file */
			if (hdl == NULL) {
				/* nothing more to do */
				return 0;
			}
			/* hdl != NULL, we should finish the current query */
			line = NULL;
			length = 0;
		} else
			length = strlen(line);

		if (length > 0 && (!linemode || (hdl == NULL && length > 0 && line[length - 1] == '\n'))) {
			/* test for special commands */
			while (length > 0 &&
			       (*line & ~0x7F) == 0 &&
			       isspace((int) *line)) {
				line++;
				length--;
			}
			/* in the switch, use continue if the line was
			   processed, use break to send to server */
			switch (*line) {
			case '\0':
				/* empty line */
				break;
			case '\\':
				switch (line[1]) {
				case 'q':
					free(buf);
					return 0;
				case 'T':
					mark = mark ? NULL : "Timer";
					if (mark2)
						free(mark2);
					mark2 = strdup(line + 2);
					continue;
				case 't':
					/* toggle interaction trace */
					mapi_trace(mid, !mapi_get_trace(mid));
					continue;
				case 'l':
					linemode = 1;
					line = "";
					length = 0;
					continue;
				case 'b':
					linemode = 0;
					continue;
				case 'A':
					mapi_setAutocommit(mid, 1);
					continue;
				case 'a':
					mapi_setAutocommit(mid, 0);
					continue;
				case 'D':
					if (line[length - 1] == '\n')
						line[--length] = 0;
					if (line[length - 1] == '\r')
						line[--length] = 0;
					if (line[2]) {
						dump_table(mid, line + 2, toConsole);
						fprintf(toConsole, "COMMIT\n");
					} else {
						dump_tables(mid, toConsole);
					}
					continue;
				default:
					break;
				}
				break;
			case '<':
				/* read commands from file */
				if (line[length - 1] == '\n')
					line[--length] = 0;
				if (line[length - 1] == '\r')
					line[--length] = 0;
				doFile(mid, line + 1, 0);
				continue;
			case '>':
				/* redirect output to file */
				line++;
				length--;
				if (line[length - 1] == '\n')
					line[--length] = 0;
				if (line[length - 1] == '\r')
					line[--length] = 0;
				if (toConsole != stdout && toConsole != stderr)
					fclose(toConsole);
				if (length == 0 || strcmp(line, "stdout") == 0)
					toConsole = stdout;
				else if (strcmp(line, "stderr") == 0)
					toConsole = stderr;
				else if ((toConsole = fopen(line, "w")) == NULL) {
					toConsole = stdout;
					fprintf(stderr, "Cannot open %s\n", line);
				}
				continue;
			case 'c':	/* cd command? */
				if (line[1] == 'd' &&
				    (line[2] & ~0x7F) == 0 &&
				    isspace((int) line[2])) {
					if (line[length - 1] == '\n')
						line[--length] = 0;
					if (line[length - 1] == '\r')
						line[--length] = 0;
					if (chdir(line + 3) < 0)
						perror(line);
					continue;
				}
				break;
			case '?':
				if (!isspace((int)line[1]))
					break;
				else
					showCommands();
				continue;
			}
		}

		if (hdl == NULL) {
			timerStart();
			hdl = mapi_query_prep(mid);
			CHECK_RESULT(mid, hdl, buf, continue);
		}
		if (length > 0) {
			assert(hdl != NULL);
			sent = 1;
			mapi_query_part(hdl, line, length);
			CHECK_RESULT(mid, hdl, buf, continue);
		}
		if (linemode) {
			assert(hdl != NULL);
			/* If the server wants more but we're at the
			   end of file (line == NULL), notify the
			   server that we don't have anything more.
			   If the server still wants more (shouldn't
			   happen according to the protocol) we break
			   out of the loop (via the continue).  The
			   assertion at the end will then go off.

			   Note that XQuery is weird: we continue
			   sending more until we reach end-of-file,
			   and *then* we send the mapi_query_done.  To
			   exit, you need to send an end-of-file
			   again. */
			if (xquery || mapi_query_done(hdl) == MMORE) {
			   	if (line != NULL) {
					continue;	/* get more data */
			   	} else if (mapi_query_done(hdl) == MMORE) {
					assert(!xquery); /* XQuery never sends MMORE */
					hdl = NULL;
					continue;	/* done */
				}
			}
			CHECK_RESULT(mid, hdl, buf, continue);

			do {
				char *reply;

				if ((reply = mapi_result_error(hdl)) != NULL) {
					mapi_explain_result(hdl, stderr);
					if (exit_on_error) {
						timerEnd();
						return 1;
					}
				}
				if (mapi_get_querytype(hdl) == Q_UPDATE) {
					fprintf(toConsole, "[ %d\t]\n",
						mapi_rows_affected(hdl));
				} else {
					while ((reply = mapi_fetch_line(hdl)) != NULL) {
						if (xquery && *reply == '=')
							reply++;
						fprintf(toConsole, "%s\n", reply);
					}
				}
			} while ((rc = mapi_needmore(hdl)) == MOK && (rc = mapi_next_result(hdl)) == 1);
			if (rc == MMORE && (line != NULL || mapi_query_done(hdl) != MOK))
				continue;	/* get more data */

			CHECK_RESULT(mid, hdl, buf, continue);

			timerEnd();
			mapi_close_handle(hdl);
			hdl = NULL;
		}
		/* for XQuery, only exit when end-of-file and we
		   didn't send any data */
	} while (line != NULL || (xquery && sent));
	/* reached on end of file */
	assert(hdl == NULL);
	return 0;
}

static void
usage(const char *prog)
{
	fprintf(stderr, "Usage: %s [ options ]\n", prog);
	fprintf(stderr, "Options are:\n");
	fprintf(stderr, " -b t/f      | --blocked=true/false /* blocked mode */\n");
	fprintf(stderr, " -c config   | --config=file    /* config filename */\n");
	fprintf(stderr, " -C colname  | --collection=name /* collection name */\n");
	fprintf(stderr, " -e          | --error          /* exit on error */\n");
	fprintf(stderr, " -H          | --history        /* load/save cmdline history (default off) */\n");
	fprintf(stderr, " -h hostname | --host=hostname  /* host to connect to */\n");
	fprintf(stderr, " -i          | --interactive    /* read stdin after command line args */\n");
	fprintf(stderr, " -l language | --language=lang  /* {mal,sql,mil,xquery} */\n");
	fprintf(stderr, " -P passwd   | --passwd=passwd  /* password */\n");
	fprintf(stderr, " -p portnr   | --port=portnr    /* port to connect to */\n");
	fprintf(stderr, " -d database | --database=database /* database to connect to */\n");
	fprintf(stderr, " -o format   | --output=format  /* output format for xquery (dm (default) or xml) */\n");
	fprintf(stderr, " -q          | --quiet          /* don't print welcome message */\n");
	fprintf(stderr, " -s stmt     | --statement=stmt /* run single statement */\n");
	fprintf(stderr, " -T          | --time           /* time commands */\n");
	fprintf(stderr, " -t          | --trace          /* trace mapi network interaction */\n");
	fprintf(stderr, " -u user     | --user=user      /* user id */\n");
	fprintf(stderr, " -?          | --help           /* show this usage message */\n");
	exit(-1);
}

/* hardwired defaults, only used if monet environment cannot be found */
#define defaultPort 50000	

int
main(int argc, char **argv)
{
	opt *set = NULL;
	int setlen;
	int port = 0;
	char *user = NULL;
	char *passwd = NULL;
	char *host = NULL;
	char *dbname = NULL;
	char *output = NULL;
	char *input = NULL;
	char *colname = NULL;
	int trace = 0;
	int guest = 1;
	int linemode = 1;
	int exit_on_error = 0;
	int c = 0;
	Mapi mid;
	int quiet = 0;
	int save_history = 0;
	int interactive = 0;
	static struct option long_options[] = {
		{"blocked", 1, 0, 'b'},
		{"config", 1, 0, 'c'},
		{"collection", 1, 0, 'C'},
		{"error", 0, 0, 'e'},
		{"interactive", 0, 0, 'i'},
		{"input", 1, 0, 'i'},
		{"host", 1, 0, 'h'},
		{"language", 1, 0, 'l'},
		{"output", 1, 0, 'o'},
		{"passwd", 2, 0, 'P'},
		{"port", 1, 0, 'p'},
		{"database", 1, 0, 'd'},
		{"set", 1, 0, 'S'},
		{"statement", 1, 0, 's'},
		{"time", 0, 0, 'T'},
		{"trace", 2, 0, 't'},
		{"user", 2, 0, 'u'},
		{"history", 0, 0, 'H'},
		{"quiet", 0, 0, 'q'},
		{"help", 0, 0, '?'},
		{0, 0, 0, 0}
	};

	toConsole = stdout;
	mark = NULL;
	mark2 = NULL;

	if ((setlen = mo_builtin_settings(&set)) == 0)
		usage(argv[0]);

	while ((c = getopt_long(argc, argv, "b:c:C:ei::l:u::p:o:P::d:qHh:s:Dt::TX:?", long_options, NULL)) != -1) {
		switch (c) {
		case 'b':
			if (*optarg == 't' || *optarg == 'T' || *optarg == '1')
				linemode = 0;
			else if (*optarg == 'f' || *optarg == 'F' || *optarg == '0')
				linemode = 1;
			else
				usage(argv[0]);
			break;
		case 'c':
			setlen = mo_add_option(&set, setlen, opt_cmdline, "config", optarg);
			break;
		case 'C':
			colname = optarg;
			break;
		case 'e':
			exit_on_error = 1;
			break;
		case 'l':
			/* accept unambiguous prefix of language */
			if (strcmp(optarg, "sql") == 0 ||
			    strcmp(optarg, "sq") == 0 ||
			    strcmp(optarg, "s") == 0) {
				language = "sql";
			} else if (strcmp(optarg, "mil") == 0 ||
				   strcmp(optarg, "mi") == 0) {
				language = "mil";
			} else if (strcmp(optarg, "mal") == 0 ||
				   strcmp(optarg, "ma") == 0) {
				language = "mal";
			} else if (strcmp(optarg, "xquery") == 0 ||
				   strcmp(optarg, "xquer") == 0 ||
				   strcmp(optarg, "xque") == 0 ||
				   strcmp(optarg, "xqu") == 0 ||
				   strcmp(optarg, "xq") == 0 ||
				   strcmp(optarg, "x") == 0) {
				language = "xquery";
			} else {
				fprintf(stderr, "language option needs to be one of sql, mil, mal, or xquery\n");
				exit(-1);
			}
			break;
		case 'u':
			guest = 0;
			user = optarg; /* can be NULL */
			break;
		case 'P':
			guest = 0;
			passwd = optarg; /* can be NULL */
			break;
		case 'i':
			interactive = 1;
			if (optarg)
				input = optarg;
			break;
		case 'h':
			host = optarg;
			break;
		case 'o':
			output = optarg;
			break;
		case 'p':
			port = atoi(optarg);
			setlen = mo_add_option(&set, setlen, opt_cmdline, "port", optarg);
			break;
		case 'd':
			dbname = optarg;
			break;
		case 's':
			command = optarg;
			break;
		case 'q':
			quiet = 1;
			break;
		case 'T':
			mark = "Timer";
			break;
		case 't':
			trace = MAPI_TRACE;
			break;
		case 'S':{
			char *eq = strchr(optarg, '=');

			if (eq)
				*eq = 0;
			setlen = mo_add_option(&set, setlen, opt_cmdline, optarg, eq ? eq + 1 : "");
			if (eq)
				*eq = '=';
			break;
		}
		case 'H':
			save_history = 1;
			break;
		case '?':
			usage(argv[0]);
		default:
			usage(argv[0]);
		}
	}

	setlen = mo_system_config(&set, setlen);

	if (port == 0) {
		char *s = "mapi_port";
                int p = defaultPort;

		if ((s = mo_find_option(set, setlen, s)) != NULL) {
			port = strtol(s, NULL, 10);
		} else {
			port = p;
		}
	}

	if (strcmp(language, "xquery") == 0 && output == NULL) {
		output = mo_find_option(set, setlen, "xquery_output");
	}

	if (host == NULL) {
		host = mo_find_option(set, setlen, "host");
		if (host == NULL)
			host = "localhost";
	}

	/* default to administrator account (eeks) when being called without
	 * any arguments, default to the current user if -u flag is given */
	if (guest) {
		user = "monetdb";
		passwd = "monetdb";
	} else {
		if (user == NULL)
			user = simple_prompt("User ", BUFSIZ, 1, getlogin());
		if (passwd == NULL)
			passwd = simple_prompt("Password", BUFSIZ, 0, NULL);
	}

	mid = mapi_connect(host, port, user, passwd, language, dbname);
	if (mid == NULL) {
		fprintf(stderr, "failed to allocate Mapi structure\n");
		exit(2);
	}
	if (mapi_error(mid)) {
		mapi_explain(mid, stderr);
		exit(2);
	}
	if (!quiet) {
		char *motd = mapi_get_motd(mid);

		if (motd)
			printf("%s", motd);
	}
	mapi_profile(mid, mark!=NULL);
	mapi_trace(mid, trace);
	if (output)
		mapi_output(mid, output);

	c = 0;

	/* we're interactive if explicit or if no files and no -s option
	   we're also interactive if no files */
	interactive |= (optind == argc && command == NULL);

	if (command) {
		/* execute from command-line */
		c = doRequest(mid, command, interactive);
		command = NULL;
	}
	if (optind < argc) {
		/* execute from file(s) */
		while (optind < argc) {
			c |= doFile(mid, argv[optind], strcmp(language, "xquery") == 0);
			optind++;
		}
	}
	if (interactive) {
		/* execute from stdin */
		struct stat statb;
		char *prompt = NULL;
		char promptbuf[16];
		int interactive_stdin = 0;

		if (fstat(fileno(stdin), &statb) == 0 && S_ISCHR(statb.st_mode)) {
			interactive_stdin = 1;
		}
		if (interactive_stdin) { 
#ifdef HAVE_LIBREADLINE
			init_readline(mid, language, save_history);
#else
			(void)save_history; /* pacify compiler */
#endif
			/* reading from terminal, prepare prompt */
			sprintf(promptbuf, "%.*s>", (int) sizeof(promptbuf) - 2, language);
			prompt = promptbuf;
		}
		/* stream xml document into the server */
		if (input && strcmp(language, "xquery") == 0) {
			mapi_stream_into(mid, input, colname);
			c = doFile(mid, NULL, strcmp(language, "xquery") == 0);
		} else {
			c = doFileByLines(mid, stdin, prompt, linemode, exit_on_error, strcmp(language, "xquery") == 0);
		}
#ifdef HAVE_LIBREADLINE
		if (interactive_stdin) {
			deinit_readline();
		}
#endif
	}
	mapi_disconnect(mid);
	return c;
}
@}
