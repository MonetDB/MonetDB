@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f alarm
@a M.L. Kersten, P. Boncz
@t Timers and Timed Interrupts

@* Introduction
@T
This module handles various signaling/timer functionalities.
The Monet interface supports two timer commands: {\tt alarm} and {\tt sleep}.
Their argument is the number of seconds to wait before the timer goes off.
The {\tt sleep} command blocks till the alarm goes off.
The {\tt alarm} command continues directly, executes off a MIL
string when it goes off.
The parameterless routines {\tt time} and {\tt ctime} provide access to
the cpu clock.They return an integer and string, respectively.

@* Module Definition
@m
.MODULE alarm;

.COMMAND sleep(int secs) = CMDsleep; "sleep X secs"
.COMMAND alarm(int secs, str action) = CMDalarm; "execute action in X secs"
.COMMAND timers() : BAT[str,str] = CMDtimers; "give a list of all active timers"
.COMMAND time() : int = CMDtime; "time in milliseconds"
.COMMAND usec() : lng = CMDusec; "time in microseconds"
.COMMAND epoch() : int = CMDepoch; "current time as unix epoch"
.COMMAND ctime() : str = CMDctime; "current time as a string"

.PRELUDE = CLKprelude;
.EPILOGUE = CLKepilogue;

.END alarm;

@{
@* Implementation
@+ The Clock Interrupt Generator
A clock event generator, called @%timer@, has been added to the database kernel.
It accepts a message @%CLKalarm(sec, usec)@, which generates an alarm
after the time indicated.
The timer maintains a small stack of timing events sorted in priority of firing.
The top contains the next timer event to go off.
The timer is disabled when no timer events are outstanding.
@h
#include <monet.h>
#include <signal.h>
#define MAXtimer                200

typedef struct {
	str action;		/* MIL action (as a string) */
	MT_Sema sema;		/* barrier */
	time_t alarm_time;	/* time when the alarm goes off */
} monet_timer_t;

@c
#include "monetdb4_config.h"
#include "alarm.h"
#include "alarm.proto.h"
#include <time.h>

static monet_timer_t timer[MAXtimer];
static int timerTop = 0;

@
@-
The timer is awakened by a clock interrupt. The interrupt granularity
is OS-dependent. The timer should be initialized as long as there
are outstanding timer events.
@c
#ifdef SIGALRM
static void
CLKinitTimer(int sec, int usec)
{
	int i = sec - time(0);

	(void) usec;
	TRGDEBUG THRprintf(GDKout, "#CLKinitTimer: set timer to %d secs \n", i);

	alarm(i);
}
#endif
@-
A new alarm is pushed onto the stack using @%CLKalarm@.
The parameter is the real-time value to be approximated.
@c
#ifdef SIGALRM
static void
CLKalarm(time_t t, str action)
{
	int j;
	int k;

	TRGDEBUG THRprintf(GDKout, "#CLKalarm: push " LLFMT "\n", (lng) t);

	if (timerTop == MAXtimer) {
		GDKerror("CLKalarm: timer stack overflow\n");
		return;
	}
	for (j = 0; j < timerTop; j++) {
		if (timer[j].alarm_time > t)
			break;
	}
	for (k = timerTop; k > j; k--) {
		timer[k] = timer[k - 1];
	}
	timer[k].alarm_time = t;
	if (action) {
		timer[k].action = GDKstrdup(action);
	} else {
		timer[k].action = 0;
                MT_init_sema(timer[k].sema, 0);
	}
	if (k == timerTop++) {
		CLKinitTimer(t, 0);	/* set it sooner */
	}
}
#endif
@-
Once a timer interrupt occurs, we should inspect the timer queue and
emit a notify signal.
@c
#ifdef SIGALRM
/* HACK to pacify compiler */
#if (defined(__INTEL_COMPILER) && (SIZEOF_VOID_P > SIZEOF_INT))
#undef  SIG_ERR			/*((__sighandler_t)-1 ) */
#define SIG_ERR   ((__sighandler_t)-1L)
#endif
static RETSIGTYPE
CLKsignal(int nr)
{
	int restype;
	int k = timerTop;
	int t;

	(void) nr;

	if (signal(SIGALRM, CLKsignal) == SIG_ERR) {
		GDKsyserror("CLKsignal: call failed\n");
	}
	TRGDEBUG THRprintf(GDKout, "#alarm signal (timeTop=%d)\n", timerTop);

	if (timerTop == 0) {
		return;
	}
	t = time(0);
	while (k-- && t >= timer[k].alarm_time) {
		if (timer[k].action) {
			TRGDEBUG THRprintf(GDKout, "#eval(%s)\n", timer[k].action);

			monet_eval(timer[k].action, &restype);
			GDKfree(timer[k].action);
		} else {
			MT_up_sema(timer[k].sema, "CLKsignal");
		}
		timerTop--;
	}
	if (timerTop > 0) {
		CLKinitTimer(timer[timerTop - 1].alarm_time, 0);
	}
}
#endif

bat *
CLKprelude(void)
{
#ifdef SIGALRM
	(void) signal(SIGALRM, CLKsignal);
#endif
	return NULL;
}

void
CLKepilogue(void)
{
	int k;

#if (defined(SIGALRM) && defined(SIG_IGN))
/* HACK to pacify compiler */
#if (defined(__INTEL_COMPILER) && (SIZEOF_VOID_P > SIZEOF_INT))
#undef  SIG_IGN			/*((__sighandler_t)1 ) */
#define SIG_IGN   ((__sighandler_t)1L)
#endif
	(void) signal(SIGALRM, SIG_IGN);
#endif
	for (k = 0; k < timerTop; k++) {
		if (timer[k].action)
			GDKfree(timer[k].action);
	}
}


int
CMDsleep(int *secs)
{

	if (*secs < 0) {
		GDKerror("CMDsleep: negative delay\n");
		return GDK_FAIL;
	} else {
#ifdef __CYGWIN__
		/* CYGWIN cannot handle SIGALRM with sleep */
		lng t = GDKusec() + (*secs)*1000000;
		
		while (GDKusec() < t)
			;
#else
		MT_sleep_ms(*secs * 1000);
#endif
	}
	return GDK_SUCCEED;
}

int
CMDalarm(int *secs, str action)
{
	if (*secs < 0) {
		GDKerror("CMDalarm: negative delay\n");
		return GDK_FAIL;
	} else {
#ifndef SIGALRM
		(void)action;
		GDKerror("CMDalarm: not implemented\n");
		return GDK_FAIL;
#else
		CLKalarm(time(0) + *secs, action);
#endif
	}
	return GDK_SUCCEED;
}

@-
Problem with CMDtimers is that they use static buffers that
may be overwritten under parallel processing.
Therefore, the code below is dangerous (!) and the re-entrant code
should be used.  However, on Windows where ctime_r is not available,
ctime is actually thread-safe.
@c
int
CMDtimers(BAT **retval)
{
	char buf[27];
	int k;

	*retval = BATnew(TYPE_str, TYPE_str, timerTop);
	if (*retval == NULL)
		return GDK_FAIL;
	BATroles(*retval, "alarm", "action");
	for (k = 0; k < timerTop; k++) {
		time_t t = timer[k].alarm_time;

#ifdef HAVE_CTIME_R3
		ctime_r(&t, buf, sizeof(buf));
#else
#ifdef HAVE_CTIME_R
		ctime_r(&t, buf);
#else
		strncpy(buf, ctime(&t), sizeof(buf));
#endif
#endif
		BUNins(*retval, buf, timer[k].action ? timer[k].action : "barrier", FALSE);
	}
	return GDK_SUCCEED;
}

int
CMDctime(str *retval)
{
	time_t t = time(0);

#ifdef HAVE_CTIME_R3
	char buf[26];

	*retval = GDKstrdup(ctime_r(&t, buf, sizeof(buf)));
#else
#ifdef HAVE_CTIME_R
	char buf[26];

	*retval = GDKstrdup(ctime_r(&t, buf));
#else
	*retval = GDKstrdup(ctime(&t));
#endif
#endif
	return GDK_SUCCEED;
}

int
CMDepoch(int *retval)		/* XXX should be lng */
{
	*retval = (int) time(0);
	return GDK_SUCCEED;
}

/* should return lng */
int
CMDusec(lng *retval)
{
	*retval = GDKusec();
	return GDK_SUCCEED;
}

int
CMDtime(int *retval)
{
	*retval = GDKms();
	return GDK_SUCCEED;
}

@}
