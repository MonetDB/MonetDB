@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f aggrX3_be_prod
@a S. Manegold
@t Improved & Extended Aggregates Module
@v 1.0

@{
@{

@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include "monetdb4_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "aggrX3.proto.h"
#include "aggrX3.h"

@- Result initialization
/*	init_result
	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
*/
@include aggrX3_ri.mx

@- Product
@c
/*	aggrX3_prod
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use prods-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]
								*dst: prod in-place or in prods-array ?
	@9:	result type
	@[10]:		r-off		(*(oid*)h)-min	index in hit array
*/
@= aggrX3_prod
	ALGODEBUG THRprintf(GDKout, "#aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]);\n");
	if (@1 && range > 0) {
		/* create tmp. prods array */
		oid i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		if (prods == NULL) {
			GDKerror("aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): prods = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(@9));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		for (i = 0; i < range; i++)
			prods[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): BATprepareHash(bn) failed");
		if (@1 && prods)
			GDKfree(prods);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	hit = (bit*) GDKzalloc(slots*sizeof(bit));
	if (hit == NULL) {
		GDKerror("aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): hit = GDKzalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(bit));
		if (@1 && prods)
			GDKfree(prods);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b, and mul values to prods in-place or in prods-array */
	bhsb = b->hseqbase - 1;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				@9 *dst = (@9*) @8;
				*dst *= (@9) *t;
				hit[@[10]] = 1;
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				@9 *dst = (@9*) @8;
				if (*dst != @9_nil) {
					if (*t == @6_nil) {
						*dst = @9_nil;
					} else {
						*dst *= (@9) *t;
						hit[@[10]] = 1;
					}
				}
			}
		}
	}
	if (@1) {
	    if (prods) {
		/* copy prods array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			@9 *dst = (@9*)BUNt@7(bni, p);
			if (hit[h] == 0) {
				*dst = @9_nil;
			} else {
				*dst = prods[h];
			}
		}
		GDKfree(prods);
	    }
	} else {
		BUN yy = 0;
		BATloop(bn, p, q) {
			@9 *dst = (@9*)BUNt@7(bni, p);
			if (hit[yy] == 0) {
				*dst = @9_nil;
			}
			yy++;
		}
	}
	if (hit)
		GDKfree(hit);
@
@c

/*	arithprod
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithprod
int
CMDaggrX3_prod_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	@3 zero = (@3) 1, *prods = NULL;
	bit *hit = NULL;
	BUN slots, off;
	BUN p, q, r;
	oid range;
	oid min, max;
	oid bhsb;

	if( bn == NULL) {
		GDKerror("CMDaggrX3_prod_@1_@3(): BATnew() failed");
		return GDK_FAIL;
	}
	off = BUNfirst(bn);
	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_prod_@1_@3[@2](b=%s,e=%s);\n",
		BATgetId(b), BATgetId(e));
	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@3)@
	range = max - min + 1;

	/* scan b, and calculate prods */
	slots = BATcount(e);
	if (slots == 0) {
		/* empty extend => empty result */
		*ret = bn;
		return GDK_SUCCEED;
	}
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3,r-off)@
		} else {
			@:aggrX3_prod(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3,r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&prods[(*(oid*)h)-min],@3,(*(oid*)h)-min)@
		} else {
			@:aggrX3_prod(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&prods[(*(oid*)h)-min],@3,(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3,r-off)@
		} else {
			@:aggrX3_prod(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3,r-off)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3,r-off)@
		} else {
			@:aggrX3_prod(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3,r-off)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithprod(bte,loc,bte)@
@:arithprod(bte,loc,sht)@
@:arithprod(bte,loc,int)@
@:arithprod(bte,loc,wrd)@
@:arithprod(bte,loc,lng)@
@:arithprod(sht,loc,sht)@
@:arithprod(sht,loc,int)@
@:arithprod(sht,loc,wrd)@
@:arithprod(sht,loc,lng)@
@:arithprod(int,loc,int)@
@:arithprod(int,loc,wrd)@
@:arithprod(int,loc,lng)@
@:arithprod(wrd,loc,wrd)@
@:arithprod(wrd,loc,lng)@
@:arithprod(lng,loc,wrd)@
@:arithprod(lng,loc,lng)@
@:arithprod(flt,loc,flt)@
@:arithprod(flt,loc,dbl)@
@:arithprod(dbl,loc,dbl)@

@}
@}
