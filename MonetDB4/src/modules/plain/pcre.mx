@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f pcre
@a N. Nes
@t PCRE - Perl-compatible regular expressions
@v 0.1
@T
The  PCRE library is a set of functions that implement regular expres-
sion pattern matching using the same syntax  and  semantics  as  Perl,
with  just  a  few  differences.  The  current  implementation of PCRE
(release 4.x) corresponds approximately with Perl 5.8, including  sup-
port  for  UTF-8  encoded  strings.   However,  this support has to be
explicitly enabled; it is not the default.


@+ Module Definition
@m
.MODULE pcre;

.ATOM pcre;
      .TOSTR   = pcre_tostr;
      .FROMSTR = pcre_fromstr;
      .NEQUAL  = pcre_nequal;
      .HASH    = pcre_hash;
      .NULL    = pcre_null;
      .PUT     = pcre_put;
      .DEL     = pcre_del;
      .LENGTH  = pcre_length;
      .HEAP    = pcre_heap;
.END;

.COMMAND pcre_compile(str pattern) : pcre = pcre_compile_wrap;
   "compile a pattern"

.COMMAND pcre_match(pcre pattern, str s) : bit = pcre_exec_wrap;
   "match a pattern"

.COMMAND pcre_select(str pattern, BAT[any::1,str] strs) : BAT[any::1,str] = pcre_select;
   "Select tuples based on the pattern"

.COMMAND pcre_uselect(str pattern, BAT[any::1,str] strs) : BAT[any::1,void] = pcre_uselect;
   "Select tuples based on the pattern, only returning the head"

.COMMAND pcre_match(str s, str pat) : bit = pcre_match;
   "POSIX pattern matching against a string"

.COMMAND pcre_match(str s, str pat, str flags) : bit = pcre_match_with_flags;
   "POSIX pattern matching against a string, with flags (see 'man pcreapi')"

.COMMAND pcre_replace(str origin_str, str pattern, str replacement, str flags) : str = pcre_replace;
   "Replace _all_ matches of \"pattern\" in \"origin_str\" with\
	\"replacement\".\n\
    Parameter \"flags\" accept these flags: 'i', 'm', 's', and 'x'.\n\
    'e': if present, an empty string is considered to be a valid\
         match\n\
    'i': if present, the match operates in case-insensitive mode.\
         Otherwise, in case-sensitive mode.\n\
    'm': if present, the match operates in multi-line mode.\n\
    's': if present, the match operates in \"dot-all\"\n\
    'x': if present, whitespace characters (#x9, #xA, #xD and #x20) in\
         the regular expression are removed prior to matching with one \
         exception: whitespace characters within character class \
         expressions are not removed.\
	The specifications of the flags can be found in \"man pcreapi\"\n\
	The flag letters may be repeated.\n\
	No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \"flags\".\n\
	Returns the replaced string, or if no matches found, the original string."
   
.COMMAND pcre_replace(BAT[any::1, str] origin_strs, str pattern, str replacement, str flags) : BAT[any::1, str] = pcre_replace_bat;
   "Replace _all_ matches of \"pattern\" in every string contained in\
   \"origin_strs\" with \"replacement\".\n\
   If no matches found in a string, the string is copied to the returned BAT."

.COMMAND pcre_quote(str s) : str = pcre_quote;
   "Return a PCRE pattern string that matches the argument exactly."

.COMMAND sql2pcre(str pat, str esc) : str = sql2pcre;
   "Convert a SQL like pattern with the given escape character into a PCRE pattern."

.PRELUDE  = pcre_init;
.EPILOGUE = pcre_exit;

.END pcre;

@{
@-
\begin{center}
ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre
\end{center}

@+ Implementation
@c
#include <monetdb4_config.h>


#ifndef HAVE_LIBPCRE

#define pcre str
#include "pcre.proto.h"

int
pcre_compile_wrap(pcre ** res, str pattern)
{
	(void) res;
	(void) pattern;
	GDKerror("pcre_compile_wrap() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

int
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	(void) res;
	(void) pattern;
	(void) s;
	GDKerror("pcre_exec_wrap() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

int
pcre_select(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;
	GDKerror("pcre_select() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

int
pcre_uselect(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;
	GDKerror("pcre_uselect() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

int
pcre_replace(str *res, str origin_str, str pattern, str replacement, str flags)
{
	(void) res;
	(void) origin_str;
	(void) pattern;
	(void) replacement;
	(void) flags;
	GDKerror("pcre_replace() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

int
pcre_replace_bat(BAT **res, BAT *origin_strs, str pattern, str replacement, str flags)
{
	(void) res;
	(void) origin_strs;
	(void) pattern;
	(void) replacement;
	(void) flags;
	GDKerror("pcre_replace_bat() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

bat *
pcre_init(void)
{
	return NULL;
}

void
pcre_exit(void)
{
}

int
pcre_match_with_flags(bit *ret, str val, str pat, str flags)
{
	(void) ret;
	(void) val;
	(void) pat;
    (void)flags;
	GDKerror("pcre_match_with_flags() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

int
pcre_match(bit *ret, str val, str pat)
{
	(void) ret;
	(void) val;
	(void) pat;
	GDKerror("pcre_match() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}
#else

#include <pcre.h>
#include "pcre.proto.h"

#define m2p(p) (pcre*)(((sht*)p)+1)
#define p2m(p) (pcre*)(((sht*)p)-1)

void *
my_pcre_malloc(size_t s)
{
	char *r = GDKmalloc(s + sizeof(sht));
	sht *sz = (sht *) r;

	*sz = s + sizeof(sht);
	return (void *) (sz + 1);
}

void
my_pcre_free(void *blk)
{
	sht *sz = (sht *) blk;

	sz -= 1;
	GDKfree((void *) sz);
}

int
pcre_compile_wrap(pcre ** res, str pattern)
{
	pcre *r;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;

	if ((r = pcre_compile(pattern, PCRE_UTF8 | PCRE_MULTILINE, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_compile() failed with\n'%s'\nat %d in\n'%s'.\n",
			err_p, errpos, pattern);
		return GDK_FAIL;
	}
	*(pcre **) res = p2m(r);
	return GDK_SUCCEED;
}

int
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	if (pcre_exec(m2p(pattern), NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
		*res = TRUE;
	} else {
		*res = FALSE;
	}
	return GDK_SUCCEED;
}

int
pcre_select(BAT **res, str pattern, BAT *strs)
{
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BAT *r;
	BUN p, q;
	pcre *re = NULL;

	if (strs->htype == TYPE_void)
		r = BATnew(TYPE_oid, TYPE_str, BATcount(strs));
	else
		r = BATnew(strs->htype, TYPE_str, BATcount(strs));
	if ((re = pcre_compile(pattern, PCRE_UTF8 | PCRE_MULTILINE, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_select: pcre compile of pattern (%s) failed at %d with\n'%s'.\n",
			pattern, errpos, err_p);
		return GDK_FAIL;
	}
	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(r, BUNhead(strs, p), s, FALSE);
		}
	}
	my_pcre_free(re);
	*res = r;
	return GDK_SUCCEED;
}

int
pcre_uselect(BAT **res, str pattern, BAT *strs)
{
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BAT *r;
	BUN p, q;
	pcre *re = NULL;

	if (strs->htype == TYPE_void)
		r = BATnew(TYPE_oid, TYPE_void, BATcount(strs));
	else
		r = BATnew(strs->htype, TYPE_void, BATcount(strs));
	if ((re = pcre_compile(pattern, PCRE_UTF8 | PCRE_MULTILINE, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_uselect: pcre compile of pattern (%s) failed at %d with\n'%s'.\n",
			pattern, errpos, err_p);
		return GDK_FAIL;
	}
	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(r, BUNhead(strs, p), NULL, FALSE);
		}
	}
	my_pcre_free(re);
	*res = r;
	return GDK_SUCCEED;
}

#define MAX_NR_CAPTURES  1024 /* Maximal number of captured substrings in one original string */

int
pcre_replace(str *res, str origin_str, str pattern, str replacement, str flags)
{
	const char err[BUFSIZ], *err_p = err, *err_p2 = err;
	pcre *pcre_code = NULL;
	pcre_extra *extra;
	str tmpres;
	int i, j, k, len, errpos = 0, offset = 0;
	int compile_options = PCRE_UTF8, exec_options = PCRE_NOTEMPTY;
	int *ovector, ovecsize;
	int len_origin_str = strlen(origin_str);
	int len_replacement = strlen(replacement);
	int capture_offsets[MAX_NR_CAPTURES * 2], ncaptures = 0, len_del = 0;
	
	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'e') {
			exec_options -= PCRE_NOTEMPTY;
			stream_printf(GDKout, "exec_options %d, PCRE_NOTEMPTY %d\n",
					exec_options, PCRE_NOTEMPTY);
		} else if (flags[i] == 'i') {
			compile_options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			compile_options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			compile_options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			compile_options |= PCRE_EXTENDED;
		} else {
			GDKerror("pcre_replace: unsupported flag character '%c'\n", flags[i]);
			return GDK_FAIL;
		}
	}

	if ((pcre_code = pcre_compile(pattern, compile_options, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_replace: pcre compile of pattern (%s) failed at %d with\n'%s'.\n", pattern, errpos, err_p);
		return GDK_FAIL;
	}

	/* Since the compiled pattern is going to be used several times, it is
	 * worth spending more time analyzing it in order to speed up the time
	 * taken for matching.
	 */
	extra = pcre_study(pcre_code, 0, &err_p2);
	pcre_fullinfo(pcre_code, extra, PCRE_INFO_CAPTURECOUNT, &i);
	ovecsize = (i + 1) * 3;
	if ((ovector = (int *) GDKmalloc(sizeof(int) * ovecsize)) == NULL) {
		GDKerror("pcre_replace: not enough memory\n");
		my_pcre_free(pcre_code);
		return GDK_FAIL;
	}
	
	i = 0;
	do {
		j = pcre_exec(pcre_code, extra, origin_str, len_origin_str, 
						offset, exec_options, ovector, ovecsize);
		if (j > 0){
			capture_offsets[i] = ovector[0];
			capture_offsets[i+1] = ovector[1];
			ncaptures++;
			i += 2;
			len_del += (ovector[1] - ovector[0]);
			offset = ovector[1];
		}
	} while((j > 0) && (offset < len_origin_str) && (ncaptures < MAX_NR_CAPTURES));
	
	if (ncaptures > 0){
		tmpres = GDKmalloc(len_origin_str - len_del + (len_replacement * ncaptures) + 1);
		if (!tmpres) {
			GDKerror("pcre_replace: not enough memory\n");
			my_pcre_free(pcre_code);
			GDKfree(ovector);
			return GDK_FAIL;
		}

		j = k = 0;

		/* possibly copy the substring before the first captured substring */
		strncpy(tmpres, origin_str, capture_offsets[j]); 
		k = capture_offsets[j];
		j++;

		for (i = 0; i < ncaptures - 1; i++) {
			strncpy(tmpres+k, replacement, len_replacement);
			k += len_replacement;
			/* copy the substring between two captured substrings */
			len = capture_offsets[j+1] - capture_offsets[j];
			strncpy(tmpres+k, origin_str+capture_offsets[j], len);
			k += len;
			j += 2;
		}

		/* replace the last captured substring */
		strncpy(tmpres+k, replacement, len_replacement);
		k += len_replacement;
		/* possibly copy the substring after the last captured substring */
		len = len_origin_str - capture_offsets[j];
		strncpy(tmpres+k, origin_str+capture_offsets[j], len);
		k += len;
		tmpres[k] = '\0';
	} else { /* no captured substrings, return the original string*/
		tmpres = GDKstrdup(origin_str);
	}

	my_pcre_free(pcre_code);
	GDKfree(ovector);
	*res = tmpres;
	return GDK_SUCCEED;
}

int
pcre_replace_bat(BAT **res, BAT *origin_strs, str pattern, str replacement, str flags)
{
	const char err[BUFSIZ], *err_p = err, *err_p2 = err;
	int i, j, k, len, errpos = 0, offset = 0;
	int compile_options = PCRE_UTF8, exec_options = PCRE_NOTEMPTY;
	pcre *pcre_code = NULL;
	pcre_extra *extra;
	BAT *tmpbat;
	BUN p, q;
	int *ovector, ovecsize;
	int len_origin_str, len_replacement = strlen(replacement);
	int capture_offsets[MAX_NR_CAPTURES * 2], ncaptures = 0, len_del = 0;
	str origin_str, replaced_str;

	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'e') {
			exec_options |= (~PCRE_NOTEMPTY);
		} else if (flags[i] == 'i') {
			compile_options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			compile_options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			compile_options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			compile_options |= PCRE_EXTENDED;
		} else {
			GDKerror("pcre_replace_bat: \"flags\" contains invalid character '%c'\n", flags[i]);
			return GDK_FAIL;
		}
	}

	if ((pcre_code = pcre_compile(pattern, compile_options, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_replace_bat: pcre compile of pattern (%s) failed at %d with\n'%s'.\n", pattern, errpos, err_p);
		return GDK_FAIL;
	}

	/* Since the compiled pattern is ging to be used several times, it is worth spending 
	 * more time analyzing it in order to speed up the time taken for matching.
	 */
	extra = pcre_study(pcre_code, 0, &err_p2);
	pcre_fullinfo(pcre_code, extra, PCRE_INFO_CAPTURECOUNT, &i);
	ovecsize = (i + 1) * 3;
	if ((ovector = (int *) GDKzalloc(sizeof(int) * ovecsize)) == NULL) {
		GDKerror("pcre_replace_bat: not enough memory\n");
		my_pcre_free(pcre_code);
		return GDK_FAIL;
	}
	
	tmpbat = BATnew(origin_strs->htype, TYPE_str, BATcount(origin_strs));
	BATloop(origin_strs, p, q) {
		origin_str = BUNtail(origin_strs, p);
		len_origin_str = strlen(origin_str);
		i = ncaptures = len_del = offset = 0;
		do {
			j = pcre_exec(pcre_code, extra, origin_str, len_origin_str, offset,
					exec_options, ovector, ovecsize);
			if (j > 0){
				capture_offsets[i] = ovector[0];
				capture_offsets[i+1] = ovector[1];
				ncaptures++;
				i += 2;
				len_del += (ovector[1] - ovector[0]);
				offset = ovector[1];
			}
		} while((j > 0) && (offset < len_origin_str) && (ncaptures < MAX_NR_CAPTURES));
	
		if (ncaptures > 0){
			replaced_str = GDKmalloc(len_origin_str - len_del + (len_replacement * ncaptures) + 1);
			if (!replaced_str) {
				GDKerror("pcre_replace_bat: not enough memory\n");
				my_pcre_free(pcre_code);
				GDKfree(ovector);
				return GDK_FAIL;
			}

			j = k = 0;

			/* copy eventually the substring before the first captured
			 * substring */
			strncpy(replaced_str, origin_str, capture_offsets[j]); 
			k = capture_offsets[j];
			j++;

			for (i = 0; i < ncaptures - 1; i++) {
				strncpy(replaced_str+k, replacement, len_replacement);
				k += len_replacement;
				/* copy the substring between two captured substrings */
				len = capture_offsets[j+1] - capture_offsets[j];
				strncpy(replaced_str+k, origin_str+capture_offsets[j], len);
				k += len;
				j += 2;
			}

			/* replace the last captured substring */
			strncpy(replaced_str+k, replacement, len_replacement);
			k += len_replacement;
			/* copy eventually the substring after the last captured substring */
			len = len_origin_str - capture_offsets[j];
			strncpy(replaced_str+k, origin_str+capture_offsets[j], len);
			k += len;
			replaced_str[k] = '\0';
			BUNins(tmpbat, BUNhead(origin_strs, p), replaced_str, FALSE);
			GDKfree(replaced_str);
		} else { /* no captured substrings, copy the original string into new bat */
			BUNins(tmpbat, BUNhead(origin_strs, p), origin_str, FALSE);
		}
	}

	my_pcre_free(pcre_code);
	GDKfree(ovector);
	if (origin_strs->htype == TYPE_void) {
		*res = BATseqbase(tmpbat, origin_strs->hseqbase);
	} else {
		*res = tmpbat;
	}
	return GDK_SUCCEED;
}

bat *
pcre_init(void)
{
	pcre_malloc = my_pcre_malloc;
	pcre_free = my_pcre_free;
	return NULL;
}

void
pcre_exit(void)
{
}

int
pcre_match_with_flags(bit *ret, str val, str pat, str flags)
{
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
    int options = PCRE_UTF8, i;
	pcre *re;

	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'i') {
			options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			options |= PCRE_EXTENDED;
		} else {
			GDKerror("pcre_match: unsupported flag character '%c'\n", flags[i]);
			return GDK_FAIL;
		}
	}

	if ((re = pcre_compile(pat, options, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre.match", "Compilation of regular expression (%s) failed at %d with '%s'", pat, errpos, err_p);
		return GDK_FAIL;
	}
	errpos = pcre_exec(re, NULL, val, strlen(val), 0, 0, NULL, 0);
	if (errpos >= 0)
		*ret = 1;
	else if (errpos == -1)
		*ret = 0;
	else {
		GDKerror("pcre.match", "Matching of regular expression (%s) failed with %d", pat, errpos);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int
pcre_match(bit *ret, str val, str pat)
{
	return pcre_match_with_flags(ret, val, pat, "");
}
#endif

int
pcre_quote(str *res, str s)
{
	str p;

	*res = p = GDKmalloc(strlen(s) * 2 + 1); /* certainly long enough */
	if (p == NULL)
		return GDK_FAIL;
	/* quote all non-alphanumeric ASCII characters (i.e. leave
	   non-ASCII and alphanumeric alone) */
	while (*s) {
		if (!((*s & 0x80) != 0 ||
		      ('a' <= *s && *s <= 'z') ||
		      ('A' <= *s && *s <= 'Z') ||
		      ('0' <= *s && *s <= '9')))
			*p++ = '\\';
		*p++ = *s++;
	}
	*p = 0;
	return GDK_SUCCEED;
}

int
pcre_tostr(str *tostr, int *l, pcre * p)
{
	(void) tostr;
	(void) l;
	(void) p;
	return GDK_FAIL;
}

int
pcre_fromstr(str instr, int *l, pcre ** val)
{
	(void) l;
	return pcre_compile_wrap(val, instr);
}

int
pcre_nequal(pcre * l, pcre * r)
{
	if (l != r)
		return 0;
	else
		return 1;
}

hash_t
pcre_hash(pcre * b)
{
	return *(sht *) b;
}

pcre *
pcre_null(void)
{
	static sht nullval, *r;

	nullval = ~(sht) 0;
	r = &nullval;
	return ((pcre *) (r));
}

void
pcre_del(Heap *h, var_t *index)
{
	HEAP_free(h, *index);
}

#define pcresize(val) ((sht*)val)[0]

var_t
pcre_put(Heap *h, var_t *bun, pcre * val)
{
	char *base;

	*bun = HEAP_malloc(h, pcresize(val));
	base = h->base;
	if (*bun)
		memcpy(&base[*bun], (char *) val, pcresize(val));
	return *bun;
}

int
pcre_length(pcre * p)
{
	return (pcresize(p));
}

void
pcre_heap(Heap *heap, size_t capacity)
{
	HEAP_initialize(heap, capacity, 0, (int) sizeof(var_t));
}

/* change SQL LIKE pattern into PCRE pattern */
int
sql2pcre(str *r, str pat, str esc_str) 
{
	/* change the SQL wilcards into PCRE wildcards */
	int len = (int) strlen(pat);
	int escaped = 0;
	int hasWildcard = 0;
	char *ppat = GDKmalloc(len*2+3 /* 3 = "^'the translated regexp'$0" */);
	int esc = esc_str[0]; /* should change to utf8_convert() */
	int specials = 0;

	*r = ppat;
	/*
	# the escape character can be a char which is special in a PCRE
	# if the user used the "+" char as escape and has "++" in
	# its pattern, then replacing this with "+" is not correct
	# but should be "\+"
	*/
	if (*esc_str && strchr( ".+*()[]", esc) != NULL) 
		specials = 1; 

	*ppat ++ = '^';
	while (*pat) {
		int c = *pat++;

		if (c == esc) {
			if (escaped) {
				if (specials) { /* change ++ into \\+ */
					*ppat++ = esc;
				} else { /* do not escape simple escape symbols */
					ppat[-1] = esc;
				}
				escaped = 0;
			} else {
				*ppat++ = '\\';
				escaped = 1;
			}
			/* not optimal but functional */
			hasWildcard = 1; 
		} else if (strchr( ".+*()[]\\", c) != NULL) {
			*ppat++ = '\\';
			*ppat++ = c;
			/* not optimal but functional */
			hasWildcard = 1; 
			escaped = 0;
		} else if (c == '%' && !escaped) {
			*ppat++ = '.';
			*ppat++ = '*';
			hasWildcard = 1;
		} else if (c == '_' && !escaped) {
			*ppat++ = '.';
			hasWildcard = 1;
		} else {
			*ppat++ = c;
			escaped = 0;
		}
	}
	/* no wildcard or escape character at end of string */
	if (!hasWildcard || escaped) {
		GDKfree(*r);
		*r = GDKstrdup(str_nil);
		if (escaped)
			return GDK_FAIL; 
	} else {
		*ppat++ = '$';
		*ppat = 0;
	}
	return GDK_SUCCEED; 
}
@}
@mil

    PROC like(str s, str pat, str esc) : bit  {
		var ppat := sql2pcre(pat, esc);
		if (isnil(ppat)) {
			return(s = pat);
		} else {
			return(pcre_match(pcre_compile(ppat), s));
		}
    }
    ADDHELP("like", "nes", "Dec 20 2004",
    "does SQL LIKE expression with use of PCRE", "algebra");

    PROC like(str s, str pat) : bit  {
		var ppat := sql2pcre(pat, "\\");
		if (isnil(ppat)) {
			return(s = pat);
		} else {
			return(pcre_match(pcre_compile(ppat), s));
		}
    }
    ADDHELP("like", "nes", "Dec 20 2004",
    "does SQL LIKE expression with use of PCRE", "algebra");

    PROC like_uselect_pcre(bat[any::1,str] b, str pat, str esc) : bat[any::1,void]  {
		var ppat := sql2pcre(pat, esc);
		if (isnil(ppat)) {
			return(uselect(b, pat));
		} else {
			return(pcre_uselect(ppat, b));
		}
    }
    ADDHELP("like_uselect_pcre", "groffen", "Dec 19 2004",
    "does SQL LIKE select with use of PCRE", "algebra");

