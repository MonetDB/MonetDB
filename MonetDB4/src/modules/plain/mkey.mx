@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f mkey
@a Peter Boncz, Stefan Manegold
@v 1.1
@* Robust Multi-Attribute Equi-Join
@m
.MODULE mkey;

.COMMAND rotate(int v, int nbits) : int = CMDrotate;
	"left-rotate an int by nbits"

.COMMAND hash(any v) : int = CMDhash;
	"compute a hash int number from any value"
.COMMAND hash(bit v) : int = CMDhash_bte;
	"compute a hash int number from a bit value"
.COMMAND hash(chr v) : int = CMDhash_bte;
	"compute a hash int number from a chr value"
.COMMAND hash(bte v) : int = CMDhash_bte;
	"compute a hash int number from a bte value"
.COMMAND hash(sht v) : int = CMDhash_sht;
	"compute a hash int number from a sht value"
.COMMAND hash(int v) : int = CMDhash_int;
	"compute a hash int number from a int value"
.COMMAND hash(flt v) : int = CMDhash_flt;
	"compute a hash int number from a flt value"
.COMMAND hash(wrd v) : int = CMDhash_wrd;
	"compute a hash int number from a wrd value"
.COMMAND hash(dbl v) : int = CMDhash_dbl;
	"compute a hash int number from a dbl value"
.COMMAND hash(lng v) : int = CMDhash_lng;
	"compute a hash int number from a lng value"
.COMMAND hash(str v) : int = CMDhash_str;
	"compute a hash int number from a str value"

.COMMAND bulk_rotate_xor_hash(BAT[oid,int] h, int nbits, BAT[oid,any] b) : BAT[oid,int] = CMDbulk_rotate_xor_hash;
	"pre:  h and b should be synced on head
         post: [:xor=]([:rotate=](h, nbits), [hash](b))"

.END mkey;


@- The Problem
When creating a join, we want to make a unique key of the attributes on both
sides and then join these keys.

Example :
@T
\begin{verbatim}
orders                  customer                link
====================    =====================   ===========
        zipcode h_nr            zipcode h_nr    oid     cid
o1      13      9       c1      11      10      o1      c5
o2      11      10      c2      11      11      o2      c1
o3      11      11      c3      12      2       o3      c2
o4      12      5       c4      12      1       o4      nil
o5      11      10      c5      13      9       o5      c1
o6      12      2       c6      14      7       o6      c3
o7      13      9                               o7      c5
o8      12      1                               o8      c4
o9      13      9                               o9      c5
                                                nil     c6
Mil code :

o_pcd := new(oid,int).insert(1@0,13).insert(2@0,11).insert(3@0,11).insert(4@0,12);
o_pcd.insert(5@0,11).insert(6@0,12).insert(7@0,13).insert(8@0,12).insert(9@0,13);

o_hnr := new(oid,int).insert(1@0,9).insert(2@0,10).insert(3@0,11).insert(4@0,5);
o_hnr.insert(5@0,10).insert(6@0,2).insert(7@0,9).insert(8@0,1).insert(9@0,9);

c_pcd := new(oid,int).insert(1@0,11).insert(2@0,11);
c_pcd.insert(3@0,12).insert(4@0,12).insert(5@0,13).insert(6@0,14);

c_hnr := new(oid,int).insert(1@0,10).insert(2@0,11);
c_hnr.insert(3@0,2).insert(4@0,1).insert(5@0,9).insert(6@0,7);
\end{verbatim}

\section{solution}

The current approach is designed to take minimal memory, as our previous
solutions to the problem did not scale well. In case of singular keys,
the link is executed by a simple MIL join. Before going into the join, we
make sure the end result size is not too large, which is done by looking
at relation sizes (if the other key is unique) or, if that is not possible,
by computing the exact join size:

sum([*](histogram(b).reverse,histogram(r)));

The MIL join was also improved to do dynamic sampling in order to determine
with high accuracy the join size, so that we can alloc in one go a memory
region of sufficient size. This also reduces the ds\_link memory requirements.

For compound keys, those that consist of multiple attributes, we now compute
a derived column that contains an integer hash value derived from all
key columns.
This is done by computing a hash value for each individual key column
and combining those by bitwise XOR and left-rotation. That is, for each
column,we rotate the working hash value by N bits and XOR the hash value
of the column over it. The working hash value is initialized with zero,
and after all columns are processed, this working value is used as output.
Computing the hash value for all columns in the key for one table is done
by the MIL proc ds\_hash(). Hence, we do ds\_hash on both sides, and join
that together with a simple MIL join:

join(ds\_hash(keys), ds\_hash(keys.reverse);
@T
One complication of this procedure are nil values:
\begin{itemize}
\item it may happen that the final hash-value (an int formed by a
random bit pattern) accidentally has the value of int(nil).
Notice that MIL join never matches nil values.
Hence these accidental nils must be replaced by a begin value (currently: 0).
\item in case any of the compound key values is nil, our nil semantics
require us that those tuples may never match on a join. Consequently,
during the ds\_hash() processing of all compound key columns for computing
the hash value, we also maintain a bit-bat that records which tuples had
a nil value. The bit-bat is initialized to false, and the results of the
nil-check on each column is OR-ed to it.
Afterwards, the hash-value of all tuples that have this nil-bit set to
TRUE are forced to int(nil), which will exclude them from matching.
\end{itemize}

Joining on hash values produces a {\em superset} of the join result:
it may happen that  two different key combinations hash on the same value,
which will make them match on the join (false hits). The final part
of the ds\_link therefore consists of filtering out the false hits.
This is done incrementally by joining back the join result to the original
columns, incrementally one by one for each pair of corresponding
columns. These values are compared with each other and we AND the
result of this comparison together for each pair of columns.
The bat containing these bits is initialized to all TRUE and serves as
final result after all column pairs have been compared.
The initial join result is finally filtered with this bit-bat.

Joining back from the initial join-result to the original columns on
both sides takes quite a lot of memory. For this reason, the false
hit-filtering is done in slices (not all tuples at one time).
In this way the memory requirements of this phase are kept low.
In fact, the most memory demanding part of the join is the int-join
on hash number, which takes N*24 bytes (where N= |L| = |R|).
In comparison, the previous CTmultigroup/CTmultiderive approach
took N*48 bytes. Additionally, by making it possible to use merge-sort,
it avoids severe performance degradation (memory thrashing) as produced
by the old ds\_link when the inner join relation would be larger than memory.

If ds\_link performance is still an issue, the sort-merge join used here
could be replaced by partitioned hash-join with radix-cluster/decluster.

@mil

# Stefan Manegold:
# Temporary HACK: don't do any sorting
proc ds_sort(BAT[any::1, any::2] b, bit x) : BAT[any::1, any::2] {
  return b.sort();
}

proc rotate_xor_hash(int h, int nbits, any v) : int {
  return xor(rotate(h, nbits), hash(v));
}

proc "[:rotate_xor_hash=]"(BAT[any::1,int] h, int nbits, BAT[any::1,any] b) : BAT[any::1,int] {
  if (synced(h,b)) {
	return bulk_rotate_xor_hash(h, nbits, b);
  }
  # we will not use the below; added for completeness
  return [:xor=]([:rotate=](h, nbits), [hash](b));
}

proc ds_hash(BAT[bat,any] keys) : BAT[oid,int] {
  var nbits := 1 + (31 / keys.count());
  var fst := keys.reverse().fetch(0);
  var res := [hash](fst).access(BAT_WRITE);
  var filter := [isnil](fst).access(BAT_WRITE);

  keys@batloop() if (str($h) != str(fst)) {
    [:rotate_xor_hash=](res, nbits, $h);
    [:or=](filter,[isnil]($h));
  }
  res := [isnil](res).[ifthenelse](0,res); # replace accidental hash-on-nil by 0
  return filter.[ifthenelse](int(nil),res); # emit a nil for keys that contain a nil
}

const JOIN_BULK_SIZE := INT_MAX;	# 5000000;

proc ds_eq(BAT[void,oid] l_slice, bat lb, BAT[void,oid] r_slice, bat rb) : BAT[void,bit] {
  var l := join(l_slice,bat(lb));
  var r := join(r_slice,bat(rb));
  return [=](l.ds_sort(true),r.ds_sort(true));
}

proc ds_link(BAT[oid,any::1] l1, BAT[oid,any::1] r1, ..BAT[oid,any]..) : BAT[oid, oid] {
	var n := $0;
	if (bit(n % 2)) {
		ERROR("ds_link(BAT[oid,any::1] l1, BAT[oid,any::1] r1, ..BAT[oid,any]..) requires an even number of parameters!\n");
		return nil;
	} else {
		var keys := new(bat,bat,n / 2);
		var i := 0;
		while (i < n) {
			keys.insert($(i+1),$(i+2));
			i :+= 2;
		}
		return ds_link(keys);
	}
}

proc ds_link(BAT[bat,bat] keys) : BAT[oid, oid]
{
  var res;
  {
    var l, r;
    # get left and right join relations
    # The sort is added by Peter Boncz, so that for large bats the merge-join algorithms
    # can be used (thus avoiding random access pattern of the hash-join)

    if (keys.count() <= 1) {
      l := keys.reverse().fetch(0).ds_sort(false);
      r := keys.fetch(0).ds_sort(false);
    } else {
      l := ds_hash(keys).ds_sort(true);
      r := ds_hash(keys.reverse()).ds_sort(true);
    }

    # create the link
    res := join(l, r.reverse());
  }

  # make sure the result is sorted conveniently
  res := res.reverse().ds_sort(true).reverse();

  # multi-attribute key joins must be filtered on false hits
  if (keys.count() > 1) {
    var cnt := res.count();
    var lo := 0;
    var hi := JOIN_BULK_SIZE;
    var res_l := res.mark(0@0).reverse();
    var res_r := res.reverse().mark(0@0).reverse();
    var sel := bat(void, bit, cnt);

    while(lo < cnt) {
      var h := keys.reverse().fetch(0);
      var t := keys.fetch(0);
      var p_l := res_l.slice(lo, hi - 1);
      var p_r := res_r.slice(lo, hi - 1);
      var p_sel := ds_eq(p_l, h, p_r, t).access(BAT_WRITE);

      keys@batloop() if (str($h) != str(h)) {
        [:and=](p_sel, ds_eq(p_l, $h, p_r, $t));
      }
      sel.insert(p_sel.reverse().project(nil).reverse());
      lo := hi; hi :+= JOIN_BULK_SIZE;
    }

    sel := sel.seqbase(0@0).uselect(true);
    if (sel.count() != res.count()) {
      res := res.semijoin( res_l.semijoin(sel).reverse() );
    }
  }
  return res;
}


@* Implementation
@c
#include "monetdb4_config.h"
#include <monet.h>
#include "mkey.proto.h"

#define GDK_ROTATE(x,y,z,m) ((((x) << (y)) & ~(m)) | (((x) >> (z)) & (m)))

@-
new functionality for the low-resource-consumption ds_link. It will
first one by one create a hash value out of the multiple attributes.
This hash value is computed by xoring and rotating individual hash
values together. We create a hash and rotate command to do this.
@c
/* TODO: nil handling. however; we do not want to lose time in bulk_rotate_xor_hash with that */
int
CMDrotate(int *res, int *val, int *n)
{
	*res = GDK_ROTATE(*val, *n, 32 - *n, (1 << *n) - 1);
	return GDK_SUCCEED;
}

/* 64bit: the CMDhash functions should probably return wrd and use the
 * same hash functions as the rest of MonetDB */
int
CMDhash_bte(int *res, bte *val)
{
	*res = *val;
	return GDK_SUCCEED;
}

int
CMDhash_sht(int *res, sht *val)
{
	*res = *val;
	return GDK_SUCCEED;
}

int
CMDhash_int(int *res, int *val)
{
	*res = *val;
	return GDK_SUCCEED;
}

int
CMDhash_flt(int *res, flt *val)
{
	*res = *(int *) val;
	return GDK_SUCCEED;
}

int
CMDhash_wrd(int *res, wrd *val)
{
#if SIZEOF_WRD == SIZEOF_INT
	*res = (int) *val;
#else
	*res = (int) (*val >> 32) ^ (int) *val;
#endif
	return GDK_SUCCEED;
}

int
CMDhash_lng(int *res, lng *val)
{
	*res = ((int *) val)[0] ^ ((int *) val)[1];
	return GDK_SUCCEED;
}

int
CMDhash_dbl(int *res, dbl *val)
{
	*res = ((int *) val)[0] ^ ((int *) val)[1];
	return GDK_SUCCEED;
}

int
CMDhash_str(int *res, str val)
{
/* 64bit: if CMDhash continues to return int, then this should
 * probably be changed to not throw away the top bits of the result */
	*res = strHash(val);
	return GDK_SUCCEED;
}

int
CMDhash(int *res, ptr val, int tpe)
{
	int code;		/* 64-bits on 64 systems; we truncate it here to save space */

	switch (ATOMstorage(tpe)) {
	case TYPE_void:
		code = int_nil;
		break;
	case TYPE_chr:
		code = *(chr *) val;
		break;
	case TYPE_bte:
		code = *(bte *) val;
		break;
	case TYPE_sht:
		code = *(sht *) val;
		break;
	case TYPE_int:
	case TYPE_flt:
		code = *(int *) val;
		break;
	case TYPE_lng:
	case TYPE_dbl:
		code = ((int *) val)[0] ^ ((int *) val)[1];
		break;
	case TYPE_str:
		code = (int) strHash((char*)val); /* 64bit: truncating top bits */
		break;
	default:
		code = (int) (*BATatoms[tpe].atomHash)(val); /* 64bit: truncating top bits */
	}
	*res = code;
	return GDK_SUCCEED;
}

int
CMDbulk_rotate_xor_hash(BAT **res, BAT *bn, int *rotate, BAT *b)
{
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	int *dst = (int *) BUNtloc(bni, BUNfirst(bn));
	int tpe = ATOMstorage(b->ttype);
	int lbit = *rotate;
	int rbit = 32 - *rotate;
	int mask = (1 << lbit) - 1;

	if (!ALIGNsynced(bn, b)) {
		GDKerror("CMDbulk_rotate_xor_hash: (%s,%d,%s): not synced on head.\n", BATgetId(bn), *rotate, BATgetId(b));
		return GDK_FAIL;
	} else if (isVIEW(bn) || bn->batRestricted) {
		GDKerror("CMDbulk_rotate_xor_hash: (%s,%d,%s): left operand not writeable.\n", BATgetId(bn), *rotate, BATgetId(b));
		return GDK_FAIL;
	} else if (*rotate < 0 || *rotate >= 32) {
		GDKerror("CMDbulk_rotate_xor_hash: (%s,%d,%s): illegal number of rotate bits.\n", BATgetId(bn), *rotate, BATgetId(b));
		return GDK_FAIL;
	} else if (tpe == TYPE_bte || tpe == TYPE_chr) {
		bte *cur = (bte *) BUNtloc(bi, BUNfirst(b));
		bte *end = (bte *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			*dst = GDK_ROTATE(*dst, lbit, rbit, mask) ^ *cur;
			cur++;
			dst++;
		}
	} else if (tpe == TYPE_sht) {
		sht *cur = (sht *) BUNtloc(bi, BUNfirst(b));
		sht *end = (sht *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			*dst = GDK_ROTATE(*dst, lbit, rbit, mask) ^ *cur;
			cur++;
			dst++;
		}
	} else if (tpe == TYPE_int || tpe == TYPE_flt) {
		int *cur = (int *) BUNtloc(bi, BUNfirst(b));
		int *end = (int *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			*dst = GDK_ROTATE(*dst, lbit, rbit, mask) ^ *cur;
			cur++;
			dst++;
		}
	} else if (tpe == TYPE_lng || tpe == TYPE_dbl) {
		lng *cur = (lng *) BUNtloc(bi, BUNfirst(b));
		lng *end = (lng *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			int *t = (int*)cur;
			int val = t[0] ^ t[1];

			*dst = GDK_ROTATE(*dst, lbit, rbit, mask) ^ val;
			cur++;
			dst++;
		}
	} else if (tpe == TYPE_str) {	/* TYPE_str */
		var_t *cur = (var_t *) BUNtloc(bi, BUNfirst(b));
		var_t *end = (var_t *) BUNtloc(bi, BUNlast(b));
		str base = b->theap->base;

		while (cur < end) {
                        str src = base + *cur;
			hash_t val;
			GDK_STRHASH(src, val);
			*dst = GDK_ROTATE(*dst, lbit, rbit, mask) ^ val;
			cur++;
			dst++;
		}
	} else if (b->ttype == TYPE_void) {
		BUN p, q;

		BATloop(b, p, q) {
			*dst = GDK_ROTATE(*dst, lbit, rbit, mask) ^ *(int *) BUNtail(bi, p);
			dst++;
		}
	} else {
		hash_t (*hash)(ptr) = BATatoms[b->ttype].atomHash;
		BUN p, q;

		BATloop(b, p, q) {
			*dst = GDK_ROTATE(*dst, lbit, rbit, mask) ^ (int) (*hash)(BUNtail(bi, p)); /* 64bit: truncating top bits */
			dst++;
		}
	}
	/* we return an already existing parameter BAT, so we must fix it */
	*res = bn;
	bn->tsorted = 0;
	if (bn->tkey)
		BATkey(BATmirror(bn), FALSE);
	BBPfix(bn->batCacheid);
	return GDK_SUCCEED;
}
