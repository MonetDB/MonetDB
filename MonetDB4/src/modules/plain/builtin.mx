@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f builtin
@a M. Kersten, P. Boncz
@v 2.0
@t MIL Builtin Operations

@* Introduction
Apart from its grammatical structure, described in the
@[<a href="../../../FrontEnds/mil/index.html">MIL Manual</a>@, MIL is just a set
of commands. When MIL is bootstrapped, this set of commands
is the empty set.

Commands are introduced by extension modules.
This module is loaded at server startup, and is always
present. The commands it defines are of type BUILTIN and
cannot be overloaded. Several other modules are loaded
on startup( @[<a href="../bat/index.html">BAT Manipulation</a>@,
@[<a href="../algebra/index.html">BAT Algebra</a>@,
@[<a href="../sys/index.html">System Information</a>@,
@[<a href="../arith/index.html">Basic Arithmetic</a>@), but
their commands @%can@ be overloaded.

This module
contains built-in primitives that cannot be overloaded. They are
mostly meta operations on MIL, or concern themselves with thread
or MIL session management. And of course, the commands for
loading and unloading new modules.

@* MEL Definition
@m
.MODULE builtin;

@+ Module management
@m
.BUILTIN module(str modname) = CMDmodule;
"Loads Monet extension module into a running Mserver.
 After this, you will be able to use new Atoms (e.g. polygon), 
 Buildins and Commands (e.g. spatjoin(A,B)). 

 In command-line mode, you can save typing the \" (providing the
 resulting identifier does not collide with another MIL keyword)."

.BUILTIN drop(str modname) = CMDdrop;
"Unloads Monet extension module (previously loaded with MODULE())
 You can only unload a module installed by yourself.

 In command-line mode, you can save typing the \" (though this often
 will collide with a MIL keyword)."

.BUILTIN mod() : str = CMDmodule_peek;
"During module loading a module stack is kept. This function returns the top module"

.BUILTIN module_push(str modname) = CMDmodule_enter;
"During module loading a variable module is set to the current module name. The previous module is pushed onto a stack"

.BUILTIN module_pop() = CMDmodule_exit;
"During module loading a variable module is set to the current module name. At the end of a module load the enclosing module is popped from a stack"

@+ Basic Value Manipulation
@m
.BUILTIN type(any v) : int = CMDtype;
"Return the type of a value (expression). Returns an type number.
 TIP: use the monet_atomtbl BAT to translate type numbers to strings."

.BUILTIN "[cast]" (bat[any::1,any] v, int type_specifier) : bat[any::1,any] = CMDbatcast;
"Cast values explicitly, using an integer-expression as type specifier."

.BUILTIN cast(any v, int type_specifier) : any = CMDcast;
"Cast values explicitly, using an integer-expression as type specifier."

.BUILTIN newoid(int range) : oid = CMDnewoid;
"Reserves a range of consecutive unique OIDs; returns the lowest in range."

.BUILTIN setoid(oid base) : oid = CMDsetoid;
"Sets the oid range of consecutive unique OIDs; returns the lowest in range."

@- variables
@m
.BUILTIN varname(VARIABLE) : str = CMDvarname;
"(invoked on a simple variable): returns the variable name."

.BUILTIN varval(str) : any = CMDvarval;
"(invoked on a simple variable): returns the variable name."

.BUILTIN constant(IDENT varname, ..IDENT... ) = CMDconstant;
"Fix both type and value of a number of MIL variables."

.BUILTIN freeze(IDENT varname, ..IDENT...) = CMDfreeze;
"Fix the type of a number of MIL variables; their values can still change."

.BUILTIN assign(VARNAME, EXPRESSION) = CMDassign;
"assign (introduce) a variable by string name."

@+ Session Management
The Monet server operates a number of interpreter threads that server client
request. Clients connect to the database, allocating interpreter resources
(variable stacks, client session records, computation time on the
interpreter threads).
Every new client session implicitly creates a new thread. Every ending
client session kills one implicitly. Note that there is
a difference between killing a client session (kill(client)) and killing a
thread (threadcnt(-1)). The first action deletes a number of jobs from the
jobqueue, and interrupts the threads serving a client, whereas the killing
of a threads just decreases the number of workers; it does not delete
any client activity.
@m
.BUILTIN prompt(str prompt) = CMDprompt;
"Change the MIL client prompt string."

.BUILTIN clientid() : int = CMDclientid;
"Returns your integer session id. On the Mserver console, this returns 0."

@- Session Manipulations
@m
.BUILTIN quit() or CTRL-D = CMDquit;
"Terminates a session. Terminating the console
 (Mserver) still makes the system wait for all active clients to finish,
 before causing a database shutdown."

.BUILTIN kill(int clientid) = CMDkill;
"Kills a client session. Killing the console (clientid = 0) is a system
 shutdown.
 WARNING: if BAT-modifying operations are killed, we do not
 garuantee *anything*!!"

.BUILTIN fork(STATEMENT) : int = CMDfork;
"Open a new client session to execute this request.
 FUTURE: forks on remote Mservers.
 Returns new client id."

@- Thread Management
@m
.BUILTIN threadcnt(int inc) : int = CMDthreadcnt;
"Increases or decreases the number of active interpreter threads.
 returns the number of active threads."

.BUILTIN threadid() : int = CMDthreadid;
"Returns your the id of the thread running your MIL interpreter."

.BUILTIN runon(STATEMENT, int threadno) = CMDrunon;
"A statement can be designated to a particular thread
 using the runon command."

@+ Queue Management Commands
@m
.BUILTIN queue() = CMDqueue;
"Print the Monet Interpreter job queue."

.BUILTIN qstat() = CMDqstat;
"Print the MIL-queue statistics."

.BUILTIN qtrace(INT jobnumber) = CMDqtrace;
"Set the MIL-queue performance tracer."
@{
@{
@
.BUILTIN enqueue(STATEMENT) : int
		= CMDenqueue;
"Put a piece of MIL into the MIL-queue. Returns the new job-number"

.BUILTIN dequeue(int jobnumber) = CMDdequeue;
"Delete a job from the MIL-queue."

.BUILTIN wakeup(int jobnumber) = CMDwakeup;
"Activate a job in the MIL-queue for execution."

.BUILTIN before(int job1, INT job2) = CMDbefore;
"Specify that job2 depends on job1."

.BUILTIN notify(ptr ov, ptr event) = CMDnotify;
"dunno really"

.BUILTIN stop() = CMDstop;
"The stop command cancels all invokations of a trigger routine."
@
@}
@}
@- Flow of Control
@m
.BUILTIN ERROR(str format, ...any...) = CMDERROR;
"Produce an error message, much like in C-printf() format.
 This raises an error, meaning that MIL statement execution will terminate."

.BUILTIN eval(str format) : any = CMDeval;
"Evaluates a MIL-script, given as a string."

.BUILTIN CATCH(STATEMENT) : str = CMDcatch;
"Turns on buffering of error messages while executing STATEMENT.
 Error messages that occur during this execution are returned as a string.
 If no error occurrs, catch returns str(nil)."

.BUILTIN RAISE(str err) = CMDraise;
"Raise the errors that were captured by the catch statement."

.BUILTIN call(str function, bat[str,str] b) : any = CMDcall;
"Evaluate a function with a variable number of parameters that come from
 a bat. Each bun in the bat is one parameter (in ordrder). The head contains
 the integer type number, and the tail a string representation. Each parameter
 value is obtained by doing a cast from string to that type."

.BUILTIN source(str mil_file) : any = interpret_file;
"Read and evaluate a MIL-script from a file. Relative paths start from
 the database directory"

@- Debugging
@m
.BUILTIN debugmask(MASK) : int  = CMDdebug;
"Return the debug mask. If a MASK is passed, set it to that value."

.BUILTIN whack(int i) : int = CMDwhack;
"Cut the reference from a BAT in the BBPcache; return its BUN heap pointer."

@- Printing
@m
.COMMAND print(ANY value) = CMDprint_val;
"Print a MIL value between square brackets."

.COMMAND print(BAT[ANY::1,ANY], ...BAT[ANY::1,ANY]...) = CMDprint_table;
 "BATs are printed with '#' for legend lines, and the BUNs on seperate
 lines between brackets, containing each to comma separated values
 (head and tail).
 If multiple BATs are passed for printing, print() performs an implicit
 natural join, producing a multiattribute table."

.COMMAND print(INT order, BAT[ANY::1,ANY], ...BAT[ANY::1,ANY]...)
                                                = CMDprint_otable;
 "The same as normal table print, but enforces to use the order of
  BAT number [1..argc] to do the printing."

.COMMAND table(BAT[any::1,any], ...BAT[any::1,any]...) = print_table_default;
	"Print an n-ary table. Like print(n-ary) but does not print oid column"

.COMMAND table(INT order, BAT[any::1,any], ...BAT[any::1,any]...) = print_table;
	"Print an n-ary table. Use the ordering of param [1..argc]"

.COMMAND multitable(BAT[any,bat]) = CMDprint_multitable;
	"Print an n-ary table contained within a BAT of BATs"

.COMMAND printf(str format, ...) = print_format;
	"Print a formatted string on the standard client output."

.COMMAND sprintf(str format, ...) : str = print_str;
	"Print a formatted string on the standard client output."


.END builtin;

@{
@* Implementation
The routines for Monet command interpretation are collected here.
Each command is passed the parse tree and a pointer where the result
should be delivered.

@c
#include "monetdb4_config.h"
#include "gdk.h"
#include "monet.h"
#include "monet_context.h"
#include "monet_client.h"
#include "monet_queue.h"
#include "monet_parse.h"
#include "builtin.proto.h"

@+ Useful Macros
The below Mx macros serve to easily  factor out the parameter handling
in the Monet Command implementations. Since there are two types of commands:
 -- builtin commands, which receive raw YYTREE parse trees as parameters.
 -- standard commands, which receive already evaluated things, i.e. value
  records as parameters.

@-
Builtin command argument check.
@= builtin_args
	if (lt->cnt != @1) {
		return handle_argerror(res,lt->cnt,@1);
	}

@= builtin_operand
{
	int _k = interpret(stk, arg(lt, @1), res);

	if (_k < 0) {
		return _k;
	}
	@3 = VALconvert(@2, res);
	if (((ptr) @3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
		return handle_paramerror(res,@1,res->vtype,@2);
	}
}
@= return_void
	res->vtype = TYPE_void;
	res->val.oval = void_nil;

@+ Module Management
The builtin command @%CMDmodule@ loads a Monet extension module for
that user. Functions and types defined in that module, can then be
accessed by him her (but not by other users!). The operation
may involve dynamic loading and linking of extra object code.

The @%CMDdrop@ command drops a module: functions and types defined
by that module cease to be known for that user.

@c
int
CMDmodule(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int ret = 0;
	Client c;

	/* run initscript in the clients lowest stack */
	CNTXTclient(stk, &c);

	if (lt->cnt == 1) {
		ValRecord res1;
		str initstr = NULL;
		str mod;

		(void) interpret(c->stk, lt->yysons[0], &res1);
		if (ret < 0 || res1.vtype != TYPE_str) {
			GDKerror("CMDmodule: illegal argument.\n");
			return GDK_FAIL;
		}
		mod = res1.val.sval;
		initstr = moduleClient(c, mod, moduleGetClient(c));
		if (initstr != NULL) {
			moduleEnterClient(c, mod);
			ret = interpret_str(c->stk, initstr, res);
			moduleExitClient(c);
			GDKfree(initstr);
		}
	} else {
		GDKerror("module(str) called with too many (%d) arguments", 
		lt->cnt);
		return GDK_FAIL;
	}
	if (ret < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
CMDdrop(Cntxt stk, YYSTREE lt, ValPtr res)
{
	Client c;

	(void) res;
	/* TODO maybe run drop also in the lowest stack context ?? */
	CNTXTclient(stk, &c);
	return dropClient(c, lt);
}

int
CMDmodule_peek(Cntxt stk, YYSTREE lt, ValPtr res)
{
	str r = NULL;
	Client c;

	(void) lt;

	CNTXTclient(stk, &c);
	r = moduleGetClient(c);
	if (!r)
		r = "main";

	res->val.sval = GDKstrdup(r);
	res->len = strLen(r);
	res->vtype = TYPE_str;

	return GDK_SUCCEED;
}

int
CMDmodule_enter(Cntxt stk, YYSTREE lt, ValPtr res)
{
	str mod = NULL;
	Client c;

	CNTXTclient(stk, &c);
	@:builtin_args(1)@
	@:builtin_operand(0,TYPE_str,mod)@
	moduleEnterClient(c, mod);
	res->vtype = TYPE_void;
	return GDK_SUCCEED;
}

int
CMDmodule_exit(Cntxt stk, YYSTREE lt, ValPtr res)
{
	Client c;

	(void) lt;

	CNTXTclient(stk, &c);
	moduleExitClient(c);
	res->vtype = TYPE_void;
	return GDK_SUCCEED;
}

@+ Value, Types and Variables
@c
int
CMDnewoid(Cntxt stk, YYSTREE lt, ValPtr res)
{
	if (lt->cnt <= 0) {
		res->val.oval = OIDnew(1);
	} else {
		int *inc;

		@:builtin_operand(0,TYPE_int,inc)@
		res->val.oval = OIDnew(*inc);
	}
	res->vtype = TYPE_oid;
	return 1;
}

int
CMDsetoid(Cntxt stk, YYSTREE lt, ValPtr res)
{
	if (lt->cnt == 0) {
		res->val.oval = OIDbase(1);
	} else {
		oid *inc;

		@:builtin_operand(0,TYPE_oid,inc)@
		res->val.oval = OIDbase(*inc);
	}
	res->vtype = TYPE_oid;
	return 1;
}

int
CMDtype(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int r;

	@:builtin_args(1)@
	if ((r = interpret(stk, lt->yysons[0], res)) >= 0) {
		res->val.ival = res->vtype;
		res->vtype = TYPE_int;
	}
	return r;
}

int
CMDcast(Cntxt stk, YYSTREE lt, ValPtr res)
{
	ValRecord argv[2];
	int i, tpe;

	@:builtin_args(2)@
	i = interpret(stk, lt->yysons[1], argv);
	tpe = argv[0].val.ival;
	if (i < 0 || argv[0].vtype != TYPE_int || tpe < 0 || tpe > GDKatomcnt) {
		GDKerror("CMDcast: 2nd parameter should be INT type specifier.\n");
		return -1;
	}
	i = interpret(stk, lt->yysons[0], argv);
	if (i < 0)
		return i;
	return interpret_cast(ATOMname(tpe), 2, argv, res);
}

int
CMDbatcast(Cntxt stk, YYSTREE lt, ValPtr res)
{
	ValRecord argv[2];
	int i, tpe, bid;

	@:builtin_args(2)@
	i = interpret(stk, lt->yysons[1], argv);
	tpe = argv[0].val.ival;
	if (i < 0 || argv[0].vtype != TYPE_int || tpe < 0 || tpe > GDKatomcnt) {
		GDKerror("CMDbatcast: 2nd parameter should be INT type specifier.\n");
		return -1;
	}
	i = interpret(stk, lt->yysons[0], argv);
	if (i < 0 || argv[0].vtype != TYPE_bat || !BATdescriptor(bid = argv[0].val.bval)) {
		GDKerror("CMDbatcast: first parameter should be a valid bat.\n");
		return -1;
	}
	i = interpret_batcast(ATOMname(tpe), 2, argv, res);
	BBPunfix(bid);
	return i;
}

int
CMDvarname(int stk, YYSTREE lt, ValPtr res)
{
	(void) stk;
	if (lt->cnt == 1 && lt->yysons[0] && (int) lt->yysons[0]->token == monet_tokident) {
		res->val.sval = GDKstrdup(lt->yysons[0]->yyval.val.sval);
		res->len = strLen(lt->yysons[0]->yyval.val.sval);
		res->vtype = TYPE_str;
		return 0;
	}
	GDKerror("CMDvarname: not invoked on a variable.\n");
	return -1;
}

int
CMDvarval(int stk, YYSTREE lt, ValPtr res)
{
	if (lt->cnt == 1 && lt->yysons[0]) {
		int i = interpret(stk, lt->yysons[0], res);

		if (i >= 0 && res->vtype == TYPE_str) {
			Variable act = VARfind(&stk, res->val.sval);

			if (act != NULL) {
				VALcopy(res, &act->binding);
				ATOMfix(res->vtype, VALptr(res));
				return 0;
			}
		}
	}
	GDKerror("CMDvarval: not invoked on a variable.\n");
	return -1;
}

int
CMDassign(int stk, YYSTREE lt, ValPtr res)
{
	int i = -1;

	if (lt->cnt == 2 && interpret(stk, lt->yysons[0], res) >= 0 && res->vtype == TYPE_str) {
		YYSTREE tt = Myynode(TOK_ASSIGNMENT, 0);
		YYSTREE t = Myynode(TOK_IDENT, 0);

		VALcopy(&t->yyval, res);
		t->yyval.len = 0;	/* HACK: context level */
		Myyexpand(tt, t);
		Myyexpand(tt, lt->yysons[1]);

		i = interpret_assignment(stk, tt, res);
		tt->yysons[1] = NULL;
		tt->cnt = 1;
		Myyfree(tt);
	}
	res->vtype = TYPE_void;
	res->val.oval = oid_nil;
	return i;
}

int
CMDdebug(int stk, YYSTREE lt, ValPtr res)
{
	if (lt->cnt == 1 && interpret(stk, lt->yysons[0], res) >= 0 && res->vtype == TYPE_int) {
		GDKdebug = res->val.ival;
	} else {
		VALclear(res);
	}
	res->vtype = TYPE_int;
	res->val.ival = GDKdebug;
	return 0;
}

@- whack a bat
DEBUGGING ONLY: whack removes the bat reference; to be used in purify
sessions to see who created it.
@c
int
CMDwhack(int stk, YYSTREE lt, ValPtr res)
{
	if (lt->cnt == 1 && interpret(stk, lt->yysons[0], res) >= 0 && res->vtype == TYPE_int && ABS(res->val.ival) < BBPsize && BBP_cache(res->val.ival)) {
		bat bid = res->val.ival;

		res->vtype = TYPE_ptr;
		res->val.pval = (ptr) BBP_cache(bid)->batBuns->base;
		BBP_cache(bid)->batBuns->base = NULL;
		BBP_cache(bid) = BBP_cache(-bid) = 0;
		return 0;
	}
	GDKerror("CMDwhack: %d illegal BAT.\n", res->val.ival);
	return -1;
}

@-
Likewise, the type of a variable can be frozen
@c
int
CMDfreeze(Cntxt stk, YYSTREE lt, ValPtr res)
{
	unsigned i;
	int j;
	Variable act;
	YYSTREE t;

	(void) res;

	for (t = lt; t; t = YYOVERFLOW(t)) {
		for (i = 0; i < lt->cnt; i++) {
			if ((int) arg(t, i)->token == monet_tokident) {
				str nme = arg(t, i)->yyval.val.sval;
				int s = stk;

				for (j = arg(t, i)->yyval.len; j > 0; j--) {
					if (s >= 0) {
						s = monet_cntxt[s].outer;
					} else {
						GDKerror("CMDfreeze: illegal context.\n");
						return -1;
					}
				}
				if ((act = VARfind(&s, nme)) == 0) {
					GDKerror("CMDfreeze: variable '%s' does not exist.\n", nme);
					return -1;
				}
				if (act->constant) {
					GDKerror("CMDfreeze: cannot freeze constant '%s'.\n", nme);
					return -1;
				}
				VARfreeze(act);
			} else {
				GDKerror("CMDfreeze: FREEZE works on variable names only.\n");
				return -1;
			}
		}
	}
	return 0;
}


@- Process Control
You can now kill clients.They are identified by their number.
This is a necessary command for background jobs, but can also
be used to stop out-of-hand jobs. There is no protection system yet!
@c
int
CMDclientid(Cntxt stk, YYSTREE lt, ValPtr res)
{
	Client c;

	(void) lt;
	CNTXTclient(stk, &c);
	res->vtype = TYPE_int;
	if (c->father >= 0) {
		res->val.ival = c->father;
	} else {
		res->val.ival = (int) (c - monet_clients);
	}
	return 0;
}

int
CMDkill(Cntxt stk, YYSTREE lt, ValPtr res)
{
	Client c, self;
	int *i;

	@:builtin_args(1)@;
	@:builtin_operand(0,TYPE_int,i)@
	CNTXTclient(stk, &self);
	CNTXTclient(*i, &c);
	if (c == self) {
		GDKerror("CMDkill: cannot kill self.\n");
		return -1;
	}
	if (c == monet_clients) {
		GDKerror("CMDkill: cannot kill console.\n");
		return -1;
	}
	killClient(c, TRUE);
	@:return_void@
	return 0;
}

int
CMDfork(Cntxt stk, YYSTREE lt, ValPtr res)
{
	Client c;

	@:builtin_args(1)@;
	if (GDKembedded && monet_forks != 0) {
		GDKerror("CMDfork: cannot execute twice in -embedded mode.\n");
		return -1;
	}
@-
Create a shadow client. This is necessary in order not to mangle
cntxt record administration between running jobs. They need to belong
to different clients.  Schedule the background request.
@c
	c = forkClient(stk, TRUE);
	if (c == NULL) {
		GDKerror("CMDfork: error creating a new thread.\n");
		return -1;
	}
	res->vtype = TYPE_int;
	res->val.ival = c->stk;
	c->tree = Myycopy(lt->yysons[0]);
	QMwakeup(QMenqueue(c->stk, c->tree, 0, (int) (c - monet_clients)));

	return 1;
}

@+ Thread management
Monet is a multi-threaded database server. The number of
threads is controlled by the command @%thread(N)@, which
ensures that N threads becomes active. If N exceeds the
current number then the missing are created. If N is smaller
than the number of active threads, it places a sequence of kill
instructions into the message queue.
They are picked up by the interpreters and lead to their termination.
@-
The command @%CMDthread@ tells the system to increase or decrease
the number of interpreter threads. It should ensure that there are
enough threads to satisfy the client access [TODO]
@c
int
CMDthreadcnt(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int *i;

	if (GDKembedded) {
		GDKerror("CMDfork: cannot execute in -embedded mode.\n");
		return -1;
	}
	@:builtin_args(1)@;
	@:builtin_operand(0,TYPE_int,i)@
	res->vtype = TYPE_int;
	res->val.ival = monetAdjustThreads(*i);
	return 0;
}

int
CMDthreadid(Cntxt stk, YYSTREE lt, ValPtr res)
{
	(void) stk;
	(void) lt;
	res->vtype = TYPE_int;
/* res->val.ival = (int) MT_getpid(); */
	res->val.ival = THRgettid();
	return 0;
}

int
CMDrunon(Cntxt stk, YYSTREE lt, ValPtr res)
{
	ptr p;
	int i;
	Request q;

	@:builtin_args(2)@
	@:builtin_operand(1,TYPE_int,p)@
	i = *(int *) p;
	if ((i < 0) || (i >= THREADS)) {
		GDKerror("CMDrunon: Illegal thread\n");
		return -1;
	} else {
		q = newRequest(stk, arg(lt, 0), 0);
		q->ev_process = GDKthreads[i].pid;
		putRequest(q);
		lt->yysons[0] = 0;
	}
	@:return_void@
	return 0;
}


@+ Queue Management Commands
The contents of the Monet Queue can be monitored with @%CMDqueue@.
The corresponding history sequence can be obtained with @%CMDqueueStat@.
@c
int
CMDqueue(Cntxt stk, YYSTREE lt, ValPtr res)
{
	(void) stk;
	(void) lt;
	(void) res;
	QMprint();
	return 0;
}

int
CMDqstat(Cntxt stk, YYSTREE lt, ValPtr res)
{
	(void) stk;
	(void) lt;
	(void) res;
	QMprintStat();
	return 0;
}

int
CMDqtrace(Cntxt stk, YYSTREE lt, ValPtr res)
{
	ptr p;

	@:builtin_args(1)@;
	@:builtin_operand(0,TYPE_int,p)@
	QMtrace(*(int *) p);
	@:return_void@
	return 0;
}

@{
@-
The queue can also be managed by the user explicitly.
@c
#ifdef MKMODS
int
CMDenqueue(Cntxt stk, YYSTREE lt, ValPtr res)
{
	res->vtype = TYPE_int;
	res->val.ival = QMenqueue(stk, lt->yysons[0], 0, 0);
	lt->yysons[0] = 0;
	return 0;
}

int
CMDdequeue(Cntxt stk, YYSTREE lt, ValPtr res)
{
	ptr p;

	@:builtin_args(1)@;
	@:builtin_operand(0,TYPE_int,p)@
	QMdequeue(*(int *) p);
	@:return_void@
	return 0;
}

int
CMDwakeup(Cntxt stk, YYSTREE lt, ValPtr res)
{
	ptr p;

	@:builtin_args(1)@;
	@:builtin_operand(0,TYPE_int,p)@
	QMwakeup(*(int *) p);
	@:return_void@
	return 0;
}

int
CMDbefore(Cntxt stk, YYSTREE lt, ValPtr res)
{
	ptr p, q;

	@:builtin_args(2)@;
	@:builtin_operand(0,TYPE_int,p)@
	@:builtin_operand(1,TYPE_int,q)@
	QMbefore(*(int *) p, *(int *) q);
	@:return_void@
	return 0;
}

@+ Trigger Management
The notify command awakens all interested triggers and places awakening
events in the queue. The argument is a variable name or a BAT modifier.
Actually, notification should be separated from re-activation, because
a trigger scheduler may decide on a different order of execution.
@c
int
CMDnotify(Cntxt stk, YYSTREE lt, ValPtr res)
{
	ptr p;
	str name;
	int obj = 0;
	Variable v;
	YYSTREE ev = 0, ov = 0;

	if (lt->cnt < 1 || lt->cnt > 2) {
		GDKerror("CMDnotify: two arguments expected.\n");
		return -1;
	}
	if (lt->cnt == 2) {
		ov = arg(lt, 0);
		ev = arg(lt, 1);
	} else {
		ev = arg(lt, 0);
		ov = 0;
	}
	if (ev->token == monet_tokident) {
		name = (str) ev->yyval.val.sval;
	} else {
		@:builtin_operand(0,TYPE_str,p)@
		name = (str) p;
	}

	if (ov && ov->token == monet_tokident) {
		v = VARfind(&stk, ov->yyval.val.sval);
		if (v == 0) {
			GDKerror("CMDnotify: variable not found\n");
			return -1;
		}
		if (v->binding.vtype != TYPE_int) {
			GDKerror("CMDnotify: int variable expected\n");
			return -1;
		}
		obj = v->binding.val.ival;
	} else if (ov) {
		@:builtin_operand(0,TYPE_int,p)@
		obj = *(int *) p;
	}
	TEMnotify(stk, name, &obj);
	@:return_void@
	return 0;
}

int
CMDstop(Cntxt stk, YYSTREE lt, ValPtr res)
{
	return 0;
}
#endif /* MKMODS */
@
@}


@+ Session control
The quit command terminates a session of a single user.
If we are running in embedded mode we may accept a new
client again.
@c
int
CMDquit(Cntxt stk, YYSTREE lt, ValPtr res)
{
	Client c;

	CNTXTclient(stk, &c);
	while (c->father >= 0) {
		c = monet_clients + c->father;
	}
	if (c == monet_clients) {
		int status = 0, *statusp = &status;

		if (lt->cnt > 0) {
			@:builtin_operand(0,TYPE_int,statusp)@
		}
		monet_running = 0;
		stopProfiler();
		/*
		   freeClient(c);
		   monet_exit(*statusp);
		 */
		stream_flush(GDKout);
		stream_destroy(GDKout);
		MT_global_exit(*statusp);
	}
	c->mode = FINISHING;
	if (GDKembedded && monet_forks > 0)
		return 0;
	/* TODO: this is still needed for forked clients 
	Request q, r;
	q = topRequest(c);
	if (q) {
		q->ev_kill = 1 + c->stk;
		r = q->ev_wakeup;
		if (r)
			rmRequest(r);
		q->ev_wakeup = NULL;
	}
	*/
	return 0;
}

@-
The client prompt can be changed to suite front-ends in their
communication with the server.
@c
int
CMDprompt(Cntxt stk, YYSTREE lt, ValPtr res)
{
	Client c;
	ptr x;

	if (lt->cnt == 1) {
		@:builtin_operand(0,TYPE_str,x)@
		for (; monet_cntxt[stk].outer > 0; stk = monet_cntxt[stk].outer)
			;
		c = monet_clients + stk;
		c->prompt = (char *) GDKstrdup(x);
		stream_printf(GDKout, "# new prompt for %s (%d):%s\n", c->user, (int) stk, c->prompt);
	} else {
		GDKwarning("prompt: argument missing\n");
	}
	@:return_void@
	return 0;
}


int
CMDERROR(Cntxt stk, YYSTREE lt, ValPtr res)
{
	ValRecord argv[MAXPARAMS];
	unsigned i;

	(void) res;

	if (lt->cnt < 1) {
		return -1;
	}
	if (lt->cnt > MAXPARAMS) {
		GDKerror("CMDERROR: too many arguments.\n");
		return -1;
	}
	for (i = 0; i < lt->cnt; i++) {
		interpret(stk, lt->yysons[i], argv + i);
	}
	if (argv[0].vtype != TYPE_str) {
		GDKerror("CMDERROR: string expected.\n");
		return -1;
	}
	(void) monet_syscall((GDKfcn) GDKerror, lt->cnt, argv);
	return -1;
}

@-
Prelude files and libraries of code are read in one shot and scheduled
for processing. In both situations a line mode is not required, even
a stand in the way.
@c
int
CMDeval(Cntxt stk, YYSTREE lt, ValPtr res)
{
	char *mil_str;
	int i;

	@:builtin_args(1)@
	res->vtype = TYPE_void;
	@:builtin_operand(0,TYPE_str,mil_str)@
	i = interpret_str(stk, mil_str, res);
	CATCHRET(stk, lt, res, i);
	return i;
}

@-
@c
int
CMDcatch(Cntxt stk, YYSTREE lt, ValPtr res)
{
	char errbuf[GDKMAXERRLEN], *head = errbuf, *bak = GDKerrbuf;
	int mode = 0;

	/* execute the MIL expression while catching all errors and warnings */
	*errbuf = 0;
	GDKsetbuf(errbuf);
	if (lt->cnt >= 1) {
		int i = interpret(stk, lt->yysons[0], res);

		CATCHRET(stk, lt, res, i);
	}
	GDKsetbuf(bak);

	/* allocate a buffer that will contain all error lines.  Make
	   sure it is large enough to contain str_nil. */
	res->vtype = TYPE_str;
	res->len = MAX(strLen(errbuf), strLen(str_nil));
	res->val.sval = (str) GDKmalloc(res->len);
	res->val.sval[0] = 0;

	/* filter catchings: error lines go to result; warning lines become warnings */
	while (*head) {
		int newmode = 0;
		str tail = head;

		while (*tail++ && tail[-1] != '\n')
			;
		if (strncmp(head, GDKWARNING, strlen(GDKWARNING)) == 0) {
			newmode = 1;
		} else if (strncmp(head, GDKERROR, strlen(GDKERROR)) == 0) {
			newmode = 2;
		}
		if (newmode) {
			int c = *head;

			*head = 0;
			if (mode == 1) {
				GDKwarning(bak + strlen(GDKWARNING));
			} else if (mode == 2) {
				strcat(res->val.sval, bak);
			}
			mode = newmode;
			bak = head;
			*head = c;
		}
		head = tail;
	}
	if (mode == 1) {
		GDKwarning(bak + strlen(GDKWARNING));
	} else if (mode == 2) {
		strcat(res->val.sval, bak);
	}
	if (*res->val.sval == 0) {
		strcpy(res->val.sval, str_nil);	/* return str_nil if no errors */
		res->len = strLen(str_nil);
	}
	return 0;
}

int
CMDraise(Cntxt stk, YYSTREE lt, ValPtr res)
{
	str s;

	@:builtin_args(1)@;
	@:builtin_operand(0,TYPE_str,s)@
	if (*s != *str_nil) {
		GDKaddbuf(s);
	}
	@:return_void@
	return 0;
}

int
CMDcall(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int xx, bid, i = 0;
	YYSTREE t, child;
	ValRecord v;
	BUN p, q;
	BAT *b;

	@:builtin_args(2)@
	@:builtin_operand(0,TYPE_str,p)@
	v = *res;
	@:builtin_operand(1,TYPE_bat,q)@
	bid = *(bat *) q;

	b = BATdescriptor(bid);
	if (b == NULL) {
		GDKerror("CMDcall: wrong BAT parameter %s.\n", BATgetId(b));
		BBPunfix(bid);
		return -1;
	}
	t = Myynode(TOK_FUNCTION, 0);
	Myyexpand(t, Myynode(0, 0));
	Myyexpand(t, Myynode(0, TYPE_int));
	t->yysons[1]->yyval.val.ival = sizeof(ValRecord);
	t->yyval = v;
	BATloopFast(b, p, q, xx) {
		child = Myynode(TOK_CONSTANT, 0);
		if (b->htype == TYPE_str) {
			i = ATOMindex(BUNhvar(b, p));
			if (i < 0) {
				GDKerror("CMDcall: wrong type %s.\n", BUNhvar(b, p));
				break;
			}
			v.vtype = TYPE_str;
			v.len = strLen(v.val.sval = (str) BUNtvar(b, p));
			i = interpret_cast(BUNhvar(b, p), 2, &v, res);
			if (i < 0) {
				GDKerror("CMDcall: wrong value %s(%s).\n", BUNhvar(b, p), BUNtvar(b, p));
				break;
			}
		} else {
			v.vtype = BATttype(b);
			if (ATOMextern(v.vtype)) {
				i = ATOMlen(v.vtype, BUNtail(b, p));
				memcpy(v.val.pval = GDKmalloc(i), BUNtail(b, p), i);
			} else {
				VALset(&v, v.vtype, BUNtail(b, p));
			}
		}
		child->yyval = *res;
		Myyexpand(t->yysons[0], child);
		t->yysons[1]->yyval.val.ival += sizeof(ValRecord);
	}
	res->vtype = TYPE_void;
	if (i == 0) {
		i = interpret(stk, t, res);
		CATCHRET(stk, t, res, i);
	}
	t->yyval.vtype = TYPE_void;
	Myyfree(t);
	BBPunfix(bid);
	return i;
}

@+ Printing
@c
int
CMDprint_val(ptr val, int tpe)
{
	stream *fp = GDKout;

	if (stream_write(fp, "[ ", 2, 1) != 1)
		return GDK_FAIL;
	ATOMprint(tpe, val, fp);
	if (stream_errnr(fp))
		return GDK_FAIL;
	return stream_write(fp, " ]\n", 3, 1) == 1 ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDprint_bats(int argc, BAT *argv[], int order)
{
	stream *fp = GDKout;

	BATmultiprintf(fp, argc + 1, argv, TRUE, order, 1);
	return GDK_SUCCEED;
}

int
CMDprint_otable(int *order, BAT *arg1, ...)
{
	BAT *b, *piv[MAXPARAMS];
	int nbats = 0;
	va_list ap;

	va_start(ap, arg1);
	piv[nbats++] = arg1;
	while ((b = va_arg(ap, BAT *)) != NULL) {
		if (nbats >= MAXPARAMS) {
			va_end(ap);
			GDKerror("print_table: too many arguments.\n");
			return GDK_FAIL;
		}
		piv[nbats++] = b;
	}
	return CMDprint_bats(nbats, piv, *order);
}

int
CMDprint_table(BAT *b, ...)
{
	BAT *piv[MAXPARAMS];
	int nbats = 0;
	va_list ap;

	va_start(ap, b);
	if (!b)
		return GDK_FAIL;
	do {
		if (nbats >= MAXPARAMS) {
			va_end(ap);
			GDKerror("print_table: too many arguments.\n");
			return GDK_FAIL;
		}
		piv[nbats++] = b;
	} while ((b = va_arg(ap, BAT *)) != NULL);

	return CMDprint_bats(nbats, piv, 0);
}

int
CMDprint_multitable(BAT *b)
{
	BAT *piv[MAXPARAMS];
	int nbats = 0;
	BUN p, q;
	int xx;

	BATloopFast(b, p, q, xx) {
		piv[nbats++] = BATdescriptor(*(bat *) BUNtail(b, p));
	}

	BATmultiprintf(GDKout, nbats + 1, piv, FALSE, 0, 1);

	BATloopFast(b, p, q, xx) {
		BBPunfix(*(bat *) BUNtail(b, p));
	}

	return GDK_SUCCEED;
}

int
print_format(str format, ...)
{
	va_list ap;
	int ret;
	str s;

	va_start(ap, format);
	ret = monet_sprintf(&s, format, ap);
	va_end(ap);
	if (ret == GDK_FAIL) {
		return GDK_FAIL;
	}
	ret = (int) stream_write(GDKout, s, strlen(s), 1);
	GDKfree(s);
	if (ret < 0) {
		GDKsyserror("printf():");
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int
print_str(str *s, str format, ...)
{
	va_list ap;
	int ret;

	va_start(ap, format);
	ret = monet_sprintf(s, format, ap);
	va_end(ap);
	return ret;
}

int
print_table(int *order, BAT *arg1, ...)
{
	BAT *piv[MAXPARAMS + 1];
	int argc = 0;
	va_list ap;

	va_start(ap, arg1);
	piv[argc++] = arg1;
	do {
		if (argc > MAXPARAMS) {
			va_end(ap);
			GDKerror("print_table: too many arguments.\n");
			return GDK_FAIL;
		}
		piv[argc] = va_arg(ap, BAT *);
	} while (piv[argc++]);
	va_end(ap);
	BATmultiprintf(GDKout, argc, piv, FALSE, *order, 1);
	return GDK_SUCCEED;
}

int
print_table_default(BAT *b, ...)
{
	BAT *piv[MAXPARAMS + 1];
	int argc = 1;
	va_list ap;

	piv[0] = b;
	va_start(ap, b);
	do {
		if (argc > MAXPARAMS) {
			va_end(ap);
			GDKerror("print_table_default: too many arguments.\n");
			return GDK_FAIL;
		}
		piv[argc] = va_arg(ap, BAT *);
	} while (piv[argc++]);
	va_end(ap);
	BATmultiprintf(GDKout, argc, piv, FALSE, 0, 1);
	return GDK_SUCCEED;
}
@}
