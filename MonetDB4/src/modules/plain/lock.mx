@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f lock
@t Lightweight Lock Module
@v 1.0
@a Peter Boncz
@* Introduction
This module provides simple SMP lock and thread functionality
as already present in the Monet system.

@* MEL Definitions
@m
.MODULE lock;

@- lock
@m
.ATOM lock = PTR;
.END;

.COMMAND lock_create() : lock = create_lock;
	"create an unset lock"
.COMMAND lock_set(lock) = set_lock;
	"try to set a lock; if set, block till it is freed"
.COMMAND lock_try(lock) : int = try_lock;
	"try a lock, if free set it and return 0, if not return EBUSY"
.COMMAND lock_unset(lock) = unset_lock;
	"unset a lock"
.COMMAND lock_destroy(lock) = destroy_lock;
	"destroy a lock"

@- semaphores
@m
.ATOM sema = PTR;
.END;

.COMMAND sema_create(int init) : sema = create_sema;
	"create an unset sema, with an initial value"
.COMMAND sema_down(sema) = down_sema;
	"decrease the semaphpore if >0; else block"
.COMMAND sema_up(sema) = up_sema;
	"increase the semaphore"
.COMMAND sema_destroy(sema) = destroy_sema;
	"destroy a sema"

.END lock;

@mil
	CONST EBUSY := 16;

@{
@* Implementation
@h
typedef ptr lock;
typedef ptr sema;
typedef ptr monet_lock;
typedef ptr monet_sema;
@c
#include "monetdb4_config.h"
#include <gdk.h>
#include "lock.h"

#include "lock.proto.h"

int
create_lock(monet_lock *l)
{
        *l = (monet_lock) GDKmalloc(sizeof(MT_Lock));
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_init((MT_Lock*) *l, "create_lock");
	return GDK_SUCCEED;
}

int
set_lock(monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_set((MT_Lock*) *l, "set_lock");
	return GDK_SUCCEED;
}

int
try_lock(int *res, monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	*res = MT_lock_try((MT_Lock*) *l) ? EBUSY : 0;
	return GDK_SUCCEED;
}

int
unset_lock(monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_unset((MT_Lock*) *l, "unset_lock");
	return GDK_SUCCEED;
}

int
destroy_lock(monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_destroy((MT_Lock*) *l);
	GDKfree(*l);
	return GDK_SUCCEED;
}

int
create_sema(monet_sema *s, int *init)
{
        *s = (monet_sema) GDKmalloc(sizeof(MT_Sema));
	if (*s == NULL || *s == ptr_nil) return GDK_FAIL;
	MT_sema_init((MT_Sema *) *s, *init, "create_sema");
	return GDK_SUCCEED;
}

int
up_sema(monet_sema *s)
{
	if (*s == NULL || *s == ptr_nil) return GDK_FAIL;
	MT_sema_up((MT_Sema*) *s, "up_sema");
	return GDK_SUCCEED;
}

int
down_sema(monet_sema *s)
{
	if (*s == NULL || *s == ptr_nil) return GDK_FAIL;
	MT_sema_down((MT_Sema*) *s, "down_sema");
	return GDK_SUCCEED;
}

int
destroy_sema(monet_sema *s)
{
	if (*s == NULL || *s == ptr_nil) return GDK_FAIL;
	MT_sema_destroy((MT_Sema*) *s);
	GDKfree(*s);
	return GDK_SUCCEED;
}

@}
