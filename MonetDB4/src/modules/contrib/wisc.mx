@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f wisc
@t Monet Wisconsin Database Generator
@a M.L. Kersten
@v 1.1
@* Introduction
The Wisconsin Benchmark has become the simpliest benchmark  to asses
the implementation of a relational database.
The generator presented here has bee used to directly construct the
benchmark database in a series of BATs. The core code has been used
to derive the information presented in the thesis of C vd Berg.

The routines not mentioned in the MODULE interface are obsolete
and should be checked before being used.

The generator can be loaded as a module into any running server.

@m
.MODULE wisc;

.COMMAND wisc(str,int) = WISCgenerator; 
	"Wisconsin Benchmark Database Generator"
.COMMAND wiscdestroy(str) = WISCdestroy; 
	"WBD destroy table"
.END wisc;

@{
@* Implementation
@c
#include "monetdb4_config.h"
#include "gdk.h"
#include "wisc.proto.h"

static char string1[54] = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
static char *rndstr;
/* static oid count; */

static void
WISCinitRndStr(int u1)
{
	int i;
	int k;
	char *p;
	char *q;

	rndstr = (char *) malloc(sizeof(char) * 7 * u1);
	p = rndstr;
	q = rndstr + 7 * u1;
	while (p < q) {
		*p++ = 'A';
	}

	for (i = 1, p = rndstr, q = rndstr + 7; i != u1; i++) {
		for (k = 0; k != 7; k++, p++, q++) {
			*q = *p + 1;
/*		if (q > rndstr+7*count) printf("bug"); */
			if (*q > 'Z') {
				*q = 'A';
			} else {
				p += 7 - k;
				q += 7 - k;
				break;
			}
		}
	}
}


static char *
rndStr(int i)
{
	int j;
	char *p, *q;

/* boundary test: i = count-1= >q = &rndstr[(count-1)+1 * 7] */
	for (j = 0, p = string1, q = &rndstr[(i + 1) * 7 - 1]; j != 7; j++) {
		*p++ = *q--;
	}
	return string1;
}


char string4[4][54] = {
	"AAAAxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
	"HHHHxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
	"OOOOxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
	"VVVVxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
};

#define rnd4Str(u) (string4[(u)%4])

int *rnd;

static void
WISCinitUniq(int cnt)
{
	int *src = (int *) malloc(sizeof(int) * cnt);
	int top = cnt;
	int i;

	srand((int) time(0));
	rnd = (int *) malloc(sizeof(int) * cnt);
	WISCinitRndStr(cnt);
	for (i = 0; i != cnt; i++) {
		src[i] = i;
	}
	for (i = 0; i != cnt; i++, top--) {
		ssize_t idx = rand() % top;

		rnd[i] = src[idx];
		src[idx] = src[top - 1];
	}
	free(src);
}

/*
ssize_t gen, prime, seed;

WISCinitUniq(int cnt)
{
	if (cnt <= 1000) { 
		gen = 279;
		prime = 1009
	} else if (cnt <= 10000) {
		gen = 2969;
		prime = 10007
	} else if (cnt <= 100000) {
		gen = 21395;
		prime = 100003;
	} else if (cnt <= 1000000) {
		gen = 2107;
		prime = 1000003;
	} else if (cnt <= 10000000) {
		gen = 211;
		prime = 10000019;
	} else if (cnt <= 100000000) {
		gen = 21;
		prime = 100000007;
	} else { 
		printf("exceeded capacity\n");
		exit(1);
	}
	seed = gen;
}

ssize_t wiscrand(ssize_t seed, ssize_t limit)
{
	do {
		seed = (gen * seed)%prime;
	} while (seed > limit);

	return seed;
}
*/
struct {
	char *attr;
	int type;
} wisctype[16] = {
	{
	"unique1", TYPE_int,}, {
	"unique2", TYPE_int,}, {
	"two", TYPE_int,}, {
	"four", TYPE_int,}, {
	"ten", TYPE_int,}, {
	"twenty", TYPE_int,}, {
	"onePercent", TYPE_int,}, {
	"tenPercent", TYPE_int,}, {
	"twentyPercent", TYPE_int,}, {
	"fiftyPercent", TYPE_int,}, {
	"unique3", TYPE_int,}, {
	"evenOnePercent", TYPE_int,}, {
	"oddOnePercent", TYPE_int,}, {
	"stringu1", TYPE_str,}, {
	"stringu2", TYPE_str,}, {
"string4", TYPE_str},};

int
WISCgenerator(str nme,		/* string: pointer to char. */
	      int *cnt		/* pointer to integer. */
    )
{
	int u1, tmp;
	oid count, u2;
	int i;
	BAT *b[16];

	count = (oid) *cnt;
	stream_printf(GDKout, "WISC generator active on \"%s\" with %d tuples\n", nme, *cnt);
	stream_flush(GDKout);

	for (i = 0; i != 16; i++) {
		char buf[150];

		sprintf(buf, "%s_%s", nme, wisctype[i].attr);
		b[i] = BATnew(TYPE_void, wisctype[i].type, count);
		BATseqbase(b[i], 0);
		BATrename(b[i], buf);
		BATmode(b[i], PERSISTENT);
	}
	WISCinitUniq(*cnt);

	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		b[0] = BUNins(b[0], &u2, &u1, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = (int) u2;
		b[1] = BUNins(b[1], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 2;
		b[2] = BUNins(b[2], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 4;
		b[3] = BUNins(b[3], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 10;
		b[4] = BUNins(b[4], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 20;
		b[5] = BUNins(b[5], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 100;
		b[6] = BUNins(b[6], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 10;
		b[7] = BUNins(b[7], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 5;
		b[8] = BUNins(b[8], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 2;
		b[9] = BUNins(b[9], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1;
		b[10] = BUNins(b[10], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 50 * 2;
		b[11] = BUNins(b[11], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 50 * 2 + 1;
		b[12] = BUNins(b[12], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		/* (void) malloc(20); */
		b[13] = BUNins(b[13], &u2, rndStr(u1), FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		b[14] = BUNins(b[14], &u2, rndStr((int) u2), FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		b[15] = BUNins(b[15], &u2, rnd4Str(u2), FALSE);
	}
	free(rnd);
	free(rndstr);
	return GDK_SUCCEED;
}

@-
The tables created for the Wisconsin database can be easily removed
by giving their base name only.
@c
int
WISCdestroy(str nme)
{
	int i;
	BAT *b;

	stream_printf(GDKout, "WISC destroy active \"%s\" \n", nme);
	stream_flush(GDKout);
	for (i = 0; i != 16; i++) {
		char buf[150];

		sprintf(buf, "%s_%s", nme, wisctype[i].attr);
		b = BATload(buf);
		if (b == 0) {
			GDKerror("WISCdestroy: %s not found\n", buf);
		} else {
			BBPreclaim(b);
		}
	}
	return GDK_SUCCEED;
}

@}
