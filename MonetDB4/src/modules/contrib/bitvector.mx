@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f bitvector
@t Bitvector datatypes
@a Peter Bosch
@v 1.0
@* Introduction

This module implements bit vectors.  One can encode a table with OIDs as
a bit vector where a bit is set when the corresponding table's OID is set.
A bit vector can also be decoded back into a real OID BAT.  Bit vectors
support the operations AND and OR.

@* Module Definition 
@m
.MODULE bitvector;

.COMMAND [allocate](wrd nbits, bit initial): 
   BAT[void,lng] = bitvector_allocate;
 "Allocate a new and empty bitvector"

.COMMAND [set](BAT[any::1,lng], wrd bnum) = bitvector_set;
 "Set a bit in a bitvector"

.COMMAND [isset](BAT[any::1,lng], wrd bnum): bit = bitvector_isset;
 "Is bit bnum set?"

.COMMAND [clr](BAT[any::1,lng], wrd bnum) = bitvector_clr;
 "Clear a bit in a bitvector"

.COMMAND [isclr](BAT[any::1,lng], wrd bnum): bit = bitvector_isclr;
 "Is bit bnum not set?"

.COMMAND [encode](BAT[any::1,oid]): BAT[void,lng] = bitvector_encode;
 "Encode a BAT with tail values into a bitvector"

.COMMAND [decode](BAT[void,lng]): BAT[oid,oid] = bitvector_decode;
 "Decodes a bitvector into a real BAT"

.COMMAND [and](BAT[void,lng], BAT[void,lng]): BAT[void,lng] = bitvector_and;
 "Logically ANDs two bitvectors"

.COMMAND [or](BAT[void,lng], BAT[void,lng]): BAT[void,lng] = bitvector_or;
 "Logically ORs two bitvectors"

.COMMAND [prt](BAT[void,lng]) = bitvector_print;
 "Print a bitvector"

.COMMAND [count](BAT[void,lng]): wrd = bitvector_count;
 "Count the number of bits set"

.END bitvector;

@mil
proc [allocate](int nbits, bit initial): bat[void,lng] {
    return [allocate](wrd(nbits), initial);
}
proc [set](bat[any::1,lng] b, int bnum): void {
    [set](b, wrd(bnum));
}
proc [isset](bat[any::1,lng] b, int bnum): bit {
    return [isset](b, wrd(bnum));
}
proc [clr](bat[any::1,lng] b, int bnum): void {
    [clr](b, wrd(bnum));
}
proc [isclr](bat[any::1,lng] b, int bnum): bit {
    return [isclr](b, wrd(bnum));
}

PROC test_bitvector() : void {

	a := new(int,oid); 
	a.insert(10, oid(0)); 
	a.insert(11, oid(62)); 
	a.insert(12, oid(64)); 
	a.insert(13, oid(256)); 

	b := new(int,oid); 
	b.insert(10, oid(0)); 
	b.insert(11, oid(31)); 
	b.insert(11, oid(32)); 
	b.insert(12, oid(62)); 

	bv_a := [encode](a);
	bv_a.print();

	bv_b := [encode](b);
	bv_b.print();

	bv_c := [and](bv_a, bv_b);
	bv_c.print();

	bv_d := [or](bv_a, bv_b);
	bv_d.print();

	c := [decode](bv_d);
	c.print();
}

@{
@* Implementation
@c
#include "monetdb4_config.h"
#include "bitvector.proto.h"

#define numentries(a, b)	(((a) + (b) - 1) / (b))

bitvector_export int
bitvector_allocate(BAT **b_dst, wrd *nbits, bit *initial)
{
	lng v;
	size_t nentries, n;

	nentries = numentries(*nbits, sizeof(lng) * 8);
	*b_dst = BATnew(TYPE_void, TYPE_lng, nentries);

	v = (*initial) ? -1 : 0;
	for (n = 0; n != nentries; n++)
		BUNappend(*b_dst, (ptr) &v, FALSE);
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_set(BAT *b_src, wrd *bnum)
{
	size_t entry;
	lng *v;

	entry = *bnum / (sizeof(lng) * 8);
	if (BATcount(b_src) < entry + 1) {
		GDKerror("bitvector_set: BAT too small " SZFMT " < " SZFMT "\n", BATcount(b_src), entry + 1);
		return GDK_FAIL;
	}

	v = (lng *) BUNtail(b_src, BUNfirst(b_src) + entry * BUNsize(b_src));
	*v |= (lng) 1 << (*bnum % (sizeof(lng) * 8));
	b_src->batDirty = TRUE;
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_isset(bit *rv, BAT *b_src, wrd *bnum)
{
	size_t entry;
	lng v;

	entry = *bnum / (sizeof(lng) * 8);
	if (BATcount(b_src) < entry + 1) {
		GDKerror("bitvector_isset: BAT too small " SZFMT " < " SZFMT "\n", BATcount(b_src), entry + 1);
		return GDK_FAIL;
	}

	v = *(lng *) BUNtail(b_src, BUNfirst(b_src) + entry * BUNsize(b_src));
	*rv = (bit) (v & ((lng) 1 << (*bnum % (sizeof(lng) * 8))));
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_clr(BAT *b_src, wrd *bnum)
{
	size_t entry;
	lng *v;

	entry = *bnum / (sizeof(lng) * 8);
	if (BATcount(b_src) < entry + 1) {
		GDKerror("bitvector_clr: BAT too small " SZFMT " < " SZFMT "\n", BATcount(b_src), entry + 1);
		return GDK_FAIL;
	}

	v = (lng *) BUNtail(b_src, BUNfirst(b_src) + entry * BUNsize(b_src));
	*v &= ~((lng) 1 << (*bnum % (sizeof(lng) * 8)));
	b_src->batDirty = TRUE;
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_isclr(bit *rv, BAT *b_src, wrd *bnum)
{
	size_t entry;
	lng v;

	entry = *bnum / (sizeof(lng) * 8);
	if (BATcount(b_src) < entry + 1) {
		GDKerror("bitvector_isclr: BAT too small " SZFMT " < " SZFMT "\n", BATcount(b_src), entry + 1);
		return GDK_FAIL;
	}

	v = *(lng *) BUNtail(b_src, BUNfirst(b_src) + entry * BUNsize(b_src));
	*rv = (v & ((lng) 1 << (*bnum % (sizeof(lng) * 8)))) ? 0 : 1;
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_encode(BAT **b_dst, BAT *b_src)
{
	lng bf;
	oid nbits, lastentry;
	int xx;
	BUN p, q;

	if (b_src == NULL || b_src->ttype != TYPE_oid || BATorder(b_src) == NULL) {
		GDKerror("bitvector_encode: No OID table.\n");
		return GDK_FAIL;
	}
	nbits = * (oid *) BUNtail(b_src, BUNlast(b_src)) + 1;
	*b_dst = BATnew(TYPE_void, TYPE_lng, numentries(nbits, sizeof(lng) * 8));
	lastentry = 0;
	bf = 0;

	BATloopFast(b_src, p, q, xx) {
		oid *bnum, entry;

		bnum = (oid *) BUNtail(b_src, p);
		entry = *bnum / ((int) sizeof(lng) * 8);
		while (lastentry < entry) {
			lastentry++;
			BUNappend(*b_dst, (ptr) &bf, FALSE);
			bf = 0;
		}
		bf |= ((lng) 1 << (*bnum % (sizeof(lng) * 8)));
	}
	BUNappend(*b_dst, (ptr) &bf, FALSE);

	return GDK_SUCCEED;
}

bitvector_export int
bitvector_decode(BAT **b_dst, BAT *b_src)
{
	oid soid;
	BUN p, q;
	int xx, n;

	if (b_src->htype != TYPE_void || b_src->ttype != TYPE_lng) {
		GDKerror("bitvector_decode: None void/lng table.\n");
		return GDK_FAIL;
	}

	*b_dst = BATnew(TYPE_void, TYPE_oid, BATcount(b_src) * sizeof(lng) * 8);
	BATseqbase(*b_dst, (oid) 0);
	BATkey(BATmirror(*b_dst), TRUE);
	soid = 0;
	BATloopFast(b_src, p, q, xx) {
		lng bf;

		bf = *(lng *) BUNtail(b_src, p);
		if (bf)
			for (n = 0; n < (int) sizeof(lng) * 8; n++)
				if (bf & ((lng) 1 << n)) {
					oid _soid = soid + n;

					BUNappend(*b_dst, (ptr) &_soid, FALSE);
				}
		soid += sizeof(lng) * 8;
	}
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_print(BAT *b_src)
{
	BUN p, q;
	int xx;

	if (b_src->htype != TYPE_void || b_src->ttype != TYPE_lng) {
		GDKerror("bitvector_decode: None void/lng table.\n");
		return GDK_FAIL;
	}

	BATloopFast(b_src, p, q, xx) {
		lng v = *(lng *) BUNtail(b_src, p);

		printf("x%08x%08x\n", (unsigned int) (v >> 32), (unsigned int) v);
	}
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_and(BAT **b_dst, BAT *b_src1, BAT *b_src2)
{
	BUN p1, q1, p2, q2;

	if (b_src1->htype != TYPE_void || b_src1->ttype != TYPE_lng || b_src2->htype != TYPE_void || b_src2->ttype != TYPE_lng) {
		GDKerror("bitvector_and: No void/lng table(s).\n");
		return GDK_FAIL;
	}

	assert(BUNsize(b_src1) == sizeof(lng));

	*b_dst = BATnew(TYPE_void, TYPE_lng, BATcount(b_src1));

	p1 = BUNfirst(b_src1);
	q1 = BUNlast(b_src1);
	p2 = BUNfirst(b_src2);
	q2 = BUNlast(b_src2);
	for (; p1 < q1 && p2 < q2; p1 += sizeof(lng), p2 += sizeof(lng)) {
		lng v1, v2;

		v1 = * (lng *) BUNtail(b_src1, p1);
		v2 = * (lng *) BUNtail(b_src2, p2);
		v1 &= v2;
		BUNappend(*b_dst, (ptr) &v1, FALSE);
	}

	/* No need to copy the tail */
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_or(BAT **b_dst, BAT *b_src1, BAT *b_src2)
{
	BUN p1, q1, p2, q2;

	if (b_src1->htype != TYPE_void || b_src1->ttype != TYPE_lng || b_src2->htype != TYPE_void || b_src2->ttype != TYPE_lng) {
		GDKerror("bitvector_and: No void/lng table(s).\n");
		return GDK_FAIL;
	}

	assert(BUNsize(b_src1) == sizeof(lng));

	*b_dst = BATnew(TYPE_void, TYPE_lng, BATcount(b_src1));

	p1 = BUNfirst(b_src1);
	q1 = BUNlast(b_src1);
	p2 = BUNfirst(b_src2);
	q2 = BUNlast(b_src2);
	for (; p1 < q1 && p2 < q2; p1 += sizeof(lng), p2 += sizeof(lng)) {
		lng v1, v2;

		v1 = * (lng *) BUNtail(b_src1, p1);
		v2 = * (lng *) BUNtail(b_src2, p2);
		v1 |= v2;
		BUNappend(*b_dst, (ptr) &v1, FALSE);
	}

	/* Copy the tail, when required */
	if (p1 < q1 || p2 < q2) {
		BUN p = NULL, q = NULL;
		BAT *b_src = NULL;

		if (p1 < q1) {
			assert(p2 == q2);
			p = p1;
			q = q1;
			b_src = b_src1;
		} else if (p2 < q2) {
			assert(p1 == q1);
			p = p2;
			q = q2;
			b_src = b_src2;
		}

		for (; p < q; p += sizeof(lng))
			BUNappend(*b_dst, BUNtail(b_src, p), FALSE);
	}

	return GDK_SUCCEED;
}

bitvector_export int
bitvector_count(wrd *count, BAT *b_src)
{
	BUN p, q;
	int xx;

	*count = 0;
	if (b_src->htype != TYPE_void || b_src->ttype != TYPE_lng) {
		GDKerror("bitvector_count: None void/lng table.\n");
		return GDK_FAIL;
	}

	BATloopFast(b_src, p, q, xx) {
		int n;
		lng v = *(lng *) BUNtail(b_src, p);

		if (v)
			for (n = 0; n != sizeof(lng) * 8; n++)
				if (v && (1 << n))
					(*count)++;
	}
	return GDK_SUCCEED;
}

@}
