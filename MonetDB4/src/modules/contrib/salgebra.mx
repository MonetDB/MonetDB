@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f salgebra
@a Arjen P. de Vries and Niels Nes
@v 1.0
@t Some (experimental) sorted-order algebraic operators
@* Introduction
@T

Warning: experimental code!

This module addresses physical database issues for the following query
pattern -- common for IR and multimedia query processing:
\begin{enumerate}
  \item semijoin between metadata and query;
  \item a series of joins to collect the associated statistics;
  \item a grouped aggregate to compute per-object rank.
\end{enumerate}

\begin{verbatim}
Since the aggregate is grouped per document, it makes sense to keep the data
in the statistics tables in object order. This can be done easily by chosing specific
order-preserving implementations of algebraic operators. 

Knowing the order can also be exploited to speed up specific operations like
select and (semi-)join; this goal is supported with specialized
hash-structures called the \em{cluster-hash}. The 

NOTE: maybe the clusterhash is sometimes also handy even when you do not
require order propagation. This may be the case for workbenches with a small
number of relatively large groups, because of improved cache usage by
localization of data-access. In the algebraic operations, this saves on the
merging phase.

NOTE: alignment.

NOTE: we want to use the clusterhash without necessarily loading the original
BAT, so, we implement the new atom type.

NOTE: the current code breaks if the hash code changes -> ugly
      share code with kunique?

unfinished documentation:
De clusterhash is speciaal bedoeld voor mappings van gegroepeerde
n-relationele schemas op binary relational schemas.
Ofwel, we hebben een schema { ag , { < a1, a2, ..., an > } }.
Een eigenschap van de query-load is dat er veel aggregaten worden uitgevoerd
op de inner sets.

Dan mappen we het schema op N+1 synchrone void bats:
 ag, a1, .., an

De clusterhash vervult zijn rol als we selecteren op 1 (wellicht m<n?) bats
uit deze mapping.

Om de clusterhash te gebruiken in een join tussen am en b, doe je in feite een
  join( am, b ).project( nil )

[ de mark is niet strickt noodzakelijk geeft alleen sneller resources vrij. 
De properties van join(am,b) zijn belangrijk
        am.head.unique -> res.head.unique
        am.clustersorted -> res.head.sorted
ie. de head van het result is een pos list, deze info moet verder
gebruit worden in de semijoins. ]

Het resultaat hiervan is een [oid,void] bat, en als je daarmee verder joint
op de subset van < a1, .., an > die meedoen in het aggregaat, dan gaat dat
extra efficient; want het worden allemaal void-joins.

Vraagje: 
wat vind je van het definieren van operator 
  ujoin( am, b ) <=> join( am, b ).project(nil)
analoog aan uselect lijkt me dat de meest logische naam toch?

misschien moet die ujoin gekozen worden op basis van
een join.project(nil) sequentie, of misschien zelfs een join.semijoin sequentie.

Je krijgt dan mil-pattern:
  pos := am.ujoin( b );

  ag' := semijoin( ag, pos ); /* Check: kiest die nu al de void-join? */
  a1' := semijoin( a1, pos );
  a2' := semijoin( a2, pos );
  ...

  res := {aggregate}( ag', a1', a2', ... );

Aandachtspunten:
  * bij selectie op m<n attributen, wat is dan het beste query plan?

  -> we kunnen m ujoins doen, en die resultaten semijoinen

     Dit is sneller (semijoins zijn merges, als die in een boom
     query plan verwerkt worden worden minder elementen gepasseerd, dan
     sequenceel door alle resultaat bats heen te scannen)

  -> we kunnen eerst een ujoin doen, dan semijoinen, dan de volgende ujoin,
     dan weer semijoinen, etc.

     Deze weg gebruikt minder resources 

  * moet de gewone join op een clusterhashed bat een clusterhashed bat
  opleveren, of het "gewone" join-resultaat?

  * Het sorteren:

  de [u]join( am, b ) een resultaat met head.sorted moet
  opleveren; wat klopt als je in de join inderdaad een mergesort doet.
  wat als je dat nu eens niet altijd meteen doet?

  bij veel kleine clusters, zou dan een (1) final sort aan het einde niet sneller
  zijn? 
    [Q: heeft de ordeningpropagatie dan nog wel zin???]

    1. neem de avg. clustergrootte, door over de [s,e]-tabel te sommeren:
       sum(e_bi-s_bi)/b.count
    2. aan de hand van de verhouding beslissen of je een sequentie aan
       mergesorts of een enkele quicksort neemt

  [ evt. zou je ook nog kunnen splitten in twee partitiejoins; dus split b op in
  twee delen, nl. een met grote en een met kleine clusters, doe de join op de
  kleine clusters en een quicksort, en iterate verder over de grote clusters en
  doe mergesorts. Zou dat een goed idee zijn, of teveel overhead veroorzaken? ]

  [Niels:] De beslising moet makelijk zijn, ie. weinig overhead  hebben.
  De keuze merge of quicksort hangt af van de size van je bat b
  en de avg. cluster size. Kleine b -> zeker merge. Grote b zeker niet.
  Kleine clusters -> quick, grote geeft merge.

  De hybride oplossing klinkt mooi, maar is waarschijnlijk te duur
  en geeft aanleiding de cluster bat te splitsen, 
  in bat met kleine en een met grote clusters.

Meer notities:

  We kennen de noties
    data stores -> bats, columns?
    maps        -> hash, cluster, enum, radix
    ordering    -> random, sorted, dense

  Deze lopen nu allemaal door elkaar; de hash-dict is in feite een functionele implementatie 
  van een enum, een alternatieve functie voor de radix (=~ signature file?).
  Wellicht is het een idee om de collision list van de hash te zien als een view op de data, 
  en wel een waarbij er een directe relatie ligt tussen de head en de tail, waarbij geldt dat 
    tl( hd[tv1] ) ) == tv1 || 0; 
  wat weer een "vrij willekeurige" implementatie is van een linked list in een bat;
  waarbij de order dus weer een belangrijke rol speelt.
  Wordt het soms tijd voor een "ordered_bat" of "ordered_column" primitieve???

\end{verbatim}

@+ Running example
@T

In the following, we will assume that we work with three [void,oid] BATs 
{\tt dj}, {\tt ti}, {\tt tfij} -- like the {\tt CONTREP} structure described
in Arjen's thesis -- in which the {\em ordered} {\tt dj} denote the
objects, the {\tt ti} denote features occurring in those objects, and {\tt tfij} the
associated frequency statistics.

A cluster-hash on {\tt ti} allows efficient processing of (semi-)joins with
query BATs.

\begin{verbatim}
TODO: 
  * loading module in both server and client does not work
      it can hang in BBPtrim if you access 
        ch_cache.info().find("batCacheid").print;
      in client and server and load module in both
  * use of local_itoa implementation causes memory leak in info
\end{verbatim}
  
@+ Building the cluster-hash
@T

We first need to obtain `a' clustering of the data; potential sources are a
normal hash-table, an enum, a radix-ed BAT, as well as a 

The hash function used for this clustering should preferably be perfect --
which is usually the case for oids and integers.
To overcome problems with non-numeric types, we may first build an enum, and
build the cluster hash from the enum.

@* Module definition
@m
.MODULE salgebra;

.USE algebra;

.FIXED_ATOM clusterhash;
  .TOSTR   = clusterhashToStr;
  .FROMSTR = clusterhashFromStr;
  .NULL    = clusterhashNull;
  .FIX	   = clusterhashFix;
  .UNFIX   = clusterhashUnfix;
.END;

.COMMAND clusterhash( BAT[any,any] b ):clusterhash = salgebra_CMDclusterhash;
  "Build a new or get a previously built clusterhash for the input bat."
.COMMAND destroy( str chname ):void = salgebra_CMDdestroy;
  "Destroy the clusterhash with name chname (if possible)."

.COMMAND uselect( clusterhash ch, any v ): BAT[oid,void] = salgebra_CMDuselect;
  "Return select(ch, v).project(nil) with propagated clustering."
.COMMAND ujoin( clusterhash ch, BAT[any,any] b ): BAT[oid,void] = salgebra_CMDujoin;
  "Return join(ch, b).project(nil) with propagated clustering."
.COMMAND usortedjoin( clusterhash ch, BAT[any,any] b ): BAT[oid,void] = 
  salgebra_CMDusortedjoin;
  "Return join(ch, b).project(nil).sort with propagated clustering."

.COMMAND CHbat( clusterhash ch ): BAT[void,any] = salgebra_CMDgetBAT;
  "Provides access to the original bat."
.COMMAND info( clusterhash ch ): BAT[str,str] = salgebra_CMDinfo;
  "Return some info about the chash."
.COMMAND rename( clusterhash ch, str name ): void = salgebra_CMDrename;
  "Try to name ch; fail upon error."

.PRELUDE = salgebra_prelude;
.EPILOGUE = salgebra_epilogue;

.END salgebra;

@mil
  PROC CHdir() :void {
    print( bat("ch_namecache"), bat("ch_refcnt"), bat("ch_cache") );
  }
  ADDHELP("CHdir", "arjen", "Jul 18 2000",
	  "List the clusterhash dictionary.", mod());

  PROC select( clusterhash ch, any::1 v ): BAT[oid,any::1] {
    RETURN ch.uselect( v ).project(v);
  }
  ADDHELP("select", "arjen", "Jun 16 2000",
	  "Select using a clusterhash uselect plus a cast.", mod());

@{
@* Implementation Code
@h
#ifndef __SALGEBRA_H__
#define __SALGEBRA_H__
#include "gdk.h"

@+ Type definition
@T

Explain fields.
@h

typedef struct {
	bat b;			/* the batId of the original bat b
				   (which may/will be trimmed from memory) */
	char *bname;		/* a copy of b's name */
	Hash *bhash;		/* a copy of b's hash structure
				   (necessary to access HASHprobe) */
	int bttype;		/* the type of the tail values */
	Heap *dict;		/* the clusterhash dictionary */
	int isPerfect;		/* boolean indicating if the hash-function is perfect */
	bat hv, tv;		/* the head values; the tail values (iff !isPerfect) */
} clusterhash;

#include "algebra.h"
#include "salgebra.proto.h"

#endif /* __SALGEBRA_H__ */

@c
#include "monetdb4_config.h"
#include "salgebra.h"

@* Clusterhash implementation

to be explained

@c

@+ Utility functions
@T

Not extremely interesting utility stuff.
We maintain a cache of known clusterhashes, protected by a lock,
and implemented as a simple BAT[int,clusterhash\_t], with a lookup
table BAT[str,int].

Note that we really need two locks, because when we insert the clusterhash,
the atomFix is called and we would end up with a deadlock.
@c
/* unsafe implementation:
static INLINE char* local_itoa(int i){
  static char buf[32];
  sprintf(buf,"%d",i);
  return buf;
}
*/

/* safe implementation with potential memory leak */
static INLINE char *
local_itoa(int i)
{
	char *buf = GDKmalloc(33);

	sprintf(buf, "%d", i);
	return buf;
}


@= SWAP
static INLINE void 
SWAP@1ptr(@1 **b1, @1 **b2) {
  @1 *h = *b1;
  *b1 = *b2;
  *b2 = h;
}
@c
@:SWAP(oid)@
@:SWAP(BAT)@

MT_Lock salgebra_chashLock[BBP_BATMASK + 1];
MT_Lock salgebra_cacheLock;
MT_Lock salgebra_refcntLock;

BAT *salgebra_cache;
BAT *salgebra_namecache;
BAT *salgebra_refcnt;

@+ MEL required functions
@T
\begin{itemize}
  \item size() and align()
  \item ToStr
  \item FromStr
  \item null
\end{itemize}
@c

int
clusterhash_size(void)
{
	return sizeof(clusterhash);
}

int
clusterhash_align(void)
{
	return sizeof(ptr);
}

clusterhash clusterhash_nil = { 0, NULL, NULL, 0, NULL, 0, 0, 0 };

#define clusterhashNil(CH)   ((clusterhash*) memcpy(CH,&clusterhash_nil,sizeof(clusterhash)))
#define clusterhashIsNil(CH) ( (!CH) || (!memcmp(CH,&clusterhash_nil,sizeof(clusterhash))) )

/*
   NOTE: return value of atomFix should be void, as it is not used 
*/
static int salgebra_getRefCnt(clusterhash *ch);
static int salgebra_incRefCnt(clusterhash *ch);
static int salgebra_decRefCnt(clusterhash *ch);

int
clusterhashFix(clusterhash *ch)
{
	int refCnt = 0;

	if (clusterhashIsNil(ch))
		return 0;
	refCnt = salgebra_incRefCnt(ch);
	(void) refCnt;		/* keep compiler happy */
#ifdef DEBUG
	printf("Fix ch for batId %d = %d\n", (int) ABS(ch->b), refCnt);
#endif
	return 0;
}

int
clusterhashUnfix(clusterhash *ch)
{
	int refCnt = 0;

	if (clusterhashIsNil(ch))
		return 0;
	refCnt = salgebra_decRefCnt(ch);
#ifdef DEBUG
	printf("Unfix ch for batId %d = %d\n", (int) ABS(ch->b), refCnt);
#endif
	if (!refCnt) {
#ifdef DEBUG
		printf("Unfix: refcount(%d) == 0\n", (int) ch->b);
#endif
		GDKfree(ch->bname);
		GDKfree(ch->bhash);
		HEAPfree(ch->dict);
		GDKfree(ch->dict);
	}
	return 0;
}

clusterhash *
clusterhashNull(void)
{
	clusterhash *ch_nil = GDKmalloc(clusterhash_size());

	return clusterhashNil(ch_nil);
}

static str
clusterhashName(int batId)
{
	BUN bun;
	str result;

	/* find ch in dictionary */
	MT_set_lock(salgebra_cacheLock, "clusterhashName");
	if (!(bun = BUNfnd(salgebra_namecache, &batId))) {
		MT_unset_lock(salgebra_cacheLock, "clusterhashName");
		GDKwarning("Inconsistency in clusterhash repository...\n");
		return NULL;
	}
	result = (str) BUNtail(salgebra_namecache, bun);
	MT_unset_lock(salgebra_cacheLock, "clusterhashName");
	return result;
}

int
clusterhashToStr(char **dst, int *len, clusterhash *ch)
{
	int nchar = 4, isnil = clusterhashIsNil(ch);
	str name = NULL;

	if (!isnil) {
		name = clusterhashName(ABS(ch->b));
		if (!(isnil = (name == NULL)))
			nchar = strLen(name);
	}
	if (*len < nchar) {
		if (*dst)
			GDKfree(*dst);
		*dst = GDKmalloc(*len = nchar);
	}
	if (isnil) {
		strcpy(*dst, "nil");
		return 3;
	}
	strncpy(*dst, name, *len);
	return (int) strlen(*dst);
}

static int
clusterhashByName(clusterhash *res, char *chname)
{
	BUN bun;
	int batId;
	clusterhash *ch = NULL;
	BAT *ncrev = BATmirror(salgebra_namecache);

	/* find ch in dictionary */
	MT_set_lock(salgebra_cacheLock, "clusterhashByName");
	if (!(bun = BUNfnd(ncrev, chname))) {
		MT_unset_lock(salgebra_cacheLock, "clusterhashByName");
		GDKwarning("Clusterhash does not exist.\n");
		(void) clusterhashNil(res);
		return GDK_FAIL;
	}
	batId = *(int *) BUNtail(ncrev, bun);
	if (!(ch = (clusterhash *) BUNtail(salgebra_cache, BUNfnd(salgebra_cache, &batId)))) {
		MT_unset_lock(salgebra_cacheLock, "clusterhashByName");
		GDKerror("clusterhashByName: Inconsistency in clusterhash repository...\n");
		(void) clusterhashNil(res);
		return GDK_FAIL;
	}
	/* copy data into output buf */
	MT_set_lock(salgebra_chashLock[ABS(ch->b) & BBP_BATMASK], "clusterhashByName");
	memcpy(res, ch, clusterhash_size());
	MT_unset_lock(salgebra_chashLock[ABS(ch->b) & BBP_BATMASK], "clusterhashByName");
	MT_unset_lock(salgebra_cacheLock, "clusterhashByName");
	return GDK_SUCCEED;
}

/* NOTE: implement on-demand clustering instead of an error! */
int
clusterhashFromStr(str src, int *len, clusterhash **dst)
{
	int l = (int) strlen(src); /* 64bit: assume string is not too long */

	if (*len < clusterhash_size()) {
		if (*dst)
			GDKfree(*dst);
		*dst = GDKmalloc(*len = clusterhash_size());
	}
	clusterhashByName(*dst, src);
	return l;
}

@+ Dictionary
@T

The dictionary stores for each cluster the start and end bucket in the 
clusterhash itself.

DICTprobe: determine bucket in CH for value V
DICTentry: entry in dictionary for bucket B

@c

typedef struct {
	int s, e;
} dict_entry;

#define DICTprobe(CH,V) HASHprobe(CH->bhash, V)
#define DICTentry(CH,B) ((dict_entry*) CH->dict->base)[B]

static INLINE int
DICTclustersize(clusterhash *ch, ptr v)
{
	hash_t bucket = DICTprobe(ch, v);
	int s = DICTentry(ch, bucket).s;

	if (s == -1)
		return 0;
	else
		return DICTentry(ch, bucket).e - s + 1;
}

static INLINE void
DICTclear(dict_entry *d, size_t n)
{
	size_t i;

	for (i = 0; i < n; i++) {
		d[i].s = d[i].e = -1;
	}
}

@+ Hashtable
@T

...

@c
/* return a newly allocated and assigned name */
static str
salgebra_CHname(char *ch_basename, int batId)
{
	size_t l = strlen(ch_basename);
	char *id = local_itoa(ABS(batId));
	int l2 = strLen(id);
	char *n = (char *) GDKmalloc(l + l2 + 1);

	memcpy(n, ch_basename, l);
	*(char *) (n + l++) = '_';
	memcpy(n+l, id, l2);
	GDKfree(id);

	return n;
}

/* fill the proper structures */
static char *
salgebra_CHadmin(clusterhash *ch)
{
	char *hvname = NULL, *result = NULL;
	int l = 0;

	/* set the names of hv (tv), ch, and cache some info */
	ch->bname = GDKstrdup(BBPname(ch->b));
	l = strLen(ch->bname);
	hvname = (char *) GDKmalloc(l + 6);
	strcpy(hvname, "ch_");
	memcpy((char *) (hvname + 3), ch->bname, l);
	strcpy((char *) (hvname + l + 2), "_hv");
	BBPrename(ch->hv, hvname);
	if (!(ch->isPerfect)) {
		*(char *) (hvname + l + 3) = 't';
		BBPrename(ch->tv, hvname);
	}
	*(char *) (hvname + l + 2) = '\0';
	result = salgebra_CHname(hvname, (int) ch->b);
	GDKfree(hvname);
	return result;
}

/* should we indeed protect the insert with a lock? */
static void
salgebra_cacheIt(clusterhash *ch)
{
	int refCnt = 0;
	char *name = NULL;
	int bid = ABS(ch->b);

	name = salgebra_CHadmin(ch);
	MT_set_lock(salgebra_cacheLock, "cacheIt");
	MT_set_lock(salgebra_refcntLock, "cacheIt");
	BUNins(salgebra_refcnt, &bid, &refCnt, FALSE);
	MT_unset_lock(salgebra_refcntLock, "cacheIt");
	BUNins(salgebra_cache, &bid, ch, FALSE);
	BUNins(salgebra_namecache, &bid, name, FALSE);
	MT_unset_lock(salgebra_cacheLock, "cacheIt");
}

static void
salgebra_uncacheIt(clusterhash *ch)
{
	int bid = ABS(ch->b);

	MT_set_lock(salgebra_cacheLock, "uncacheIt");
	BUNdelHead(salgebra_namecache, &bid, FALSE);
	BUNdelHead(salgebra_cache, &bid, FALSE);
	MT_set_lock(salgebra_refcntLock, "uncacheIt");
	BUNdelHead(salgebra_refcnt, &bid, FALSE);
	MT_unset_lock(salgebra_refcntLock, "uncacheIt");
	MT_unset_lock(salgebra_cacheLock, "uncacheIt");
}

static int
salgebra_isCached(int batId)
{
	int bid = ABS(batId);
	BUN chbun = BUNfnd(salgebra_cache, &bid);

	return chbun ? TRUE : FALSE;
}

/* pre: !isNil( ch ) */
@= deltaRefCnt
int
salgebra_@1RefCnt( clusterhash *ch ) {
  int refCnt = 0;
  int batId = ABS( ch->b );
  BUN chbun = NULL;
  MT_set_lock( salgebra_refcntLock, "@1RefCnt" );
  chbun = BUNfnd( salgebra_refcnt, &batId );
  ERRORcheck( !chbun, "Inconsistency in clusterhash repository...\n" );
  refCnt = @2*( (int *) BUNtail( salgebra_refcnt, chbun ) );
  MT_unset_lock( salgebra_refcntLock, "@1RefCnt" );
  return refCnt;
}
@
@c
@:deltaRefCnt(get,)@
@:deltaRefCnt(inc,++)@
@:deltaRefCnt(dec,--)@

@T
Build a clusterhash for bat b, deriving the clustering from a hash 
defined for b.
@c

static int
salgebra_CHbuild(clusterhash *ch, BAT *b)
{
	Hash *h = NULL;
	BAT *bt = NULL, *hv = NULL, *tv = NULL;
	dict_entry *dict = NULL;
	int cstart = 0, cend = 0;
	hash_t hb = 0, chlen = 0, cur = 0, cluster = 0;
	size_t xx = 0;
	int isPerfect = 1, bid = BBPcacheid(b);
	oid *hvs = NULL;

	/* CHECK: existing clusterhash on this bat? */
	MT_set_lock(salgebra_chashLock[ABS(bid) & BBP_BATMASK], "CHbuild");
	if (salgebra_isCached(ch->b = bid)) {
		GDKerror("salgebra_CHbuild: Clusterhash already exists.\n");
		(void) clusterhashNil(ch);
		MT_unset_lock(salgebra_chashLock[ABS(bid) & BBP_BATMASK], "CHbuild");
		return GDK_FAIL;
	}
	ch->bttype = BATttype(b);
	/* build a hash if it does not yet exist */
	bt = BATmirror(b);
	if (!(bt->hhash))
		BAThash(bt, 0);
	h = bt->hhash;
	ch->bhash = (Hash *) GDKmalloc(sizeof(Hash));
	memcpy(ch->bhash, h, sizeof(Hash));

	/* allocate space for the chash */
	chlen = h->mask + 1;
	ch->dict = (Heap *) GDKmalloc(sizeof(Heap));
	ch->dict->filename = NULL;
	if (HEAPalloc(ch->dict, chlen, sizeof(dict_entry)) < 0) {
		MT_unset_lock(salgebra_chashLock[ABS(bid) & BBP_BATMASK], "CHbuild");
		GDKfree(ch->bhash);
		GDKfree(ch->dict);
		ch->bhash = NULL;
		ch->dict = NULL;
		return GDK_FAIL;
	}
	dict = (dict_entry *) ch->dict->base;
	DICTclear(dict, chlen);

	/* 
	   allocate a bat for the ordered head values, and another bat for the 
	   tail values; the tail value bat is disregarded if the hash turns out 
	   perfect
	 */

	/* NOTE: htype == void; 
	   the idea should however extend to other ordered types as well (?) */
	hv = BATnew(TYPE_oid, TYPE_void, xx = BATcount(b));
	hv->batBuns->free = xx * sizeof(oid);
	BATsetcount(hv, xx);
	hvs = (oid *) BUNfirst(hv);

	/* Read the unique ch's from the hash (i.e., do a k-cluster-unique) */
	for (cur = 0; cur < chlen; cur++) {
		int ncur = 0, cc = 0;
		ptr cur_tl = NULL;

		/* Any values for this cluster? */
		cluster = h->hash[cur];
		if (cluster == HASH_MAX)
			continue;

		/* determine size of cluster and set pointers */
		for (hb = cluster; hb != HASH_MAX; hb = h->link[hb])
			ncur++;
		cc = 0;
		cstart = cend;
		cend += ncur;

		/* extend dictionary */
		dict[cur].s = cstart;
		dict[cur].e = cend - 1;

		/* printf( "dict entry[%d]=<%d,%d>\n", cur, cstart, cend - 1 ); */
		for (hb = cluster; hb != HASH_MAX; hb = h->link[hb]) {
			/* and create the output bat */
			ptr tl = NULL;
			oid hoid = (oid) hb;

			/* printf( "ch[%d]=<%d@0,%d>\n", cend - cc - 1, hoid, cur ); */
			hvs[cend - cc - 1] = hoid;
			if (!isPerfect) {
				cc++;
				continue;
			}
			/* check if still perfect */
			tl = BUNtail(b, BUNptr(b, hb));	/* will be obsolete if isPerfect */
			if (cc++ == 0) {
				/* cache tail value of first bun */
				cur_tl = tl;
			} else {
				/* compare tail values */
				isPerfect = (!ATOMcmp(b->ttype, cur_tl, tl));
				if (!isPerfect)
					GDKwarning("Imperfect hash detected!\n");
			}
		}
	}
	/* Set properties;
	   some day, this should be hv->hsorted = GDK_CLUSTERSORTED */
	ch->hv = BBPcacheid(hv);

	if (!(ch->isPerfect = isPerfect)) {
		/* set tv := join( hv.reverse, b ).reverse.seqbase(0@0); */
		tv = BATjoin(BATmirror(hv), b, oid_nil);
		tv = BATmirror(tv);
		ch->tv = BBPcacheid(tv);
	}

	/* maintain some admin. info in the bbp etc. */
	salgebra_cacheIt(ch);
	BBPcold(ch->b);

	MT_unset_lock(salgebra_chashLock[ABS(bid) & BBP_BATMASK], "CHbuild");
	return GDK_SUCCEED;
}

/* 
   salgebra_mergesort_matches
   --------------------------
   pre:  buffer res is already allocated and has capacity for at least (na+nb) oids
   post: res[1..na+nb] is the (merge-)sorted union of a[1..na] and b[1..nb]
*/

static void
salgebra_mergesort_matches(oid *res, oid *a, int na, oid *b, int nb)
{
	oid *ae = a + na, *be = b + nb;

	while ((a < ae) && (b < be))
		if (*a < *b) {
			*res++ = *a++;
		} else if (*a > *b) {
			*res++ = *b++;
		} else {
			GDKerror("salgebra_mergesort_matches: clusterhash head values are not unique");
		}
	while (a < ae)
		*res++ = *a++;
	while (b < be)
		*res++ = *b++;
}

/* 
   salgebra_collect_matches( result, clusterhash, value )
   ------------------------------------------------------
   Find matching buns using clusterhash ch.
   Returns the number of matching values

   TODO: can we easily get the <hvs = BUNfirst> statement out of the loop?
*/

static int
salgebra_collect_matches_imperfect(oid *res, clusterhash *ch, hash_t bucket, ptr v)
{
	BAT *hv = BBPdescriptor(ch->hv), *tv = BBPdescriptor(ch->tv);
	oid *hvs = (oid *) BUNfirst(hv);
	int i = 0, j = DICTentry(ch, bucket).s, n = DICTentry(ch, bucket).e - j + 1, nres = 0;

#ifdef DEBUG
	printf("cm_imperfect: ch[" SZFMT "]=<%d,%d>\n", (size_t) bucket, DICTentry(ch, bucket).s, DICTentry(ch, bucket).e);
#endif
	if (j == -1)
		return 0;	/* no matches */
	for (i = 0; i < n; i++) {
		/* Inner loop over q; check tails since the hash is imperfect */
		if (!(ATOMcmp(ch->bttype, BUNhead(tv, BUNptr(tv, j + 1)), v))) {
			*res++ = hvs[j];
			nres++;
		}
		j++;
	}
	return nres;
}

static int
salgebra_collect_matches_perfect(oid *res, clusterhash *ch, hash_t bucket)
{
	BAT *hv = BBPdescriptor(ch->hv);
	oid *hvs = (oid *) BUNfirst(hv);
	int i = 0, j = DICTentry(ch, bucket).s, n = DICTentry(ch, bucket).e - j + 1;

#ifdef DEBUG
	printf("cm_perfect: ch[" SZFMT "]=<%d,%d>\n", (size_t) bucket, DICTentry(ch, bucket).s, DICTentry(ch, bucket).e);
#endif
	if (j == -1)
		return 0;	/* no matches */
	for (i = 0; i < n; i++)
		*res++ = hvs[j++];
	return n;
}

static int
salgebra_collect_matches(oid *res, clusterhash *ch, ptr v)
{
	int nres = 0;
	hash_t bucket = DICTprobe(ch, v);

	if (ch->isPerfect)
		nres = salgebra_collect_matches_perfect(res, ch, bucket);
	else
		nres = salgebra_collect_matches_imperfect(res, ch, bucket, v);
	return nres;
}

/*
   .COMMAND entry points
   =====================
*/

@= CHECKnil
if ( clusterhashIsNil( ch ) ) {
  GDK@1( "clusterhash is nil." );
  return GDK_@2;
}
@c

int
salgebra_CMDclusterhash(clusterhash *res, BAT *b)
{
	int batId;
	clusterhash *ch;

	BATcheck(b, "CHbuild");
	ERRORcheck((b->htype != TYPE_void), "Argument head must be void.\n");
	batId = ABS(BBPcacheid(b));
	if (!salgebra_isCached(batId)) {
		/* build clusterhash */
		int ret;

#ifdef DEBUG
		GDKwarning("Building clusterhash\n");
#endif
		ret = salgebra_CHbuild(res, b);
		clusterhashFix(res);
		return ret;
	}
	/* retrieve ch from the dictionary */
	MT_set_lock(salgebra_cacheLock, "CMDclusterhash");
	ch = (clusterhash *) BUNtail(salgebra_cache, BUNfnd(salgebra_cache, &batId));
	memcpy(res, ch, clusterhash_size());
	MT_unset_lock(salgebra_cacheLock, "CMDclusterhash");
	clusterhashFix(res);
	return GDK_SUCCEED;
}

int
salgebra_CMDgetBAT(BAT **res, clusterhash *ch)
{
	@:CHECKnil(error,FAIL)@
	*res = BATdescriptor(ch->b);
	if (!(*res)) {
		GDKerror("CMDgetBAT: Bat %s is no longer valid.\n", ch->bname);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int
salgebra_CMDinfo(BAT **res, clusterhash *ch)
{
	BAT *bn;

	@:CHECKnil(error,FAIL)@

	if (!(bn = BATnew(TYPE_str, TYPE_str, 16)))
		return GDK_FAIL;

	BUNins(bn, "name", clusterhashName(ABS(ch->b)), FALSE);
	BUNins(bn, "bname", ch->bname, FALSE);
	BUNins(bn, "ttype", ATOMname(ch->bttype), FALSE);
	BUNins(bn, "batId", local_itoa(ch->b), FALSE);
	BUNins(bn, "perfect", local_itoa(ch->isPerfect), FALSE);
	BUNins(bn, "refCnt", local_itoa(salgebra_getRefCnt(ch)), FALSE);
	*res = bn;
	return GDK_SUCCEED;
}

int
salgebra_CMDrename(clusterhash *ch, str name)
{
	BAT *ncrev = NULL;
	int batId = ABS(ch->b);

	@:CHECKnil(error,FAIL)@

	MT_set_lock(salgebra_cacheLock, "rename");
	ncrev = BATmirror(salgebra_namecache);
	if (BUNfnd(ncrev, name)) {
		GDKerror("salgebra_CMDrename: A clusterhash with name %s already exists.\n", name);
		MT_unset_lock(salgebra_cacheLock, "rename");
		return GDK_FAIL;
	}
	BUNdelHead(salgebra_namecache, &batId, FALSE);
	BUNins(salgebra_namecache, &batId, name, FALSE);
	MT_unset_lock(salgebra_cacheLock, "rename");
	return GDK_SUCCEED;
}

int
salgebra_CMDuselect(BAT **res, clusterhash *ch, ptr v, int v_type)
{
	BAT *result = NULL;
	int nres = 0, nmaxres = 0;

	(void) v_type;

	@:CHECKnil(error,FAIL)@
	nmaxres = DICTclustersize(ch, v);
	result = BATnew(TYPE_oid, TYPE_void, nmaxres);
	result->batBuns->free = nmaxres * sizeof(oid);
	BATsetcount(result, nmaxres);
	nres = salgebra_collect_matches((oid *) BUNfirst(result), ch, v);
	result->batBuns->free -= (nmaxres - nres) * sizeof(oid);
	result->batCount -= (nmaxres - nres);
	*res = result;
	return GDK_SUCCEED;
}

int
salgebra_CMDujoin(BAT **res, clusterhash *ch, BAT *b)
{
	BUN p, q;
	BAT *result = NULL;
	oid *matches = NULL;
	int nres = 0, nmaxres = 0;

	/* basic type checks */
	@:CHECKnil(error,FAIL)@
	ERRORcheck((b->htype != ch->bttype), "ujoin: types do not match\n");

	/* determine result size if perfect hash */
	BATloop(b, p, q)
	    nmaxres += (DICTclustersize(ch, BUNhead(b, p)));

	/* create result BAT */
	result = BATnew(TYPE_oid, TYPE_void, nmaxres);
	result->hsorted = 0;
	result->batBuns->free = nmaxres * sizeof(oid);
	BATsetcount(result, nmaxres);

	/* construct result */
	matches = (oid *) BUNfirst(result);
	BATloop(b, p, q)
	    nres += salgebra_collect_matches(&matches[nres], ch, BUNhead(b, p));
	result->batBuns->free -= (nmaxres - nres) * sizeof(oid);
	result->batCount -= (nmaxres - nres);

	/* return the result */
	*res = result;
	return GDK_SUCCEED;
}

int
salgebra_CMDusortedjoin(BAT **res, clusterhash *ch, BAT *b)
{
	BUN p, q;
	BAT *result = NULL, *hbuf = NULL;
	oid *cur = NULL, *prev = NULL, *matches = NULL;
	int ncur = 0, nres = 0, nmaxres = 0;

	/* basic type checks */
	@:CHECKnil(error,FAIL)@
	ERRORcheck((b->htype != ch->bttype), "usortedjoin: types do not match\n");

	/* determine result size if perfect hash */
	BATloop(b, p, q)
	    nmaxres += (DICTclustersize(ch, BUNhead(b, p)));

	/* create result BAT, and a temporary buffer for mergesorting */
	result = BATnew(TYPE_oid, TYPE_void, nmaxres);
	result->batBuns->free = nmaxres * sizeof(oid);
	BATsetcount(result, nmaxres);

	hbuf = BATnew(TYPE_oid, TYPE_void, nmaxres);
	hbuf->batBuns->free = nmaxres * sizeof(oid);
	BATsetcount(hbuf, nmaxres);

	/* construct sorted result */
	prev = (oid *) BUNfirst(result);
	matches = (oid *) BUNfirst(hbuf);
	BATloop(b, p, q) {
		cur = &prev[nres];
		ncur = salgebra_collect_matches(cur, ch, BUNhead(b, p));
		salgebra_mergesort_matches(matches, cur, ncur, prev, nres);
		nres += ncur;
		SWAPoidptr(&prev, &matches);
		SWAPBATptr(&result, &hbuf);
	}
	BBPreclaim(hbuf);
	result->batBuns->free -= (nmaxres - nres) * sizeof(oid);
	result->batCount -= (nmaxres - nres);

	/* return the result */
	*res = result;
	return GDK_SUCCEED;
}

int
salgebra_CMDdestroy(str chname)
{
	int refcnt, bid;
	clusterhash *ch = GDKmalloc(clusterhash_size());

	if (!clusterhashByName(ch, chname))
		return GDK_FAIL;
	refcnt = salgebra_getRefCnt(ch);
	ERRORcheck(refcnt > 1, "Still references around; cannot destroy ch\n");
        bid = ABS(ch->b);
	MT_set_lock(salgebra_chashLock[bid & BBP_BATMASK], "CMDdestroy");
	salgebra_uncacheIt(ch);
	MT_unset_lock(salgebra_chashLock[bid & BBP_BATMASK], "CMDdestroy");
	return GDK_SUCCEED;
}

bat *
salgebra_prelude(void)
{
	static bat buf[2];
	int i = 0;

#ifdef DEBUG
	GDKwarning("salgebra prelude!\n");
#endif
	/* allocate locks */
	for (i = 0; i <= BBP_BATMASK; i++) {
		MT_init_lock(salgebra_chashLock[i], "salgebra_chashLock");
	}
	MT_init_lock(salgebra_cacheLock, "salgebra_cacheLock");
	MT_init_lock(salgebra_refcntLock, "salgebra_refcntLock");

	salgebra_cache = BATnew(TYPE_int, TYPE_clusterhash, 10);
	BBPrename(BBPcacheid(salgebra_cache), "ch_cache");

	salgebra_namecache = BATnew(TYPE_int, TYPE_str, 10);
	BBPrename(BBPcacheid(salgebra_namecache), "ch_namecache");

	salgebra_refcnt = BATnew(TYPE_int, TYPE_int, 10);
	BBPrename(BBPcacheid(salgebra_refcnt), "ch_refcnt");

	clusterhash_nil.bttype = int_nil;
	clusterhash_nil.isPerfect = int_nil;
	clusterhash_nil.b = *((bat *) ATOMnilptr(TYPE_bat));
	clusterhash_nil.hv = *((bat *) ATOMnilptr(TYPE_bat));
	clusterhash_nil.tv = *((bat *) ATOMnilptr(TYPE_bat));

	buf[0] = BBPcacheid(salgebra_cache);
	buf[1] = 0;
	return buf;
}

void
salgebra_epilogue(void)
{
	int i = 0;

#ifdef DEBUG
	GDKwarning("salgebra epilogue!\n");
#endif
	BBPunfix(BBPcacheid(salgebra_namecache));
	BBPunfix(BBPcacheid(salgebra_cache));
	BBPunfix(BBPcacheid(salgebra_refcnt));

	MT_destroy_lock(salgebra_cacheLock);
	MT_destroy_lock(salgebra_refcntLock);
	for (i = 0; i <= BBP_BATMASK; i++) {
		MT_destroy_lock(salgebra_chashLock[i]);
	}
}

@}

@+ Sample script
@mil

PROC test_salgebra() : void {   

	var ti := new( void, oid );
	ti.insert( nil, 0@0 );
	ti.insert( nil, 3@0 );
	ti.insert( nil, 0@0 );
	ti.insert( nil, 2@0 );
	ti.insert( nil, 3@0 );
	ti.seqbase( 0@0 );
	ti.rename( "ti" );

	var ch := clusterhash( ti );
	ch.rename( "ti" );
	printf( "Created clusterhash %s\n", str(ch) );

	var ch_2 := clusterhash( "ti" );
	ch_2.info().print();
	ch_2 := nil;

	var tj := new( oid, str );
	tj.rename( "tj" );
	tj.insert( 2@0, "two" );
	tj.insert( 3@0, "three" );

	#ch2 := clusterhash( tj.project(nil).reverse() );
	#ch2.rename("tjrev");

	ch.info().print();
	#ch2.info().print();

	CHdir();

	# use the clusterhash for a uselect or a ujoin
	uselect( ch, 0@0 ).print();
	uselect( ch, 1@0 ).print();
	uselect( ch, 2@0 ).print();
	uselect( ch, 3@0 ).print();

	ujoin( ch, tj ).print();
	usortedjoin( ch, tj ).print();

	CHdir();

	ch := nil;
}

