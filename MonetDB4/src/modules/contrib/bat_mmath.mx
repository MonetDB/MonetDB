@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@' 		Alex van Ballegooij  <Alex.van.Ballegooij@cwi.nl>

@f bat_mmath
@t Optimized Multiplexed Mathematical Functions on BATs
@a A.R. van Ballegooij
@v 1.0
@* Introduction

This module provides optimized code-expanded implementations of multiplxed
math functions ([exp],[log],[pow]) on void-headed, head-aligned BATs.
Only the dbl type is supported.

@* Module Definition 
@m
.MODULE bat_mmath;

@T
\begin{verbatim}
	signatures
	@1:	dbl			arithmetic type
	@2:	unary:  exp, log, sqrt 	mathematical function
	   	binary: pow            	mathematical function
\end{verbatim}

@= unarysignatures
.COMMAND "[@2]" (BAT[void,@1]) : BAT[void,@1] = bat_@1_@2;
	"optimized multiplexed @2 on [void,@1] BATs"

@= binarysignatures
.COMMAND "[@2]" (BAT[void,@1],BAT[void,@1]) : BAT[void,@1] = batbat_@1_@2;
	"optimized multiplexed @2 on head-aligned [void,@1] BATs"
.COMMAND "[@2]" (@1,BAT[void,@1]) : BAT[void,@1] = valbat_@1_@2;
	"optimized multiplexed left-scalar @2 on [void,@1] BAT"
.COMMAND "[@2]" (BAT[void,@1],@1) : BAT[void,@1] = batval_@1_@2;
	"optimized multiplexed right-scalar @2 on [void,@1] BAT"

@m
@:unarysignatures(dbl,exp)@
@:unarysignatures(dbl,log)@
@:unarysignatures(dbl,sqrt)@

@:binarysignatures(dbl,pow)@

.END bat_arith;

@* Implementation
@c
#include "monetdb4_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "bat_arith.proto.h"
#include "bat_mmath.proto.h"

#include <math.h>

@c
/*
	implementation
	@1:	dbl			arithmetic type
	@2:	unary:  exp, log, sqrt 	mathematical function
	   	binary: pow            	mathematical function
*/
@= unaryimplementations
int
bat_@1_@2(BAT **ret, BAT *b)
{
	REGISTER chr *bp, *bq;
	REGISTER @1 *bnp;
	REGISTER int bs = BUNsize(b);
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "bat_@1_@2(b=%s);\n",BATgetId(b));
 	ERRORcheck((b->htype!=TYPE_void),
 	           "bat_@1_@2: BAT b must be void-headed.\n");
	/* todo for commutative operators call batval (ie. for * and /) */

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	bnp = (@1*)BUNtloc(bn,BUNlast(bn));
	for (; bp < bq; bp+=bs) {
		REGISTER @1 bv = *(@1*)bp;
		if (bv != @1_nil) {
			bv = @2(bv);
		}
		*bnp = bv;
		bnp++;
	}
        bn->batBuns->free = (BUN)bnp - bn->batBuns->base;
        BATsetcount(bn, bn->batBuns->free/BUNsize(bn));
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}

@= binaryimplementations
int
batbat_@1_@2(BAT **ret, BAT *l, BAT *r)
{
	REGISTER @1 *bnp;
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "batbat_@1_@2(l=%s,r=%s);\n",BATgetId(l),BATgetId(r));
 	ERRORcheck((l->htype!=TYPE_void)||(r->htype!=TYPE_void)||(l->hseqbase!=r->hseqbase)||(BATcount(l)!=BATcount(r)),
 	           "batbat_@1_@2: BATs l & r must be void-headed and head-aligned.\n");

	bn = BATnew(TYPE_void, l->ttype, BATcount(l));
	BATseqbase(bn,l->hseqbase);
	bn->tsorted = 0;

	if ((BUNsize(l)==sizeof(@1))&&(BUNsize(r)==sizeof(@1))) {
		REGISTER @1 *lp, *lq, *rp;
		REGISTER int cnt = 4096/(int)sizeof(@1);
		@1* lbuf = GDKmalloc(2*cnt*sizeof(@1));
		@1* rbuf = lbuf+cnt;

		lq = (@1*)BUNtloc(l,BUNlast(l));
		lp = (@1*)BUNtloc(l,BUNfirst(l));
		rp = (@1*)BUNtloc(r,BUNfirst(r));
		bnp = (@1*)BUNtloc(bn,BUNlast(bn));
		for (; lp < lq; lp+=cnt, rp+=cnt) {
			/* 0 <= cnt <= 4096, so cast to int is safe */
			REGISTER int x = (int) (lq - lp < cnt ? lq - lp : cnt);
			REGISTER int y = x*(int)sizeof(@1);
			REGISTER int i;
			memcpy(lbuf,lp,y);
			memcpy(rbuf,rp,y);
			for (i=0; i<x; i++) {
				if ((lbuf[i] != @1_nil) && (rbuf[i] != @1_nil)) {
					*bnp = @2(lbuf[i], rbuf[i]);
				} else {
					*bnp = @1_nil;
				}
				bnp++;
			}
		}
	        GDKfree(lbuf);
	} else if ((BUNsize(l)==BUNsize(r))) {
		REGISTER chr *lp, *lq, *rp;
		REGISTER int bs = BUNsize(l);
		REGISTER int sze = (4096/bs)*bs;
		chr* lbuf = GDKmalloc(2*sze);
		chr* rbuf = lbuf+sze;

		lq = (chr*)BUNtloc(l,BUNlast(l));
		lp = (chr*)BUNtloc(l,BUNfirst(l));
		rp = (chr*)BUNtloc(r,BUNfirst(r));
		bnp = (@1*)BUNtloc(bn,BUNlast(bn));
		for (; lp < lq; lp+=sze, rp+=sze) {
			/* 0 <= sze <= 4096, so cast to int is safe */
			REGISTER int z = (int) (lq - lp < sze ? lq - lp : sze);
			REGISTER chr *lbp=lbuf, *lbq=lbuf+z, *rbp=rbuf;
			memcpy(lbuf,lp,z);
			memcpy(rbuf,rp,z);
			for (; lbp < lbq; lbp+=bs, rbp+=bs) {
				if ((*(@1*)lbp != @1_nil) && (*(@1*)rbp != @1_nil)) {
					*bnp = @2(*(@1*)lbp, *(@1*)rbp);
				} else {
					*bnp = @1_nil;
				}
				bnp++;
			}
		}
	        GDKfree(lbuf);
	} else {
		REGISTER chr *lp, *lq, *rp;
		REGISTER int ls = BUNsize(l);
		REGISTER int rs = BUNsize(r);

		lq = (chr*)BUNtloc(l,BUNlast(l));
		lp = (chr*)BUNtloc(l,BUNfirst(l));
		rp = (chr*)BUNtloc(r,BUNfirst(r));
		bnp = (@1*)BUNtloc(bn,BUNlast(bn));
		for (; lp < lq; lp+=ls, rp+=rs) {
			if ((*(@1*)lp != @1_nil) && (*(@1*)rp != @1_nil)) {
				*bnp = @2(*(@1*)lp, *(@1*)rp);
			} else {
				*bnp = @1_nil;
			}
			bnp++;
		}
	}

        bn->batBuns->free = (BUN)bnp - bn->batBuns->base;
        BATsetcount(bn, bn->batBuns->free/BUNsize(bn));
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}
int
valbat_@1_@2(BAT **ret, @1 *v, BAT *b)
{
	REGISTER chr *bp, *bq;
	REGISTER @1 *bnp;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	REGISTER int bs = BUNsize(b);
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "valbat_@1_@2(v,b=%s);\n",BATgetId(b));
 	ERRORcheck((b->htype!=TYPE_void),
 	           "valbat_@1_@2: BAT b must be void-headed.\n");
	/* todo for commutative operators call batval (ie. for * and /) */

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	bnp = (@1*)BUNtloc(bn,BUNlast(bn));
	if (vv != @1_nil) {
		for (; bp < bq; bp+=bs) {
			REGISTER @1 bv = *(@1*)bp;
			if (bv != @1_nil) {
				bv = @2(vv,bv);
			}
			*bnp = bv;
			bnp++;
		}
	} else {
		for (; bp < bq; bp+=bs) {
			*bnp = vv;
			bnp++;
		}
	}
        bn->batBuns->free = (BUN)bnp - bn->batBuns->base;
        BATsetcount(bn, bn->batBuns->free/BUNsize(bn));
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}
int
batval_@1_@2(BAT **ret, BAT *b, @1 *v)
{
	REGISTER chr *bp, *bq;
	REGISTER @1 *bnp;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	REGISTER int bs = BUNsize(b);
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "batval_@1_@2(v,b=%s);\n",BATgetId(b));
 	ERRORcheck((b->htype!=TYPE_void),
 	           "batval_@1_@2: BAT b must be void-headed.\n");

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	bnp = (@1*)BUNtloc(bn,BUNlast(bn));
	if (vv != @1_nil) {
		for (; bp < bq; bp+=bs) {
			REGISTER @1 bv = *(@1*)bp;
			if (bv != @1_nil) {
				bv = @2(bv,vv);
			}
			*bnp = bv;
			bnp++;
		}
	} else {
		for (; bp < bq; bp+=bs) {
			*bnp = vv;
			bnp++;
		}
	}
        bn->batBuns->free = (BUN)bnp - bn->batBuns->base;
        BATsetcount(bn, bn->batBuns->free/BUNsize(bn));
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}
@c

@:unaryimplementations(dbl,exp)@
@:unaryimplementations(dbl,log)@
@:unaryimplementations(dbl,sqrt)@

@:binaryimplementations(dbl,pow)@
