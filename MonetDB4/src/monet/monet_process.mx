@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f monet_process
@a M. L. Kersten, P. Boncz

@* Monet Processes
@T
The multi-threaded parallel implementation of Monet is geared towards 
shared-memory multiprocessors only. 
The single threaded code simply cycles through the queue until it becomes empty.
The multi-threaded Monet code is split into three kinds
of threads that work semi-independently:
\begin{itemize}
\item an Internet Server thread.
\item MIL Interpreter threads.
\item Client Interpreter threads
\end{itemize}

The  MIL interpreter threads take their requests from an internal request
queue. They normally interpreter MIL statements obtained from client sources.

However, the DBA can extend the number of interpreters easily. So as
to support specialized language interpreters direct access to the BAT
primitives and MIL request queue.

since you have to swap fd-s on every request. ]
@-
The number of threads can be controlled by the Monet
routine @%threads@, which assures a number of concurrent interpreter
threads to become active. 
If there are more threads already active then some are selected
at random to cease operation. 
@-
The threads have to update their I/O descriptor before doing I/O.
@h
#ifndef _MONET_PROCESS_H_
#define _MONET_PROCESS_H_
#include "gdk.h"

/* monet standard threads */
m_export void monetInterpreter(void *dummy);
m_export void monetSingle(int status);

/* interpreter thread handling */
m_export MT_Id monetFork(void);
m_export int monetAdjustThreads(int i);
m_export int monetSetChannel(Thread t, stream *in, stream *out);


#endif /* _MONET_PROCESS_H_ */
@c
#include "monetdb4_config.h"
#include "monet.h"

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef NATIVE_WIN32
# include <winsock.h>
#endif
@+ Monet Single Threaded
The single threaded code is large copied from @%monetInterpreter@.
@c
int monet_threads = 0;

void
monetSingle(int status)
{
	Thread t = THRget(THRgettid());

	(void) status;
	if (t == 0)
		return;
	monet_threads++;
	PARDEBUG THRprintf(GDKerr, "monetInterpreter()\n");

	doRequest(t, 0);
	monet_threads--;
	PARDEBUG THRprintf(GDKerr, "exit\n");
}


@+ Monet Interpreter Threads
@-
This will be dropped when everything works ok.
@c
void
monetInterpreter(void *status)
{
	Thread t;

	t = THRnew(MT_getpid(), "Interpreter");
	if (t) {
		monet_threads++;
		monet_up_sema(monet_forksync, "monetInterpreter");
		PARDEBUG THRprintf(GDKerr, "monetInterpreter()\n");

		doRequest(t, 0);
		monet_set_lock(monet_critical, "monetInterpreter");
		THRdel(t);
		monet_threads--;
		monet_unset_lock(monet_critical, "monetInterpreter");
	} else {
		if (status)
			*(int *) status = -1;
		monet_up_sema(monet_forksync, "monetInterpreter");
	}
	PARDEBUG THRprintf(GDKerr, "monetInterpreter(exit)\n");

	if (monet_threads) {
		MT_exit_thread(0);
	} else {
		monet_exit(0);
		MT_global_exit(0);
	}
}

int
monetSetChannel(Thread t, stream *in, stream *out)
{
	if (t == 0) {
		GDKerror("monetSetChannel: unknown thread\n");
	}
	if (t->data[0] == 0 || t->data[1] == 0) {
		return EOF;
	}
	PARDEBUG THRprintf(GDKerr, "setchannel %s %s\n", stream_name(in), stream_name(out));

	t->data[1] = in;
	t->data[0] = out;

	return 0;
}



@-
New interpreters threads are added here. 
If the system is supposed to run with a single interpreter thread
we simply ignore all subsequent requests.
@c
MT_Id
monetFork(void)
{
	MT_Id p = 0;
	int status = 0;

	TMDEBUG printf("# monetFork: embedded %d protected %d forks %d\n", GDKembedded, GDKprotected, monet_forks);

	if (GDKembedded && monet_forks > 0) {
		/* allow for one client only */
		return ~(MT_Id) 0;
	}
	if (!GDKprotected && !GDKembedded) {
		protectMonet();
	}
	monet_forks++;
	monet_set_lock(monet_critical, "monetFork");
	/* exclusive access to monet_forksync barrier
	 * and monet_threads counter. */
	if (MT_create_thread(&p, monetInterpreter, &status) != 0) {
		GDKsyserror("monetFork:failed\n");
		p = ~(MT_Id) 0;
	} else {
		monet_down_sema(monet_forksync, "monetFork");
		if (status)
			p = ~(MT_Id) 0;
	}
	monet_unset_lock(monet_critical, "monetFork");
	return p;
}


int
monetAdjustThreads(int i)
{
	PARDEBUG THRprintf(GDKerr, "monetAdjustThreads(%d)\n", i);

	for (; i < 0; i++) {
		putkillRequest();
	}
	for (; i > 0; i--) {
		if (monetFork() == ~(MT_Id) 0) {
			return monet_threads;
		}
	}
	return monet_threads;
}

@}
