@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f monet_interpreter
@a M. L. Kersten, P. Boncz

@* The Monet interpreter
The command interpreter executes statements taken from the Monet
Execution queue. More than one Monet Interpreter may be simultanuously
active.  Statements may be simple or composite. Composite statements
include IF..THEN, WHILE, sequential blocks, and parallel blocks. The
first two have their ususal intuitive meaning. The latter two create a
new context stack, and put a series of new requests on the queue (one
for each statement in the block).
@
To provide for easy iteration over BATs, there are iterators.
They execute a block of MIL over each BUN in a BAT, substituting
$1 for the current head value and $2 for the current tail value.
Iterators can be specified to run in parallel: in this
case the N MIL-blocks with substituted values are taken into
execution simultanously.
@
Finally, there are the multiplex operators. They execute a MIL command
of N params on a set of N BATs with equal head columns and tail
types corresponding to the N parameters. For each corresponding
set of BUNs the command is invoked. The result values are collected
in the tail column of the result BAT; wherin the head column
is again identical to all other N BATs.
@
MIL programs are represented by trees (see yytree.mx). These
trees are interpreted by the recurcsive interpret() call.
As MIL commands produce maxium one return value, garbage collection
uses the MIL trees (a field in the tree nodes).
@
MIL actions are supposed to be coarse grained. The interpret, however,
is optimized in order to be quick. A common optimization technique is
run-time tree-rewriting. Expensive startup-actions in a block that is
repeatedly executed (like function resolution) is factored out using
this technique.
@{
@h
#ifndef _MONET_INTERPRETER_H_
#define _MONET_INTERPRETER_H_

#include "gdk.h"

@+ signature checking
We compress actual parameter types (argc,argv) of a command in a so-called
'signature bitstring'. This representation is specifically targeted to
providing signature equality checks at very high speed. This is achieved by
making sure the bit string can be compared as an array of 32-bit words.
@T
The signatures contain, in a bit sequence, descriptions for all parameters.
Each parameter starts with a length field of 4 bits. This can encode
values between 0-13 (14/15 are the special values MONETSIG\_BAT/MONETSIG\_BATCONST
that indicate a BAT-value). An integer of this number of bits that encodes the
type number follows. Hence we can encode type numbers up till 4095 (13 bits
integers); The simple case - non-BAT types - gets encoded as follows:
\begin{verbatim}
 CONTENTS:   log(tpe)          tpe
          $__ __ __ __$__ __  ..... __ __$
          $  |  |  |  $  |  | .....   |  $
    NBITS:      4           log(tpe)
\end{verbatim}
For BATs we use the previously mentioned MONETSIG\_BAT or MONETSIG\_BATCONST
in the length field.  After this, we place two encoded types, namely the
head- and tail-type of the BAT. The format of these head- and tail-type
packings is like described above. This yields the below picture:
\begin{verbatim}
BAT/BATCONST log(b->htpe)    b->htype      log(b->ttpe)      b->ttype
$__ __ __ __$__ __ __ __$__ __ __ __ __ __$__ __ __ __$__ __ __ __ __ __$
$  |  |  |  $  |  |  |  $  |  |  |  |  |  $  |  |  |  $  |  |  |  |  |  $
       4           4      log(b->htype)        4         log(b->ttpe)
\end{verbatim}
In the worst case, a BAT-type occupies 4 + 4 + 14 + 4 + 14 = 40 bits = 5 bytes.
In the very very worst case, MAXPARAMS(=32) BAT parameters are given. This would
require 40 (=MONETSIG\_MAXWORDS) 32-bit words to encode in a function signature.
@h
#define MONETSIG_BAT		15
#define MONETSIG_BATCONST	14
#define MONETSIG_MAXWORDS	((MAXPARAMS*40)/32)
#define MONETSIG_NWORDS(s)	((monetsig_nbits(s)+31)	>> 5)
#define MONETSIG_TOTSIZE(s)	(sizeof(monet_sig_t) + sizeof(int)*(s))

/* this structure contains the result of function resolution.
 * one such thing is stored for each expanded MIL operator in a
 * TOK_FUNCTION node */
typedef int (*PackFcn) (int argc, ValPtr argv);

typedef struct {
	PackFcn pack_fcn;	/* function pointer to generated impl stub */
	GDKfcn fast_fcn;	/* function pointer that gets pointer params */
	str fcn_nme;		/* function name */
	sht ret_tpe;		/* -1=unknown, or monet atom number */
	sht token;		/* kind of function to execute */
	chr special;		/* 0=none, 1=ifthenelse, 2=ifthen, 3=ifelse */
	bit assignop;		/* [OP=](A,..) overwrite A with result */
	bit array_opt;		/* multiplex applicable for array opt */
	bit merge_opt;		/* multiplex applicable for merge opt */

	/* BIT SIGNATURE -- we misuse words[0] for storing nbits and argc */
#define monetsig_nbits(s)	((sht*)	(s)->words)[0]
#define monetsig_argc(s)	((sht*)	(s)->words)[1]
	int words[1];		/* allocate the rest dynamically */
} monet_sig_t;

m_export int handle_argerror(ValPtr res, int actual, int correct);
m_export int handle_paramerror(ValPtr res, int param, int actual, int correct);
m_export int interpret(Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_while(Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_ident(Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_var(Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_assignment(Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_seqblock(Cntxt stk, YYSTREE lt, ValPtr res, int scope);
m_export int interpret_parblock(Cntxt stk, YYSTREE lt, int scope);
m_export int interpret_iterator(Cntxt stk, YYSTREE lt, int parallel);
m_export int interpret_str(Cntxt stk, str buf, ValPtr res);
m_export int interpret_file(Cntxt stk, YYSTREE lt, ValPtr res);
m_export int interpret_cast(str atom, int argc, ValPtr val, ValPtr res);
m_export int interpret_batcast(str atom, int argc, ValPtr val, ValPtr res);
m_export void closeProfiler(stream *o);
m_export int startProfiler(stream *o);
m_export int stopProfiler(void);
m_export int setProfilerFilter(str left, str right);
m_export void setProfilerMode(int mode);
m_export BAT *getProfilerCount(void);
m_export BAT *getProfilerTicks(void);
m_export void resetProfiler(void);
#endif /* _MONET_INTERPRETER_H_ */

@c
#include "monetdb4_config.h"
#include "monet.h"

@= pack_bits
	*wordptr |= @2 << bitoffset;
	bitoffset += @1;
	if (bitoffset > 32) {
		bitoffset -= 32;
		*(++wordptr) = @2 >> (@1-bitoffset);
	}
@= pack_type
{	int _tpe = @1, _log, _base;
	if (_tpe < 0)
		_tpe = TYPE_void;
	for (_log = 0, _base = _tpe; _base; _log++)
		_base >>= 1;
	@:pack_bits(4,_log)@
	@:pack_bits(_log,_tpe)@ }
@c
static INLINE int
monet_sig_pack(monet_sig_t *s, int argc, ValPtr argv)
{
	int i = 1, bitoffset = 0, *wordptr = s->words + 1;

	monetsig_argc(s) = argc - 1;
	for (*wordptr = 0; i < argc; i++) {
		BAT *b;

		if (argv[i].vtype == TYPE_bat) {
			bat bid = argv[i].val.bval;

			BBPfix(bid);
			b = (BAT*)BBPgetdesc(ABS(bid));
			if (b) {
				int batbits = (argv[i].len == int_nil) ? MONETSIG_BATCONST : MONETSIG_BAT;

				@:pack_bits(4,batbits)@
				@:pack_type((bid>0)?b->htype:b->ttype)@
				@:pack_type((bid>0)?b->ttype:b->htype)@
			}
			BBPunfix(bid);
			if (!b)
				return -1;
		} else {
		      @:pack_type(argv[i].vtype)@
		}
	}
	monetsig_nbits(s) = (sht) (bitoffset + ((wordptr - (s->words + 1)) << 5));
	return 0;
}

static INLINE int
monet_sig_eq(monet_sig_t *s1, monet_sig_t *s2)
{
	int *e2, *b1 = s1->words, *b2 = s2->words;

	/* check both nbits and argc */
	if (*(b1++) != *(b2++))
		return FALSE;

	e2 = b2 + MONETSIG_NWORDS(s2);
	while (b2 < e2) {
		if (*(b1++) != *(b2++))
			return FALSE;
	}
	return TRUE;
}

@+ Run-time MIL string parsing
Call back the interpreter to do a run-time parse of some string
(that is supposed to be MIL) and execute the resulting tree.

Until recently this was a quite tricky business because the parser modified
the Client state, which interacted with the interpreter garbage
collection which also depends on the Client record (c->maxstk etc).

now we do a lightweight fork to obtain a temporary client session

@- interpret_str
This forks a new subclient in order to get an independent context.
In this context, it calls the parser and executes the tree read.
Then the sub-client is killed.
@c
int
interpret_str(Cntxt stk, str buf, ValPtr res)
{
	int i = -1;

	res->vtype = TYPE_void;

	/* Parse and interpret the script code. */
	if (buf && *buf) {
		Client c = forkClient(stk, FALSE);
		char *input_bak;

		if (c == NULL)
			return i;
		input_bak = c->input;
		c->input = buf;

		if (parseClient(c, FALSE)) {
			i = interpret(c->stk, c->tree, res);
			if (i != -TOK_RETURN) {
				VALclear(res);
			}
			CLEANUP(c->tree);
			Myyfree(c->tree);
			c->tree = NULL;
		}
		c->input = input_bak;
		closeClient(c, FALSE);
	}
	return i;
}

@- interpret_file
First interpret file name, then read file, then call interpret_str().
@c
int
interpret_file(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int i;
	char *ptr, *buf;
	Client c;

	if (lt->cnt != 1) {
		GDKerror("interpret_file: expects just one file name parameter\n");
		return -1;
	}
	i = interpret(stk, arg(lt, 0), res);
	if (i < 0) {
		return i;
	}
	i = res->vtype;
	res->vtype = TYPE_void;
	if (i != TYPE_str) {
		GDKerror("interpret_file: string argument expected.\n");
		return -1;
	}
	ptr = res->val.sval;

	CNTXTclient(stk, &c);

	buf = monet_load_script(ptr, NULL);

	if (buf) {
		i = interpret_str(stk, buf, res);
		GDKfree(buf);
	} else {
		i = -1;
	}
	return i;
}


@* Tree interpretation


@- bat pinning
BATs that are passed into commands must be pinned into memory,
so the BBP trim cannot unexpectedly unload them while a
C implementation is using this BAT handle.

Here, we also solve one of the sticky problems in Monet: calling the
BUNhead and BUNtail macros on BATs with void columns is thread-unsafe (for
no good reason, just due to late evolution in the MIL data structures).

A workaround for this problem is to create a BATview on BATs with void
columns whenever it is going to be accessed concurrently. As concurrent
access (should be) read-only, this should not pose too much hindrance
(VIEWs are read-only and do not allow operators that modify them).

The params macro above examines BATs that are used and creates VIEWs
were appropiate. The below macro is called after execution and
cleans up the created views.
@c
BAT *
interpret_pin(batrec *r, int force, str s)
{
	BAT *b;
	BATDEBUG THRprintf(GDKerr, "interpret_pin(%s) on bat(%d) refcnt = %d\n", s, (int) r->id, BBPrefs(r->id) + 1);
	b = BATdescriptor(r->id);

	if (b == NULL) {
		return NULL;
	} else if ((b->htype == TYPE_void) | (b->ttype == TYPE_void)) {
		BAT *_b = BBP_cache(ABS(r->id));
		int tid = THRgettid();

		monet_set_lock(monet_voidLock, "pin");
		if (_b->void_cnt & (force | (_b->void_tid != tid))) {
			BAT *v = VIEWcreate(b);
			BBPunfix(r->id);

			v->batStamp = b->batCacheid;
			BATDEBUG THRprintf(GDKerr, "interpret_pin(%s) create %d[1,%d] on %d[%d,%d]\n", s, (int) v->batCacheid, tid, (int) b->batCacheid, _b->void_cnt, _b->void_tid);

			_b = b = v;
		} else {
			BATDEBUG THRprintf(GDKerr, "interpret_pin(%s) => %d[%d,%d]\n", s, b->batCacheid, _b->void_cnt + 1, _b->void_tid);
		}
		_b->void_cnt++;
		_b->void_tid = tid;
		monet_unset_lock(monet_voidLock, "pin");
	}
	r->id = b->batCacheid;

	r->stamp = b->batStamp;
	return b;
}

void
interpret_unpin(batrec *r, str s)
{
	BAT *b = BBP_cache(r->id);
	BATDEBUG THRprintf(GDKerr, "interpret_unpin(%s) on bat(%d) refcnt = %d\n", s, (int) r->id, BBPrefs(r->id) - 1);

	if (b) {
		if (b->batStamp != r->stamp) {
			GDKerror("interpret_unpin: %s bat=%d,stamp=%d OVERWRITTEN\n", s, r->id, r->stamp);
		} else if (b->htype == TYPE_void || b->ttype == TYPE_void) {
			BAT *_b = BBPdescriptor(ABS(r->id));

			monet_set_lock(monet_voidLock, "unpin");
			if (--(_b->void_cnt) == 0) {
				BATDEBUG THRprintf(GDKerr, "interpret_unpin(%s) => kill %d[%d,%d]\n", s, (int) b->batCacheid, _b->void_cnt, _b->void_tid);

				_b->void_tid = 0;
			} else {
				BATDEBUG THRprintf(GDKerr, "interpret_unpin(%s) => %d[%d,%d]\n", s, (int) b->batCacheid, _b->void_cnt, _b->void_tid);
			}
			monet_unset_lock(monet_voidLock, "unpin");
		}
	}
	BBPunfix(r->id);
}

@- param execution(name,lt,argc,argv)
this macro interprets all parameters of name={operator,function,etc} 'lt'
placing the parameter count in  'argc' and the result values in 'argv[1..argc]'
@c
int
interpret_params(int stk, YYSTREE lt, ValPtr params, str fcn_nme)
{
	ValPtr val_array = params + 1;
	unsigned j;
	int argc = 1;

	params[0].vtype = TYPE_void;
	params[0].val.oval = void_nil;
	for (argc = 1; lt; lt = YYOVERFLOW(lt)) {
		YYSTREE *t = lt->yysons;

		for (j = 0; j < lt->cnt; j++, t++) {
			ValRecord res, *argv = &res;
			YYSTREE tt = *t;
			int inc = 1, param_range = 0;

			if (argc >= MAXPARAMS + 1) {
				GDKerror("interpret_params: %s parameters out of range: [0,%d]).\n", fcn_nme, MAXPARAMS - 1);
				return -argc;
			}
			if (tt->token == TOK_RANGETEMP) {
				tt = tt->yysons[0];
				param_range = 1;
			}
			if (interpret(stk, tt, &res) < 0) {
				GDKerror("interpret_params: %s(param %d): evaluation error.\n", fcn_nme, j + 1);
				return -argc;
			}
			if (param_range) {
				inc += (*t)->yyval.len - argv->val.ival;
				argv = ((ValPtr) (*t)->yyval.val.pval) + argv->val.ival;
				if (res.vtype != TYPE_int) {
					GDKerror("interpret_params: %s(param %d): illegal vararg range.\n", fcn_nme, j + 1);
					return -argc;
				}
			}
			if (inc > 0 && argc + inc > MAXPARAMS + 1) {
				GDKerror("interpret_params: %s parameters out of range: [0,%d]).\n", fcn_nme, MAXPARAMS - 1);
				return -argc;
			}
			while (inc-- > 0) {
				if (argv->vtype == TYPE_bat) {
					if (BBPcheck(argv->val.bval, "interpret_params") == 0) {
						GDKerror("interpret_params: %s(param %d): invalid BAT.\n", fcn_nme, j + 1);
						return -argc;
					}
				} else if (ATOMextern(argv->vtype)) {
					if (!argv->val.pval) {
						GDKerror("interpret_params %s(param %d): invalid %s.\n", fcn_nme, j + 1, ATOMname(argv->vtype));
						return -argc;
					}
				}
				*val_array++ = *argv++;
				argc++;
			}
		}
	}
	return argc;
}

void
interpret_params_unpin(int argc, ValPtr argv, str op_name)
{
	int i = 0;

	while (++i < argc)
		if (argv[i].vtype == TYPE_bat) {
			interpret_unpin(&argv[i].val.br, op_name);
		}
}

int
interpret_params_pin(int argc, ValPtr argv, str op_name)
{
	int i, j;

	for (i=1; i < argc; i++)
		if (argv[i].vtype == TYPE_bat) {
			bat bi = ABS(argv[i].val.bval);
			for (j=1; j < i; j++) {
				bat bj = ABS(argv[j].val.bval);
				if ((argv[j].vtype == TYPE_bat) & (bi == bj)) {
					BAT *b = BBP_cache(argv[i].val.bval);
					if ((b->htype == TYPE_void) | (b->ttype == TYPE_void)) 
						break; /* danger: same void bat passed twice! */ 
				}
			}
			if (interpret_pin(&argv[i].val.br, j<i, op_name) == NULL) break;
		}
	if (i < argc) {
		interpret_params_unpin(i, argv, op_name);
		return 0;
        }
	return 1;
}

@-
The new version dumps performance information on a separate profiling
event stream. The amount of data is rather large and a potential
performance bottleneck. Nevertheless, it is considered usefull information
for debugging and optimizing the mil programs.

When the profilermode is set to >1, it collects information
in a persistent BAT. It can be picked up at a later time for inspection.
This can be extended upon need to also collect the timings.

To avoid problems, each time client disappears we close the profiling option.
It should be explicitly set afterwards.
@c
#ifdef HAVE_TIMES
#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif

#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif
#include "monet_deparse.h"
static void onlineProfilerEvent(char *caller, lng clk, lng ticks, struct tms *timer, YYSTREE lt);
static void onlineProfilerHeader(void);

static stream *eventstream = NULL;
static int delayswitch = 0;
static int showheader = 0;
static int profilemode = 0;	/* 1-> events 2-> count summary */
static BAT *profilerCount = 0;
static BAT *profilerTicks = 0;

void
closeProfiler(stream *o)
{
	monet_set_lock(profilerLock, "startProfiler");
	if (o == eventstream) {
		eventstream = NULL;
	}
	profilemode = 0;
	monet_unset_lock(profilerLock, "startProfiler");
}

int
startProfiler(stream *o)
{
	monet_set_lock(profilerLock, "startProfiler");
	eventstream = o;
	delayswitch = 1;
	showheader = 1;
	profilemode = 1;
	monet_unset_lock(profilerLock, "startProfiler");
	return 0;
}

void 
commitProfiler(void)
{
	BAT *b = BATnew(TYPE_void, TYPE_str, 3);

	BUNappend(b, BBPname(profilerCount->batCacheid), FALSE);
	BUNappend(b, BBPname(profilerTicks->batCacheid), FALSE);
	TMsubcommit(b);
	BBPreclaim(b);
}

int
stopProfiler(void)
{
	monet_set_lock(profilerLock, "stopProfiler");
	eventstream = NULL;
	profilemode = 0;
	if (profilerCount || profilerTicks)
		commitProfiler();
	monet_unset_lock(profilerLock, "stopProfiler");
	return 0;
}

void
setProfilerMode(int mode)
{
	profilemode = mode;
	if (mode > 1) {
		/* check existence of the BAT */
		profilerCount = BATdescriptor(BBPindex("monet_profiler_count"));
		if (profilerCount == NULL) {
			profilerCount = BATnew(TYPE_str, TYPE_int, (size_t) 1000);
			BBPrename(profilerCount->batCacheid, "monet_profiler_count");
			BATroles(profilerCount, "name", "count");
			BATmode(profilerCount, PERSISTENT);
			BBPincref(profilerCount->batCacheid, TRUE);
		} else		/* keep it in memory */
			BBPincref(profilerCount->batCacheid, TRUE);
		profilerTicks = BATdescriptor(BBPindex("monet_profiler_ticks"));
		if (profilerTicks == NULL) {
			profilerTicks = BATnew(TYPE_str, TYPE_lng, (size_t) 1000);
			BBPrename(profilerTicks->batCacheid, "monet_profiler_ticks");
			BATroles(profilerTicks, "name", "count");
			BATmode(profilerTicks, PERSISTENT);
			BBPincref(profilerTicks->batCacheid, TRUE);
		} else		/* keep it in memory */
			BBPincref(profilerTicks->batCacheid, TRUE);
		commitProfiler();
		/* set default filters */
		setProfilerFilter("proc", "*");
		setProfilerFilter("command", "*");
	}
}
BAT *
getProfilerCount()
{
	return profilerCount;
}

BAT *
getProfilerTicks()
{
	return profilerTicks;
}

void
resetProfiler()
{
	if (profilerCount)
		BATclear(profilerCount);
	if (profilerTicks)
		BATclear(profilerTicks);
}
#else
void
closeProfiler(stream *o)
{
	(void) o;
}

int
startProfiler(stream *o)
{
	(void) o;
	return 0;
}

int
stopProfiler(void)
{
	return 0;
}

void
setProfilerMode(int mode)
{
	(void)mode;
}

BAT *
getProfilerCount()
{
	return 0;
}

BAT *
getProfilerTicks()
{
	return 0;
}

void
resetProfiler()
{
}
#endif /* HAVE_TIMES */
@-
The information gathered is currently limited to some basic OS properties;
It is dumped on the eventstream whenever we leave the interpreter();
@= profileEvent
#ifdef HAVE_TIMES
	if (profilemode) {
		lng nc = GDKusec();
		onlineProfilerEvent("@1", nc, nc - clk, &timer, lt);
	}
#endif
@= profileCapture
#ifdef HAVE_TIMES
	if( eventstream) {
		clk=GDKusec();
		times(&timer);
	}
#endif
@c

/* two handy utilities for builtin functions */
int
handle_argerror(ValPtr res, int actual, int correct)
{
	str s = GDKmalloc(80);

	VALclear(res);
	res->val.sval = s;
	res->vtype = TYPE_str;
	sprintf(s, "%d arguments expected (got %d)", correct, actual);
	return -1;
}

int
handle_paramerror(ValPtr res, int param, int actual, int correct)
{
	str s = GDKmalloc(80);

	VALclear(res);
	res->val.sval = s;
	res->vtype = TYPE_str;
	sprintf(s, "parameter %d has type '%s' ('%s' expected)", param, TBL_atomname(actual), TBL_atomname(correct));
	return -1;
}

/* the guts of MIL interpretation */
int
interpret(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int stamp, i = res->len = 0, r = 0;

#ifdef HAVE_TIMES
	lng clk = 0;
	struct tms timer;

	@:profileCapture@
#endif
@-
We do not want recursive programs crashing the server, so once in
a while we check whether we are running dangerously low on available
stack space.
@c
	if ((stk & 31) == 31 && THRhighwater()) {
		GDKerror("interpret: running out of physical stack space!\n");
		return -1;
	}

@+ passive interpretations
massaging interpretation of MIL trees. We shuffle some values around.
No new ones are created. Nothing really happens in the GDK world of BATs.
@c
	if (lt->token <= TOK_TRG) {
		/* the switch list is kept dense (see monet_parse.mx) so maybe
		 * the C compiler can construct a nice jump-table.
		 */
		switch (lt->token) {
		case TOK_ITERTEMP:
		case TOK_TEMPLATE:
			if (!lt->yyval.val.pval || lt->yyval.vtype != TYPE_ptr) {
				GDKerror("interpret: unresolved reference.\n");
				return -1;
			}
			*res = *((ValPtr) lt->yyval.val.pval);
			@:profileEvent(template)@
			return 0;
		case TOK_VARTEMP:
			i = interpret(stk, lt->yysons[0], res);
			if (i < 0) {
				@:profileEvent(vartemp)@
				return i;
			}
			if (res->vtype != TYPE_int) {
				GDKerror("interpret: vararg must be an int.\n");
				return -1;
			}
			if ((res->val.ival < 1) || (res->val.ival > lt->yyval.len)) {
				GDKerror("interpret: vararg $%d does not exist.\n", res->val.ival);
				return -1;
			}
			*res = ((ValPtr) lt->yyval.val.pval)[res->val.ival];
			@:profileEvent(vartemp)@
			return 0;
		case TOK_RANGETEMP:
			GDKerror("interpret: parameter range not appropriate here.\n");
			return -1;
		case TOK_CONSTANT:
			*res = lt->yyval;
			@:profileEvent(constant)@
			return 0;
		case TOK_ASSIGNMENT:
			r = interpret_assignment(stk, lt, res);
			@:profileEvent(assignment)@
			return r;
		case TOK_SEQBLOCK:
			i = 1;
			/* fall through */
		case TOK_SEQ:
			return interpret_seqblock(stk, lt, res, i);
		case TOK_PARBLOCK:
			return interpret_parblock(stk, lt, 1);
		case TOK_PAREND:
			return 0;
		case TOK_IDENT:
			return interpret_ident(stk, lt, res);
		case TOK_IF:
			if ((i = interpret(stk, arg(lt, 0), res)) < 0) {
				@:profileEvent(if)@
				return i;
			}
			if (res->vtype != TYPE_bit) {
				GDKerror("interpret: if-expression needs BIT param.\n");
				return -1;
			} else if (res->val.cval[0] == bit_nil) {
				GDKerror("interpret: if bit(nil): don't know what to do!\n");
				return -1;
			}
			if (res->val.cval[0]) {
				r = interpret(stk, arg(lt, 1), res);
				@:profileEvent(if1)@
				return r;
			} else if (lt->cnt == 3) {
				r = interpret(stk, arg(lt, 2), res);
				@:profileEvent(if2)@
				return r;
			}
			@:profileEvent(if3)@
			break;
		case TOK_WHILE:
			return interpret_while(stk, lt, res);
		case TOK_ITERATOR:
		case TOK_ITCOMPILED:
			if (lt->cnt > 1 && lt->yysons[2]) {
				i = interpret(stk, lt->yysons[2], res);
				if (i < 0)
					return i;
				if (res->vtype != TYPE_int) {
					GDKwarning("interpret: parloop specifier cast to INT.\n");
				}
				i = MAX(1, res->val.ival);
				CLEANUP(lt->yysons[2]);
			} else {
				i = 1;
			}
			i = interpret_iterator(stk, lt, i);
			@:profileEvent(itcompiler)@
			return CATCHBREAK(i);
		case TOK_BREAK:
			return -TOK_BREAK;
		case TOK_RETURN:
			if (lt->cnt > 0 && lt->yysons[0]) {
				i = interpret(stk, arg(lt, 0), res);
				if (i < 0)
					return i;
				ATOMfix(res->vtype, VALptr(res));
				VALcopy(res, res);
			}
			@:profileEvent(return)@
			return -TOK_RETURN;
		case TOK_VAR:
			r = interpret_var(stk, lt, res);
			@:profileEvent(var)@
			return r;
		case TOK_CONST:
			i = interpret(stk, lt->yysons[0], res);
			if (res->vtype == TYPE_bat) {
				res->len = int_nil;
			}
			@:profileEvent(const)@
			return i;

@+ active interpretations
An interpreter is not just interpreting things all the time as this would
mean that nothing could ever happen (you cannot implement smalltalk in
smalltalk in smalltalk, etc..) Magic things must be done someday somewhere!
That place is here for MIL. The tokens below this line call GDK/C routines.
They are able to produce new values in the process. The deallocation
primitives CATCH* look after garbage collecting these results.
@c
		case TOK_BUILTIN:
		{
			int (*imp) (Cntxt, YYSTREE, ValPtr) = (int (*)(Cntxt, YYSTREE, ValPtr)) lt->yyval.val.pval;

			res->vtype = TYPE_void;
			res->val.oval = void_nil;
			stamp = BBPcurstamp();
			i = (*imp) (stk, lt, res);
			if (i >= 0) {
				CATCHREF(stk, lt, res);
			}
			CATCHERR(stk, lt, res, i, ((YYSTREE) imp));
			@:profileEvent(builtin)@
			break;
		}
#ifdef MKMODS
		case TOK_TRG:
			i = interpret_trg(stk, lt, res);
			CATCHERR(stk, lt, res, i, lt->yysons[2]);
			break;
#endif
		}
	} else if (lt->token > TOK_SETAGGR) {
		GDKerror("interpret: unexpected token %d.\n", lt->token);
		return -1;

@- MIL functor interpretation
Basic MIL functors with multiple parameters (builtins were handled separately
above). All of which may be string derefences ((*nme)(), {*nme}(), [*nme]())
@T
When a functor-tree is inside a loop, it gets executed multiple times.
Evaluation of a MIL functor (be it a command, proc, set aggregate or multiplex)
needs to go through a phase of {\em function resolution}. This involves finding
the correct overloading of a functor, given the types of the actual parameters.
This resolution process is slow. We want to exploit the fact that often on each
iteration, the types of the actual parameters will be equal (as MIL
is a dynamically typed language, we can never guarantee this 100\%).
In such cases, we factor out command resolution overhead, by using the results
of an earlier iteration.

The result of function resolution is often a tree-expansion, that contains
specific info, which depends on the mode of execution (e.g. proc, command,
multiplex, or set-aggr execution). To accomodate these optimizations in
a generalized setting, each functor MIL tree has the following generic
format:
\begin{verbatim}
                            TOK_FUNCTION
                            yyval.val.sval="print"  ==> function string name
                            yysons[0,1,2]
                                  /  |  \
                                 /   |   \
                                /    |    \
                               /     |     \
                              /      |      \
                         PARAMS  EXPANSIONS  DEREF
                      yysons[..] yysons[..]  yysons[..]
                         /|\        /\        /\
call:                   / | \      /  \      /  \  ==> tree that evaluates
interpret     <==  argv[1]|argv[3]/    \    /____\     to a str fcn-name
 (stk,argv[i],res)      argv[2]  /      \                        (OPTIONAL)
                               sig1    sigN
to get the param               /\      yyval.val.pval->monet_sig_t
          values              /  \                     'signature record'
                             /____\ ==> e.g. expanded
                                             PROC tree for sig1
\end{verbatim}
The sig-nodes contain a signature-bitstring, that contains a compressed
representation of the actual parameters for which the expansion was done.
The EXPANSION node hence is like a 'cache' in which the interpret() can
do a quick lookup to see whether an expansion was already made in an earlier
iteration for these actual parameter settings. If so, it can reuse the
already expanded functor. If not, it must expand it the functor and
put it into the EXPANSIONS tree.
@c
	} else {
		YYSTREE op, opcache = lt->yysons[1], tt = opcache;
		int argc, deref_fcn = (lt->cnt >= 3);
		ValRecord local[MAXPARAMS+1], *argv = local;
		int *buf;
		monet_sig_t *sig;
		str fcn_nme;

@-
phase 1: resolve 'nme' in (*nme)(), {*nme}(), and [*nme]()
@c
		if (deref_fcn) {
			i = interpret(stk, lt->yysons[2], res);
			if (i < 0 || res->vtype != TYPE_str) {
				GDKerror("interpret: operator string name expected.\n");
				return -1;
			} else {
				int l = (int) strlen(res->val.sval);
				str s = (str) alloca(l + 3);

				/* resume normal dereference case */
				fcn_nme = s;
				if (lt->token == TOK_SETOP) {
					*(s++) = '[';
				} else if (lt->token == TOK_SETAGGR) {
					*(s++) = '{';
				}
				strcpy(s, res->val.sval);
				s += l;
				if (lt->token == TOK_SETOP) {
					*(s++) = ']';
				} else if (lt->token == TOK_SETAGGR) {
					*(s++) = '}';
				}
				*s = 0;
			}
		} else {
			fcn_nme = lt->yyval.val.sval;
		}
		buf = (int *) alloca(MONETSIG_TOTSIZE(MONETSIG_MAXWORDS));
		sig = (monet_sig_t *) buf;


@-
phase 2: interpret the actual params
@c
		/* PROCs attach the argv storage to the tree so they can keep pointing to it across iterations */
		if (opcache->yyval.vtype == TYPE_str) {
			argv = opcache->yyval.val.pval; 
		}
		argc = interpret_params(stk, lt->yysons[0], argv, fcn_nme);
		if (argc < 0)
			return -1;
		res->vtype = TYPE_void;
		res->val.oval = void_nil;
@-
phase 3: check if we have this already in expanded form
@c
		if (monet_sig_pack(sig, argc, argv)< 0)
			return -1;

		do {
			unsigned j;
			for (j = 0; j < tt->cnt && (op = tt->yysons[j]); j++) {
				monet_sig_t *p = (monet_sig_t *) op->yyval.val.pval;
				if (monet_sig_eq(sig, p)) {
					if (deref_fcn && strcmp(p->fcn_nme, fcn_nme))
						continue;
					sig = p;
					goto exec;	/* HIT => skip phases 4-6 */
				}
			}
		} while ((tt = YYOVERFLOW(tt)) != NULL);
@-
phase 4: do resolution and expand an execution tree in op
@c
		sig->token = i = TBL_normal_resolve(fcn_nme, argc, argv, sig, stk);
		if (i < 0) {
			char *alt_nme = (char *) alloca(128), p = *fcn_nme;
			int tok_cast = TOK_BATCAST, retry = i;

			if (p == '{' || p == '[') {
				strcpy(alt_nme, fcn_nme + 1);
				alt_nme[strlen(alt_nme) - 1] = 0;

				if (p == '{') {
					retry = TBL_setaggr_resolve(alt_nme, argc, argv, sig, stk);
					sig->token = TOK_SETAGGR;
				} else {
					sig->assignop = (lt->yyval.len == -TOK_ASSIGNOP);
					sig->special = 0;
					if (alt_nme[0] == 'i' && alt_nme[1] == 'f') {
						if (strcmp(alt_nme + 2, "thenelse") == 0) {
							sig->special = 1;
						} else if (strcmp(alt_nme + 2, "then") == 0) {
							sig->special = 2;
						} else if (strcmp(alt_nme + 2, "else") == 0) {
							sig->special = 3;
						}
					}
					retry = TBL_multiplex_resolve(alt_nme, argc, argv, sig, stk);
					sig->token = TOK_SETOP;
					if (retry == TBL_RESOLVE_NOBAT) {
						/* accept [+](1+1) as +(1,1) */
						sig->token = retry = TBL_normal_resolve(alt_nme, argc, argv, sig, stk);
						tok_cast = TOK_CAST;
					} 
					if (retry < 0 && argc == 2 && (retry = ATOMindex(alt_nme)) >= 0) {
						fcn_nme = BATatoms[retry].name;
						sig->token = i = tok_cast;
					}
				}
			} else {
				alt_nme = fcn_nme;
				if (argc <= 2 && (retry = ATOMindex(alt_nme)) >= 0) {
					fcn_nme = BATatoms[retry].name;
					sig->token = i = TOK_CAST;
				}
			}
			if (retry > i)
				i = retry;	/* found something better */

			if (i < 0 && opcache->token == TOK_IDENT) {
				GDKerror("interpret: unknown variable '%s'.\n", fcn_nme);
				return -1;
			}

			/* Function resolution error */
			if (i < 0) {
				char *s, *signatures = NULL;

@- phase 5: function resolution error

A function resolution error generally gives and i=TBL_RESOLVE_NOFCN result;

However, sometimes there is/are an existing function(s) by this name
and with a matching number of parameters, but the actual parameter types don't
(fully) match a signature. If enumeration types are to be supported in the
MIL kernel, we could now trap and any convert enumeration types present to
their original representation (one by one, cheapest conversion first) and retry.

Such a conditition is identified by a return of i = TBL_RESOLVE_NOSIG
more precisely: (i ==TBL_RESOLVE_NOSIG ||  op->token==TBL_RESOLVE_NOSIG)

Finally, when a user uses a type that is not loaded by himself in an invocation,
there is a special error code TBL_RESOLVE_NOTPE; in that case we give an
appropriate error message (signatures == NULL) and don't show the list of
alternative signatures.
@c
				if (i != TBL_RESOLVE_NOTPE) {
					signatures = (char *) alloca(8192);
					TBL_printsigs(signatures, stk, fcn_nme);
					if (p == '{' || p == '[') {
						for (s = signatures; *s; s++)
							;
						TBL_printsigs(s, stk, alt_nme);
					}
				}
				monet_sigerror("MIL operator", fcn_nme, signatures, argc, argv);
				return -1;
			}
		}

@- phase 6: expansion
Expand a procedure tree (if fcn_nme resolved to a proc), create a new
signature record (of just the right size - `not a penny too much') and
add it to the expansion cache.
@c
		/* if procs are involved, we need to attach an allocated argv to the tree */
		if (opcache->yyval.vtype == TYPE_int && i == TOK_PROC) {
			/* it *should* fit the size predicted by Myypostprocess() */
			assert((int) (argc*sizeof(ValRecord)) <= opcache->yyval.val.ival);

			opcache->yyval.vtype = TYPE_str;
			opcache->yyval.len = opcache->yyval.val.ival;
			opcache->yyval.val.pval = GDKmalloc(opcache->yyval.len);
			memcpy(opcache->yyval.val.pval, argv, opcache->yyval.len);
			argv = opcache->yyval.val.pval;
		}

		if (i == TOK_PROC) {
#if 0
			/* PETER: temporary hack to monitor proc instantiation (1/2) */
			static BAT *yysubst = NULL;

			if (yysubst == NULL) {
				yysubst = BATnew(TYPE_str, TYPE_lng, 1000);
				BATrename(yysubst, "yysubst");
			}
			argv[0].val.ival = 0;
#endif
			op = Myysubstitute_proc((YYSTREE) sig->pack_fcn, argc - 1, argv);
#if 0
			{	/* PETER: temporary hack to monitor proc instantiation (2/2) */
				BUN pp = BUNfnd(yysubst, fcn_nme);
				lng add = (LL_CONSTANT(1) << 32) + argv[0].val.ival;
				if (pp == NULL) {
					BUNins(yysubst, fcn_nme, &add, FALSE);
				} else {
					*((lng *) BUNtloc(yysubst, pp)) += add;
				}
			}
#endif
		} else {
			op = Myynode(i, 0);
			if (opcache->yyval.vtype != TYPE_int) {
				memcpy(opcache->yyval.val.pval, argv, opcache->yyval.len);
				argv = opcache->yyval.val.pval;
			}
		}
		i = MONETSIG_TOTSIZE(MONETSIG_NWORDS(sig));	/*length */
		if (deref_fcn) {
			str s = fcn_nme;

			sig = (monet_sig_t *) GDKmalloc(i + strLen(fcn_nme));
			strcpy(fcn_nme = ((char *) sig) + i, s);
		} else {
			sig = (monet_sig_t *) GDKmalloc(i);
		}
		memcpy(sig, buf, i);
		sig->fcn_nme = fcn_nme;
		op->yyval.val.pval = (ptr) sig;
		op->yyval.vtype = TYPE_str;	/* this triggers deallocate of sig */
		Myyexpand(opcache, op);	/* add 'op' to the expansion list */

@- phase 7: execution
Comes down to 3 cases: normal, proc, or {X}/[X] execution
@c
	      exec:stamp = BBPcurstamp();
		if (sig->token == TOK_PROC) {
			YYSTREE proc = (YYSTREE) sig->pack_fcn;

			i = interpret(stk, op, res);
			CATCHRET(stk, opcache, res, i);
			CATCHERR(stk, opcache, res, i, proc);
			if (i >= 0 && !TBL_procreturn(argc, argv, res, proc)) {
				if (proc->noyyval)
					GDKerror("interpret: proc returned unexpected type.\n");
				else
					GDKerror("interpret: %s returned unexpected type.\n", proc->yyval.val.sval);
				i = -1;
			}
			@:profileEvent(proc)@
			return i;
		}
		if (!interpret_params_pin(argc, argv, fcn_nme)) {
			return -1;
		}
		if (sig->token == TOK_COMMAND) {
			i = (*sig->pack_fcn) (argc, argv);
			*res = argv[0];
			CATCHVAL(stk, opcache, res);
			CATCHERR(stk, opcache, res, i, ((YYSTREE) sig->pack_fcn));
			@:profileEvent(command)@
		} else if (sig->token == TOK_CAST) {
			i = interpret_cast(sig->fcn_nme, argc, argv + 1, res);
			@:profileEvent(cast)@
			if (i >= 0) {
				CATCHREF(stk, opcache, res);
			}
		} else if (sig->token == TOK_BATCAST) {
			i = interpret_batcast(sig->fcn_nme, argc, argv + 1, res);
			@:profileEvent(batcast)@
			if (i >= 0) {
				CATCHREF(stk, opcache, res);
			}
		} else {
			/* multiplex and set aggregate can execute procs in a loop!
			 * we must indicate this to the garbage collector. It will
			 * keep the context records around for speed.
			 */
			int reuse = monet_cntxt[stk].reuse;

			if (reuse < 0) {
				monet_cntxt[stk].reuse = stk;
			}
			if (sig->token == TOK_SETAGGR) {
				i = interpret_setaggr(sig->fcn_nme, argc, argv, res, op, stk);
				@:profileEvent(setaggr)@
			} else if (sig->token == TOK_SETOP) {
				i = interpret_multiplex(sig->fcn_nme, argc, argv, res, op, stk);
				@:profileEvent(setop)@
			}
			CATCHVAL(stk, opcache, res);
			if (reuse < 0) {
				monet_cntxt[stk].reuse = reuse;
				CNTXTfree1(stk);
			}
		}
		interpret_params_unpin(argc, argv, fcn_nme);
	}
	return i;
}

@+ Specific Interpretations
@c
@- While-loop Interpretation
@c
#define RETURN(x) { i = x; goto xit; }

int
interpret_while(int stk, YYSTREE lt, ValPtr res)
{
	int i, reuse = monet_cntxt[stk].reuse;

	if (reuse < 0) {
		monet_cntxt[stk].reuse = stk;
	}
	if ((i = interpret(stk, arg(lt, 0), res)) < 0) {
		RETURN(i);
	}
	if (res->vtype != TYPE_bit) {
		GDKerror("interpret_while: expression needs BIT param.\n");
		RETURN(-1);
	} else if (res->val.cval[0] == bit_nil) {
		GDKerror("interpret_while: bit(nil) => don't know what to do!\n");
		RETURN(-1);
	}

	while (res->val.cval[0]) {
		CLEANUP(arg(lt, 0));
		if ((i = interpret(stk, arg(lt, 1), res)) < 0) {
			RETURN(CATCHBREAK(i));
		}
		CLEANUP(arg(lt, 1));
		if ((i = interpret(stk, arg(lt, 0), res)) < 0) {
			RETURN(i);
		}
	}
	i = 0;
  xit:
	CLEANUP(arg(lt, 0));
	if (reuse < 0) {
		monet_cntxt[stk].reuse = reuse;
		CNTXTfree1(stk);
	}
	return i;
}

@- Identifier Interpretation
Identifiers are resolved only the first time. If they are
a constant expression, they are substituted by constants. If they
denote a variable value, it is replaced by a pointer (TOK_TEMPLATE)
to the @%ValRecord@ of that variable in the context stack.
@c
int
interpret_ident(int stk, YYSTREE lt, ValPtr res)
{
	int i = stk;
	Variable v = VARfind(&i, lt->yyval.val.sval);

	if (v != NULL) {
		if (!lt->iscopy) GDKfree(lt->yyval.val.sval);
		/* resolve only once: TEMPLATE */
		lt->token = TOK_TEMPLATE;
		lt->yyval.vtype = TYPE_ptr;
		lt->yyval.val.pval = &v->binding;
		*res = v->binding;
		return 0;
	}
	if (!monet_nostalgic) {
		GDKerror("interpret: unknown variable '%s'.\n", lt->yyval.val.sval);
		return -1;
	}
	Myyexpand(lt, Myynode(0, 0));
	Myyexpand(lt, Myynode(TOK_IDENT, TYPE_int));
	lt->token = TOK_FUNCTION;
	lt->yyval.vtype = TYPE_str;
	lt->yyval.len = 1 + (int) strlen(lt->yyval.val.sval);
	return interpret(stk, lt, res);
}

@- Variable Declaration Interpretation
Only executed the first time. We keep the variable stacks, so
the second time only the initialization statements are executed as
a sequential block.
@c
int
interpret_var(int stk, YYSTREE lt, ValPtr res)
{
	int i = 0;

	lt->token = TOK_SEQ;	/* we only create once */
	for (; lt; lt = YYOVERFLOW(lt)) {
		Variable v;
		unsigned j;

		for (j = 0; j < lt->cnt; j++) {
			YYSTREE t = lt->yysons[j];

			if (t != NULL) {
				v = VARlocalfind(&stk, t->yyval.val.sval);
				if (!v) {
					v = VARnew(stk, t->yyval.val.sval);
				} else {
					/*GDKwarning("Overwriting var %s\n", t->yyval.val.sval); */

					ATOMunfix(v->binding.vtype, VALptr(&(v->binding)));
					VALclear(&v->binding);
				}
				if (t->token == TOK_ASSIGNMENT) {
					arg(t, 0)->token = TOK_TEMPLATE;
					arg(t, 0)->yyval.vtype = TYPE_ptr;
					arg(t, 0)->yyval.val.pval = (ptr) &v->binding;
					i = interpret_assignment(stk, t, res);
					CLEANUP(t);
					if (i < 0)
						break;
				} else {
					/* ignore this node in the future */
					t->token = TOK_PAREND;
				}
			}
		}
	}
	return i;
}


@- MIL Trigger Interpretation
Instantiation of a trigger is more-or-less equivalent to procedure call.
A copy of the trigger definition is used and scheduled for execution.
@c
#ifdef MKMODS
int
interpret_trigger(int stk, YYSTREE lt, ValPtr res)
{
	ValPtr argv = (ValPtr) GDKmalloc((1 + MAXPARAMS) * sizeof(ValRecord));
	YYSTREE definition = (YYSTREE) lt->yyval.val.pval;
	YYSTREE t, expr;
	int argc, i = 0;

	argc = interpret_params(stk, lt, argv, definition->yyval.val.sval);
	if (argc < 0) {
		i = argc;
		goto xit;
	}
	t = Myynode(TOK_COMPILED, TYPE_str);
	t->yyval.len = MAXPARAMS * sizeof(ValRecord);
	t->yyval.val.pval = argv;
	t->yysons[0] = Myysubstitute_proc(definition, argc - 1, argv);
	lt->yysons[2] = definition;
	t->cnt = 1;
	i = TEMenable(stk, t->yysons[0], res);
  xit:
	return i;
}
#endif


@- Atomic Cast Interpretation
Any atom can be casted to another one. All numeric values can be interchanged,
and conversion to and from string is always possible.
@c
#define trivial_cast(dst,src)	\
	((dst) == (src) || \
	 (ATOMstorage(dst) == ATOMstorage(src) && \
	  ((dst) != TYPE_oid) /* oid is unsigned, while int & lng are signed! */ && \
	  ((dst) != TYPE_str || BATatoms[src].atomToStr == BATatoms[TYPE_str].atomToStr) && \
	  ((src) != TYPE_str || BATatoms[dst].atomFromStr == BATatoms[TYPE_str].atomFromStr)))

int
interpret_cast(str atom, int argc, ValPtr val, ValPtr res)
{
	int tpe = ATOMindex(atom);

	if (argc == 1) {
		res->vtype = TYPE_int;
		res->val.ival = tpe;
	} else if (tpe == val->vtype ||
		   (ATOMstorage(tpe) == ATOMstorage(val->vtype) &&
		    ATOMstorage(tpe) == TYPE_str && /* extra compared to trivial_cast above */
		    (tpe != TYPE_str || BATatoms[val->vtype].atomToStr == BATatoms[TYPE_str].atomToStr) &&
		    ((val->vtype) != TYPE_str || BATatoms[tpe].atomFromStr == BATatoms[TYPE_str].atomFromStr))) {
		VALcopy(res, val);
		res->vtype = tpe;
	} else if (val->vtype == TYPE_str) {
		char *s = val->val.sval;

		if (ATOMextern(tpe)) {
			res->val.pval = NULL;
			res->len = 0;
			ATOMfromstr(tpe, &res->val.pval, &res->len, s);
		} else {
			ptr dst = (ptr) &res->val.ival;

			res->len = ATOMsize(ATOMtype(tpe));
			ATOMfromstr(tpe, &dst, &res->len, s);
		}
		res->vtype = tpe;
	} else if (tpe == TYPE_str) {
		if (ATOMcmp(val->vtype, VALptr(val), ATOMnilptr(val->vtype)) == 0) {
			/* nil */
			res->val.sval = ATOMnil(TYPE_str);
		} else if (val->vtype == TYPE_chr) {
			/* special case for chr -> str */
			if (val->val.cval[0] & 0x80) {
				/* non-ASCII chr */
#ifndef ASCII_CHR
				if (val->val.cval[0] != chr_nil) {
					char *s = res->val.sval = GDKmalloc(3);
					*s++ = 0xC0 | ((val->val.cval[0] >> 6) & 0x03);
					*s++ = 0x80 | (val->val.cval[0] & 0x3F);
					*s++ = 0;
					res->len = 3;
				} else
#endif
					res->val.sval = ATOMnil(TYPE_str);
			} else {
				/* (7-bit) ASCII */
				char *s = res->val.sval = GDKmalloc(2);
				*s++ = val->val.cval[0];
				*s++ = 0;
				res->len = 2;
			}
		} else {
			char *s = 0;

			res->len = 1 + VALformat(&s, val);
			res->val.sval = s;
		}
		res->vtype = TYPE_str;
	} else {
		*res = *val;
		if ((VALconvert(tpe, res) == ILLEGALVALUE) || TYPEerror(tpe, res->vtype)) {
			GDKerror("interpret_cast: should have a string parameter.\n");
			return -1;
		}
	}
	ATOMfix(res->vtype, VALptr(res));
	return 0;
}

int
interpret_batcast(str atom, int argc, ValPtr val, ValPtr res)
{
	BAT *bn, *b = BBP_cache(val->val.bval);
	int ok = 0, tpe = ATOMindex(atom);
	ptr v = NULL;

	(void) argc;

	if (trivial_cast(tpe, b->ttype)) {
		/* trivial conversion, e.g. int => int */
		int dense_bak = b->T->dense;

		b->T->dense = FALSE;
		bn = BATcopy(b, b->htype, tpe, FALSE);	/* we do not want smart oid->void conversion */
		if (bn == NULL)
			return -1;
		b->T->dense = dense_bak;
	} else {
		int reduce = 0;	/* reduce is set when conversion loses precision */

		bn = BATnew(b->htype, tpe, BATcount(b));
		if (bn == NULL)
			return -1;


		/* propagate properties */
		ALIGNsetH(bn, b);
		if (BATcount(b) < 2) {
			/* trivial case */
			bn->tsorted = GDK_SORTED;
		} else if (!(BATtordered(b) & 1) ||
			   b->ttype > TYPE_lng || tpe > TYPE_lng ||
			   b->ttype == TYPE_bit || tpe == TYPE_bit ||
			   b->ttype == TYPE_bat || tpe == TYPE_bat ||
			   b->ttype == TYPE_ptr || tpe == TYPE_ptr) {
			/* cases, where we
			 * (1) know that the result will not be sorted
			 * (2) cannot tell, whether the result will not be sorted
			 * (3) do not care, whether the result will not be sorted
			 */
			bn->tsorted = 0;
		} else if ((b->ttype != TYPE_void && b->ttype < tpe && (b->ttype < TYPE_flt || tpe >= TYPE_flt))
			   || (b->ttype == TYPE_lng && tpe >= TYPE_flt && tpe <= TYPE_dbl)
#if SIZEOF_OID == SIZEOF_INT
			   || (b->ttype == TYPE_void && tpe >= TYPE_int)
			   || (b->ttype == TYPE_oid  && tpe == TYPE_int) /* not covered by b->ttype < tpe */
#else
			   || (b->ttype == TYPE_void && tpe >= TYPE_oid)
			   || (b->ttype == TYPE_wrd  && tpe == TYPE_oid) /* not covered by b->ttype < tpe */
			   || (b->ttype == TYPE_lng  && tpe == TYPE_oid) /* not covered by b->ttype < tpe */
#endif
#if SIZEOF_WRD == SIZEOF_INT
			   || (b->ttype == TYPE_wrd  && tpe >= TYPE_int) /* not covered by b->ttype < tpe */
#else
			   || (b->ttype == TYPE_lng  && tpe == TYPE_wrd) /* not covered by b->ttype < tpe */
#endif
			   || (b->ttype <= TYPE_oid && tpe == TYPE_void)) {
			/* casts with target domain larger than source domain, i.e.,
			 * no underflows/overflows can occur, and hence sortedness is always maintained */
			/* (a bit dirty, since we silently assume that negative integers become "nil"
			 *  when casted to oid; but since oid_nil < 0@0, sortedness is not violated ...) */
			bn->tsorted = GDK_SORTED;
		} else if ((b->ttype == TYPE_void || b->ttype == TYPE_oid) /* && tpe < TYPE_int */ ) {
			/* oid's are >= 0, hence we only need to check for overflows */
			bit overflow = FALSE;
			oid max_val = *(oid *) BUNtail(b, BUNlast(b) - BUNsize(b));

			switch (tpe) {
@= interpret_batcast_overflow_case
			case TYPE_@1:
				overflow = (max_val > (oid)GDK_@1_max);
				break;
@c
			@:interpret_batcast_overflow_case(chr)@
			@:interpret_batcast_overflow_case(bte)@
			@:interpret_batcast_overflow_case(sht)@
#if SIZEOF_OID != SIZEOF_INT
			@:interpret_batcast_overflow_case(int)@
#endif
			default:
				assert(0);
			}
			bn->tsorted = (overflow ? 0 : GDK_SORTED);
		} else {
			/* all remaining cases require checking for both underflows & overflows */
			/* (source domain is always larger than target domain) */
			bit overflow = FALSE;

			assert(b->ttype != TYPE_void && tpe != TYPE_void);
			assert(b->ttype != TYPE_oid);
#if SIZEOF_OID != SIZEOF_INT
			assert(tpe != TYPE_oid);
#endif
			/* assert(b->ttype > tpe && ... ); */
@= interpret_batcast_source_switch
		switch (b->ttype) {
		@:interpret_batcast_source_case(sht,\
			@:interpret_batcast_target_case(sht,chr)@\
			@:interpret_batcast_target_case(sht,bte)@)@
		@:interpret_batcast_source_case(int,\
			@:interpret_batcast_target_case(int,chr)@\
			@:interpret_batcast_target_case(int,bte)@\
			@:interpret_batcast_target_case(int,sht)@)@
		@:interpret_batcast_source_case(wrd,\
			@:interpret_batcast_target_case(wrd,chr)@\
			@:interpret_batcast_target_case(wrd,bte)@\
			@:interpret_batcast_target_case(wrd,sht)@\
			@:interpret_batcast_target_case(wrd,int)@\
			@:interpret_batcast_target_case(wrd,oid)@)@
		@:interpret_batcast_source_case(lng,\
			@:interpret_batcast_target_case(lng,chr)@\
			@:interpret_batcast_target_case(lng,bte)@\
			@:interpret_batcast_target_case(lng,sht)@\
			@:interpret_batcast_target_case(lng,int)@\
			@:interpret_batcast_target_case(lng,wrd)@\
			@:interpret_batcast_target_case(lng,oid)@)@
		@:interpret_batcast_source_case(flt,\
			@:interpret_batcast_target_case(flt,chr)@\
			@:interpret_batcast_target_case(flt,bte)@\
			@:interpret_batcast_target_case(flt,sht)@\
			@:interpret_batcast_target_case(flt,int)@\
			@:interpret_batcast_target_case(flt,wrd)@\
			@:interpret_batcast_target_case(flt,oid)@\
			@:interpret_batcast_target_case(flt,lng)@)@
		@:interpret_batcast_source_case(dbl,\
			@:interpret_batcast_target_case(dbl,chr)@\
			@:interpret_batcast_target_case(dbl,bte)@\
			@:interpret_batcast_target_case(dbl,sht)@\
			@:interpret_batcast_target_case(dbl,int)@\
			@:interpret_batcast_target_case(dbl,wrd)@\
			@:interpret_batcast_target_case(dbl,oid)@\
			@:interpret_batcast_target_case(dbl,lng)@\
			@:interpret_batcast_target_case(dbl,flt)@)@
		default:
			assert(0);
		}
@= interpret_batcast_source_case
		case TYPE_@1: {
			@1 min_val = *(@1*)BUNtail(b,BUNfirst(b));
			@1 max_val = *(@1*)BUNtail(b,BUNlast(b)-BUNsize(b));
			if ( min_val == @1_nil ) {
				overflow = TRUE;
			} else {
				switch (tpe) {
				@2
				default:
					assert(0);
				}
			}
			break;
		}
@= interpret_batcast_target_case
		case TYPE_@2: {
			overflow |= (min_val < (@1)GDK_@2_min);
			overflow |= (max_val > (@1)GDK_@2_max);
			break;
		}
@c
		@:interpret_batcast_source_switch@
			bn->tsorted = (overflow ? 0 : GDK_SORTED);
		}


		if (BATcount(b)) {
			int len = ATOMsize(ATOMtype(BATttype(b)));
			BUN q = BUNlast(b);
			BUN p = BUNfirst(b);
			BUN r = BUNfirst(bn);
			int xx = BUNsize(b);
			int yy = BUNsize(bn);

			if (tpe == TYPE_oid && b->ttype == TYPE_void) {
				/* void => oid materialization is a special case */
				oid curid = b->tseqbase;

				BATloopFast(b, p, q, xx) {
					bunfastins_nocheck(bn, r, BUNhead(b, p), &curid, yy);
					r += yy;
					if (curid != oid_nil)
						curid++;
				}
				ALIGNsetT(bn, b);
			} else if (tpe == TYPE_str || b->ttype == TYPE_str) {
				/* from-string or to-string conversion */
				v = GDKmalloc(len);
				if (tpe == TYPE_chr) {
					/* str => chr: just get first character */
					chr *s, c;

					BATloopFast(b, p, q, xx) {
						s = (chr *) BUNtvar(b, p);
						if (*s & 0x80) {
#ifndef ASCII_CHR
							/* check whether the first UTF-8 char fits in an 8-bit value */
							if ((*s & 0xFC) == 0xC0 && (s[1] & 0xC0) == 0x80)
								c = ((s[0] & 0x03) << 6) | (s[1] & 0x3F);
							else
#endif
								c = chr_nil;
						} else
							c = *s;
						bunfastins_nocheck(bn, r, BUNhead(b, p), &c, yy);
						r += yy;
					}
					reduce = 1; /* first character might be identical for several strings */
				} else if (tpe != TYPE_str) {
					/* str => any: use fromstr ADT routine */
					int (*fromstr) (str, int *, ptr *) = BATatoms[tpe].atomFromStr;

					BATloopFast(b, p, q, xx) {
						/* nil str value will produce a nil atom value */
						(*fromstr) (BUNtvar(b, p), &len, &v);
						bunfastins_nocheck(bn, r, BUNhead(b, p), v, yy);
						r += yy;
					}
					reduce = 1; /* strings might only differ by (ignored) whitespace */
				} else if (b->ttype == TYPE_chr) {
					/* chr => str: do this efficiently */
					chr s[3];

					s[1] = 0;
					s[2] = 0;
					/*reduce = 0;*/ /* be optimistic... */
					BATloopFast(b, p, q, xx) {
						/* also works well on NILs */
						s[0] = *(chr *) BUNtloc(b, p);
						s[1] = 0;
						if ((*s & 0x80) && *s != chr_nil) {
							/* non-ASCII chr */
#ifdef ASCII_CHR
							s[0] = chr_nil; /* turn into nil */
							reduce = 1; /* NILs destroy keyness */
#else
							s[1] = 0x80 | (s[0] & 0x3F);
							s[0] = 0xC0 | ((s[0] >> 6) & 0x03);
#endif
						}
						bunfastins_nocheck(bn, r, BUNhead(b, p), s, yy);
						r += yy;
					}
				} else {
					/* any => str: use tostr ADT routine */
					int (*tostr) (str *, int *, ptr) = BATatoms[b->ttype].atomToStr;
					int (*cmp) (ptr, ptr) = BATatoms[b->ttype].atomCmp;
					ptr nilptr = ATOMnilptr(b->ttype);

					/*reduce = 0;*/ /* be optimistic... */
					BATloopFast(b, p, q, xx) {
						ptr t = BUNtail(b, p);

						if ((*cmp) (t, nilptr)) {
							(*tostr) ((str *) (ptr) &v, &len, t);
							bunfastins_nocheck(bn, r, BUNhead(b, p), v, yy);
							r += yy;
						} else {
							bunfastins_nocheck(bn, r, BUNhead(b, p), str_nil, yy);
							r += yy;
							reduce = 1; /* NILs destroy keyness */
						}
					}
				}
			} else {
				ptr s;

				/* misc conversions by VALconvert are expensive */
				res->vtype = BATttype(b);
				if (ATOMextern(res->vtype)) {
					res->val.pval = BUNtail(b, p);
					reduce = 1;	/* extern atoms are suspicious */
				} else {
					memcpy(&res->val.ival, BUNtail(b, p), len);
					reduce = 0;
				}
				/* reduce is set when conversion loses precision */
				if (ATOMsize(ATOMtype(tpe)) <= ATOMsize(ATOMtype(res->vtype))) {
					reduce = 1;
				} else if (b->ttype == TYPE_flt && tpe == TYPE_lng) {
					reduce = 1;	/* rounding off */
				}
				/* use a version of VALconvert that does not free any data, it wasn't allocated */
				s = VALconvert2(tpe, res, res);	/* try once if this works */
				if (s == ILLEGALVALUE || TYPEerror(tpe, res->vtype)) {
					GDKerror("interpret_batcast: impossible to convert '%s' into '%s'.\n", ATOMname(b->ttype), ATOMname(tpe));
					goto bunins_failed;
				}
				bunfastins_nocheck(bn, r, BUNhead(b, p), s, yy);
				r += yy;
				if (ATOMextern(BATttype(b))) {
					for (p += xx; p < q; p += xx) {
						res->vtype = BATttype(b);
						res->val.pval = BUNtail(b, p);
						s = VALconvert2(tpe, res, res);
						if (s == ILLEGALVALUE) {
							GDKerror("interpret_batcast: impossible to convert '%s' into '%s'.\n", ATOMname(b->ttype), ATOMname(tpe));
							goto bunins_failed;
						}
						bunfastins_nocheck(bn, r, BUNhead(b, p), s, yy);
						r += yy;
					}
				} else {
					for (p += xx; p < q; p += xx) {
						res->vtype = BATttype(b);
						memcpy(&res->val.ival, BUNtail(b, p), len);
						s = VALconvert2(tpe, res, res);
						if (s == ILLEGALVALUE) {
							GDKerror("interpret_batcast: impossible to convert '%s' into '%s'.\n", ATOMname(b->ttype), ATOMname(tpe));
							goto bunins_failed;
						}
						bunfastins_nocheck(bn, r, BUNhead(b, p), s, yy);
						r += yy;
					}
				}
			}	/* different kind of conversions */
		}
		if (BATcount(bn) < 2) {
			BATkey(BATmirror(bn), TRUE);
		} else if ((!bn->tkey) && (!reduce)) {
			BATkey(BATmirror(bn), b->tkey);
		}
		BATsetaccess(bn, BAT_READ);
	}
	ok = 1;
      bunins_failed:
	if (v)
		GDKfree(v);
	if (!ok) {
		BBPreclaim(bn);
		return -1;
	}
	res->vtype = TYPE_bat;
	res->val.bval = bn->batCacheid;
	res->len = 0;
	BBPincref(bn->batCacheid, TRUE);
	BBPunfix(bn->batCacheid);
	return 0;
}

@- Variable Assignment Interpretation
@c
int
interpret_assignment(int stk, YYSTREE lt, ValPtr res)
{
	int i, s = stk;
	ValRecord oldvalue, *value;
	Variable act = 0;

	if (arg(lt, 0)->token == TOK_IDENT) {
		str nme = arg(lt, 0)->yyval.val.sval;

		for (i = arg(lt, 0)->yyval.len; i > 0; i--) {
			if (s >= 0) {
				s = monet_cntxt[s].outer;
			} else {
				GDKerror("interpret_assignment: illegal context.\n");
				return -1;
			}
		}
		if ((act = VARfind(&s, nme)) == 0) {
			GDKerror("interpret_assignment: unknown variable '%s'\n", nme);
			return -1;
		}
		if (act->constant) {
			GDKerror("interpret_assignment: cannot assign to constant '%s'\n", nme);
			return -1;
		}
@-
If the variable is in a stable scope, we modify the reference
into a TEMPLATE, to avoid resolving it again.
@c
		arg(lt, 0)->token = TOK_TEMPLATE;
		if (!arg(lt, 0)->iscopy) GDKfree(arg(lt, 0)->yyval.val.pval);
		arg(lt, 0)->yyval.vtype = TYPE_ptr;
		arg(lt, 0)->yyval.val.pval = &act->binding;
		value = &act->binding;
	} else {
		value = arg(lt, 0)->yyval.val.pval;
	}
@c
@-
Evaluate the expression, and assign the value. Increment refcnt,
if it is a bat-expression.
@c
	i = interpret(stk, arg(lt, 1), res);
@-
Variables with frozen type may lead to type errors
@c
	if (act && act->frozen && value->vtype != res->vtype) {
		GDKerror("interpret_assignment: cannot change type of frozen variable '%s'\n", act->name);
		return -1;
	}
	if (i >= 0) {
		oldvalue = *value;
		VALcopy(value, res);
		ATOMfix(res->vtype, VALptr(res));
@-
Cleanup the old value.
@c
		ATOMunfix(oldvalue.vtype, VALptr(&oldvalue));
		if (ATOMextern(oldvalue.vtype)) {
			GDKfree(oldvalue.val.pval);
		}
	} else {
		res->vtype = TYPE_void;
        }
	return i;
}


@}

@- Sequential Block Interpretation
Sequential blocks can be handled directly -- no need to go to the queue.
@c
int
interpret_seqblock(int stk, YYSTREE lt, ValPtr res, int scope)
{
	unsigned i;
	int r = 0;

	if (scope) {
		if (!lt->old_cntxt) {
			stk = CNTXTnew(stk);
			if (stk <= 0)
				return -1;
			lt->old_cntxt = stk;
		} else
			stk = lt->old_cntxt;
		CNTXTuse(stk);
	}
	for (; lt; lt = YYOVERFLOW(lt)) {
		for (i = 0; i < lt->cnt; i++)
			if (lt->yysons[i]) {
				r = interpret(stk, lt->yysons[i], res);
				CLEANUP(lt->yysons[i]);
				if (r < 0)
					goto xit;
			}
	}
      xit:
	if (scope) {
		CNTXTclear(stk);
		if (monet_cntxt[stk].reuse < 0)
			CNTXTfree1(stk);
	}
	if (r >= 0) {
		res->vtype = TYPE_void;
		res->val.oval = void_nil;
	}
	return r;
}

@}
@- Parallel Block Interpretation
The statements in a parallel block are synchronized by the PAREND statement,
i.e. a no-op, which directly follows the parallel block.
The sole action is to delete the context for the parallel block.
The parallel statements are immediately taken into execution.
@{
@c
int
interpret_parblock(int stk, YYSTREE lt, int scope)
{
	int reuse = monet_cntxt[stk].reuse;
	int tid = THRgettid();
	Thread t = THRget(tid);
	YYSTREE bt;
	Request barrier;
	Request current;
	Request p = 0;
	Request q = 0;
	Client c;
	unsigned i;

	PARDEBUG THRprintf(GDKerr, "parallel block\n");

	CNTXTclient(stk, &c);

	if (scope) {
		if (!lt->old_cntxt) {
			stk = CNTXTnew(stk);
			if (stk <= 0)
				return -1;
			lt->old_cntxt = stk;
			if (reuse < 0) {
				monet_cntxt[stk].reuse = stk;
			}
		} else
			stk = lt->old_cntxt;
		CNTXTuse(stk);
	}
	bt = Myynode(TOK_PAREND, stk);
	barrier = newRequest(stk, bt, 0);
@-
The parallel block is translated into a sequence of requests,
which have no interdependencies, and can be scheduled
immediately.
@c
	for (; lt; lt = YYOVERFLOW(lt)) {
		for (i = 0; i < lt->cnt; i++) {
			barrier->ev_status++;
			current = newRequest(stk, lt->yysons[i], 0);
			current->ev_wakeup = barrier;
			if (qm_profile) {
				char msg[40];

				sprintf(msg, "[%u]", i);
				QMmessage(current, msg);
			}
			if (p == 0) {
				q = p = current;
			} else {
				q->ev_next = current;
				current->ev_prev = q;
				q = current;
			}
		}
	}
	q->ev_next = barrier;
	barrier->ev_prev = q;
	barrier->ev_process = tid;
@-
Insert the string of independent requests in the execution queue.
Use the first request for immediate execution.
@c
	putRequest(p);
	doRequest(t, barrier);
	Myyfree(bt);
	if (scope) {
		CNTXTclear(stk);
		if (reuse < 0) {
			monet_cntxt[stk].reuse = reuse;
			CNTXTfree2(stk, c);
		}
	}
	return 0;
}

@}

@- Iterator Interpretation.

Iterators are special Monet commands, that repeatedly evaluate a
syntax-tree, once at a time for each selected BUN out of some BAT. The
selection of BUNs is made by the user-implemented iteration-command.
This user-implemented iteration-command must contain a call in its
inner loop to the function @%ITERATE(head, tail, handle)@, which
triggers the evaluation of the syntax tree. This design allows an
efficient implementation of the user-iterator, but of course
evaluating the syntax tree still incurs normal interpretation-overhead.

@%interpret_iterator()@ prepares the syntax tree for repeated evaluation, by
making a copy of it in which the parameters are substituted by
pointers to value records (the syntax-tree can receive two parameters
named "$h" and "$t", corresponding to a value-record for a head, resp.
tail). On every iteration, the head- and tail-values of the current
BUN are copied into those value-records by the @:ITERATE()@ routine,
and subsequently the syntax-tree is interpreted.

Things are complicated a bit further because iterators can be
specified to evaluate tuples in parallel. So, actually, a sequence of
syntax trees and their corresponding parameter records (for head,tail
substitution) are created.
@= expand
@:tuple_interpret(@1,@2,f,chval)@
@:tuple_interpret(@1,@2,f,btval)@
@:tuple_interpret(@1,@2,f,shval)@
@:tuple_interpret(@1,@2,f,ival)@
@:tuple_interpret(@1,@2,f,wval)@
@:tuple_interpret(@1,@2,f,dval)@
@:tuple_interpret(@1,@2,v,pval)@
@:tuple_interpret(@1,@2,f,pval)@
@:par_collect(@1,@2,f,chval)@
@:par_collect(@1,@2,f,btval)@
@:par_collect(@1,@2,f,shval)@
@:par_collect(@1,@2,f,ival)@
@:par_collect(@1,@2,f,wval)@
@:par_collect(@1,@2,f,dval)@
@:par_collect(@1,@2,v,pval)@
@:par_collect(@1,@2,f,pval)@
@c
#define atmlen(h,f)	(h).len = (*(f))((h).val.pval)
#define len_vv(p,x)	atmlen(p[0],x->h_len); atmlen(p[1],x->t_len)
#define len_vf(p,x)	atmlen(p[0],x->h_len)
#define len_fv(p,x)	atmlen(p[1],x->t_len)
#define len_ff(p,x)
#define assign_chval(p,v)	p.cval[0] = *(chr*) v;
#define assign_btval(p,v)	p.btval = *(bte*) v;
#define assign_shval(p,v)	p.shval = *(sht*) v;
#define assign_ival(p,v)	p.ival = *(int*) v;
#define assign_wval(p,v)	p.wval = *(wrd*) v;
#define assign_dval(p,v)	p.dval = *(dbl*) v;
#define assign_pval(p,v)	p.pval = v;

@:expand(f,chval)@
@:expand(f,btval)@
@:expand(f,shval)@
@:expand(f,ival)@
@:expand(f,wval)@
@:expand(f,dval)@
@:expand(v,pval)@
@:expand(f,pval)@


static void
iterator_maketrees(Iteration handle, YYSTREE body, int parallel, int ht, int tt)
{
	ValPtr p;
	int i;

	(void) ht;
	(void) tt;

	if (handle->params) {
		GDKfree(handle->params);
	}
	handle->params = p = (ValPtr) GDKmalloc(sizeof(ValRecord) * 2 * parallel);

	if (parallel > 1) {
		if (handle->parmax <= 1) {
			YYSTREE t = handle->tree;

			handle->tree = Myynode(TOK_PARBLOCK, 0);
			if (t)
				Myyexpand(handle->tree, t);
		}
		for (i = handle->parmax; i < parallel; i++, p += 2) {
			Myyexpand(handle->tree, Myysubstitute_iter(body, 2, p - 1));
		}
	} else if (handle->tree == 0) {
		handle->tree = Myysubstitute_iter(body, 2, p - 1);
	}
}

ptr
interpret_fcn(int ht, int tt, int parallel)
{
	ptr addr;

	switch (ATOMstorage(ht)) {
	case TYPE_chr:
		@:switch_ht(fchval)@
		break;
	case TYPE_bte:
		@:switch_ht(fbtval)@
		break;
	case TYPE_sht:
		@:switch_ht(fshval)@
		break;
#if SIZEOF_OID == SIZEOF_INT
	case TYPE_void:
#endif
	case TYPE_int:
	case TYPE_flt:
		@:switch_ht(fival)@
		break;
#if SIZEOF_OID == SIZEOF_LNG
	case TYPE_void:
#endif
	case TYPE_lng:
	case TYPE_dbl:
		@:switch_ht(fdval)@
		break;
	default:
		if (ATOMvarsized(ht))
			@:switch_ht(vpval)@
		else
			@:switch_ht(fpval)@
	}
@= switch_ht
	switch (ATOMstorage(tt)) {
	case TYPE_chr:
		@:switch_tt(@1,fchval)@
		break;
	case TYPE_bte:
		@:switch_tt(@1,fbtval)@
		break;
	case TYPE_sht:
		@:switch_tt(@1,fshval)@
		break;
#if SIZEOF_OID == SIZEOF_INT
	case TYPE_void:
#endif
	case TYPE_int:
	case TYPE_flt:
		@:switch_tt(@1,fival)@
		break;
#if SIZEOF_OID == SIZEOF_LNG
	case TYPE_void:
#endif
	case TYPE_lng:
	case TYPE_dbl:
		@:switch_tt(@1,fdval)@
		break;
	default:
		if (ATOMvarsized(tt))
			@:switch_tt(@1,vpval)@
	        else
			@:switch_tt(@1,fpval)@
	}
@= switch_tt
	addr = (ptr) ((parallel)?par_collect_@1_@2:tuple_interpret_@1_@2);
@c
	return addr;
}

int
interpret_iterator(Cntxt stk, YYSTREE lt, int parallel)
{
	int reuse = monet_cntxt[stk].reuse;
	ValRecord argv[MAXPARAMS + 2];
	ITrecord *handle;
	YYSTREE params = lt->yysons[1];
	YYSTREE body = lt->yysons[0];
	int argc, i, ht, tt, (*cmd) (int, ValRecord *);

	/* Deeper contexts get reused across iterations.
	 */
	if (reuse < 0) {
		monet_cntxt[stk].reuse = stk;
	}

	/* Evaluate the command line parameters.
	 */
	argc = interpret_params(stk, params, argv + 1, "batloop");
	if (!interpret_params_pin(argc, argv + 1, "batloop"))
		return -1;
	argv[1] = argv[2];
	if (argc <= 1 || argv[1].vtype != TYPE_bat) {
		GDKerror("interpret_iterator: iterator should work on a BAT.\n");
		RETURN(-1);
	}
	ht = ATOMtype(BAThtype(BBP_cache(argv[1].val.bval)));
	tt = ATOMtype(BATttype(BBP_cache(argv[1].val.bval)));
	argv[2].vtype = TYPE_ptr;

	if (lt->token == TOK_ITERATOR) {
		/* Create the first iteration handle.
		 */
		char *name = lt->yyval.val.sval;

		/* Try all iterators by that name.  */
		if (!(cmd = (int (*)(int, ValRecord *)) TBL_iterator(stk, name, argc + 1, argv))) {
			char *signatures = (char *) alloca(8192);

			if (name)
				TBL_printsigs(signatures, stk, name);
			monet_sigerror("iterator", name ? name : "name unknown", name ? signatures : "", argc + 1, argv);
			RETURN(-1);
		}
		body = Myyexpand(Myynode(TOK_SEQ, 0), body); /* TOK_SEQ ensures we can safely use par_retval */
		if (!lt->iscopy) GDKfree(lt->yyval.val.sval);
		lt->token = TOK_ITCOMPILED;
		lt->yyval.val.pval = (ptr) cmd;
		lt->yyval.vtype = TYPE_void;
		lt->yysons[3] = Myynode(0, 0);

		/* Fill the iteration handle.
		 */
		handle = (Iteration) GDKmalloc(sizeof(ITrecord));
		handle->stk = stk;
		handle->params = 0;
		handle->tree = 0;
		handle->parcnt = 0;
		handle->parmax = handle->parcap = 0;
	} else {
		handle = (Iteration) lt->yysons[1]->yyval.val.pval;
		cmd = (int (*)(int, ValRecord *)) lt->yyval.val.pval;
	}

	/* Fill in handle according to current circumstances
	 */

	if (parallel > handle->parcap) {
		/* Create more trees
		 */
		iterator_maketrees(handle, body, parallel, ht, tt);

		/* Rearrange the tree: we make one structure of everything,
		 * and hang our created spaces into it as TYPE_str values,
		 * such that they will be destroyed later.
		 */
		lt->cnt = 5;
		lt->yysons[4] = handle->tree;
		lt->yysons[3]->yyval.vtype = TYPE_str;
		lt->yysons[1]->yyval.vtype = TYPE_str;
		lt->yysons[1]->yyval.val.pval = (ptr) handle;
		lt->yysons[3]->yyval.val.pval = (ptr) handle->params;
		handle->parcap = parallel;
	}
	handle->tuple_interpret = (int (*)(ptr, ptr, ptr)) interpret_fcn(ht, tt, parallel > 1);
	handle->parmax = parallel;
	handle->status = 0;
	handle->h_len = BATatoms[ht].atomLen;
	handle->t_len = BATatoms[tt].atomLen;
	for (i = 0; i < parallel; i++) {
		handle->params[2 * i].vtype = ht;
		handle->params[2 * i].len = ATOMsize(ht);
		handle->params[2 * i + 1].vtype = tt;
		handle->params[2 * i + 1].len = ATOMsize(tt);
	}

	/* Call the iterator.
	 */
	argv[2].val.pval = handle;
	if ((i = (*cmd) (argc + 1, argv)) >= 0) {
		i = handle->status;
	}

	/* Flush rest of parallel jobs.
	 */
	if (parallel > 1) {
		YYSTREE t;
		int i;

		/* limit tree size to handle->parcnt, by 'hiding' child nodes, hacking the yystree->cnt field */
		for (t = handle->tree, i = handle->parcnt; t; t = YYOVERFLOW(t), i -= YYMAXSONS) {
			t->cnt = MAX(0, MIN(YYMAXSONS, i));
		}

		/* execute last block with less (i.e. parcnt) statements in it */
		@:par_interpret(handle)@

		/* undo the above operation: unhide child nodes, as this tree will be reused, e.g. if in a while block */
		for (t = handle->tree, i = handle->parmax; t; t = YYOVERFLOW(t), i -= YYMAXSONS) {
			t->cnt = MAX(0, MIN(YYMAXSONS, i));
		}

		i = handle->status;
	}

	/* clean up temporary space/bats, generated by parameter evaluation
	 */
      xit:
	argv[2] = argv[1];
	argc = ABS(argc);
	interpret_params_unpin(ABS(argc), argv + 1, "batloop");
	CLEANUP(lt->yysons[1]);
	if (reuse < 0) {
		monet_cntxt[stk].reuse = reuse;
		CNTXTfree1(stk);
	}
	return i;
}


@- Sequential Iteration
Directly execute the body with head and tail substituted in.

@= tuple_interpret
int
tuple_interpret_@1@2_@3@4(ptr head, ptr tail, Iteration handle)
{
	ValRecord res;

	assign_@2(handle->params[0].val, head);
	assign_@4(handle->params[1].val, tail);
	len_@1@3(handle->params,handle);
	handle->status = interpret(handle->stk, handle->tree, &res);
	CATCHRET(handle->stk,handle->tree,(&res),handle->status);
	CLEANUP(handle->tree);
	return handle->status;
}
@

@- Parallel Iteration
Performing interpretation the iterator-body on a number of tuples
in parallel is a way of expressing data-parallelism. We prepare a
s = maximum number of M iteration bodies, and do M iterations to
obtain the first M tuples. They are then put into a parallel block,
and scheduled for execution. This step is repeated until all tuples
have been interpreted.
The M is user-defined as in: <bat-expr>@[M]<iterator><stmt>
@c
@= par_collect
int
par_collect_@1@2_@3@4(ptr head, ptr tail, Iteration handle)
{
	ValPtr params = handle->params+handle->parcnt+handle->parcnt;

	assign_@2(params[0].val, head);
	assign_@4(params[1].val, tail);
	len_@1@3(params,handle);
	if (++handle->parcnt >= handle->parmax) {
		@:par_interpret(handle)@
		handle->parcnt = 0;
	}
	return handle->status;
}
@= par_interpret
	if (@1->parcnt > 0) {
		YYSTREE t;
		unsigned i;

		for (t = @1->tree; t; t = YYOVERFLOW(t))
			for (i = 0; i < t->cnt; i++)
				t->yysons[i]->par_retval = 0;

		interpret_parblock(@1->stk, @1->tree, 0);

		@1->status = 0;
		for (t = @1->tree; t; t = YYOVERFLOW(t))
			for (i = 0; i < t->cnt; i++)
				if (t->yysons[i]->par_retval < 0)
					@1->status = t->yysons[i]->par_retval;
	}


@+ Profiler
The remainder consists of utilities for the dynamic profiler
The first part contains the administration needed for
filtering events. The number of filters is explicitly limited.
All events can be filtered by calling setProfilerFilter("*","*");
It also removes any previously defined filter patterns.
Pattern matching is limited to finding the string in the prefix
of the call.
@c
#ifdef HAVE_TIMES

#define MAXFILTER 16
static str filter[MAXFILTER][2];
static int filterlength[MAXFILTER][2];
static int filtertop = 0;

int
setProfilerFilter(str left, str right)
{
	int i;

	/*fprintf(stderr,"prepare filter %s %s\n",left,right); */
	if (filtertop == MAXFILTER) {
		GDKerror("setProfilerFilter: out of profile filter space.\n");
		return GDK_FAIL;
	}
	monet_set_lock(profilerLock, "startProfiler");
	if (strcmp(left, "*") == 0 && strcmp(right, "*") == 0) {
		for (i = 0; i < filtertop; i++) {
			if (filter[i][0])
				GDKfree(filter[i][0]);
			if (filter[i][1])
				GDKfree(filter[i][1]);
			filter[i][0] = NULL;
			filter[i][1] = NULL;
			filterlength[i][0] = 0;
			filterlength[i][1] = 0;
		}
		filtertop = 0;
		monet_unset_lock(profilerLock, "startProfiler");
		return GDK_SUCCEED;
	}
	filter[filtertop][0] = GDKstrdup(left);
	if (strcmp(left, "*") == 0)
		filterlength[filtertop][0] = 0;	/* quick test */
	else
		filterlength[filtertop][0] = strlen(left);
	filter[filtertop][1] = GDKstrdup(right);
	if (strcmp(right, "*") == 0)
		filterlength[filtertop][1] = 0;	/* quick test */
	else
		filterlength[filtertop][1] = strlen(right);
	filtertop++;
	monet_unset_lock(profilerLock, "startProfiler");
	return GDK_SUCCEED;
}
static int
tstpattern(str pattern, int len, str callee)
{
	char *s;

	s = strchr(callee, *pattern);
	if (s == 0)
		return 0;
	return strncmp(pattern, s, len) == 0;
}
static int
tstFilter(str caller, str callee)
{
	int i, cnt = 0;

	if (strncmp(callee, "unknown", 7) == 0)
		return 0;
	if (filtertop == 0)
		return 1;
	/*for(i=0;i<filtertop;i++){
	   fprintf(stderr,"filter:%s %s\n", filter[i][0],filter[i][1]);
	   } */
	for (i = 0; i < filtertop; i++) {
		cnt = 0;
		if (filterlength[i][0] == 0)
			cnt++;
		else
			cnt += tstpattern(filter[i][0], filterlength[i][0], caller);
		if (cnt == 0)
			continue;
		if (filterlength[i][1] == 0)
			cnt++;
		else
			cnt += tstpattern(filter[i][1], filterlength[i][1], callee);
		if (cnt >= 2)
			return 1;
	}
	return 0;
}

@-
As a soon as an error occurs on the event stream we should abandon
any performance profiling.
@c

#define log(X,Y) if(eventstream && (stream_errnr(eventstream) \
		||  stream_printf(eventstream,X,Y)<0)){ \
		eventstream=0;\
		monet_unset_lock(profilerLock, "onlineProfilerEvent"); return;}
#define log0(X) if(eventstream && (stream_errnr(eventstream) \
		|| stream_printf(eventstream,X)<0) ){ \
		eventstream=0;\
		monet_unset_lock(profilerLock, "onlineProfilerEvent"); return;}
#define log2(X,Y,Z) if(eventstream && (stream_errnr(eventstream) \
		|| stream_printf(eventstream,X,Y,Z)<0) ){ \
		eventstream=0;\
		monet_unset_lock(profilerLock, "onlineProfilerEvent"); return;}
#define flushLog() if(eventstream && stream_errnr(eventstream)){eventstream=0;\
	monet_unset_lock(profilerLock, "onlineProfilerEvent"); return;} \
	else stream_flush(eventstream); \
	if(eventstream && stream_errnr(eventstream)){eventstream=0;\
	monet_unset_lock(profilerLock, "onlineProfilerEvent"); return;}

void
onlineProfilerHeader(void)
{
	/* the column header name info */
	log0("# ");
	log0("caller,\t");
	log0("callee,\t");
	log0("ticks,\t");
	log0("clock,\t");
	log0("stmt,\t");
	log0("utime,\t");
	log0("cutime,\t");
	log0("stime,\t");
	log0("cstime,\t");
	log0("maxrss,\t");
	log0("arena,\t");
	log0("ordblks,\t");
	log0("smblks,\t");
	log0("hblkhd,\t");
	log0("hblks,\t");
	log0("fsmblks,\t");
	log0("uordblks,\t");
	log0("page reclaim,\t");
	log0("page faults,\t");
	log0("swaps,\t");
	log0("block reads,\t");
	log0("block writes,\t");
	log0("context switch,\t");
	log0("involunarty switch,\t");
	log0("event\t# name\n");
	/* the column header type info */
	log0("# ");
	log0("str,\t");
	log0("str,\t");
	log0("int,\t");
	log0("int,\t");
	log0("str,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int,\t");
	log0("int\t# type\n");
	flushLog();
}
static void
quote(char *buf, int lim)
{
	char *tmp = GDKstrdup(buf);
	char *s = buf, *t = tmp, *sl = buf + lim - 1;

	while (*t && s < sl) {
		switch (*t) {
		case '"':
			*s++ = '\\';
		default:
			*s++ = *t++;
		}
	}
	*s = 0;
	GDKfree(tmp);
}

void
onlineProfilerEvent(char *caller, lng clk, lng ticks, struct tms *timer, YYSTREE lt)
{
	static struct mallinfo prevMalloc;
	static struct rusage prevUsage;
	static int eventcounter;
	struct tms newTms;
	struct mallinfo infoMalloc;
	struct rusage infoUsage;
	char namebuf[1024];

	if (profilemode > 1) {
		int one = 1;

		namebuf[0] = 0;
		yydeparseFunction(monet_clients, lt, namebuf, namebuf + 1024);
		if (tstFilter(caller, namebuf)) {
			BUN cnt = BUNfnd(profilerCount, namebuf);

			if (cnt == NULL)
				BUNins(profilerCount, namebuf, &one, FALSE);
			else {
				cnt = BUNtail(profilerCount, cnt);
				*(int *) cnt = *(int *) cnt + 1;
				profilerCount->batDirty = TRUE;
			}
			cnt = BUNfnd(profilerTicks, namebuf);
			if (cnt == NULL) {
				lng zero = 0;

				BUNins(profilerTicks, namebuf, &zero, FALSE);
			} else {
				lng *tik;

				tik = (lng *) BUNtail(profilerTicks, cnt);
				*tik = *tik + ticks;
				profilerTicks->batDirty = TRUE;
			}
		}
		return;
	}
	if (eventstream == 0)
		return;
	if (delayswitch > 0) {
		/* first call to profiled */
		delayswitch--;
		return;
	}
	if (delayswitch == 0) {
		delayswitch = -1;
	}
	monet_set_lock(profilerLock, "onlineProfilerEvent");
	if (showheader > 0) {
		onlineProfilerHeader();
		showheader--;
	}
	if (eventstream == NULL || stream_errnr(eventstream)) {
		monet_unset_lock(profilerLock, "onlineProfilerEvent");
		eventstream = NULL;
		return;
	}
	/* generate actual call statement */
	namebuf[0] = 0;
	yydeparseFunction(monet_clients, lt, namebuf, namebuf + 1024);
	if (!tstFilter(caller, namebuf)) {
		monet_unset_lock(profilerLock, "onlineProfilerEvent");
		return;
	}

	times(&newTms);
	infoMalloc = MT_mallinfo();
	getrusage(RUSAGE_SELF, &infoUsage);

	/* steal a lock for re-use */
	/* make basic profile event tuple  */
	log0("[ ");

	/* get context of call */
	log("%s,\t", caller)
	    quote(namebuf, 256);
	log("\"%s\",\t", namebuf);

	log(LLFMT ",\t", ticks);
	log(LLFMT ",\t", clk);

	namebuf[0] = 0;
	yydeparseCall(monet_clients, lt, namebuf, namebuf + 256);
	quote(namebuf, 256);
	log("\"%s\",\t", namebuf);

	log(LLFMT ",\t", (lng) (newTms.tms_utime - timer->tms_utime));
	log(LLFMT ",\t", (lng) (newTms.tms_cutime - timer->tms_cutime));
	log(LLFMT ",\t", (lng) (newTms.tms_stime - timer->tms_stime));
	log(LLFMT ",\t", (lng) (newTms.tms_cstime - timer->tms_cstime));

	log(LLFMT ",\t", (lng) (infoUsage.ru_maxrss));
	log(LLFMT ",\t", (lng) (infoMalloc.arena - prevMalloc.arena));
	log(LLFMT ",\t", (lng) (infoMalloc.ordblks - prevMalloc.ordblks));
	log(LLFMT ",\t", (lng) (infoMalloc.smblks - prevMalloc.smblks));
	log(LLFMT ",\t", (lng) (infoMalloc.hblkhd - prevMalloc.hblkhd));
	log(LLFMT ",\t", (lng) (infoMalloc.hblks - prevMalloc.hblks));
	log(LLFMT ",\t", (lng) (infoMalloc.fsmblks - prevMalloc.fsmblks));
	log(LLFMT ",\t", (lng) (infoMalloc.uordblks - prevMalloc.uordblks));
	prevMalloc = infoMalloc;

	log(LLFMT ",\t", (lng) (infoUsage.ru_minflt - prevUsage.ru_minflt));
	log(LLFMT ",\t", (lng) (infoUsage.ru_majflt - prevUsage.ru_majflt));
	log(LLFMT ",\t", (lng) (infoUsage.ru_nswap - prevUsage.ru_nswap));
	log(LLFMT ",\t", (lng) (infoUsage.ru_inblock - prevUsage.ru_inblock));
	log(LLFMT ",\t", (lng) (infoUsage.ru_oublock - prevUsage.ru_oublock));
	log(LLFMT ",\t", (lng) (infoUsage.ru_nvcsw - prevUsage.ru_nvcsw));
	log(LLFMT ",\t", (lng) (infoUsage.ru_nivcsw - prevUsage.ru_nivcsw));
	prevUsage = infoUsage;

	log(LLFMT " ]\n", (lng) (eventcounter));
	eventcounter++;
	if (eventstream && stream_flush(eventstream))
		eventstream = 0;
	monet_unset_lock(profilerLock, "onlineProfilerEvent");
}

#else

int
setProfilerFilter(str left, str right)
{
	(void) left;
	(void) right;
	GDKerror("setProfilerFilter: no profiler support.\n");
	return GDK_FAIL;
}

#endif /* HAVE_TIMES */
