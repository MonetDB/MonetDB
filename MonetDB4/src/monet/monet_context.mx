@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f monet_context
@a M. L. Kersten, P. Boncz

@* Monet variables
The Monet name space is a multi-level hierarchy of contexts. Each
context contains variables. Variables are sought from the deepest
level upwards.s The root conext is formed by the context created at
server start, i.e. the administrator console (0).  The next layer is
bound to a client session, the lower layers correspond to the stack
of MIL blocks in execution.

The context structures are collected in a table. The first entries
are reserved for a session context per client.

The stack forms a potential shared resource. The task of assigning new
context records or freeing them therefore is protected with a lock.
The implementation is optimistic in the sense that once an entry has been
located it is privately used. This assumes the implementation of detecting
duplicate identifier use in parallel blocks!

A variable binding may become CONSTANT for the duration of its
life time, or the type can be FROZEN.

TODO: looking for a variable in a context is implemented by scanning
the whole list.  Maybe we should switch to a hash-table here!
One thing to have in mind, though, is intrensive MIL scripts that do
while or batloops, only lookup a variable the first time the loop
is executed, so the performance problem should not be very severe.
@h
#ifndef _MONET_CNTXT_H_
#define _MONET_CNTXT_H_
#include "monet.h"


typedef struct VARSTRUCT {
	ValRecord binding;	/* the MIL value of the variable */
	struct VARSTRUCT *next;	/* linked list */
	bit constant;		/* value cannot change */
	bit frozen;		/* type cannot change */
	char name[1];		/* variable name (var length, extends after record!!) */
} *Variable, VarRecord;

typedef struct CNTXT {
	Variable var;		/* head of the variable list */
	Cntxt outer;		/* where to look next, basically the call stack */
	Cntxt next;		/* for making chains. differs from 'outer' due to parallel execution */
	bit shadow;		/* shadow stk; create new variables in outer */
	bit used;		/* in use or not */
	int reuse;		/* context record is reused (i.e. kept around) for speed among multiple loop iterations
				 * reuse==-1: not in a loop, reuse==stk: reused by (while/multiplex/bat)loop in 'stk'
				 */
} CntxtRec;

m_export CntxtRec *monet_cntxt;

m_export void CNTXTinit(void);
m_export Cntxt CNTXTnew(Cntxt outer);
m_export void CNTXTclear(Cntxt i);
m_export void CNTXTfree(Cntxt stk, Client c);
m_export void CNTXTdelete(Cntxt i);
m_export int CNTXTclient(Cntxt i, Client *c);
m_export void CNTXTcopy(Cntxt src, Client c);
m_export ptr CNTXTregvars(Client c);

/* inline for speed */
#define CNTXTuse(stk)		monet_cntxt[stk].used = 1;
#define CNTXTfree2(stk,c)	if ((c) && (c)->maxstk != stk) CNTXTfree(stk,c)
#define CNTXTfree1(stk)		{ Client c; CNTXTclient(stk, &c); CNTXTfree2(stk,c); }

m_export Variable VARfind(Cntxt *stk, str scope);
m_export Variable VARlocalfind(Cntxt *stk, str scope);
m_export Variable VARnew(Cntxt stk, str name);
m_export str VARfindinstance(Cntxt *foundstk, int *foundatom, int natoms, int *atoms);
m_export void VARdel(Cntxt stk, Variable del);

#define VARfreeze(X)	do { if (X) (X)->frozen=TRUE; } while (0)
#define VARfixate(X)	do { if (X) (X)->constant=(X)->frozen=TRUE; } while (0)

m_export Cntxt monet_cntxtmax;
m_export Cntxt monet_cntxtlim;

#endif /* _MONET_CNTXT_H_ */
@c
#include "monetdb4_config.h"
#include "monet.h"

Cntxt monet_cntxtmax = 200 * MAXCLIENTS;
Cntxt monet_cntxtlim = 1024 * 1024;
Cntxt monet_cntxtfree = MAXCLIENTS;
Cntxt monet_cntxtcur = 0;
CntxtRec *monet_cntxtbuf = NULL, *monet_cntxt = NULL;

void
CNTXTinit(void)
{
	monet_cntxtlim = MAX(monet_cntxtmax + 1, monet_cntxtlim);

	/* alloc cntxt space; try to reserve as much space as possible */
	for (;;) {
		size_t size = (monet_cntxtmax + 1) * sizeof(CntxtRec);
		size_t maxsize = monet_cntxtlim * sizeof(CntxtRec);

		monet_cntxtbuf = (CntxtRec *) GDKvmalloc(size, &maxsize, 1);
		MT_alloc_register(monet_cntxtbuf, maxsize, 'C');
		if (monet_cntxtbuf && maxsize >= monet_cntxtlim * sizeof(CntxtRec)) {
			monet_cntxtlim = (Cntxt) (maxsize / sizeof(CntxtRec));
			break;
		}
		MT_alloc_register(monet_cntxtbuf, maxsize, 'c');
		if (monet_cntxtbuf)
			GDKvmfree(monet_cntxtbuf, size, maxsize);
		if ((monet_cntxtlim /= 2) < monet_cntxtmax + 1) {
			GDKfatal("CNTXTinit: could not alloc arena\n");
		}
	}
	memset(monet_cntxtbuf, 0, (monet_cntxtmax + 1) * sizeof(CntxtRec));
	MT_mmap_pin(monet_cntxtbuf, (monet_cntxtmax + 1) * sizeof(CntxtRec));
	monet_cntxt = monet_cntxtbuf + 1;
}


int
CNTXTrealloc(flt factor)
{
	/* extend the VM region; make it start at the same base address */
	Cntxt oldsize = monet_cntxtmax + 1;
	Cntxt newsize = (Cntxt) ((double) oldsize * factor);
	size_t maxsize = MAX(newsize, monet_cntxtlim) * sizeof(CntxtRec);
	CntxtRec *p = (CntxtRec *) GDKvmrealloc(monet_cntxtbuf, oldsize * sizeof(CntxtRec),
						newsize * sizeof(CntxtRec), maxsize, &maxsize, 1);

	if (p == NULL || p != monet_cntxtbuf) {
		if (p)
			GDKvmfree(p, oldsize * sizeof(CntxtRec), maxsize);
		GDKerror("CNTXTrealloc: out of context space\n");
		return FALSE;
	}
	memset(monet_cntxtbuf + oldsize, 0, (newsize - oldsize) * sizeof(CntxtRec));
	monet_cntxtmax = newsize - 1;
	monet_cntxtlim = (Cntxt) (maxsize / sizeof(CntxtRec));
	return TRUE;
}

@-
find the Client who owns  a cetrain context record 'stk' (by walking upwards).
@c
int
CNTXTclient(Cntxt stk, Client *c)
{
	int depth = 0;

	while (stk >= MAXCLIENTS) {
		depth++;
		stk = monet_cntxt[stk].outer;
	}
	*c = monet_clients + stk;
	return depth;
}

@-
Initialize a new context for a particular user. The non-used
context records are linked through the outer field. This way
we can get a new context in 'constant' time.
@c
Cntxt
CNTXTnew(Cntxt outer)
{
	Client c;
	Cntxt i;

	CNTXTclient(outer, &c);

	monet_set_lock(monet_contextLock, "CNTXTnew");
	if (monet_cntxtcur >= MAXCLIENTS) {
		i = monet_cntxtcur;	/* get from freelist */
		monet_cntxtcur = monet_cntxt[monet_cntxtcur].next;
	} else if (monet_cntxtfree >= monet_cntxtmax && !CNTXTrealloc((flt) BATMARGIN)) {
		monet_unset_lock(monet_contextLock, "CNTXTnew");
		return 0;
	} else {
		i = monet_cntxtfree++;	/* alloc new at end succeeded */
	}
	monet_cntxt[i].shadow = 0;
	monet_cntxt[i].used = 1;
	monet_cntxt[i].reuse = monet_cntxt[outer].reuse;
	monet_cntxt[i].next = c->maxstk;
	monet_cntxt[i].outer = outer;
	c->maxstk = i;
	monet_unset_lock(monet_contextLock, "CNTXTnew");
	return i;
}

@-
Deleting a context basically means deleting all its variables
@c
void
CNTXTdelete(Cntxt cur)
{
	Variable w, v = monet_cntxt[cur].var;

	for (monet_cntxt[cur].var = 0; v; v = w) {
		w = v->next;
		GDKfree(v);
	}
	monet_cntxt[cur].reuse = -1;
}

@-
CNTXTfree deletes all unsed contexts between maxstk and stk. It then adapts maxstk.
Due to parallel execution, not all stacks on the trail from maxstk to current
can be freed. Hence we filter out those that can, and leave in those that cannot.
@c
void
CNTXTfree(Cntxt stk, Client c)
{
	Cntxt keep_first = -1, del_first = -1;
	Cntxt keep_last = -1, del_last = -1;
	Cntxt cur;

	monet_set_lock(monet_contextLock, "CNTXTfree");
	for (cur = c->maxstk; cur != stk; cur = monet_cntxt[cur].next) {
		if (monet_cntxt[cur].used == 0 && (monet_cntxt[cur].reuse < 0 || monet_cntxt[monet_cntxt[cur].reuse].reuse < 0)) {
			CNTXTdelete(cur);
			if (del_first < 0)
				del_first = cur;
			if (del_last >= 0)
				monet_cntxt[del_last].next = cur;
			del_last = cur;
		} else {
			if (keep_first < 0)
				keep_first = cur;
			if (keep_last >= 0)
				monet_cntxt[keep_last].next = cur;
			keep_last = cur;
		}
	}
	if (del_last >= 0) {
		monet_cntxt[del_last].next = monet_cntxtcur;
		monet_cntxtcur = del_first;
	}
	if (keep_last >= 0) {
		monet_cntxt[keep_last].next = stk;
		c->maxstk = keep_first;
	} else {
		c->maxstk = stk;
	}
	monet_unset_lock(monet_contextLock, "CNTXTfree");
}

@-
Clearing a context leavs all variables in place, but frees
all their values, which are set to nil. This typically
occurs when a MIL block (context) that is in a loop
reaches end-of-scope. The context and all variable records
are left intact, so they can be reused in the next iteration.
@c
void
CNTXTclear(Cntxt stk)
{
	Variable w, v = monet_cntxt[stk].var;

	while (v) {
		w = v->next;
		ATOMunfix(v->binding.vtype, VALptr(&v->binding));
		VALclear(&v->binding);
		v = w;
	}
	monet_cntxt[stk].used = 0;
}

@-
Create a new stack with copies of all variables in all scopes until root.
@c
void
CNTXTcopy(Cntxt stk, Client c)
{
	while (stk > 0) {
		Variable v;

		for (v = monet_cntxt[stk].var; v != NULL; v = v->next) {
			Variable n = VARnew(c->stk, v->name);

			n->constant = v->constant;
			n->frozen = v->frozen;
			VALcopy(&n->binding, &v->binding);
			ATOMfix(n->binding.vtype, VALptr(&n->binding));
		}
		stk = monet_cntxt[stk].outer;
	}
}

ptr
CNTXTregvars(Client c)
{
	Variable n, r;
	Cntxt stk = c->stk;

	while (monet_cntxt[stk].shadow)
		stk = monet_cntxt[stk].outer;
	r = monet_cntxt[stk].var;

	if (c->m_stack)
		for (n = r; n != c->m_stack->var; n = n->next)
			TBL_Install_MilVar(c, c->m_stack->mod, (ptr) n);
	return (ptr) r;
}


@-
A variable is initialized as an integer 0 and made accessible through
a context.
@c
Variable
VARnew(Cntxt stk, str name)
{
	Variable v;
	size_t i;

	i = strlen(name);
	v = (Variable) GDKmalloc(sizeof(VarRecord) + i);
	memset(v, 0, sizeof(VarRecord) + i);
	v->binding.vtype = TYPE_void;
	v->binding.val.oval = void_nil;

	strncpy(v->name, name, i);
	v->name[i] = 0;
	v->constant = 0;
	v->frozen = 0;

	monet_set_lock(monet_contextLock, "VARnew");
	while (monet_cntxt[stk].shadow)
		stk = monet_cntxt[stk].outer;
	v->next = monet_cntxt[stk].var;
	monet_cntxt[stk].var = v;

	monet_unset_lock(monet_contextLock, "VARnew");
	return v;
}

@
@-
The routine @%VARfind@ dereferences a name to find the variable descriptor.
@c
Variable
VARfind(Cntxt *stk, str nme)
{
	Variable v;
	int i, s = *stk;

	if (nme == NULL) {
		return 0;
	}
	do {
		i = s;
		for (v = monet_cntxt[i].var; v; v = v->next) {
			if (*nme == *v->name && strcmp(nme, v->name) == 0) {
				return v;
			}
		}
		s = monet_cntxt[i].outer;
	} while (i >= 0);

	return 0;
}

@-
The routine @%VARlocalfind@ dereferences a name to find the variable descriptor.
Only the local stack is inspected.
@c
Variable
VARlocalfind(Cntxt *stk, str nme)
{
	Variable v;
	int i, s = *stk;

	if (nme == NULL) {
		return 0;
	}
	i = s;
	for (v = monet_cntxt[i].var; v; v = v->next) {
		if (*nme == *v->name && strcmp(nme, v->name) == 0) {
			*stk = s;
			return v;
		}
	}

	return 0;
}



@-
In order to drop a module we must enforce that the client does not use
anu more instances of soon-to-be-obsolete atomic types (that disappear
through the drop). Thus, we check the client's variable stack, and
even better, check all variable stacks for such offending varaiables.

If any variables of offending types are found, the drop will fail.

BAT values are now checked in the drop implementation (monet_tbl).
@c
str
VARfindinstance(Cntxt *foundstk, int *foundatom, int natoms, int *atoms)
{
	Variable v;
	Cntxt j;
	int i;

	monet_set_lock(monet_contextLock, "VARfindinstance");
	for (j = 0; j < monet_cntxtmax; j++) {
		if (!monet_cntxt[j].used)
			continue;

		for (v = monet_cntxt[j].var; v; v = v->next) {
			if (v->binding.vtype > TYPE_str) {
				for (i = 0; i < natoms; i++) {
					if (atoms[i] == v->binding.vtype) {
						str foundvar = GDKstrdup(v->name);

						*foundstk = j;
						*foundatom = v->binding.vtype;
						monet_unset_lock(monet_contextLock, "VARfindinstance");
						return foundvar;
					}
				}
			}
		}
	}
	monet_unset_lock(monet_contextLock, "VARfindinstance");
	return NULL;
}

void
VARdel(Cntxt stk, Variable del)
{
	Variable cur, last = NULL, modify = NULL;
	int found = FALSE;

	monet_set_lock(monet_contextLock, "VARdel");
	for (cur = monet_cntxt[stk].var; cur; cur = cur->next) {
		if (cur == del) {
			modify = last;
			found = TRUE;
		}
		last = cur;
	}
	if (found) {
		/* put it at the end of the list, invalidate name, and unfix value */
		if (modify) {
			modify->next = del->next;
		} else {
			monet_cntxt[stk].var = del->next;
		}
		last->next = del;
		del->next = NULL;

		/* do not destroy Variable nor memory space because of potential race conditions */
		ATOMunfix(del->binding.vtype, VALptr(&del->binding));
		del->name[0] = '.';	/* normal MIL variable names cannot have a dot */
		del->binding.vtype = TYPE_void;
		/* del->binding.val.pval is leaked on purpose */
	}
	monet_unset_lock(monet_contextLock, "VARdel");
}

@
