stdout of test '02_Modules_plain` in directory 'tests/Availability` itself:


# 06:00:16 >  
# 06:00:16 >   Mserver "--config=C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\conf\MonetDB.conf" --debug=10 --set "monet_mod_path=C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\plain\.libs;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\plain;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\contrib\.libs;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\contrib;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\calibrator\.libs;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\calibrator;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\mapi\.libs;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\mapi;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\mnetcdf\.libs;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\mnetcdf;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\scripts\tools" --set "gdk_dbfarm=C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\dbfarm" --set "sql_logdir=C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\sql_logs" --set "xquery_logdir=C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\xquery_logs" --set mapi_open=true --set xrpc_open=true --set mapi_port=30048 --set xrpc_port=41800 --set monet_prompt= --trace --dbname=mTests_tests_Availability  
# 06:00:16 >  

# MonetDB Server v4.21.0
# based on GDK   v1.21.0
# Copyright (c) 1993-2007, CWI. All rights reserved.
# Compiled for i686-pc-win32/32bit with 32bit OIDs; dynamically linked.
# Visit http://monetdb.cwi.nl/ for further information.
setoid(oid(20000000));

var MODULES:=bat("MODULES");

var Static_fcn:=monet_fcntbl.reverse().copy();

var Fname:=new(oid,str);	Fname.col_name("function");
var FnameS:=new(oid,str);	FnameS.col_name("function");
var Ftype:=new(oid,str);	Ftype.col_name("type");
var Fsig:=new(oid,str);		Fsig.col_name("signature");
var Fhelp:=new(oid,str);	Fhelp.col_name("help");
var Fnts:=new(oid,str);

var Plain_mods:=MODULES.select("plain").sort().copy();
table(Plain_mods.reverse().col_name(sprintf("%i modules",Plain_mods.count())));
#-----------------#
# 24 modules	  # name
# str		  # type
#-----------------#
[ "aggr"	  ]
[ "aggrX3"	  ]
[ "alarm"	  ]
[ "ascii_io"	  ]
[ "bat_arith"	  ]
[ "blob"	  ]
[ "counters"	  ]
[ "decimal"	  ]
[ "enum"	  ]
[ "lock"	  ]
[ "logger"	  ]
[ "mapi"	  ]
[ "mkey"	  ]
[ "mmath"	  ]
[ "monettime"	  ]
[ "pcl"		  ]
[ "pcre"	  ]
[ "pqueue"	  ]
[ "profiler"	  ]
[ "stats"	  ]
[ "streams"	  ]
[ "unix"	  ]
[ "url"		  ]
[ "xtables"	  ]
Plain_mods@batloop() {
	var The_mod:=$h;
	printf("\nModule: \"%s\"\n\n",The_mod);
	module($h);

	var Mod_fcn:=sdiff(monet_fcntbl.reverse(),Static_fcn).reverse();
	Mod_fcn.sort()@batloop() {
	    var addThis:=false;
	    if (not(monet_fcn_mid.exist($t))) {
		addThis:=true;
	    } else {
		var m:=monet_mod_nme.find(monet_fcn_mid.find($t));
		if (m.startsWith("_")) {
		    m:=string(m,1);
		}
		if (m = The_mod) {
		    addThis:=true;
		}
	    }
	    if (addThis) {
		var Tname:=$h;
		var Ttype:=help_tpe(monet_fcn_tpe.find($t));
		var Tsig:=format_fcn_sig($t);
		var Thelp:="";
		if (monet_fcn_dsc.exist($t)) {
			Thelp:=monet_fcn_dsc.find($t);
		} else {
			Thelp:="not available";
		}
		Fname.insert($t,Tname);
		Ftype.insert($t,Ttype);
		Fsig.insert($t,Tsig);
		Fhelp.insert($t,Thelp);
		Fnts.insert($t,sprintf("%s %s %s",Tname,Ttype,Tsig));
	    }
	}

	drop($h);
	Static_fcn:=sunion(Static_fcn,monet_fcntbl.reverse());

	Fnts.count().print();
	Fnts.reverse().sort().reverse()@batloop() {
		FnameS.insert($h,Fname.find($h));
	}
	FnameS.count().print(); table(1,FnameS,Ftype,Fsig,Fhelp);

	Fname.delete();
	FnameS.delete();
	Ftype.delete();
	Fsig.delete();
	Fhelp.delete();
	Fnts.delete();
}

Module: "aggr"

[ 77 ]
[ 77 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature							help								  # name
# str			str		str								str								  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "card",		  "COMMAND:   ",  "card(BAT[any,any]) : wrd",					  "return the number of different values in a tail column"	  ]
[ "card",		  "COMMAND:   ",  "card(BAT[any,any], wrd) : wrd",				  "as card(b), but returns nil if card(b) > maxelements"	  ]
[ "hasNil",		  "COMMAND:   ",  "hasNil(BAT[any,any]) : bit",					  "return if there is a nil value in the tail column"		  ]
[ "size",		  "COMMAND:   ",  "size(BAT[any,bit]) : wrd",					  "return the number of true values in a tail column"		  ]
[ "size",		  "PROC:      ",  "size(BAT[any,bit]) : wrd",					  "not available"						  ]
[ "variance",		  "PROC:      ",  "variance(BAT[any,any::1]) : any::1",				  "not available"						  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,int], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{card}",		  "PROC:      ",  "{card}(BAT[oid,any], BAT[oid,any]) : BAT[oid,wrd]",		  "not available"						  ]
[ "{count_no_nil}",	  "PROC:      ",  "{count_no_nil}(BAT[oid,any], BAT[oid,any]) : BAT[oid,int]",	  "short-cut for {count}(b,e,TRUE)"				  ]
[ "{count}",		  "COMMAND:   ",  "{count}(BAT[oid,any], BAT[oid,any], bit) : BAT[oid,int]",	  "grouped count; ignores nil values iff ignore_nils==TRUE"	  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[oid,any], BAT[oid,any]) : BAT[oid,int]",		  "short-cut for {count}(b,e,FALSE)"				  ]
[ "{max}",		  "COMMAND:   ",  "{max}(BAT[oid,any::1], BAT[oid,any]) : BAT[oid,any::1]",	  "grouped tail maximum"					  ]
[ "{min}",		  "COMMAND:   ",  "{min}(BAT[oid,any::1], BAT[oid,any]) : BAT[oid,any::1]",	  "grouped tail minimum"					  ]
[ "{prod_bte}",		  "COMMAND:   ",  "{prod_bte}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,bte]",	  "grouped tail product"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail product"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail product"					  ]
[ "{prod_flt}",		  "COMMAND:   ",  "{prod_flt}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",	  "grouped tail product"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail product"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail product"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail product"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail product"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,int], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail product"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail product"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail product"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail product"					  ]
[ "{prod_sht}",		  "COMMAND:   ",  "{prod_sht}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail product"					  ]
[ "{prod_sht}",		  "COMMAND:   ",  "{prod_sht}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail product"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail product"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,int], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail product"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail product"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail product"					  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,bte]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,wrd]",		  "not available"						  ]
[ "{size}",		  "COMMAND:   ",  "{size}(BAT[oid,bit], BAT[oid,any]) : BAT[oid,wrd]",		  "grouped count of true values"				  ]
[ "{sum_bte}",		  "COMMAND:   ",  "{sum_bte}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,bte]",	  "grouped tail sum"						  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail sum"						  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail sum"						  ]
[ "{sum_flt}",		  "COMMAND:   ",  "{sum_flt}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",	  "grouped tail sum"						  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail sum"						  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail sum"						  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail sum"						  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail sum"						  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,int], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail sum"						  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail sum"						  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail sum"						  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail sum"						  ]
[ "{sum_sht}",		  "COMMAND:   ",  "{sum_sht}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail sum"						  ]
[ "{sum_sht}",		  "COMMAND:   ",  "{sum_sht}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail sum"						  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail sum"						  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,int], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail sum"						  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail sum"						  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail sum"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,bte]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,wrd]",		  "not available"						  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,bte]",	  "grouped tail variance"					  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail variance"					  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",	  "grouped tail variance"					  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail variance"					  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail variance"					  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail variance"					  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail variance"					  ]

Module: "aggrX3"

[ 133 ]
[ 133 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature									help								  # name
# str			str		str										str								  # type
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "card",		  "PROC:      ",  "card(BAT[any,any]) : wrd",							  "not available"						  ]
[ "size",		  "PROC:      ",  "size(BAT[any,bit]) : wrd",							  "not available"						  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on bte"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on bte"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on dbl"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,dbl], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on dbl"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on flt"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on flt"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,int], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on int"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on int"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on lng"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on lng"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on sht"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on sht"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on wrd"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,wrd], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on wrd"					  ]
[ "{card}",		  "PROC:      ",  "{card}(BAT[oid,any], BAT[oid,any]) : BAT[oid,wrd]",				  "not available"						  ]
[ "{card}",		  "PROC:      ",  "{card}(BAT[oid,any], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",		  "not available"						  ]
[ "{count_no_nil}",	  "PROC:      ",  "{count_no_nil}(BAT[oid,any], BAT[oid,any]) : BAT[oid,int]",			  "short-cut for {count}(b,e,TRUE)"				  ]
[ "{count_no_nil}",	  "PROC:      ",  "{count_no_nil}(BAT[oid,any], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",	  "short-cut for {count}(b,g,e,TRUE)"				  ]
[ "{count}",		  "COMMAND:   ",  "{count}(BAT[oid,any], BAT[oid,any], bit) : BAT[oid,int]",			  "grouped count; ignores nil values iff ignore_nils==TRUE"	  ]
[ "{count}",		  "COMMAND:   ",  "{count}(BAT[oid,any], BAT[oid,oid], BAT[oid,any], bit) : BAT[oid,int]",	  "grouped count; ignores nil values iff ignore_nils==TRUE"	  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[oid,any], BAT[oid,any]) : BAT[oid,int]",				  "short-cut for {count}(b,e,FALSE)"				  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[oid,any], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "short-cut for {count}(b,g,e,FALSE)"				  ]
[ "{max}",		  "COMMAND:   ",  "{max}(BAT[oid,any::1], BAT[oid,any]) : BAT[oid,any::1]",			  "grouped tail maximum"					  ]
[ "{max}",		  "COMMAND:   ",  "{max}(BAT[oid,any::1], BAT[oid,oid], BAT[oid,any]) : BAT[oid,any::1]",	  "grouped tail maximum"					  ]
[ "{min}",		  "COMMAND:   ",  "{min}(BAT[oid,any::1], BAT[oid,any]) : BAT[oid,any::1]",			  "grouped tail minimum"					  ]
[ "{min}",		  "COMMAND:   ",  "{min}(BAT[oid,any::1], BAT[oid,oid], BAT[oid,any]) : BAT[oid,any::1]",	  "grouped tail minimum"					  ]
[ "{prod_bte}",		  "COMMAND:   ",  "{prod_bte}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,bte]",			  "grouped tail prod on bte"					  ]
[ "{prod_bte}",		  "COMMAND:   ",  "{prod_bte}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,bte]",	  "grouped tail prod on bte"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",			  "grouped tail prod on dbl"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,dbl], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail prod on dbl"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",			  "grouped tail prod on flt"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail prod on flt"					  ]
[ "{prod_flt}",		  "COMMAND:   ",  "{prod_flt}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",			  "grouped tail prod on flt"					  ]
[ "{prod_flt}",		  "COMMAND:   ",  "{prod_flt}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,flt]",	  "grouped tail prod on flt"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,int]",			  "grouped tail prod on bte"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail prod on bte"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",			  "grouped tail prod on int"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail prod on int"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,int]",			  "grouped tail prod on sht"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail prod on sht"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail prod on bte"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail prod on bte"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,int], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail prod on int"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail prod on int"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail prod on lng"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail prod on lng"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail prod on sht"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail prod on sht"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail prod on wrd"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,wrd], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail prod on wrd"					  ]
[ "{prod_sht}",		  "COMMAND:   ",  "{prod_sht}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,sht]",			  "grouped tail prod on bte"					  ]
[ "{prod_sht}",		  "COMMAND:   ",  "{prod_sht}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail prod on bte"					  ]
[ "{prod_sht}",		  "COMMAND:   ",  "{prod_sht}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",			  "grouped tail prod on sht"					  ]
[ "{prod_sht}",		  "COMMAND:   ",  "{prod_sht}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail prod on sht"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,wrd]",			  "grouped tail prod on bte"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail prod on bte"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,int], BAT[oid,any]) : BAT[oid,wrd]",			  "grouped tail prod on int"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail prod on int"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,wrd]",			  "grouped tail prod on lng"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail prod on lng"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,wrd]",			  "grouped tail prod on sht"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail prod on sht"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,wrd]",			  "grouped tail prod on wrd"					  ]
[ "{prod_wrd}",		  "COMMAND:   ",  "{prod_wrd}(BAT[oid,wrd], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",	  "grouped tail prod on wrd"					  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,bte]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,bte]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,dbl], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,flt]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,sht]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,wrd]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,wrd], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",		  "not available"						  ]
[ "{size}",		  "COMMAND:   ",  "{size}(BAT[oid,bit], BAT[oid,any]) : BAT[oid,wrd]",				  "grouped count of true values"				  ]
[ "{sum_bte}",		  "COMMAND:   ",  "{sum_bte}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,bte]",			  "grouped tail sum on bte"					  ]
[ "{sum_bte}",		  "COMMAND:   ",  "{sum_bte}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,bte]",		  "grouped tail sum on bte"					  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",			  "grouped tail sum on dbl"					  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,dbl], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail sum on dbl"					  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",			  "grouped tail sum on flt"					  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail sum on flt"					  ]
[ "{sum_flt}",		  "COMMAND:   ",  "{sum_flt}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",			  "grouped tail sum on flt"					  ]
[ "{sum_flt}",		  "COMMAND:   ",  "{sum_flt}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,flt]",		  "grouped tail sum on flt"					  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,int]",			  "grouped tail sum on bte"					  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "grouped tail sum on bte"					  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",			  "grouped tail sum on int"					  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "grouped tail sum on int"					  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,int]",			  "grouped tail sum on sht"					  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "grouped tail sum on sht"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail sum on bte"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "grouped tail sum on bte"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,int], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail sum on int"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "grouped tail sum on int"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail sum on lng"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "grouped tail sum on lng"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail sum on sht"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "grouped tail sum on sht"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail sum on wrd"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,wrd], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "grouped tail sum on wrd"					  ]
[ "{sum_sht}",		  "COMMAND:   ",  "{sum_sht}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,sht]",			  "grouped tail sum on bte"					  ]
[ "{sum_sht}",		  "COMMAND:   ",  "{sum_sht}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,sht]",		  "grouped tail sum on bte"					  ]
[ "{sum_sht}",		  "COMMAND:   ",  "{sum_sht}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",			  "grouped tail sum on sht"					  ]
[ "{sum_sht}",		  "COMMAND:   ",  "{sum_sht}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,sht]",		  "grouped tail sum on sht"					  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,wrd]",			  "grouped tail sum on bte"					  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",		  "grouped tail sum on bte"					  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,int], BAT[oid,any]) : BAT[oid,wrd]",			  "grouped tail sum on int"					  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",		  "grouped tail sum on int"					  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,wrd]",			  "grouped tail sum on lng"					  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",		  "grouped tail sum on lng"					  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,wrd]",			  "grouped tail sum on sht"					  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",		  "grouped tail sum on sht"					  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,wrd]",			  "grouped tail sum on wrd"					  ]
[ "{sum_wrd}",		  "COMMAND:   ",  "{sum_wrd}(BAT[oid,wrd], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",		  "grouped tail sum on wrd"					  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,bte], BAT[oid,any]) : BAT[oid,bte]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,bte], BAT[oid,oid], BAT[oid,any]) : BAT[oid,bte]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,dbl], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,flt]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,sht]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,wrd], BAT[oid,any]) : BAT[oid,wrd]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,wrd], BAT[oid,oid], BAT[oid,any]) : BAT[oid,wrd]",		  "not available"						  ]

Module: "alarm"

[ 7 ]
[ 7 ]
#---------------------------------------------------------------------------------------------------------#
# function		type		signature			help					  # name
# str		str		str				str					  # type
#---------------------------------------------------------------------------------------------------------#
[ "alarm",	  "COMMAND:   ",  "alarm(int, str) : void",	  "execute action in X secs"		  ]
[ "ctime",	  "COMMAND:   ",  "ctime() : str",		  "current time as a string"		  ]
[ "epoch",	  "COMMAND:   ",  "epoch() : int",		  "current time as unix epoch"		  ]
[ "sleep",	  "COMMAND:   ",  "sleep(int) : void",		  "sleep X secs"			  ]
[ "time",	  "COMMAND:   ",  "time() : int",		  "time in milliseconds"		  ]
[ "timers",	  "COMMAND:   ",  "timers() : BAT[str,str]",	  "give a list of all active timers"	  ]
[ "usec",	  "COMMAND:   ",  "usec() : lng",		  "time in microseconds"		  ]

Module: "ascii_io"

[ 20 ]
[ 20 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature										help			  # name
# str			str		str											str			  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "ascii_io_debug",	  "COMMAND:   ",  "ascii_io_debug(int) : void",								  ""			  ]
[ "bat_ttype",		  "PROC:      ",  "bat_ttype(BAT[any,any]) : str",							  "not available"	  ]
[ "dump",		  "COMMAND:   ",  "dump(BAT[void,str], BAT[void,str], BAT[void,BAT], str, int) : void",			  ""			  ]
[ "dump_data",		  "PROC:      ",  "dump_data(BAT[str,BAT], BAT[str,BAT], str, int) : void",				  "not available"	  ]
[ "dump_data",		  "PROC:      ",  "dump_data(BAT[str,BAT], str, int) : void",						  "not available"	  ]
[ "dump_format",	  "PROC:      ",  "dump_format(BAT[void,BAT], str) : BAT[str,BAT]",					  "not available"	  ]
[ "dump_seps",		  "PROC:      ",  "dump_seps(BAT[void,BAT]) : BAT[void,str]",						  "not available"	  ]
[ "export",		  "PROC:      ",  "export(BAT[any,any], str) : void",							  "not available"	  ]
[ "fclose",		  "PROC:      ",  "fclose(Stream) : void",								  "not available"	  ]
[ "fflush",		  "PROC:      ",  "fflush(Stream) : void",								  "not available"	  ]
[ "fopen",		  "PROC:      ",  "fopen(str, str) : Stream",								  "not available"	  ]
[ "fputs",		  "PROC:      ",  "fputs(str, Stream) : void",								  "not available"	  ]
[ "import",		  "PROC:      ",  "import(BAT[any,any], str) : BAT[any,any]",						  "not available"	  ]
[ "input",		  "COMMAND:   ",  "input(BAT[void,str], BAT[void,str], BAT[void,str], Stream, int) : BAT[str,BAT]",	  ""			  ]
[ "load",		  "COMMAND:   ",  "load(BAT[void,str], BAT[void,str], BAT[void,str], str, int) : BAT[str,BAT]",		  ""			  ]
[ "load_data",		  "PROC:      ",  "load_data(BAT[str,BAT], str, int) : BAT[str,BAT]",					  "Load data given Mload-style format; limit to nr elements (all if -1)"  ]
[ "load_format",	  "PROC:      ",  "load_format(str) : BAT[str,BAT]",							  "Load Mload-style format file fmt"					  ]
[ "make_persistent",	  "PROC:      ",  "make_persistent(BAT[str,BAT]) : void",						  "Make loaded bats persistent."					  ]
[ "merge_data",		  "PROC:      ",  "merge_data(BAT[str,BAT]) : void",							  "Merge loaded bats with existing ones."				  ]
[ "output",		  "COMMAND:   ",  "output(BAT[any,any], BAT[void,str], BAT[void,BAT], Stream) : void",			  ""			  ]

Module: "bat_arith"

[ 210 ]
[ 210 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature						help														  # name
# str		str		str							str														  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,bte], BAT[void,bte]) : BAT[void,bte]",	  "optimized multiplexed mod ('%') on head-aligned [void,bte] BATs"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,bte], bte) : BAT[void,bte]",		  "optimized multiplexed right-scalar mod ('%') on [void,bte] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",	  "optimized multiplexed mod ('%') on head-aligned [void,dbl] BATs"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar mod ('%') on [void,dbl] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",	  "optimized multiplexed mod ('%') on head-aligned [void,flt] BATs"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar mod ('%') on [void,flt] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,int], BAT[void,int]) : BAT[void,int]",	  "optimized multiplexed mod ('%') on head-aligned [void,int] BATs"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar mod ('%') on [void,int] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "optimized multiplexed mod ('%') on head-aligned [void,lng] BATs"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar mod ('%') on [void,lng] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",	  "optimized multiplexed mod ('%') on head-aligned [void,sht] BATs"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar mod ('%') on [void,sht] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,wrd], BAT[void,wrd]) : BAT[void,wrd]",	  "optimized multiplexed mod ('%') on head-aligned [void,wrd] BATs"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,wrd], wrd) : BAT[void,wrd]",		  "optimized multiplexed right-scalar mod ('%') on [void,wrd] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](bte, BAT[void,bte]) : BAT[void,bte]",		  "optimized multiplexed left-scalar mod ('%') on [void,bte] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar mod ('%') on [void,dbl] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar mod ('%') on [void,flt] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar mod ('%') on [void,int] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar mod ('%') on [void,lng] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar mod ('%') on [void,sht] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](wrd, BAT[void,wrd]) : BAT[void,wrd]",		  "optimized multiplexed left-scalar mod ('%') on [void,wrd] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,bte], BAT[void,bte]) : BAT[void,bte]",	  "optimized multiplexed mul ('*') on head-aligned [void,bte] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,bte], bte) : BAT[void,bte]",		  "optimized multiplexed right-scalar mul ('*') on [void,bte] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",	  "optimized multiplexed mul ('*') on head-aligned [void,dbl] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar mul ('*') on [void,dbl] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",	  "optimized multiplexed mul ('*') on head-aligned [void,flt] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar mul ('*') on [void,flt] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,int], BAT[void,int]) : BAT[void,int]",	  "optimized multiplexed mul ('*') on head-aligned [void,int] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar mul ('*') on [void,int] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "optimized multiplexed mul ('*') on head-aligned [void,lng] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar mul ('*') on [void,lng] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",	  "optimized multiplexed mul ('*') on head-aligned [void,sht] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar mul ('*') on [void,sht] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,wrd], BAT[void,wrd]) : BAT[void,wrd]",	  "optimized multiplexed mul ('*') on head-aligned [void,wrd] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,wrd], wrd) : BAT[void,wrd]",		  "optimized multiplexed right-scalar mul ('*') on [void,wrd] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](bte, BAT[void,bte]) : BAT[void,bte]",		  "optimized multiplexed left-scalar mul ('*') on [void,bte] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar mul ('*') on [void,dbl] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar mul ('*') on [void,flt] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar mul ('*') on [void,int] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar mul ('*') on [void,lng] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar mul ('*') on [void,sht] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](wrd, BAT[void,wrd]) : BAT[void,wrd]",		  "optimized multiplexed left-scalar mul ('*') on [void,wrd] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,bte], BAT[void,bte]) : BAT[void,bte]",	  "optimized multiplexed add ('+') on head-aligned [void,bte] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,bte], bte) : BAT[void,bte]",		  "optimized multiplexed right-scalar add ('+') on [void,bte] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",	  "optimized multiplexed add ('+') on head-aligned [void,dbl] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar add ('+') on [void,dbl] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",	  "optimized multiplexed add ('+') on head-aligned [void,flt] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar add ('+') on [void,flt] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,int], BAT[void,int]) : BAT[void,int]",	  "optimized multiplexed add ('+') on head-aligned [void,int] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar add ('+') on [void,int] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "optimized multiplexed add ('+') on head-aligned [void,lng] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar add ('+') on [void,lng] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",	  "optimized multiplexed add ('+') on head-aligned [void,sht] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar add ('+') on [void,sht] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,wrd], BAT[void,wrd]) : BAT[void,wrd]",	  "optimized multiplexed add ('+') on head-aligned [void,wrd] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,wrd], wrd) : BAT[void,wrd]",		  "optimized multiplexed right-scalar add ('+') on [void,wrd] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](bte, BAT[void,bte]) : BAT[void,bte]",		  "optimized multiplexed left-scalar add ('+') on [void,bte] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar add ('+') on [void,dbl] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar add ('+') on [void,flt] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar add ('+') on [void,int] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar add ('+') on [void,lng] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar add ('+') on [void,sht] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](wrd, BAT[void,wrd]) : BAT[void,wrd]",		  "optimized multiplexed left-scalar add ('+') on [void,wrd] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,bte], BAT[void,bte]) : BAT[void,bte]",	  "optimized multiplexed sub ('-') on head-aligned [void,bte] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,bte], bte) : BAT[void,bte]",		  "optimized multiplexed right-scalar sub ('-') on [void,bte] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",	  "optimized multiplexed sub ('-') on head-aligned [void,dbl] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar sub ('-') on [void,dbl] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",	  "optimized multiplexed sub ('-') on head-aligned [void,flt] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar sub ('-') on [void,flt] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,int], BAT[void,int]) : BAT[void,int]",	  "optimized multiplexed sub ('-') on head-aligned [void,int] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar sub ('-') on [void,int] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "optimized multiplexed sub ('-') on head-aligned [void,lng] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar sub ('-') on [void,lng] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",	  "optimized multiplexed sub ('-') on head-aligned [void,sht] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar sub ('-') on [void,sht] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,wrd], BAT[void,wrd]) : BAT[void,wrd]",	  "optimized multiplexed sub ('-') on head-aligned [void,wrd] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,wrd], wrd) : BAT[void,wrd]",		  "optimized multiplexed right-scalar sub ('-') on [void,wrd] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](bte, BAT[void,bte]) : BAT[void,bte]",		  "optimized multiplexed left-scalar sub ('-') on [void,bte] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar sub ('-') on [void,dbl] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar sub ('-') on [void,flt] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar sub ('-') on [void,int] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar sub ('-') on [void,lng] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar sub ('-') on [void,sht] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](wrd, BAT[void,wrd]) : BAT[void,wrd]",		  "optimized multiplexed left-scalar sub ('-') on [void,wrd] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,bte], BAT[void,bte]) : BAT[void,bte]",	  "optimized multiplexed div ('/') on head-aligned [void,bte] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,bte], bte) : BAT[void,bte]",		  "optimized multiplexed right-scalar div ('/') on [void,bte] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",	  "optimized multiplexed div ('/') on head-aligned [void,dbl] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar div ('/') on [void,dbl] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",	  "optimized multiplexed div ('/') on head-aligned [void,flt] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar div ('/') on [void,flt] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,int], BAT[void,int]) : BAT[void,int]",	  "optimized multiplexed div ('/') on head-aligned [void,int] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar div ('/') on [void,int] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "optimized multiplexed div ('/') on head-aligned [void,lng] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar div ('/') on [void,lng] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",	  "optimized multiplexed div ('/') on head-aligned [void,sht] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar div ('/') on [void,sht] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,wrd], BAT[void,wrd]) : BAT[void,wrd]",	  "optimized multiplexed div ('/') on head-aligned [void,wrd] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,wrd], wrd) : BAT[void,wrd]",		  "optimized multiplexed right-scalar div ('/') on [void,wrd] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](bte, BAT[void,bte]) : BAT[void,bte]",		  "optimized multiplexed left-scalar div ('/') on [void,bte] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar div ('/') on [void,dbl] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar div ('/') on [void,flt] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar div ('/') on [void,int] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar div ('/') on [void,lng] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar div ('/') on [void,sht] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](wrd, BAT[void,wrd]) : BAT[void,wrd]",		  "optimized multiplexed left-scalar div ('/') on [void,wrd] BAT"						  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,bte], BAT[void,bte]) : BAT[void,bte]",  "optimized multiplexed in-place mod (':%=') on head-aligned [void,bte] BATs (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,bte], bte) : BAT[void,bte]",		  "optimized multiplexed right-scalar in-place mod (':%=') on [void,bte] BAT (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed in-place mod (':%=') on head-aligned [void,dbl] BATs (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar in-place mod (':%=') on [void,dbl] BAT (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",  "optimized multiplexed in-place mod (':%=') on head-aligned [void,flt] BATs (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar in-place mod (':%=') on [void,flt] BAT (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,int], BAT[void,int]) : BAT[void,int]",  "optimized multiplexed in-place mod (':%=') on head-aligned [void,int] BATs (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar in-place mod (':%=') on [void,int] BAT (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "optimized multiplexed in-place mod (':%=') on head-aligned [void,lng] BATs (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar in-place mod (':%=') on [void,lng] BAT (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",  "optimized multiplexed in-place mod (':%=') on head-aligned [void,sht] BATs (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar in-place mod (':%=') on [void,sht] BAT (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,wrd], BAT[void,wrd]) : BAT[void,wrd]",  "optimized multiplexed in-place mod (':%=') on head-aligned [void,wrd] BATs (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,wrd], wrd) : BAT[void,wrd]",		  "optimized multiplexed right-scalar in-place mod (':%=') on [void,wrd] BAT (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](bte, BAT[void,bte]) : BAT[void,bte]",		  "optimized multiplexed left-scalar in-place mod (':%=') on [void,bte] BAT (overwrites second operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar in-place mod (':%=') on [void,dbl] BAT (overwrites second operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar in-place mod (':%=') on [void,flt] BAT (overwrites second operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar in-place mod (':%=') on [void,int] BAT (overwrites second operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar in-place mod (':%=') on [void,lng] BAT (overwrites second operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar in-place mod (':%=') on [void,sht] BAT (overwrites second operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](wrd, BAT[void,wrd]) : BAT[void,wrd]",		  "optimized multiplexed left-scalar in-place mod (':%=') on [void,wrd] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,bte], BAT[void,bte]) : BAT[void,bte]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,bte] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,bte], bte) : BAT[void,bte]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,bte] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,dbl] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,dbl] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,flt] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,flt] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,int], BAT[void,int]) : BAT[void,int]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,int] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,int] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,lng] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,lng] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,sht] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,sht] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,wrd], BAT[void,wrd]) : BAT[void,wrd]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,wrd] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,wrd], wrd) : BAT[void,wrd]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,wrd] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](bte, BAT[void,bte]) : BAT[void,bte]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,bte] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,dbl] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,flt] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,int] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,lng] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,sht] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](wrd, BAT[void,wrd]) : BAT[void,wrd]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,wrd] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,bte], BAT[void,bte]) : BAT[void,bte]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,bte] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,bte], bte) : BAT[void,bte]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,bte] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,dbl] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,dbl] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,flt] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,flt] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,int], BAT[void,int]) : BAT[void,int]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,int] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,int] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,lng] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,lng] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,sht] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,sht] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,wrd], BAT[void,wrd]) : BAT[void,wrd]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,wrd] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,wrd], wrd) : BAT[void,wrd]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,wrd] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](bte, BAT[void,bte]) : BAT[void,bte]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,bte] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,dbl] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,flt] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,int] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,lng] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,sht] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](wrd, BAT[void,wrd]) : BAT[void,wrd]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,wrd] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,bte], BAT[void,bte]) : BAT[void,bte]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,bte] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,bte], bte) : BAT[void,bte]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,bte] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,dbl] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,dbl] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,flt] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,flt] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,int], BAT[void,int]) : BAT[void,int]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,int] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,int] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,lng] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,lng] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,sht] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,sht] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,wrd], BAT[void,wrd]) : BAT[void,wrd]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,wrd] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,wrd], wrd) : BAT[void,wrd]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,wrd] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](bte, BAT[void,bte]) : BAT[void,bte]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,bte] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,dbl] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,flt] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,int] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,lng] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,sht] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](wrd, BAT[void,wrd]) : BAT[void,wrd]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,wrd] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,bte], BAT[void,bte]) : BAT[void,bte]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,bte] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,bte], bte) : BAT[void,bte]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,bte] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,dbl] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,dbl] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,flt] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,flt] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,int], BAT[void,int]) : BAT[void,int]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,int] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,int] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,lng] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,lng] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,sht] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,sht] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,wrd], BAT[void,wrd]) : BAT[void,wrd]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,wrd] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,wrd], wrd) : BAT[void,wrd]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,wrd] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](bte, BAT[void,bte]) : BAT[void,bte]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,bte] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,dbl] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,flt] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,int] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,lng] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,sht] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](wrd, BAT[void,wrd]) : BAT[void,wrd]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,wrd] BAT (overwrites second operand)"	  ]

Module: "blob"

[ 4 ]
[ 4 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature			help																  # name
# str		str		str				str																  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "nitems",	  "COMMAND:   ",  "nitems(blob) : int",		  "get the number of bytes stored in this blob."										  ]
[ "toblob",	  "COMMAND:   ",  "toblob(str) : blob",		  "store a string as a blob."													  ]
[ "tostr",	  "COMMAND:   ",  "tostr(blob) : str",		  "get the bytes from blob as a string, till the first 0 byte\n         or the end of the blob"					  ]
[ "tostr",	  "COMMAND:   ",  "tostr(blob, int) : str",	  "get the bytes from blob as a string, starting at byte 'index'\n         till the first 0 byte or the end of the blob."	  ]

Module: "counters"

[ 14 ]
[ 14 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature				help											  # name
# str			str		str					str											  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "counter2bat",	  "COMMAND:   ",  "counter2bat(counter) : BAT[str,lng]",  "store the retrieved results in a BAT"						  ]
[ "counter2str",	  "PROC:      ",  "counter2str(counter) : str",		  "cast counter to string."								  ]
[ "event_name",		  "PROC:      ",  "event_name(int) : str",		  "return the (native) name of an event given by number"				  ]
[ "event_number",	  "PROC:      ",  "event_number(int) : int",		  "return the number of an event given by name"						  ]
[ "event_number",	  "PROC:      ",  "event_number(str) : int",		  "not available"									  ]
[ "init_counters",	  "COMMAND:   ",  "init_counters() : void",		  "initialize counters module\n  (to be used on initial load, only)"			  ]
[ "profile",		  "PROC:      ",  "profile(str, str, str) : counter",	  "Count events event0 & event1 while executing cmd; return the results as counter."	  ]
[ "show_native_events",	  "COMMAND:   ",  "show_native_events() : BAT[int,str]",  "all available events"								  ]
[ "show_unified_events",  "COMMAND:   ",  "show_unified_events() : BAT[int,str]", "all unified event names"								  ]
[ "start_count",	  "COMMAND:   ",  "start_count(int, int) : counter",	  "start counters for two events specified by number"					  ]
[ "start_count",	  "PROC:      ",  "start_count(int, str) : counter",	  "start counters for two events, first specified by number, second specified by name"	  ]
[ "start_count",	  "PROC:      ",  "start_count(str, int) : counter",	  "start counters for two events, first specified by name, second specified by number"	  ]
[ "start_count",	  "PROC:      ",  "start_count(str, str) : counter",	  "start counters for two events specified by name"					  ]
[ "stop_count",		  "COMMAND:   ",  "stop_count(counter) : counter",	  "stop the counting and retrieve the results"						  ]

Module: "decimal"

[ 36 ]
[ 36 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature								help																																																																																									  # name
# str			str		str									str																																																																																									  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "!=",			  "OPERATOR:  ",  "!=(decimal, decimal) : bit",						  "decimal non-equality test (!DS2.2)"																																																																																					  ]
[ "*",			  "OPERATOR:  ",  "*(decimal, decimal) : decimal",					  "Returns a decimal whose value is exactly (val1 * val2)."																																																																																		  ]
[ "+",			  "OPERATOR:  ",  "+(decimal, decimal) : decimal",					  "Returns a decimal whose value is extactly (val1 + val2)."																																																																																		  ]
[ "-",			  "OPERATOR:  ",  "-(decimal) : decimal",						  "Returns a decimal whose value is -1 * value, with equal scale and precision as 'value'."																																																																														  ]
[ "-",			  "OPERATOR:  ",  "-(decimal, decimal) : decimal",					  "Returns a decimal whose value is exactly (val1 - val2)."																																																																																		  ]
[ "/",			  "OPERATOR:  ",  "/(decimal, decimal) : decimal",					  "Returns a decimal whose value is val1 DIV val2, (scale=0) like in C integer division.\n      This operator can implement MOD as MOD(x,y) = x - y*DIV(d,y).\n      Use the tertiary divide(num,div,prec) command for dividing with arbitrary precision.\n      Division by zero returns decimal(nil)."																																																				  ]
[ "<",			  "OPERATOR:  ",  "<(decimal, decimal) : bit",						  "decimal smaller-than test (!DS2.2)"																																																																																					  ]
[ "<=",			  "OPERATOR:  ",  "<=(decimal, decimal) : bit",						  "decimal smaller-or-equal test (!DS2.2)"																																																																																				  ]
[ "=",			  "OPERATOR:  ",  "=(decimal, decimal) : bit",						  "decimal equality test (!DS2.2)"																																																																																					  ]
[ ">",			  "OPERATOR:  ",  ">(decimal, decimal) : bit",						  "decimal greater-than test (!DS2.2)"																																																																																					  ]
[ ">=",			  "OPERATOR:  ",  ">=(decimal, decimal) : bit",						  "decimal greater-or-equal test (!DS2.2)"																																																																																				  ]
[ "[/]",		  "PROC:      ",  "[/](BAT[any::1,decimal], decimal) : BAT[any::1,decimal]",		  "not available"																																																																																							  ]
[ "[divide]",		  "PROC:      ",  "[divide](BAT[any::1,decimal], decimal, int) : BAT[any::1,decimal]",	  "not available"																																																																																							  ]
[ "abs",		  "COMMAND:   ",  "abs(decimal) : decimal",						  "Returns a decimal whose value is the absolute value of this number."																																																																																	  ]
[ "addscale",		  "COMMAND:   ",  "addscale(decimal, int) : decimal",					  "Return a  decimal with the same number as value, but with scale = value.scale + delta.\n      This can be seen as shifting the dot in the floating-point value of the decimal\n      to the left (delta < 0) or right (delta > 0) (!DS2.2)."																																																												  ]
[ "bulkdivide",		  "COMMAND:   ",  "bulkdivide(BAT[any::1,decimal], decimal) : BAT[any::1,decimal]",	  "(!DS2.2)"																																																																																								  ]
[ "bulkdivide",		  "COMMAND:   ",  "bulkdivide(BAT[any::1,decimal], decimal, int) : BAT[any::1,decimal]",  "(!DS2.2)"																																																																																								  ]
[ "dbl",		  "COMMAND:   ",  "dbl(decimal) : dbl",							  "Return the value of a decimal as a double (return dbl(nil) on overflow)."																																																																																  ]
[ "decimal",		  "COMMAND:   ",  "decimal(dbl) : decimal",						  "Create a decimal from a double value."																																																																																				  ]
[ "decimal",		  "COMMAND:   ",  "decimal(flt) : decimal",						  "Create a decimal from a float value."																																																																																				  ]
[ "decimal",		  "COMMAND:   ",  "decimal(int) : decimal",						  "Translates an integer into a decimal."																																																																																				  ]
[ "decimal",		  "COMMAND:   ",  "decimal(lng) : decimal",						  "Translates a long into a decimal."																																																																																					  ]
[ "decimal_minrepeat",	  "COMMAND:   ",  "decimal_minrepeat(int) : void",					  "set number of repeating characters after which to condense decimals (!DS2.2)."																																																																															  ]
[ "divide",		  "COMMAND:   ",  "divide(decimal, decimal, int) : decimal",				  "Returns a decimal whose value is (val1 / val2), truncated to a specified precision.\n      Division by zero returns decimal(nil)."																																																																									  ]
[ "flt",		  "COMMAND:   ",  "flt(decimal) : flt",							  "Return the value of a decimal as a float (return flt(nil) on overflow)."																																																																																  ]
[ "getprecision",	  "COMMAND:   ",  "getprecision(decimal) : int",					  "Returns the precision of this number (!DS2.2)."																																																																																			  ]
[ "getscale",		  "COMMAND:   ",  "getscale(decimal) : int",						  "Returns the scale of this number (!DS2.2)"																																																																																				  ]
[ "int",		  "COMMAND:   ",  "int(decimal) : int",							  "Return the truncated value of a decimal as an integer (return int(nil) on overflow)."																																																																														  ]
[ "isnil",		  "COMMAND:   ",  "isnil(decimal) : bit",						  "decimal nil test (!DS2.2)"																																																																																						  ]
[ "istenfold",		  "COMMAND:   ",  "istenfold(decimal) : bit",						  "returns whether decimal is an exact multiple of 10 (!DS2.2)."																																																																																	  ]
[ "lng",		  "COMMAND:   ",  "lng(decimal) : lng",							  "Return the truncated value of a decimal as a long (return lng(nil) on overflow)."																																																																															  ]
[ "pow",		  "COMMAND:   ",  "pow(decimal, int) : decimal",					  "Raises a decimal to the power of some integer.\n      The precision of the result is the precision of the decimal (!DS2.2)."																																																																										  ]
[ "pow",		  "COMMAND:   ",  "pow(decimal, int, int) : decimal",					  "Raises a decimal to the power of some integer.\n      The precision argument determines the maximum precision of the result (!DS2.2)."																																																																								  ]
[ "setprecision",	  "COMMAND:   ",  "setprecision(decimal, int) : decimal",				  "Return the same number but with a different precision; i.e. truncated or zero-padded (!DS2.2)."																																																																													  ]
[ "setscale",		  "COMMAND:   ",  "setscale(decimal, int) : decimal",					  "Normalize the number of a decimal by setting the scale to a fixed value.\n      This is compensated by making the number shorter (by truncation) or by enlarging\n      it with trailing zeros (!DS2.2)."																																																																  ]
[ "str",		  "COMMAND:   ",  "str(decimal, str) : str",						  "Formats a decimal in a fixed-width string (truncated, if necessary).\n      format = [ '+' ] ( N1 | ( N1 '.' N2 ) | ( '.' N2 ) ) [ 'E' N3 ]\n       with: Nx = a number of the form [0-9]+ (possibly starting with 0)\n      where: N1 = is the number of digits before the decimal point (default = 0)\n             N2 = is the number of digits after the decimal point (default = 1)\n             N3 = the number of digits to use for the scale (default = 2)\n      A zero will be printed with only one zero digit (left space-padded), unless N1 has a\n      leading zero, in which case a zero-padded number of width N1 is produced.\n      If the plus at start is specified, positive numbers start with a plus. "	  ]

Module: "enum"

[ 23 ]
[ 23 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature								help										  # name
# str			str		str									str										  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[decode]",		  "COMMAND:   ",  "[decode](int, BAT[any::1,any]) : BAT[any::1,any]",			  "decode a BAT of tail values, into a new BAT of decoded values"		  ]
[ "[encode]",		  "COMMAND:   ",  "[encode](int, BAT[any::1,any]) : BAT[any::1,any]",			  "encode a BAT of tail values, into a new BAT of encoded values"		  ]
[ "decode",		  "COMMAND:   ",  "decode(int, any) : any",						  "decode a value"								  ]
[ "encode",		  "COMMAND:   ",  "encode(int, any) : any",						  "encode a value"								  ]
[ "enum_create",	  "PROC:      ",  "enum_create(str, BAT[any,any]) : int",				  "create a new enumeration type."						  ]
[ "enum_destroy",	  "COMMAND:   ",  "enum_destroy(int) : void",						  "destroy an enumeration type"							  ]
[ "enum_drop",		  "PROC:      ",  "enum_drop(int) : void",						  "deactivate an enumeration type."						  ]
[ "enum_ishisto",	  "COMMAND:   ",  "enum_ishisto(int, BAT[any,any]) : bit",				  "returns whether enum_table(tpe) is a histogram on b's head column"		  ]
[ "enum_load",		  "COMMAND:   ",  "enum_load(BAT[any,int]) : int",					  "load/activate a previously created enumeration type."			  ]
[ "enum_load",		  "PROC:      ",  "enum_load(str) : void",						  "activate an enumeration type from a histogram bat."				  ]
[ "enum_new",		  "COMMAND:   ",  "enum_new(str, BAT[any,any]) : int",					  "create a new enumeration type."						  ]
[ "enum_print",		  "COMMAND:   ",  "enum_print(Stream, BAT[any,int], BAT[any,any]) : void",		  "quick file print of 2 synced bats, an int and enumerated string tail"	  ]
[ "enum_print",		  "COMMAND:   ",  "enum_print(Stream, BAT[any,int], BAT[any,any], BAT[any,any]) : void",  "quick file print of 3 synced bats, and int tail and two enumerated strings"	  ]
[ "enum_sethisto",	  "COMMAND:   ",  "enum_sethisto(int, BAT[any,any]) : void",				  "registers the fact that enum_table(tpe) is a histogram on b's head column"	  ]
[ "enum_table",		  "COMMAND:   ",  "enum_table(int) : BAT[any,any]",					  "return the enumeration BAT of an enum type"					  ]
[ "enum_trick",		  "PROC:      ",  "enum_trick(BAT[oid,any], BAT[any,int]) : BAT[oid,any]",		  "create a view on a BAT with a diffrent enum map."				  ]
[ "fclose",		  "PROC:      ",  "fclose(Stream) : void",						  "not available"								  ]
[ "fflush",		  "PROC:      ",  "fflush(Stream) : void",						  "not available"								  ]
[ "fopen",		  "PROC:      ",  "fopen(str, str) : Stream",						  "not available"								  ]
[ "fputs",		  "PROC:      ",  "fputs(str, Stream) : void",						  "not available"								  ]
[ "isenum",		  "COMMAND:   ",  "isenum(int) : bit",							  "returns true iff tpe is an enumerated type"					  ]
[ "lower",		  "COMMAND:   ",  "lower(int, any) : any",						  "encode to the lowest value in the encoded domain that is larger than v"	  ]
[ "upper",		  "COMMAND:   ",  "upper(int, any) : any",						  "encode to the hightes value in the encoded domain that is smaller than v"	  ]

Module: "lock"

[ 9 ]
[ 9 ]
#-----------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature			help									  # name
# str		str		str				str									  # type
#-----------------------------------------------------------------------------------------------------------------------------------------#
[ "lock_create",  "COMMAND:   ",  "lock_create() : lock",	  "create an unset lock"						  ]
[ "lock_destroy", "COMMAND:   ",  "lock_destroy(lock) : void",	  "destroy a lock"							  ]
[ "lock_set",	  "COMMAND:   ",  "lock_set(lock) : void",	  "try to set a lock; if set, block till it is freed"			  ]
[ "lock_try",	  "COMMAND:   ",  "lock_try(lock) : int",	  "try a lock, if free set it and return 0, if not return EBUSY"	  ]
[ "lock_unset",	  "COMMAND:   ",  "lock_unset(lock) : void",	  "unset a lock"							  ]
[ "sema_create",  "COMMAND:   ",  "sema_create(int) : sema",	  "create an unset sema, with an initial value"				  ]
[ "sema_destroy", "COMMAND:   ",  "sema_destroy(sema) : void",	  "destroy a sema"							  ]
[ "sema_down",	  "COMMAND:   ",  "sema_down(sema) : void",	  "decrease the semaphpore if >0; else block"				  ]
[ "sema_up",	  "COMMAND:   ",  "sema_up(sema) : void",	  "increase the semaphore"						  ]

Module: "logger"

[ 18 ]
[ 18 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature							help													  # name
# str			str		str								str													  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "log_abort",		  "COMMAND:   ",  "log_abort(logger) : void",					  "write transaction aborted in the WAL"												  ]
[ "log_bat",		  "COMMAND:   ",  "log_bat(logger, BAT[void,any::1], str) : void",		  "log the inserts in the WAL"														  ]
[ "log_bat_clear",	  "COMMAND:   ",  "log_bat_clear(logger, str) : void",				  "log the inserts in the WAL"														  ]
[ "log_bat_persists",	  "COMMAND:   ",  "log_bat_persists(logger, BAT[void,any::1], str) : void",	  "log the created bat in the WAL (return success)"											  ]
[ "log_bat_transient",	  "COMMAND:   ",  "log_bat_transient(logger, str) : void",			  "log the bat destruction in the WAL (return success)"											  ]
[ "log_delta",		  "COMMAND:   ",  "log_delta(logger, BAT[oid,any::1], str) : void",		  "log the updates in the WAL"														  ]
[ "log_trans_end",	  "COMMAND:   ",  "log_trans_end(logger) : void",				  "write transaction end in the WAL"													  ]
[ "log_trans_start",	  "COMMAND:   ",  "log_trans_start(logger) : void",				  "Log a start of a transaction"													  ]
[ "logger_add_bat",	  "COMMAND:   ",  "logger_add_bat(logger, BAT[void,any::1], str) : int",	  "Register a bat name, return the bid"													  ]
[ "logger_changes",	  "COMMAND:   ",  "logger_changes(logger) : int",				  "Return the number of logged changes."												  ]
[ "logger_cleanup",	  "COMMAND:   ",  "logger_cleanup(logger) : void",				  "Cleanup the old no longer needed logfiles. Should be called after logger_restart but can be called without any locks."		  ]
[ "logger_create",	  "COMMAND:   ",  "logger_create(int, str, str, str, int) : logger",		  "Create logger, check if recovery is needed. The fn variable names the frontend,this is needed to keep the catalog bat seperate"	  ]
[ "logger_del_bat",	  "COMMAND:   ",  "logger_del_bat(logger, int) : void",				  "Unregister a bat with given bid"													  ]
[ "logger_destroy",	  "COMMAND:   ",  "logger_destroy(logger) : void",				  "Free the resources used by the logger."												  ]
[ "logger_exit",	  "COMMAND:   ",  "logger_exit(logger) : void",					  "After the manager replaced some bats we need to flush these bats to disk and close the current log file."				  ]
[ "logger_find_bat",	  "COMMAND:   ",  "logger_find_bat(logger, str) : int",				  "Find the bid for a named bat"													  ]
[ "logger_restart",	  "COMMAND:   ",  "logger_restart(logger) : void",				  "Restart will call logger_exit and logger_open to start a new log file."								  ]
[ "logger_start",	  "PROC:      ",  "logger_start() : void",					  "not available"											  ]

Module: "mapi"

[ 26 ]
[ 26 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature									help																																								  # name
# str			str		str										str																																								  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "client",		  "BUILTIN:   ",  "client(stream in, stream out) : void ",				  "mapi-client"																												  ]
[ "fclose",		  "PROC:      ",  "fclose(Stream) : void",							  "not available"																																						  ]
[ "fflush",		  "PROC:      ",  "fflush(Stream) : void",							  "not available"																																						  ]
[ "fopen",		  "PROC:      ",  "fopen(str, str) : Stream",							  "not available"																																						  ]
[ "fputs",		  "PROC:      ",  "fputs(str, Stream) : void",							  "not available"																																						  ]
[ "get_mapi_open",	  "PROC:      ",  "get_mapi_open() : bit",						  "not available"																											  ]
[ "get_mapi_port",	  "PROC:      ",  "get_mapi_port() : int",							  "not available"																																						  ]
[ "listen",		  "PROC:      ",  "listen() : void",								  "Start the Mapi listener on 50000."																																				  ]
[ "listen",		  "PROC:      ",  "listen(bit) : void",								  "Start the Mapi listener on 50000.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."																														  ]
[ "listen",		  "PROC:      ",  "listen(int) : void",								  "Start the Mapi listener on <port>."																																				  ]
[ "listen",		  "PROC:      ",  "listen(int, bit) : void",						  "Start the Mapi listener on <port>.\nIf <open> is true, accept connections from everywhere, otherwise only from localhost."														  ]
[ "listen",		  "PROC:      ",  "listen(int, int) : void",						  "Start the Mapi listener on <port> for <maxusers>."																							  ]
[ "listen",		  "PROC:      ",  "listen(int, int) : void",							  "Start the Mapi listener on <port> for <maxusers>."																																		  ]
[ "listen",		  "PROC:      ",  "listen(int, int, bit) : void",						  "Start the Mapi listener on <port> for <maxusers>.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."																												  ]
[ "listen",		  "PROC:      ",  "listen(int, str, int) : void",					  "Start the Mapi listener on <port> and/or <sockfile> for <maxusers>."																					  ]
[ "mapi_listen",	  "BUILTIN:   ",  "mapi_listen(int port, str sockfile, int maxusers, bit open) ",	  "Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.\n <sockfile> is the name of a Unix socket.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."				  ]
[ "mapi_listen_ssl",	  "BUILTIN:   ",  "mapi_listen_ssl(int port, int maxusers, str keyfile, str certfile) ",  "Start the Mapi listener on <port> for <maxusers> using SSL.\n<keyfile> and <certfile> give the path names for files with the server key and certificates in PEM format."								  ]
[ "mapi_register",	  "COMMAND:   ",  "mapi_register(ptr) : void",						  "register a frontend"																											  ]
[ "mapi_running",	  "COMMAND:   ",  "mapi_running() : bit",						  "Is there an mapi listen active ?"																									  ]
[ "mapi_server",	  "PROC:      ",  "mapi_server() : void",						  "not available"																											  ]
[ "mapi_stream_read",	  "PROC:      ",  "mapi_stream_read(Stream) : str",						  "Read a string from <S> until a '\\1' character."																																		  ]
[ "mil_frontend",	  "COMMAND:   ",  "mil_frontend() : ptr",						  "create/return the mil_frontend"																									  ]
[ "mil_start",		  "PROC:      ",  "mil_start() : void",							  "not available"																											  ]
[ "stream_line",	  "PROC:      ",  "stream_line(Stream) : str",							  "Read a string from <S> until a newline."																																			  ]
[ "stream_strip",	  "PROC:      ",  "stream_strip(Stream, str) : str",						  "Read a string from <S> until the <stop> word.\nThe <stop> word is stripped from the result string."																												  ]
[ "stream_until",	  "COMMAND:   ",  "stream_until(Stream, str) : str",						  "read a string from <S> until the <stop> word"																																		  ]

Module: "mkey"

[ 20 ]
[ 20 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature										help													  # name
# str			str		str											str													  # type
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[:rotate_xor_hash=]",  "PROC:      ",  "[:rotate_xor_hash=](BAT[any::1,int], int, BAT[any::1,any]) : BAT[any::1,int]",	  "not available"											  ]
[ "bulk_rotate_xor_hash", "COMMAND:   ",  "bulk_rotate_xor_hash(BAT[oid,int], int, BAT[oid,any]) : BAT[oid,int]",		  "pre:  h and b should be synced on head\n         post: [:xor=]([:rotate=](h, nbits), [hash](b))"	  ]
[ "ds_eq",		  "PROC:      ",  "ds_eq(BAT[void,oid], BAT[any,any], BAT[void,oid], BAT[any,any]) : BAT[void,bit]",	  "not available"											  ]
[ "ds_hash",		  "PROC:      ",  "ds_hash(BAT[BAT,any]) : BAT[oid,int]",						  "not available"											  ]
[ "ds_link",		  "PROC:      ",  "ds_link(BAT[BAT,BAT]) : BAT[oid,oid]",						  "not available"											  ]
[ "ds_link",		  "PROC:      ",  "ds_link(BAT[oid,any::1], BAT[oid,any::1], ..BAT[oid,any]..) : BAT[oid,oid]",		  "not available"											  ]
[ "ds_sort",		  "PROC:      ",  "ds_sort(BAT[any::1,any::2], bit) : BAT[any::1,any::2]",				  "not available"											  ]
[ "hash",		  "COMMAND:   ",  "hash(any) : int",									  "compute a hash int number from any value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(bit) : int",									  "compute a hash int number from a bit value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(bte) : int",									  "compute a hash int number from a bte value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(chr) : int",									  "compute a hash int number from a chr value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(dbl) : int",									  "compute a hash int number from a dbl value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(flt) : int",									  "compute a hash int number from a flt value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(int) : int",									  "compute a hash int number from a int value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(lng) : int",									  "compute a hash int number from a lng value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(sht) : int",									  "compute a hash int number from a sht value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(str) : int",									  "compute a hash int number from a str value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(wrd) : int",									  "compute a hash int number from a wrd value"								  ]
[ "rotate",		  "COMMAND:   ",  "rotate(int, int) : int",								  "left-rotate an int by nbits"										  ]
[ "rotate_xor_hash",	  "PROC:      ",  "rotate_xor_hash(int, int, any) : int",						  "not available"											  ]

Module: "mmath"

[ 39 ]
[ 39 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature			help																																											  # name
# str			str		str				str																																											  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "acos",		  "COMMAND:   ",  "acos(dbl) : dbl",		  "The acos(x) function calculates the arc cosine of x;\nthat is the value whose cosine is x. The value is returned in radians\nand is mathematically defined to be between 0 and PI (inclusive)."																			  ]
[ "acos",		  "PROC:      ",  "acos(flt) : flt",		  "not available"																																									  ]
[ "asin",		  "COMMAND:   ",  "asin(dbl) : dbl",		  "The asin(x) function calculates the arc sine of x;\nthat is the value whose sine is x. The value is returned in radians\nand is mathematically defined to be between -PI/20 and -PI/2 (inclusive)."																			  ]
[ "asin",		  "PROC:      ",  "asin(flt) : flt",		  "not available"																																									  ]
[ "atan",		  "COMMAND:   ",  "atan(dbl) : dbl",		  "The atan(x) function calculates the arc tangent of x;\nthat is the value whose tangent is x. The value is returned in radians\nand is mathematically defined to be between -PI/2 and PI/2 (inclusive)."																		  ]
[ "atan",		  "PROC:      ",  "atan(flt) : flt",		  "not available"																																									  ]
[ "atan2",		  "COMMAND:   ",  "atan2(dbl, dbl) : dbl",	  "The atan2(x,y) function calculates the arc tangent of the two\nvariables x and y. It is similar to calculating the arc\ntangent of y / x, except that the signs of both arguments\nare used to determine the quadrant of the result.\nThe value is returned in radians and is mathematically defined\nto be between -PI/2 and PI/2 (inclusive)."	  ]
[ "ceil",		  "COMMAND:   ",  "ceil(dbl) : dbl",		  "The ceil(x) function rounds x upwards to the nearest integer."																																			  ]
[ "ceil",		  "PROC:      ",  "ceil(flt) : flt",		  "not available"																																									  ]
[ "cos",		  "COMMAND:   ",  "cos(dbl) : dbl",		  "The cos(x) function returns the cosine of x,\nwhere x is given in radians. The return value is between -1 and 1."																													  ]
[ "cos",		  "PROC:      ",  "cos(flt) : flt",		  "not available"																																									  ]
[ "cosh",		  "COMMAND:   ",  "cosh(dbl) : dbl",		  "The cosh() function  returns the hyperbolic cosine of x,\nwhich is defined mathematically as (exp(x) + exp(-x)) / 2."																												  ]
[ "cosh",		  "PROC:      ",  "cosh(flt) : flt",		  "not available"																																									  ]
[ "exp",		  "COMMAND:   ",  "exp(dbl) : dbl",		  "The exp(x) function returns the value of e\n(the base of natural logarithms) raised to the power of x."																														  ]
[ "exp",		  "PROC:      ",  "exp(flt) : flt",		  "not available"																																									  ]
[ "fabs",		  "COMMAND:   ",  "fabs(dbl) : dbl",		  "The fabs(x) function returns the absolute value of the\nfloating-point number x."																																  ]
[ "finite",		  "COMMAND:   ",  "finite(dbl) : bit",		  "The finite(x) function returns true if x is neither infinite nor a 'not-a-number' (NaN) value, and false otherwise."																													  ]
[ "floor",		  "COMMAND:   ",  "floor(dbl) : dbl",		  "The floor(x) function rounds x downwards to the nearest integer."																																			  ]
[ "floor",		  "PROC:      ",  "floor(flt) : flt",		  "not available"																																									  ]
[ "fmod",		  "COMMAND:   ",  "fmod(dbl, dbl) : dbl",	  "The fmod(x,y) function computes the remainder of dividing x by y.\nThe return value is x - n * y, where n is the quotient of x / y,\nrounded towards zero to an integer."																						  ]
[ "isinf",		  "COMMAND:   ",  "isinf(dbl) : int",		  "The isinf(x) function returns -1 if x represents negative infinity, 1 if x represents positive infinity, and 0 otherwise."																												  ]
[ "isnan",		  "COMMAND:   ",  "isnan(dbl) : bit",		  "The isnan(x) function returns true if x is 'not-a-number' (NaN), and false otherwise."																																  ]
[ "log",		  "COMMAND:   ",  "log(dbl) : dbl",		  "The log(x) function returns the natural logarithm of x."																																				  ]
[ "log",		  "PROC:      ",  "log(flt) : flt",		  "not available"																																									  ]
[ "log10",		  "COMMAND:   ",  "log10(dbl) : dbl",		  "The log10(x) function returns the base-10 logarithm of x."																																				  ]
[ "log10",		  "PROC:      ",  "log10(flt) : flt",		  "not available"																																									  ]
[ "pi",			  "PROC:      ",  "pi() : dbl",			  "not available"																																									  ]
[ "pow",		  "COMMAND:   ",  "pow(dbl, dbl) : dbl",	  "The pow(x,y) function  returns the value of x raised to the power of y."																																		  ]
[ "round",		  "COMMAND:   ",  "round(dbl, int) : dbl",	  "The round(n, m) returns n rounded to m places to the right of the\ndecimal point; if m is omitted, to 0 places. m can be negative to\nround off digits left of the decimal point. m must be an integer."																		  ]
[ "sin",		  "COMMAND:   ",  "sin(dbl) : dbl",		  "The sin(x) function returns the cosine of x,\nwhere x is given in radians. The return value is between -1 and 1."																													  ]
[ "sin",		  "PROC:      ",  "sin(flt) : flt",		  "not available"																																									  ]
[ "sinh",		  "COMMAND:   ",  "sinh(dbl) : dbl",		  "The sinh() function  returns  the  hyperbolic sine of x,\nwhich is defined mathematically as (exp(x) - exp(-x)) / 2."																												  ]
[ "sinh",		  "PROC:      ",  "sinh(flt) : flt",		  "not available"																																									  ]
[ "sqrt",		  "COMMAND:   ",  "sqrt(dbl) : dbl",		  "The sqrt(x) function returns the non-negative square root of x."																																			  ]
[ "sqrt",		  "PROC:      ",  "sqrt(flt) : flt",		  "not available"																																									  ]
[ "tan",		  "COMMAND:   ",  "tan(dbl) : dbl",		  "The tan(x) function returns the tangent of x,\nwhere x is given in radians"																																		  ]
[ "tan",		  "PROC:      ",  "tan(flt) : flt",		  "not available"																																									  ]
[ "tanh",		  "COMMAND:   ",  "tanh(dbl) : dbl",		  "The tanh() function returns the hyperbolic tangent of x,\nwhich is defined mathematically as sinh(x) / cosh(x)."																													  ]
[ "tanh",		  "PROC:      ",  "tanh(flt) : flt",		  "not available"																																									  ]

Module: "monettime"

[ 119 ]
[ 119 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function				type		signature														help													  # name
# str				str		str															str													  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "!=",				  "OPERATOR:  ",  "!=(date, date) : bit",												  "date non-equality test (!DS2.2)"									  ]
[ "!=",				  "OPERATOR:  ",  "!=(daytime, daytime) : bit",												  "daytime non-equality test (!DS2.2)"									  ]
[ "!=",				  "OPERATOR:  ",  "!=(timestamp, timestamp) : bit",											  "timestamp non-equality test (!DS2.2)"								  ]
[ "<",				  "OPERATOR:  ",  "<(date, date) : bit",												  "date smaller-than test (!DS2.2)"									  ]
[ "<",				  "OPERATOR:  ",  "<(daytime, daytime) : bit",												  "daytime smaller-than test (!DS2.2)"									  ]
[ "<",				  "OPERATOR:  ",  "<(timestamp, timestamp) : bit",											  "timestamp smaller-than test (!DS2.2)"								  ]
[ "<=",				  "OPERATOR:  ",  "<=(date, date) : bit",												  "date smaller-or-equal test (!DS2.2)"									  ]
[ "<=",				  "OPERATOR:  ",  "<=(daytime, daytime) : bit",												  "daytime smaller-or-equal test (!DS2.2)"								  ]
[ "<=",				  "OPERATOR:  ",  "<=(timestamp, timestamp) : bit",											  "timestamp smaller-or-equal test (!DS2.2)"								  ]
[ "=",				  "OPERATOR:  ",  "=(date, date) : bit",												  "date equality test (!DS2.2)"										  ]
[ "=",				  "OPERATOR:  ",  "=(daytime, daytime) : bit",												  "daytime equality test (!DS2.2)"									  ]
[ "=",				  "OPERATOR:  ",  "=(timestamp, timestamp) : bit",											  "timestamp equality test (!DS2.2)"									  ]
[ ">",				  "OPERATOR:  ",  ">(date, date) : bit",												  "date greater-than test (!DS2.2)"									  ]
[ ">",				  "OPERATOR:  ",  ">(daytime, daytime) : bit",												  "daytime greater-than test (!DS2.2)"									  ]
[ ">",				  "OPERATOR:  ",  ">(timestamp, timestamp) : bit",											  "timestamp greater-than test (!DS2.2)"								  ]
[ ">=",				  "OPERATOR:  ",  ">=(date, date) : bit",												  "date greater-or-equal test (!DS2.2)"									  ]
[ ">=",				  "OPERATOR:  ",  ">=(daytime, daytime) : bit",												  "daytime greater-or-equal test (!DS2.2)"								  ]
[ ">=",				  "OPERATOR:  ",  ">=(timestamp, timestamp) : bit",											  "timestamp greater-or-equal test (!DS2.2)"								  ]
[ "TIMEZONE",			  "PROC:      ",  "TIMEZONE(str) : tzone",												  "not available"											  ]
[ "[date]",			  "PROC:      ",  "[date](BAT[any::1,timestamp]) : BAT[any::1,date]",									  "not available"											  ]
[ "[daytime]",			  "PROC:      ",  "[daytime](BAT[any::1,int]) : BAT[any::1,daytime]",									  "not available"											  ]
[ "[daytime]",			  "PROC:      ",  "[daytime](BAT[any::1,int], BAT[any::1,int]) : BAT[any::1,daytime]",							  "not available"											  ]
[ "[daytime]",			  "PROC:      ",  "[daytime](BAT[any::1,int], BAT[any::1,int], BAT[any::1,int]) : BAT[any::1,daytime]",					  "not available"											  ]
[ "[daytime]",			  "PROC:      ",  "[daytime](BAT[any::1,timestamp]) : BAT[any::1,daytime]",								  "not available"											  ]
[ "[epoch]",			  "PROC:      ",  "[epoch](BAT[any::1,timestamp]) : BAT[any::1,int]",									  "not available"											  ]
[ "[rule]",			  "PROC:      ",  "[rule](BAT[any::1,int], BAT[any::1,int], BAT[any::1,int], BAT[any::1,int], BAT[any::1,int]) : BAT[any::1,rule]",	  "not available"											  ]
[ "[rule]",			  "PROC:      ",  "[rule](BAT[any::1,int], BAT[any::1,str], BAT[any::1,int], BAT[any::1,int]) : BAT[any::1,rule]",			  "not available"											  ]
[ "[rule]",			  "PROC:      ",  "[rule](BAT[any::1,int], BAT[any::1,str], BAT[any::1,int], BAT[any::1,int], BAT[any::1,int]) : BAT[any::1,rule]",	  "not available"											  ]
[ "[timestamp]",		  "PROC:      ",  "[timestamp](BAT[any::1,date], BAT[any::1,daytime]) : BAT[any::1,timestamp]",						  "not available"											  ]
[ "[timestamp]",		  "PROC:      ",  "[timestamp](BAT[any::1,int]) : BAT[any::1,timestamp]",								  "not available"											  ]
[ "add",			  "COMMAND:   ",  "add(daytime, lng) : daytime",											  "returns the daytime that comes 'msecs' (possibly negative) after 'value'."				  ]
[ "add",			  "COMMAND:   ",  "add(timestamp, lng) : timestamp",											  "returns the timestamp that comes 'msecs' (possibly negative) after 'value' (!DS2.2)."		  ]
[ "adddays",			  "COMMAND:   ",  "adddays(date, int) : date",												  "returns the date after a number of days (possibly negative)."					  ]
[ "addmonths",			  "COMMAND:   ",  "addmonths(date, int) : date",											  "returns the date after a number of months (possibly negative)."					  ]
[ "addmonths",			  "PROC:      ",  "addmonths(timestamp, int) : timestamp",										  "not available"											  ]
[ "addyears",			  "COMMAND:   ",  "addyears(date, int) : date",												  "returns the date after a number of years (possibly negative)."					  ]
[ "compute",			  "COMMAND:   ",  "compute(rule, int) : date",												  "compute the date from a rule in a certain year (!DS2.2)."						  ]
[ "current_date",		  "PROC:      ",  "current_date() : date",												  "not available"											  ]
[ "current_time",		  "PROC:      ",  "current_time() : daytime",												  "not available"											  ]
[ "current_timestamp",		  "PROC:      ",  "current_timestamp() : timestamp",											  "not available"											  ]
[ "date",			  "COMMAND:   ",  "date(int, int, int) : date",												  "creates a date from (year,month,day) parameters."							  ]
[ "date",			  "COMMAND:   ",  "date(timestamp) : date",												  "extracts date from timestamp (in the local timezone)."						  ]
[ "date",			  "COMMAND:   ",  "date(timestamp, tzone) : date",											  "extracts date from timestamp in a certain tzone (!DS2.2)."						  ]
[ "date_add_sec_interval",	  "COMMAND:   ",  "date_add_sec_interval(date, int) : date",										  "add  seconds interval"										  ]
[ "date_add_sec_interval",	  "PROC:      ",  "date_add_sec_interval(date, lng) : date",										  "not available"											  ]
[ "date_sub_month_interval",	  "COMMAND:   ",  "date_sub_month_interval(date, int) : date",										  "subtract months interval"										  ]
[ "date_sub_sec_interval",	  "COMMAND:   ",  "date_sub_sec_interval(date, int) : date",										  "subtract seconds interval"										  ]
[ "date_sub_sec_interval",	  "PROC:      ",  "date_sub_sec_interval(date, lng) : date",										  "not available"											  ]
[ "day",			  "COMMAND:   ",  "day(date) : int",													  "extracts day from date (value between 1 and 31)"							  ]
[ "day",			  "COMMAND:   ",  "day(rule) : int",													  "extract day from rule (!DS2.2)."									  ]
[ "day",			  "PROC:      ",  "day(lng) : lng",													  "not available"											  ]
[ "day",			  "PROC:      ",  "day(timestamp) : int",												  "not available"											  ]
[ "dayname",			  "COMMAND:   ",  "dayname(int) : str",													  "Returns day name from a number between [1-7], str(nil) otherwise (!DS2.2)."				  ]
[ "daynum",			  "COMMAND:   ",  "daynum(str) : int",													  "Returns number of day [1-7] from a string; or nil if does not match any (!DS2.2)."			  ]
[ "dayofweek",			  "COMMAND:   ",  "dayofweek(date) : int",												  "Returns the current day of the week where 1=sunday, .., 7=saturday"					  ]
[ "dayofyear",			  "COMMAND:   ",  "dayofyear(date) : int",												  "Returns N where d is the Nth day of the year (january 1 returns 1)"					  ]
[ "daytime",			  "COMMAND:   ",  "daytime(int, int, int, int) : daytime",										  "creates a time from (hours,minutes,seconds,milliseconds) parameters."				  ]
[ "daytime",			  "COMMAND:   ",  "daytime(timestamp) : daytime",											  "extracts daytime from timestamp (in the local timezone)."						  ]
[ "daytime",			  "COMMAND:   ",  "daytime(timestamp, tzone) : daytime",										  "extracts daytime from timestamp in a certain tzone (!DS2.2)."					  ]
[ "daytime",			  "PROC:      ",  "daytime(int) : daytime",												  "not available"											  ]
[ "daytime",			  "PROC:      ",  "daytime(int, int) : daytime",											  "not available"											  ]
[ "daytime",			  "PROC:      ",  "daytime(int, int, int) : daytime",											  "not available"											  ]
[ "diff",			  "COMMAND:   ",  "diff(date, date) : int",												  "returns the number of days between 'val1' and 'val2'."						  ]
[ "diff",			  "COMMAND:   ",  "diff(timestamp, timestamp) : lng",											  "returns the number of milliseconds between 'val1' and 'val2' (!DS2.2)."				  ]
[ "dst",			  "COMMAND:   ",  "dst(timestamp, tzone) : bit",											  "return whether DST holds in the tzone at a certain point of time (!DS2.2)."				  ]
[ "end_dst",			  "COMMAND:   ",  "end_dst(tzone) : rule",												  "extract rule that determines end of DST from tzone (!DS2.2)."					  ]
[ "epoch",			  "PROC:      ",  "epoch(timestamp) : int",												  "not available"											  ]
[ "hours",			  "COMMAND:   ",  "hours(daytime) : int",												  "extracts hour from daytime (value between 0 and 23)"							  ]
[ "hours",			  "PROC:      ",  "hours(lng) : int",													  "not available"											  ]
[ "hours",			  "PROC:      ",  "hours(timestamp) : int",												  "not available"											  ]
[ "isnil",			  "COMMAND:   ",  "isnil(date) : bit",													  "date nil test (!DS2.2)"										  ]
[ "isnil",			  "COMMAND:   ",  "isnil(daytime) : bit",												  "daytime nil test (!DS2.2)"										  ]
[ "isnil",			  "COMMAND:   ",  "isnil(timestamp) : bit",												  "timestamp nil test (!DS2.2)"										  ]
[ "local_timezone",		  "PROC:      ",  "local_timezone() : lng",												  "not available"											  ]
[ "milliseconds",		  "COMMAND:   ",  "milliseconds(daytime) : int",											  "extracts milliseconds from daytime (value between 0 and 999)"					  ]
[ "milliseconds",		  "PROC:      ",  "milliseconds(timestamp) : int",											  "not available"											  ]
[ "minutes",			  "COMMAND:   ",  "minutes(daytime) : int",												  "extracts minutes from daytime (value between 0 and 59)"						  ]
[ "minutes",			  "COMMAND:   ",  "minutes(rule) : int",												  "extract minutes from rule (!DS2.2)."									  ]
[ "minutes",			  "COMMAND:   ",  "minutes(tzone) : int",												  "extract number of minutes that tzone is offset wrt GMT (!DS2.2)."					  ]
[ "minutes",			  "PROC:      ",  "minutes(lng) : int",													  "not available"											  ]
[ "minutes",			  "PROC:      ",  "minutes(timestamp) : int",												  "not available"											  ]
[ "monettime_synonyms",		  "COMMAND:   ",  "monettime_synonyms(bit) : void",											  "Allow synonyms for the parse format of date/timestamp in addition ot their print format (!DS2.2)."	  ]
[ "month",			  "COMMAND:   ",  "month(date) : int",													  "extracts month from date (value between 1 and 12)"							  ]
[ "month",			  "COMMAND:   ",  "month(rule) : int",													  "extract month from rule (!DS2.2)."									  ]
[ "month",			  "PROC:      ",  "month(int) : int",													  "not available"											  ]
[ "month",			  "PROC:      ",  "month(timestamp) : int",												  "not available"											  ]
[ "monthname",			  "COMMAND:   ",  "monthname(int) : str",												  "Returns month name from a number between [1-12], str(nil) otherwise (!DS2.2)."			  ]
[ "monthnum",			  "COMMAND:   ",  "monthnum(str) : int",												  "Returns month number [1-12] from a string; or nil if does not match any (!DS2.2)."			  ]
[ "msec",			  "COMMAND:   ",  "msec() : lng",													  "get time of day in milliseconds since 1-1-1970."							  ]
[ "msecs",			  "PROC:      ",  "msecs(int, int, int, int, int) : lng",										  "not available"											  ]
[ "olddate",			  "COMMAND:   ",  "olddate(str) : date",												  "create a date from the old instant format."								  ]
[ "oldduration",		  "COMMAND:   ",  "oldduration(str) : int",												  "parse the old duration format and return an (estimated) number of days."				  ]
[ "rule",			  "COMMAND:   ",  "rule(int, int, int, int) : rule",											  "create a DST start/end date rule. (!DS2.2)"								  ]
[ "rule",			  "PROC:      ",  "rule(int, int, int, int, int) : rule",										  "not available"											  ]
[ "rule",			  "PROC:      ",  "rule(int, str, int, int) : rule",											  "not available"											  ]
[ "rule",			  "PROC:      ",  "rule(int, str, int, int, int) : rule",										  "not available"											  ]
[ "seconds",			  "COMMAND:   ",  "seconds(daytime) : int",												  "extracts seconds from daytime (value between 0 and 59)"						  ]
[ "seconds",			  "PROC:      ",  "seconds(lng) : int",													  "not available"											  ]
[ "seconds",			  "PROC:      ",  "seconds(timestamp) : int",												  "not available"											  ]
[ "start_dst",			  "COMMAND:   ",  "start_dst(tzone) : rule",												  "extract rule that determines start of DST from tzone (!DS2.2)."					  ]
[ "time_add_sec_interval",	  "PROC:      ",  "time_add_sec_interval(daytime, lng) : daytime",									  "not available"											  ]
[ "time_sub_sec_interval",	  "PROC:      ",  "time_sub_sec_interval(daytime, lng) : daytime",									  "not available"											  ]
[ "timestamp",			  "COMMAND:   ",  "timestamp(date, daytime) : timestamp",										  "creates a timestamp from (date,daytime) parameters (in the local timezone)."				  ]
[ "timestamp",			  "COMMAND:   ",  "timestamp(date, daytime, tzone) : timestamp",									  "creates a timestamp from (date,daytime,tzone) parameters (!DS2.2)."					  ]
[ "timestamp",			  "PROC:      ",  "timestamp(date) : timestamp",											  "not available"											  ]
[ "timestamp",			  "PROC:      ",  "timestamp(int) : timestamp",												  "not available"											  ]
[ "timestamp",			  "PROC:      ",  "timestamp(lng) : timestamp",												  "not available"											  ]
[ "timestamp_add_sec_interval",	  "PROC:      ",  "timestamp_add_sec_interval(timestamp, lng) : timestamp",								  "not available"											  ]
[ "timestamp_sub_month_interval", "PROC:      ",  "timestamp_sub_month_interval(timestamp, int) : timestamp",								  "not available"											  ]
[ "timestamp_sub_sec_interval",	  "PROC:      ",  "timestamp_sub_sec_interval(timestamp, lng) : timestamp",								  "not available"											  ]
[ "tzone",			  "COMMAND:   ",  "tzone(int) : tzone",													  "create a tzone as a simple hour difference from GMT. (!DS2.2)"					  ]
[ "tzone",			  "COMMAND:   ",  "tzone(int, rule, rule) : tzone",											  "create a tzone as an hour difference from GMT and a DST. (!DS2.2)"					  ]
[ "tzone_local",		  "COMMAND:   ",  "tzone_local() : tzone",												  "get the local tzone; which is used for printing timestamps (!DS2.2)"					  ]
[ "tzone_local",		  "COMMAND:   ",  "tzone_local(tzone) : void",												  "set the local tzone; which is used for printing timestamps (!DS2.2)"					  ]
[ "weekday",			  "COMMAND:   ",  "weekday(rule) : int",												  "extract weekday from rule (!DS2.2)."									  ]
[ "weekofyear",			  "COMMAND:   ",  "weekofyear(date) : int",												  "Returns the week number in the year."								  ]
[ "year",			  "COMMAND:   ",  "year(date) : int",													  "extracts year from date (nonzero value between -5867411 and +5867411)."				  ]
[ "year",			  "PROC:      ",  "year(int) : int",													  "not available"											  ]
[ "year",			  "PROC:      ",  "year(timestamp) : int",												  "not available"											  ]

Module: "pcl"

[ 8 ]
[ 8 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature					help								  # name
# str			str		str						str								  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "pcl_eventname",	  "COMMAND:   ",  "pcl_eventname(int) : str",			  "return name of given event number"				  ]
[ "pcl_info",		  "COMMAND:   ",  "pcl_info() : BAT[str,str]",			  "get information about the processor in use"			  ]
[ "pcl_query",		  "COMMAND:   ",  "pcl_query(BAT[int,any], int) : BAT[int,int]",  "query for existing events"					  ]
[ "pcl_start",		  "COMMAND:   ",  "pcl_start(BAT[int,any], int) : void",	  "start counting the given events"				  ]
[ "pcl_start_rates",	  "COMMAND:   ",  "pcl_start_rates(BAT[int,any], int) : void",	  "start counting the events needed for the given rates"	  ]
[ "pcl_stop",		  "COMMAND:   ",  "pcl_stop(BAT[int,any]) : BAT[int,lng]",	  "stop counting and return the counts for the given events."	  ]
[ "pcl_stop_rates",	  "COMMAND:   ",  "pcl_stop_rates(BAT[int,any]) : BAT[int,dbl]",  "stop event counters and return the requested rates."		  ]
[ "pcl_try",		  "COMMAND:   ",  "pcl_try(BAT[int,any], int) : bit",		  "try wheter the events could be started together on this CPU"	  ]

Module: "pcre"

[ 10 ]
[ 10 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature							help								  # name
# str		str		str								str								  # type
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "pcre_compile", "COMMAND:   ",  "pcre_compile(str) : pcre",					  "compile a pattern"						  ]
[ "pcre_match",	  "COMMAND:   ",  "pcre_match(pcre, str) : bit",				  "match a pattern"						  ]
[ "pcre_match",	  "COMMAND:   ",  "pcre_match(str, str) : bit",						  "POSIX pattern matching against a string"																																																																																							  ]
[ "pcre_match",	  "COMMAND:   ",  "pcre_match(str, str, str) : bit",					  "POSIX pattern matching against a string, with flags (see 'man pcreapi')"																																																																																																																									  ]
[ "pcre_quote",	  "COMMAND:   ",  "pcre_quote(str) : str",						  "Return a PCRE pattern string that matches the argument exactly."																																																																																				  ]
[ "pcre_replace", "COMMAND:   ",  "pcre_replace(BAT[any::1,str], str, str, str) : BAT[any::1,str]",	  "Replace _all_ matches of \"pattern\" in every string contained in\\n   \"origin_strs\" with \"replacement\".\n\\n   If no matches found in a string, the string is copied to the returned BAT."																																																																				  ]
[ "pcre_replace", "COMMAND:   ",  "pcre_replace(str, str, str, str) : str",				  "Replace _all_ matches of \"pattern\" in \"origin_str\" with\\n\t\"replacement\".\n\\n    Parameter \"flags\" accept these flags: 'i', 'm', 's', and 'x'.\n\\n    'e': if present, an empty string is considered to be a valid\\n         match\n\\n    'i': if present, the match operates in case-insensitive mode.\\n         Otherwise, in case-sensitive mode.\n\\n    'm': if present, the match operates in multi-line mode.\n\\n    's': if present, the match operates in \"dot-all\"\n\\n    'x': if present, whitespace characters (#x9, #xA, #xD and #x20) in\\n         the regular expression are removed prior to matching with one \\n         exception: whitespace characters within character class \\n         expressions are not removed.\\n\tThe specifications of the flags can be found in \"man pcreapi\"\n\\n\tThe flag letters may be repeated.\n\\n\tNo other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \"flags\".\n\\n\tReturns the replaced string, or if no matches found, the original string."	  ]
[ "pcre_select",  "COMMAND:   ",  "pcre_select(str, BAT[any::1,str]) : BAT[any::1,str]",	  "Select tuples based on the pattern"				  ]
[ "pcre_uselect", "COMMAND:   ",  "pcre_uselect(str, BAT[any::1,str]) : BAT[any::1,void]",	  "Select tuples based on the pattern, only returning the head"	  ]
[ "sql2pcre",	  "COMMAND:   ",  "sql2pcre(str, str) : str",						  "Convert a SQL like pattern with the given escape character into a PCRE pattern."																																																																																		  ]

Module: "pqueue"

[ 116 ]
[ 116 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# tmp_35				tmp_36		tmp_37							tmp_40											  # name
# str				str		str							str											  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,any]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,bte]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,chr]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,dbl]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,flt]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,int]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,lng]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,oid]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,ptr]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,sht]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,wrd]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,any]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,bte]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,chr]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,dbl]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,flt]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,int]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,lng]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,oid]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,ptr]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,sht]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,wrd]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,any], oid, any) : void",	  "Inserts element (oid,any) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,bte], oid, bte) : void",	  "Inserts element (oid,bte) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,chr], oid, chr) : void",	  "Inserts element (oid,chr) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,dbl], oid, dbl) : void",	  "Inserts element (oid,dbl) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,flt], oid, flt) : void",	  "Inserts element (oid,flt) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,int], oid, int) : void",	  "Inserts element (oid,int) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,lng], oid, lng) : void",	  "Inserts element (oid,lng) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,oid], oid, oid) : void",	  "Inserts element (oid,oid) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,ptr], oid, ptr) : void",	  "Inserts element (oid,ptr) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,sht], oid, sht) : void",	  "Inserts element (oid,sht) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,wrd], oid, wrd) : void",	  "Inserts element (oid,wrd) in the max-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,any], oid, any) : void",	  "Inserts element (oid,any) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,bte], oid, bte) : void",	  "Inserts element (oid,bte) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,chr], oid, chr) : void",	  "Inserts element (oid,chr) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,dbl], oid, dbl) : void",	  "Inserts element (oid,dbl) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,flt], oid, flt) : void",	  "Inserts element (oid,flt) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,int], oid, int) : void",	  "Inserts element (oid,int) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,lng], oid, lng) : void",	  "Inserts element (oid,lng) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,oid], oid, oid) : void",	  "Inserts element (oid,oid) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,ptr], oid, ptr) : void",	  "Inserts element (oid,ptr) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,sht], oid, sht) : void",	  "Inserts element (oid,sht) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,wrd], oid, wrd) : void",	  "Inserts element (oid,wrd) in the min-pqueue"						  ]
[ "pqueue_init",		  "COMMAND:   ",  "pqueue_init(BAT[void,any::1], wrd) : BAT[oid,any::1]", "Creates an initially empty pqueue of bat a's tailtype with maximum size maxsize"	  ]
[ "pqueue_init",		  "PROC:      ",  "pqueue_init(BAT[void,any::1], int) : BAT[oid,any::1]", "not available"									  ]
[ "pqueue_peek",		  "PROC:      ",  "pqueue_peek(BAT[oid,any]) : any",			  "not available"									  ]
[ "pqueue_topn",		  "PROC:      ",  "pqueue_topn(BAT[oid,any], int, int) : BAT[oid,any]",	  "not available"									  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,any], int) : BAT[oid,any]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,bte], int) : BAT[oid,bte]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,chr], int) : BAT[oid,chr]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,dbl], int) : BAT[oid,dbl]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,flt], int) : BAT[oid,flt]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,int], int) : BAT[oid,int]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,lng], int) : BAT[oid,lng]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,oid], int) : BAT[oid,oid]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,ptr], int) : BAT[oid,ptr]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,sht], int) : BAT[oid,sht]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,wrd], int) : BAT[oid,wrd]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,any], int) : BAT[oid,any]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,bte], int) : BAT[oid,bte]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,chr], int) : BAT[oid,chr]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,dbl], int) : BAT[oid,dbl]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,flt], int) : BAT[oid,flt]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,int], int) : BAT[oid,int]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,lng], int) : BAT[oid,lng]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,oid], int) : BAT[oid,oid]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,ptr], int) : BAT[oid,ptr]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,sht], int) : BAT[oid,sht]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,wrd], int) : BAT[oid,wrd]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,any], int) : BAT[oid,any]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,bte], int) : BAT[oid,bte]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,chr], int) : BAT[oid,chr]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,dbl], int) : BAT[oid,dbl]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,flt], int) : BAT[oid,flt]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,int], int) : BAT[oid,int]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,lng], int) : BAT[oid,lng]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,oid], int) : BAT[oid,oid]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,ptr], int) : BAT[oid,ptr]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,sht], int) : BAT[oid,sht]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,wrd], int) : BAT[oid,wrd]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,any], int) : BAT[oid,any]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,bte], int) : BAT[oid,bte]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,chr], int) : BAT[oid,chr]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,dbl], int) : BAT[oid,dbl]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,flt], int) : BAT[oid,flt]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,int], int) : BAT[oid,int]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,lng], int) : BAT[oid,lng]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,oid], int) : BAT[oid,oid]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,ptr], int) : BAT[oid,ptr]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,sht], int) : BAT[oid,sht]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,wrd], int) : BAT[oid,wrd]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,any], oid, any) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,bte], oid, bte) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,chr], oid, chr) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,dbl], oid, dbl) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,flt], oid, flt) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,int], oid, int) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,lng], oid, lng) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,oid], oid, oid) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,ptr], oid, ptr) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,sht], oid, sht) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,wrd], oid, wrd) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,any], oid, any) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,bte], oid, bte) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,chr], oid, chr) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,dbl], oid, dbl) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,flt], oid, flt) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,int], oid, int) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,lng], oid, lng) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,oid], oid, oid) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,ptr], oid, ptr) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,sht], oid, sht) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,wrd], oid, wrd) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "test_pqueue",		  "PROC:      ",  "test_pqueue() : void",				  "not available"									  ]
[ "test_pqueue_str",		  "PROC:      ",  "test_pqueue_str() : void",				  "not available"									  ]

Module: "profiler"

[ 9 ]
[ 9 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature				help									  # name
# str			str		str					str									  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "getProfilerCount",	  "COMMAND:   ",  "getProfilerCount() : BAT[str,int]",	  "Get a copy of the profiler count summary table"			  ]
[ "getProfilerTicks",	  "COMMAND:   ",  "getProfilerTicks() : BAT[str,lng]",	  "Get a copy of the profiler ticks summary table"			  ]
[ "profile",		  "PROC:      ",  "profile() : int",			  "not available"							  ]
[ "resetProfiler",	  "COMMAND:   ",  "resetProfiler() : void",		  "Set all counters to zero again"					  ]
[ "setFilter",		  "COMMAND:   ",  "setFilter(str, str) : int",		  "Set the profile filter strings"					  ]
[ "startProfiler",	  "COMMAND:   ",  "startProfiler() : void",		  "Collect command and proc counts"					  ]
[ "startProfiler",	  "COMMAND:   ",  "startProfiler(Stream) : int",	  "Start the event profiling stream; output is sent to Stream output"	  ]
[ "startProfiler",	  "COMMAND:   ",  "startProfiler(str) : int",		  "Start the event profiling stream; output is sent to fname"		  ]
[ "stopProfiler",	  "COMMAND:   ",  "stopProfiler() : int",		  "Stop the event profiling stream"					  ]

Module: "stats"

[ 5 ]
[ 5 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------#
# function				type		signature						help					  # name
# str				str		str							str					  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[stats_add]",		  "COMMAND:   ",  "[stats_add](ptr, lng) : void",			  "Add a value to a statistics object."	  ]
[ "[stats_del]",		  "COMMAND:   ",  "[stats_del](ptr) : void",				  "Delete a statistics object."		  ]
[ "[stats_histogram_new]",	  "COMMAND:   ",  "[stats_histogram_new](str, int, int, lng) : ptr",	  "Construct a new statistics object."	  ]
[ "[stats_new]",		  "COMMAND:   ",  "[stats_new](str) : ptr",				  "Construct a new statistics object."	  ]
[ "[stats_report]",		  "COMMAND:   ",  "[stats_report](ptr, str) : void",			  "Generate results."			  ]

Module: "streams"

[ 31 ]
[ 31 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature						help									  # name
# str			str		str							str									  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "block_stream",	  "COMMAND:   ",  "block_stream(Stream) : Stream",			  "open a block based stream"						  ]
[ "bstream_create",	  "COMMAND:   ",  "bstream_create(Stream, int) : Bstream",		  "create a buffered stream"						  ]
[ "bstream_destroy",	  "COMMAND:   ",  "bstream_destroy(Bstream) : void",			  "destroy bstream"							  ]
[ "bstream_read",	  "COMMAND:   ",  "bstream_read(Bstream, int) : int",			  "read atleast size bytes into the buffer of s"			  ]
[ "fgetc",		  "COMMAND:   ",  "fgetc(Stream) : int",				  "See: man fgetc"							  ]
[ "fgets",		  "COMMAND:   ",  "fgets(Stream) : str",				  "See: man fgets"							  ]
[ "fprintf",		  "COMMAND:   ",  "fprintf(Stream, str, ..any..) : void",		  "See: man fprintf"							  ]
[ "ftable",		  "COMMAND:   ",  "ftable(Stream, ..BAT[any::1,any]..) : void",		  "Print an n-ary table to a file."					  ]
[ "ftable",		  "COMMAND:   ",  "ftable(Stream, int, ..BAT[any::1,any]..) : void",	  "Print an n-ary table to a file, using order of BAT [1..argc]."	  ]
[ "fwrite",		  "COMMAND:   ",  "fwrite(Stream, str, int) : void",			  "See: man fwrite"							  ]
[ "open_rastream",	  "COMMAND:   ",  "open_rastream(str) : Stream",			  "open ascii file stream for reading"					  ]
[ "open_rstream",	  "COMMAND:   ",  "open_rstream(str) : Stream",				  "open a file stream for reading"					  ]
[ "open_wastream",	  "COMMAND:   ",  "open_wastream(str) : Stream",			  "open ascii file stream for writing"					  ]
[ "open_wstream",	  "COMMAND:   ",  "open_wstream(str) : Stream",				  "open a file stream for writing"					  ]
[ "socket_rastream",	  "COMMAND:   ",  "socket_rastream(int, str) : Stream",			  "open ascii socket stream for reading"				  ]
[ "socket_rstream",	  "COMMAND:   ",  "socket_rstream(int, str) : Stream",			  "open a socket stream for reading"					  ]
[ "socket_wastream",	  "COMMAND:   ",  "socket_wastream(int, str) : Stream",			  "open ascii socket stream for writing"				  ]
[ "socket_wstream",	  "COMMAND:   ",  "socket_wstream(int, str) : Stream",			  "open a socket stream for writing"					  ]
[ "stderr",		  "COMMAND:   ",  "stderr() : Stream",					  "return the error stream for the database console"			  ]
[ "stdin",		  "COMMAND:   ",  "stdin() : Stream",					  "return the input stream to the database client"			  ]
[ "stdout",		  "COMMAND:   ",  "stdout() : Stream",					  "return the output stream for the database client"			  ]
[ "stream_close",	  "COMMAND:   ",  "stream_close(Stream) : void",			  "close and destroy the stream s"					  ]
[ "stream_flush",	  "COMMAND:   ",  "stream_flush(Stream) : void",			  "flush the stream"							  ]
[ "stream_read",	  "COMMAND:   ",  "stream_read(Stream) : str",				  "read data from the stream"						  ]
[ "stream_readInt",	  "COMMAND:   ",  "stream_readInt(Stream) : int",			  "read an integer from the stream"					  ]
[ "stream_readLng",	  "COMMAND:   ",  "stream_readLng(Stream) : lng",			  "read a long integer from the stream"					  ]
[ "stream_rstream",	  "COMMAND:   ",  "stream_rstream(Stream) : Stream",			  "convert an ascii stream to binary"					  ]
[ "stream_write",	  "COMMAND:   ",  "stream_write(Stream, str) : void",			  "write data on the stream"						  ]
[ "stream_writeInt",	  "COMMAND:   ",  "stream_writeInt(Stream, int) : void",		  "write an integer on the stream"					  ]
[ "stream_writeLng",	  "COMMAND:   ",  "stream_writeLng(Stream, lng) : void",		  "write a long integer on the stream"					  ]
[ "stream_wstream",	  "COMMAND:   ",  "stream_wstream(Stream) : Stream",			  "convert an ascii stream to binary"					  ]

Module: "unix"

[ 2 ]
[ 2 ]
#---------------------------------------------------------------------------------------------------------#
# function		type		signature			help					  # name
# str		str		str				str					  # type
#---------------------------------------------------------------------------------------------------------#
[ "getenv",	  "COMMAND:   ",  "getenv(str) : str",		  "Get the environment variable string."  ]
[ "setenv",	  "COMMAND:   ",  "setenv(str, str) : bit",	  "Set the environment variable string."  ]

Module: "url"

[ 20 ]
[ 20 ]
#---------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature				help							  # name
# str		str		str					str							  # type
#---------------------------------------------------------------------------------------------------------------------------------#
[ "escape",	  "COMMAND:   ",  "escape(str) : str",			  "Convert characters in the given STR which have special meanings in a URL to their hexadecimal values"  ]
[ "getAnchor",	  "COMMAND:   ",  "getAnchor(url) : str",		  "Extract the anchor (reference) from the URL"		  ]
[ "getBasename",  "COMMAND:   ",  "getBasename(url) : str",		  "Extract the base file name of the URL"		  ]
[ "getContent",	  "COMMAND:   ",  "getContent(url) : str",		  "Get the URL resource in a local file"		  ]
[ "getContext",	  "COMMAND:   ",  "getContext(url) : str",		  "Get the path context of a URL "			  ]
[ "getDirectory", "COMMAND:   ",  "getDirectory(url) : BAT[int,str]",	  "Extract the directory names from the URL"		  ]
[ "getDomain",	  "COMMAND:   ",  "getDomain(url) : str",		  "Extract the Internet domain from the URL"		  ]
[ "getExtension", "COMMAND:   ",  "getExtension(url) : str",		  "Extract the file extension of the URL"		  ]
[ "getFile",	  "COMMAND:   ",  "getFile(url) : str",			  "Extract the last file name of the URL"		  ]
[ "getHost",	  "COMMAND:   ",  "getHost(url) : str",			  "Extract the server identity from the URL"		  ]
[ "getPort",	  "COMMAND:   ",  "getPort(url) : str",			  "Extract the port id from the URL"			  ]
[ "getProtocol",  "COMMAND:   ",  "getProtocol(url) : str",		  "Extract the protocol from the URL"			  ]
[ "getQuery",	  "COMMAND:   ",  "getQuery(url) : str",		  "Extract the query string from the URL"		  ]
[ "getQueryArg",  "COMMAND:   ",  "getQueryArg(url) : BAT[str,str]",	  "Extract the argument mappings from the URL"		  ]
[ "getRobotURL",  "COMMAND:   ",  "getRobotURL(url) : str",		  "Extract the location of the robot control file"	  ]
[ "getUser",	  "COMMAND:   ",  "getUser(url) : str",			  "Extract the user identity from the URL"		  ]
[ "isaURL",	  "COMMAND:   ",  "isaURL(url) : bit",			  "Check conformity of the URL syntax"			  ]
[ "newurl",	  "COMMAND:   ",  "newurl(str, str, int, str) : url",	  "Construct a URL from protocol, host,port,and file"	  ]
[ "newurl",	  "COMMAND:   ",  "newurl(str, str, str) : url",	  "Construct a URL from protocol, host,and file"	  ]
[ "unescape",	  "COMMAND:   ",  "unescape(str) : str",		  "Convert the hexadecimal values in the given STR to ASCI chracters"					  ]

Module: "xtables"

[ 24 ]
[ 24 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature									help																																						  # name
# str			str		str										str																																						  # type
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "CTderive",		  "COMMAND:   ",  "CTderive(grp, BAT[oid,any]) : grp",						  "Cross tabulation group extension step.\nReturned head values are identical as in 'ct'. Tail values are from\nthe same domain and indicate further refinement of the groups in 'ct',\ntaking into account also the tail-values in 'attr'."						  ]
[ "CTderive",		  "PROC:      ",  "CTderive(BAT[oid,any], BAT[oid,any]) : grp",					  "not available"																																	  ]
[ "CTextend",		  "COMMAND:   ",  "CTextend(grp) : BAT[oid,any]",						  "Return the group extend."																																  ]
[ "CTgroup",		  "COMMAND:   ",  "CTgroup(BAT[oid,any]) : grp",						  "Cross tabulation group initialization.\nReturned head values are identical as in 'attr'. Tail values are from\nthe same domain and indicate unique groups in 'attr' tail column."													  ]
[ "CTgroup",		  "COMMAND:   ",  "CTgroup(grp, BAT[oid,any]) : grp",						  "binary grouping; a synonym for CTderive(ct,attr)"																													  ]
[ "CTgroup",		  "PROC:      ",  "CTgroup(BAT[oid,any], BAT[oid,any]) : grp",					  "not available"																																	  ]
[ "CThistogram",	  "COMMAND:   ",  "CThistogram(grp) : BAT[any,int]",						  "Return the groups histogram."																															  ]
[ "CThistosum",		  "COMMAND:   ",  "CThistosum(BAT[oid,oid], BAT[oid,int]) : BAT[oid,int]",			  "Produce sum over old histogram table"																																	  ]
[ "CTmap",		  "COMMAND:   ",  "CTmap(grp) : BAT[oid,oid]",							  "Return the group map."																																  ]
[ "CTorderby",		  "PROC:      ",  "CTorderby(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",			  "not available"																																				  ]
[ "CTorderby_rev",	  "PROC:      ",  "CTorderby_rev(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",			  "not available"																																				  ]
[ "CTrefine",		  "COMMAND:   ",  "CTrefine(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",			  "refine the ordering of a tail-ordered BAT by sub-ordering on the\nvalues of a second bat 'a' (where the heads of a and b match 1-1).\nThe effect of this is similar to (hash-based) CTderive, with the\ndistinction that the group ids respect the ordering of the group values."	  ]
[ "CTrefine_rev",	  "COMMAND:   ",  "CTrefine_rev(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",			  "reverse sorting version of CTrefine"																																		  ]
[ "CTsubgroup",		  "PROC:      ",  "CTsubgroup(BAT[oid,oid], BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",	  "not available"																																				  ]
[ "CTsubhisto",		  "COMMAND:   ",  "CTsubhisto(BAT[void,bit], BAT[void,oid], BAT[oid,any]) : BAT[oid,int]",	  "optimized sub-histogram for synced grp[void,oid] and sel[void,bit]\nbats on a previously known domain "																								  ]
[ "_CTgroup",		  "COMMAND:   ",  "_CTgroup(BAT[oid,any], int, int) : grp",					  "Cross tabulation group initialization like CTgroup, but with user\nprovided #bits in hashmask and #distinct values in range."																			  ]
[ "extend",		  "PROC:      ",  "extend(grp) : BAT[any,int]",							  "not available"																																	  ]
[ "histogram",		  "PROC:      ",  "histogram(grp) : BAT[any,int]",						  "not available"																																	  ]
[ "map",		  "PROC:      ",  "map(grp) : BAT[oid,oid]",							  "not available"																																	  ]
[ "orderby_table",	  "PROC:      ",  "orderby_table(str, str, ..BAT[any::1,any]..) : void",			  "not available"																																				  ]
[ "print",		  "PROC:      ",  "print(str, BAT[any::1,any], ..BAT[any::1,any]..) : void",			  "not available"																																				  ]
[ "table",		  "PROC:      ",  "table(str, BAT[any::1,any], ..BAT[any::1,any]..) : void",			  "not available"																																				  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[oid,bit], BAT[oid,oid], BAT[oid,int]) : BAT[oid,int]",		  "not available"																																				  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[void,bit], BAT[void,oid], BAT[oid,int]) : BAT[oid,int]",		  "not available"																																				  ]

quit();

# 18:28:13 >  
# 18:28:13 >  Done.
# 18:28:13 >  

