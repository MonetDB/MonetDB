@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2006 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$

@f prec_foll
@a Henning Rode
@t prec_foll

@c

/*******************************************
* prec_foll.c : axis step operators for preceding and following axis
*
*/
#include <gdk.h>

/**
 * This file contains the axis step algoritms for following and
 * preceding axis.
 * 
 * Both algorithms work similiar to the staircase-join approach:
 * 
 * - evaluation is done during a single sequential scan of the
 *   level table and the context set
 * - context set pruning is performed on-the-fly
 * 
 * Unlike the staircasejoins for ancestor and desecendant steps
 * we have to take care about the limitations of document fragments.
 * Nodes on the following axis of x, are all nodes with
 * pre(v) > pre(x) + size(x),
 * but only that nodes qualify, that belong to the same document fragment
 * as x itself.
 */

/* FOLLOWING STEP */
@:head(following)@
    oid min_post;
@:specialcases@
@:init@
    min_post = INT_MAX;
    pre_cur = 0;
    
    /* ---------------------------- main part ----------------------------- 
     * - the outer loop traverses all context nodes
     * - if a context node with minimal postorder rank is found
     *   we search for the limit of the corresponding document fragment
     *   and copy all nodes with preorder rank < limit to the result
     * - all further context nodes in the same document fragment are
     *   skipped
     */

    while (ctx_cur <= ctx_last)
    {
        ctx_pre = *(oid*)BUNhead(ctx, ctx_cur);

        if (ctx_pre < min_post)
        {
            min_post = ctx_pre + size[ctx_pre];
            pre_cur = min_post + 1;
            ctx_cur += ctx_bunsize;
        }
        else
        {
@:docbounds_hi(&pre_cur,doc_hi)@
            
            /* copy nodes to result */
            while (pre_cur < doc_hi)
                *res_cur++ = pre_cur++;
        
            /* skip context nodes in the same document fragment */
            while ((ctx_cur <= ctx_last) && (*(oid*)BUNhead(ctx, ctx_cur) < doc_hi))
                ctx_cur += ctx_bunsize;
            
            /* reset post value */    
            min_post = INT_MAX;
        }
    }
    
    /* handling of the last context node, in case it has a minimal postorder
       rank within its document fragment */
    if (min_post < INT_MAX)
    {
@:docbounds_hi(&pre_cur,doc_hi)@
        
        /* copy nodes to result */
        while (pre_cur < doc_hi)
            *res_cur++ = pre_cur++;
    }

@:end@

/* PRECEDING STEP */
@:head(preceding)@
    oid ctx_prev, post, doc_lo;
@:specialcases@
@:init@
    
    /* ---------------------------- main part ----------------------------- 
     * - the outer loop traverses all context nodes
     * - if the context node with maximal postorder rank in the current
     *   document fragment is found, we scan the document partition of
     *   that context node for preceding nodes.
     * - all other context nodes are pruned.
     */
    
    ctx_pre = *(oid*)BUNhead(ctx, ctx_cur);

@:docbounds_lo_hi(&ctx_pre,doc_lo,doc_hi)@

    ctx_prev = ctx_pre;
    ctx_cur += ctx_bunsize;
            
    while (ctx_cur <= ctx_last)
    {
        ctx_pre = *(oid*)BUNhead(ctx, ctx_cur);
        
        /* search for last context node within current document fragement */
        if (ctx_pre < doc_hi)
        {
            ctx_prev = ctx_pre;
            ctx_cur += ctx_bunsize;
        } 
        
        /* start collecting preceding nodes from the beginning
         * of the document fragment.
         * we can copy preceding nodes and their descendants to the result,
         * but have to skip ancestors */
        else
        {
       
            pre_cur = doc_lo;
            
            while (pre_cur < ctx_prev)
            {
                if (ctx_prev > (post = pre_cur + size[pre_cur]))
                    while (pre_cur <= post)
                        *res_cur++ = pre_cur++;
                else pre_cur++;        
            }
            
            /* determine document fragment of current context node */
@:docbounds_lo_hi(&ctx_pre,doc_lo,doc_hi)@

        }
    }
    
    /* handling of last context node */
    pre_cur = *(oid*)BUNtail(doc_pre, doc_cur);
    
    while (pre_cur < ctx_prev)
    {
        if (ctx_prev > (post = pre_cur + size[pre_cur]))
            while (pre_cur <= post)
                *res_cur++ = pre_cur++;
        else pre_cur++;        
    }

@:end@
@-

PARAMETERS: function name
@= head
int
PF@1_void(BAT **result, BAT *pre_size, BAT *ctx, BAT *doc_pre, int *height, int *upperbound)
{
    /* --------------------------- declaration ----------------------------- */

    char *name = "PF_@1_void";
    BUN ctx_cur, ctx_last, doc_cur, doc_last;
    oid pre_cur, *res_cur, ctx_pre, doc_hi;
    int ctx_bunsize, doc_bunsize, *size;
    
    /* result bat allocation. for result size use upperbound parameter */
    BAT *res = BATnew(TYPE_oid, TYPE_void, *upperbound);

@= specialcases
    /* --------------------------- special cases --------------------------- */
    if (!(BAThordered(ctx) & 1))
    {
        GDKerror("%s: context must be ordered on head.\n", name);
        return GDK_FAIL;
    }
    if (BATcount(ctx) == 0 || BATcount(pre_size) == 0)
    {
        *result = BATnew(TYPE_oid, TYPE_void, 0);
        return GDK_SUCCEED;
    }
    if (res == NULL) 
    { 
        GDKerror("%s: could not allocate a result BAT of size %d.\n", name, *upperbound);
        return GDK_FAIL;
    }

@= init
    /* ----------------- initialization of table cursors ------------------- */

    ctx_bunsize = BUNsize(ctx);
    ctx_cur = BUNfirst(ctx);
    ctx_last = BUNlast(ctx) - ctx_bunsize;
    doc_bunsize = BUNsize(doc_pre);
    doc_last = BUNlast(doc_pre) - doc_bunsize;
    
    res_cur = (oid*)BUNfirst(res);
    
    /* definition for "array-like" access on size values of given nodes */
    size = ((int*) BUNfirst(pre_size)) - pre_size->hseqbase;

    ALGODEBUG
        THRprintf(GDKout, "%s: node set of %u buns, context set of %u buns, height %u\n",
                          name, BATcount(pre_size), BATcount(ctx), *height);
@-
PARAMETERS: pointer to compared value, lower and, higher document limit 
@= docbounds_lo_hi
    /* SORTfndlast returns the BUN of doc_pre 
       with the smallest value higher than the 2nd parameter */
    doc_cur = SORTfndlast(doc_pre, @1) - doc_bunsize;
    @2 = *(oid*)BUNtail(doc_pre, doc_cur);
    @3 = (doc_cur < doc_last) ? 
             *(oid*)BUNtail(doc_pre, (doc_cur + doc_bunsize)) : 
             BATcount(pre_size);
@-
PARAMETERS: pointer to compared value, lower and, higher document limit 
@= docbounds_hi
    /* SORTfndlast returns the BUN of doc_pre 
       with the smallest value higher than the 2nd parameter */
    doc_cur = SORTfndlast(doc_pre, @1);
    @2 = (doc_cur <= doc_last) ? 
             *(oid*)BUNtail(doc_pre, doc_cur) : 
	     BATcount(pre_size);

@= end
    /* ---------------------------- end of main part --------------------------
     * tidy up and propagate result properties
     */

    /* mark the end point of the BUNs section in the BUNheap 
     */
    res->batBuns->free = ((BUN)res_cur) - res->batBuns->base;
    BATsetcount(res, (res->batBuns->free+Bunbase(res)-BUNfirst(res))/BUNsize(res));

    res->batDirty = TRUE;
    res->hsorted = GDK_SORTED;
    BATkey(res,TRUE);
    BATseqbase(BATmirror(res), oid_nil);
    *result = res;

    return GDK_SUCCEED;
}

@c
/* vim:set shiftwidth=4 expandtab: */
