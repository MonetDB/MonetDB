# pathfinder.mx
#
# Monet runtime support for the Pathfinder XQuery compiler
#
# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2004 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#
# $Id$
#

@f pathfinder
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@a Jan Flokstra
@a Jens Teubner
@t Runtime Support for the Pathfinder XQuery Compiler

@m
.MODULE pathfinder;

@:prec_foll(following)@
@:prec_foll(preceding)@

@= prec_foll
.COMMAND @1_void (BAT[void,int] pre_size,
               BAT[oid,any] ctx,
               BAT[void,oid] doc_pre,
	       int height,
               int upperbound) : BAT[oid,void] = PF@1_void;
"PARAMETERS
  pre_size: the complete size BAT (preorder rank, size)
  ctx: context node sequence (preorder rank, *)
  doc_pre: table of document fragments (doc id, preorder start value)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @1 axis from the given context."
@m
@:scj_cmd(descorself,descendant-or-self)@
@:scj_cmd(desc,descendant)@
@:scj_cmd(ancorself,ancestor-or-self)@
@:scj_cmd(anc,ancestor)@

@= scj_cmd
.COMMAND scj_@1(BAT[void,int] pre_size,
                BAT[oid,any] ctx,
                int height,
                int upperbound): BAT[oid,void] = PFscj_@1_void;
"PARAMETERS
  pre_size: the complete size BAT (preorder rank, size)
  ctx: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."
@m
@:lev_cmd(child,child)@
@:lev_cmd(parent,parent)@
@:lev_cmd(fs,following-sibling)@
@:lev_cmd(ps,preceding-sibling)@

@= lev_cmd
.COMMAND lev_@1(BAT[void,chr] pre_level,
                BAT[oid,any] ctx,
		int height,
                int upperbound) : BAT[oid,void] = PFlev_@1;
"PARAMETERS
  pre_level: the complete level BAT (preorder rank, level)
  ctx: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."
@m
.END pathfinder;

@mil
# load modules used in pathfinder.mx
module(xtables);
# FIXME: What is `pf_support' supposed to be? No such module exists on my
#        machine. Everything appears to work fine without this, though.
#module(pf_support);
module(malalgebra);

PROC get_type (bat[void,int] kind, int type_) : bat[oid,void]
{
        return kind.[and](63).ord_uselect(type_); # 63 = 2^6 - 1
}

PROC get_type_node (bat[void,int] kind) : bat[oid,void]
{
        return kind.ord_uselect(NODE, int(nil));
}

PROC get_type_atomic (bat[void,int] kind) : bat[oid,void]
{
        return kind.ord_uselect(int(nil), ATOMIC);
}

PROC get_fragment (bat[void,int] kind) : bat[void,oid]
{
        return kind.[>>](6).[oid]();
}

PROC get_kind (bat[void,oid] frag, int type_) : bat[void,int]
{
        return frag.[int]().[<<](6).[or](type_);
}

#PROC get_types (bat[void,int] kind) : bat[void,int]
#{
#        return kind.[and](63); # 63 = 2^6 - 1
#}

#PROC get_kind (bat[void,oid] frag, bat[void,int] type_) : bat[void,int]
#{
#        return frag.[int]().[<<](6).[or](type_);
#}

#PROC get_kind (int frag, bat[void,int] type_) : bat[void,int]
#{
#        return type_.[or](frag<<6);
#}

#
# Serialization function, mainly for debugging purposes.
#
# Serialization should probably be done in a more sophisticated fashion.
# For now we just implement it in MIL to have something for debugging.
# If for the final version we decide on different paraemters, the
# MIL generation code in the Pathfinder compiler should be adapted
# accordingly. Have a look at the top-level rule in milgen.mt.sed, and
# at the stuff related to PFmil_ser() in mil.c. The printing routines
# in milprint.c need to be adapted as well.
#
# Parameters:
#   prefix         The BAT prefix used in milgen.mt.sed
#   has_nat_part   true, if the type of this attribute contains the nat type.
#   has_int_part   true, if the type of this attribute contains the int type.
#   has_str_part   true, if the type of this attribute contains the str type.
#   has_node_part  true, if the type of this attribute contains the node type.
#   has_dec_part   true, if the type of this attribute contains the dec type.
#   has_dbl_part   true, if the type of this attribute contains the dbl type.
#   has_bln_part   true, if the type of this attribute contains the bln type.
#
PROC serialize (str prefix,
                bit has_nat_part, bit has_int_part, bit has_str_part,
                bit has_node_part, bit has_dec_part, bit has_dbl_part,
                bit has_bln_part) : void
{
    if (not (has_nat_part) and not (has_int_part) and not (has_str_part)
        and not (has_node_part) and not (has_dec_part) and not (has_dbl_part)
        and not (has_bln_part)) {
        print ("<empty result>");
        return;
    }

    var pos_oid := varval (prefix + "_pos_nat");
    var values := new (void, BAT);

    if (has_nat_part) { values.insert (nil, varval (prefix + "_item_nat")); }
    if (has_int_part) { values.insert (nil, varval (prefix + "_item_int")); }
    if (has_str_part) { values.insert (nil, varval (prefix + "_item_str")); }
    if (has_node_part) { values.insert (nil, varval (prefix + "_item_node")); }
    if (has_dec_part) { values.insert (nil, varval (prefix + "_item_dec")); }
    if (has_dbl_part) { values.insert (nil, varval (prefix + "_item_dbl")); }
    if (has_bln_part) { values.insert (nil, varval (prefix + "_item_bln")); }

    # Sort by pos column
    pos_oid := pos_oid.reverse().sort().reverse();

    pos_oid@batloop {
        var curr_oid := $h;

        values@batloop {
            $t.reverse().select (curr_oid).reverse@batloop {
                print ($t);
            }
        }
    }
}

ADDHELP("serialize", "teubner", "August 2004",
"PARAMETERS:\n\
prefix        - prefix of the top-level algebra result, as generated by pf,\n\
has_nat_part  - Does the result contain values of type `nat'?\n\
has_int_part  - Does the result contain values of type `int'?\n\
has_str_part  - Does the result contain values of type `str'?\n\
has_node_part - Does the result contain values of type `node'?\n\
has_dec_part  - Does the result contain values of type `dec'?\n\
has_dbl_part  - Does the result contain values of type `dbl'?\n\
has_bln_part  - Does the result contain values of type `bln'?\n\
\n\
DESCRIPTION:\n\
Serialize algebra expression. The pathfinder compiler generates MIL code\n\
that will produce variable bindings so that the expression result is\n\
available in BATs that all start with the same prefix (this is the first\n\
parameter of this procedure). There is a BAT <prefix>_iter_nat for the\n\
column `iter', a BAT <prefix>_pos_nat for the column `pos' (output will\n\
be sorted by this column), and a set of BATs <prefix>_item_<type>, one\n\
for each type for which the has_<type>_part variable has been set to\n\
true.\n\
NOTE: This implementation is mainly meant for debugging, it is far from\n\
efficient. Feel free to implement it the right way ;-).",
"pathfinder");


#############################################
# Document management functions
#
# - import_doc
# - delete_doc
# - delete_all_docs
# - compress_properties
# - create_ws
# - add_doc
#
# Each imported XML-document is stored as a collection of persistent BATs 
# whose name starts with the name of the BAT and ends with the document ID. 
# The execution of an XQuery is not performed on the persistent BATs, but on 
# the transient 'working set', a global document collection represented
# by the ws-BAT.
#
# Each collection contains the following BATs:
# - pre_size    : BAT[oid,int]  pre-value of node / and its descendant size,
# - pre_level   : BAT[oid,chr]  pre-value of node / and its level,
# - pre_prop    : BAT[oid,oid]  pre-value of node / and property ID,
# - pre_kind    : BAT[oid,chr]  pre-value of node / and property ID,
#
# - qn_ns        : BAT[oid,str]  property ID / and name space (elements and attributes),
# - qn_loc       : BAT[oid,str]  property ID / and local name (elements and attributes),
# - prop_text    : BAT[oid,str]  property ID / and text,
# - prop_com     : BAT[oid,str]  property ID / and comment,
# - prop_ins     : BAT[oid,str]  property ID / and processing instruction,
# - prop_tgt     : BAT[oid,str]  property ID / and processing instruction target,
#
# - attr_own  : BAT[oid,oid]  attribute ID / pre-value of owner
# - attr_qn   : BAT[oid,oid]  attribute ID / and qname/property ID
# - attr_prop : BAT[oid,oid]  attribute ID / value ID
#
# - prop_val  : BAT[oid,str]  value ID / value of attribute nodes
#
# Global information on persistent stored documents:
# - doc_name    : BAT[oid,str]  document ID / document name
# - doc_height  : BAT[oid,int]  document ID / height of document
# 
# Information on documents/fragments in the working set:
# - PRE_FRAG   : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each pre value (copied in element construction)
# - ATTR_FRAG  : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each attr value (copied in element/attribute 
#                construction)
# - DOC_LOADED : BAT[void,str] fragment ID / name of document 
#                (starts with 1@0 because WS is first 'loaded' document
# - FRAG       : BAT[void,oid] 0@0 / oid of the newest added fragment
# - WS_FRAG    : BAT[void,oid] enumeration / root-pre values of
#                generated element fragments
# - HEIGTH     : BAT[void,int] enumeration of the fragments / maximal
#                depth of the fragment (starts with 0@0 - WS)

# DEFINITION of constants concerning the data model
const PRE_BASE := 0@0;
const ELEMENT := chr(0);
const TEXT := chr(1);
const COMMENT := chr(2);
const PI := chr(3);
const DOCUMENT := chr(4);

# types in translation
const QNAME := 2;
const BOOL := 3;
const INT := 4;
const DEC := 5;
const DBL := 6;
const STR := 7;
# ATOMIC is not a type but all atomic types
# can be retrieved with 'select(int(nil),ATOMIC)'
const ATOMIC := 31;
# NODE is not a type but all node types
# can be retrieved with 'select(NODE,int(nil))'
const NODE := 32;
const ELEM := 33;
const ATTR := 34;

const WS := 0@0;

# don't switch the values without also changing the order in create_ws
const PRE_SIZE   :=  0;
const PRE_LEVEL  :=  1;
const PRE_PROP   :=  2;
const PRE_KIND   :=  3;
const PRE_FRAG   :=  4;
const QN_NS      :=  5;
const QN_LOC     :=  6;
const PROP_TEXT  :=  7;
const PROP_COM   :=  8;
const PROP_INS   :=  9;
const PROP_TGT   := 10;
const ATTR_OWN   := 11;
const ATTR_QN    := 12;
const ATTR_PROP  := 13;
const ATTR_FRAG  := 14;
const PROP_VAL   := 15;
const DOC_LOADED := 16;
const FRAG       := 17;
const WS_FRAG    := 18;
const HEIGHT     := 19;

PROC add_doc(BAT[void,bat] ws, str name) : BAT[void,bat]
{
    if (not(bat("doc_name").reverse().exist(name)))
        { ERROR("Document %s does not exist\n",name); }
    var docid := str(int(bat("doc_name").reverse().find(name)));
    
    var frag := ws.fetch(DOC_LOADED).uselect(name);
    if (frag.count() = 0)
    {
        ws.fetch(DOC_LOADED).insert(nil,name);
	frag := oid(ws.fetch(DOC_LOADED).count());
	ws.fetch(PRE_SIZE).insert(nil,bat("pre_size" + docid));
	ws.fetch(PRE_LEVEL).insert(nil,bat("pre_level" + docid));
	ws.fetch(PRE_PROP).insert(nil,bat("pre_prop" + docid));
	ws.fetch(PRE_KIND).insert(nil,bat("pre_kind" + docid));
	ws.fetch(PRE_FRAG).insert(nil,bat("pre_level" + docid).project(frag));
	ws.fetch(QN_NS).insert(nil,bat("qn_ns" + docid));
	ws.fetch(QN_LOC).insert(nil,bat("qn_loc" + docid));
	ws.fetch(PROP_TEXT).insert(nil,bat("prop_text" + docid));
	ws.fetch(PROP_COM).insert(nil,bat("prop_com" + docid));
	ws.fetch(PROP_INS).insert(nil,bat("prop_ins" + docid));
	ws.fetch(PROP_TGT).insert(nil,bat("prop_tgt" + docid));
	ws.fetch(ATTR_OWN).insert(nil,bat("attr_own" + docid));
	ws.fetch(ATTR_QN).insert(nil,bat("attr_qn" + docid));
	ws.fetch(ATTR_PROP).insert(nil,bat("attr_prop" + docid));
	ws.fetch(ATTR_FRAG).insert(nil,bat("attr_own" + docid).project(frag));
	ws.fetch(PROP_VAL).insert(nil,bat("prop_val" + docid));
        ws.fetch(FRAG).replace(0@0,frag);
        ws.fetch(HEIGHT).insert(nil,bat("doc_height").find(oid(docid)));
    }
    else
       { ws.fetch(FRAG).replace(0@0,frag.reverse().fetch(0)); }

    return ws;
}
ADDHELP("add_doc", "tsheyar", "July 2004",
"PARAMETERS:\n\
bat(void,bat) - actual working set,\n\
str - the name of the document, which is added\n\
DESCRIPITON:\n\
adds the document to the working set and gives back the\n\
updated working set. (At position FRAG stands the actual\n\
fragment to which the new root is linked.)",
"pathfinder");

PROC create_ws () : BAT[void,bat]
{
    var ws := bat (void,bat).seqbase(PRE_BASE);
    # don't switch the order without also changing the constants
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PRE_SIZE
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PRE_LEVEL
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PRE_PROP
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PRE_KIND
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PRE_FRAG
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # QN_NS
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # QN_LOC
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PROP_TEXT
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PROP_COM
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PROP_INS
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PROP_TGT
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # ATTR_OWN
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # ATTR_QN
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # ATTR_PROP
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # ATTR_FRAG
    ws.insert(nil, bat(void,bat).seqbase(PRE_BASE)); # PROP_VAL
    # offset starts with 1@0 because temporary variables have no name
    ws.insert(nil, bat(void,str).seqbase(1@0));      # DOC_LOADED
    ws.insert(nil, bat(void,oid).seqbase(0@0));      # FRAG
    ws.insert(nil, bat(void,oid).seqbase(0@0));      # WS_FRAG
    ws.insert(nil, bat(void,int).seqbase(0@0));      # HEIGHT

    # add the working set
    ws.fetch(PRE_SIZE).insert(nil, bat(void,int).seqbase(PRE_BASE)); # PRE_SIZE
    ws.fetch(PRE_LEVEL).insert(nil, bat(void,chr).seqbase(PRE_BASE)); # PRE_LEVEL
    ws.fetch(PRE_PROP).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # PRE_PROP
    ws.fetch(PRE_KIND).insert(nil, bat(void,chr).seqbase(PRE_BASE)); # PRE_KIND
    ws.fetch(PRE_FRAG).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # PRE_FRAG
    ws.fetch(QN_NS).insert(nil, bat(void,str).seqbase(PRE_BASE)); # QN_NS
    ws.fetch(QN_LOC).insert(nil, bat(void,str).seqbase(PRE_BASE)); # QN_LOC
    ws.fetch(PROP_TEXT).insert(nil, bat(void,str).seqbase(PRE_BASE)); # PROP_TEXT
    ws.fetch(PROP_COM).insert(nil, bat(void,str).seqbase(PRE_BASE)); # PROP_COM
    ws.fetch(PROP_INS).insert(nil, bat(void,str).seqbase(PRE_BASE)); # PROP_INS
    ws.fetch(PROP_TGT).insert(nil, bat(void,str).seqbase(PRE_BASE)); # PROP_TGT
    ws.fetch(ATTR_OWN).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # ATTR_OWN
    ws.fetch(ATTR_QN).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # ATTR_QN
    ws.fetch(ATTR_PROP).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # ATTR_PROP
    ws.fetch(ATTR_FRAG).insert(nil, bat(void,oid).seqbase(PRE_BASE)); # ATTR_FRAG
    ws.fetch(PROP_VAL).insert(nil, bat(void,str).seqbase(PRE_BASE)); # PROP_VAL
    ws.fetch(FRAG).insert(0@0,nil);
    ws.fetch(HEIGHT).insert(nil,0);

    return ws;
}
ADDHELP("create_ws", "tsheyar", "July 2004",
"DESCRIPITON:\n\
creates a new working set and gives back the reference",
"pathfinder");

# called by compress_properties
PROC compress_val(str batname) : bat[void,oid]
{
    var bat1 := bat(batname);
    var grp := CTgroup(bat1);
    var unq := grp.tunique().mark(0@0).reverse();

    { var tmp := unq.join(bat1); bat1.access(BAT_WRITE).delete().insert(tmp); }

    return grp.join(unq.reverse());
}

# called by compress_properties
PROC compress_val(str batname1, str batname2) : bat[void,oid]
{
    var bat1 := bat(batname1);
    var bat2 := bat(batname2);
    var grp := CTgroup(bat1).CTgroup(bat2); # void,old-oid
    var unq := grp.tunique().mark(0@0).reverse(); # void,new-oid 

    { var tmp := unq.join(bat1); bat1.access(BAT_WRITE).delete().insert(tmp); }
    { var tmp := unq.join(bat2); bat2.access(BAT_WRITE).delete().insert(tmp); }
 
    return grp.leftjoin(unq.reverse());
}

PROC compress_properties(str name) : void
{
    if (not(bat("doc_name").reverse().exist(name)))
	{ ERROR("Document %s does not exist\n",name); }
    var docid := str(int(bat("doc_name").reverse().find(name)));

    printf("[ \">>> Compress properties of loaded document '%s'\" ]\n",name);
    
    # eliminate property duplicates in each BAT prop_*
    # (in case of tag-names and PIs every unique combination of
    #  ns:loc, (resp. tgt:ins) gets a property ID)
    
    var pre_kind := bat("pre_kind" + docid);
    var pre_prop := bat("pre_prop" + docid);

    var pre_oldProp := pre_kind.ord_uselect(DOCUMENT).mirror().leftfetchjoin(pre_prop); 
    var _pre := pre_oldProp.mark(0@0).reverse();
    var _newProp := pre_oldProp.reverse().mark(0@0).reverse();

    pre_oldProp := pre_kind.ord_uselect(ELEMENT).mirror().leftfetchjoin(pre_prop);
    var oldProp_newProp := compress_val(("qn_ns" + docid), ("qn_loc" + docid));
    # combine the intermediate results
    var pre_newProp_part := pre_oldProp.leftjoin(oldProp_newProp);
    var _pre_part := pre_newProp_part.mark(0@0).reverse();
    var _newProp_part := pre_newProp_part.reverse().mark(0@0).reverse();
    var tmp := merged_union (_pre, _pre_part, _newProp, _newProp_part);
    pre_oldProp := nil;
    oldProp_newProp := nil;
    pre_newProp_part := nil;
    _pre_part := nil;
    _newProp_part := nil;
    _pre := tmp.fetch(0);
    _newProp := tmp.fetch(1);
    tmp := nil;
    # use the already compressed QNames to get the new attr qn references
    var attr_oldQn := bat("attr_qn" + docid);
    var attr_newQn := attr_oldQn.leftfetchjoin(oldProp_newProp);
    # FIXME: leftfetchjoin has to be order preserving to allow such a mark
    attr_newQn := attr_newQn.reverse().mark(0@0).reverse();
    # change the persistent attr_qn bat
    attr_oldQn.access(BAT_WRITE).delete().insert(attr_newQn);

    pre_oldProp := pre_kind.ord_uselect(TEXT).mirror().leftfetchjoin(pre_prop); 
    oldProp_newProp := compress_val(("prop_text" + docid));
    # combine the intermediate results
    pre_newProp_part := pre_oldProp.leftjoin(oldProp_newProp);
    _pre_part := pre_newProp_part.mark(0@0).reverse();
    _newProp_part := pre_newProp_part.reverse().mark(0@0).reverse();
    tmp := merged_union (_pre, _pre_part, _newProp, _newProp_part);
    pre_oldProp := nil;
    oldProp_newProp := nil;
    pre_newProp_part := nil;
    _pre_part := nil;
    _newProp_part := nil;
    _pre := tmp.fetch(0);
    _newProp := tmp.fetch(1);
    tmp := nil;

    pre_oldProp := pre_kind.ord_uselect(COMMENT).mirror().leftfetchjoin(pre_prop); 
    oldProp_newProp := compress_val(("prop_com" + docid));
    # combine the intermediate results
    pre_newProp_part := pre_oldProp.leftjoin(oldProp_newProp);
    _pre_part := pre_newProp_part.mark(0@0).reverse();
    _newProp_part := pre_newProp_part.reverse().mark(0@0).reverse();
    tmp := merged_union (_pre, _pre_part, _newProp, _newProp_part);
    pre_oldProp := nil;
    oldProp_newProp := nil;
    pre_newProp_part := nil;
    _pre_part := nil;
    _newProp_part := nil;
    _pre := tmp.fetch(0);
    _newProp := tmp.fetch(1);
    tmp := nil;

    pre_oldProp := pre_kind.ord_uselect(PI).mirror().leftfetchjoin(pre_prop); 
    oldProp_newProp := compress_val(("prop_ins" + docid), ("prop_tgt" + docid));
    # combine the intermediate results
    pre_newProp_part := pre_oldProp.leftjoin(oldProp_newProp);
    _pre_part := pre_newProp_part.mark(0@0).reverse();
    _newProp_part := pre_newProp_part.reverse().mark(0@0).reverse();
    tmp := merged_union (_pre, _pre_part, _newProp, _newProp_part);
    pre_oldProp := nil;
    oldProp_newProp := nil;
    pre_newProp_part := nil;
    _pre_part := nil;
    _newProp_part := nil;
    _pre := tmp.fetch(0);
    _newProp := tmp.fetch(1);
    tmp := nil;

    # change the persistent pre_prop bat
    pre_prop.access(BAT_WRITE).delete().insert(_pre.reverse().leftjoin(_newProp));
    _pre := nil;
    _newProp := nil;

    var attr_prop := bat("attr_prop" + docid);
    oldProp_newProp := compress_val(("prop_val" + docid));
    var attr_newProp := attr_prop.leftfetchjoin(oldProp_newProp);
    # FIXME: leftfetchjoin has to be order preserving to allow such a mark
    attr_newProp := attr_newProp.reverse().mark(0@0).reverse();
    # change the persistent attr_prop bat
    attr_prop.access(BAT_WRITE).delete().insert(attr_newProp);

    commit();
    print("Compression completed");
}
ADDHELP("compress_properties", "tsheyar", "Juli 2004",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
compression of property duplicates",
"pathfinder");

PROC import_doc(str flnm, str name) : void
{
    # create doc_name table in case it does not exist
    if (not(view_bbp_name.reverse().exist("doc_name")))
    {    
        new(oid,str).persists(true).bbpname("doc_name");
        new(oid,int).persists(true).bbpname("doc_height");
    }
    var doc_oid;
    if (bat("doc_name").count() = 0) { doc_oid := 0@0; }
    else { doc_oid := oid(int(bat("doc_name").reverse().max()) + 1); }
    
    if (bat("doc_name").reverse().exist(name))
	{ ERROR("Document %s already exists\n",name); }

    module("ascii_io");

    printf("[ \">>> Importing '%s' with name '%s'\" ]\n",flnm,name);

    # column/line separators (4 columns)
    var seps4 := new (void, str);
    seps4.insert (nil, ",");
    seps4.insert (nil, ",");
    seps4.insert (nil, ",");
    seps4.insert (nil, "\n");

    # column/line separators (3 columns)
    var seps3 := new (void, str);
    seps3.insert (nil, ",");
    seps3.insert (nil, ",");
    seps3.insert (nil, "\n");

    # column/line separators (2 columns)
    var seps2 := new (void, str);
    seps2.insert (nil, ",");
    seps2.insert (nil, "\n");

    # column/line separators (1 column)
    var seps1 := new (void, str);
    seps1.insert (nil, "\n");

    # table pre|size|level|prop|kind 
    var pre := new (void, str);
    pre.insert (nil, "size");
    pre.insert (nil, "level");
    pre.insert (nil, "prop");
    pre.insert (nil, "kind");

    # column types
    var pre_ty := new (void, str);
    pre_ty.insert (nil, "int");
    pre_ty.insert (nil, "sht");
    pre_ty.insert (nil, "oid");
    pre_ty.insert (nil, "sht");

    # table prop|ns|loc
    var tag := new (void, str);
    tag.insert (nil, "ns");
    tag.insert (nil, "loc");

    # column types
    var tag_ty := new (void, str);
    tag_ty.insert (nil, "str");
    tag_ty.insert (nil, "str");

    # table prop|text
    var text := new (void, str);
    text.insert (nil, "text");

    # column types
    var text_ty := new (void, str);
    text_ty.insert (nil, "str");

    # table prop|com
    var com := new (void, str);
    com.insert (nil, "com");

    # column types
    var com_ty := new (void, str);
    com_ty.insert (nil, "str");

    # table prop|tgt|ins
    var pi := new (void, str);
    pi.insert (nil, "tgt");
    pi.insert (nil, "ins");

    # column types
    var pi_ty := new (void, str);
    pi_ty.insert (nil, "str");
    pi_ty.insert (nil, "str");

    # table att|own|qn|prop
    var att := new (void, str);
    att.insert (nil, "own");
    att.insert (nil, "qn");
    att.insert (nil, "prop");

    # column types
    var att_ty := new (void, str);
    att_ty.insert (nil, "oid");
    att_ty.insert (nil, "oid");
    att_ty.insert (nil, "oid");

    # table prop|val
    var att_val := new (void, str);
    att_val.insert (nil, "val");

    # column types
    var att_val_ty := new (void, str);
    att_val_ty.insert (nil, "str");

    # load table pre|size|level|prop|kind 
    var tmp := load(pre, seps4, pre_ty, flnm + ".pre", -1);
    
    bat("doc_name").insert(doc_oid, name);
    bat("doc_height").insert(doc_oid, tmp.find("level").max() + 1);
    var docid := str(int(doc_oid));
    doc_oid := nil;

    tmp.find("size").persists(true).bbpname("pre_size" + docid);
    tmp.find("level").[chr].copy().persists(true).bbpname("pre_level" + docid);
    tmp.find("prop").persists(true).bbpname("pre_prop" + docid);
    tmp.find("kind").[chr].copy().persists(true).bbpname("pre_kind" + docid);

    # load table prop|ns|loc
    tmp := load(tag, seps2, tag_ty, flnm + ".qn", -1);
    tmp.find("ns").persists(true).bbpname("qn_ns" + docid);
    tmp.find("loc").persists(true).bbpname("qn_loc" + docid);

    # load table prop|text
    tmp := load(text, seps1, text_ty, flnm + ".text", -1);
    tmp.find("text").persists(true).bbpname("prop_text" + docid);

    # load table prop|com
    tmp := load(com, seps1, com_ty, flnm + ".com", -1);
    tmp.find("com").persists(true).bbpname("prop_com" + docid);

    # load table prop|tgt|ins
    tmp := load(pi, seps2, pi_ty, flnm + ".pi", -1);
    tmp.find("tgt").persists(true).bbpname("prop_tgt" + docid);
    tmp.find("ins").persists(true).bbpname("prop_ins" + docid);

    # load table att|own|qn|prop
    tmp := load(att, seps3, att_ty, flnm + ".@", -1);
    tmp.find("own").persists(true).bbpname("attr_own" + docid);
    tmp.find("qn").persists(true).bbpname("attr_qn" + docid);
    tmp.find("prop").persists(true).bbpname("attr_prop" + docid);

    # load table prop|val
    tmp := load(att_val, seps1, att_val_ty, flnm + ".@val", -1);
    tmp.find("val").persists(true).bbpname("prop_val" + docid);

    # save all persistent BATs
    commit();
    print("Document successfully imported");

    if (((bat("pre_kind" + docid).select(ELEMENT).count() +
          bat("attr_own" + docid).count()) = 
         bat("qn_ns" + docid).count())
        and
	(bat("pre_kind" + docid).select(TEXT).count() =
        bat("prop_text" + docid).count()))
    {
        printf("[ \"The properties of the file '%s' are propably not compressed!\" ]\n", flnm);
	printf("[ \"You can compress the loaded instance '%s' with: 'compress_properties(\"%s\");'\" ]\n", name, name);
    }
}
ADDHELP("import_doc", "rode", "Nov 2003",
"PARAMETERS:\n\
str file name (\"/anypath/foo.xml\" if loader output is located in \"/anypath/foo.xml.*\")\n\
str document name in database\n\
DESCRIPITON:\n\
Import files generated by the loader as persistent document.",
"pathfinder");

PROC delete_doc(str name) : void
{
    if (not(bat("doc_name").reverse().exist(name)))
	{ ERROR("Document %s does not exist\n",name); }
    var doc_oid := bat("doc_name").reverse().find(name);
    
    bat("doc_name").delete(doc_oid);
    bat("doc_height").delete(doc_oid);
    
    var docid := str(int(doc_oid));
    bat("pre_size" + docid).persists(false);
    bat("pre_level" + docid).persists(false);
    bat("pre_prop" + docid).persists(false);
    bat("pre_kind" + docid).persists(false);
    bat("qn_ns" + docid).persists(false);
    bat("qn_loc" + docid).persists(false);
    bat("prop_text" + docid).persists(false);
    bat("prop_com" + docid).persists(false);
    bat("prop_tgt" + docid).persists(false);
    bat("prop_ins" + docid).persists(false);
    bat("attr_own" + docid).persists(false);
    bat("attr_qn" + docid).persists(false);
    bat("attr_prop" + docid).persists(false);
    bat("prop_val" + docid).persists(false);
    
    commit();
}
ADDHELP("delete_doc", "tsheyar", "July 2004",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
delete the persistent BATS that store the document.",
"pathfinder");

PROC delete_all_docs() : void
{
    if (not(view_bbp_name.reverse().exist("doc_name")))
	{ print("no documents to delete"); }
    else {
        bat("doc_name")@batloop () {
            delete_doc($t);
        }
#        bat("doc_name").persists(false);
#        bat("doc_height").persists(false);
#        commit();
    }
}
ADDHELP("delete_all_docs", "tsheyar", "July 2004",
"DESCRIPITON:\n\
deletes all persistent document BATs that store xml documents.",
"pathfinder");

@(
# the print routine is not usable and therefore not needed any more

#############################################
# XML print functions / XML Serialization
#
# - xml_print()
# - xml_print(str docname)
# - xml_print(BAT[oid,any] context set)
#
# The xml_print function serializes the information stored in the
# collection of BATs. Thus, it restores fragments of the textual
# representation of the XML-document.
# xml_print() can be either called without argument, which causes
# printing of the whole working set, or related to a specific document
# or context set. In the latter case, for each node within the context
# set, the node itself and its descendant fragment is printed (even if
# this means to repeatedly print the same information, when context 
# nodes relate to each other on the descendant axis).
#

PROC attr_print(oid pre) : void
{
    var attr_list := Tattr_own.uselect(pre);
    var name;
    attr_list@batloop
    {
	# recompose name
	name := Tattr_ns.fetch($h);
	if (name != "") { name :+= ":"; }
	name :+= Tattr_loc.fetch($h);
	# TODO: distinguish quot and apos enclosed attributes
        printf(" %s=\"%s\"", name, Tattr_val.fetch($h));
    }
}

PROC node_print(oid pre, BAT[oid,str] S) : void
{
    var kind := Tpre_kind.fetch(pre);
    var prop := Tpre_prop.fetch(pre);
	
    if (kind = ELEMENT)
    {    
	# recompose tag name
	var tag := Tprop_ns.fetch(prop);
	if (tag != "") { tag :+= ":"; }
	tag :+= Tprop_loc.fetch(prop);
	
        printf("<%s",tag);
	attr_print(pre);
	printf(">");

	# push node on S
	S.insert(oid(int(pre) + Tpre_size.fetch(pre)), tag);
    }
    else { if (kind = TEXT)
        { printf("%s",Tprop_text.fetch(prop)); }
    else { if (kind = COMMENT)
        { printf("<!--%s-->",Tprop_com.fetch(prop)); }
    else { if (kind = PI)
        { printf("<?%s %s?>",Tprop_tgt.fetch(prop), Tprop_ins.fetch(prop)); }
    else { if (kind = DOCUMENT)
	{ S.insert(oid(int(pre) + Tpre_size.fetch(pre)), ""); }
	 }}}}
}

PROC endtag_print(oid pre, BAT[oid,str] S) : void
{
    # pseudocode of this procedure:
    # while (pre > S.top()) print(name(S.pop()));
    var i := S.count() - 1;
    var popped := S.reverse().select(oid(nil), pre, true, false).reverse();
    var poplimit := i - popped.count();
    var tag;
    
    while (i > poplimit)
    {
        # the 'tag != ""'-check is needed, to suppress output
        # if a document node is popped from the stack
        tag := S.fetch(i);
	if (tag != "") { printf("</%s>", tag); }
	i :-= 1;
    }
    
    S.delete(popped);
}

PROC xml_print(BAT[oid,any] CS) : void
{
    if (CS.count() = 0) { return; }
    
    # line feed
    printf("\n");

    # node stack (storing pre+size and the name of a node)
    var S := new(oid,str);
    
    # cursor moving over the pre values
    var pre;
    var lastpre := Tpre_size.reverse().fetch(Tpre_size.count() - 1);
   
    # for all nodes in the context set do ...
    CS@batloop{
        
	pre := $h;
        
	# missing "do...while"-loops in mil ... 
	node_print(pre, S);
	pre := oid(int(pre) + 1);
        endtag_print(pre, S);
	
        while ((S.count() > 0) and (pre <= lastpre))
	{
	    node_print(pre, S);
	    pre := oid(int(pre) + 1);
            endtag_print(pre, S);
        }
	# line feed
	printf("\n\n");
    }
}
ADDHELP("xml_print", "rode", "Dec 2003",
"PARAMETERS:\n\
BAT[oid,any] context set\n\
DESCRIPITON:\n\
Print XML-fragment enclosed by each context node.",
"pathfinder");

PROC xml_print() : void
{
    xml_print(Tdoc_pre.reverse());
}
ADDHELP("xml_print", "rode", "Dec 2003",
"DESCRIPITON:\n\
Print all XML-documents in the working set.",
"pathfinder");

PROC xml_print(str name) : void
{
    if (not(Tdoc_name.reverse().exist(name)))
	{ ERROR("Document %s does not exist in working set\n",name); }
    var docid := int(Tdoc_name.reverse().find(name));	
    xml_print(Tdoc_pre.slice(docid,docid).reverse());
}
ADDHELP("xml_print", "rode", "Dec 2003",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
Print XML-document with the specified name.",
"pathfinder");

@) 
@mil

#############################################
# MIL WRAPPER for AXIS STEPS 
#
# In order to simplify the invocation of the axis steps functions, this
# interface provides...
# 

PROC descendant(BAT[void,oid] ctx, BAT[void,oid] frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_sizes := ws.fetch(PRE_SIZE);
    var pre_levels := ws.fetch(PRE_LEVEL);
    var heights := ws.fetch(HEIGHT);

    var unq := {count}(frag.reverse(), frag.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        result.insert(scj_desc
                              (pre_sizes.fetch($h),
                               ctx_slice,
                               heights.fetch($h),
                               pre_sizes.fetch($h).count()).project($h));
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return scj_desc(Tpre_size, ctx, Theight, Tpre_size.count());
}
ADDHELP("descendant", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the descendant axis of the ctx-nodes.",
"pathfinder");

PROC descendant_or_self(BAT[void,oid] ctx, BAT[void,oid] frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_sizes := ws.fetch(PRE_SIZE);
    var pre_levels := ws.fetch(PRE_LEVEL);
    var heights := ws.fetch(HEIGHT);

    var unq := {count}(frag.reverse(), frag.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        result.insert(scj_descorself
                              (pre_sizes.fetch($h),
                               ctx_slice,
                               heights.fetch($h),
                               pre_sizes.fetch($h).count()).project($h));
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return scj_descorself(Tpre_size, ctx, Theight, Tpre_size.count());
}
ADDHELP("descendant_or_self", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the descendant-or-self axis of the ctx-nodes.",
"pathfinder");

PROC ancestor(BAT[void,oid] ctx, BAT[void,oid] frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_sizes := ws.fetch(PRE_SIZE);
    var pre_levels := ws.fetch(PRE_LEVEL);
    var heights := ws.fetch(HEIGHT);

    var unq := {count}(frag.reverse(), frag.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        result.insert(scj_anc
                              (pre_sizes.fetch($h),
                               ctx_slice,
                               heights.fetch($h),
                               pre_sizes.fetch($h).count()).project($h));
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return scj_anc(Tpre_size, ctx, Theight, Tpre_size.count());
}
ADDHELP("ancestor", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the ancestor axis of the ctx-nodes.",
"pathfinder");

PROC ancestor_or_self(BAT[void,oid] ctx, BAT[void,oid] frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_sizes := ws.fetch(PRE_SIZE);
    var pre_levels := ws.fetch(PRE_LEVEL);
    var heights := ws.fetch(HEIGHT);

    var unq := {count}(frag.reverse(), frag.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        result.insert(scj_ancorself
                              (pre_sizes.fetch($h),
                               ctx_slice,
                               heights.fetch($h),
                               pre_sizes.fetch($h).count()).project($h));
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return scj_ancorself(Tpre_size, ctx, Theight, Tpre_size.count());
}
ADDHELP("ancestor_or_self", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the ancestor-or-self axis of the ctx-nodes.",
"pathfinder");

PROC child(BAT[void,oid] ctx, BAT[void,oid] frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_levels := ws.fetch(PRE_LEVEL);
    var heights := ws.fetch(HEIGHT);

    var unq := {count}(frag.reverse(), frag.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        result.insert(lev_child
                              (pre_levels.fetch($h),
                               ctx_slice,
                               heights.fetch($h),
                               pre_levels.fetch($h).count()).project($h));
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return lev_child(Tpre_level, ctx, Theight, Tpre_level.count());
}
ADDHELP("child", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the child axis of the ctx-nodes.",
"pathfinder");

PROC parent(BAT[void,oid] ctx, BAT[void,oid] frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_levels := ws.fetch(PRE_LEVEL);
    var heights := ws.fetch(HEIGHT);

    var unq := {count}(frag.reverse(), frag.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        result.insert(lev_parent
                              (pre_levels.fetch($h),
                               ctx_slice,
                               heights.fetch($h),
                               pre_levels.fetch($h).count()).project($h));
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return lev_parent(Tpre_level, ctx, Theight, Tpre_level.count());
}
ADDHELP("parent", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the parent axis of the ctx-nodes.",
"pathfinder");

PROC following_sibling(BAT[void,oid] ctx, BAT[void,oid] frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_levels := ws.fetch(PRE_LEVEL);
    var heights := ws.fetch(HEIGHT);

    var unq := {count}(frag.reverse(), frag.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        result.insert(lev_fs
                              (pre_levels.fetch($h),
                               ctx_slice,
                               heights.fetch($h),
                               pre_levels.fetch($h).count()).project($h));
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return lev_fs(Tpre_level, ctx, Theight, Tpre_level.count());
}
ADDHELP("following_sibling", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the following-sibling axis of the ctx-nodes.",
"pathfinder");

PROC preceding_sibling(BAT[void,oid] ctx, BAT[void,oid] frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_levels := ws.fetch(PRE_LEVEL);
    var heights := ws.fetch(HEIGHT);

    var unq := {count}(frag.reverse(), frag.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        result.insert(lev_ps
                              (pre_levels.fetch($h),
                               ctx_slice,
                               heights.fetch($h),
                               pre_levels.fetch($h).count()).project($h));
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return lev_ps(Tpre_level, ctx, Theight, Tpre_level.count());
}
ADDHELP("preceding_sibling", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the preceding-sibling axis of the ctx-nodes.",
"pathfinder");

PROC following(BAT[void,oid] ctx, BAT[void,oid] frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_sizes := ws.fetch(PRE_SIZE);
    var pre_levels := ws.fetch(PRE_LEVEL);
    var heights := ws.fetch(HEIGHT);

    var unq := {count}(frag.reverse(), frag.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    # FIXME: dirty code because, don't want to change scj implementation
    var doc_pre;
    var default_bat := bat(void,oid).seqbase(0@0).insert(nil,1@0);

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        # FIXME: dirty code because, don't want to change scj implementation
        if ($h = 0@0)
            { doc_pre := ws.fetch(WS_FRAG); }
        else
            { doc_pre := default_bat; }

        result.insert(following_void
                              (pre_sizes.fetch($h),
                               ctx_slice,
                               doc_pre,
                               heights.fetch($h),
                               pre_sizes.fetch($h).count()).project($h));
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return following_void(Tpre_size, ctx, Tdoc_pre, Theight, Tpre_size.count());
}
ADDHELP("following", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the following axis of the ctx-nodes.",
"pathfinder");

PROC preceding(BAT[void,oid] ctx, BAT[void,oid] frag, BAT[void,bat] ws) : BAT[oid,oid]
{
    var pre_sizes := ws.fetch(PRE_SIZE);
    var pre_levels := ws.fetch(PRE_LEVEL);
    var heights := ws.fetch(HEIGHT);

    var unq := {count}(frag.reverse(), frag.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

    # FIXME: dirty code because, don't want to change scj implementation
    var doc_pre;
    var default_bat := bat(void,oid).seqbase(0@0).insert(nil,1@0);

    unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().mark(nil);
	ctx_slice.chk_order(false); # have to check because step expects it sorted
        # FIXME: dirty code because, don't want to change scj implementation
        if ($h = 0@0)
            { doc_pre := ws.fetch(FRAG_PRE); }
        else
            { doc_pre := default_bat; }

        result.insert(preceding_void
                              (pre_sizes.fetch($h),
                               ctx_slice,
                               doc_pre,
                               heights.fetch($h),
                               pre_sizes.fetch($h).count()).project($h));
        offset := offset + $t;
    }
    return result.access(BAT_READ);
#    return preceding_void(Tpre_size, ctx, Tdoc_pre, Theight, Tpre_size.count());
}
ADDHELP("preceding", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the preceding axis of the ctx-nodes.",
"pathfinder");


@:loop_lifted_scj_step1(ancestor)@
@:loop_lifted_scj_step1(ancestor_or_self)@
@:loop_lifted_scj_step1(child)@
@:loop_lifted_scj_step1(descendant)@
@:loop_lifted_scj_step1(descendant_or_self)@
@:loop_lifted_scj_step1(following)@
@:loop_lifted_scj_step1(following_sibling)@
@:loop_lifted_scj_step1(parent)@
@:loop_lifted_scj_step1(preceding)@
@:loop_lifted_scj_step1(preceding_sibling)@

# expanding of the return_type
@= jRetType
bat[void,bat]
@= jReturn
result_scj := bat(void,bat).seqbase(0@0);
# join is implicitly done in the iterative approach
result_scj.insert(nil,pruned_item);
result_scj.insert(nil,ctx_dn_item);
result_scj.insert(nil,ctx_dn_frag);
@
@= unjRetType
bat[void,bat]
@= unjReturn
result_scj := bat(void,bat).seqbase(0@0);
result_scj.insert(nil,pruned_item);
result_scj.insert(nil,ctx_dn_item);
result_scj.insert(nil,ctx_dn_frag);
@ 
# expansion of the different return types
@= loop_lifted_scj_step1
@:loop_lifted_scj_step2(@1,_joined,@:jRetType@,@:jReturn)@
@:loop_lifted_scj_step2(@1,_unjoined,@:unjRetType@,@:unjReturn@)@
@
#==================================================================
# expansions of the loop lifted scj
@= comma
,
@
# kind argument
@= kind
@:comma@chr kind
@
# code for kind testing
@= kindcode
        kind_scj := mposjoin (item_part, frag_part, ws.fetch(PRE_KIND));
        temp1_scj := kind_scj.ord_uselect(kind).mark(0@0).reverse();
	kind_scj := nil;
        item_part := temp1_scj.leftfetchjoin(item_part);
        frag_part := temp1_scj.leftfetchjoin(frag_part);
	temp1_scj := nil;
@
# tagname argument
@= tagname_ns
@:comma@str ns
@
@= tagname_loc
@:comma@str loc
@
@= tagname_nsloc
@:comma@str ns@:comma@ str loc
@
# code for tagname testing
@= ns_code
		tmp := ws.fetch(QN_NS).fetch($t).ord_uselect(ns);
@
@= loc_code
		tmp := ws.fetch(QN_LOC).fetch($t).ord_uselect(loc);
@
@= nsloc_code
		tmp := ws.fetch(QN_NS).fetch($t).ord_uselect(ns).mark(0@0).reverse();
		tmp := tmp.leftjoin(ws.fetch(QN_LOC).fetch($t)).ord_uselect(loc);
@
@= gettagnames
	var tagtest_prop;
	var tagtest_frag;
	{
	var tagtest := frag;
	# FIXME: propably there is a better solution to get all fragments
	# test if WS is present - if yes add all possible fragments
	if (frag.ord_uselect(0@0).count() > 0)
            { tagtest.access(BAT_WRITE).insert(ws.fetch(PRE_FRAG).fetch(WS)); }

	tagtest := tagtest.tunique().mark(0@0).reverse();
	var result := bat(oid,oid);

	var tmp;
	tagtest@batloop () {
		@1
		result.insert(tmp.project($t).reverse());
	}
	tagtest_prop := result.reverse().mark(0@0).reverse();
	tagtest_frag := result.mark(0@0).reverse();
	}
@
# code for tagname testing
@= tagnamecode
        kind_scj := mposjoin (item_part, frag_part, ws.fetch(PRE_KIND));
        temp1_scj := kind_scj.ord_uselect(ELEMENT).mark(0@0).reverse();
	kind_scj := nil;
        item_part := temp1_scj.leftfetchjoin(item_part);
        frag_part := temp1_scj.leftfetchjoin(frag_part);
	temp1_scj := nil;

	# create void|testprop corresponding to item_part
	temp1_scj := mposjoin(item_part, frag_part, ws.fetch(PRE_FRAG));
	temp1_scj := temp1_scj.leftjoin(tagtest_frag.reverse());
	temp1_scj := temp1_scj.leftfetchjoin(tagtest_prop);

	# compare PROP of item_part with testprop
	bool_scj := temp1_scj.[=](mposjoin (item_part, frag_part, ws.fetch(PRE_PROP)));
	temp1_scj := bool_scj.ord_uselect(true).mark(0@0).reverse();
	bool_scj := nil;

        item_part := temp1_scj.leftfetchjoin(item_part);
        frag_part := temp1_scj.leftfetchjoin(frag_part);
	temp1_scj := nil;
@
# resetting the tagname
@= resetpropID
tagtest_prop := nil;
tagtest_frag := nil;
@
# expanding the scj for the different tests
@= loop_lifted_scj_step2
@:loop_lifted_scj_step3(@1,@2,,@3,,,,@4)@
@:loop_lifted_scj_step3(@1,_with_kind_test@2,@:kind@,@3,,@:kindcode@,,@4)@
@:loop_lifted_scj_step3(@1,_with_ns_test@2,@:tagname_ns@,@3,@:gettagnames(@:ns_code)@,@:tagnamecode@,@:resetpropID@,@4)@
@:loop_lifted_scj_step3(@1,_with_loc_test@2,@:tagname_loc@,@3,@:gettagnames(@:loc_code@)@,@:tagnamecode@,@:resetpropID@,@4)@
@:loop_lifted_scj_step3(@1,_with_nsloc_test@2,@:tagname_nsloc@,@3,@:gettagnames(@:nsloc_code@)@,@:tagnamecode@,@:resetpropID@,@4)@
@
#==================================================================
# actual definition of the scj proc
@= loop_lifted_scj_step3
proc loop_lifted_@1_step@2 (bat[void, oid] iter, bat[void, oid] item, bat[void, oid] frag, bat[void, bat] ws@3) : @4
{
   var offset := 0;
   var pruned_item := bat(void,oid).access(BAT_APPEND).seqbase(0@0);
   var ctx_dn_item := bat(void,oid).access(BAT_APPEND).seqbase(0@0);
   var ctx_dn_frag := bat(void,oid).access(BAT_APPEND).seqbase(0@0);

#   # IMPORTANT: input should be sorted on iter|frag|item
#   # (distinct-doc-order, doc or path step)
#   # therefore the next 5 lines shouldn't be needed
#   var sorting := iter.reverse().sort().reverse().mark(0@0).reverse();
#   iter := sorting.leftfetchjoin(iter);
#   item := sorting.leftfetchjoin(item);
#   frag := sorting.leftfetchjoin(frag);
#   sorting := nil;

   var uniqueIter_count := {count}(iter.reverse(), iter.tunique());
   
   # printf("[ \"order: uniqueIter_count %i, iter %i\" ]\n", uniqueIter_count.chk_order(false), iter.chk_order(false));

   if ((and(uniqueIter_count.chk_order(false),4) = 4) or 
       (iter.chk_order(false) >= 4))
   {
       uniqueIter_count.print();
       iter.print();
       ERROR ("ordering is wrong in scj (concept with slices doesn't work)");
   }	
   uniqueIter_count := uniqueIter_count.[-](1);

   @5

   # temporary variables
   var temp1_scj;
   var kind_scj;
   var bool_scj;

   var item_part;
   var frag_part;
   var seqb;

   uniqueIter_count@batloop ()
   {
   	item_part := item.slice(offset, offset + $t).reverse().mark(0@0).reverse();
   	frag_part := frag.slice(offset, offset + $t).reverse().mark(0@0).reverse();
	temp1_scj := @1 (item_part, frag_part, ws);
        item_part := temp1_scj.mark(0@0).reverse();
        frag_part := temp1_scj.reverse().mark(0@0).reverse();
	temp1_scj := nil;

	# possible test
	@6

   	seqb := oid(count(ctx_dn_item));
   	item_part := item_part.reverse().mark(seqb).reverse();
   	ctx_dn_item.insert(item_part);
   	pruned_item.insert(item_part.project($h));
   	frag_part := frag_part.reverse().mark(seqb).reverse();
   	ctx_dn_frag.insert(frag_part);

   	offset := offset + $t + 1;
   }

   offset := nil;
   item_part := nil;
   frag_part := nil;
   seqb := nil;
   uniqueIter_count := nil;
   iter := nil;
   item := nil;
   @7 # propID := nil;

   ctx_dn_item.access(BAT_READ);
   pruned_item.access(BAT_READ);
   ctx_dn_frag.access(BAT_READ);

   var result_scj;
   @8
   return result_scj.access(BAT_READ);
}
@

@mil
PROC concat (BAT[any,str] strings) : str
{
    var result := "";
    strings@batloop () {
        result :+= $t;
    }
    return result;
}
ADDHELP("concat", "tsheyar", "Aug 2004",
"PARAMETERS:\n\
BAT[any,str] list of strings\n\
DESCRIPITON:\n\
concatenates list of strings to one string",
"pathfinder");

PROC combine_string (BAT[any,str] strings) : str
{
    if (strings.count() = 0)
	{ return ""; }

    var result := strings.fetch(0);
    strings.slice(1,strings.count() - 1)@batloop () {
	result :+= " " + $t;
    }
    return result;
}
ADDHELP("combine_string", "tsheyar", "Aug 2004",
"PARAMETERS:\n\
BAT[any,str] list of strings\n\
DESCRIPITON:\n\
concatenates all strings from the bat to one string with a single space between each string.",
"pathfinder");

PROC combine_strings (BAT[oid,str] strings) : BAT[oid,str]
{
    return {combine_string}(strings);
}
ADDHELP("combine_strings", "tsheyar", "Aug 2004",
"DESCRIPITON:\n\
pseudonym for {combine_string}(BAT[oid,str])",
"pathfinder");
