@' pathfinder.mx
@'
@' XQuery runtime environment
@'
@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2006 University of Konstanz.  All Rights Reserved.
@'
@' $Id$
@'

@f pathfinder
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@a Jan Flokstra
@a Jens Teubner
@a Stefan Manegold
@a Peter Boncz 
@a Ying Zhang
@a Niels Nes

@t Runtime Support for the Pathfinder XQuery Compiler

@m
.MODULE pathfinder;

.USE streams;

.COMMAND xquery_frontend() : ptr = xquery_frontend;
 "create/return the xquery_frontend callback interface to pass to mapi register. "

.BUILTIN xquery(mode str, xquery str, is_url bit) : str = CMDxquery;
 "xquery execution. parameters: mode, query, is_url (optional)
 usage:  var result := xquery(\"xml\", \"1+1\", false); printf(result);
 or:  printf(xquery(\"xml\", \"1+1\"));"

.COMMAND xquery_start_query_cache(lng maxsize) : void = CMDxquery_start_query_cache; 
 "Cached xquery clients use the query plan cache (also flushes the cache when called). if nonzero, the parameter is a per-connection size limit to the plan cache in bytes"

.PRELUDE = xquery_prelude;
.EPILOGUE = xquery_epilogue;

.END pathfinder;
@mil
module(mapi);       # remote client access
module(monettime); 

PROC pfstart(bit open, lng sz) : void {
        xquery_start_query_cache(sz);
	mapi_register(xquery_frontend());
        if (not(mapi_running())) {
                mapi_listen(
                        int(monet_environment.find("mapi_port")), 
                        str(nil), 
                        5, 
                        open).fork();
        }
}
ADDHELP("pfstart", "boncz", "April 2005",
"PARAMETERS:\n\
bit whether the listener should listen to outside requests \
(default false: only local connections).\n\
sz per-connection size limit to the query plan cache, see also \"xquery_start_query_cache\".\n\
DESCRIPTION:\n\
start the xquery server.",
"pathfinder");

PROC pfstart() : void {
        pfstart(false, 0LL);
}

PROC xquery_server_start(bit global) : void {
        pfstart(false, 0LL);
}

PROC xquery_server_start() : void {
        xquery_server_start(false);
}

#############################################
# User-level document management functions:
#
# - shred_doc
# - delete_doc
# - delete_all_docs
#
# Each imported XML-document is stored as a collection of persistent BATs 
# whose name starts with the name of the BAT and ends with the document ID. 
# The execution of an XQuery is not performed on the persistent BATs, but on 
# the transient 'working set', a global document collection represented
# by the ws-BAT.
#
# Each collection contains the following rid_* BATs from which the pre_* BATs can be reconstructed:
# - map_pid     : BAT[oid,oid]  64K tuple page-id / and its page index in the rid_table
# - rid_size    : BAT[oid,int]  rid-value of node / and its descendant size,
# - rid_level   : BAT[oid,chr]  rid-value of node / and its level,
# - rid_prop    : BAT[oid,oid]  rid-value of node / and property ID,
# - rid_kind    : BAT[oid,chr]  rid-value of node / and node kind,
#                              
# NOTE: page indices start at oid(0). by putting the rid_* phyisical pages in the 
#       order specified by map_pid we get the original pre_* tables back.
#
# - qn_ns        : BAT[oid,str]  property ID / and name space (elements and attributes),
# - qn_loc       : BAT[oid,str]  property ID / and local name (elements and attributes),
# - prop_text    : BAT[oid,str]  property ID / and text,
# - prop_com     : BAT[oid,str]  property ID / and comment,
# - prop_ins     : BAT[oid,str]  property ID / and processing instruction,
# - prop_tgt     : BAT[oid,str]  property ID / and processing instruction target,
#
# - attr_own  : BAT[oid,oid]  attribute ID / pre-value of owner
# - attr_qn   : BAT[oid,oid]  attribute ID / and qname/property ID
# - attr_prop : BAT[oid,oid]  attribute ID / value ID
#
# - prop_val  : BAT[oid,str]  value ID / value of attribute nodes
#
# Global information on persistent stored documents:
# - doc_name      : BAT[oid,str]        document ID / document name
# - doc_height    : BAT[oid,int]        document ID / height of document
# - doc_size      : BAT[oid,lng]        document ID / size in bytes
# - doc_timestamp : BAT[oid,timestamp]  document ID / end-of-cache-time (nil if none)
# - uri_lifetime  : BAT[str,lng]        URI prefix  / time-to-live (seconds), nil if not to be cached 
# 
# Information on documents/containers in the working set:
# - PRE_CONT       BAT[void,BAT[void,oid]] list of bats with containers
#                  oids for each pre value (copied in element construction)
# - ATTR_CONT      BAT[void,BAT[void,oid]] list of bats with containers
#                  oids for each attr value (copied in element/attribute construction)
# - CONT_COLL      BAT[void,oid] container-ID / collection-ID
#                  (starts with 1@0 because WS is first 'loaded' document
# - HEIGTH         BAT[void,int] enumeration of the containers / maximal
#                  depth of the container (starts with 0@0 - WS)
# - CONT_DOCID     BAT[oid,oid] container-ID / docid (this is local to ws, NOT a key to doc_* tables) 
#
# - DOCID_OID      BAT[void,oid] docid / persistent document-ID (the key to the doc_* tables)
# - DOCID_NAME     BAT[void,str] docid / document name

module(pf_support); 

@- ws definition

This macro is used for the MIL const defs, the C const defs,
but also in the MIL procs for creating, filling and destroying
a working set.

We define a table with the column name, its number,
the type of data (typically again a bat), and if
so the head and tail type of that bat.

actually the field 'tpe' is taken to be bat *always*, 
EXCEPT when (child-T == void)

('tpe' = void means it is a view; without persistent name)

All ws entries starting with '_' are master bats, whereas 
their versions with '_' copies/views. The latter ones
are used for querying, as they provide isolation against
concurrent updates.

         name       number  htp  ttp  col[H,T]    col-seqbase 
         ========   ======  ===  ===  ==========  ===========
@= ws
@:@1_ws(PRE_SIZE,       0, void, bat, void,  int, PRE_BASE)@
@:@1_ws(PRE_LEVEL,      1, void, bat, void,  chr, PRE_BASE)@
@:@1_ws(PRE_PROP,       2, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(PRE_KIND,       3, void, bat, void,  chr, PRE_BASE)@
@:@1_ws(PRE_NID,        4, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(WS_FRAG,        5, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(MAP_PID,        6, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(NID_RID,        7, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(QN_URI,         8, void, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_PREFIX,      9, void, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_LOC,        10, void, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_TEXT,     11, void, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_COM,      12, void, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_INS,      13, void, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_TGT,      14, void, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_VAL,      15, void, bat, void,  str, PRE_BASE)@
@:@1_ws(ID_NID,        16, void, bat,  str,  oid, oid(nil))@
@:@1_ws(IDREF_NID,     17, void, bat,  str,  oid, oid(nil))@
@:@1_ws(ATTR_OWN,      18, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_QN,       19, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_PROP,     20, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(QN_PREFIX_URI, 21, void, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_LOC_URI,    22, void, bat, void,  str, PRE_BASE)@
@:@1_ws(KND_NID_0,     23, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(KND_PROP_0,    24, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(KND_NID_1,     25, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(KND_NID_2,     26, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(KND_NID_3,     27, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(KND_PROP_3,    28, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(KND_NID_4,     29, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(REGION_PRE,    30, void, bat, void,  oid, oid(nil))@
@:@1_ws(REGION_START,  31, void, bat, void,  lng, oid(nil))@
@:@1_ws(REGION_END,    32, void, bat, void,  lng, oid(nil))@
@:@1_ws(PRE_CONT,      33, void, void,void,  oid, PRE_BASE)@
@:@1_ws(ATTR_CONT,     34, void, void,void,  oid, PRE_BASE)@
@:@1_ws(HEIGHT,        35, void, int, void, void, oid(nil))@
@:@1_ws(DOCID_NAME,    36, void, str, void, void, oid(nil))@
@:@1_ws(DOCID_OID,     37, void, oid, void, void, oid(nil))@
@:@1_ws(CONT_DOCID,    38, oid,  oid, void, void, oid(nil))@
@:@1_ws(CONT_COLL,     39, void, oid, void, void, oid(nil))@
@:@1_ws(_RID_SIZE,     40, void, bat, void,  int, PRE_BASE)@
@:@1_ws(_RID_LEVEL,    41, void, bat, void,  chr, PRE_BASE)@
@:@1_ws(_RID_PROP,     42, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_RID_KIND,     43, void, bat, void,  chr, PRE_BASE)@
@:@1_ws(_RID_NID,      44, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_WS_FRAG,      45, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_MAP_PID,      46, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_NID_RID,      47, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_QN_URI,       48, void, bat, void,  str, PRE_BASE)@
@:@1_ws(_QN_PREFIX,    49, void, bat, void,  str, PRE_BASE)@
@:@1_ws(_QN_LOC,       50, void, bat, void,  str, PRE_BASE)@
@:@1_ws(_PROP_TEXT,    51, void, bat, void,  str, PRE_BASE)@
@:@1_ws(_PROP_COM,     52, void, bat, void,  str, PRE_BASE)@
@:@1_ws(_PROP_INS,     53, void, bat, void,  str, PRE_BASE)@
@:@1_ws(_PROP_TGT,     54, void, bat, void,  str, PRE_BASE)@
@:@1_ws(_PROP_VAL,     55, void, bat, void,  str, PRE_BASE)@
@:@1_ws(_ID_NID,       56, void, bat,  str,  oid, oid(nil))@
@:@1_ws(_IDREF_NID,    57, void, bat,  str,  oid, oid(nil))@
@:@1_ws(_ATTR_OWN,     58, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_ATTR_QN,      59, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_ATTR_PROP,    60, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_QN_PREFIX_URI,61, void, bat, void,  str, PRE_BASE)@
@:@1_ws(_QN_LOC_URI,   62, void, bat, void,  str, PRE_BASE)@
@:@1_ws(_KND_NID_0,    63, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_KND_PROP_0,   64, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_KND_NID_1,    65, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_KND_NID_2,    66, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_KND_NID_3,    67, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_KND_PROP_3,   68, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_KND_NID_4,    69, void, bat, void,  oid, PRE_BASE)@
@:@1_ws(_REGION_PRE,   70, void, bat, void,  oid, oid(nil))@
@:@1_ws(_REGION_START, 71, void, bat, void,  lng, oid(nil))@
@:@1_ws(_REGION_END,   72, void, bat, void,  lng, oid(nil))@

@-
BEWARE: WS_SIZE (below) should *always* be the size of ws (above)

@= decl
@:@1_decl_ws(WS_SIZE, 60)@
@:@1_decl_ws(QNAME,    2)@
@:@1_decl_ws(BOOL,     3)@
@:@1_decl_ws(INT,      4)@
@:@1_decl_ws(DEC,      5)@
@:@1_decl_ws(DBL,      6)@
@:@1_decl_ws(STR,      7)@
@:@1_decl_ws(U_A,      8)@
@:@1_decl_ws(ATOMIC,  31)@
@:@1_decl_ws(NODE,    32)@
@:@1_decl_ws(ELEM,    33)@
@:@1_decl_ws(ATTR,    34)@

@= mil_decl_ws
const @1 := @2;
@mil
@:ws(mil_decl)@
@:decl(mil)@

# DEFINITION of constants concerning the data model
const PRE_BASE := 0@0;
const ELEMENT := chr(0);
const TEXT := chr(1);
const COMMENT := chr(2);
const PI := chr(3);
const DOCUMENT := chr(4);
const WS := 0@0;

const KND_NID  := new(chr,int,5);
const KND_PROP := new(chr,int,2);
{
    var knd := ELEMENT;
    var idx := KND_NID_0;
    while ( knd <= DOCUMENT ) {
        KND_NID.insert(knd,idx);
        idx :+= 1;
        if ( (knd = ELEMENT) or (knd = PI) ) {
            KND_PROP.insert(knd,idx);
            idx :+= 1;
        }
        knd :+= chr(1);
    }
}
KND_NID .access(BAT_READ);
KND_PROP.access(BAT_READ);

# ATOMIC is not a type but all atomic types
# can be retrieved with 'select(int(nil),ATOMIC)'

# NODE is not a type but all node types
# can be retrieved with 'select(NODE,int(nil))'


@- shared BATs

Note that MIL variables are not shared between concurrent MIL sessions. Therefore, we need the pflock()
command to get a global lock handle for synchronization. However, BATs are global objects and may be
shared. This mechanism is used to share the global data structures (each XQuery session has its own
MIL variables, but these point to the same global BATs).

@= create_ws
    ws_nme.append(toLower("@1"));
    ws_tpe.append(@4);
    ws_htp.append(@5);
    ws_ttp.append(@6);
    ws_seq.append(@7);
@mil
# get a handle to the global lock
var pf_lock := pflock(); 

# the set of document collections
var collection_name; # collection name 
var doc_name;        # document name
var doc_location;    # document URI
var doc_collection;  # collection-id 
var doc_root;        # root oid in collection 
var doc_height;      # height of document
var doc_size;        # document size in bytes
var doc_timestamp;   # caching limit (nil if none)

const TEMP_DOC := 0@0; # reversed for temp docs (invalid key for doc table)

# caching rules
var uri_lifetime; 

# (logical) document usage
var doc_query; # bat[oid,int] active working-sets (queries) that use a particular document 
var doc_sema;  # bat[oid,sema] used by delete_doc to wait until all doc users have gone

# (physical) collection usage
var coll_lock;  # bat[oid,lock] used by append_page() to ensure unique pages are given out size
var coll_free;  # bat[oid,bat]  per document a list with all free pages smaller than the master size

# empty pages to append onto rid_* master bats
var empty_page;  # bat[void,int] of size REMAP_PAGE_SIZE counting down from REMAP_PAGE_SIZE-1

# the ws_* bats contain a recipe for creating a new ws
var ws_nme; # name (prefix) of ws entry as persistent bat
var ws_tpe; # type of ws entry (often bat)
var ws_htp; # (if tpe=bat) head-type of nested bat
var ws_ttp; # (if tpe=bat) tail-type of nested bat
var ws_seq; # (if tpe=bat) seqbase of nested bat
var ws_col; # all ws entries that are real bats, and their names
var ws_dsk; # of those, all persistent bats on disk for a document container , and their names
var ws_rid; # of those, all master rid_* bats, and their (remapped) pre_* views
var ws_mem; # of those, all master non-rid_* bats, and their (copy-on-write) updatable views 
var ws_shr; # all bats delivered by shredder, and their future persistent names

# standoff extensions
var standoff := false;
if (monet_environment.exist("standoff"))
    standoff := =(monet_environment.find("standoff"),"enabled"); 

# initialize doc_query and doc_sema (use BBP as global mechanism to discover initialization)
# note that this is required for concurrent MapiClient MIL sessions to share each other's variables.
lock_set(pf_lock);
if (isnil(CATCH(bat("doc_name").count()))) {
    collection_name  := bat("collection_name");
    doc_name         := bat("doc_name");
    doc_location     := bat("doc_location");
    doc_collection   := bat("doc_collection");
    doc_root         := bat("doc_root");
    doc_timestamp    := bat("doc_timestamp");
    doc_height       := bat("doc_height");
    doc_size         := bat("doc_size");
    uri_lifetime     := bat("uri_lifetime");
} else {
    # create doc_name table in case it does not exist
    (collection_name := new(oid,str).persists(true)).bbpname("collection_name");
    (doc_name        := new(oid,str).persists(true)).bbpname("doc_name");
    (doc_location    := new(oid,str).persists(true)).bbpname("doc_location");
    (doc_collection  := new(oid,oid).persists(true)).bbpname("doc_collection");
    (doc_root        := new(oid,oid).insert(0@0,0@0).persists(true)).bbpname("doc_root");
    (doc_timestamp   := new(oid,timestamp).persists(true)).bbpname("doc_timestamp");
    (doc_height      := new(oid,int).persists(true)).bbpname("doc_height");
    (doc_size        := new(oid,lng).persists(true)).bbpname("doc_size");
    (uri_lifetime    := new(str,lng).persists(true)).bbpname("uri_lifetime");
}
if (not(doc_height.exist(TEMP_DOC))) {
    doc_height.insert(TEMP_DOC, 1000); # hack: store next oid as in invalid TEMP_DOC tuple
}
if (isnil(CATCH(bat("doc_query").count()))) {
    doc_query  := bat("doc_query"); 
    doc_sema   := bat("doc_sema"); 
    coll_lock  := bat("coll_lock"); 
    coll_free  := bat("coll_free"); 
    empty_page := bat("empty_page"); 
    ws_nme     := bat("ws_bat");
    ws_tpe     := bat("ws_tpe"); 
    ws_htp     := bat("ws_htp");
    ws_ttp     := bat("ws_ttp");
    ws_seq     := bat("ws_seq");
    ws_col     := bat("ws_col");
    ws_dsk     := bat("ws_dsk");
    ws_rid     := bat("ws_rid");
    ws_mem     := bat("ws_mem");
    ws_shr     := bat("ws_shr");
} else {
    (doc_query := new(oid,int)).bbpname("doc_query"); 
    (doc_sema  := new(oid,monet_atomtbl.find("sema"))).bbpname("doc_sema"); 
    (coll_lock := new(oid,monet_atomtbl.find("lock"))).bbpname("coll_lock"); 
    (coll_free := new(oid,bat)).bbpname("coll_free"); 
    (empty_page:= new(void,int,REMAP_PAGE_SIZE)).bbpname("empty_page"); 

    var m := int(nil), i := int(REMAP_PAGE_SIZE);
    var bak := debugmask();
    debugmask(0);
    while((i :-= 1) >= 0) {
        empty_page.append(nilor(i, m));
    }
    debugmask(bak);
    empty_page.seqbase(0@0).access(BAT_READ);

    ws_nme := bat(void,str,WS_SIZE);
    ws_tpe := bat(void,int,WS_SIZE);
    ws_htp := bat(void,int,WS_SIZE);
    ws_ttp := bat(void,int,WS_SIZE);
    ws_seq := bat(void,oid,WS_SIZE);
    @:ws(create)@
    ws_nme.seqbase(0@0).access(BAT_READ).bbpname("ws_nme");
    ws_tpe.seqbase(0@0).access(BAT_READ).bbpname("ws_tpe");
    ws_htp.seqbase(0@0).access(BAT_READ).bbpname("ws_htp");
    ws_ttp.seqbase(0@0).access(BAT_READ).bbpname("ws_ttp");
    ws_seq.seqbase(0@0).access(BAT_READ).bbpname("ws_seq");

    ws_col := ws_tpe.ord_uselect(bat).mirror().leftfetchjoin(ws_nme);
    ws_col.bbpname("ws_col");
    ws_dsk := ws_nme.reverse().ord_select(oid(_RID_SIZE), oid(nil)).reverse();
    ws_dsk.bbpname("ws_dsk");
    ws_rid := [int](ws_dsk.mirror().ord_select(oid(_RID_SIZE), oid(_RID_NID))).[-](_RID_SIZE - PRE_SIZE).[oid]();
    ws_rid.bbpname("ws_rid");
    ws_mem := [int](ws_dsk.mirror().ord_select(oid(_WS_FRAG), oid(nil))).[-](_RID_SIZE - PRE_SIZE).[oid]();
    ws_mem.bbpname("ws_mem");
    ws_shr := [+]("_", reverse(reverse(ws_col).ord_select(oid(nil), oid(PRE_CONT - 1))).[substitute]("pre_", "rid_", false));
    ws_shr.bbpname("ws_shr");
}
lock_unset(pf_lock);


PROC ws_bat(oid id, int tpe, int htp, int ttp, oid seq) : BAT[void,any]
{
    if ((ttp != void) and (int(id) < _RID_SIZE)) { # a bat of bats (persistent or view)
        var b := bat(htp,ttp,10000);
        if (not(isnil(seq))) b.seqbase(seq); 
        return bat(void,bat).seqbase(PRE_BASE).append(b);
    } 
    return bat(void,tpe).seqbase(PRE_BASE); # a constant bat
}

PROC create_ws () : BAT[void,bat]
{
    # only instantiates the default views of the ws-bats (not the master bats)
    var ws := [ws_bat](mirror(ws_tpe), ws_tpe, ws_htp, ws_ttp, ws_seq);

    # fill the constant bats with initial values
    ws.fetch(CONT_COLL).seqbase(1@0);       # no entry for transient container
    ws.fetch(HEIGHT).seqbase(0@0).append(0);

    # add identical bat references as 'master' bats just to make the transient container complete  
    [append](mirror(ws_rid).leftfetchjoin(ws), [fetch](ws_rid.leftfetchjoin(ws), 0));
    [append](mirror(ws_mem).leftfetchjoin(ws), [fetch](ws_mem.leftfetchjoin(ws), 0));

    return ws.access(BAT_READ);
}

PROC destroy_ws_locked(BAT[void,bat] ws) : void
{
    doc_query.select(int(ws))@batloop() {
        var doc_oid := $h;
        var coll_oid := doc_collection.find($h);

        doc_query.delete(doc_oid, int(ws));
        if (not(reverse(doc_collection).join(doc_query).exist(coll_oid))) {
            coll_lock.find(coll_oid).lock_destroy();
            coll_lock.delete(coll_oid);
            coll_free.delete(coll_oid);
        }
        if (not(doc_query.exist(doc_oid))) {
            if (doc_sema.exist(doc_oid)) {
                sema_up(doc_sema.find(doc_oid));
            }
        }
    }
    # determine whether a cache flush is desired (only count cached bats, those with a timestamp)
    var cursize := sum(doc_timestamp.select(timestamp(nil),timestamp(nil)).mirror().join(doc_size));
    var maxsize := (1024LL * 1024LL) * lng(monet_environment.find("xquery_cacheMB"));

    if (cursize > maxsize) {
        delete_all_docs_locked(true);
    }
}

PROC destroy_ws(BAT[void,bat] ws) : void
{
    var err;

    if (type(doc_query) != bat) { return; }

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(destroy_ws_locked(ws));
    lock_unset(pf_lock);

    if (not(isnil(err))) { ERROR(err); }
}

PROC ws_newpage_locked(BAT[void,bat] ws, oid cont) : oid {
    var coll_oid := ws.fetch(CONT_COLL).find(cont);
    var rid_size  := ws.fetch(_RID_SIZE).find(cont);
    var rid_level := ws.fetch(_RID_LEVEL).find(cont);
    var rid_prop  := ws.fetch(_RID_PROP).find(cont);
    var rid_kind  := ws.fetch(_RID_KIND).find(cont);
    var rid_nid   := ws.fetch(_RID_NID).find(cont);
    var free_pages, i := 0;
    var rid_cnt := count(rid_size);
    var last_pid := 1 + (rid_cnt = 0).ifthenelse(0, (rid_cnt - 1) >> REMAP_PAGE_BITS);
    
    # obtain a free-list of pages
    if (coll_free.exist(coll_oid)) {
        free_pages := coll_free.find(coll_oid);
    } else {
        free_pages := reverse(ws.fetch(MAP_PID).find(cont).uselect(oid(nil))).access(BAT_WRITE);
        coll_free.insert(coll_oid, free_pages);
    }

    # re-use a page from the list; or -if empty- append a new page
    i := count(free_pages);
    if (i > 0) {
        last_pid := free_pages.fetch(i - 1);
        free_pages.reverse().delete(last_pid);
    } else {
        # append a page to the master rid_* table
        var empty_page_chr := empty_page.project(chr(nil));
        var empty_page_oid := empty_page.project(oid(nil));
        var lastpage_size := and(lng(rid_cnt),REMAP_PAGE_MASK);
        if (lastpage_size > 0LL) {
            # take care to fill out the last page (if not yet full)
            rid_size.append(empty_page.slice(lastpage_size,REMAP_PAGE_SIZE), true);
            rid_level.append(empty_page_chr.slice(lastpage_size,REMAP_PAGE_SIZE), true);
            rid_kind.append(empty_page_chr.slice(lastpage_size,REMAP_PAGE_SIZE), true);
            rid_prop.append(empty_page_oid.slice(lastpage_size,REMAP_PAGE_SIZE), true);
            rid_nid.append(empty_page_oid.slice(lastpage_size,REMAP_PAGE_SIZE), true);
        }
        # append the new page
        rid_size.append(empty_page, true);
        rid_level.append(empty_page_chr, true);
        rid_kind.append(empty_page_chr, true);
        rid_prop.append(empty_page_oid, true);
        rid_nid.append(empty_page_oid, true);
    }
    return oid(last_pid);
}

PROC ws_newpage(BAT[void,bat] ws, oid cont) : oid {
    var page_lock := coll_lock.find(ws.fetch(CONT_COLL).find(cont));
    var page_id;

    lock_set(page_lock);
    var err := CATCH(page_id := ws_newpage_locked(ws, cont));
    lock_unset(page_lock);

    if (not(isnil(err))) ERROR("ws_newpage: " + err);
    return page_id;
} 

PROC shred_doc_locked(BAT[str,bat] docBAT, str location, str name, str collection, timestamp ts, int ws, int height) : void 
{
    # get a new persistent doc id
    var doc_id := doc_height.find(TEMP_DOC);
    var ws_frag := docBAT.find("_ws_frag"); 
    var doc_oid := oid(doc_id);

    # determine the collection id for this doc
    var coll_oid := doc_oid;
    if (collection_name.texist(collection)) {
        coll_oid := reverse(collection_name).find(collection);
    } else {
        collection_name.insert(coll_oid, collection);
    }

    # add to meta table
    doc_name.insert(doc_oid, name);
    doc_location.insert(doc_oid, location);
    doc_timestamp.insert(doc_oid, ts);
    doc_height.insert(doc_oid, height);
    doc_size.insert(doc_oid, sum([batsize](docBAT)));
    doc_collection.insert(doc_oid, coll_oid);
    doc_root.insert(doc_oid, ws_frag.fetch(count(ws_frag) - 1)); # last fragment

    # rename all new bats with the doc id as suffix
    [rename](docBAT, [+](str(int(coll_oid)), mirror(docBAT)));
    [persists](docBAT, true);

    # set the next persistent doc id
    while ((doc_id :+= 1) > 1000000000) {
        # if the id has overflown, we look for an unused id (unlikely to occur ever)
        if (not(isnil(CATCH(bat(str(doc_id) + "_rid_size"))))) break;
        if (doc_id > 2000000000) doc_id := 1000000000; # keep cycling to find one
    }
    doc_height.replace(TEMP_DOC, doc_id);

    # add the meta table to the commit set 
    docBAT.insert(str(nil),collection_name);
    docBAT.insert(str(nil),doc_name);
    docBAT.insert(str(nil),doc_location);
    docBAT.insert(str(nil),doc_collection);
    docBAT.insert(str(nil),doc_root);
    docBAT.insert(str(nil),doc_timestamp);
    docBAT.insert(str(nil),doc_height);
    docBAT.insert(str(nil),doc_size);
    docBAT := [bbpname](docBAT);
    if (not(subcommit(docBAT))) 
        ERROR("shred_doc(%s) : commit failed\n", name);

    if (not(isnil(ws))) {
        pin_doc(doc_oid, ws);
    }
}

PROC index_doc(BAT[oid,bat] shredBAT, BAT[str,bat] docBAT) : int
{
    # insert all bats from shredBAT in docBAT
    [insert](const docBAT, ws_shr, shredBAT);

    # these are simple concatenations (to accelerate combined lookup)
    # the replace is because we use this slot for transferring the docseq_pre
    # bat from the shredder to the MIL routines. This is very ugly but I tried
    # to delete the tail of ths shredBAT bat and this did not work. JF
    docBAT.insert("_qn_prefix_uri", docBAT.find("_qn_prefix").[+](str('\1')).[+](docBAT.find("_qn_uri")));
    docBAT.insert("_qn_loc_uri",    docBAT.find("_qn_loc").[+](str('\1')).[+](docBAT.find("_qn_uri")));

    # mapping between immutable node-id's and pre-order ranks (pre==rid, just after shredding)
    var pre_nid := docBAT.find("_rid_nid");

    # create our indices
    var knd := ELEMENT;
    var kinds := docBAT.find("_rid_kind").splitkind();
    while ( knd <= DOCUMENT ) {
        var knd_no  := str(chr(48 + knd));
        var knd_pre := kinds.fetch(int(knd)).hmark(PRE_BASE).chk_order();
        var knd_nid := knd_pre.leftfetchjoin(pre_nid).chk_order();
        if ((htype(knd_nid) != 0) or (head(knd_nid) != "void")) {
            ERROR("pathfinder.mx: index_doc(): htype(knd_nid) = %d, head(knd_nid) = %s !\n",
                  htype(knd_nid), head(knd_nid));
        }
        docBAT.insert("_knd_nid_" + knd_no, knd_nid);
        if ( (knd = ELEMENT) or (knd = PI) ) {
            var knd_prop := knd_pre.leftfetchjoin(docBAT.find("_rid_prop")).chk_order();
            if ((htype(knd_prop) != 0) or (head(knd_prop) != "void")) {
                ERROR("pathfinder.mx: index_doc(): htype(knd_prop) = %d, head(knd_prop) = %s !\n",
                      htype(knd_prop), head(knd_prop));
            }
            docBAT.insert("_knd_prop_" + knd_no, knd_prop);
        }
        knd :+= chr(1);
    }
    docBAT := docBAT.access(BAT_READ);
    return shredBAT.fetch(PRE_LEVEL).max().int() + 1;
}


PROC shred_doc_impl(BAT[str,bat] docBAT, str location, str name, str collection, bit doCommit, str opt, timestamp ts, int ws) : int
{
    var shredRES;

    if (false) {
      var docseq := bat(str,str,4);
      docseq.insert(location,"");
      # docseq.insert("/home/flokstra/scripts/DATA/foo.xml","");
      shredRES := shred2collection(docseq,opt);
      # docseq_pre is a [void,oid] BAT containing the document_pre numbers of
      # the documents in the docseq BAT in the same order.
      var docseq_pre := shredRES.fetch(ATTR_PROP+1);
    } else {
      shredRES := shred2bats(location,"",opt);
    }
    var err, exists := false;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(exists := doc_name.texist(name));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
    else if (exists) ERROR("shred_doc(%s): already exists in database!\n", name);

    # add indices to the shredded doc, and find out maximum doc height
    var height := index_doc(shredRES, docBAT);

#[StandOff] [FIXME: OBSOLETE CODE], we do not use persistent region-indices anymore
    # TODO: remove REGION_PRE, REGION_START and REGION_END from document-bats
    #if (standoff) {
    #    print("# extracting regions...\n");
    #    docBAT := region_extract(docBAT, "lng");
    #} else {
       var r_nid, r_start, r_end;
       (r_nid := bat(void, oid).seqbase(0@0)).bbpname("_region_pre");
       (r_start := bat(void, lng).seqbase(0@0)).bbpname("_region_start");
       (r_end := bat(void, lng).seqbase(0@0)).bbpname("_region_end");
       docBAT.access(BAT_WRITE).insert("_region_pre",r_nid); 
       docBAT.access(BAT_WRITE).insert("_region_start",r_start); 
       docBAT.access(BAT_WRITE).insert("_region_end",r_end); 
    #}
#[/StandOff]
    if (collection != name) {
        # TODO: modify shredder such that it adds to the bats rather than creating new ones 
        #       also think of rebuilding/extending to the indices!
        ERROR("shredding of multi-document collections is not yet implemented");
    } 
    if (doCommit) {
        [save](docBAT.[access](BAT_WRITE).[access](BAT_READ)); # flush to disk before locking
        [mmap](docBAT, [ifthenelse]([<]([count](docBAT), 4*int(REMAP_PAGE_SIZE)), STORE_MEM, STORE_MMAP));

        # add doc to the database locked
        lock_set(pf_lock);
        err := CATCH(shred_doc_locked(docBAT, location, name, collection, ts, ws, height));
        lock_unset(pf_lock);

        if (not(isnil(err))) ERROR(err);
    }
    return height;
}

PROC shred_doc_base(str location, str name, str collection, bit doCommit, str opt) : void
{
    var us := usec();
    var docBAT := bat(str,bat,WS_SIZE);
    shred_doc_impl(docBAT, location, name, collection, doCommit, opt, timestamp(nil), int(nil));
    var ms := (us := usec() - us) / 1000;
    if ( doCommit ) {
        printf("# Shredded XML doc(\"%s\"), total time after commit=%lld.%03llds\n", name, /(ms,1000),%(ms,1000));
    } else {
        printf("# Shredded XML doc(\"%s\") uncommitted, total time =%lld.%03llds\n", name, /(ms,1000),%(ms,1000));
    }
}
PROC shred_doc_base(str location, str name, bit doCommit, str opt) : void
{
    shred_doc_base(location, name, name, doCommit, opt); 
}

PROC shred_doc(str location, str name) : void
{
    shred_doc_base(location, name, true, "0");
}

PROC shred_doc(str location, str name, int perc) : void
{
    shred_doc_base(location, name, true, str(perc));
}
ADDHELP("shred_doc", "flokstra", "Dec 2004",
"PARAMETERS:\n\
- str URI containing the xml document to be shredded)\n\
- str document name ('alias') in database\n\
DESCRIPTION:\n\
Shred xml document to the internal Pathfinder format, (analog to import_doc()).",
"pathfinder");

PROC delete_doc_locked(oid doc_oid) : bit
{
    var docBAT := new(void,str,WS_SIZE);

    if (doc_sema.exist(doc_oid)) {
        # somebody else is deleting the same doc!
        while(doc_sema.exist(doc_oid)) {
            lock_unset(pf_lock);
            sleep(1);
            lock_set(pf_lock);
        }
        return; # now he is done
    }
    # we will delete it
    while (doc_query.exist(doc_oid)) {
        var sem := sema_create(0);
        doc_sema.insert(doc_oid, sem);

        lock_unset(pf_lock);
        sema_down(sem); # wait for the users to go away 
        lock_set(pf_lock);

        sema_destroy(sem);
        doc_sema.delete(doc_oid, sem);
    }

    var coll_oid := doc_collection.find(doc_oid);
    doc_name.delete(doc_oid);
    doc_location.delete(doc_oid);
    doc_collection.delete(doc_oid);
    doc_root.delete(doc_oid);
    doc_timestamp.delete(doc_oid);
    doc_height.delete(doc_oid);
    doc_size.delete(doc_oid);

    if (not(doc_collection.texist(coll_oid))) {
        collection_name.delete(coll_oid); # delete empty collection (kludge?)

        # docBAT becomes [name,bat]
        docBAT := [bat]([+](str(int(coll_oid)), ws_dsk).reverse().mirror());

        # rename the bats so even in case of failure they don't bother us directly anymore
        [rename](docBAT, [+]([+]("rm_", mirror(docBAT)), +("_" , str(lng(current_timestamp()))))).access(BAT_WRITE);

        # remove them from the repository
        [persists](docBAT, false);
    }

    # also commit the meta bats
    docBAT := [bbpname](docBAT).access(BAT_WRITE);
    docBAT.insert(str(nil), "doc_name");
    docBAT.insert(str(nil), "doc_location");
    docBAT.insert(str(nil), "doc_collection");
    docBAT.insert(str(nil), "doc_root");
    docBAT.insert(str(nil), "doc_timestamp");
    docBAT.insert(str(nil), "doc_height");
    docBAT.insert(str(nil), "doc_size");
    return subcommit(docBAT);
}

PROC delete_doc(str name) : void
{
    var err, exists := false;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(exists := doc_name.texist(name));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
    else if (not(exists)) ERROR("delete_doc(%s): document not found in database!\n", name);

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(delete_doc_locked(doc_name.reverse().find(name)));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
}
ADDHELP("delete_doc", "tsheyar", "July 2004",
"PARAMETERS:\n\
str document name\n\
DESCRIPTION:\n\
delete the persistent BATS that store the document.",
"pathfinder");

PROC delete_all_docs_locked(bit cachedOnly) : void
{
    doc_timestamp.copy()@batloop() {
        if (not(and(cachedOnly, isnil($t))))
            delete_doc_locked($h);
    }
}

PROC delete_all_docs(bit cachedOnly) : void
{
    var err, b := bat(timestamp,str);

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(delete_all_docs_locked(cachedOnly));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
}
ADDHELP("delete_all_docs", "tsheyar", "July 2004",
"DESCRIPTION:\n\
deletes all persistent document BATs that store xml documents;\n\
with parameter TRUE, only the (implicitely) cached documents are deleted,\n\
with parameter FALSE, also the (explicitely) shredded documents are deleted.",
"pathfinder");


PROC pin_doc(oid doc_oid, int ws) : void 
{
    # pin the document on this working set (must hold lock!)
    doc_query.insert(doc_oid, int(ws));
    var coll_oid := doc_collection.find(doc_oid);
    if (not(coll_lock.exist(coll_oid))) {
          coll_lock.insert(coll_oid, lock_create());
    }
}


# get filename if the URI is a file; else return str(nil)
PROC doc_filename(str name) : str
{
    var uri_idx := -1;
    if (startsWith(name, "file://") or startsWith(name, "FILE://")) {
        name := string(name, 7);
     } else if (search(name, "://") >= 0) {
        return str(nil);
     }
     return name;
}

# get the actual timestamp of the document cached in the database
PROC doc_curtime(str filename) : timestamp {
    var ts := current_timestamp();
    if (not(isnil(filename))) {
        # a file: get lastmodification time
        var tts, err := CATCH(tts := lastmod_time(filename));
        if (isnil(err)) ts := tts;
    }
    return ts;
}

PROC add_docbat(BAT[void,bat] ws, BAT[str,bat] docBAT, str name, oid doc_oid, oid coll_oid, int height) : oid
{
    var cont, docid := oid(count(ws.fetch(DOCID_OID)));

    if (ws.fetch(CONT_COLL).texist(coll_oid)) {
        # collection is already part of the working set
        cont := reverse(ws.fetch(CONT_COLL)).find(coll_oid);
    } else {
        # add the collection to the working set
        var pre, mem, dsk, dst := ws_col.mirror().leftfetchjoin(ws);

        if (doc_oid = TEMP_DOC) { 
            # temporary shredded (read-only) doc; no isolation needed 
            coll_oid := TEMP_DOC;                     # must pass oid(nil) for TEMP_DOCs!!
            dsk := ws_dsk.leftjoin(docBAT);           # doc has just been shredded into docBAT
            pre := reverse(ws_rid).leftjoin(dsk);     # pre_*'s are identical to rid_*
            mem := reverse(ws_mem).leftjoin(dsk);     # other bats are also just the same bats
        } else {
            # here we get transaction isolation: pre's are remapped views, and mem are normal views
            dsk := [bat]([+](str(int(coll_oid)), ws_dsk));
            var map_pid := dsk.find(oid(_MAP_PID)).select(oid(nil),oid(nil)).reverse().sort().tmark(0@0);
            pre := [remap](reverse(ws_rid).leftjoin(dsk), const map_pid, false);
            mem := [rcopy](reverse(ws_mem).leftjoin(dsk));
        }
        # use the ws_* bats to add all bats to the working set in a multiplex
        [append](dst, pre.access(BAT_WRITE).insert(mem).insert(dsk));

        # create views for the container-id (which is constant within a doc)
        ws.fetch(CONT_COLL).append(coll_oid);
        cont := oid(count(ws.fetch(CONT_COLL)));

        var cont_bat := constant2bat(cont);
        ws.fetch(PRE_CONT).append(cont_bat);
        ws.fetch(ATTR_CONT).append(cont_bat);

        if (isnil(height))
            height := ws.fetch(PRE_LEVEL).max().int() + 1;
        ws.fetch(HEIGHT).append(height);
    }
    if (not(ws.fetch(DOCID_NAME).texist(name))) {
        # add the document to the working set
        ws.fetch(DOCID_OID).append(doc_oid);
        ws.fetch(DOCID_NAME).insert(docid, name);            
        ws.fetch(CONT_DOCID).insert(cont, docid);            
    }
    return cont;
}


PROC add_doc_locked(str name, timestamp ts, int ws) : oid 
{
    var doc_oid := oid(nil);
    # check if the document already existed
    if (doc_name.texist(name)) {
        doc_oid := doc_name.reverse().find(name);
    } else if (doc_location.texist(name)) {
        # existed as cached location (URI): must check timestamp
        doc_oid := doc_location.reverse().find(name);
    }
    if (not(isnil(doc_oid))) {
        var lim := doc_timestamp.find(doc_oid);
        if (not(isnil(lim))) { # a nil limit means the doc never expires
            if  (ts > lim) {
                delete_doc_locked(doc_oid); # remove outdated document from the cache
                return oid(nil);
            }
        }
        pin_doc(doc_oid, ws); # GOT IT! make sure nobody can delete it
     }
     return doc_oid;
}

PROC lifetime_doc_locked(str name, str filename, oid doc_oid, timestamp ts) : timestamp
{
    if (isnil(doc_oid) and isnil(filename)) {
        # for not-yet-cached URIs: get lifetime from uri_lifetime BAT
        var b := [startsWith](name, mirror(uri_lifetime)).uselect(true);
        var lifetime := lng(nil);
        if (b.count() > 0) {
            var matchlen := [length](mirror(b));
            lifetime :=  *(1000LL, uri_lifetime.find(matchlen.reverse().find(matchlen.max())));
        }
        # this may set ts to nil; such URIs are never cached (and thus do not need to be persistent)
        ts := ts.add(lifetime);
    }
    return ts;
}

PROC add_doc(BAT[void,bat] ws, str name) : int
{
    var time_shred := 0; 
    var filename := doc_filename(name);
    var t := time();
    var coll_oid := oid(nil);
    var doc_oid := oid(nil);
    var ts := doc_curtime(filename);
    var err;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(doc_oid := add_doc_locked(name,ts,int(ws)));
    if (isnil(err)) err := CATCH(ts := lifetime_doc_locked(name,filename,doc_oid,ts));
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
    var docBAT := new(str,bat,WS_SIZE);
    var doCommit := true;
    var height;

    if (isnil(doc_oid)) {
        if (isnil(ts)) {
            doc_oid := TEMP_DOC;
            doCommit := false;
        }
        height := shred_doc_impl(docBAT, name, name, name, doCommit, "0", ts, int(ws));
        time_shred :+= time() - t;
    }
    if (isnil(doc_oid) or (doc_oid != TEMP_DOC)) {
        doc_oid := doc_name.reverse().find(name);
        coll_oid := doc_collection.find(doc_oid);
        height := doc_height.find(doc_oid);
    }
    add_docbat(ws, docBAT, name, doc_oid, coll_oid, height);
    return time_shred;
}


@- xml document cache
When fn:doc() is used with a previously unseen URI, it is shredded on the fly and placed into 
the xml document cache (see text below). A number of procs are provided to monitor
and control the behavior of the cache.
@mil
const xmlcache_help := 
"The XML document cache keeps indexed copies of documents that where recently\n\
used in the fn:doc(URI) xquery function.\n\
\n\
The size of the cache is controlled using the 'xquery_cacheMB' setting in\n\
the 'MonetDB.conf' file.\n\
\n\
For file URIs, the cache looks at the last-modification-time of the file on disk\n\
to guarantee that the cached document is still up-to-date for answering queries from.\n\
\n\
For other URIs, *lifetime rules* determine how long documents can stay in the cache.\n\
Each lifetime rule consists of a URI prefix and the registered seconds of lifetime.\n\
\n\
The rule with longest prefix that matches an URI counts. Specifying a lifetime\n\
of 'int(nil)' seconds means that the URI will *not* be cached at all.\n\
This is also the default if no prefix matches an URI.\n\
\n\
The name of a cached document is the same as its location (URI). For explicitly\n\
shredded documents (with 'shred_doc(location,name)'), the name is an 'alias' and\n\
may differ from the URI. Explicitly shredded documents fall outside the XML document\n\
cache; documents are only removed at explicit user request (with 'delete_doc(name)').";

PROC xmlcache_add_rule(str uri, any lifetime) : void {
    xmlcache_add_rule(uri, lng(lifetime)); 
}
PROC xmlcache_add_rule(str uri, lng lifetime) : void {
    lock_set(pf_lock);
    var err := CATCH({ uri_lifetime.delete(uri); uri_lifetime.insert(uri, lifetime); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_add_rule", "boncz", "May 2005",
"DESCRIPTION:\nadd a new URI lifetime rule.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_del_rule(str uri) : void {
    lock_set(pf_lock);
    var err := CATCH({ uri_lifetime.delete(uri);});
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_del_rule", "boncz", "May 2005",
"DESCRIPTION:\ndeletes an existing URI lifetime rule.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_print_rules() : void {
    lock_set(pf_lock);
    var err := CATCH({  table(uri_lifetime.hmark(0@0).col_name("URI-prefix"), uri_lifetime.tmark(0@0).col_name("liftime-secs")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_print_rules", "boncz", "May 2005",
"DESCRIPTION:\nshows all URI lifetime rules.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_print() : void {
    lock_set(pf_lock);
    var err := CATCH({  table( doc_name.col_name("alias"), doc_location.col_name("URI"), doc_size.col_name("size"), doc_timestamp.select(timestamp(nil),timestamp(nil)).col_name("valid-thru")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_print", "boncz", "May 2005",
        "DESCRIPTION:\nshows the actual content of the XML document cache.\n\n" + xmlcache_help,  "pathfinder");

PROC xmldb_print() : void {
    lock_set(pf_lock);
    var err := CATCH({  table( tsort(mirror(doc_timestamp.uselect(timestamp(nil))).join(doc_collection).join(collection_name)).col_name("collection"), doc_name.col_name("alias"), doc_location.col_name("URI"), doc_size.col_name("size")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmldb_print", "boncz", "May 2005",
"DESCRIPTION:\nshows the actual content of the persistent XML document database (not the XML document cache).\n\nThis consists of all documents explicitly shredded with shred_doc(URI, alias).",  "pathfinder");

@= c_decl_ws
#define @1 @2
@h
#ifndef PATHFINDER_H
#define PATHFINDER_H

#include <monet.h>
#include <monettime.h>
#include <lock.h>
#include <monet_context.h>
#include <monet_interpreter.h>
#include <streams.h>
#include <mapi.h>
#include <sys.h>
#include <pathfinder.proto.h>

#define is_fake_project(b) (((b)->htype==TYPE_void) && (BATcount(b)==1) && ((b)->hseqbase==oid_nil))

@:ws(c_decl)@
@:decl(c)@

#define XTRACT_KIND(X)     (X & 63)
#define XTRACT_CONT(X)     (X >> 6)
#define SET_CONT_KIND(X,Y) (X << 6 | Y)

/* xquery_method : execute a loop-lifted xquery function
 *
 * argc          = #params
 * itercnt       = #iterations
 * argcnt[iter]  = #items per param 
 * argtpe[]      = xquery type of each parameter (as string, e.g. 'xs:integer')
 * argval[]      = str representation of item (e.g. '42')
 *
 * shredBAT   = optional shredded document table, that is added to working set
 *              params of type xs:anyNode are represented as int pre-numbers.
 *
 * we return an error string, or NULL iff everything went A-OK  
 */
pathfinder_export char *
xquery_method(stream *out, 
              int rpctiming,
              char* module, 
              char* uri, 
              char *method, 
              int argc, 
              int itercnt, 
              int** argcnt, 
              str* argtpe, 
              str* argval, 
              BAT* shredBAT);

#endif
@c
#include "pathfinder.h"

#define XQUERY_BUFSIZE 16364

/* the xquery builtin type hierarchy */
typedef struct {
    int parent;
    int monet_tpe;
    int kind;
    char* name;
} xquery_type;

#define DOCBAT (ELEM | (1<<6))
#define XQUERY_TYPES 15
#define XQUERY_ABSTRACT 6

xquery_type xquery_types[XQUERY_TYPES+1] =
{ {  5, TYPE_bit, BOOL,   "xs:bool"  },  
  {  2, TYPE_lng, INT,    "xs:integer" },
  {  4, TYPE_dbl, DEC,    "xs:decimal" },
  {  4, TYPE_dbl, DBL,    "xs:float" },
  {  5, TYPE_dbl, DBL,    "xs:double" },
  {  7, TYPE_str, STR,    "xs:string" },
  {  8, TYPE_str, STR,    "xs:untypedAtomic" },
  {  8, TYPE_str, STR,    "xdt:anyAtomicType" },
  {  9, TYPE_str, STR,    "xs:anySimpleType" },
  { 14, TYPE_str, STR,    "xs:anyType" },
  { 14, TYPE_str, STR,    "xdt:untypedAny" },
  { 13, TYPE_oid, DOCBAT, "xs:anyElement" },
  { 13, TYPE_oid, DOCBAT, "xs:anyAttribute" },
  { 14, TYPE_oid, DOCBAT, "xs:anyNode" },
  { 15, TYPE_oid, DOCBAT, "xs:anyItem" },
  {  0, TYPE_oid, DOCBAT, "illegal type" } };

/*
 * return xquery type number, given a type string
 */
static int
xquery_typenr(char* tpe) 
{
    int i;
    for(i=0; i<XQUERY_TYPES; i++) 
        if (strcmp(tpe, xquery_types[i].name) == 0) break;
    return i;
}

/*
 * find the common ancestor of two xquery types
 */
static int
xquery_type_common_ancestor(int t1, int t2) 
{
    if (t1 < 0 || t1 >= XQUERY_TYPES) return t2;
    if (t2 < 0 || t2 >= XQUERY_TYPES) return t1;
    while(t1 != t2) {
        if (t1 < t2) t1 = xquery_types[t1].parent;  
        else         t2 = xquery_types[t2].parent;  
    }
    return t1;
} 

/* representation of a xquery function signature */
typedef struct {
    int argc;                     /* number of params */
    unsigned int zero;            /* bit-mask that indicates whether param (bit) i can be the empty sequence */
    unsigned int multiple;        /* bit-mask that indicates whether param (bit) i can be a sequence */
    unsigned char tpe[MAXPARAMS]; /* xquery type number (point into above xquery_types table) */
    char name[1];                 /* method name */
} xquery_sig;


/* xquery functions */
typedef struct _xquery_function {
    struct _xquery_function *next;
    oid vid;                      /* vid of first param */
    lng size;                     /* byte size of prepared tree */
    xquery_sig *sig;              /* method signature */
    char* mil;                    /* generated MIL */
    char  proc[1];                /* MIL procname */
} xquery_function;


/* xquery modules */
typedef struct _xquery_module {
    struct _xquery_module *next;
    char* prologue;               /* MIL procs defined in this module */
    char* epilogue;               /* MIL procs undefs for this module */
    xquery_function *functions;   /* functions declared in this module */
    char *nsurl;                  /* module namespace definition */
    char url[1];                  /* module url */
} xquery_module;

/* global list of known modules and their function declarations */
xquery_module *xquery_compiled_modules = NULL;


/* cached functions */
typedef struct _xquery_prepared_function {
    struct _xquery_prepared_function *next;
    xquery_function *def;         /* function definition */
    YYSTREE lt;                   /* cached MIL tree */
    unsigned int lru;             /* least recently used stamp */
} xquery_prepared_function;

unsigned int xquery_lru = 0;

/* loaded modules */
typedef struct _xquery_loaded_module {
    struct _xquery_loaded_module *next;
    xquery_module* def;           /* module definition */
    char* ns;                     /* namespace under which the module was loaded */
    int nslen;
} xquery_loaded_module;


/* cached MIL client + Xquery specific context */
typedef struct {
    bit initialized;

    Cntxt stk; /* stack to execute module prologues and non-cacheable queries in */  
    /* MIL child context of ctx->stk; it is marked as a reusable stack frame so variable records are kept */
    Cntxt repeat_stk; /* stk to execute the prepared function trees in  for fast reuse */ 

    /* value parsing buffer reuse */
    int vallen;
    ptr val;

    /* query buffer reuse */
    size_t buflen;
    char *buf;
    int cacheid;        /* only reuse from the same cache */
        
    /* error stream (normally fderr=GDKerr=GDKout) */
    stream *fderr;

    /* live BAT handles (note we gave them a memory refcount in BBP) */
    BAT *proc_vid, *var_usage;
    BAT *dbl_values, *int_values, *str_values;
    BAT *fun_vid000, *fun_iter000, *fun_item000, *fun_kind000, *loop000;

    /* pointers into MIL variable records (to set values) */
    int *shredBAT; 
    int *time_compile; 
    int *time_shred; 
    int *time_exec; 
    int *time_print; 
    char **genType;

    /* counts used to remove query (non-module) procs and stacks after execution */
    size_t var_usage_size; 
    size_t proc_vid_size;

    /* size of the cached procs */
    size_t cachesize;

    xquery_prepared_function* prepared_functions;
    xquery_loaded_module *loaded_modules; 
} xquery_client;

size_t xquery_client_bytes = 64<<20; /* 64MB of procs should be enough for anyone */
int xquery_cacheid = 0;

MT_Lock pf_compiler_lock;
MT_Lock pf_module_lock;
MT_Lock pf_cache_lock;

#include "compile_interface.h"

/*
 * =================== MIL execution ================================
 *
 * int     
 * xquery_tree_exec(xquery_client *ctx, YYSTREE t, int repeat) { 
 * - execute parsed MIL tree
 *
 * YYSTREE 
 * xquery_mil2tree(xquery_client *ctx, char* buf) { 
 * - parse MIL buffer into a tree
 *
 * int
 * xquery_mil_exec(xquery_client *ctx, char* buf, int debug) { 
 * - execute MIL buffer (parse & execute)
 *
 * int
 * xquery_compile_exec(xquery_client *ctx, char *mode, char* xquery, int is_url, 
 *                     char** prologue, char** query, char** epilogue, char* nsurl) 
 * - translate xquery to MIL and execute
 *
 * all int-returning functions return error(0)/ok(1)
 */

/*
 * execute parsed MIL tree, return error(0)/ok(1)
 */
static int 
xquery_tree_exec(xquery_client *ctx, 
                 YYSTREE t, 
                 int repeat) 
{ 
    ValRecord res;
    int ret = interpret(repeat?ctx->repeat_stk:ctx->stk, t, &res);
    if (ret == -TOK_RETURN) {
        /* ignore return value here */
        VALclear(&res);
        ret = 1;
    } else if (ret >= 0) {
        ret = 1;
    } else {
        ret = 0;
    }
    CLEANUP(t);
    return ret;
}

/*
 * parse MIL buffer into a tree
 */
static YYSTREE 
xquery_mil2tree(xquery_client *ctx, 
                char* buf) 
{ 
    Client c = monet_clients + ctx->stk;
    YYSTREE ret = NULL, treebak = c->tree;
    char* bufbak = c->input;
    int listing_bak = c->listing;
    c->listing = 0;
    c->input = buf;
    c->tree = NULL;
    if (parseClient(c, FALSE))
        ret = c->tree;
    c->tree = treebak;
    c->input = bufbak;
    c->listing = listing_bak;
    return ret;
}

/*
 * execute MIL buffer (parse & execute), return error(0)/ok(1)
 */
static int 
xquery_mil_exec(xquery_client *ctx,  
                char* buf, 
                int debug) 
{
    int ret = 0;
    YYSTREE t;

    if (debug)
        stream_write(ctx->fderr, buf, strlen(buf), 1);

    t = xquery_mil2tree(ctx, buf); 
    if (t) {
        ret = xquery_tree_exec(ctx, t, 0);
        Myyfree(t);
    }
    return ret;
}

static char* xquery_parse_ident(char* p); 
static char* xquery_parse_space(char* p); 
static char* xquery_parse_string(char* p, char *buf, int len); 

/*
 * translate xquery to MIL and execute, return error(0)/ok(1)
 * We collect the MIL scripts in three sections (prologue,query,epilogue).
 * The query may be NULL, in which case we mean that it should be ignored. 
 */
#define PFURLCACHE(fcn, query, cache) {\
    char *url = query;\
    query = PFurlcache(url, cache);\
    if (query == NULL) {\
        err = (char*) alloca(strlen(url)+80);\
        sprintf(err, "%s(%s): could not retrieve query\n", fcn, url);\
}    }
static int
xquery_compile_exec(xquery_client *ctx, 
                    char *mode,  
                    char* xquery, 
                    int is_url, 
                    char** prologue, 
                    char** query, 
                    char** epilogue,
                    char* nsurl)
{
    int is_mil = 0, len=0, ret = 0, debug = strstr(mode,"debug") != NULL;
    char *mapi = strstr(mode, "mapi")?"=":"";
    char *err = NULL;

    MT_set_lock(pf_compiler_lock, "xquery_compile_exec");
    if (is_url) {
        int l = strlen(xquery);
        is_mil = (l > 4 && xquery[l-4] == '.' && xquery[l-3] == 'm' && xquery[l-2] == 'i' && xquery[l-1] == 'l');
        PFURLCACHE("xquery_compile_exec", xquery, !is_mil);
    }
    if (err == NULL) {
        char *del = NULL;
        if (is_mil && query == NULL) {
            *prologue = xquery; *epilogue = NULL;
        } else {
            err = PFcompile_MonetDB(xquery, mode, prologue, &del, epilogue);
            if (err == NULL && nsurl != NULL){
                /* get the module namespace URL Y from pattern: "module namespace X = Y" */
                char *p0 = xquery_parse_space(xquery); 
                err = "xquery_compile_exec: cannot parse module namespace.\n";
                if (strncmp(p0, "module", 6) == 0) {
                    char *p1 = xquery_parse_space(p0+=6); 
                    if (p1 > p0 && strncmp(p1, "namespace", 9) == 0) {
                        char *p2 = xquery_parse_space(p1+=9); 
                        if (p2 > p1) {
                            char* p3 = xquery_parse_ident(p2);
                            if (p3 > p2) {
                                char *p4 = xquery_parse_space(p3); 
                                if (p4 > p3 && *p4++ == '=') {
                                    char *p5 = xquery_parse_space(p4); 
                                    if (p5 > p4 && xquery_parse_string(p5, nsurl, 1024) > p5) {
                                        err = NULL; /* success! */
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (err == NULL || (prologue && *prologue) || (del && *del)) {
            ret = 1; /* no errors, or some MIL script came out still */
        }
        if (query) {
            *query = del;
        } else if (del) {
            free(del); /* we are ignoring the query part apparently */
        }
    }
    if (err) {
        len = strlen(err);
        if (*mapi) {
            /* put ! before error lines */
            char *p = err, *q = err;
            while (*p) {
                if (*p++ == '\n')
                    len++;
            }
            err = (char*) alloca(len+3);
            *err = '!'; 
            for (p = err + 1; *q; q++) {
                *p++ = *q;
                if (*q == '\n')
                    *p++ = '!'; 
            }
            /* guard against errors that do not terminate in a newline */
            if (q > err && q[-1] != '\n')
                *p++ = '\n';
            else if (p[-1] == '!')
                p--;
            *p = 0;
            len = p - err;
        }
    }
    MT_unset_lock(pf_compiler_lock, "xquery_compile_exec");
    
    /* write errors and debug info on client stream */
    if (err && *err) stream_write(ctx->fderr, err, len, 1);

    /* execute the three MIL sections */
    if (ret && *prologue && **prologue)
        ret = xquery_mil_exec(ctx, *prologue, debug);

    if (ret && query) {
        if (*query && **query)
            ret = xquery_mil_exec(ctx, *query, debug);

        if (ret && *epilogue && **epilogue)
            ret = xquery_mil_exec(ctx, *epilogue, 0);
    }
    return ret?ret+is_mil:0;
}

/*
 * =================== function admin ================================
 *
 * xquery_sig*
 * xquery_sig_init(char *proc)
 * - infer the xquery function signature from the mangled MIL procname (return NULL on error)
 *
 * int
 * xquery_sig_match(xquery_sig *sig, int argc, int* mincnt, int* maxcnt, int *argtpe)
 * - check whether sig can match the actual parameters (return true/false)
 *
 * xquery_function* 
 * xquery_resolve(xquery_client *ctx, char *ns, char *method, int argc, int *mincnt, int* maxcnt, int* argtpe)
 * - resolve a method call in the current xquery context (return NULL if not resolved)
 *
 * char*
 * xquery_function_call(xquery_client *ctx, int msec, char* mode, char *ns, char *method, 
 *                      int argc, int itercnt, int** argcnt, char** argtpe, char** argval, BAT *shredBAT)
 * - call a function ns:method(). try to use the function cache (ie re-use a cached MIL tree).
 *   otherwise generate MIL yourself, interpret it (and cache it). Returns error string (NULL if ok).
 */

/*
 * infer the xquery function signature from the mangled MIl procname (return NULL on error)
 */
static xquery_sig* 
xquery_sig_init(char *proc) 
{
    char *cur = (char*) alloca(strlen(proc)); 
    xquery_sig* sig;
    int len = 0;

    proc = strchr(proc, '_'); /* skip fnXXXXXXXX_' */
    if (proc == NULL) return NULL;
    strcpy(cur, ++proc);
    sig = (xquery_sig*) GDKmalloc(sizeof(xquery_sig)+strlen(proc)); 
    if (sig == NULL) return NULL;

    sig->argc = sig->zero = sig->multiple = 0;

    /* get method name */
    while(cur[0]) {
        if (cur[0] == '_' && cur[1] == '_') {
            cur++; /* unescape '_' */
        } else if (cur[0] == '_' && (cur[1] == '4' || cur[1] == '5') && cur[2] == '_') {
            sig->name[len++] = (cur[1] == '4')?'-':'.'; cur += 3; continue;
        } else if (cur[0] == '_') {
            break; /* unescaped '_' => end of function name */
        }
        sig->name[len++] = *cur++;
    }
    sig->name[len] = 0;
    while(*cur++ == '_') {
        char *tpe = cur;
                
        /* parse namespace part */
        for(len=0; cur[0]; cur++) {
            if (cur[0] == '_' && cur[1] == '_') {
                tpe[len++] = '_';
                cur++; /* unescape '_' */
            } else if (cur[0] != '_') {
                tpe[len++] = cur[0];
            } else {
                tpe[len++] = ':';
                cur++; break;
            }
        }
        /* parse type part */
        for(; cur[0]; cur++) {
            if (cur[0] == '_' && cur[1] == '_') {
                tpe[len++] = '_';
                cur++; /* unescape '_' */
            } else if (cur[0] != '_') {
                tpe[len++] = cur[0];
            } else {
                break;
            }
        }
        if (cur[-1] == '0') {
            sig->zero |= 1<<sig->argc; 
        } else if (cur[-1]  == '2') {
            sig->zero |= 1<<sig->argc; 
            sig->multiple |= 1<<sig->argc; 
        } else if (cur[-1]  == '3') {
            sig->multiple |= 1<<sig->argc; 
        }
        cur[-1] = 0;
        if ((sig->tpe[sig->argc++] = xquery_typenr(tpe)) >= XQUERY_TYPES) {
            /* unknown type: don't cache this function */
            GDKfree(sig);
            return NULL;
        }
    }
    return sig;
}


/*
 * check whether sig can match the actual parameters (return true/false)
 */
static int
xquery_sig_match(xquery_sig *sig, int argc, int* mincnt, int* maxcnt, int *argtpe) 
{
    int i, tpe[MAXPARAMS];
    for(i=0; i < argc; i++) {
        if (mincnt[i] == 0 && !(sig->zero & (1<<i))) return 0; 
        if (maxcnt[i] > 1 && !(sig->multiple & (1<<i))) return 0; 
        tpe[i] = argtpe[i];
        while(sig->tpe[i] != tpe[i]) {
            if (tpe[i] >= XQUERY_TYPES) return 0;
            tpe[i] = xquery_types[tpe[i]].parent;
        }
    }
    for(i=0; i< argc; i++) {
        argtpe[i] = tpe[i];
    }
    return 1;
}

/*
 * resolve a method call in the current xquery context (return NULL if nonresolved)
 */
static xquery_function*
xquery_resolve(xquery_client *ctx, char *ns, char *method, int argc, int *mincnt, int* maxcnt, int* argtpe) 
{
    xquery_loaded_module *mod = ctx->loaded_modules;
    int nslen = strlen(ns);

    /* look up ns and method */
    while(mod) {
        if (mod->nslen == nslen && strncmp(mod->ns, ns, nslen) == 0) {
            xquery_function *fun = mod->def->functions;
            while(fun) {
                if (argc == fun->sig->argc && strcmp(method, fun->sig->name) == 0) {
                    if (xquery_sig_match(fun->sig, argc, mincnt, maxcnt, argtpe)) return fun;
                }
                fun = fun->next;
            }
        }
        mod = mod->next;
    }
    return NULL;
}


@= seqbase
    BATseqbase(ctx->@1, @2);
    if (debug) m += snprintf(mil+m, XQUERY_BUFSIZE-l, "@1.seqbase(" @3 ");\n");
@= bunins
    if (BUNins(ctx->@1, @2, @3, FALSE) == NULL) return "xquery_method: allocation error while inserting in @1";
    if (debug) m += snprintf(mil+m, XQUERY_BUFSIZE-l, "@1.append(" @5 @6 ");\n", @4 @3);
@= bunappend
    if (BUNappend(ctx->@1, @2, FALSE) == NULL) return "xquery_method: allocation error while inserting in @1";
    if (debug) m += snprintf(mil+m, XQUERY_BUFSIZE-l, "@1.append(" @4 @5 ");\n", @3 @2);
@c
/*
 * call a function ns:method(). try to use the function cache (ie re-use a cached MIL tree).
 * otherwise generate MIL yourself, interpret it (and cache it). Returns error string (NULL if ok).
 */
static char xquery_function_error[80] = "xquery_method: error during execution.\n";
static char* 
xquery_function_call(xquery_client *ctx, 
                     int msec, 
                     char *mode, 
                     char *ns, 
                     char *method, 
                     int argc, 
                     int itercnt, 
                     int** argcnt, 
                     char** argtpe, 
                     char** argval, 
                     BAT *shredBAT) 
{
    xquery_prepared_function *prepfun = ctx->prepared_functions;
    xquery_function *fun;
    int i, j, k, l, m=0, tpe[MAXPARAMS], mincnt[MAXPARAMS], maxcnt[MAXPARAMS];
    int debug = (strstr(mode,"debug") != NULL);
    char mil[XQUERY_BUFSIZE], *src, *cur = mil, *end = mil + XQUERY_BUFSIZE-1;

    /* determine minimum and maximum sequence of the parameters, and the common ancestor type of each sequence  */
    for(j=0; j<argc; j++) {
        mincnt[j] = maxcnt[j] = argcnt[0][j];
        tpe[j] = -1;
    }
    for(l=i=0; i<itercnt; i++) {
        for(j=0; j<argc; j++) {
            if (argcnt[i][j] > maxcnt[j]) maxcnt[j] = argcnt[i][j];
            if (argcnt[i][j] < mincnt[j]) mincnt[j] = argcnt[i][j];
            for(k=0; k<argcnt[i][j]; k++,l++) {
                int t = xquery_typenr(argtpe[l]);
                if (t >= XQUERY_TYPES) 
                    return (char*) -1; /* can't make a quick function resolution if unknown types are involved */
                tpe[j] = xquery_type_common_ancestor(tpe[j],t);
            }
        }
    }

    /* try to resolve the parameters */
    fun = xquery_resolve(ctx, ns, method, argc, mincnt, maxcnt, tpe);
    if (fun == NULL)
        return (char*) -1; /* no such udf. but it may be a built-in, actually */

    /* create a prepared function record for this MIL client */
    while(prepfun && prepfun->def != fun) prepfun = prepfun->next;
    if (prepfun == NULL) {
        prepfun = (xquery_prepared_function*) GDKmalloc(sizeof(xquery_prepared_function));
        if (prepfun == NULL)
            return "xquery_function_call: allocation failed.\n";
        prepfun->def = fun;
        prepfun->lt = NULL;
        prepfun->next = ctx->prepared_functions;
        ctx->prepared_functions = prepfun;
    }
        
    /* generate small MIL query that calls the function PROC */
    if (fun->mil == NULL) {
        MT_set_lock(pf_cache_lock, "xquery_function_call");
        if (fun->mil == NULL) {
            /* create working set */
            int ret;
  
            src = (char*) PFstartMIL();
            while(*src && cur < end) *cur++ = *src++;

            if (shredBAT) {
                /* add shredded RPC request message to the working set */
                src = (char*) PFdocbatMIL();
                while(*src && cur < end) *cur++ = *src++;
            }

            /* call UDF */
            ret = snprintf(cur, XQUERY_BUFSIZE-(cur-mil), 
                           PFudfMIL(), 
                           fun->proc, 0, 0, 0,0, 0, 0, 0, 0, fun->sig->name, fun->sig->name, 0, 0, 0, 0);
            if (ret > 0) cur += ret;

            /* destroy working set */
            ret = snprintf(cur, XQUERY_BUFSIZE-(cur-mil), PFstopMIL());
            if (ret > 0) cur += ret;

            /* done! execute the script */
            if (cur >= end) {
                return "xquery_function_call: generated MIL query exceeds buffer size.\n";
            }
            *cur = 0;
            fun->mil = GDKstrdup(mil);
        }
        MT_unset_lock(pf_cache_lock, "xquery_function_call");
    }

    /* if no MIL tree is available, create it now */
    if (prepfun->lt == NULL) {
        prepfun->lt = xquery_mil2tree(ctx, fun->mil);
        if (prepfun->lt == NULL) {
            GDKfree(prepfun);
            return "xquery_function_call: error during parsing .\n";
        }
    }

    /* put the actual parameters into the fun_* bats (and *_values containers) */
    @:seqbase(fun_vid000, oid_nil, "oid(nil)")@
    @:seqbase(fun_iter000, oid_nil, "oid(nil)")@
    @:seqbase(fun_kind000, oid_nil, "oid(nil)")@
    @:seqbase(fun_item000, oid_nil, "oid(nil)")@
    @:seqbase(loop000, oid_nil, "oid(nil)")@

    for(l=j=0; j<itercnt; j++) {
        for(i=0; i<argc; i++) {
            oid item, vid = i + fun->vid, iter = j+1;
            if (i == 0 && j > 0) {
                @:bunappend(loop000, &iter, (size_t) *(oid*), SZFMT, "@0")@
            }
            for(k=0; k<argcnt[j][i]; k++,l++) {
                int t = xquery_typenr(argtpe[l]);
                char c;

                /* 'hack': perform simple atomic casts using Monet's ATOMfromstr */
                if (fun->sig->tpe[i] < XQUERY_ABSTRACT)
                    t = fun->sig->tpe[i]; /* just parse the value string as if it was from the desired type */ 
                /* it is doubtful how well pathfinder supports other
                 * casts and what we should do here in those cases.
                 */
                c = xquery_types[t].name[3];

                if (ATOMfromstr(xquery_types[t].monet_tpe, &ctx->val, &ctx->vallen, argval[l]) <= 0)
                    return "xquery_function_call: illegal parameter value.\n";

                @:bunappend(fun_vid000, &vid, (size_t) *(oid*), SZFMT, "@0")@
                @:bunappend(fun_iter000, &iter, (size_t) *(oid*), SZFMT, "@0")@
                @:bunappend(fun_kind000, &xquery_types[t].kind, *(int*), "%d")@
                if (c == 'i') { /* xs:integer */
                    @:bunappend(int_values, ctx->val, *(lng*), LLFMT, "LL")@
                    item = *(oid*) BUNhead(ctx->int_values, BUNfnd(BATmirror(ctx->int_values), ctx->val));
                    @:bunappend(fun_item000, &item, (size_t) *(oid*), SZFMT, "@0")@
                } else if (c == 'd') { /* xs:double or xs:decimal */
                    @:bunappend(dbl_values, ctx->val, *(dbl*), "%g")@
                    item = *(oid*) BUNhead(ctx->dbl_values, BUNfnd(BATmirror(ctx->dbl_values), ctx->val));
                    @:bunappend(fun_item000, &item , (size_t) *(oid*), SZFMT, "@0")@
                } else if (c == 's') { /* xs:string */
                    @:bunappend(str_values, ctx->val, (str), "\"%s\"")@
                    item = *(oid*) BUNhead(ctx->str_values, BUNfnd(BATmirror(ctx->str_values), ctx->val));
                    @:bunappend(fun_item000, &item, (size_t) *(oid*), SZFMT, "@0")@
                } else if (shredBAT == NULL) { 
                    return "xquery_function_call: node parameter without shredBAT.\n";
                } else {
                    @:bunappend(fun_item000, ctx->val, (size_t) *(oid*), SZFMT, "@0")@
                }
            }
        }
    }
    @:seqbase(loop000, 0, "0@0")@
    @:seqbase(fun_vid000, 0, "0@0")@
    @:seqbase(fun_iter000, 0, "0@0")@
    @:seqbase(fun_kind000, 0, "0@0")@
    @:seqbase(fun_item000, 0, "0@0")@

    /* for debugging purposes, we simulate a full MIL on the log; even if parts are cached */
    if (debug) { 
        /* MIL corresponding to BUNins calls we made from C */
        stream_write(ctx->fderr, mil, strlen(mil), 1);
        /* MIL corresponding to UDF call sequence (even if we already have it cached) */
        stream_write(ctx->fderr, fun->mil, strlen(fun->mil), 1);
    }

    /* set the MIL shredBAT and getType variables to the actual values */
    ctx->shredBAT[0] = shredBAT?shredBAT->batCacheid:0;
    if (*(ctx->genType) == NULL || strcmp(*(ctx->genType), mode)) { 
        if (*(ctx->genType)) GDKfree(*(ctx->genType));
        *(ctx->genType) = GDKstrdup(mode);
    }

    *(ctx->time_compile) = GDKms() - msec;
    
    /* Done preparing the query. Time to (re-)execute the MIL tree */
    prepfun->lru = xquery_lru++;
    if (xquery_tree_exec(ctx, prepfun->lt, 1)) {
        if (strstr(mode, "rpcservertime") != NULL) {
           printf("\nServer_Application: %d msec\n", (*ctx->time_compile + *ctx->time_exec) );
           printf("\tTrans: %d msec\n", (*ctx->time_compile) );
           printf("\tShred: %d msec\n", (*ctx->time_shred) );
           printf("\tQuery: %d msec\n", (*ctx->time_exec - *ctx->time_shred) );
           printf("Server_Serialisation + Network_Server_2_Client: %d msec\n", (*ctx->time_print) );
        }

        size_t dummy;
        if (fun->size == 0)
            fun->size = Myysize(prepfun->lt, &dummy);

        /* keep the prepared function cache within a certain size */
        ctx->cachesize += fun->size;
        while (ctx->cachesize > xquery_client_bytes) {
             xquery_prepared_function *kill=NULL,*cur;
             unsigned int lru = xquery_lru;
             for(cur=ctx->prepared_functions; cur; cur=cur->next)
                 if (cur->lt && cur->lru < lru) { kill = cur; lru = cur->lru; }
             if (kill) {
                 Myyfree(kill->lt);
                 kill->lt = NULL;
                 ctx->cachesize -= kill->def->size; 
             }
        }

        return NULL;
    }
    return xquery_function_error;
}


/*
 * =================== module admin ================================
 *
 * void
 * xquery_module_free(xquery_module *mod)
 * - free module structure 
 *
 * xquery_module* 
 * xquery_module_compile(xquery_client *ctx, char* mode, char *url)
 * - get an xquery module, compile it and cache it (return NULL on error)
 *
 * char*
 * xquery_module_load(xquery_client *ctx, char* mode, char *ns, char *url)
 * - check whether we already loaded the module, or if we already 
 *   have it cached. If not, fetch&compile. Returns error string or NULL if ok.
 */

/* 
 * free module structure 
 */
static void 
xquery_module_free(xquery_module *mod) 
{
    xquery_function *fun = mod->functions;
    while(fun) {
        xquery_function *del = fun;
        fun = fun->next;
        if (del->mil) GDKfree(del->mil);
        GDKfree(del);
    }
    if (mod->epilogue) free(mod->epilogue);
    if (mod->prologue) free(mod->prologue);
    GDKfree(mod);
}

/*
 * get an xquery module, compile it and cache it (return NULL on error)
 */
xquery_module*
xquery_module_compile(xquery_client *ctx, 
                      char* mode, 
                      char *url) 
{
    xquery_module *mod = NULL;
    BAT *b = ctx->proc_vid;
    int xx = BUNsize(b);
    int cnt = BUNindex(b, BUNlast(b));
    int ret, url_len = strlen(url)+1;
    BUN p, q;

    mod = GDKmalloc(sizeof(xquery_module)+url_len+1024);
    if (mod == NULL) return NULL;
    memset(mod, 0, sizeof(xquery_module)+url_len+1024);
    strcpy(mod->url, url);
    mod->nsurl = mod->url + url_len;

    ret = xquery_compile_exec(ctx, mode, url, 1, &mod->prologue, NULL, &mod->epilogue, mod->nsurl);
    if (!ret) {
        xquery_module_free(mod);
        return NULL;
    } 
    if (ret == 2) mod->nsurl = NULL; /* for MIL modules (ret == 2), mod->nsurl == NULL (we don't know it :-( )*/

    for(p = BUNptr(b,cnt), q = BUNlast(b); p < q; p += xx) {
        char *proc = (char*) BUNhead(b,p);
        xquery_function *fun = (xquery_function*) GDKmalloc(sizeof(xquery_function)+strlen(proc));
        if (fun == NULL) {
            xquery_module_free(mod);
            return NULL;
        }
        strcpy(fun->proc, proc);
        fun->vid = *(lng*) BUNtail(b,p);
        fun->sig = xquery_sig_init(fun->proc);
        fun->mil = NULL;
        fun->size = 0;
        if (fun->sig == NULL) {
            GDKfree(fun);
        } else {
            fun->next = mod->functions;
            mod->functions = fun;
        }
    }
    mod->next = xquery_compiled_modules;
    xquery_compiled_modules = mod;
    return mod;
}

/*
 * check whether we already loaded the module, or if we already have it cached. 
 * If not, fetch&compile. Returns error string or NULL if ok.
 */
static char* 
xquery_module_load(xquery_client *ctx, 
                   char* mode, 
                   char *ns, 
                   char *module,
                   char *url) 
{
    xquery_loaded_module *mod, *prev = NULL;
    int nslen = strlen(ns);

    /* check whether it was already loaded in this query */
    for(mod = ctx->loaded_modules; mod; prev = mod, mod = mod->next) {
        if (strcmp(mod->def->url, url) == 0) {
            if (mod->nslen == 0) {
                if (prev) prev->next = mod->next;
                else ctx->loaded_modules = NULL;
                break; /* put module at front of list */
            }
            if (mod->def->nsurl && module && strcmp(mod->def->nsurl, module)) 
                return "xquery_module_load: import module statement does not match module namespace declaration.\n";
        }
    }
    if (mod == NULL) {
        xquery_module *def;
        mod = (xquery_loaded_module*) GDKmalloc(sizeof(xquery_loaded_module));
        if (mod == NULL) 
            return "xquery_module_load: could not allocate.\n";
        mod->def = NULL;

        MT_set_lock(pf_module_lock, "xquery_module_load");
        for(def = xquery_compiled_modules; def; def = def->next) 
            if (strcmp(def->url, url) == 0) break;

        if (def == NULL){
            mod->def = xquery_module_compile(ctx, mode, url);
        }
        MT_unset_lock(pf_module_lock, "xquery_module_load");

        /* if a compiled module was found, we still need to execute it */
        if (def && xquery_mil_exec(ctx, def->prologue, strstr(mode, "debug") != NULL))
            mod->def = def; /* TODO: find a way to share PROC defs between MIL sessions */

        if (mod->def == NULL) {
            GDKfree(mod);
            return "xquery_module_load: could not load module.\n";
        }
        ctx->var_usage_size = BATcount(ctx->var_usage);
        ctx->proc_vid_size = BATcount(ctx->proc_vid);
    } else if (strstr(mode,"debug") != NULL) {
        stream_write(ctx->fderr, mod->def->prologue, strlen(mod->def->prologue), 1);
    }
    mod->ns = ns;
    mod->nslen = nslen;
    mod->next = ctx->loaded_modules;
    ctx->loaded_modules = mod;

    if (mod->def->nsurl && module && strcmp(mod->def->nsurl, module)) 
        return "xquery_module_load: import module statement does not match module namespace declaration.\n";
    return NULL;
}

/*
 * wait for all queries to finish; free all clients; clear PF url cache
 * freeing the cached YYTREEs in the xquery clients is done lazily 
 * (postponed to the next initialization of the record)
 */
static void
xquery_client_flushall()
{
    int i, wait = 100;
    while(wait) {
        MT_set_lock(pf_cache_lock, "xquery_client_flushall");
        i = active_clients("xquery");
        if (i == 0) {
            /* ok, no xquery clients are active */
            xquery_module *mod = xquery_compiled_modules;
            while(mod) {
                xquery_module *del = mod;
                mod = mod->next;
                xquery_module_free(del);
            }
            xquery_compiled_modules = NULL;
            PFurlcache_flush();
            wait = 0;
        }
        MT_unset_lock(pf_cache_lock, "xquery_client_flushall");
        MT_sleep_ms(wait);
    }
}

/*
 * flush the cache. 
 */
int
CMDxquery_start_query_cache(lng *maxsize)
{
    xquery_client_flushall();
    if (*maxsize > 0) xquery_client_bytes = *maxsize;
    xquery_cacheid++; /* old clients need to clean up their resources */
    return GDK_SUCCEED;
}


/*
 * =================== client session management ================================
 *
 * xquery_client *
 * xquery_client_alloc(mapi_client *fc);
 * - allocate a new xquery client, returns error message (NULL on success)
 *
 * char*
 * xquery_client_init(mapi_client *fc);
 * - initialize a new xquery cache context, returns error string (NULL if ok)
 *
 * void
 * xquery_client_free(mapi_client *fc);
 * - free a xquery cache context (terminate)
 *
 * void
 * xquery_client_end(xquery_client *ctx, char *err);
 * - end of xquery execution (struct stays alive for reuse). 
 */

@= find_var
    v = VARfind(&ctx->stk, "@1");
    if (v == NULL) 
        return "xquery_client_alloc_: failed to lookup @1 variable.\n"; 
    if (v->binding.vtype != TYPE_@2) 
        return "xquery_client_alloc_: @1 variable has wrong type != int.\n"; 
    ctx->@1 = &v->binding.val.@3; 

@= find_bat
{   Variable v = VARfind(&ctx->stk, "@1");
    ctx->@1 =  NULL;
    if (v && v->binding.vtype == TYPE_bat)
        ctx->@1 = BATdescriptor(v->binding.val.bval);
    if (ctx->@1 == NULL) return "xquery_client_init: failed to lookup @1 variable.\n"; }
@c

static xquery_client*
xquery_client_new(Cntxt stk) {
    xquery_client *ctx = (xquery_client*)GDKmalloc(sizeof(xquery_client));

    memset(ctx, 0, sizeof(xquery_client));
    ctx->stk = stk; 
    ctx->fderr = GDKerr;
    return ctx; 
}

static char *
xquery_client_alloc_(xquery_client *ctx)
{
    Variable v;

    if (!xquery_mil_exec(ctx, (char*) PFinitMIL(), 0))
        return "xquery_client_alloc: failed to execute init script.\n"; 

    @:find_var(shredBAT,int,ival)@
    @:find_var(genType,str,sval)@
    @:find_var(time_compile,int,ival)@
    @:find_var(time_exec,int,ival)@
    @:find_var(time_print,int,ival)@
    @:find_var(time_shred,int,ival)@

    @:find_bat(proc_vid)@
    @:find_bat(var_usage)@
    @:find_bat(dbl_values)@
    @:find_bat(int_values)@
    @:find_bat(str_values)@
    @:find_bat(fun_vid000)@
    @:find_bat(fun_iter000)@
    @:find_bat(fun_item000)@
    @:find_bat(fun_kind000)@
    @:find_bat(loop000)@

    ctx->var_usage_size = BATcount(ctx->var_usage);
    ctx->proc_vid_size = BATcount(ctx->proc_vid);
    ctx->cachesize = 0;
    ctx->loaded_modules = NULL;
    ctx->prepared_functions = NULL;
    ctx->buflen = XQUERY_BUFSIZE;
    ctx->cacheid = xquery_cacheid;
    ctx->buf = GDKmalloc(ctx->buflen+1);
    ctx->val = GDKmalloc(ctx->vallen = 128);
    if (ctx->val == NULL || ctx->buf == NULL) {
            if (ctx->buf) GDKfree(ctx->buf);
            if (ctx->val) GDKfree(ctx->val);
            ctx->buflen = 0;
            return "xquery_client_alloc: failed to allocate.\n";
    }
    ctx->repeat_stk = CNTXTnew(ctx->stk);
    ctx->initialized = 0;
    CNTXTuse(ctx->repeat_stk);
    monet_cntxt[ctx->repeat_stk].reuse = TRUE;

    return NULL;
}

/* 
 * allocate a new xquery client, returns client cntxt (0 on error)
 */
static char* 
xquery_client_alloc(mapi_client *fc)
{
    xquery_client *ctx = xquery_client_new(fc->stk);

    fc->fc = ctx;
    if (!ctx) {
        return "!ERROR: no space to allocate xquery client\n";
    } else {
        return xquery_client_alloc_(ctx);
    }
}

/*
 * initialize a new xquery cache context, returns error string (NULL if ok)
 */ 
static char *
xquery_client_init_(xquery_client *ctx )
{
    if (!ctx->initialized) {
        ctx->initialized = 1;
        if (!xquery_mil_exec(ctx, (char*) PFvarMIL(), 0))
            return "xquery_client_init: failed to execute variable declarations.\n"; 
    }
    return NULL;
}

/*
 * free all cached subtrees and all proc definitions for all xquery modules
 * (the epilogue contains UNDEF procs) 
 */ 
void
xquery_client_free_cached_modules(xquery_client *ctx)
{
    xquery_prepared_function *fun= ctx->prepared_functions; 
    xquery_loaded_module *mod= ctx->loaded_modules; 

    while(fun) {
        xquery_prepared_function *del = fun;
        fun = fun->next;
        if (del->lt) Myyfree(del->lt);
        GDKfree(del);
    }
    while(mod) {
        xquery_loaded_module *del = mod;
        mod = mod->next;
        /* free all modules */
        if (del->def->epilogue && !xquery_mil_exec(ctx, del->def->epilogue, 0))
            fprintf(stderr, "xquery_client_free: client %d error dropping %s\n", ctx->stk, del->def->url);
        GDKfree(mod);
    }
    ctx->loaded_modules = NULL;
    ctx->prepared_functions = NULL;

    /* free the query buffer */
    if (ctx->buf) GDKfree(ctx->buf);
    ctx->buf = NULL;
    ctx->buflen = 0;
}

static char* 
xquery_client_init(mapi_client *fc) 
{ 
    xquery_client *ctx = fc->fc;
    char* err = xquery_client_init_(ctx);

    ctx->fderr = fc->c->fdout;

    if (!err && ctx->cacheid != xquery_cacheid) {
        xquery_client_free_cached_modules(ctx);

        ctx->buflen = XQUERY_BUFSIZE;
        ctx->cacheid = xquery_cacheid;
        ctx->buf = GDKmalloc(ctx->buflen+1);
        if (ctx->buf == NULL) {
            if (ctx->buf) GDKfree(ctx->buf);
            ctx->buflen = 0;
            err = "xquery_client_init: failed to allocate.\n";
        }
    }
    if (err)
        fprintf(stderr, "xquery_client_init: client %d %s\n", fc->stk, err);
    return err;
}


@= unfix
    if (ctx->@1) BBPunfix(ctx->@1->batCacheid);
    ctx->@1 = NULL;
@c
/* 
 * free a xquery cache context (terminate).
 */
static void
xquery_client_free_(xquery_client *ctx)
{
    xquery_client_free_cached_modules(ctx);

    ctx->shredBAT = NULL;

    /* free the value buffer */
    if (ctx->val) GDKfree(ctx->val);
    ctx->val = NULL;
    ctx->vallen = 0;
    
    /* unfix the BAT handles */
    @:unfix(int_values)@
    @:unfix(dbl_values)@
    @:unfix(str_values)@
    @:unfix(fun_vid000)@
    @:unfix(fun_iter000)@
    @:unfix(fun_item000)@
    @:unfix(fun_kind000)@
    @:unfix(loop000)@

    /* close the MIL client session */
    monet_cntxt[ctx->repeat_stk].reuse = FALSE;
    CNTXTclear(ctx->repeat_stk);
    CNTXTfree1(ctx->repeat_stk);
    CNTXTdelete(ctx->repeat_stk);
}

static void 
xquery_client_free(mapi_client *fc) 
{
    xquery_client_free_(fc->fc);
}

/* 
 * end of xquery execution (struct stays alive for reuse).
 */
static void 
xquery_client_end(xquery_client *ctx, char *err) 
{
    oid zero = 0, one = 1;

    /* undo any inserts by the query into the var_usage bats */
    size_t delta_var_usage = BATcount(ctx->var_usage) - ctx->var_usage_size;
    size_t delta_proc_vid = BATcount(ctx->proc_vid) - ctx->proc_vid_size;
    BATsetcount(ctx->var_usage, ctx->var_usage_size);
    ctx->var_usage->batBuns->free -= delta_var_usage*BUNsize(ctx->var_usage);
    BATsetcount(ctx->proc_vid, ctx->proc_vid_size);
    ctx->proc_vid->batBuns->free -= delta_proc_vid*BUNsize(ctx->proc_vid);

    /* empty all bats (static variables) */
    BATclear(ctx->loop000);
    BUNins(ctx->loop000, &zero, &one, FALSE);

    BATclear(ctx->fun_vid000);
    BATclear(ctx->fun_iter000);
    BATclear(ctx->fun_kind000);
    BATclear(ctx->fun_item000);
    BATclear(ctx->dbl_values);
    BATclear(ctx->int_values);
    BATclear(ctx->str_values);
    BUNappend(ctx->str_values, (ptr)str_nil, FALSE);
    *ctx->shredBAT = int_nil; 

    MT_set_lock(pf_cache_lock, "xquery_client_end");
    /* only deactivate the loaded modules */
    xquery_loaded_module *mod= ctx->loaded_modules; 
    while(mod) {
            mod->nslen = 0;
            mod->ns = NULL; 
            mod = mod->next;
    }
    MT_unset_lock(pf_cache_lock, "xquery_client_end");

    if (err) 
        fprintf(stderr, "xquery_server: client %d %s\n", ctx->stk, err);
}


/*
 * ========== parse xquery to identify 'import module's and function calls ==========
 *
 * char*
 * xquery_parse_ident(char* p) 
 * - parse an identifier; accept any UTF-8 characters in it (is that correct?)
 *
 * char*
 * xquery_parse_comment(char* p)
 * - parse an xquery (: .. :)  comment. Note it may be nested.
 *
 * char*
 * xquery_parse_space(char* p)
 * - parse xquery space, which may include comments 
 *
 * char*
 * xquery_parse_string(char* p, char *buf, int len)
 * - parse an XML datamodel string. Deliver an unescaped version as a result 
 *
 * char*
 * xquery_parse_numeric(char* p, char **tpe)
 * - parse an XML datamodel numeric, and determine its minimal type (xs:integer, xs:decimal or xs:double) 
 *
 * all above functions return the new pointer in the xquery after parsing.
 *
 * char*
 * xquery_prepare(xquery_client *ctx, int msec, char* mode, char* xquery)
 * - parse xquery; chop off module imports, and recognize single method calls. These are re-executed
 *   from a cached MIL tree. Otherwise use pathfinder to compile. Returns error string (NULL if ok).
 */

/* 
 * parse an identifier; accept any UTF-8 characters in it (is that correct?)
 */
static char* 
xquery_parse_ident(char* p) 
{
    if ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || *(unsigned char*) p >= 128) {
        p++;
        while((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*(unsigned char*) p >= 128) ||
              (*p == '_') || (*p == '.') || (*p == '-') || (*p >= '0' && *p <= '9')) p++;
    }
    return p;
}

/* 
 * parse an xquery (: .. :)  comment. Note it may be nested.
 */
static char* 
xquery_parse_comment(char* p) 
{
    int nesting;
    for(nesting=1; *p; p++) {
        if (p[0] == ':' && p[1] == ')' && --nesting == 0) return p+2;
        if (p[0] == '(' && *(++p) == ':') nesting++;
    }
    return p;
}

/* 
 * parse xquery space, which may include comments 
 */
#define ISSPACE(c) ((c) == ' ' || (c) == '\t' || (c) == 10 || (c) == 13) 
static char* 
xquery_parse_space(char* p) 
{
    while(*p) {
        while(ISSPACE(*p)) p++;
        if (p[0] != '(' || p[1] != ':') break; 
        p = xquery_parse_comment(p+2);
    }
    return p;
}

/* 
 * parse an XML datamodel string. Deliver an unescaped version as a result 
 */
static char* 
xquery_parse_string(char* p, 
                    char *buf, 
                    int len) 
{
    char *q = buf, *r = buf+len-1;
    int sep1 = *p++;
    int sep2 = (sep1=='"')?'\'':'"';
    int escape = 0;
    while(*p) {
        if (escape) {
            if (p[0] == sep2) escape = 0;
            if (q < r) *q++ = *p; p++;
        } else {
            if (p[0] == sep1) {
                p++; break;
            } else if (p[0] == sep2) {
                if (p[1] == sep1 && p[2] == sep1 && p[3] == sep2) {
                    if (q < r) *q++ = sep1; p += 4;
                } else {
                    if (q < r) *q++ = *p; p++;
                    escape = 1;
                }
            } else if (p[0] == '&') {
                if (p[1] == '#' && p[2] == 'x') {
                    unsigned long v = 0; 
                    for(p+=3; *p; p++) {
                        if (*p >= '0' && *p <= '9') {
                            v = (v << 4) + (*p - '0');
                        } else if (*p >= 'a' && *p <= 'f') {
                            v = (v << 4) + (*p - 'a');
                        } else if (*p >= 'A' && *p <= 'F') {
                            v = (v << 4) + (*p - 'A');
                        } else {
                            break;
                        }
                    }
                    if (q < r) *q++ = (char) v;
                } else if (p[1] == '#') {
                    unsigned long v = 0; 
                    for(p+=2; *p; p++) {
                        if (*p >= '0' && *p <= '9') {
                            v = (v * 10) + (*p - '0');
                        } else {
                            break;
                        }
                    }
                    if (q < r) *q++ = (char) v;
                } else if (p[1] == 'l' && p[2] == 't' && p[3] == ';') {
                    if (q < r) *q++ = '<'; p += 4;
                } else if (p[1] == 'g' && p[2] == 't' && p[3] == ';') {
                    if (q < r) *q++ = '<'; p += 4;
                } else if (p[1] == 'a' && p[2] == 'm' && p[3] == 'p' && p[4] == ';') {
                    if (q < r) *q++ = '&'; p += 5;
                } else if (p[1] == 'q' && p[2] == 'u' && p[3] == 'o' && p[4] == 't' && p[5] == ';') {
                    if (q < r) *q++ = '"'; p += 6;
                } else if (p[1] == 'a' && p[2] == 'p' && p[3] == 'o' && p[4] == 's' && p[5] == ';') {
                    if (q < r) *q++ = '\''; p += 6;
                }
            } else {
                if (q < r) *q++ = *p; p++;
            }
        }
    }
    *q = 0;
    return p;
}

/* 
 * parse an XML datamodel numeric, and determine its minimal type (xs:integer, xs:decimal or xs:double) 
 */
static char* 
xquery_parse_numeric(char* p, 
                     char **tpe) 
{
    *tpe = "xs:integer";
    if (p[0] == '-' || p[0] == '+') p++;
    while(p[0] >= '0' && p[0] <= '9') p++;
    if (p[0] == '.' && (p[1] >= '0' && p[1] <= '9')) {
        p++;
        while(p[0] >= '0' && p[0] <= '9') p++;
        *tpe = "xs:decimal";
    }
    if (p[0] == 'e' || p[0] == 'E') {
        char *q = p+1;
        if (q[0] == '-' || q[0] == '+') q++;
        if (q[0] >= '0' && q[0] <= '9') {
           while(q[0] >= '0' && q[0] <= '9') q++;
           p = q;
           *tpe = "xs:double";
        }
    }
    return p;
}

/* 
 * parse xquery; chop off module imports, and recognize single method calls. These are re-executed
 * from a cached MIL tree. Otherwise use pathfinder to compile. Returns error string (NULL if ok).
 */
static char*
xquery_prepare(xquery_client *ctx, 
               int msec, 
               char* mode, 
               char* query) 
{
    int nsbuf = 0, loaded_modules = 0, len;
    char *ns = (char*)&nsbuf, *nsend = ns, *locend, *loc = NULL, *p = query;
    char val[256], url1[256], url2[256];
    char *err = NULL;

    if (strstr(mode,"debug") != NULL) {
        /* for debugging purposes, we simulate a full MIL on the log; even if parts are cached */
        char *prologue = (char*) PFinitMIL();
        stream_write(ctx->fderr, prologue, strlen(prologue), 1);
        prologue = (char*) PFvarMIL();
        stream_write(ctx->fderr, prologue, strlen(prologue), 1);
    }
    while(*p && err == NULL) {
        p = xquery_parse_space(p);
        if (strncmp(p, "import", 6) || !ISSPACE(p[6])) {
            break;
        } else {
            /* e.g. import module namespace xmark = "/cygwin/tmp/" at "/cygwin/tmp/mod1.xq";
             * or:  import rpc-module namespace xmark = "/cygwin/tmp/" at "/cygwin/tmp/mod1.xq"; */ 
            p = xquery_parse_space(p+6);
            if ( (strncmp(p, "module", 6) == 0 && ISSPACE(p[6])) ||
                 (strncmp(p, "rpc-module", 10) == 0 && ISSPACE(p[10])) ){
                len = p[0] == 'm' ? 6 : 10;
                p = xquery_parse_space(p+len);
                if (strncmp(p, "namespace", 9) == 0 && ISSPACE(p[9])) {
                    ns = xquery_parse_space(p+9);
                    nsend = xquery_parse_ident(ns);
                    p = xquery_parse_space(nsend);
                    if (*p == '=') {
                        p = xquery_parse_space(p+1);
                    } else {
                        return "xquery_prepare: expecting '=' after namespace declaration";
                    }
                }
                p = xquery_parse_string(p, url1, 256);
                p = xquery_parse_space(p);
                if (*p == 'a' && *(++p) == 't' && ISSPACE(p[1])) do {
                    char bak = *nsend;
                    loc = xquery_parse_space(p+1);
                    locend = xquery_parse_string(loc, url2, 256);
                    p = xquery_parse_space(locend);

                    /* cut off module import from the query, and load it here (to have it cached later) */
                    *nsend = 0;

                    err = xquery_module_load(ctx, mode, ns, url1, url2);
                    if (err) return err;
                    *nsend = bak; 
                } while (*p == ',');
            }
            if (*p != ';') {
                return "xquery_prepare: missing ';' after module import.\n";
            } else {
                loaded_modules++;
                p++;
            }
        }
    }

    if (loaded_modules == 0) {
        err = (char*) -1; /* no module loaded: query not recognized as a function call */
    } else {
        /* detect queries that consist of a single method call only */
        nsend = ns = (char*) &nsbuf; 
        loc = p; 
        locend = xquery_parse_ident(loc);
        p = xquery_parse_space(locend);
        if (*p == ':') {
            ns = loc; nsend = locend; 
            loc = ++p; 
            locend = xquery_parse_ident(p);
            p = xquery_parse_space(locend);
        }
        if (*p != '(' || ((locend-loc) == 2 && loc[0] == 'i' && loc[1] == 'f')) {
            err = (char*) -1; /* query not recognized as a function call */
        } else {
            int cnt[MAXPARAMS];
            char* tpe[MAXPARAMS];
            char* param[MAXPARAMS];
            int argc = 0;
    
            /* e.g. ns:function(1,2,3) */
            p = xquery_parse_space(p+1);
            if (*p == ')') {
               p++;
            } else do {
                param[argc] = p;
                tpe[argc] = "xs:string";
                cnt[argc] = 1;
                if (*param[argc] == '"' || *param[argc] == '\'') {
                    p = xquery_parse_string(param[argc], val, 256);
                    if (p <= param[argc]) {
                        err = "xquery_prepare: could not parse string literal.\n";
                        break;
                    }
                } else if (*p == '-' || *p == '+' || *p == '.' || (*p >= '0' && *p <= '9')) {
                    p = xquery_parse_numeric(param[argc], tpe+argc);
                    if (p <= param[argc]) {
                        err = "xquery_prepare: could not parse numeric literal.\n";
                        break;
                    }
                } else {
                    /* complex parameter */
                    err = (char*) -1; /* query not recognized as a simple function call */
                    break;
                }
                if (++argc >= MAXPARAMS) {
                    err = "xquery_prepare: too many parameters.\n";
                    break;
                }
                p = xquery_parse_space(p);
                if (*p == ')') {
                    p++; 
                    break;
                } else if (*p != ',') {
                    err = "xquery_prepare: expecting a ',' between function parameters.\n";
                    break;
                }
                p = xquery_parse_space(p+1);
            } while(*p);
    
            if (err == NULL) {    
                p = xquery_parse_space(p);
                if (*p == '/') {
                    err = (char*) -1;
                } else if (*p) {
                    err = "xquery_prepare: unexpected characters after ';'.\n";
                } else {
                    /* all set: make the call */
                    int* cnt_ptr = cnt;    
                    char nsbak = *nsend, locbak = *locend;
                    *nsend = 0; *locend = 0;
                    err = xquery_function_call(ctx, msec, mode, ns, loc, argc, 1, &cnt_ptr, tpe, param, NULL);
                    *nsend = nsbak; *locend = locbak;
                }
            }
        }
    }
    if (err == xquery_function_error) {
        err = (char*) -1; /* execution error in xquery_function_call */
    } else if (err == (char*) -1) {
        char *sec1 = NULL;
        char *sec2 = NULL;
        char *sec3 = NULL;
        /* compile and execute the query (minus module imports) */
        if (xquery_compile_exec(ctx, mode, query, 0, &sec1, &sec2, &sec3, NULL)) 
                err = NULL; /* in case of execution err, it stays -1 */
        if (sec1) free(sec1);
        if (sec2) free(sec2);
        if (sec3) free(sec3);
    } 
    return err;
}

/*
 * =================== exported functions ================================
 *
 * see MIL module definition (top of file)
 */

@= builtin_operand
{
    int _k = interpret(stk, arg(lt, @1), res);
    if (_k < 0) {
        return _k;
    }
    @3 = VALconvert(@2, res);
    if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
        return handle_paramerror(res,@1,res->vtype,@2);
    }
}
@c

static void
xquery_client_engine(mapi_client *fc )
{
    size_t curlen;
    xquery_client *ctx = fc->fc;
    stream *in = fc->c->fdin, *out = fc->c->fdout;
    char *xquery,  buf[100], *p=buf, *err = (char*) -1;
    int msec;

    while(1) {
        /* use the MAPI protocol to read as much xquery buffer as possible */
        if (!fc->c->blocked && 
                stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) < 0) {
            xquery_client_end(ctx, "could not write prompt"); 
            return;
        }
        if (stream_flush(out)) {
            xquery_client_end(ctx, "could not flush prompt"); 
            return;
        }

        for (p = ctx->buf, curlen = 0; p; ) {
            ssize_t n = stream_read(in, p + curlen, 1, ctx->buflen - curlen);
            if (n < 0) {
                xquery_client_end(ctx, NULL); 
                return;
            }
            if (n == 0)
                break;

            curlen += n;
            if (curlen == ctx->buflen) {
                p = GDKrealloc(ctx->buf, ctx->buflen + 1025);
                if (p) {
                    ctx->buflen += 1024;
                    ctx->buf = p;
                }
            }
        }
        if (curlen == 0)
                break;
        msec = GDKms();
    
        /* execute query */
        if (p) {
            p[curlen] = 0;        /* terminate (we know there is space) */
    
            /* first line of the query is the mode */ 
            for (xquery = p; *xquery; xquery++) {
                if (*xquery == '\n') {
                    *xquery++ = 0;
                    break;
                }
            }
            err = xquery_prepare(ctx, msec, p, xquery);
            if (err && err != (char*) -1) {
                /* report errors back to client */
                stream_write(ctx->fderr, err, strlen(err), 1);
            }
        }
        if (strstr(p, "debug")) {
            /* memory debugging */
            xquery_prepared_function *fun = ctx->prepared_functions;
            BAT *b = NULL;
            view_client_size(&b, &fc->stk);
            if (b) {
               while(fun) {
                   BUNins(b, fun->def->proc, &fun->def->size, FALSE);
                   fun = fun->next;
                } 
                BATprintf(GDKstdout, b);
                BBPreclaim(b);
            } 
        }
        /* second and on queries also need a cleared context */
        xquery_client_end(ctx, NULL); 
    }
    xquery_client_end(ctx, NULL); 
}

int
xquery_frontend( ptr *F)
{
	char *m_clients = GDKgetenv("mapi_clients"); 
	int nr = (m_clients)?strtol(m_clients, NULL, 10):1;
	mapi_frontend *f = (mapi_frontend*)GDKmalloc(sizeof(mapi_frontend));
	*F = f;
	f->name = GDKstrdup("xquery");
	f->cache_limit = nr;
	f->f_alloc = xquery_client_alloc;
	f->f_init  = xquery_client_init;
	f->f_free  = xquery_client_free;
	f->f_engine  = xquery_client_engine; /* read/parse/execute loop */
	return GDK_SUCCEED;
}


/*
 * execute xquery and return the result in a string.
 */
int
CMDxquery(Cntxt stk, 
          YYSTREE lt, 
          ValPtr res)
{
    int msec = GDKms();
    char *mode = "xml", *xquery = NULL, *err = NULL;
    bit no=0, *is_url=&no;
    Client c = NULL;
    xquery_client *ctx;

    /* this is a BUILTIN because we must obtain the client context (and
     * thus the streams) */
    if (lt->cnt > 4)
        return handle_argerror(res, lt->cnt, 3);
    if (lt->cnt == 1) {
        @:builtin_operand(0,TYPE_str,xquery)@
    } else {
        @:builtin_operand(0,TYPE_str,mode)@
        @:builtin_operand(1,TYPE_str,xquery)@
    }
    if (lt->cnt == 3) {
        @:builtin_operand(2,TYPE_bit,is_url)@
    }
    CNTXTclient(stk, &c);
    ctx = xquery_client_new(c->stk);
    ctx->fderr = GDKerr;
    MT_set_lock(pf_cache_lock, "CMDxquery");
    err = xquery_client_alloc_(ctx);
    if (!err)
        err = xquery_client_init_(ctx);
    MT_unset_lock(pf_cache_lock, "CMDxquery");

    if (err == NULL && *is_url == TRUE) { 
        MT_set_lock(pf_compiler_lock, "CMDxquery");
        PFURLCACHE("CMDxquery", xquery, 1);
        MT_unset_lock(pf_compiler_lock, "CMDxquery");
    }

    if (err == NULL) {
        buffer *b = buffer_create(XQUERY_BUFSIZE);
        if (b) {
            stream *s = buffer_wastream(b, "CMDxquery");
            if (s) {
                /* run the query, but collect all output in a buffer */
                stream *bak = GDKout;
                THRsetdata(0,s);
                err = xquery_prepare(ctx, msec, mode, xquery);
                if (err == NULL || err == (char*) -1) {
                    res->val.sval = GDKmalloc(b->pos+1);
                    if (res->val.sval) {
                        memcpy(res->val.sval, b->buf, b->pos);
                        res->val.sval[b->pos] = 0;
                        res->vtype = TYPE_str;
                    } else {
                        err = "CMDxquery: failed to allocate buffer";
                    }
                }
                THRsetdata(0,bak);
                stream_close(s);
            } else {
                err = "CMDxquery: failed to create stream";
            }
            buffer_destroy(b);
            stream_destroy(s);
        } else {
            err = "CMDxquery: failed to allocate streambuffer";
        }
    }
    MT_set_lock(pf_cache_lock, "CMDxquery");
    xquery_client_free_(ctx);
    MT_unset_lock(pf_cache_lock, "CMDxquery");
    if (err) {
	GDKerror((err==(char*)-1)?res->val.sval:err);
	VALclear(res);
        return GDK_FAIL;
    } 
    /* stream_printf(GDKout,"RES = %s\n",res->val.sval); */
    return GDK_SUCCEED;
}

/*
 * call a method in a temporary xquery client context
 */  
char*
xquery_method(stream *out, 
              int rpctiming,
              char* module, 
              char* uri, 
              char *method, 
              int argc, 
              int itercnt, 
              int** argcnt, 
              str* argtpe, 
              str* argval, 
              BAT* shredBAT)
{
    int msec = GDKms();
    MT_Id XQthread_id = THRgettid();
    Thread XQthread = THRget(XQthread_id);
    char *err = NULL, *ns = "fn", *mode = "xml-noheader-typed-old-root-iter";
    stream *s = NULL;
    mapi_client *mc = MAPIclient(GDKin, out, "xquery" );
    xquery_client *ctx;

    if (mc == NULL) 
        return "xquery_method: out of client slots.\n";

    if (rpctiming){
        mode = "xml-rpcservertime-timing-noheader-typed-old-root-iter";
    }
    
    ctx = mc->fc; 
    ctx->fderr = GDKerr;
    mc->t = XQthread_id;
    mc->thread = XQthread;
    monetSetChannel(XQthread, GDKin, out);
    if (argc > 1000) {
        /* hack: pass argc+1000 and you get debug output */
        s = open_wstream("/tmp/xquery_rpc.mil");
        char *prologue = (char*) PFinitMIL();
        if (s) {
            ctx->fderr = s;
            if (rpctiming){
                mode = "xml-rpcservertime-timing-debug-noheader-typed-old-root-iter";
            } else {
                mode = "xml-debug-noheader-typed-old-root-iter";
            }
        }
        stream_write(ctx->fderr, prologue, strlen(prologue), 1);
        argc = argc % 1000;
    }

    if (err == NULL && module){
        err = xquery_module_load(ctx, mode, ns="xquery_rpc", module, uri); 
    }

    if (err == NULL) { 
        err = xquery_function_call(ctx, msec, mode, ns, method, argc, itercnt, argcnt, argtpe, argval, shredBAT);
        if (err == (char*) -1) err = "xquery_method: function could not be resolved.\n";
    }

    if (s) {
        stream_close(ctx->fderr);
        stream_destroy(ctx->fderr);
    }
    monetSetChannel(XQthread, GDKin, GDKout);

    xquery_client_end(ctx, NULL);
    mc->inuse = 0;
    mc->t = ~(MT_Id)0;
    return err;
}

/*
 * module initialization
 */
extern void xmlInitThreads();
bat *
xquery_prelude()
{
    pf_compiler_lock = MT_create_lock();
    pf_module_lock = MT_create_lock();
    pf_cache_lock = MT_create_lock();

    xmlInitThreads();
   
    xquery_compiled_modules = NULL;
    return NULL;
}

/*
 * module cleanup
 */
void
xquery_epilogue()
{
    xquery_client_flushall();
    MT_destroy_lock(pf_compiler_lock);
    MT_destroy_lock(pf_cache_lock);
}
/* vim:set shiftwidth=4 expandtab: */
