@' pathfinder.mx
@'
@' XQuery runtime environment
@'
@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2006 University of Konstanz.  All Rights Reserved.
@'
@' $Id$
@'

@f pathfinder
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@a Jan Flokstra
@a Jens Teubner
@a Stefan Manegold
@a Peter Boncz 

@t Runtime Support for the Pathfinder XQuery Compiler

@m
.MODULE pathfinder;

.USE streams;

.COMMAND xquery_frontend() : ptr = xquery_frontend;
 "create/return the xquery_frontend callback interface to pass to mapi register. "

.BUILTIN xquery(mode str, xquery str, is_url bit) : str = CMDxquery;
 "xquery execution. parameters: mode, query, is_url (optional)
 usage:  var result := xquery(\"xml\", \"1+1\", false); printf(result);
 or:  printf(xquery(\"xml\", \"1+1\"));"

.COMMAND xquery_start_query_cache(lng maxsize) : void = CMDxquery_start_query_cache; 
 "Cached xquery clients use the query plan cache (also flushes the cache when called). if nonzero, the parameter is a per-connection size limit to the plan cache in bytes"

.PRELUDE = xquery_prelude;
.EPILOGUE = xquery_epilogue;

.END pathfinder;
@mil
module(mapi);       # remote client access
module(monettime); 

PROC pfstart(bit open, lng sz) : void {
        xquery_start_query_cache(sz);
	mapi_register(xquery_frontend());
        if (not(mapi_running())) {
                mapi_listen(
                        int(monet_environment.find("mapi_port")), 
                        str(nil), 
                        5, 
                        open).fork();
        }
}
ADDHELP("pfstart", "boncz", "April 2005",
"PARAMETERS:\n\
bit whether the listener should listen to outside requests \
(default false: only local connections).\n\
sz per-connection size limit to the query plan cache, see also \"xquery_start_query_cache\".\n\
DESCRIPTION:\n\
start the xquery server.",
"pathfinder");

PROC pfstart() : void {
        pfstart(false, 0LL);
}

PROC xquery_server_start(bit global) : void {
        pfstart(false, 0LL);
}

PROC xquery_server_start() : void {
        xquery_server_start(false);
}

#############################################
# User-level document management functions:
#
# - shred_doc
# - delete_doc
# - delete_all_docs
#
# Each imported XML-document is stored as a collection of persistent BATs 
# whose name starts with the name of the BAT and ends with the document ID. 
# The execution of an XQuery is not performed on the persistent BATs, but on 
# the transient 'working set', a global document collection represented
# by the ws-BAT.
#
# Each collection contains the following BATs:
# - pre_size    : BAT[oid,int]  pre-value of node / and its descendant size,
# - pre_level   : BAT[oid,chr]  pre-value of node / and its level,
# - pre_prop    : BAT[oid,oid]  pre-value of node / and property ID,
# - pre_kind    : BAT[oid,chr]  pre-value of node / and node kind,
#
# - qn_ns        : BAT[oid,str]  property ID / and name space (elements and attributes),
# - qn_loc       : BAT[oid,str]  property ID / and local name (elements and attributes),
# - prop_text    : BAT[oid,str]  property ID / and text,
# - prop_com     : BAT[oid,str]  property ID / and comment,
# - prop_ins     : BAT[oid,str]  property ID / and processing instruction,
# - prop_tgt     : BAT[oid,str]  property ID / and processing instruction target,
#
# - attr_own  : BAT[oid,oid]  attribute ID / pre-value of owner
# - attr_qn   : BAT[oid,oid]  attribute ID / and qname/property ID
# - attr_prop : BAT[oid,oid]  attribute ID / value ID
#
# - prop_val  : BAT[oid,str]  value ID / value of attribute nodes
#
# Global information on persistent stored documents:
# - doc_name      : BAT[oid,str]        document ID / document name
# - doc_height    : BAT[oid,int]        document ID / height of document
# - doc_size      : BAT[oid,lng]        document ID / size in bytes
# - doc_timestamp : BAT[oid,timestamp]  document ID / end-of-cache-time (nil if none)
# - uri_lifetime  : BAT[str,lng]        URI prefix  / time-to-live (seconds), nil if not to be cached 
# 
# Information on documents/fragments in the working set:
# - PRE_FRAG   : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each pre value (copied in element construction)
# - ATTR_FRAG  : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each attr value (copied in element/attribute 
#                construction)
# - DOC_LOADED : BAT[void,str] fragment ID / name of document 
#                (starts with 1@0 because WS is first 'loaded' document
# - FRAG       : BAT[void,oid] 0@0 / oid of the newest added fragment
# - WS_FRAG    : BAT[void,oid] enumeration / root-pre values of
#                generated element fragments
# - HEIGTH     : BAT[void,int] enumeration of the fragments / maximal
#                depth of the fragment (starts with 0@0 - WS)

module(pf_support); 

# get a handle to the global lock
var pf_lock := pflock(); 

# note that these variables may not be shared by parallel MIL clients
var doc_query; # bat[oid,int] active working-sets (queries) that use a particular document 
var doc_sema;  # bat[oid,sema] used by delete_doc to wait until all doc users have gone

# initialize doc_query and doc_sema (use BBP as global mechanism to discover initialization)
lock_set(pf_lock);
if (not(isnil(CATCH(bat("doc_name").count())))) {
    # create doc_name table in case it does not exist
    new(oid,str).persists(true).bbpname("doc_name");
    new(oid,str).persists(true).bbpname("doc_location");
    new(oid,timestamp).persists(true).bbpname("doc_timestamp");
    new(oid,int).persists(true).bbpname("doc_height");
    new(oid,lng).persists(true).bbpname("doc_size");
    new(str,lng).persists(true).bbpname("uri_lifetime");
}
if (isnil(CATCH(bat("doc_query").count()))) {
    doc_query := bat("doc_query"); 
    doc_sema := bat("doc_sema"); 
} else {
    (doc_query := new(oid,int)).bbpname("doc_query"); 
    (doc_sema := new(oid,monet_atomtbl.find("sema"))).bbpname("doc_sema"); 
}
lock_unset(pf_lock);

# DEFINITION of constants concerning the data model
const PRE_BASE := 0@0;
const ELEMENT := chr(0);
const TEXT := chr(1);
const COMMENT := chr(2);
const PI := chr(3);
const DOCUMENT := chr(4);
const WS := 0@0;

@- ws definition

This macro is used for the MIL const defs, the C const defs,
but also in the MIL procs for creating, filling and destroying
a working set.

We define a table with the column name, its number,
the type of data (typically again a bat), and if
so the head and tail type of that bat.

actually the field 'tpe' is taken to be bat *always*, 
EXCEPT when (child-T == void)

('tpe' = void means it is a view; without persistent name)

        name       number  tpe  col[H,T]    col-seqbase 
        ========   ======  ===  ==========  ===========
@= ws
@:@1_ws(PRE_SIZE,       0, bat, void,  int, PRE_BASE)@
@:@1_ws(PRE_LEVEL,      1, bat, void,  chr, PRE_BASE)@
@:@1_ws(PRE_PROP,       2, bat, void,  oid, PRE_BASE)@
@:@1_ws(PRE_KIND,       3, bat, void,  chr, PRE_BASE)@
@:@1_ws(PRE_FRAG,       4, void,void,  oid, PRE_BASE)@
@:@1_ws(QN_URI,         5, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_PREFIX,      6, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_LOC,         7, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_TEXT,      8, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_COM,       9, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_INS,      10, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_TGT,      11, bat, void,  str, PRE_BASE)@
@:@1_ws(ID_PRE,        12, bat,  str,  oid, oid(nil))@
@:@1_ws(IDREF_PRE,     13, bat,  str,  oid, oid(nil))@
@:@1_ws(ATTR_OWN,      14, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_QN,       15, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_PROP,     16, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_FRAG,     17, void,void,  oid, PRE_BASE)@
@:@1_ws(PROP_VAL,      18, bat, void,  str, PRE_BASE)@
@:@1_ws(DOC_LOADED,    19, str, void, void, oid(nil))@
@:@1_ws(FRAG,          20, oid, void, void, oid(nil))@
@:@1_ws(WS_FRAG,       21, oid, void, void, oid(nil))@
@:@1_ws(HEIGHT,        22, int, void, void, oid(nil))@
@:@1_ws(QN_PREFIX_URI, 23, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_LOC_URI,    24, bat, void,  str, PRE_BASE)@
@:@1_ws(KIND_PRE_0,    25, bat, void,  oid, oid(nil))@
@:@1_ws(KIND_PRE_1,    26, bat, void,  oid, oid(nil))@
@:@1_ws(KIND_PRE_2,    27, bat, void,  oid, oid(nil))@
@:@1_ws(KIND_PRE_3,    28, bat, void,  oid, oid(nil))@
@:@1_ws(KIND_PRE_4,    29, bat, void,  oid, oid(nil))@
@:@1_ws(PROP_PRE_0,    30, bat,  oid,  oid, oid(nil))@
@:@1_ws(PROP_PRE_3,    31, bat,  oid,  oid, oid(nil))@
@:@1_ws(REGION_PRE,    32, bat, void,  oid, oid(nil))@
@:@1_ws(REGION_START,  33, bat, void,  lng, oid(nil))@
@:@1_ws(REGION_END,    34, bat, void,  lng, oid(nil))@

@-
BEWARE: WS_SIZE (below) should *always* be the size of ws (above)

@= decl
@:@1_decl_ws(WS_SIZE, 35)@
@:@1_decl_ws(QNAME,    2)@
@:@1_decl_ws(BOOL,     3)@
@:@1_decl_ws(INT,      4)@
@:@1_decl_ws(DEC,      5)@
@:@1_decl_ws(DBL,      6)@
@:@1_decl_ws(STR,      7)@
@:@1_decl_ws(U_A,      8)@
@:@1_decl_ws(ATOMIC,  31)@
@:@1_decl_ws(NODE,    32)@
@:@1_decl_ws(ELEM,    33)@
@:@1_decl_ws(ATTR,    34)@

@= mil_decl_ws
const @1 := @2;
@mil

@:ws(mil_decl)@
@:decl(mil)@

const KIND_PRE := KIND_PRE_0;
const PROP_PRE := PROP_PRE_0;

# ATOMIC is not a type but all atomic types
# can be retrieved with 'select(int(nil),ATOMIC)'

# NODE is not a type but all node types
# can be retrieved with 'select(NODE,int(nil))'

@= create_ws
    ws_nme.append(toLower("@1"));
    ws_oid.append(oid(@1));
    ws_tpe.append(@3);
    ws_htp.append(@4);
    ws_ttp.append(@5);
    ws_seq.append(@6);
@mil
# the ws_* bats contain a recipe for creating a new ws
var ws_nme := bat(void,str,WS_SIZE); 
var ws_oid := bat(void,oid,WS_SIZE); 
var ws_tpe := bat(void,int,WS_SIZE); 
var ws_htp := bat(void,int,WS_SIZE); 
var ws_ttp := bat(void,int,WS_SIZE); 
var ws_seq := bat(void,oid,WS_SIZE); 
@:ws(create)@
ws_nme.access(BAT_READ).seqbase(0@0);
ws_oid.access(BAT_READ).seqbase(0@0);
ws_tpe.access(BAT_READ).seqbase(0@0);
ws_htp.access(BAT_READ).seqbase(0@0);
ws_ttp.access(BAT_READ).seqbase(0@0);
ws_seq.access(BAT_READ).seqbase(0@0);

PROC ws_bat(int tpe, int htp, int ttp, oid seq) : BAT[void,any]
{
    if (ttp != void) { # a bat of bats (persistent or view)
        var b := bat(htp,ttp);
        if (not(isnil(seq))) b.seqbase(seq); 
        return bat(void,bat).seqbase(PRE_BASE).append(b);
    } 
    return bat(void,tpe).seqbase(PRE_BASE); # a constant bat
}

PROC create_ws () : BAT[void,bat]
{
    var ws := [ws_bat](ws_tpe, ws_htp, ws_ttp, ws_seq);

    # fill the constant bats with initial values
    ws.fetch(DOC_LOADED).seqbase(1@0);
    ws.fetch(FRAG).seqbase(0@0).append(oid(nil));
    ws.fetch(HEIGHT).seqbase(0@0).append(0);
    return ws.access(BAT_READ);
}

PROC destroy_ws_locked(BAT[void,bat] ws) : void
{
    doc_query.select(int(ws))@batloop() {
        var doc_oid := $h;
        doc_query.delete(doc_oid, int(ws));
        if (not(doc_query.exist(doc_oid))) {
            if (doc_sema.exist(doc_oid)) {
                sema_up(doc_sema.find(doc_oid));
            }
        }
    }
    # determine whether a cache flush is desired (only count cached bats, those with a timestamp)
    var cursize := sum(bat("doc_timestamp").select(timestamp(nil),timestamp(nil)).mirror().join(bat("doc_size")));
    var maxsize := (1024LL * 1024LL) * lng(monet_environment.find("xquery_cacheMB"));

    if (cursize > maxsize) {
        delete_all_docs_locked(true);
    }
}

PROC destroy_ws(BAT[void,bat] ws) : void
{
    var err;

    if (type(doc_query) != bat) { return; }

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(destroy_ws_locked(ws));
    lock_unset(pf_lock);

    if (not(isnil(err))) { ERROR(err); }
}

PROC shred_doc_locked(BAT[str,bat] docBAT, str location, str name, timestamp ts, int ws, int height) : void 
{
    # get a new persistent doc id
    var doc_oid := 0@0;
    if (bat("doc_name").count() > 0) 
        doc_oid := oid(int(bat("doc_name").reverse().max()) + 1); 

    # rename all new bats with the doc id as suffix
    [rename](docBAT, [+](mirror(docBAT), str(int(doc_oid))));
    var totsize := sum([batsize](docBAT));

    # add to meta table
    bat("doc_name").insert(doc_oid, name);
    bat("doc_location").insert(doc_oid, location);
    bat("doc_timestamp").insert(doc_oid, ts);
    bat("doc_height").insert(doc_oid, height);
    bat("doc_size").insert(doc_oid, totsize);

    [persists](docBAT, true);

    # add the meta table to the commit set 
    #docBAT.insert(str(nil),bat("doc_name"));
    #docBAT.insert(str(nil),bat("doc_location"));
    #docBAT.insert(str(nil),bat("doc_timestamp"));
    #docBAT.insert(str(nil),bat("doc_height"));
    #docBAT.insert(str(nil),bat("doc_size"));
    #if (not(subcommit(docBAT))) 
    if (not(commit())) ERROR("shred_doc(%s) : commit failed\n", name);

    if (not(isnil(ws))) {
        pin_doc(doc_oid, ws);
    }
}

PROC index_doc(BAT[oid,bat] shredBAT, BAT[str,bat] docBAT) : int
{
    # insert all bats from shredBAT in docBAT
    var ins := ws_tpe.ord_uselect(bat).mirror().ord_select(oid(nil),oid(-(DOC_LOADED,1))).mirror();
    [insert](const docBAT, ins.leftfetchjoin(ws_nme), ins.leftfetchjoin(ws_oid).leftjoin(shredBAT));

    # these are simple concatenations (to accelerate combined lookup)
    docBAT.insert("qn_prefix_uri", docBAT.find("qn_prefix").[+](str('\1')).[+](docBAT.find("qn_uri")));
    docBAT.insert("qn_loc_uri",    docBAT.find("qn_loc").[+](str('\1')).[+](docBAT.find("qn_uri")));

    # create our indices
    var knd := ELEMENT;
    while ( knd <= DOCUMENT ) {
        docBAT.insert("kind_pre" + "_" + str(chr(48 + knd)),
                      docBAT.find("pre_kind").ord_uselect(knd).reverse().chk_order());
        knd :+= chr(1);
    }

    # we must now get all elemment-ids (prop) sorted, and within that, all pre's sorted
    var prop_pre_bat, sorted_pros;

    # get all element-pre's with their prop values in *reverse* pre order (note revert())
    prop_pre_bat := docBAT.find("kind_pre" + "_" + str(chr(48 + ELEMENT))).reverse().mirror();
    prop_pre_bat := prop_pre_bat.leftfetchjoin(docBAT.find("pre_prop")).reverse().access(BAT_WRITE).revert();

    # get all unique props, and sort them (we hope for a small set of values => small hash table)
    var sorted_props := prop_pre_bat.project(nil).kunique().sort().mirror();

    # lefthashjoin will keep props in order and output pre's ordered again within that
    # ..will construct a big hash-table, but exploits reverse-insert-order-out property of hash join
    prop_pre_bat := sorted_props.lefthashjoin(prop_pre_bat);
    docBAT.insert("prop_pre" + "_" + str(chr(48 + ELEMENT)), prop_pre_bat);

    # same procedure for PI (tends to be very small set anyway)
    prop_pre_bat := docBAT.find("kind_pre" + "_" + str(chr(48 + PI))).reverse().mirror();
    prop_pre_bat := prop_pre_bat.leftfetchjoin(docBAT.find("pre_prop")).reverse().access(BAT_WRITE).revert();
    sorted_props := prop_pre_bat.project(nil).kunique().sort().mirror();
    prop_pre_bat := sorted_props.lefthashjoin(prop_pre_bat);
    docBAT.insert("prop_pre" + "_" + str(chr(48 + PI)), prop_pre_bat);

    docBAT := docBAT.access(BAT_READ);
    return shredBAT.fetch(PRE_LEVEL).max().int() + 1;
}

PROC shred_doc_impl(BAT[str,bat] docBAT, str location, str name, bit doCommit, str opt, timestamp ts, int ws) : int
{
    var shredRES := shred2bats(location,"",opt);
    var err, exists := false;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(exists := bat("doc_name").texist(name));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
    else if (exists) ERROR("shred_doc(%s): already exists in database!\n", name);

    # add indices to the shredded doc, and find out maximum doc height
    var height := index_doc(shredRES, docBAT);

#[BURKOWSKI]
    var burkowski := false;
    CATCH( { burkowski := =(monet_environment.find("burkowski"),"enabled"); } );
    if (burkowski) {
        print("# extracting regions...\n");
        docBAT := region_extract(docBAT, "lng");
    } else {
       var r_pre := bat(void, oid).seqbase(0@0).bbpname("region_pre");
       var r_start := bat(void, lng).seqbase(0@0).bbpname("region_start");
       var r_end := bat(void, lng).seqbase(0@0).bbpname("region_end");
       docBAT.access(BAT_WRITE).insert("region_pre",r_pre); 
       docBAT.access(BAT_WRITE).insert("region_start",r_start); 
       docBAT.access(BAT_WRITE).insert("region_end",r_end); 
    }
#[/BURKOWSKI]

    if (doCommit) {
        [mmap](docBAT, [ifthenelse]([<]([count](docBAT), 65536), STORE_MEM, STORE_MMAP));
        [save](docBAT);

        # add doc to the database locked
        lock_set(pf_lock);
        err := CATCH(shred_doc_locked(docBAT, location, name, ts, ws, height));
        lock_unset(pf_lock);

        if (not(isnil(err))) ERROR(err);
    }
    return height;
}

PROC shred_doc_base(str location, str name, bit doCommit, str opt) : void
{
    var us := usec();
    var docBAT := bat(str,bat,WS_SIZE);
    shred_doc_impl(docBAT, location, name, doCommit, opt, timestamp(nil), int(nil));
    var ms := (us := usec() - us) / 1000;
    if ( doCommit ) {
        printf("# Shredded XML doc(\"%s\"), total time after commit=%lld.%03llds\n", name, /(ms,1000),%(ms,1000));
    } else {
        printf("# Shredded XML doc(\"%s\") uncommitted, total time =%lld.%03llds\n", name, /(ms,1000),%(ms,1000));
    }
}
PROC shred_doc(str location, str name) : void
{
    shred_doc_base(location, name, true, "");
}
ADDHELP("shred_doc", "flokstra", "Dec 2004",
"PARAMETERS:\n\
- str URI containing the xml document to be shredded)\n\
- str document name ('alias') in database\n\
DESCRIPTION:\n\
Shred xml document to the internal Pathfinder format, (analog to import_doc()).",
"pathfinder");

PROC delete_doc_locked(oid doc_oid) : bit
{
    var docBAT := new(void,str,WS_SIZE);

    if (doc_sema.exist(doc_oid)) {
        # somebody else is deleting the same doc!
        while(doc_sema.exist(doc_oid)) {
            lock_unset(pf_lock);
            sleep(1);
            lock_set(pf_lock);
        }
        return; # now he is done
    }
    # we will delete it
    while (doc_query.exist(doc_oid)) {
        var sem := sema_create(0);
        doc_sema.insert(doc_oid, sem);

        lock_unset(pf_lock);
        sema_down(sem); # wait for the users to go away 
        lock_set(pf_lock);

        sema_destroy(sem);
        doc_sema.delete(doc_oid, sem);
    }

    # docBAT becomes [name,bat]
    docBAT := [bat]([+](ws_tpe.uselect(bat).mirror().join(ws_nme), str(int(doc_oid))).reverse().mirror());

    # rename the bats so even in case of failure they don't bother us directly anymore
    [rename](docBAT, [+]([+]("rm_", mirror(docBAT)), +("_" , str(lng(current_timestamp()))))).access(BAT_WRITE);

    # remove them from the repository
    [persists](docBAT, false);

    bat("doc_name").delete(doc_oid);
    bat("doc_location").delete(doc_oid);
    bat("doc_timestamp").delete(doc_oid);
    bat("doc_height").delete(doc_oid);
    bat("doc_size").delete(doc_oid);

    # also commit the meta bats
    #docBAT.insert(str(nil), bat("doc_name"));
    #docBAT.insert(str(nil), bat("doc_location"));
    #docBAT.insert(str(nil), bat("doc_timestamp"));
    #docBAT.insert(str(nil), bat("doc_height"));
    #docBAT.insert(str(nil), bat("doc_size"));
    #return subcommit(docBAT);
    return commit();
}

PROC delete_doc(str name) : void
{
    var err, exists := false;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(exists := bat("doc_name").texist(name));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
    else if (not(exists)) ERROR("delete_doc(%s): document not found in database!\n", name);

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(delete_doc_locked(bat("doc_name").reverse().find(name)));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
}
ADDHELP("delete_doc", "tsheyar", "July 2004",
"PARAMETERS:\n\
str document name\n\
DESCRIPTION:\n\
delete the persistent BATS that store the document.",
"pathfinder");

PROC delete_all_docs_locked(bit cachedOnly) : void
{
    bat("doc_timestamp").copy()@batloop() {
        if (not(and(cachedOnly, isnil($t))))
            delete_doc_locked($h);
    }
}

PROC delete_all_docs(bit cachedOnly) : void
{
    var err, b := bat(timestamp,str);

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(delete_all_docs_locked(cachedOnly));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
}
ADDHELP("delete_all_docs", "tsheyar", "July 2004",
"DESCRIPTION:\n\
deletes all persistent document BATs that store xml documents;\n\
with parameter TRUE, only the (implicitely) cached documents are deleted,\n\
with parameter FALSE, also the (explicitely) shredded documents are deleted.",
"pathfinder");


PROC pin_doc(oid doc_oid, int ws) : void 
{
    # pin the document on this working set (must hold lock!)
    doc_query.insert(doc_oid, int(ws));
}


# get filename if the URI is a file; else return str(nil)
PROC doc_filename(str name) : str
{
    var uri_idx := -1;
    if (startsWith(name, "file://") or startsWith(name, "FILE://")) {
        name := string(name, 7);
     } else if (search(name, "://") >= 0) {
        return str(nil);
     }
     return name;
}

# get the actual timestamp of the document cached in the database
PROC doc_curtime(str filename) : timestamp {
    var ts := current_timestamp();
    if (not(isnil(filename))) {
        # a file: get lastmodification time
        var tts, err := CATCH(tts := lastmod_time(filename));
        if (isnil(err)) ts := tts;
    }
    return ts;
}

PROC add_docbat(BAT[void,bat] ws, BAT[str,bat] docBAT, str name, str docid, int height) : oid
{
    # add it to the working set
    var frag := ws.fetch(DOC_LOADED).uselect(name);

    if (frag.count() = 0) {
        ws.fetch(DOC_LOADED).append(name);
        frag := oid(ws.fetch(DOC_LOADED).count());

        # use the ws_* bats to add all bats to the working set in a multiplex
        var src := ws_tpe.ord_uselect(bat).mirror().leftfetchjoin(ws_nme);
        var dst := src.mirror().leftfetchjoin(ws);
        if (docid != "") 
            # if docid != "", it holds the str(id) of the persistent doc
            src := [bat]([+](src, docid));
        else
            # if not, the temporary document has been shredded into docBAT
            src := src.leftjoin(docBAT);
        [append](dst, src);

        # create views
        ws.fetch(PRE_FRAG).append(constant2bat(frag));
        ws.fetch(ATTR_FRAG).append(constant2bat(frag));

        # adapt constants
        ws.fetch(FRAG).replace(0@0,frag);

        if (isnil(height))
            height := ws.fetch(PRE_LEVEL).max().int() + 1;
        ws.fetch(HEIGHT).append(height);
    } else { 
        ws.fetch(FRAG).replace(0@0,frag.reverse().fetch(0)); 
    }
    return frag;
}

PROC add_doc_locked(str name, timestamp ts, int ws) : oid 
{
    var doc_oid := oid(nil);
    # check if the document already existed
    if (bat("doc_name").texist(name)) {
        doc_oid := bat("doc_name").reverse().find(name);
    } else if (bat("doc_location").texist(name)) {
        # existed as cached location (URI): must check timestamp
        doc_oid := bat("doc_location").reverse().find(name);
    }
    if (not(isnil(doc_oid))) {
        var lim := bat("doc_timestamp").find(doc_oid);
        if (not(isnil(lim))) { # a nil limit means the doc never expires
            if  (ts > lim) {
                delete_doc_locked(doc_oid); # remove outdated document from the cache
                return oid(nil);
            }
        }
        pin_doc(doc_oid, ws); # GOT IT! make sure nobody can delete it
     }
     return doc_oid;
}

PROC lifetime_doc_locked(str name, str filename, oid doc_oid, timestamp ts) : timestamp
{
    if (isnil(doc_oid) and isnil(filename)) {
        # for not-yet-cached URIs: get lifetime from uri_lifetime BAT
        var uri_lifetime := bat("uri_lifetime");
        var b := [startsWith](name, mirror(uri_lifetime)).uselect(true);
        var lifetime := lng(nil);
        if (b.count() > 0) {
            var matchlen := [length](mirror(b));
            lifetime :=  *(1000LL, uri_lifetime.find(matchlen.reverse().find(matchlen.max())));
        }
        # this may set ts to nil; such URIs are never cached (and thus do not need to be persistent)
        ts := ts.add(lifetime);
    }
    return ts;
}

PROC add_doc(BAT[void,bat] ws, str name) : int
{
    var time_shred := 0; 
    var filename := doc_filename(name);
    var t := time();
    var doc_oid := oid(nil);
    var ts := doc_curtime(filename);
    var err;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(doc_oid := add_doc_locked(name,ts,int(ws)));
    if (isnil(err)) err := CATCH(ts := lifetime_doc_locked(name,filename,doc_oid,ts));
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);

    var docBAT := new(str,bat,WS_SIZE);
    var doCommit := true;
    var docid := str(nil);
    var height;

    if (isnil(doc_oid)) {
        if (isnil(ts)) {
            doCommit := false;
            docid := "";
        }
        height := shred_doc_impl(docBAT, name, name, doCommit, "", ts, int(ws));
        time_shred :+= time() - t;
    }
    if (isnil(docid)) {
        doc_oid := bat("doc_name").reverse().find(name);
        height := bat("doc_height").find(doc_oid);
        docid := str(int(doc_oid));
    }
    add_docbat(ws, docBAT, name, docid, height);
    return time_shred;
}


@- xml document cache
When fn:doc() is used with a previously unseen URI, it is shredded on the fly and placed into 
the xml document cache (see text below). A number of procs are provided to monitor
and control the behavior of the cache.
@mil
const xmlcache_help := 
"The XML document cache keeps indexed copies of documents that where recently\n\
used in the fn:doc(URI) xquery function.\n\
\n\
The size of the cache is controlled using the 'xquery_cacheMB' setting in\n\
the 'MonetDB.conf' file.\n\
\n\
For file URIs, the cache looks at the last-modification-time of the file on disk\n\
to guarantee that the cached document is still up-to-date for answering queries from.\n\
\n\
For other URIs, *lifetime rules* determine how long documents can stay in the cache.\n\
Each lifetime rule consists of a URI prefix and the registered seconds of lifetime.\n\
\n\
The rule with longest prefix that matches an URI counts. Specifying a lifetime\n\
of 'int(nil)' seconds means that the URI will *not* be cached at all.\n\
This is also the default if no prefix matches an URI.\n\
\n\
The name of a cached document is the same as its location (URI). For explicitly\n\
shredded documents (with 'shred_doc(location,name)'), the name is an 'alias' and\n\
may differ from the URI. Explicitly shredded documents fall outside the XML document\n\
cache; documents are only removed at explicit user request (with 'delete_doc(name)').";

PROC xmlcache_add_rule(str uri, any lifetime) : void {
    xmlcache_add_rule(uri, lng(lifetime)); 
}
PROC xmlcache_add_rule(str uri, lng lifetime) : void {
    lock_set(pf_lock);
    var err := CATCH({ bat("uri_lifetime").delete(uri); bat("uri_lifetime").insert(uri, lifetime); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_add_rule", "boncz", "May 2005",
"DESCRIPTION:\nadd a new URI lifetime rule.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_del_rule(str uri) : void {
    lock_set(pf_lock);
    var err := CATCH({ bat("uri_lifetime").delete(uri);});
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_del_rule", "boncz", "May 2005",
"DESCRIPTION:\ndeletes an existing URI lifetime rule.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_print_rules() : void {
    lock_set(pf_lock);
    var err := CATCH({  table(bat("uri_lifetime").hmark(0@0).col_name("URI-prefix"), bat("uri_lifetime").tmark(0@0).col_name("liftime-secs")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_print_rules", "boncz", "May 2005",
"DESCRIPTION:\nshows all URI lifetime rules.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_print() : void {
    lock_set(pf_lock);
    var err := CATCH({  table(bat("doc_name").col_name("alias"), bat("doc_location").col_name("URI"), bat("doc_size").col_name("size"), bat("doc_timestamp").select(timestamp(nil),timestamp(nil)).col_name("valid-thru")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_print", "boncz", "May 2005",
        "DESCRIPTION:\nshows the actual content of the XML document cache.\n\n" + xmlcache_help,  "pathfinder");

PROC xmldb_print() : void {
    lock_set(pf_lock);
    var err := CATCH({  table(mirror(bat("doc_timestamp").uselect(timestamp(nil))).join(bat("doc_name")).col_name("alias"), bat("doc_location").col_name("URI"), bat("doc_size").col_name("size")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmldb_print", "boncz", "May 2005",
"DESCRIPTION:\nshows the actual content of the persistent XML document database (not the XML document cache).\n\nThis consists of all documents explicitly shredded with shred_doc(URI, alias).",  "pathfinder");

@= c_decl_ws
#define @1 @2
@h
#ifndef PATHFINDER_H
#define PATHFINDER_H

#include <monettime.h>
#include <lock.h>
#include <monet.h>
#include <monet_context.h>
#include <monet_interpreter.h>
#include <streams.h>
#include <mapi.h>
#include <sys.h>
#include <pathfinder.proto.h>

#define is_fake_project(b) (((b)->htype==TYPE_void) && (BATcount(b)==1) && ((b)->hseqbase==oid_nil))

@:ws(c_decl)@
@:decl(c)@

#define XTRACT_KIND(X)  (X & 63)
#define XTRACT_FRAG(X)  (X >> 6)

/* xquery_method : execute a loop-lifted xquery function
 *
 * argc          = #params
 * itercnt       = #iterations
 * argcnt[iter]  = #items per param 
 * argtpe[]      = xquery type of each parameter (as string, e.g. 'xs:integer')
 * argval[]      = str representation of item (e.g. '42')
 *
 * shredBAT   = optional shredded document table, that is added to working set
 *              params of type xs:anyNode are represented as int pre-numbers.
 *
 * we return an error string, or NULL iff everything went A-OK  
 */
char*
xquery_method(stream *out, 
              int rpctiming,
              char* module, 
              char* uri, 
              char *method, 
              int argc, 
              int itercnt, 
              int** argcnt, 
              str* argtpe, 
              str* argval, 
              BAT* shredBAT);

#endif
@c
#include "pathfinder.h"

#define XQUERY_BUFSIZE 16364

/* the xquery builtin type hierarchy */
typedef struct {
    int parent;
    int monet_tpe;
    int kind;
    char* name;
} xquery_type;

#define DOCBAT (ELEM | (1<<6))
#define XQUERY_TYPES 15
#define XQUERY_ABSTRACT 6

xquery_type xquery_types[XQUERY_TYPES+1] =
{ {  5, TYPE_bit, BOOL,   "xs:bool"  },  
  {  2, TYPE_lng, INT,    "xs:integer" },
  {  4, TYPE_dbl, DEC,    "xs:decimal" },
  {  4, TYPE_dbl, DBL,    "xs:float" },
  {  5, TYPE_dbl, DBL,    "xs:double" },
  {  7, TYPE_str, STR,    "xs:string" },
  {  8, TYPE_str, STR,    "xs:untypedAtomic" },
  {  8, TYPE_str, STR,    "xdt:anyAtomicType" },
  {  9, TYPE_str, STR,    "xs:anySimpleType" },
  { 14, TYPE_str, STR,    "xs:anyType" },
  { 14, TYPE_str, STR,    "xdt:untypedAny" },
  { 13, TYPE_oid, DOCBAT, "xs:anyElement" },
  { 13, TYPE_oid, DOCBAT, "xs:anyAttribute" },
  { 14, TYPE_oid, DOCBAT, "xs:anyNode" },
  { 15, TYPE_oid, DOCBAT, "xs:anyItem" },
  {  0, TYPE_oid, DOCBAT, "illegal type" } };

/*
 * return xquery type number, given a type string
 */
static int
xquery_typenr(char* tpe) 
{
    int i;
    for(i=0; i<XQUERY_TYPES; i++) 
        if (strcmp(tpe, xquery_types[i].name) == 0) break;
    return i;
}

/*
 * find the common ancestor of two xquery types
 */
static int
xquery_type_common_ancestor(int t1, int t2) 
{
    if (t1 < 0 || t1 >= XQUERY_TYPES) return t2;
    if (t2 < 0 || t2 >= XQUERY_TYPES) return t1;
    while(t1 != t2) {
        if (t1 < t2) t1 = xquery_types[t1].parent;  
        else         t2 = xquery_types[t2].parent;  
    }
    return t1;
} 

/* representation of a xquery function signature */
typedef struct {
    int argc;                     /* number of params */
    unsigned int zero;            /* bit-mask that indicates whether param (bit) i can be the empty sequence */
    unsigned int multiple;        /* bit-mask that indicates whether param (bit) i can be a sequence */
    unsigned char tpe[MAXPARAMS]; /* xquery type number (point into above xquery_types table) */
    char name[1];                 /* method name */
} xquery_sig;


/* xquery functions */
typedef struct _xquery_function {
    struct _xquery_function *next;
    oid vid;                      /* vid of first param */
    lng size;                     /* byte size of prepared tree */
    xquery_sig *sig;              /* method signature */
    char* mil;                    /* generated MIL */
    char  proc[1];                /* MIL procname */
} xquery_function;


/* xquery modules */
typedef struct _xquery_module {
    struct _xquery_module *next;
    char* prologue;               /* MIL procs defined in this module */
    char* epilogue;               /* MIL procs undefs for this module */
    xquery_function *functions;   /* functions declared in this module */
    char *nsurl;                  /* module namespace definition */
    char url[1];                  /* module url */
} xquery_module;

/* global list of known modules and their function declarations */
xquery_module *xquery_compiled_modules = NULL;


/* cached functions */
typedef struct _xquery_prepared_function {
    struct _xquery_prepared_function *next;
    xquery_function *def;         /* function definition */
    YYSTREE lt;                   /* cached MIL tree */
    unsigned int lru;             /* least recently used stamp */
} xquery_prepared_function;

unsigned int xquery_lru = 0;

/* loaded modules */
typedef struct _xquery_loaded_module {
    struct _xquery_loaded_module *next;
    xquery_module* def;           /* module definition */
    char* ns;                     /* namespace under which the module was loaded */
    int nslen;
} xquery_loaded_module;


/* cached MIL client + Xquery specific context */
typedef struct {
    bit initialized;
    int inuse; 

    /* xquery_clients[stk].stk == stk; MIL client is monet_clients[stk] */
    Cntxt stk; /* stack to execute module prologues and non-cacheable queries in */  

    /* MIL child context of ctx->stk; it is marked as a reusable stack frame so variable records are kept */
    Cntxt repeat_stk; /* stk to execute the prepated function trees in  for fast reuse */ 

    /* last MIL variable that should be cleared after execution */ 
    Variable lastvar; 

    /* value parsing buffer reuse */
    int vallen;
    ptr val;

    /* query buffer reuse */
    size_t buflen;
    char *buf;
    int cacheid;        /* only reuse from the same cache */
        
    /* error stream (normally fderr=GDKerr=GDKout) */
    stream *fderr;

    /* live BAT handles (note we gave them a memory refcount in BBP) */
    BAT *proc_vid, *var_usage;
    BAT *dbl_values, *int_values, *str_values;
    BAT *fun_vid000, *fun_iter000, *fun_item000, *fun_kind000, *loop000;

    /* pointers into MIL variable records (to set values) */
    int *shredBAT; 
    int *time_compile; 
    int *time_shred;
    int *time_exec;
    int *time_print;
    char **genType;

    /* counts used to remove query (non-module) procs and stacks after execution */
    size_t var_usage_size; 
    size_t proc_vid_size;

    /* size of the cached procs */
    size_t cachesize;

    xquery_prepared_function* prepared_functions;
    xquery_loaded_module *loaded_modules; 
} xquery_client;

/* xquery context cache corresponds slot-by-slot with monet_clients */
xquery_client xquery_clients[MAXCLIENTS + 1];

size_t xquery_client_bytes = 64<<20; /* 64MB of procs should be enough for anyone */
int xquery_cacheid = 0;

MT_Lock pf_compiler_lock;
MT_Lock pf_module_lock;
MT_Lock pf_cache_lock;

#include "compile_interface.h"

/*
 * =================== MIL execution ================================
 *
 * int     
 * xquery_tree_exec(xquery_client *ctx, YYSTREE t, int repeat) { 
 * - execute parsed MIL tree
 *
 * YYSTREE 
 * xquery_mil2tree(xquery_client *ctx, char* buf) { 
 * - parse MIL buffer into a tree
 *
 * int
 * xquery_mil_exec(xquery_client *ctx, char* buf, int debug) { 
 * - execute MIL buffer (parse & execute)
 *
 * int
 * xquery_compile_exec(xquery_client *ctx, char *mode, char* xquery, int is_url, 
 *                     char** prologue, char** query, char** epilogue, char* nsurl) 
 * - translate xquery to MIL and execute
 *
 * all int-returning functions return error(0)/ok(1)
 */

/*
 * execute parsed MIL tree, return error(0)/ok(1)
 */
static int 
xquery_tree_exec(xquery_client *ctx, 
                 YYSTREE t, 
                 int repeat) 
{ 
    ValRecord res;
    int ret = interpret(repeat?ctx->repeat_stk:ctx->stk, t, &res);
    if (ret == -TOK_RETURN) {
        /* ignore return value here */
        VALclear(&res);
        ret = 1;
    } else if (ret >= 0) {
        ret = 1;
    } else {
        ret = 0;
    }
    CLEANUP(t);
    return ret;
}

/*
 * parse MIL buffer into a tree
 */
static YYSTREE 
xquery_mil2tree(xquery_client *ctx, 
                char* buf) 
{ 
    Client c = monet_clients + ctx->stk;
    YYSTREE ret = NULL, treebak = c->tree;
    char* bufbak = c->input;
    int listing_bak = c->listing;
    c->listing = 0;
    c->input = buf;
    c->tree = NULL;
    if (parseClient(c, FALSE))
        ret = c->tree;
    c->tree = treebak;
    c->input = bufbak;
    c->listing = listing_bak;
    return ret;
}

/*
 * execute MIL buffer (parse & execute), return error(0)/ok(1)
 */
static int 
xquery_mil_exec(xquery_client *ctx,  
                char* buf, 
                int debug) 
{
    int ret = 0;
    YYSTREE t;

    if (debug)
        stream_write(ctx->fderr, buf, strlen(buf), 1);

    t = xquery_mil2tree(ctx, buf); 
    if (t) {
        ret = xquery_tree_exec(ctx, t, 0);
        Myyfree(t);
    }
    return ret;
}

static char* xquery_parse_ident(char* p); 
static char* xquery_parse_space(char* p); 
static char* xquery_parse_string(char* p, char *buf, int len); 

/*
 * translate xquery to MIL and execute, return error(0)/ok(1)
 * We collect the MIL scripts in three sections (prologue,query,epilogue).
 * The query may be NULL, in which case we mean that it should be ignored. 
 */
#define PFURLCACHE(fcn, query, cache) {\
    char *url = query;\
    query = PFurlcache(url, cache);\
    if (query == NULL) {\
        err = (char*) alloca(strlen(url)+80);\
        sprintf(err, "%s(%s): could not retrieve query\n", fcn, url);\
}    }
static int
xquery_compile_exec(xquery_client *ctx, 
                    char *mode,  
                    char* xquery, 
                    int is_url, 
                    char** prologue, 
                    char** query, 
                    char** epilogue,
                    char* nsurl)
{
    int is_mil = 0, len=0, ret = 0, debug = strstr(mode,"debug") != NULL;
    char *mapi = strstr(mode, "mapi")?"=":"";
    char *err = NULL;

    MT_set_lock(pf_compiler_lock, "xquery_compile_exec");
    if (is_url) {
        int l = strlen(xquery);
        is_mil = (l > 4 && xquery[l-4] == '.' && xquery[l-3] == 'm' && xquery[l-2] == 'i' && xquery[l-1] == 'l');
        PFURLCACHE("xquery_compile_exec", xquery, !is_mil);
    }
    if (err == NULL) {
        char *del = NULL;
        if (is_mil && query == NULL) {
            *prologue = xquery; *epilogue = NULL;
        } else {
            err = PFcompile_MonetDB(xquery, mode, prologue, &del, epilogue);
            if (err == NULL && nsurl != NULL){
                /* get the module namespace URL Y from pattern: "module namespace X = Y" */
                char *p0 = xquery_parse_space(xquery); 
                err = "xquery_compile_exec: cannot parse module namespace.\n";
                if (strncmp(p0, "module", 6) == 0) {
                    char *p1 = xquery_parse_space(p0+=6); 
                    if (p1 > p0 && strncmp(p1, "namespace", 9) == 0) {
                        char *p2 = xquery_parse_space(p1+=9); 
                        if (p2 > p1) {
                            char* p3 = xquery_parse_ident(p2);
                            if (p3 > p2) {
                                char *p4 = xquery_parse_space(p3); 
                                if (p4 > p3 && *p4++ == '=') {
                                    char *p5 = xquery_parse_space(p4); 
                                    if (p5 > p4 && xquery_parse_string(p5, nsurl, 1024) > p5) {
                                        err = NULL; /* success! */
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (err == NULL || (prologue && *prologue) || (del && *del)) {
            ret = 1; /* no errors, or some MIL script came out still */
        }
        if (query) {
            *query = del;
        } else if (del) {
            free(del); /* we are ignoring the query part apparently */
        }
    }
    if (err) {
        len = strlen(err);
        if (*mapi) {
            /* put ! before error lines */
            char *p = err, *q = err;
            while (*p) {
                if (*p++ == '\n')
                    len++;
            }
            err = (char*) alloca(len+3);
            *err = '!'; 
            for (p = err + 1; *q; q++) {
                *p++ = *q;
                if (*q == '\n')
                    *p++ = '!'; 
            }
            /* guard against errors that do not terminate in a newline */
            if (q > err && q[-1] != '\n')
                *p++ = '\n';
            else if (p[-1] == '!')
                p--;
            *p = 0;
            len = p - err;
        }
    }
    MT_unset_lock(pf_compiler_lock, "xquery_compile_exec");
    
    /* write errors and debug info on client stream */
    if (err && *err) stream_write(ctx->fderr, err, len, 1);

    /* execute the three MIL sections */
    if (ret && *prologue && **prologue)
        ret = xquery_mil_exec(ctx, *prologue, debug);

    if (ret && query) {
        if (*query && **query)
            ret = xquery_mil_exec(ctx, *query, debug);

        if (ret && *epilogue && **epilogue)
            ret = xquery_mil_exec(ctx, *epilogue, 0);
    }
    return ret?ret+is_mil:0;
}

/*
 * =================== function admin ================================
 *
 * xquery_sig*
 * xquery_sig_init(char *proc)
 * - infer the xquery function signature from the mangled MIL procname (return NULL on error)
 *
 * int
 * xquery_sig_match(xquery_sig *sig, int argc, int* mincnt, int* maxcnt, int *argtpe)
 * - check whether sig can match the actual parameters (return true/false)
 *
 * xquery_function* 
 * xquery_resolve(xquery_client *ctx, char *ns, char *method, int argc, int *mincnt, int* maxcnt, int* argtpe)
 * - resolve a method call in the current xquery context (return NULL if not resolved)
 *
 * char*
 * xquery_function_call(xquery_client *ctx, int msec, char* mode, char *ns, char *method, 
 *                      int argc, int itercnt, int** argcnt, char** argtpe, char** argval, BAT *shredBAT)
 * - call a function ns:method(). try to use the function cache (ie re-use a cached MIL tree).
 *   otherwise generate MIL yourself, interpret it (and cache it). Returns error string (NULL if ok).
 */

/*
 * infer the xquery function signature from the mangled MIl procname (return NULL on error)
 */
static xquery_sig* 
xquery_sig_init(char *proc) 
{
    char *cur = (char*) alloca(strlen(proc)); 
    xquery_sig* sig;
    int len = 0;

    proc = strchr(proc, '_'); /* skip fnXXXXXXXX_' */
    if (proc == NULL) return NULL;
    strcpy(cur, ++proc);
    sig = (xquery_sig*) GDKmalloc(sizeof(xquery_sig)+strlen(proc)); 
    if (sig == NULL) return NULL;

    sig->argc = sig->zero = sig->multiple = 0;

    /* get method name */
    while(cur[0]) {
        if (cur[0] == '_' && cur[1] == '_') {
            cur++; /* unescape '_' */
        } else if (cur[0] == '_' && (cur[1] == '4' || cur[1] == '5') && cur[2] == '_') {
            sig->name[len++] = (cur[1] == '4')?'-':'.'; cur += 3; continue;
        } else if (cur[0] == '_') {
            break; /* unescaped '_' => end of function name */
        }
        sig->name[len++] = *cur++;
    }
    sig->name[len] = 0;
    while(*cur++ == '_') {
        char *tpe = cur;
                
        /* parse namespace part */
        for(len=0; cur[0]; cur++) {
            if (cur[0] == '_' && cur[1] == '_') {
                tpe[len++] = '_';
                cur++; /* unescape '_' */
            } else if (cur[0] != '_') {
                tpe[len++] = cur[0];
            } else {
                tpe[len++] = ':';
                cur++; break;
            }
        }
        /* parse type part */
        for(; cur[0]; cur++) {
            if (cur[0] == '_' && cur[1] == '_') {
                tpe[len++] = '_';
                cur++; /* unescape '_' */
            } else if (cur[0] != '_') {
                tpe[len++] = cur[0];
            } else {
                break;
            }
        }
        if (cur[-1] == '0') {
            sig->zero |= 1<<sig->argc; 
        } else if (cur[-1]  == '2') {
            sig->zero |= 1<<sig->argc; 
            sig->multiple |= 1<<sig->argc; 
        } else if (cur[-1]  == '3') {
            sig->multiple |= 1<<sig->argc; 
        }
        cur[-1] = 0;
        if ((sig->tpe[sig->argc++] = xquery_typenr(tpe)) >= XQUERY_TYPES) {
            /* unknown type: don't cache this function */
            GDKfree(sig);
            return NULL;
        }
    }
    return sig;
}


/*
 * check whether sig can match the actual parameters (return true/false)
 */
static int
xquery_sig_match(xquery_sig *sig, int argc, int* mincnt, int* maxcnt, int *argtpe) 
{
    int i, tpe[MAXPARAMS];
    for(i=0; i < argc; i++) {
        if (mincnt[i] == 0 && !(sig->zero & (1<<i))) return 0; 
        if (maxcnt[i] > 1 && !(sig->multiple & (1<<i))) return 0; 
        tpe[i] = argtpe[i];
        while(sig->tpe[i] != tpe[i]) {
            if (tpe[i] >= XQUERY_TYPES) return 0;
            tpe[i] = xquery_types[tpe[i]].parent;
        }
    }
    for(i=0; i< argc; i++) {
        argtpe[i] = tpe[i];
    }
    return 1;
}

/*
 * resolve a method call in the current xquery context (return NULL if nonresolved)
 */
static xquery_function*
xquery_resolve(xquery_client *ctx, char *ns, char *method, int argc, int *mincnt, int* maxcnt, int* argtpe) 
{
    xquery_loaded_module *mod = ctx->loaded_modules;
    int nslen = strlen(ns);

    /* look up ns and method */
    while(mod) {
        if (mod->nslen == nslen && strncmp(mod->ns, ns, nslen) == 0) {
            xquery_function *fun = mod->def->functions;
            while(fun) {
                if (argc == fun->sig->argc && strcmp(method, fun->sig->name) == 0) {
                    if (xquery_sig_match(fun->sig, argc, mincnt, maxcnt, argtpe)) return fun;
                }
                fun = fun->next;
            }
        }
        mod = mod->next;
    }
    return NULL;
}


@= seqbase
    BATseqbase(ctx->@1, @2);
    if (debug) m += snprintf(mil+m, XQUERY_BUFSIZE-l, "@1.seqbase(" @3 ");\n");
@= bunins
    if (BUNins(ctx->@1, @2, @3, FALSE) == NULL) return "xquery_method: allocation error while inserting in @1";
    if (debug) m += snprintf(mil+m, XQUERY_BUFSIZE-l, "@1.append(" @5 @6 ");\n", @4 @3);
@= bunappend
    if (BUNappend(ctx->@1, @2, FALSE) == NULL) return "xquery_method: allocation error while inserting in @1";
    if (debug) m += snprintf(mil+m, XQUERY_BUFSIZE-l, "@1.append(" @4 @5 ");\n", @3 @2);
@c
/*
 * call a function ns:method(). try to use the function cache (ie re-use a cached MIL tree).
 * otherwise generate MIL yourself, interpret it (and cache it). Returns error string (NULL if ok).
 */
static char xquery_function_error[80] = "xquery_method: error during execution.\n";
static char* 
xquery_function_call(xquery_client *ctx, 
                     int msec, 
                     char *mode, 
                     char *ns, 
                     char *method, 
                     int argc, 
                     int itercnt, 
                     int** argcnt, 
                     char** argtpe, 
                     char** argval, 
                     BAT *shredBAT) 
{
    xquery_prepared_function *prepfun = ctx->prepared_functions;
    xquery_function *fun;
    int i, j, k, l, m=0, tpe[MAXPARAMS], mincnt[MAXPARAMS], maxcnt[MAXPARAMS];
    int debug = (strstr(mode,"debug") != NULL);
    char mil[XQUERY_BUFSIZE], *src, *cur = mil, *end = mil + XQUERY_BUFSIZE-1;

    /* determine minimum and maximum sequence of the parameters, and the common ancestor type of each sequence  */
    for(j=0; j<argc; j++) {
        mincnt[j] = maxcnt[j] = argcnt[0][j];
        tpe[j] = -1;
    }
    for(l=i=0; i<itercnt; i++) {
        for(j=0; j<argc; j++) {
            if (argcnt[i][j] > maxcnt[j]) maxcnt[j] = argcnt[i][j];
            if (argcnt[i][j] < mincnt[j]) mincnt[j] = argcnt[i][j];
            for(k=0; k<argcnt[i][j]; k++,l++) {
                int t = xquery_typenr(argtpe[l]);
                if (t >= XQUERY_TYPES) 
                    return (char*) -1; /* can't make a quick function resolution if unknown types are involved */
                tpe[j] = xquery_type_common_ancestor(tpe[j],t);
            }
        }
    }

    /* try to resolve the parameters */
    fun = xquery_resolve(ctx, ns, method, argc, mincnt, maxcnt, tpe);
    if (fun == NULL)
        return (char*) -1; /* no such udf. but it may be a built-in, actually */

    /* create a prepared function record for this MIL client */
    while(prepfun && prepfun->def != fun) prepfun = prepfun->next;
    if (prepfun == NULL) {
        prepfun = (xquery_prepared_function*) GDKmalloc(sizeof(xquery_prepared_function));
        if (prepfun == NULL)
            return "xquery_function_call: allocation failed.\n";
        prepfun->def = fun;
        prepfun->lt = NULL;
        prepfun->next = ctx->prepared_functions;
        ctx->prepared_functions = prepfun;
    }
        
    /* generate small MIL query that calls the function PROC */
    if (fun->mil == NULL) {
        MT_set_lock(pf_cache_lock, "xquery_function_call");
        if (fun->mil == NULL) {
            /* create working set */
            int ret;
  
            src = (char*) PFstartMIL();
            while(*src && cur < end) *cur++ = *src++;

            if (shredBAT) {
                /* add shredded RPC request message to the working set */
                src = (char*) PFdocbatMIL();
                while(*src && cur < end) *cur++ = *src++;
            }

            /* call UDF */
            ret = snprintf(cur, XQUERY_BUFSIZE-(cur-mil), 
                           PFudfMIL(), 
                           fun->proc, 0, 0, 0,0, 0, 0, 0, 0, fun->sig->name, fun->sig->name, 0, 0, 0, 0);
            if (ret > 0) cur += ret;

            /* destroy working set */
            ret = snprintf(cur, XQUERY_BUFSIZE-(cur-mil), PFstopMIL());
            if (ret > 0) cur += ret;

            /* done! execute the script */
            if (cur >= end) {
                return "xquery_function_call: generated MIL query exceeds buffer size.\n";
            }
            *cur = 0;
            fun->mil = GDKstrdup(mil);
        }
        MT_unset_lock(pf_cache_lock, "xquery_function_call");
    }

    /* if no MIL tree is available, create it now */
    if (prepfun->lt == NULL) {
        prepfun->lt = xquery_mil2tree(ctx, fun->mil);
        if (prepfun->lt == NULL) {
            GDKfree(prepfun);
            return "xquery_function_call: error during parsing .\n";
        }
    }

    /* put the actual parameters into the fun_* bats (and *_values containers) */
    @:seqbase(fun_vid000, oid_nil, "oid(nil)")@
    @:seqbase(fun_iter000, oid_nil, "oid(nil)")@
    @:seqbase(fun_kind000, oid_nil, "oid(nil)")@
    @:seqbase(fun_item000, oid_nil, "oid(nil)")@
    @:seqbase(loop000, oid_nil, "oid(nil)")@

    for(l=j=0; j<itercnt; j++) {
        for(i=0; i<argc; i++) {
            oid item, vid = i + fun->vid, iter = j+1;
            if (i == 0 && j > 0) {
                @:bunappend(loop000, &iter, (size_t) *(oid*), SZFMT, "@0")@
            }
            for(k=0; k<argcnt[j][i]; k++,l++) {
                int t = xquery_typenr(argtpe[l]);
                char c;

                /* 'hack': perform simple atomic casts using Monet's ATOMfromstr */
                if (fun->sig->tpe[i] < XQUERY_ABSTRACT)
                    t = fun->sig->tpe[i]; /* just parse the value string as if it was from the desired type */ 
                /* it is doubtful how well pathfinder supports other
                 * casts and what we should do here in those cases.
                 */
                c = xquery_types[t].name[3];

                if (ATOMfromstr(xquery_types[t].monet_tpe, &ctx->val, &ctx->vallen, argval[l]) <= 0)
                    return "xquery_function_call: illegal parameter value.\n";

                @:bunappend(fun_vid000, &vid, (size_t) *(oid*), SZFMT, "@0")@
                @:bunappend(fun_iter000, &iter, (size_t) *(oid*), SZFMT, "@0")@
                @:bunappend(fun_kind000, &xquery_types[t].kind, *(int*), "%d")@
                if (c == 'i') { /* xs:integer */
                    @:bunappend(int_values, ctx->val, *(lng*), LLFMT, "LL")@
                    item = *(oid*) BUNhead(ctx->int_values, BUNfnd(BATmirror(ctx->int_values), ctx->val));
                    @:bunappend(fun_item000, &item, (size_t) *(oid*), SZFMT, "@0")@
                } else if (c == 'd') { /* xs:double or xs:decimal */
                    @:bunappend(dbl_values, ctx->val, *(dbl*), "%g")@
                    item = *(oid*) BUNhead(ctx->dbl_values, BUNfnd(BATmirror(ctx->dbl_values), ctx->val));
                    @:bunappend(fun_item000, &item , (size_t) *(oid*), SZFMT, "@0")@
                } else if (c == 's') { /* xs:string */
                    @:bunappend(str_values, ctx->val, (str), "\"%s\"")@
                    item = *(oid*) BUNhead(ctx->str_values, BUNfnd(BATmirror(ctx->str_values), ctx->val));
                    @:bunappend(fun_item000, &item, (size_t) *(oid*), SZFMT, "@0")@
                } else if (shredBAT == NULL) { 
                    return "xquery_function_call: node parameter without shredBAT.\n";
                } else {
                    @:bunappend(fun_item000, ctx->val, (size_t) *(oid*), SZFMT, "@0")@
                }
            }
        }
    }
    @:seqbase(loop000, 0, "0@0")@
    @:seqbase(fun_vid000, 0, "0@0")@
    @:seqbase(fun_iter000, 0, "0@0")@
    @:seqbase(fun_kind000, 0, "0@0")@
    @:seqbase(fun_item000, 0, "0@0")@

    /* for debugging purposes, we simulate a full MIL on the log; even if parts are cached */
    if (debug) { 
        /* MIL corresponding to BUNins calls we made from C */
        stream_write(ctx->fderr, mil, strlen(mil), 1);
        /* MIL corresponding to UDF call sequence (even if we already have it cached) */
        stream_write(ctx->fderr, fun->mil, strlen(fun->mil), 1);
    }

    /* set the MIL shredBAT and getType variables to the actual values */
    ctx->shredBAT[0] = shredBAT?shredBAT->batCacheid:0;
    if (*(ctx->genType) == NULL || strcmp(*(ctx->genType), mode)) { 
        if (*(ctx->genType)) GDKfree(*(ctx->genType));
        *(ctx->genType) = GDKstrdup(mode);
    }

    *(ctx->time_compile) = GDKms() - msec;
    
    /* Done preparing the query. Time to (re-)execute the MIL tree */
    prepfun->lru = xquery_lru++;
    if (xquery_tree_exec(ctx, prepfun->lt, 1)) {
        if (strstr(mode, "rpcservertime") != NULL) {
           printf("\nServer_Application: %d msec\n", (*ctx->time_compile + *ctx->time_exec) );
           printf("\tTrans: %d msec\n", (*ctx->time_compile) );
           printf("\tShred: %d msec\n", (*ctx->time_shred) );
           printf("\tQuery: %d msec\n", (*ctx->time_exec - *ctx->time_shred) );
           printf("Server_Serialisation + Network_Server_2_Client: %d msec\n", (*ctx->time_print) );
        }

        size_t dummy;
        if (fun->size == 0)
            fun->size = Myysize(prepfun->lt, &dummy);

        /* keep the prepared function cache within a certain size */
        ctx->cachesize += fun->size;
        while (ctx->cachesize > xquery_client_bytes) {
             xquery_prepared_function *kill=NULL,*cur;
             unsigned int lru = xquery_lru;
             for(cur=ctx->prepared_functions; cur; cur=cur->next)
                 if (cur->lt && cur->lru < lru) { kill = cur; lru = cur->lru; }
             if (kill) {
                 Myyfree(kill->lt);
                 kill->lt = NULL;
                 ctx->cachesize -= kill->def->size; 
             }
        }

        return NULL;
    }
    return xquery_function_error;
}


/*
 * =================== module admin ================================
 *
 * void
 * xquery_module_free(xquery_module *mod)
 * - free module structure 
 *
 * xquery_module* 
 * xquery_module_compile(xquery_client *ctx, char* mode, char *url)
 * - get an xquery module, compile it and cache it (return NULL on error)
 *
 * char*
 * xquery_module_load(xquery_client *ctx, char* mode, char *ns, char *url)
 * - check whether we already loaded the module, or if we already 
 *   have it cached. If not, fetch&compile. Returns error string or NULL if ok.
 */

/* 
 * free module structure 
 */
static void 
xquery_module_free(xquery_module *mod) 
{
    xquery_function *fun = mod->functions;
    while(fun) {
        xquery_function *del = fun;
        fun = fun->next;
        if (del->mil) GDKfree(del->mil);
        GDKfree(del);
    }
    if (mod->epilogue) free(mod->epilogue);
    if (mod->prologue) free(mod->prologue);
    GDKfree(mod);
}

/*
 * get an xquery module, compile it and cache it (return NULL on error)
 */
xquery_module*
xquery_module_compile(xquery_client *ctx, 
                      char* mode, 
                      char *url) 
{
    xquery_module *mod = NULL;
    BAT *b = ctx->proc_vid;
    int xx = BUNsize(b);
    int cnt = BUNindex(b, BUNlast(b));
    int ret, url_len = strlen(url)+1;
    BUN p, q;

    mod = GDKmalloc(sizeof(xquery_module)+url_len+1024);
    if (mod == NULL) return NULL;
    memset(mod, 0, sizeof(xquery_module)+url_len+1024);
    strcpy(mod->url, url);
    mod->nsurl = mod->url + url_len;

    ret = xquery_compile_exec(ctx, mode, url, 1, &mod->prologue, NULL, &mod->epilogue, NULL);
    if (!ret) {
        xquery_module_free(mod);
        return NULL;
    } 
    if (ret == 2) mod->nsurl = NULL; /* for MIL modules (ret == 2), mod->nsurl == NULL (we don't know it :-( )*/

    for(p = BUNptr(b,cnt), q = BUNlast(b); p < q; p += xx) {
        char *proc = (char*) BUNhead(b,p);
        xquery_function *fun = (xquery_function*) GDKmalloc(sizeof(xquery_function)+strlen(proc));
        if (fun == NULL) {
            xquery_module_free(mod);
            return NULL;
        }
        strcpy(fun->proc, proc);
        fun->vid = *(lng*) BUNtail(b,p);
        fun->sig = xquery_sig_init(fun->proc);
        fun->mil = NULL;
        fun->size = 0;
        if (fun->sig == NULL) {
            GDKfree(fun);
        } else {
            fun->next = mod->functions;
            mod->functions = fun;
        }
    }
    mod->next = xquery_compiled_modules;
    xquery_compiled_modules = mod;
    return mod;
}

/*
 * check whether we already loaded the module, or if we already have it cached. 
 * If not, fetch&compile. Returns error string or NULL if ok.
 */
static char* 
xquery_module_load(xquery_client *ctx, 
                   char* mode, 
                   char *ns, 
                   char *module,
                   char *url) 
{
    xquery_loaded_module *mod, *prev = NULL;
    int nslen = strlen(ns);

    /* check whether it was already loaded in this query */
    for(mod = ctx->loaded_modules; mod; prev = mod, mod = mod->next) {
        if (strcmp(mod->def->url, url) == 0) {
            if (mod->nslen == 0) {
                if (prev) prev->next = mod->next;
                else ctx->loaded_modules = NULL;
                break; /* put module at front of list */
            }
            if (mod->def->nsurl && module && strcmp(mod->def->nsurl, module)) 
                return "xquery_module_load: import module statement does not match module namespace declaration.\n";
        }
    }
    if (mod == NULL) {
        xquery_module *def;
        mod = (xquery_loaded_module*) GDKmalloc(sizeof(xquery_loaded_module));
        if (mod == NULL) 
            return "xquery_module_load: could not allocate.\n";
        mod->def = NULL;

        MT_set_lock(pf_module_lock, "xquery_module_load");
        for(def = xquery_compiled_modules; def; def = def->next) 
            if (strcmp(def->url, url) == 0) break;

        if (def == NULL){
            mod->def = xquery_module_compile(ctx, mode, url);
        }
        MT_unset_lock(pf_module_lock, "xquery_module_load");

        /* if a compiled module was found, we still need to execute it */
        if (def && xquery_mil_exec(ctx, def->prologue, strstr(mode, "debug") != NULL))
            mod->def = def; /* TODO: find a way to share PROC defs between MIL sessions */

        if (mod->def == NULL) {
            GDKfree(mod);
            return "xquery_module_load: could not load module.\n";
        }
        ctx->var_usage_size = BATcount(ctx->var_usage);
        ctx->proc_vid_size = BATcount(ctx->proc_vid);
    } else if (strstr(mode,"debug") != NULL) {
        stream_write(ctx->fderr, mod->def->prologue, strlen(mod->def->prologue), 1);
    }
    mod->ns = ns;
    mod->nslen = nslen;
    mod->next = ctx->loaded_modules;
    ctx->loaded_modules = mod;

    if (mod->def->nsurl && module && strcmp(mod->def->nsurl, module)) 
        return "xquery_module_load: import module statement does not match module namespace declaration.\n";
    return NULL;
}

/*
 * wait for all queries to finish; free all clients; clear PF url cache
 * freeing the cached YYTREEs in the xquery clients is done lazily 
 * (postponed to the next initialization of the record)
 */
static void
xquery_client_flushall()
{
    int i, wait = 100;
    while(wait) {
        MT_set_lock(pf_cache_lock, "xquery_client_flushall");
        i = active_clients("xquery");
        if (i == 0) {
            /* ok, no xquery clients are active */
            xquery_module *mod = xquery_compiled_modules;
            while(mod) {
                xquery_module *del = mod;
                mod = mod->next;
                xquery_module_free(del);
            }
            xquery_compiled_modules = NULL;
            PFurlcache_flush();
            wait = 0;
        }
        MT_unset_lock(pf_cache_lock, "xquery_client_flushall");
        MT_sleep_ms(wait);
    }
}

/*
 * flush the cache. 
 */
int
CMDxquery_start_query_cache(lng *maxsize)
{
    xquery_client_flushall();
    if (*maxsize > 0) xquery_client_bytes = *maxsize;
    xquery_cacheid++; /* old clients need to clean up their resources */
    return GDK_SUCCEED;
}


/*
 * =================== client session management ================================
 *
 * xquery_client *
 * xquery_client_alloc(mapi_client *fc);
 * - allocate a new xquery client, returns error message (NULL on success)
 *
 * char*
 * xquery_client_init(mapi_client *fc);
 * - initialize a new xquery cache context, returns error string (NULL if ok)
 *
 * void
 * xquery_client_free(mapi_client *fc);
 * - free a xquery cache context (terminate)
 *
 * void
 * xquery_client_end(xquery_client *ctx, char *err);
 * - end of xquery execution (struct stays alive for reuse). 
 */

@= find_var
    v = VARfind(&ctx->stk, "@1");
    if (v == NULL) 
        return "xquery_client_alloc_: failed to lookup @1 variable.\n"; 
    if (v->binding.vtype != TYPE_@2) 
        return "xquery_client_alloc_: @1 variable has wrong type != int.\n"; 
    ctx->@1 = &v->binding.val.@3; 

@= find_bat
{   Variable v = VARfind(&ctx->stk, "@1");
    ctx->@1 =  NULL;
    if (v && v->binding.vtype == TYPE_bat)
        ctx->@1 = BATdescriptor(v->binding.val.bval);
    if (ctx->@1 == NULL) return "xquery_client_alloc: failed to lookup @1 variable.\n"; }
@c

static xquery_client*
xquery_client_new(Cntxt stk) {
    xquery_client *ctx = (xquery_client*)GDKmalloc(sizeof(xquery_client));

    memset(ctx, 0, sizeof(xquery_client));
    ctx->stk = stk; 
    ctx->fderr = GDKerr;
    return ctx; 
}

static char *
xquery_client_alloc_(xquery_client *ctx)
{
    Variable v;

    if (!xquery_mil_exec(ctx, (char*) PFinitMIL(), 0))
        return "xquery_client_alloc: failed to execute init script.\n"; 

    @:find_var(shredBAT,int,ival)@
    @:find_var(genType,str,sval)@
    @:find_var(time_compile,int,ival)@
    @:find_var(time_exec,int,ival)@
    @:find_var(time_print,int,ival)@
    @:find_var(time_shred,int,ival)@

    @:find_bat(proc_vid)@
    @:find_bat(var_usage)@
    @:find_bat(dbl_values)@
    @:find_bat(int_values)@
    @:find_bat(str_values)@
    @:find_bat(fun_vid000)@
    @:find_bat(fun_iter000)@
    @:find_bat(fun_item000)@
    @:find_bat(fun_kind000)@
    @:find_bat(loop000)@

    ctx->var_usage_size = BATcount(ctx->var_usage);
    ctx->proc_vid_size = BATcount(ctx->proc_vid);
    ctx->cachesize = 0;
    ctx->loaded_modules = NULL;
    ctx->prepared_functions = NULL;
    ctx->buflen = XQUERY_BUFSIZE;
    ctx->cacheid = xquery_cacheid;
    ctx->buf = GDKmalloc(ctx->buflen+1);
    ctx->val = GDKmalloc(ctx->vallen = 128);
    if (ctx->val == NULL || ctx->buf == NULL) {
            if (ctx->buf) GDKfree(ctx->buf);
            if (ctx->val) GDKfree(ctx->val);
            ctx->buflen = 0;
            return "xquery_client_alloc: failed to allocate.\n";
    }
    ctx->repeat_stk = CNTXTnew(ctx->stk);
    ctx->initialized = 0;
    CNTXTuse(ctx->repeat_stk);
    monet_cntxt[ctx->repeat_stk].reuse = TRUE;

    return NULL;
}

/* 
 * allocate a new xquery client, returns client cntxt (0 on error)
 */
static char* 
xquery_client_alloc(mapi_client *fc)
{
    xquery_client *ctx = xquery_client_new(fc->stk);

    fc->fc = ctx;
    if (!ctx) {
        return "!ERROR: no space to allocate xquery client\n";
    } else {
        return xquery_client_alloc_(ctx);
    }
}

/*
 * initialize a new xquery cache context, returns error string (NULL if ok)
 */ 
static char *
xquery_client_init_(xquery_client *ctx )
{
    if (!ctx->initialized) {
        ctx->initialized = 1;
        if (!xquery_mil_exec(ctx, (char*) PFvarMIL(), 0))
            return "xquery_client_init: failed to execute variable declarations.\n"; 
    }
    return NULL;
}

/*
 * free all cached subtrees and all proc definitions for all xquery modules
 * (the epilogue contains UNDEF procs) 
 */ 
void
xquery_client_free_cached_modules(xquery_client *ctx)
{
    xquery_prepared_function *fun= ctx->prepared_functions; 
    xquery_loaded_module *mod= ctx->loaded_modules; 

    while(fun) {
        xquery_prepared_function *del = fun;
        fun = fun->next;
        if (del->lt) Myyfree(del->lt);
        GDKfree(del);
    }
    while(mod) {
        xquery_loaded_module *del = mod;
        mod = mod->next;
        /* free all modules */
        if (del->def->epilogue && !xquery_mil_exec(ctx, del->def->epilogue, 0))
            fprintf(stderr, "xquery_client_free: client %d error dropping %s\n", ctx->stk, del->def->url);
        GDKfree(mod);
    }
    ctx->loaded_modules = NULL;
    ctx->prepared_functions = NULL;

    /* free the query buffer */
    if (ctx->buf) GDKfree(ctx->buf);
    ctx->buf = NULL;
    ctx->buflen = 0;
}

static char* 
xquery_client_init(mapi_client *fc) 
{ 
    xquery_client *ctx = fc->fc;
    char* err = xquery_client_init_(ctx);

    ctx->fderr = fc->c->fdout;

    if (!err && ctx->cacheid != xquery_cacheid) {
        xquery_client_free_cached_modules(ctx);

        ctx->buflen = XQUERY_BUFSIZE;
        ctx->cacheid = xquery_cacheid;
        ctx->buf = GDKmalloc(ctx->buflen+1);
        if (ctx->buf == NULL) {
            if (ctx->buf) GDKfree(ctx->buf);
            ctx->buflen = 0;
            err = "xquery_client_init: failed to allocate.\n";
        }
    }
    if (err)
        fprintf(stderr, "xquery_client_init: client %d %s\n", fc->stk, err);
    return err;
}


@= unfix
    if (ctx->@1) BBPunfix(ctx->@1->batCacheid);
    ctx->@1 = NULL;
@c
/* 
 * free a xquery cache context (terminate).
 */
static void
xquery_client_free_(xquery_client *ctx)
{
    xquery_client_free_cached_modules(ctx);

    ctx->shredBAT = NULL;

    /* free the value buffer */
    if (ctx->val) GDKfree(ctx->val);
    ctx->val = NULL;
    ctx->vallen = 0;
    
    /* unfix the BAT handles */
    @:unfix(int_values)@
    @:unfix(dbl_values)@
    @:unfix(str_values)@
    @:unfix(fun_vid000)@
    @:unfix(fun_iter000)@
    @:unfix(fun_item000)@
    @:unfix(fun_kind000)@
    @:unfix(loop000)@

    /* close the MIL client session */
    monet_cntxt[ctx->repeat_stk].reuse = FALSE;
    CNTXTclear(ctx->repeat_stk);
    CNTXTfree1(ctx->repeat_stk);
    CNTXTdelete(ctx->repeat_stk);
}

static void 
xquery_client_free(mapi_client *fc) 
{
    xquery_client_free_(fc->fc);
}

/* 
 * end of xquery execution (struct stays alive for reuse).
 */
static void 
xquery_client_end(xquery_client *ctx, char *err) 
{
    oid zero = 0, one = 1;

    /* undo any inserts by the query into the var_usage bats */
    size_t delta_var_usage = BATcount(ctx->var_usage) - ctx->var_usage_size;
    size_t delta_proc_vid = BATcount(ctx->proc_vid) - ctx->proc_vid_size;
    BATsetcount(ctx->var_usage, ctx->var_usage_size);
    ctx->var_usage->batBuns->free -= delta_var_usage*BUNsize(ctx->var_usage);
    BATsetcount(ctx->proc_vid, ctx->proc_vid_size);
    ctx->proc_vid->batBuns->free -= delta_proc_vid*BUNsize(ctx->proc_vid);

    /* empty all bats (static variables) */
    BATclear(ctx->loop000);
    BUNins(ctx->loop000, &zero, &one, FALSE);

    BATclear(ctx->fun_vid000);
    BATclear(ctx->fun_iter000);
    BATclear(ctx->fun_kind000);
    BATclear(ctx->fun_item000);
    BATclear(ctx->dbl_values);
    BATclear(ctx->int_values);
    BATclear(ctx->str_values);
    BUNappend(ctx->str_values, (ptr)str_nil, FALSE);
    *ctx->shredBAT = int_nil; 

    MT_set_lock(pf_cache_lock, "xquery_client_end");
    /* only deactivate the loaded modules */
    xquery_loaded_module *mod= ctx->loaded_modules; 
    while(mod) {
            mod->nslen = 0;
            mod->ns = NULL; 
            mod = mod->next;
    }
    MT_unset_lock(pf_cache_lock, "xquery_client_end");

    if (err) 
        fprintf(stderr, "xquery_server: client %d %s\n", ctx->stk, err);
}


/*
 * ========== parse xquery to identify 'import module's and function calls ==========
 *
 * char*
 * xquery_parse_ident(char* p) 
 * - parse an identifier; accept any UTF-8 characters in it (is that correct?)
 *
 * char*
 * xquery_parse_comment(char* p)
 * - parse an xquery (: .. :)  comment. Note it may be nested.
 *
 * char*
 * xquery_parse_space(char* p)
 * - parse xquery space, which may include comments 
 *
 * char*
 * xquery_parse_string(char* p, char *buf, int len)
 * - parse an XML datamodel string. Deliver an unescaped version as a result 
 *
 * char*
 * xquery_parse_numeric(char* p, char **tpe)
 * - parse an XML datamodel numeric, and determine its minimal type (xs:integer, xs:decimal or xs:double) 
 *
 * all above functions return the new pointer in the xquery after parsing.
 *
 * char*
 * xquery_prepare(xquery_client *ctx, int msec, char* mode, char* xquery)
 * - parse xquery; chop off module imports, and recognize single method calls. These are re-executed
 *   from a cached MIL tree. Otherwise use pathfinder to compile. Returns error string (NULL if ok).
 */

/* 
 * parse an identifier; accept any UTF-8 characters in it (is that correct?)
 */
static char* 
xquery_parse_ident(char* p) 
{
    if ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || *(unsigned char*) p >= 128) {
        p++;
        while((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*(unsigned char*) p >= 128) ||
              (*p == '_') || (*p == '.') || (*p == '-') || (*p >= '0' && *p <= '9')) p++;
    }
    return p;
}

/* 
 * parse an xquery (: .. :)  comment. Note it may be nested.
 */
static char* 
xquery_parse_comment(char* p) 
{
    int nesting;
    for(nesting=1; *p; p++) {
        if (p[0] == ':' && p[1] == ')' && --nesting == 0) return p+2;
        if (p[0] == '(' && *(++p) == ':') nesting++;
    }
    return p;
}

/* 
 * parse xquery space, which may include comments 
 */
#define ISSPACE(c) ((c) == ' ' || (c) == '\t' || (c) == 10 || (c) == 13) 
static char* 
xquery_parse_space(char* p) 
{
    while(*p) {
        while(ISSPACE(*p)) p++;
        if (p[0] != '(' || p[1] != ':') break; 
        p = xquery_parse_comment(p+2);
    }
    return p;
}

/* 
 * parse an XML datamodel string. Deliver an unescaped version as a result 
 */
static char* 
xquery_parse_string(char* p, 
                    char *buf, 
                    int len) 
{
    char *q = buf, *r = buf+len-1;
    int sep1 = *p++;
    int sep2 = (sep1=='"')?'\'':'"';
    int escape = 0;
    while(*p) {
        if (escape) {
            if (p[0] == sep2) escape = 0;
            if (q < r) *q++ = *p; p++;
        } else {
            if (p[0] == sep1) {
                p++; break;
            } else if (p[0] == sep2) {
                if (p[1] == sep1 && p[2] == sep1 && p[3] == sep2) {
                    if (q < r) *q++ = sep1; p += 4;
                } else {
                    if (q < r) *q++ = *p; p++;
                    escape = 1;
                }
            } else if (p[0] == '&') {
                if (p[1] == '#' && p[2] == 'x') {
                    unsigned long v = 0; 
                    for(p+=3; *p; p++) {
                        if (*p >= '0' && *p <= '9') {
                            v = (v << 4) + (*p - '0');
                        } else if (*p >= 'a' && *p <= 'f') {
                            v = (v << 4) + (*p - 'a');
                        } else if (*p >= 'A' && *p <= 'F') {
                            v = (v << 4) + (*p - 'A');
                        } else {
                            break;
                        }
                    }
                    if (q < r) *q++ = (char) v;
                } else if (p[1] == '#') {
                    unsigned long v = 0; 
                    for(p+=2; *p; p++) {
                        if (*p >= '0' && *p <= '9') {
                            v = (v * 10) + (*p - '0');
                        } else {
                            break;
                        }
                    }
                    if (q < r) *q++ = (char) v;
                } else if (p[1] == 'l' && p[2] == 't' && p[3] == ';') {
                    if (q < r) *q++ = '<'; p += 4;
                } else if (p[1] == 'g' && p[2] == 't' && p[3] == ';') {
                    if (q < r) *q++ = '<'; p += 4;
                } else if (p[1] == 'a' && p[2] == 'm' && p[3] == 'p' && p[4] == ';') {
                    if (q < r) *q++ = '&'; p += 5;
                } else if (p[1] == 'q' && p[2] == 'u' && p[3] == 'o' && p[4] == 't' && p[5] == ';') {
                    if (q < r) *q++ = '"'; p += 6;
                } else if (p[1] == 'a' && p[2] == 'p' && p[3] == 'o' && p[4] == 's' && p[5] == ';') {
                    if (q < r) *q++ = '\''; p += 6;
                }
            } else {
                if (q < r) *q++ = *p; p++;
            }
        }
    }
    *q = 0;
    return p;
}

/* 
 * parse an XML datamodel numeric, and determine its minimal type (xs:integer, xs:decimal or xs:double) 
 */
static char* 
xquery_parse_numeric(char* p, 
                     char **tpe) 
{
    *tpe = "xs:integer";
    if (p[0] == '-' || p[0] == '+') p++;
    while(p[0] >= '0' && p[0] <= '9') p++;
    if (p[0] == '.' && (p[1] >= '0' && p[1] <= '9')) {
        p++;
        while(p[0] >= '0' && p[0] <= '9') p++;
        *tpe = "xs:decimal";
    }
    if (p[0] == 'e' || p[0] == 'E') {
        char *q = p+1;
        if (q[0] == '-' || q[0] == '+') q++;
        if (q[0] >= '0' && q[0] <= '9') {
           while(q[0] >= '0' && q[0] <= '9') q++;
           p = q;
           *tpe = "xs:double";
        }
    }
    return p;
}

/* 
 * parse xquery; chop off module imports, and recognize single method calls. These are re-executed
 * from a cached MIL tree. Otherwise use pathfinder to compile. Returns error string (NULL if ok).
 */
static char*
xquery_prepare(xquery_client *ctx, 
               int msec, 
               char* mode, 
               char* query) 
{
    int nsbuf = 0, loaded_modules = 0, len;
    char *ns = (char*)&nsbuf, *nsend = ns, *locend, *loc = NULL, *p = query;
    char val[256], url1[256], url2[256];
    char *err = NULL;

    if (strstr(mode,"debug") != NULL) {
        /* for debugging purposes, we simulate a full MIL on the log; even if parts are cached */
        char *prologue = (char*) PFinitMIL();
        stream_write(ctx->fderr, prologue, strlen(prologue), 1);
        prologue = (char*) PFvarMIL();
        stream_write(ctx->fderr, prologue, strlen(prologue), 1);
    }
    while(*p && err == NULL) {
        p = xquery_parse_space(p);
        if (strncmp(p, "import", 6) || !ISSPACE(p[6])) {
            break;
        } else {
            /* e.g. import module namespace xmark = "/cygwin/tmp/" at "/cygwin/tmp/mod1.xq";
             * or:  import rpc-module namespace xmark = "/cygwin/tmp/" at "/cygwin/tmp/mod1.xq"; */ 
            p = xquery_parse_space(p+6);
            if ( (strncmp(p, "module", 6) == 0 && ISSPACE(p[6])) ||
                 (strncmp(p, "rpc-module", 10) == 0 && ISSPACE(p[10])) ){
                len = p[0] == 'm' ? 6 : 10;
                p = xquery_parse_space(p+len);
                if (strncmp(p, "namespace", 9) == 0 && ISSPACE(p[9])) {
                    ns = xquery_parse_space(p+9);
                    nsend = xquery_parse_ident(ns);
                    p = xquery_parse_space(nsend);
                    if (*p == '=') {
                        p = xquery_parse_space(p+1);
                    } else {
                        return "xquery_prepare: expecting '=' after namespace declaration";
                    }
                }
                p = xquery_parse_string(p, url1, 256);
                p = xquery_parse_space(p);
                if (*p == 'a' && *(++p) == 't' && ISSPACE(p[1])) do {
                    char bak = *nsend;
                    loc = xquery_parse_space(p+1);
                    locend = xquery_parse_string(loc, url2, 256);
                    p = xquery_parse_space(locend);

                    /* cut off module import from the query, and load it here (to have it cached later) */
                    *nsend = 0;

                    err = xquery_module_load(ctx, mode, ns, url1, url2);
                    if (err) return err;
                    *nsend = bak; 
                } while (*p == ',');
            }
            if (*p != ';') {
                return "xquery_prepare: missing ';' after module import.\n";
            } else {
                loaded_modules++;
                p++;
            }
        }
    }

    if (loaded_modules == 0) {
        err = (char*) -1; /* no module loaded: query not recognized as a function call */
    } else {
        /* detect queries that consist of a single method call only */
        nsend = ns = (char*) &nsbuf; 
        loc = p; 
        locend = xquery_parse_ident(loc);
        p = xquery_parse_space(locend);
        if (*p == ':') {
            ns = loc; nsend = locend; 
            loc = ++p; 
            locend = xquery_parse_ident(p);
            p = xquery_parse_space(locend);
        }
        if (*p != '(' || ((locend-loc) == 2 && loc[0] == 'i' && loc[1] == 'f')) {
            err = (char*) -1; /* query not recognized as a function call */
        } else {
            int cnt[MAXPARAMS];
            char* tpe[MAXPARAMS];
            char* param[MAXPARAMS];
            int argc = 0;
    
            /* e.g. ns:function(1,2,3) */
            p = xquery_parse_space(p+1);
            if (*p == ')') {
               p++;
            } else do {
                param[argc] = p;
                tpe[argc] = "xs:string";
                cnt[argc] = 1;
                if (*param[argc] == '"' || *param[argc] == '\'') {
                    p = xquery_parse_string(param[argc], val, 256);
                    if (p <= param[argc]) {
                        err = "xquery_prepare: could not parse string literal.\n";
                        break;
                    }
                } else if (*p == '-' || *p == '+' || *p == '.' || (*p >= '0' && *p <= '9')) {
                    p = xquery_parse_numeric(param[argc], tpe+argc);
                    if (p <= param[argc]) {
                        err = "xquery_prepare: could not parse numeric literal.\n";
                        break;
                    }
                } else {
                    /* complex parameter */
                    err = (char*) -1; /* query not recognized as a simple function call */
                    break;
                }
                if (++argc >= MAXPARAMS) {
                    err = "xquery_prepare: too many parameters.\n";
                    break;
                }
                p = xquery_parse_space(p);
                if (*p == ')') {
                    p++; 
                    break;
                } else if (*p != ',') {
                    err = "xquery_prepare: expecting a ',' between function parameters.\n";
                    break;
                }
                p = xquery_parse_space(p+1);
            } while(*p);
    
            if (err == NULL) {    
                p = xquery_parse_space(p);
                if (*p == '/') {
                    err = (char*) -1;
                } else if (*p) {
                    err = "xquery_prepare: unexpected characters after ';'.\n";
                } else {
                    /* all set: make the call */
                    int* cnt_ptr = cnt;    
                    char nsbak = *nsend, locbak = *locend;
                    *nsend = 0; *locend = 0;
                    err = xquery_function_call(ctx, msec, mode, ns, loc, argc, 1, &cnt_ptr, tpe, param, NULL);
                    *nsend = nsbak; *locend = locbak;
                }
            }
        }
    }
    if (err == xquery_function_error) {
        err = (char*) -1; /* execution error in xquery_function_call */
    } else if (err == (char*) -1) {
        char *sec1 = NULL;
        char *sec2 = NULL;
        char *sec3 = NULL;
        /* compile and execute the query (minus module imports) */
        if (xquery_compile_exec(ctx, mode, query, 0, &sec1, &sec2, &sec3, NULL)) 
                err = NULL; /* in case of execution err, it stays -1 */
        if (sec1) free(sec1);
        if (sec2) free(sec2);
        if (sec3) free(sec3);
    } 
    return err;
}

/*
 * =================== exported functions ================================
 *
 * see MIL module definition (top of file)
 */

@= builtin_operand
{
    int _k = interpret(stk, arg(lt, @1), res);
    if (_k < 0) {
        return _k;
    }
    @3 = VALconvert(@2, res);
    if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
        return handle_paramerror(res,@1,res->vtype,@2);
    }
}
@c

static void
xquery_client_engine(mapi_client *fc )
{
    size_t curlen;
    xquery_client *ctx = fc->fc;
    stream *in = fc->c->fdin, *out = fc->c->fdout;
    char *xquery,  buf[100], *p=buf, *err = (char*) -1;
    int msec;

    while(1) {
        /* use the MAPI protocol to read as much xquery buffer as possible */
        if (!fc->c->blocked && 
                stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) < 0) {
            xquery_client_end(ctx, "could not write prompt"); 
            return;
        }
        if (stream_flush(out)) {
            xquery_client_end(ctx, "could not flush prompt"); 
            return;
        }

        for (p = ctx->buf, curlen = 0; p; ) {
            ssize_t n = stream_read(in, p + curlen, 1, ctx->buflen - curlen);
            if (n < 0) {
                xquery_client_end(ctx, NULL); 
                return;
            }
            if (n == 0)
                break;

            curlen += n;
            if (curlen == ctx->buflen) {
                p = GDKrealloc(ctx->buf, ctx->buflen + 1025);
                if (p) {
                    ctx->buflen += 1024;
                    ctx->buf = p;
                }
            }
        }
        if (curlen == 0)
                break;
        msec = GDKms();
    
        /* execute query */
        if (p) {
            p[curlen] = 0;        /* terminate (we know there is space) */
    
            /* first line of the query is the mode */ 
            for (xquery = p; *xquery; xquery++) {
                if (*xquery == '\n') {
                    *xquery++ = 0;
                    break;
                }
            }
            err = xquery_prepare(ctx, msec, p, xquery);
            if (err && err != (char*) -1) {
                /* report errors back to client */
                stream_write(ctx->fderr, err, strlen(err), 1);
            }
        }
        if (strstr(p, "debug")) {
            /* memory debugging */
            xquery_prepared_function *fun = ctx->prepared_functions;
            BAT *b = NULL;
            view_client_size(&b, &fc->stk);
            if (b) {
               while(fun) {
                   BUNins(b, fun->def->proc, &fun->def->size, FALSE);
                   fun = fun->next;
                } 
                BATprintf(GDKstdout, b);
                BBPreclaim(b);
            } 
        }
        /* second and on queries also need a cleared context */
        xquery_client_end(ctx, NULL); 
    }
    xquery_client_end(ctx, NULL); 
}

int
xquery_frontend( ptr *F)
{
	char *m_clients = GDKgetenv("mapi_clients"); 
	int nr = (m_clients)?strtol(m_clients, NULL, 10):1;
	mapi_frontend *f = (mapi_frontend*)GDKmalloc(sizeof(mapi_frontend));
	*F = f;
	f->name = GDKstrdup("xquery");
	f->cache_limit = nr;
	f->f_alloc = xquery_client_alloc;
	f->f_init  = xquery_client_init;
	f->f_free  = xquery_client_free;
	f->f_engine  = xquery_client_engine; /* read/parse/execute loop */
	return GDK_SUCCEED;
}


/*
 * execute xquery and return the result in a string.
 */
int
CMDxquery(Cntxt stk, 
          YYSTREE lt, 
          ValPtr res)
{
    int msec = GDKms();
    char *mode = "xml", *xquery = NULL, *err = NULL;
    bit no=0, *is_url=&no;
    Client c = NULL;
    xquery_client *ctx;

    /* this is a BUILTIN because we must obtain the client context (and
     * thus the streams) */
    if (lt->cnt > 4)
        return handle_argerror(res, lt->cnt, 3);
    if (lt->cnt == 1) {
        @:builtin_operand(0,TYPE_str,xquery)@
    } else {
        @:builtin_operand(0,TYPE_str,mode)@
        @:builtin_operand(1,TYPE_str,xquery)@
    }
    if (lt->cnt == 3) {
        @:builtin_operand(2,TYPE_bit,is_url)@
    }
    CNTXTclient(stk, &c);
    ctx = xquery_client_new(c->stk);
    ctx->fderr = GDKerr;
    MT_set_lock(pf_cache_lock, "CMDxquery");
    err = xquery_client_alloc_(ctx);
    if (!err)
        err = xquery_client_init_(ctx);
    MT_unset_lock(pf_cache_lock, "CMDxquery");

    if (err == NULL && *is_url == TRUE) { 
        MT_set_lock(pf_compiler_lock, "CMDxquery");
        PFURLCACHE("CMDxquery", xquery, 1);
        MT_unset_lock(pf_compiler_lock, "CMDxquery");
    }

    if (err == NULL) {
        buffer *b = buffer_create(XQUERY_BUFSIZE);
        if (b) {
            stream *s = buffer_wastream(b, "CMDxquery");
            if (s) {
                /* run the query, but collect all output in a buffer */
                stream *bak = GDKout;
                THRsetdata(0,s);
                err = xquery_prepare(ctx, msec, mode, xquery);
                if (err == NULL || err == (char*) -1) {
                    res->val.sval = GDKmalloc(b->pos+1);
                    if (res->val.sval) {
                        memcpy(res->val.sval, b->buf, b->pos);
                        res->val.sval[b->pos] = 0;
                        res->vtype = TYPE_str;
                    } else {
                        err = "CMDxquery: failed to allocate buffer";
                    }
                }
                THRsetdata(0,bak);
                stream_close(s);
            } else {
                err = "CMDxquery: failed to create stream";
            }
            buffer_destroy(b);
            stream_destroy(s);
        } else {
            err = "CMDxquery: failed to allocate streambuffer";
        }
    }
    MT_set_lock(pf_cache_lock, "CMDxquery");
    xquery_client_free_(ctx);
    MT_unset_lock(pf_cache_lock, "CMDxquery");
    if (err) {
	GDKerror((err==(char*)-1)?res->val.sval:err);
	VALclear(res);
        return GDK_FAIL;
    } 
    /* stream_printf(GDKout,"RES = %s\n",res->val.sval); */
    return GDK_SUCCEED;
}

/*
 * call a method in a temporary xquery client context
 */  
char*
xquery_method(stream *out, 
              int rpctiming,
              char* module, 
              char* uri, 
              char *method, 
              int argc, 
              int itercnt, 
              int** argcnt, 
              str* argtpe, 
              str* argval, 
              BAT* shredBAT)
{
    int msec = GDKms();
    MT_Id XQthread_id = THRgettid();
    Thread XQthread = THRget(XQthread_id);
    char *err = NULL, *ns = "fn", *mode = "xml-noheader-typed-root-iter";
    stream *s = NULL;
    mapi_client *mc = MAPIclient(GDKin, out, "xquery" );
    xquery_client *ctx;

    if (mc == NULL) 
        return "xquery_method: out of client slots.\n";

    if (rpctiming){
        mode = "xml-rpcservertime-timing-noheader-typed-root-iter";
    }
    
    ctx = mc->fc; 
    ctx->fderr = GDKerr;
    mc->t = XQthread_id;
    mc->thread = XQthread;
    monetSetChannel(XQthread, GDKin, out);
    if (argc > 1000) {
        /* hack: pass argc+1000 and you get debug output */
        s = open_wstream("/tmp/xquery_rpc.mil");
        char *prologue = (char*) PFinitMIL();
        if (s) {
            ctx->fderr = s;
            if (rpctiming){
                mode = "xml-rpcservertime-timing-debug-noheader-typed-root-iter";
            } else {
                mode = "xml-debug-noheader-typed-root-iter";
            }
        }
        stream_write(ctx->fderr, prologue, strlen(prologue), 1);
        argc = argc % 1000;
    }

    if (err == NULL && module){
        err = xquery_module_load(ctx, mode, ns="xquery_rpc", module, uri); 
    }

    if (err == NULL) { 
        err = xquery_function_call(ctx, msec, mode, ns, method, argc, itercnt, argcnt, argtpe, argval, shredBAT);
        if (err == (char*) -1) err = "xquery_method: function could not be resolved.\n";
    }

    if (s) {
        stream_close(ctx->fderr);
        stream_destroy(ctx->fderr);
    }
    monetSetChannel(XQthread, GDKin, GDKout);

    xquery_client_end(ctx, NULL);
    mc->inuse = 0;
    mc->t = ~(MT_Id)0;
    return err;
}

/*
 * module initialization
 */
extern void xmlInitThreads();
bat *
xquery_prelude()
{
    pf_compiler_lock = MT_create_lock();
    pf_module_lock = MT_create_lock();
    pf_cache_lock = MT_create_lock();

    xmlInitThreads();
   
    xquery_compiled_modules = NULL;
    return NULL;
}

/*
 * module cleanup
 */
void
xquery_epilogue()
{
    xquery_client_flushall();
    MT_destroy_lock(pf_compiler_lock);
    MT_destroy_lock(pf_cache_lock);
}
/* vim:set shiftwidth=4 expandtab: */
