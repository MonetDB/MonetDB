@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2008 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$

@f ll_prec_foll
@a Stefan Manegold, Peter Boncz, Jennie Zhang 
@t ll_prec_foll

@c

/*******************************************
* ll_prec_foll.c : axis step operators for loop-lifted preceding and following axis
*
*/
#include "pf_config.h"
#include <gdk.h>

/**
 * This file contains the axis step algoritms for following and
 * preceding axis.
 * 
 * Both algorithms work similiar to the staircase-join approach:
 * 
 * - evaluation is done during a single sequential scan of the
 *   size table and the context set
 *   (we now use size rather than level to enable skipping)
 * - context set pruning is performed on-the-fly
 * 
 * Unlike the staircasejoins for ancestor and desecendant steps
 * we have to take care about the limitations of document fragments.
 * Nodes on the following axis of x, are all nodes with
 * pre(v) > pre(x) + size(x),
 * but only that nodes qualify, that belong to the same document fragment
 * as x itself.
 */

/* check, if result buffer is big enough; otherwise extend it */
#define PFll_check_BAT_capacity(b,grow,res_scur,res_hcur,res_tcur) \
{\
        size_t _oldcap = BATcapacity(b);\
        size_t _reqcap = BATcount(b) + grow;\
        size_t _bunsize = Hsize(b) + Tsize(b);\
        if (_oldcap < _reqcap) {\
            size_t _newcap = MAX(_reqcap, BATgrows(b));\
            if (BATextend((b), _newcap) == NULL) {\
                GDKerror("%s: BATextend of BAT '%s' (#%d) failed "\
                         "for " SZFMT " buns (" SZFMT " bytes).\n",\
                         __func__, BATgetId(b), (b)->batCacheid,\
                         _newcap, _newcap * _bunsize);\
                BBPreclaim(b);\
                return GDK_FAIL;\
            }\
            _newcap = BATcapacity(b);\
            if (_newcap < _reqcap) {\
                GDKerror("%s: BATextend of BAT '%s' (#%d) failed: "\
                         "required " SZFMT " buns (" SZFMT " bytes), "\
                         "got only " SZFMT " buns (" SZFMT " bytes).\n",\
                         __func__, BATgetId(b), (b)->batCacheid,\
                         _reqcap, _reqcap * _bunsize,\
                         _newcap, _newcap * _bunsize);\
                BBPreclaim(b);\
                return GDK_FAIL;\
            }\
            res_scur = (oid*) Hloc(res, BUNfirst(res));\
            res_hcur = (oid*) Hloc(res, BUNlast(res));\
            res_tcur = (oid*) Tloc(res, BUNlast(res));\
        }\
}

/* FOLLOWING STEP */
int
PFll_following(BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *doc_pre, BAT *pre_size, BAT *pre_kind, chr *_kind_test)
{
    @:init(following)@

@= init
    BATiter iter_bati = bat_iterator(iter_bat), ctx_bati = bat_iterator(ctx_bat);
    BATiter doc_prei = bat_iterator(doc_pre);
    char *name = "PFll_@1";
    BUN p = 0, q = 0;
    int *size = 0;
    chr *kind = 0, kind_test = *_kind_test;

    size_t res_size = 0, grow = 0;
    BAT *res = 0;
    oid *iter_cur = 0, *iter_end = 0, *ctx_cur = 0, *ctx_end = 0;
    oid *res_scur = 0, *res_hcur = 0, *res_tcur = 0;
    bit one_ctx = 0;
    oid min_iter = 0, max_iter = 0, num_iter = 0, ctx_max = 0;

    /* --------------------------- checks ---------------------------------- */

    BATcheck(iter_bat, name);
    BATcheck(ctx_bat, name);
    BATcheck(doc_pre, name);
    BATcheck(pre_size, name);
    BATcheck(pre_kind, name);

    iter_cur = (oid*) BUNtail(iter_bati, BUNfirst(iter_bat)); 
    iter_end = (oid*) BUNtail(iter_bati, BUNlast(iter_bat));

    ctx_cur = (oid*) BUNtail(ctx_bati, BUNfirst(ctx_bat)); 
    ctx_end = (oid*) BUNtail(ctx_bati, BUNlast(ctx_bat));
    ctx_max = *(ctx_end - 1);
    one_ctx = *ctx_cur == ctx_max;

    ALGODEBUG
        THRprintf(GDKout, "%s: |iter_bat|="SZFMT", |ctx_bat|="SZFMT", |doc_pre|="SZFMT", |pre_size|="SZFMT", |pre_kind|="SZFMT", kind_test=%d, one_ctx=%d\n",
                          name, BATcount(iter_bat), BATcount(ctx_bat), BATcount(doc_pre), BATcount(pre_size), BATcount(pre_kind), (int)kind_test, (int)one_ctx);

    if (!(BAThdense(iter_bat) && BAThdense(ctx_bat)))
    {
        GDKerror("%s: both iter_bat and ctx_bat must have a dense head.\n", name);
        return GDK_FAIL;
    }
    if ((iter_bat->hseqbase != ctx_bat->hseqbase) || (BATcount(iter_bat) != BATcount(ctx_bat)))
    {
        GDKerror("%s: iter_bat and ctx_bat must be head-aligned, i.e., have equal head seqbases and length.\n", name);
        return GDK_FAIL;
    }
    if (!(BATtordered(ctx_bat) & 1))
    {
        GDKerror("%s: ctx_bat must be ordered on tail.\n", name);
        return GDK_FAIL;
    }
    if (ctx_bat->ttype == TYPE_void)
    {
        GDKerror("%s: ctx_bat cannot have a void tail.\n", name);
        return GDK_FAIL;
    }
    if (iter_bat->ttype == TYPE_void)
    {
        GDKerror("%s: iter_bat cannot have a void tail.\n", name);
        return GDK_FAIL;
    }
    if (one_ctx && !(BATtordered(iter_bat) & 1))
    {
        GDKerror("%s: iter_bat must be ordered on tail.\n", name);
        return GDK_FAIL;
    }
    if (!(BATtordered(doc_pre) & 1))
    {
        GDKerror("%s: doc_pre must be ordered on tail.\n", name);
        return GDK_FAIL;
    }

    if (!BAThdense(pre_size))
    {
        GDKerror("%s: head of pre_size must be dense.\n", name);
        return GDK_FAIL;
    }
    if (pre_size->ttype != TYPE_int)
    {
        GDKerror("%s: tail of pre_size must be type INT.\n", name);
        return GDK_FAIL;
    }
    if (pre_size->htype != TYPE_void)
    {
        GDKerror("%s: head (oid) of pre_size must NOT be materialized.\n", name);
        return GDK_FAIL;
    }
    if (*ctx_cur < pre_size->hseqbase || ctx_max >= pre_size->hseqbase + BATcount(pre_size))
    {
        GDKerror("%s: context nodes exceed collection range.\n", name);
        return GDK_FAIL;
    }
    size = ((int*) Tloc(pre_size, BUNfirst(pre_size))) - (int)pre_size->hseqbase;

    if (kind_test != chr_nil) {
        if (!BAThdense(pre_kind))
        {
            GDKerror("%s: head of pre_kind must be dense.\n", name);
            return GDK_FAIL;
        }
        if ((pre_size->hseqbase != pre_kind->hseqbase) || (BATcount(pre_size) != BATcount(pre_kind)))
        {
            GDKerror("%s: pre_size and pre_kind must be head-aligned, i.e., have equal head seqbases and length.\n", name);
            return GDK_FAIL;
        }
        if (pre_kind->ttype != TYPE_chr)
        {
            GDKerror("%s: tail of pre_kind must be type CHR.\n", name);
            return GDK_FAIL;
        }
        if (pre_kind->htype != TYPE_void)
        {
            GDKerror("%s: head (oid) of pre_kind must NOT be materialized.\n", name);
            return GDK_FAIL;
        }
        kind = ((chr*) Tloc(pre_kind, BUNfirst(pre_kind))) - (int)pre_kind->hseqbase;
    }

    /* --------------------------- empty result ---------------------------- */

    if (BATcount(ctx_bat) == 0 || BATcount(pre_size) == 0 || BATcount(doc_pre) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_void, 0);
        BATkey (res, TRUE);
        res->hsorted = GDK_SORTED;
        res->hdense = TRUE;
        BATseqbase (res, (oid)0); /* does not really matter */
        BATkey (BATmirror(res), TRUE);
        res->tsorted = TRUE;
        res->tdense = TRUE;
        BATseqbase (BATmirror(res), (oid)0); /* does not really matter */
        BATset(res, TRUE);
        *result = res;
        return GDK_SUCCEED;
    }

    /* --------------------------- analyze iters --------------------------- */

    if (BATtordered(iter_bat) & 1)
    {
        min_iter = *iter_cur;
        max_iter = *(iter_end - 1);
    } else {
        oid *cur_iter = iter_cur;
        min_iter = GDK_oid_max;
        max_iter = GDK_oid_min;
        for (; cur_iter < iter_end; cur_iter++) {
            oid iter = *cur_iter;
            if (iter < min_iter) min_iter = iter;
            if (iter > max_iter) max_iter = iter;
        }
    }
    assert(min_iter <= max_iter);
    num_iter = (max_iter - min_iter) + 1;

    ALGODEBUG
        THRprintf(GDKout, "%s: min_iter="OIDFMT", max_iter="OIDFMT", num_iter="OIDFMT"\n",
                          name, min_iter, max_iter, num_iter);

    /* --- result bat allocation. for result size use res_size parameter --- */

    res_size = num_iter * ((BATcount(pre_size) / 2) / BATcount(doc_pre));
    res = BATnew(TYPE_oid, TYPE_oid, res_size);
    if (res == NULL) 
    { 
        GDKerror("%s: could not allocate a result BAT of size "SZFMT".\n", name, res_size);
        return GDK_FAIL;
    }
    res_scur = res_hcur = (oid*) Hloc(res, BUNlast(res)); 
    res_tcur =            (oid*) Tloc(res, BUNlast(res)); 
@
@c
    /* ------------------------- actual algorithm -------------------------- */

    if (kind_test != chr_nil) {
        @:ll_foll(if (kind[cur_following] == kind_test))@
    } else {
        @:ll_foll()@
    }
    
@= ll_foll
    if (one_ctx) {
        /* 1 ctx, 1/n iter */
        p = SORTfndlast(doc_pre, ctx_cur);
        if (p > BUNfirst(doc_pre)) {
            oid boundary = *(oid*) BUNtail(doc_prei, p - 1);
            oid cur_following = *ctx_cur + size[*ctx_cur] + 1;

            /* now, everything until the end of the fragment is a following node */
            boundary += size[boundary] + 1;
            if (cur_following < boundary) {
                /* check, if result buffer is big enough; otherwise extend it */
                grow = num_iter * (boundary - cur_following);
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                if (num_iter == 1) {
                    ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, 1 iter\n", name);
                    while(cur_following < boundary) {
                        int sz = size[cur_following];
                        if (sz >= 0) {
                            @1 {
                                *res_hcur++ = min_iter;
                                *res_tcur++ = cur_following;
                            }
                            cur_following++;
                        } else { 
                            /* this node has been deleted! skip the hole */
                            cur_following += 1 + (sz & ~(1<<31)); 
                        }
                    }
                } else {
                    /* num_iter > 1 */
                    if (iter_bat->tkey) {
                        ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, n iter (key)\n", name);
                        while(cur_following < boundary) {
                            int sz = size[cur_following];
                            if (sz >= 0) {
                                @1 {
                                    oid *cur_iter = iter_cur;
                                    for (; cur_iter < iter_end; cur_iter++) {
                                        *res_hcur++ = *cur_iter;
                                        *res_tcur++ = cur_following;
                                    }
                                }
                                cur_following++;
                            } else { 
                                /* this node has been deleted! skip the hole */
                                cur_following += 1 + (sz & ~(1<<31)); 
                            }
                        }
                    } else {
                        /* !iter_bat->tkey */
                        ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, n iter\n", name);
                        while(cur_following < boundary) {
                            int sz = size[cur_following];
                            if (sz >= 0) {
                                @1 {
                                    oid *cur_iter = iter_cur;
                                    oid prev_iter = oid_nil;
                                    for (; cur_iter < iter_end; cur_iter++) {
                                        if (*cur_iter != prev_iter) {
                                            *res_hcur++ = *cur_iter;
                                            *res_tcur++ = cur_following;
                                            prev_iter = *cur_iter;
                                        }
                                    }
                                }
                                cur_following++;
                            } else { 
                                /* this node has been deleted! skip the hole */
                                cur_following += 1 + (sz & ~(1<<31)); 
                            }
                        }
                    }
                }
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
    } else
    if (num_iter == 1) {
        /* n ctx, 1 iter */
        ALGODEBUG THRprintf(GDKout, "%s: n ctx, 1 iter\n", name);
        BATloop(doc_pre, p, q) {
            oid boundary = *(oid*) BUNtail(doc_prei,p);
            oid cur_following = boundary += size[boundary] + 1;

            /* within the fragment (boundary), go over all context nodes */
            while(ctx_cur < ctx_end && *ctx_cur < cur_following /*<= boundary*/) { 
                /* new following is the first following node of the current context node */
                oid new_following = *ctx_cur + size[*ctx_cur] + 1;

                if (new_following < cur_following) {
                    cur_following = new_following; /* keep setting cur_following back */
                }
                ctx_cur++;
            }
            while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
                ctx_cur++; /* advance ctx pointer after breaking out early */
            }
            if (cur_following < boundary) {
                /* now, everything until the end of the fragment is a following node */
                /* check, if result buffer is big enough; otherwise extend it */
                grow = boundary - cur_following;
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                while(cur_following < boundary) {
                    int sz = size[cur_following];
                    if (sz >= 0) {
                        @1 {
                            *res_hcur++ = min_iter;
                            *res_tcur++ = cur_following;
                        }
                        cur_following++;
                    } else { 
                        /* this node has been deleted! skip the hole */
                        cur_following += 1 + (sz & ~(1<<31)); 
                    }
                }
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
    } else
    {
        /* n ctx, n iter */
        ALGODEBUG THRprintf(GDKout, "%s: n ctx, n iter\n", name);
        oid *min_following = (oid*) GDKmalloc(num_iter * sizeof(oid));
        if (min_following == NULL) 
        { 
            GDKerror("%s: could not allocate a stack of size "SZFMT".\n", name, (size_t)num_iter * sizeof(oid));
            BBPreclaim(res);
            return GDK_FAIL;
        }
        BATloop(doc_pre, p, q) {
            oid iter = 0, fst_iter = num_iter, lst_iter = 0;
            oid boundary = *(oid*) BUNtail(doc_prei,p);
            oid cur_following = boundary += size[boundary] + 1;
            for (; iter < num_iter; iter++) {
                min_following[iter] = cur_following;
            }

            /* within the fragment (boundary), go over all context nodes */
            while(ctx_cur < ctx_end && *ctx_cur < /*cur_following <=*/ boundary) { 
                /* new following is the first following node of the current context node */
                oid new_following = *ctx_cur + size[*ctx_cur] + 1;
                oid prev_ctx = *ctx_cur;

                if (new_following < cur_following) {
                    cur_following = new_following; /* keep setting cur_following back */
                }
                
                while(ctx_cur < ctx_end && *ctx_cur == prev_ctx) {
                    iter = *iter_cur - min_iter;
                    if (new_following < min_following[iter]) {
                        min_following[iter] = new_following;
                        if (iter < fst_iter) fst_iter = iter;
                        if (iter > lst_iter) lst_iter = iter;
                    }
                    ctx_cur++;
                    iter_cur++;
                }
            }
@(
            while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
                ctx_cur++; /* advance ctx pointer after breaking out early */
                iter_cur++;
            }
@)
            if (cur_following < boundary && fst_iter <= lst_iter) {
                /* now, everything until the end of the fragment is a following node */
                /* check, if result buffer is big enough; otherwise extend it */
                grow = ((lst_iter - fst_iter) + 1) * (boundary - cur_following);
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                while(cur_following < boundary) {
                    int sz = size[cur_following];
                    if (sz >= 0) {
                        @1 {
                            for (iter = fst_iter; iter <= lst_iter; iter++) {
                                if (min_following[iter] <= cur_following) {
                                    *res_hcur++ = iter + min_iter;
                                    *res_tcur++ = cur_following;
                                }
                            }
                        }
                        cur_following++;
                    } else { 
                        /* this node has been deleted! skip the hole */
                        cur_following += 1 + (sz & ~(1<<31)); 
                    }
                }
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
        GDKfree(min_following);
    }
@
@c
    @:end@

@= end
    /* -------------------- set result properties ---------------------- */
{
    bit trivial  = (BATcount(res) < 2);
    oid fst_item = *(oid*)Tloc(res, BUNfirst(res));
    oid lst_item = *(oid*)Tloc(res, BUNlast(res) - 1);
    bit one_item = (fst_item == lst_item);
    bit one_iter = (num_iter == 1);

    res->batDirty = TRUE;
    res->hdense = (trivial||(res->htype==TYPE_void)); /* might be TRUE in some more cases... */
    if (res->hdense) {
        if (BATcount(res) == 0) {
            BATseqbase (res, (oid)0); /* does not really matter */
        } else {
            BATseqbase (res, *(oid*)Hloc(res, BUNfirst(res)));
        }
    }
    res->hsorted = ((one_iter||one_item) ? GDK_SORTED : 0); /* might be TRUE in some more cases... */
    BATkey(res,(res->hdense||one_item)); /* might be TRUE in some more cases... */
    res->tdense = (trivial||(res->ttype==TYPE_void)); /* might be TRUE in some more cases... */
    if (res->tdense) {
        if (BATcount(res) == 0) {
            BATseqbase (BATmirror(res), (oid)0); /* does not really matter */
        } else {
            BATseqbase (BATmirror(res), *(oid*)Tloc(res, BUNfirst(res)));
        }
    }
    res->tsorted = GDK_SORTED;
    BATkey(BATmirror(res),(res->tdense||one_iter)); /* might be TRUE in some more cases... */
    BATset(res, TRUE);
}
    *result = res;

    return GDK_SUCCEED;
@
@c
}


/* PRECEDING STEP */
int
PFll_preceding(BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *doc_pre, BAT *pre_size, BAT *pre_kind, chr *_kind_test)
{
    @:init(preceding)@

    /* ------------------------- actual algorithm -------------------------- */

    if (kind_test != chr_nil) {
        @:ll_prec(if (kind[cur_preceding] == kind_test))@
    } else {
        @:ll_prec()@
    }
    
@= ll_prec
    if (one_ctx) {
        /* 1 ctx, 1/n iter */
        p = SORTfndlast(doc_pre, ctx_cur);
        if (p > BUNfirst(doc_pre)) {
            oid cur_preceding = *(oid*) BUNtail(doc_prei, p - 1);
            oid boundary = *ctx_cur;

            /* now, everything between the beginning of the fragment (cur_preceding) and
             * the context node (boundary) is preceding --- unless it's hole or ancestor */
            if (cur_preceding < boundary) {
                /* check, if result buffer is big enough; otherwise extend it */
                grow = num_iter * (boundary - cur_preceding);
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                if (num_iter == 1) {
                    ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, 1 iter\n", name);
                    while(cur_preceding < boundary) {
                        int sz = size[cur_preceding];
                        oid new_preceding = cur_preceding + 1 + (sz & ~(1<<31));
                        if (sz < 0) {
                            cur_preceding = new_preceding; /* skip hole */
                        } else
                        if (new_preceding > boundary) {
                            cur_preceding++; /* skip ancestor */
                        } else {
                            @1 {
                                *res_hcur++ = min_iter;
                                *res_tcur++ = cur_preceding;
                            }
                            cur_preceding++;
                        }
                    } 
                } else {
                    /* num_iter > 1 */
                    if (iter_bat->tkey) {
                        ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, n iter (key)\n", name);
                        while(cur_preceding < boundary) {
                            int sz = size[cur_preceding];
                            oid new_preceding = cur_preceding + 1 + (sz & ~(1<<31));
                            if (sz < 0) {
                                cur_preceding = new_preceding; /* skip hole */
                            } else
                            if (new_preceding > boundary) {
                                cur_preceding++; /* skip ancestor */
                            } else {
                                @1 {
                                    oid *cur_iter = iter_cur;
                                    for (; cur_iter < iter_end; cur_iter++) {
                                        *res_hcur++ = *cur_iter;
                                        *res_tcur++ = cur_preceding;
                                    }
                                }
                                cur_preceding++;
                            }
                        } 
                    } else {
                        /* !iter_bat->tkey */
                        ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, n iter\n", name);
                        while(cur_preceding < boundary) {
                            int sz = size[cur_preceding];
                            oid new_preceding = cur_preceding + 1 + (sz & ~(1<<31));
                            if (sz < 0) {
                                cur_preceding = new_preceding; /* skip hole */
                            } else
                            if (new_preceding > boundary) {
                                cur_preceding++; /* skip ancestor */
                            } else {
                                @1 {
                                    oid *cur_iter = iter_cur;
                                    oid prev_iter = oid_nil;
                                    for (; cur_iter < iter_end; cur_iter++) {
                                        if (*cur_iter != prev_iter) {
                                            *res_hcur++ = *cur_iter;
                                            *res_tcur++ = cur_preceding;
                                        }
                                    }
                                }
                                cur_preceding++;
                            }
                        } 
                    }
                }
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
    } else
    if (num_iter == 1) {
        /* n ctx, 1 iter */
        ALGODEBUG THRprintf(GDKout, "%s: n ctx, 1 iter\n", name);
        BATloop(doc_pre, p, q) {
            oid *ctx_fst = ctx_cur;
            oid cur_preceding = *(oid*) BUNtail(doc_prei,p); /* first node of the fragment */
            oid boundary = cur_preceding + size[cur_preceding] + 1; /* first of next fragment */

            /* within the fragment (boundary), go over all context nodes; and remember the last one */
            while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
                ctx_cur++;
            }
            if (ctx_fst < ctx_cur) {
                boundary = ctx_cur[-1]; /* the last context node in this fragment */
            } else {
                boundary = 0;
            }
            
            /* now, everything between the beginning of the fragment (cur_preceding) and
             * the context node (boundary) is preceding --- unless it's hole or ancestor */
            if (cur_preceding < boundary) {
                /* check, if result buffer is big enough; otherwise extend it */
                grow = boundary - cur_preceding;
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                while(cur_preceding < boundary) {
                    int sz = size[cur_preceding];
                    oid new_preceding = cur_preceding + 1 + (sz & ~(1<<31));
                    if (sz < 0) {
                        cur_preceding = new_preceding; /* skip hole */
                    } else
                    if (new_preceding > boundary) {
                        cur_preceding++; /* skip ancestor */
                    } else {
                        @1 {
                            *res_hcur++ = min_iter;
                            *res_tcur++ = cur_preceding;
                        }
                        cur_preceding++;
                    }
                } 
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
    } else
    {
        /* n ctx, n iter */
        ALGODEBUG THRprintf(GDKout, "%s: n ctx, n iter\n", name);
        oid *max_preceding = (oid*) GDKmalloc(num_iter * sizeof(oid));
        if (max_preceding == NULL) 
        { 
            GDKerror("%s: could not allocate a stack of size "SZFMT".\n", name, (size_t)num_iter * sizeof(oid));
            BBPreclaim(res);
            return GDK_FAIL;
        }
        BATloop(doc_pre, p, q) {
            oid iter = 0, fst_iter = num_iter, lst_iter = 0;
            oid cur_preceding = *(oid*) BUNtail(doc_prei,p); /* first node of the fragment */
            oid boundary = cur_preceding + size[cur_preceding] + 1; /* first of next fragment */
            memset(max_preceding, 0, num_iter * sizeof(oid));

            /* within the fragment (boundary), go over all context nodes; and remember the last one per iter */
            while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
                iter = *iter_cur - min_iter;
                max_preceding[iter] = *ctx_cur;
                if (iter < fst_iter) fst_iter = iter;
                if (iter > lst_iter) lst_iter = iter;
                ctx_cur++;
                iter_cur++;
            }
            boundary = max_preceding[iter]; /* the last context node in this fragment */
            
            if (cur_preceding < boundary && fst_iter <= lst_iter) {
                /* now, everything between the beginning of the fragment (cur_preceding) and
                 * the context node (boundary) is preceding --- unless it's hole or ancestor */
                /* check, if result buffer is big enough; otherwise extend it */
                grow = ((lst_iter - fst_iter) + 1) * (boundary - cur_preceding);
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                while(cur_preceding < boundary) {
                    int sz = size[cur_preceding];
                    oid new_preceding = cur_preceding + 1 + (sz & ~(1<<31));
                    if (sz < 0) {
                        cur_preceding = new_preceding; /* skip hole */
                    } else
                    if (new_preceding > boundary) {
                        cur_preceding++; /* skip "global" ancestor */
                    } else {
                        @1 {
                            for (iter = fst_iter; iter <= lst_iter; iter++) {
                                if (new_preceding <= max_preceding[iter]) {
                                    /* not "local" ancestor => preceding! */
                                    *res_hcur++ = iter + min_iter;
                                    *res_tcur++ = cur_preceding;
                                }
                            }
                        }
                        cur_preceding++;
                    }
                } 
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
        GDKfree(max_preceding);
    }
@
@c
    @:end@
}

/* vim:set shiftwidth=4 expandtab: */
