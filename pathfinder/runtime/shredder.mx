@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2005 University of Konstanz.  All Rights Reserved.
@'
@' $Id$

@f shredder
@a Jan Flokstra
@t shredder

@c
/**********************************************************************
 * shredder.c : xml document shredder for pathfinder
 *
 * It is an adapted version of pf-tools/loader/pf_shred where I tried to
 * generate exactly the same BAT's.
 * TODO:
 *      - stop the xmlparser more elegant in case of an error. xmlStopParser()
 *        generates a lot of extra confusing 'noise'
 */

/* #define DEBUG */

#define USE_COMPRESSION 1
#define PRINT_STAT 0

#include <gdk.h>
#include <monet.h>

#include <pf_config.h>

typedef int nat;
/* typedef oid nat; this works too but I I think it is not correct */
typedef unsigned int posint;
#define NATNIL ((nat) INT_MIN)
#define OIDNIL oid_nil
#define NATFMT "u"

/* support oid-s up to the 48 bits boundary => 13 decimal digits */
#define OIDFMT "%13" NATFMT 

static char emptyString[1] = "";

/*******
 *
 */

#include <strings.h>

/* SAX parser interface (libxml2) */
#include "libxml/parser.h"
#include "libxml/parserInternals.h"

#include "pathfinder.h"

/*********
 *
 * Attribute database definition section
 */

/* #define ADB_DEBUG */
/* #define ADB_USE_NAMES */

#define ADB_STARTSIZE	4

typedef struct specAttrStr {
	char*	ownerTag;
	char*	attrTag;
	int	type; /* XML_ATTRIBUTE_[ID|IDREF|IDREFS] */
} specAttrStr;

typedef struct specAttrDbStr {
	int doCheck;  /* boolean to signal if the attr db is in use */
	int n_specAttr;
	int max_specAttr;
	specAttrStr* specAttr;
} specAttrDbStr;

static int initAttrDB(specAttrDbStr* adb) {
#ifdef ADB_DEBUG
	stream_printf(GDKout,"[ADB] initialize database\n");
#endif
	adb->n_specAttr = adb->max_specAttr = 0;
	adb->specAttr   = 0;
#ifdef ADB_USE_NAMES
	/* in this case even when no attributes are encountered the db is in use. */
	adb->doCheck    = 1;
#else
	adb->doCheck    = 0;
#endif
	return 1;
}

static specAttrStr* findAttrDB(specAttrDbStr* adb, char* oTag, char* aTag) {
	int i;

	for(i=0; i<adb->n_specAttr; i++) {
		specAttrStr* sas = &adb->specAttr[i];
		if ( (strcmp(oTag, sas->ownerTag) == 0) &&
		     (strcmp(aTag, sas->attrTag) == 0) ) {
#ifdef ADB_DEBUG
			/* stream_printf(GDKout,"[ADB] found(%s,%s,%d)\n",sas->ownerTag,sas->attrTag,sas->type); */
#endif
			return sas;
		};
	}
	return 0;
}

static int specialAttrType(specAttrDbStr* adb, char* oTag, char* aTag) {
	if ( adb->doCheck ) { /* check if db is in use */
	    specAttrStr* sas;
	    if ( (sas = findAttrDB(adb,oTag,aTag)) )
		return sas->type;
	    else {
#ifdef ADB_USE_NAMES
		if ( (strcmp(aTag,"id")==0) || (strcmp(aTag,"ID")==0) )
		     return XML_ATTRIBUTE_ID;
		else if ( (strcmp(aTag,"idref")==0) || (strcmp(aTag,"IDREF")==0) )
		     return XML_ATTRIBUTE_IDREF;
		else if ( (strcmp(aTag,"idrefs")==0) || (strcmp(aTag,"IDREFS")==0) )
		     return XML_ATTRIBUTE_IDREFS;
#endif
	    }
	}
	return 0;
}

static int insertAttrDB(specAttrDbStr* adb, char* oTag, char* aTag, int type) {
        adb->doCheck = 1; /* signal database is in use */
	if ( findAttrDB(adb,oTag,aTag) ) {
		GDKerror("shredder.mx:insertAttrDB: specAttrDb(%s,%s,%d) is duplicate.\n",oTag, aTag, type);
		return -1;
	}
	if ( ++adb->n_specAttr > adb->max_specAttr ) {
		int newsz = (adb->max_specAttr?(adb->max_specAttr*2):ADB_STARTSIZE);

		specAttrStr* newb = (specAttrStr*)malloc(newsz*sizeof(specAttrStr));
		if ( adb->specAttr ) {
			memcpy(newb,adb->specAttr,adb->max_specAttr*sizeof(specAttrStr));
			free(adb->specAttr);
		}
		adb->specAttr     = newb;
		adb->max_specAttr = newsz;
	}
	specAttrStr* sas = &adb->specAttr[adb->n_specAttr - 1];
	sas->type     = type;
	sas->ownerTag = strdup(oTag);
	sas->attrTag  = strdup(aTag);
#ifdef ADB_DEBUG
	stream_printf(GDKout,"[ADB] inserted(%s,%s,%d)\n",oTag,aTag,type);
#endif
	return 1;
}

static int disposeAttrDB(specAttrDbStr* adb) {
	int i;

	for(i=0; i<adb->n_specAttr; i++) {
		specAttrStr* sas = &adb->specAttr[i];
		free(sas->ownerTag);
		free(sas->attrTag);
	}
	if ( adb->specAttr )
		free(adb->specAttr);
	adb->n_specAttr = adb->max_specAttr = 0;
	adb->specAttr   = 0;
	adb->doCheck	= 0;
#ifdef ADB_DEBUG
	stream_printf(GDKout,"[ADB] disposed database\n");
#endif
	return 1;
}

/* define the number of BATs in the requuired result set */
#define SHRED_BATS (PROP_VAL + 1)

/* description of the static properties of a result BAT */
typedef struct shredBATdef {
        int     id;       /* the index in the BAT, for assert usage */
        char*   name;     /* the name for the bat */
        int     headType; /* the headType of the BAT */
        int     tailType; /* the tailtype of the BAT */
        double  sizeFact; /* The mult. factor sizewise */
        char    compress; /* In case of str BAT to flag compression */
} shredBATdef;

/* values of the static properties of a result BAT */
static shredBATdef shredbatdef[SHRED_BATS] = {
        { PRE_SIZE, "PRE_SIZE", TYPE_void, TYPE_int, 1.0, 0},
        { PRE_LEVEL,"PRE_LEVEL",TYPE_void, TYPE_chr, 1.0, 0},
        { PRE_PROP, "PRE_PROP", TYPE_void, TYPE_oid, 1.0, 0},
        { PRE_KIND, "PRE_KIND", TYPE_void, TYPE_chr, 1.0, 0},
        { PRE_FRAG, "PRE_FRAG", TYPE_void, TYPE_oid, 1.0, 0},
        { QN_URI,   "QN_URI",   TYPE_void, TYPE_str, 0.0, 0},
        { QN_PREFIX,"QN_PREFIX",TYPE_void, TYPE_str, 0.0, 0},
        { QN_LOC,   "QN_LOC",   TYPE_void, TYPE_str, 0.0, 0},
        { PROP_TEXT,"PROP_TEXT",TYPE_void, TYPE_str, 0.0, 1},
        { PROP_COM, "PROP_COM", TYPE_void, TYPE_str, 0.0, 1},
        { PROP_INS, "PROP_INS", TYPE_void, TYPE_str, 0.0, 0},
        { PROP_TGT, "PROP_TGT", TYPE_void, TYPE_str, 0.0, 0},
        { ID_PRE,   "ID_PRE",   TYPE_str,  TYPE_oid, 0.0, 0},
        { IDREF_PRE,"IDREF_PRE",TYPE_str,  TYPE_oid, 0.0, 0},
        { ATTR_OWN, "ATTR_OWN", TYPE_void, TYPE_oid, 0.5, 0},
        { ATTR_QN,  "ATTR_QN",  TYPE_void, TYPE_oid, 0.5, 0},
        { ATTR_PROP,"ATTR_PROP",TYPE_void, TYPE_oid, 0.5, 0},
        { ATTR_FRAG,"ATTR_FRAG",TYPE_void, TYPE_oid, 0.0, 0},
        { PROP_VAL, "PROP_VAL", TYPE_void, TYPE_str, 0.0, 0}
};

/* description of the dynamic properties of a result BAT */
typedef struct shredBAT {
        shredBATdef     *def; /* pointer to static properties */
        nat             cnt;  /* current #of elements in the BAT */
        nat             dupl; /* the number of duplicate BUNins so far */
        off_t           size; /* current maximum size of the BAT */
        BAT             *bat; /* the physical BAT */
        /* */
        union { /* cast to perform direct indexex insert in [void,any] BATs */
            void* voidCAST; /* the basecast */
            nat*  natCAST;  /* cast for [void,int] BAT */
            chr*  chrCAST;  /* cast for [void,chr] BAT */
            oid*  oidCAST;  /* cast for [void,oid] BAT */
        } cast;
} shredBAT;

/*
 * 
 */
#define BAILOUT(C)	{ xmlStopParser(C); SHREDCTX(C)->err=1; return; }

/**
 * XML node stack maximum depth (use `-d' for deeper XML instances)
 */
#define XML_DEPTH_MAX 256
nat xml_depth_max = XML_DEPTH_MAX;

#define PUSH(SC,n) ((SC)->lifo[(SC)->sp++] = (n))
#define POP(SC)    ((SC)->lifo[--(SC)->sp])
#define TOP(SC)    ((SC)->lifo[(SC)->sp - 1])

/**
 * Node element of the XMD document interpretation stack
 */
typedef struct node_t node_t;
struct node_t {
    nat  pre;                   /**< preorder rank */
    nat  size;                  /**< size of subtree below node */
    int  level;                 /**< tree level of parent 
                                     (0 if root, -1 if document node) */
    nat  prop;                  /**< property ID */
    nat  kind;                  /**< node kind */
};

/* the computing context environmentf the shredding process */
typedef struct shredCtxStruct {
    char*       location;       /* xml document location */
    /* pre-level-depth administration */
    nat         nnode_pre; 	    /* next preorder rank to assign */
    nat         nnode_attr;	    /* number of attributes counter */
    nat         level;		    /* current level */
    nat         depth;		    /* current max depth */
    /* the xml node stack */
    node_t      *lifo;          /* the stack */
    nat         sp;             /* the stackpointer */
    /* buffer administration */
    nat         content;	    /* content ptr in char buff */
    char        *content_buf;   /* character buffer */
    /* */
    off_t       fileSize;       /* size of the input file */
    off_t       estSize;        /* extimated number of pre nodes */
    shredBAT    dstBAT[SHRED_BATS]; /* all the result BATs */
    BAT*        pfxlocBAT;      /* the BAT to compress NS and LOC */
    int         pfxlocDUPL;     /* the number of duplicates pfxlocs */
    int         shredWords;     /* store all words in text seperate,
                                 * this is something the Tijah 
                                 * people were asking for
                                 */
    specAttrDbStr	specAttrDb;	/* the database containing the 
                                 * ID|IDREF|IDREFS attributes
                                 */
    char        workSpace[1024];/* temporary workspace for this session */
    int         err;		    /* error during shred */
} shredCtxStruct;

/* the minimal incremental size of a BAT during estimation process */
#define MINCHUNK        1024

static shredCtxStruct *createShredCtx(char* location, off_t  fileSize) {
        int i;

        shredCtxStruct *res = (shredCtxStruct*)malloc( sizeof(shredCtxStruct) );
        res->location = location;
        res->fileSize = fileSize;
        res->estSize  = MIN(MAX(MINCHUNK,fileSize/20),INT_MAX);
        for(i=0; i<SHRED_BATS; i++) {
                shredBAT* sb = &res->dstBAT[i];

                sb->def = & shredbatdef[i];

                if ( sb->def->id != i ) {
                        GDKerror("shredder.mx:createShredCtx: id - sync\n");
                        return NULL;
                }
                sb->cnt  = sb->dupl = 0;
                if ( sb->def->headType == TYPE_str || sb->def->tailType == TYPE_str)
                        sb->size = MINCHUNK; /* let Monet do the resize self */
                else 
                        sb->size = (int)(sb->def->sizeFact * res->estSize);
                sb->bat  = BATnew(sb->def->headType,sb->def->tailType,sb->size);
                if ( !sb->bat ) {
                        GDKerror("shredder.mx:createShredCtx: BATnew(%d) for %s fails, disk full?\n",sb->size,sb->def->name);
                        return NULL;
                }
#ifdef USE_COMPRESSION
                if ( sb->def->compress ) {
                        /* create an accelerator on the str tail of the BAT */
                        sb->bat = BATmirror(BAThash(BATmirror(sb->bat),0));
                        if ( !sb->bat ) {
                                GDKerror("shredder.mx:createShredCtx: Hash[%d]:create fails\n",i);
                                return NULL;
                        }
                }
#endif
                BATseqbase(sb->bat,0);
                if ( sb->def->tailType != TYPE_str )
                        sb->cast.voidCAST = (void*)BUNfirst(sb->bat);
        }
#ifdef USE_COMPRESSION
        /* incomplete, what does second arg of BAThash do ?? */
        res->pfxlocBAT = BAThash(BATnew(TYPE_str,TYPE_oid,res->estSize/50),0);
        if ( !res->pfxlocBAT ) {
            GDKerror("shredder.mx:createShredCtx: pfxlocBAT:create fails\n");
            return NULL;
        }
        res->pfxlocDUPL= 0;
#endif
        res->shredWords = 0; /* do not shred words by default */
	/* and finally init the special attribute database */
	initAttrDB(&res->specAttrDb);
        return res;
}

/* Compress a [void,str] BAT in the most efficient way. 
 * (c:)P.Boncz
 */
int pf_compress(BAT *b,    /* BAT[void,str] input with duplicates */
                BAT **unq, /* BAT[void,str] output with unique strings */
                BAT **map  /* BAT[void,oid] output maps old oids into new */
){
  BAT *tmp_i, *tmp_m, *tmp_o, *bm = BATmirror(b);
  size_t hashmask_size = BATcount(b);
  int ret = -1;

  if (b->ttype == TYPE_str && GDK_ELIMDOUBLES(b->theap)) {
    b->ttype = bm->htype = TYPE_var; /* hack: use str offsets as int */
    b->tvarsized = bm->hvarsized = 0;
    hashmask_size = 65536;
  }

  /* guarantee a hash table suitable for some serious double elim */
  tmp_i = BATnew(b->ttype, TYPE_oid , hashmask_size);
  if (tmp_i != NULL && BAThash(tmp_i, hashmask_size) != NULL) {     
    tmp_i = BATins_kunique(tmp_i, bm); /* bat[str,oid] */
    if (tmp_i != NULL) {
      tmp_m = BATmark(BATsetaccess(tmp_i, BAT_READ), 0); /* bat[str,void] */
      if (tmp_m != NULL) {
        tmp_o = BATmark(BATmirror(tmp_i), 0); /* bat[oid,void] */
        if (tmp_o != NULL) {
          *map = BATleftjoin(b, tmp_m, BATcount(b)); /* bat[void,oid] */
          if (*map != NULL) {
            b->ttype = bm->htype = TYPE_str; /* undo hack for join */
	    b->tvarsized = bm->hvarsized = 1;
            *unq = BATleftfetchjoin(BATmirror(tmp_o), b, BATcount(tmp_o)); /* bat[v?oid,oid] */
            if (*unq != NULL) {
              BATsetaccess(*map, BAT_READ);
              BATsetaccess(*unq, BAT_READ);
              ret = 0; /* success */          
            } else {
              BBPreclaim(*map);
            }
          }
          BBPreclaim(tmp_o);
        }
        BBPreclaim(tmp_m);
      }
      BBPreclaim(tmp_i);
    }
  }
  b->ttype = bm->htype = TYPE_str; /* undo hack (in error case) */
  b->tvarsized = bm->hvarsized = 1;
  return ret;
}

/* function to tailor the exact size 'n' of the bat ctx->dstBAT[idx]. If
 * correct the batsize will always shrink!
 */
static int setBATcapacity(shredCtxStruct* shredCtx, int idx, int n) {
        BAT* b = shredCtx->dstBAT[idx].bat;

        void* top;
        
        int bottomTop = n;
        shredCtx->dstBAT[idx].cnt = n;
        switch( shredCtx->dstBAT[idx].def->tailType ) {
         case TYPE_int :
                top = &shredCtx->dstBAT[idx].cast.natCAST[bottomTop];
                break;
         case TYPE_chr: {
                b->batBuns->free = n; 
                BATsetcount(b, n);
                b->tsorted = 0;
                return 1;
                }
         case TYPE_oid:
                top = &shredCtx->dstBAT[idx].cast.oidCAST[bottomTop];
                break;
         default:
                GDKerror("shredder.mx:setBATcapacity: bad tailType\n");
                return -1;
        }
        b->batBuns->free = ((BUN)top) - BUNfirst(b);
        BATsetcount(b, n);
        b->tsorted = 0;
	return 1;
}

static void printStat(shredCtxStruct* shredCtx) {
        int i;

        stream_printf(GDKout,"############\n");
        stream_printf(GDKout,"# STATISTICS of shredding \"%s\":\n",shredCtx->location);
        for(i=0; i<SHRED_BATS; i++) {
                shredBAT* sb = &shredCtx->dstBAT[i];

                stream_printf(GDKout,"# [%9s, ",sb->def->name);
                stream_printf(GDKout,"cnt=%d",sb->cnt);
                if ( sb->def->compress || i==QN_PREFIX || i==QN_LOC) {
                    int dupl;

                    if ( sb->def->compress )
                        dupl = sb->dupl;
                    else
                        dupl = shredCtx->pfxlocDUPL;
                    stream_printf(GDKout,", dupl=%d(=%.f%%) ",dupl, ((dupl+sb->cnt)?100.0*(float)(sb->cnt)/(float)(dupl+sb->cnt):100.0));
                }
                if ( i==PRE_SIZE )
                        stream_printf(GDKout,", eg. the number of document nodes");
                if ( i==QN_PREFIX )
                        stream_printf(GDKout,", eg. the number of distinct tags");
                if ( i==ATTR_OWN )
                        stream_printf(GDKout,", eg. the number of attributes");
                stream_printf(GDKout,"]\n");
        }
}

static BAT* finalizeShredCtx(shredCtxStruct* shredCtx) {
        oid i;

        BAT* res = BATnew(TYPE_oid,TYPE_bat,SHRED_BATS); /* create result BAT */

        if ( !res ) {
                GDKerror("shredder.mx:finalizeShredCtx: resultBAT:create failed.\n");
                return NULL;
        }
	if (
          (setBATcapacity(shredCtx,PRE_SIZE, shredCtx->nnode_pre)  < 0) ||
          (setBATcapacity(shredCtx,PRE_LEVEL,shredCtx->nnode_pre)  < 0) ||
          (setBATcapacity(shredCtx,PRE_PROP, shredCtx->nnode_pre)  < 0) ||
          (setBATcapacity(shredCtx,PRE_KIND, shredCtx->nnode_pre)  < 0) ||
          (setBATcapacity(shredCtx,ATTR_OWN, shredCtx->nnode_attr) < 0) ||
          (setBATcapacity(shredCtx,ATTR_QN,  shredCtx->nnode_attr) < 0) ||
          (setBATcapacity(shredCtx,ATTR_PROP,shredCtx->nnode_attr) < 0)
	)
		return NULL;
	/* */
	shredBAT* pv = &shredCtx->dstBAT[PROP_VAL];

	BAT* pvu;
	BAT* xlate_oid;

	if ( pf_compress(pv->bat,&pvu,&xlate_oid) < 0 ) {
        	GDKerror("shredder.mx:finalizeShredCtx: compressing PROP_VAL fails\n");
                return NULL;
	}
	/* */
	if ( BATcount(pv->bat) != BATcount(xlate_oid) ) {
		GDKerror("shredder.mx:finalizeShredCtx: pf_compress() returns bad # of xlate oids: " SZFMT " (expected " SZFMT ")\n",BATcount(xlate_oid),BATcount(pv->bat));
		return NULL;
	}
	/* */
	BBPunfix(BBPcacheid(pv->bat));
	pv->cnt = (nat)BATcount(pvu); /* set the correct #values in the bat */
	pv->bat = pvu;

	shredBAT* ap = &shredCtx->dstBAT[ATTR_PROP];
	BAT* lj = BATleftjoin(ap->bat,xlate_oid,BATcount(ap->bat));
	BBPunfix(BBPcacheid(xlate_oid));
	BBPunfix(BBPcacheid(ap->bat));
	ap->bat = lj;
	/* */
	if ( 0 ) {
		BATprintf(GDKout,shredCtx->dstBAT[ATTR_PROP].bat);
		BATprintf(GDKout,shredCtx->dstBAT[PROP_VAL].bat);
	}

        for(i=0; i<SHRED_BATS; i++) {
                shredBAT* sb = &shredCtx->dstBAT[i];
#ifdef USE_COMPRESSION
                if ( sb->def->compress ) {
                        /* remove all accelerators from the BAT */
                        HASHdestroy(sb->bat);
                }
#endif
                if ( sb->def->headType==TYPE_void && !BAThdense(sb->bat) )
                        stream_printf(GDKout,"WARNING: BAT[%s] not dense\n",sb->def->name);
                sb->bat = BATsetaccess( sb->bat, BAT_READ );
                bat bbb = BBPcacheid( sb->bat );
                if ( ! BUNins(res, &i, &bbb) ) {
                     GDKerror("shredder.mx:finalizeShredCtx: copy2result fails\n");
                     return NULL;
                }
                BBPunfix( bbb );
        }
        if ( PRINT_STAT )
                printStat(shredCtx);
#ifdef USE_COMPRESSION
        BBPunfix( BBPcacheid( shredCtx->pfxlocBAT ) );
#endif
	disposeAttrDB(&shredCtx->specAttrDb);
        free( shredCtx );
        return BATsetaccess( res, BAT_READ );
}


static int mainSHREDDER(shredCtxStruct* shredCtx, char* location, char* buffer);
static char *timer_str (long elapsed);

/* simplistic check whether location is an URL:
   protocols consist of more than one letter, so we consider location
   a URL if it starts with at least two letters, followed by a
   colon. */
int isURL(char* location) {
	int i = 0;
	while (*location && (('a' <= *location && *location <= 'z') ||
			     ('A' <= *location && *location <= 'Z'))) {
		location++;
		i++;
	}
	return i > 1 && *location == ':';
}

off_t  fileSize(char* location) {
    /* buffer for file I/O status */
    struct stat statbuf;

    if ( !isURL(location) ) {
        if (stat (location, &statbuf) < 0) {
            GDKerror("shredder.mx:fileSize: cannot stat `%s': %s\n",
                     location, strerror (errno));
            return ~(off_t)0;
        } else
            return statbuf.st_size;
    } else {
	/* INCOMPLETE, return an estimate of the size of the XML file */
        return ~(off_t)100000;
    }
}

int
CMDshred2bats(BAT **res2mil, str location, str buffer, str opt)
{
    /* detect NULL strings from MIL */
    if ( strlen(location)==0 && strlen(buffer) == 0 ) {
        GDKerror("shredder.mx:CMDshred2bats: nothing to shred!\n");
        return GDK_FAIL;
    }

    if ( strlen(location)!=0 && strlen(buffer)!= 0 ) {
        GDKerror("shredder.mx:CMDshred2bats: \"location\" and \"buffer\" may not contain values at the same time!\n");
        return GDK_FAIL;
    }

    /* shred context */
    shredCtxStruct* shredCtx;

    /* timing */
    struct timeval now;
    long start, stop;

    /* start timer */
    (void) gettimeofday (&now, 0);
    start = now.tv_sec * 1000000 + now.tv_usec;
    
    off_t xmlFileSize;
    if (strcmp(buffer, str_nil) != 0)
        xmlFileSize = strlen(buffer);
    else if ( (xmlFileSize = fileSize(location)) == ~(off_t)0 )
        return GDK_FAIL;

    if ( !(shredCtx = createShredCtx(location,xmlFileSize)) )
        return GDK_FAIL;
    shredCtx->shredWords = (strcmp(opt,"tijah")==0);

    if ( mainSHREDDER(shredCtx, location, buffer) < 0 )
        return GDK_FAIL;

    if ( !(*res2mil = finalizeShredCtx( shredCtx )) )
        return GDK_FAIL;

    /* read elapsed time */
    gettimeofday (&now, 0);
    stop = now.tv_sec * 1000000 + now.tv_usec;

    if ( PRINT_STAT ) {
            stream_printf(GDKout,"# Elapsed time = %s [%s/node]\n",
                        timer_str (abs (stop - start)),
                        timer_str (abs (stop - start) / shredCtx->nnode_pre));
    }
    return GDK_SUCCEED;
}

#define CHECK_BAT_SIZE(SB,I)    if ( ((off_t)(I)>=(SB)->size) && incrBATsize(SB,I)<0) return NATNIL; 

static int incrBATsize(shredBAT* sb, nat i) {
    off_t newsize = MAX(sb->size+MAX(MINCHUNK,sb->size/4),(off_t)i);

    /* first check if the number of BUN's < INT_MAX. If this was the case
     * and the previous time INT_MAX was returned this means the BAT cannot
     * grow any longer.
     */
    if ( newsize > INT_MAX ) {
    	newsize = INT_MAX;

	if ( sb->size == INT_MAX ) {
        	GDKerror("shredder.mx:incrBATsize: BATextend[\"%s\"](size>INT_MAX) fails\n",sb->def->name);
		return -1;
	}
    }
    sb->size= newsize;
    if ( !(sb->bat = BATextend(sb->bat,newsize)) ) {
        GDKerror("shredder.mx:incrBATsize: BATextend[\"%s\"](%d to %d) fails\n",sb->def->name,sb->size,newsize);
        return -1;
    }
    if ( sb->def->tailType != TYPE_str ) {
         sb->cast.voidCAST = (void*)BUNfirst(sb->bat);
    }
    return 1;
}

static INLINE nat direct_nat2bat(shredCtxStruct* shredCtx, int idx, nat i, nat v) {
        shredBAT* sb = & shredCtx->dstBAT[idx];
#ifdef VERBOSE
        stream_printf(GDKout,"DIRECT[%s](%d) = %d\n",sb->def->name,i,v);
#endif
        CHECK_BAT_SIZE(sb,i);
        sb->cast.natCAST[i] = v;
        return i;
}

static INLINE nat direct_natoid2bat(shredCtxStruct* shredCtx, int idx, nat i, nat v_nat) {
        shredBAT* sb = & shredCtx->dstBAT[idx];
#ifdef VERBOSE
        stream_printf(GDKout,"DIRECT[%s](%d) = %d@0\n",sb->def->name,i,v);
#endif
        CHECK_BAT_SIZE(sb,i);
	oid v_oid;
	if ( v_nat != NATNIL ) {
		v_oid = v_nat;
	} else {
        	v_oid = OIDNIL;
	}
        sb->cast.oidCAST[i] = v_oid;
        return i;
}

static INLINE nat direct_chr2bat(shredCtxStruct* shredCtx, int idx, nat i, chr v) {
        shredBAT* sb = & shredCtx->dstBAT[idx];
#ifdef VERBOSE
        stream_printf(GDKout,"DIRECT[%s](%d) = chr(%d)\n",sb->def->name,i,v);
#endif
        CHECK_BAT_SIZE(sb,i);
        sb->cast.chrCAST[i] = v;
        return i;
}

static INLINE nat append_str2bat(shredCtxStruct* shredCtx, int idx, str v) {
        oid my_oid_nil = OIDNIL;

        shredBAT* sb = & shredCtx->dstBAT[idx];

#ifdef USE_COMPRESSION
        if ( sb->def->compress ) {
                /* incomplete, this mirror stuff looks rather clumsy */
                BAT* mb = BATmirror(sb->bat);

                BUN bun;
                bun = BUNfnd(mb,v);
                if ( bun ) {
                        oid fo = *(oid*)BUNtail(mb,bun);
                        sb->dupl++;
                        return (nat)fo;
                }
        }
#endif /*USE_COMPRESSION*/

#ifdef VERBOSE
        stream_printf(GDKout,"APPEND-STR[%s](%s)\n",sb->def->name,v);
#endif
        if ( !BUNins(sb->bat,(ptr)&my_oid_nil,(ptr)v) ) {
            GDKerror("shredder.mx:append_str2bat: APPEND-STR[%s](%s), BUNins fails\n",sb->def->name,v);
            return NATNIL;
        }
        return sb->cnt++;
}

static INLINE nat append_str_oid2bat(shredCtxStruct* shredCtx, int idx, str s, oid o) {
        shredBAT* sb = & shredCtx->dstBAT[idx];
#ifdef VERBOSE
        stream_printf(GDKout,"APPEND-STR-OID[%s](%s,%d)\n",sb->def->name,s,o);
#endif
        if ( !BUNins(sb->bat,(ptr)s,(ptr)&o) ) {
            return NATNIL;
        }
        return sb->cnt++;
}

/*******
 *
 */

/**
 * XML node kinds
 */
#define ELEMENT   0
#define PFTEXT    1
#define COMMENT   2
#define PI        3
#define DOCUMENT  4

/**
 * maximum length of a string
 */
#define PFSHRED_STRLEN_MAX (1 << 23)
#define PFSHRED_BUFLEN (1 << 10)

/**
 * XML node
 */
#define XML_TAG_MAX PFSHRED_STRLEN_MAX

/**
 * convert ms timing value into string
 */
static char *
timer_str (long elapsed)
{
    char *tm, *str;

    tm = str = strdup ("000h 00m 00s 000ms 000us");

    if (elapsed / 3600000000UL) {
        str += sprintf (str, "%03ldh ", elapsed / 3600000000UL);
        elapsed %= 3600000000UL;
    }
  
    if (elapsed / 60000000UL) {
        str += sprintf (str, "%02ldm ", elapsed / 60000000UL);
        elapsed %= 60000000UL;
    }
  
    if (elapsed / 1000000UL) {
        str += sprintf (str, "%02lds ", elapsed / 1000000UL);
        elapsed %= 1000000UL;
    }

    if (elapsed / 1000UL) {
        str += sprintf (str, "%03ldms ", elapsed / 1000UL);
        elapsed %= 1000UL;
    }

    str += sprintf (str, "%03ldus", elapsed);

    return tm;
}

/**
 * enter new XML node into pre|size|level|prop|kind relation
 */
static int
emitnode (shredCtxStruct* shredCtx, node_t node)
{
    if (
       direct_nat2bat(shredCtx,PRE_SIZE, node.pre,node.size)  == NATNIL ||
       direct_chr2bat(shredCtx,PRE_LEVEL,node.pre,node.level) == NATNIL ||
       direct_natoid2bat(shredCtx,PRE_PROP, node.pre,node.prop)  == NATNIL ||
       direct_chr2bat(shredCtx,PRE_KIND, node.pre,node.kind)  == NATNIL 
    )
        return -1;
    else
        return 1;
}

/* This method checks for a maximum of INT_MAX for the pre number because it
 * must be stored in an [void,int] BAT. When the BAT will store unsigned int's
 * the maximum will become UINT_MAX.
 */
#define NEXT_PRE(P)     if ( (P++) == INT_MAX ) { GDKerror("shredder.mx: FATAL_ERROR: NEXT_PRE(): pre >INT_MAX. Use 64bit oid!\n"); exit(0); }

#define SHREDCTX(X)   ((shredCtxStruct*)((xmlParserCtxtPtr)X)->_private)

void 
shred_start_document (void *xmlCtx)
{
    shredCtxStruct* shredCtx = SHREDCTX(xmlCtx);

#ifdef DEBUG
    stream_printf(GDKout,"start_document()\n");
#endif
    shredCtx->nnode_pre  = 0;   /* next ``node ID'' */
    shredCtx->nnode_attr = 0;   /* attribute value property ID */
    shredCtx->level      = 0;
    shredCtx->depth      = 0;
    shredCtx->content    = 0;

    /* push document node */
    PUSH (shredCtx,((node_t) { .pre   = 0, 
                      .size  = 0, 
                      .level = -1,
                      .prop  = NATNIL,
                      .kind  = DOCUMENT
                    }));
    NEXT_PRE(shredCtx->nnode_pre);
}

void 
shred_end_document (void *xmlCtx)
{
    shredCtxStruct* shredCtx = SHREDCTX(xmlCtx);

    /* pop document node and enter into pre|size|level|prop|kind relation */
    if ( emitnode (shredCtx,POP(shredCtx)) < 0 ) {
    	BAILOUT(xmlCtx);
    }
#ifdef DEBUG
    stream_printf(GDKout,"end_document()\n");
#endif
}

/**
 * write buffered text content (if any) to prop|text relation
 */
static int 
emitString(shredCtxStruct* shredCtx, char* s)
{
    node_t node;

    /* fill the node */
    node.pre   = shredCtx->nnode_pre;
    NEXT_PRE(shredCtx->nnode_pre);
    node.size  = 0;
    node.level = shredCtx->level;
    node.kind  = PFTEXT;
    if ( (node.prop=append_str2bat(shredCtx,PROP_TEXT,s)) == NATNIL)
            return -1;

    /* this text node contributes to the size of its parent */
    TOP(shredCtx).size++;

    /* enter text node into pre|size|level|prop|kind relation */
    if ( emitnode (shredCtx,node) < 0 )
        return -1;
    return 1;
}

const char* del = " \t\n\r";

static int 
emitShreddedString(shredCtxStruct* shredCtx, char* s)
{
    char *t;

    if ( (t = strtok(s,del)) ) do {
        if ( emitString(shredCtx,t) < 0 )
             return -1;
    } while ( (t=strtok(NULL,del)) );
    return 1;
}

static int 
handleXmlCharacters (shredCtxStruct* shredCtx)
{
    /* is there any buffered text content? */
    if (shredCtx->content) {
        shredCtx->content_buf[shredCtx->content] = 0; /* properly terminate string content_buf */

        if ( !shredCtx->shredWords ) {
            if ( emitString(shredCtx,shredCtx->content_buf) < 0 )
                return -1;
        } else {
            /* do the Tijah support thing */
            if ( emitShreddedString(shredCtx,shredCtx->content_buf) < 0 )
                return -1;
        }
    }
    shredCtx->content = 0;
    return 1;
}

static nat store_PfxLoc4SAX1(shredCtxStruct* shredCtx, char* pfxloc) {
#ifdef USE_COMPRESSION
        BUN bun;
        if ( (bun = BUNfnd(shredCtx->pfxlocBAT,pfxloc)) ) {
                shredCtx->pfxlocDUPL++;
                return (nat)*(oid*)BUNtail(shredCtx->pfxlocBAT,bun);
        }
	oid res_oid;
#endif
        nat res;
        char *colon, *nsStr, *locStr;

        /* new fast namespace/localname decoding */
        if ( (colon = strchr (pfxloc, ':')) ) {
            nsStr  = pfxloc;
            *colon = '\0';
            locStr = &colon[1]; 
        } else {
            nsStr  = emptyString;
            locStr = pfxloc; 
        }
	/* incomplete, do something with the URI here */
        if ( (res=append_str2bat(shredCtx,QN_URI,emptyString))==NATNIL)
                return NATNIL;
        if ( (res=append_str2bat(shredCtx,QN_PREFIX,nsStr))==NATNIL)
                return NATNIL;
        if ( res != append_str2bat(shredCtx,QN_LOC,locStr) ) {
                GDKerror("shredder.mx:store_PfxLoc: NS-LOC sync error\n");
                return NATNIL;
        }
#ifdef USE_COMPRESSION
	res_oid = (oid)res;
        if ( !BUNins(shredCtx->pfxlocBAT,pfxloc,&res_oid) ) {
                GDKerror("shredder.mx:store_PfxLoc: compression table insert fails\n");
                return NATNIL;
        }
#endif
	if ( colon ) {
	    /* undo the inserted '\0' between the ns and the locName */
	    *colon = ':';
	}
        return res;
}


static nat store_PfxLocNEW(
		shredCtxStruct* shredCtx,
		const xmlChar*  a_uri,
		const xmlChar*  a_pfx,
		const xmlChar*  a_tag
	) {
	char *pfxloc;

	if ( a_uri ) {
	   if ( !a_pfx )
	       a_pfx = (xmlChar*)emptyString;
	   sprintf(shredCtx->workSpace,"%s:%s:%s",a_uri,a_pfx,a_tag);
	   pfxloc = &shredCtx->workSpace[0];
	} else if ( a_pfx ) {
	   a_uri = (xmlChar*)emptyString;
	   sprintf(shredCtx->workSpace,"%s:%s",a_pfx,a_tag);
	   pfxloc = &shredCtx->workSpace[0];
	} else {
	   a_uri = a_pfx = (xmlChar*)emptyString;
	   pfxloc = (char*)a_tag;
	}
    	/* stream_printf(GDKout,"** store_PfxLocNEW(%s)\n",pfxloc); */
#ifdef USE_COMPRESSION
        BUN bun;
        if ( (bun = BUNfnd(shredCtx->pfxlocBAT,pfxloc)) ) {
                shredCtx->pfxlocDUPL++;
                return (nat)*(oid*)BUNtail(shredCtx->pfxlocBAT,bun);
        }
	oid res_oid;
#endif
        nat res;

        if ( (res=append_str2bat(shredCtx,QN_URI,(char*)a_uri))==NATNIL)
                return NATNIL;
        if ( res != append_str2bat(shredCtx,QN_PREFIX,(char*)a_pfx) )
                return NATNIL;
        if ( res != append_str2bat(shredCtx,QN_LOC,(char*)a_tag) ) {
                GDKerror("shredder.mx:store_PfxLoc: NS-LOC sync error\n");
                return NATNIL;
        }
#ifdef USE_COMPRESSION
	res_oid = (oid)res;
        if ( !BUNins(shredCtx->pfxlocBAT,pfxloc,&res_oid) ) {
                GDKerror("shredder.mx:store_PfxLoc: compression table insert fails\n");
                return NATNIL;
        }
#endif
	/* if ( colon ) { */
	    /* undo the inserted '\0' between the ns and the locName */
	    /* *colon = ':'; */
	/* } */
        return res;
}


/* forward definition of tokenize_IDREFS() */
static int tokenize_IDREFS( shredCtxStruct *shredCtx, char* ownerTag, oid pre, str attrTag, str attrVal);

static int 
handleID_IDREF( shredCtxStruct *shredCtx, 
		char* ownerTag,
		oid   pre,
		str   attrTag,
		str   attrVal,
		int   attrType)
{
#ifdef ADB_DEBUG
	stream_printf(GDKout,"handleID_IDREF(own=%s,pre=%d,pfxloc=%s,v=\"%s\") = %d\n",ownerTag,pre,attrTag,attrVal,attrType);
#endif
	int batIdx = 0;

	switch( attrType ) {
	 case XML_ATTRIBUTE_ID:
		batIdx = ID_PRE;
	 	break;
	 case XML_ATTRIBUTE_IDREF:
		batIdx = IDREF_PRE;
	 	break;
	 case XML_ATTRIBUTE_IDREFS:
		return tokenize_IDREFS(shredCtx,ownerTag,pre,attrTag,attrVal);
	}
	if ( append_str_oid2bat(shredCtx,batIdx,attrVal,pre) == NATNIL ) {
		GDKerror("shredder.mx:handleID_IDREF: append() for handleID_IDREF(own=%s,pre=%d,pfxloc=%s,v=\"%s\") = %d FAILED\n",ownerTag,pre,attrTag,attrVal,attrType);
		return 0;
	}
	return 1;
}

static int 
tokenize_IDREFS( shredCtxStruct *shredCtx, 
		 char* ownerTag,
		 oid   pre,
		 str   attrTag,
		 str   attrVal) {
	/* tokenize IDREFS value attrVal and handle every tokenized value
	 * as an IDREF.
	 */ 
	/* Windows doesn't support strtok_r, but at least strtok is
	 * thread-safe
	 */
#ifdef HAVE_STRTOK_R
	char* insideStrtok;
#endif
	char* spaces = " \t";
	char *tok;
#ifdef HAVE_STRTOK_R
	tok = strtok_r(attrVal,spaces,&insideStrtok);
#else
	tok = strtok(attrVal,spaces);
#endif
	while ( tok ) {
		if ( !handleID_IDREF(shredCtx,ownerTag,pre,attrTag,tok,XML_ATTRIBUTE_IDREF) )
			return 0;
#ifdef HAVE_STRTOK_R
		tok = strtok_r(0,spaces,&insideStrtok);
#else
		tok = strtok(0,spaces);
#endif
	}
	return 1;
}

/**
 * SAX callback, invoked whenever `<t ...>' is seen
 */
void 
shred_start_element(void *xmlCtx, 
                     const xmlChar  *e_uri, 
                     const xmlChar  *e_pfx, 
                     const xmlChar  *e_loc, 
		     int	     n_atts,
		     const xmlChar **atts)
{
    node_t node;
    nat qn_id, val_id;
    shredCtxStruct* shredCtx = SHREDCTX(xmlCtx);

    if ( handleXmlCharacters (shredCtx) < 0 ) {
        BAILOUT(xmlCtx);
    }
    /* (1) assign preorder rank (document order), size, level, and kind */
    node.pre   = shredCtx->nnode_pre;
    NEXT_PRE(shredCtx->nnode_pre);
    node.size  = 0;
    node.level = shredCtx->level;
    node.kind  = ELEMENT;

    /* descend one level */
    if ( shredCtx->level++ >= xml_depth_max) {
        GDKerror("shredder.mx:shred_start_element: max document nesting exceeded:(MAX==%d)\n", xml_depth_max);
        BAILOUT(xmlCtx);
    }

    /* keep track of document depth */
    if (shredCtx->level > shredCtx->depth)
        shredCtx->depth = shredCtx->level;

#ifdef DEBUG
    stream_printf(GDKout," start_element(");
    if (e_uri) stream_printf(GDKout,"uri=%s,",e_uri);
    if (e_pfx) stream_printf(GDKout,"pfx=%s,",e_pfx);
    stream_printf(GDKout,"lev=%d",node.level);
    stream_printf(GDKout,"loc=%s",e_loc);
    stream_printf(GDKout,")\n");
#endif
    if ( (node.prop = store_PfxLocNEW(shredCtx,e_uri,e_pfx,e_loc)) == NATNIL ) {
        BAILOUT(xmlCtx);
    }

    /* push node onto node stack: size to be determined later */
    PUSH (shredCtx,node);

    /* (2) process the elements attribute(s) */
    int i;
    for(i=0;i<(5*n_atts); i+=5) {
    	    const xmlChar *a_tag = atts[i];
    	    const xmlChar *a_pfx = atts[i+1];
    	    const xmlChar *a_uri = atts[i+2];
    	    const xmlChar *a_val = atts[i+3];
    	    const xmlChar *a_end = atts[i+4];

	    xmlChar qiChar = *a_end; /* remember char value */
	    *(xmlChar*)a_end = 0; /* UGLY HACK: ignore const modifier */
#ifdef DEBUG
    	    stream_printf(GDKout,"  attr(");
    	    if (a_uri) stream_printf(GDKout,"uri=%s,",a_uri);
    	    if (a_pfx) stream_printf(GDKout,"pfx=%s,",a_pfx);
    	    stream_printf(GDKout,"tag=%s",a_tag);
    	    stream_printf(GDKout,",val=\"%s\"",a_val);
    	    stream_printf(GDKout,")\n");
#endif
            qn_id  = store_PfxLocNEW(shredCtx,a_uri,a_pfx,a_tag);

	    /* INCOMPLETE, this value stuff should be done properly by libxml2, but how? */
            val_id = append_str2bat(shredCtx,PROP_VAL,(char*)a_val);
            /* */
            if ( 
               qn_id  == NATNIL ||
               val_id == NATNIL ||
               direct_natoid2bat(shredCtx,ATTR_OWN ,shredCtx->nnode_attr, node.pre) == NATNIL ||
               direct_natoid2bat(shredCtx,ATTR_QN  ,shredCtx->nnode_attr, qn_id)    == NATNIL ||
               direct_natoid2bat(shredCtx,ATTR_PROP,shredCtx->nnode_attr, val_id)   == NATNIL
            ) {
                BAILOUT(xmlCtx);
            }
	    int attrType;

	    if ( (attrType = specialAttrType(&shredCtx->specAttrDb,(char*)e_loc,(char*)*atts)) ) {
	        if ( !handleID_IDREF(shredCtx,(char*)e_loc,node.pre,(char*)a_tag,(char*)a_val,attrType) ) {
                	BAILOUT(xmlCtx);
		}
	    }
	    *(xmlChar*)a_end = qiChar;	      /* restore the quote */
            /* process next attribute */
            shredCtx->nnode_attr++;
    }
}

void 
shred_start_element4SAX1(void *xmlCtx, 
                     const xmlChar *t, const xmlChar **atts)
{
    node_t node;
    nat qn_id, val_id;
    shredCtxStruct* shredCtx = SHREDCTX(xmlCtx);

    if ( handleXmlCharacters (shredCtx) < 0 ) {
        BAILOUT(xmlCtx);
    }
    /* (1) assign preorder rank (document order), size, level, and kind */
    node.pre   = shredCtx->nnode_pre;
    NEXT_PRE(shredCtx->nnode_pre);
    node.size  = 0;
    node.level = shredCtx->level;
    node.kind  = ELEMENT;

    /* descend one level */
    shredCtx->level++;

    /* keep track of document depth */
    if (shredCtx->level > shredCtx->depth)
        shredCtx->depth = shredCtx->level;

    if ( (node.prop = store_PfxLoc4SAX1(shredCtx, (char*) t)) == NATNIL ) {
        BAILOUT(xmlCtx);
    }

    /* push node onto node stack: size to be determined later */
    PUSH (shredCtx,node);

    /* (2) process the element's attribute(s), if any */
    if (atts)
        while (*atts) {            
            qn_id  = store_PfxLoc4SAX1(shredCtx, (char*) *atts);
            val_id = append_str2bat(shredCtx,PROP_VAL,(char*)*(atts + 1));
            /* */
            if ( 
               qn_id  == NATNIL ||
               val_id == NATNIL ||
               direct_natoid2bat(shredCtx,ATTR_OWN ,shredCtx->nnode_attr, node.pre) == NATNIL ||
               direct_natoid2bat(shredCtx,ATTR_QN  ,shredCtx->nnode_attr, qn_id)    == NATNIL ||
               direct_natoid2bat(shredCtx,ATTR_PROP,shredCtx->nnode_attr, val_id)   == NATNIL
            ) {
                BAILOUT(xmlCtx);
            }
	    int attrType;

	    if ( (attrType = specialAttrType(&shredCtx->specAttrDb,(char*)t,(char*)*atts)) ) {
	        if ( !handleID_IDREF(shredCtx,(char*)t,node.pre,(char*)*atts,(char*)*(atts + 1),attrType) ) {
                	BAILOUT(xmlCtx);
		}
	    }
            /* process next attribute */
            shredCtx->nnode_attr++;
            atts += 2;
        }
}

/** 
 * SAX callback invoked whenever `</t>' is seen
 */
void 
shred_end_element (void *xmlCtx, const xmlChar *tag)
{
    node_t node;
    shredCtxStruct* shredCtx = SHREDCTX(xmlCtx);

    (void) tag;

    if ( handleXmlCharacters (shredCtx) < 0 ) {
        BAILOUT(xmlCtx);
    }

    node = POP(shredCtx);

    /* ascend up one level */
    shredCtx->level--;

    /* the size of the subtree below this element and the element
     * itself contributes to the size of its parent
     */
    TOP(shredCtx).size += node.size + 1;

    /* enter element node into pre|size|level|prop|kind relation */
    if ( emitnode (shredCtx,node) < 0 ) {
        BAILOUT(xmlCtx);
    }
#ifdef DEBUG
    stream_printf(GDKout," end_element(%s)\n",tag);
#endif
}

/**
 * SAX callback invoked whenever text node content is seen,
 * simply buffer the content here
 */
void 
shred_characters (void *xmlCtx, const xmlChar *cs, int n)
{
    shredCtxStruct* shredCtx = SHREDCTX(xmlCtx);

    int l = MIN (PFSHRED_STRLEN_MAX - (int) shredCtx->content, n);

    (void) xmlCtx;

    memcpy (&(shredCtx->content_buf[shredCtx->content]), cs, l);
    shredCtx->content += l;

    if (l < n)
        GDKwarning("shredder.mx:shred_characters: WARNING: truncated text node > %" NATFMT " characters (starts with `%.16s...')\n",
                 PFSHRED_STRLEN_MAX,cs);
}

/**
 * SAX callback invoked whenever `<![CDATA[...]]>' is seenx
 */
void 
shred_cdata (void *xmlCtx, const xmlChar *cdata, int n)
{
    shred_characters (xmlCtx, cdata, n);
}

/** 
 * SAX callback invoked whenever `<?target ins?>' is seen
 */
void 
shred_pi (void *xmlCtx, const xmlChar *tgt, const xmlChar *ins)
{
    /*
     * incomplete, do not compress tgt ins properties yet. Should do
     * it analog to pfxloc with an extra BAT
     */
    node_t node;
    shredCtxStruct* shredCtx = SHREDCTX(xmlCtx);

    if ( handleXmlCharacters (shredCtx) < 0 ) {
        BAILOUT(xmlCtx);
    }

    node.pre   = shredCtx->nnode_pre;
    NEXT_PRE(shredCtx->nnode_pre);
    node.size  = 0;
    node.level = shredCtx->level;
    node.kind  = PI;

    /* this comment p-i contributes to the size of its parent */
    TOP(shredCtx).size++;
        
    node.prop = append_str2bat(shredCtx,PROP_TGT,(char*)tgt);
    if ( node.prop != append_str2bat(shredCtx,PROP_INS,(char*)ins) ) {
        GDKerror("shredder.mx:shred_pi: tgt-ins sync error\n");
        BAILOUT(xmlCtx);
    }
    
    /* enter p-i node into pre|size|level|prop|kind relation */
    if ( emitnode (shredCtx,node) < 0 ) {
        BAILOUT(xmlCtx);
    }
}

void 
shred_comment (void *xmlCtx, const xmlChar *c)
{
    node_t node;
    shredCtxStruct* shredCtx = SHREDCTX(xmlCtx);

    if ( handleXmlCharacters (shredCtx) < 0 ) {
        BAILOUT(xmlCtx);
    }

    node.pre   = shredCtx->nnode_pre;
    NEXT_PRE(shredCtx->nnode_pre);
    node.size  = 0;
    node.level = shredCtx->level;
    node.kind  = COMMENT;

    /* this comment node contributes to the size of its parent */
    TOP(shredCtx).size++;

    node.prop = append_str2bat(shredCtx,PROP_COM,(char*)c);

    /* enter comment node into pre|size|level|prop|kind relation */
    if ( emitnode (shredCtx,node) < 0 ) {
        BAILOUT(xmlCtx);
    }
}

static void 
print_error(void *ctx, const char *msg, ...) {
    va_list args;
    (void)ctx;

    int len = 0;
    char buf[PFSHRED_BUFLEN];

    /* IMPORTANT this function may be called multiple times for one error
     * message so it is not possible to use GDKerror() here */
    va_start(args, msg);
    /* vfprintf((FILE *)xmlGenericErrorContext, msg, args); ORIGINAL libxml2 */
    len += vsnprintf(buf+len, PFSHRED_BUFLEN-len-1, msg, args);
    va_end(args);

    stream_printf(GDKerr,buf);
}

/** 
 * The catchAttributeDef() handles the DTD attribute definition callbacks
 * in the from the header of the XML file. This is used for the ID/IDREF
 * handeling of the shredder.
 */
void catchAttributeDef(	void *ctx,
		const xmlChar *elem,
		const xmlChar *fullname,
		int type,
		int def,
		const xmlChar *defaultValue,
		xmlEnumerationPtr tree) {
	(void)ctx;
	(void)def; /* XML_ATTRIBUTE_(NONE|REQUIRED:IMPLIED) */
	(void)*defaultValue;
	(void)tree;
	specAttrDbStr* adb = &SHREDCTX(ctx)->specAttrDb;

	switch(type) {
	 case XML_ATTRIBUTE_ID:
	 case XML_ATTRIBUTE_IDREF:
	 case XML_ATTRIBUTE_IDREFS:
	 	if ( insertAttrDB(adb,(char*)elem,(char*)fullname,type) < 0 ) {
			BAILOUT(ctx);
		}
		break;
	}
}

int handleExternalSubset(shredCtxStruct* shredCtx, xmlDtdPtr dtd) {
	struct _xmlNode *p = dtd->children;

	while( p ) {
	   if ( p->type == XML_ATTRIBUTE_DECL ) {
	   	xmlAttributePtr ap = (xmlAttributePtr)p;

		switch( ap->atype ) {
		 case XML_ATTRIBUTE_ID:
		 case XML_ATTRIBUTE_IDREF:
		 case XML_ATTRIBUTE_IDREFS:
	 		if ( insertAttrDB(&shredCtx->specAttrDb,(char*)ap->elem,(char*)ap->name,ap->atype) < 0 ) {
				return -1;
			}
			break;
		 default:
		 	break; /* ignore */
	        }
	    }
	    p = p->next;
	}
	return 1;
}

void catchExternalSubset(
		void *ctx,
		const xmlChar * name, 
		const xmlChar * ExternalID, 
		const xmlChar * SystemID) {
	(void)name;
#ifdef ADB_DEBUG
	stream_printf(GDKout,"catchExternalSubset(ctx,%s,%s,%s)\n",name,ExternalID,SystemID);
#endif
	if ( ExternalID || SystemID ) {
		/* INCOMPLETE, this part only works with absolute filenames or
		 * files located in the current working directory! A bit more
		 * inteligence could be applied here.
	 	 */
		xmlDtdPtr dtd;

		if ( (dtd=xmlParseDTD(ExternalID,SystemID)) ) {
			if ( !handleExternalSubset(SHREDCTX(ctx),dtd) )
			    GDKwarning("shredder.mx:catchExternalSubset: WARNING: xmlParseDTD(\"%s\") SUBSET HANDLING FAILED, NO ID/IDREF QUERIES\n",SystemID);
			xmlFreeDtd(dtd);
		} else {
			GDKerror("shredder.mx:catchExternalSubset: WARNING: xmlParseDTD(\"%s\") FAILED, NO ID/IDREF QUERIES\n",SystemID);
			GDKerror("shredder.mx:catchExternalSubset: NOTE   : maybe using absolute filenames works, sorry!\n");
			BAILOUT(ctx);
		}
	}
}

/* libxml2 SAX2 version for the startElement construction */
static void my_startElementNsSAX2Func(
		void * ctx, 
		const xmlChar * localname, 
		const xmlChar * prefix, 
		const xmlChar * URI, 
		int nb_namespaces, 
		const xmlChar ** namespaces, 
		int nb_attributes, 
		int nb_defaulted, 
		const xmlChar ** attributes) {
	(void)nb_namespaces; 
	(void)namespaces; 
	shred_start_element(ctx,URI,prefix,localname,nb_attributes+nb_defaulted,attributes);
}

/* libxml2 SAX2 version for the endElement construction */
static void my_endElementNsSAX2Func(
	void * ctx, 
	const xmlChar * localname, 
	const xmlChar * prefix, 
	const xmlChar * URI) {
	(void)prefix;
	(void)URI;
	shred_end_element(ctx,localname /* unused byfunc */);
}


/**
 * SAX callback table.
 */
xmlSAXHandler shredder = {
    .startDocument         = shred_start_document
  , .endDocument           = shred_end_document
#if HAVE_SAX2
  , .startElement          = 0
  , .endElement            = 0
#else
  , .startElement          = shred_start_element4SAX1
  , .endElement            = shred_end_element
#endif
  , .characters            = shred_characters
  , .processingInstruction = shred_pi
  , .comment               = shred_comment
  , .error                 = 0
  , .cdataBlock            = shred_cdata
  , .internalSubset        = 0
  , .isStandalone          = 0
  , .hasInternalSubset     = 0
  , .hasExternalSubset     = 0
  , .resolveEntity         = 0
  , .getEntity             = 0
  , .entityDecl            = 0
  , .notationDecl          = 0
  , .attributeDecl         = catchAttributeDef
  , .elementDecl           = 0
  , .unparsedEntityDecl    = 0
  , .setDocumentLocator    = 0
  , .reference             = 0
  , .ignorableWhitespace   = 0
  , .warning               = 0
  , .fatalError            = 0
  , .getParameterEntity    = 0
  , .externalSubset        = catchExternalSubset /* catch this 1 and process */
#if HAVE_SAX2
  , .startElementNs	   = my_startElementNsSAX2Func
  , .endElementNs	   = my_endElementNsSAX2Func
  , .initialized           = XML_SAX2_MAGIC /* set this to zero for SAX1 */
#else
  , .initialized           = 0
#endif
};

/**
 * Main shredder driver handling the libxml2 and buffer stuff
 */
static int 
mainSHREDDER(shredCtxStruct* shredCtx, char* location, char* buffer)
{
    int wellFormed = 0;
    xmlParserCtxtPtr xmlCtx;

    /* this code is not really Unicode or multi-byte aware (yet) */
    assert (sizeof (char) == sizeof (xmlChar));

    /* allocate a buffer for TEXT nodes */
    shredCtx->content_buf = (char*) malloc(PFSHRED_STRLEN_MAX);
    assert(shredCtx->content_buf);

    /* allocate XML node stack */
    if (! (shredCtx->lifo = (node_t *) malloc ((xml_depth_max+1) * sizeof (node_t)))) {
        GDKerror("shredder.mx:mainSHREDDER: cannot allocate XML node stack: %s\n",
                 strerror (errno));

        return -1;
    }
    shredCtx->sp = 0; /* initialize stackpointer */
    shredCtx->err= 0;

    /* reset libxml2 error handling */
    xmlSetGenericErrorFunc (NULL, print_error);

    /* parse XML input (receive SAX events) */
    if ( strlen(location) == 0 ) {
        xmlCtx = xmlCreateMemoryParserCtxt(buffer, shredCtx->fileSize);
        if ( !xmlCtx ) {
            GDKerror("shred:mainSHREDDER: xmlCreateMemoryParserCtxt() failed\n");
            return -1;
        }
    } else if ( !isURL(location) ) {
        if ( !(xmlCtx = xmlCreateFileParserCtxt (location)) ) {
            GDKerror("shred:mainSHREDDER: xmlCreateFileParserCtxt(\"%s\") failed\n",location);
            return -1;
        }
    } else {
#if HAVE_SAX2
        if ( !(xmlCtx = xmlCreateURLParserCtxt (location, 0)) ) {
            GDKerror("shred:mainSHREDDER: xmlCreateURLParserCtxt(\"%s\") failed\n",location); 
            return -1;
        }
#else
	GDKerror("shred:mainSHREDDER: xmlCreateURLParserCtxt() not set. Configure HAVE_SAX2 for this.\n");
	return -1;
#endif
    }
    xmlCtx->sax        = &shredder;
    xmlCtx->_private = shredCtx; /* set the SHREDCTX() value */
    xmlSwitchEncoding (xmlCtx, XML_CHAR_ENCODING_UTF8);

    /* The good old xmlParseDocument() works without complaining! */
    (void) xmlParseDocument (xmlCtx);
    wellFormed = xmlCtx->wellFormed;
    xmlCtx->sax      = NULL; /* avoid double free() */
    xmlCtx->_private = NULL; /* avoid double free() */
    xmlFreeParserCtxt(xmlCtx);

    /* free the TEXT buffer */
    free(shredCtx->content_buf);

    /* Check if something has gone wrong durin shred */
    if ( shredCtx->err ) {
        return -1;
    }
    if (! wellFormed) {
        GDKerror("shredder.mx:mainSHREDDER: XML input not well-formed.\n");
        return -1;
    }
    return 1;
}

@c
/* vim:set shiftwidth=4 expandtab: */
