@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2006 University of Konstanz.  All Rights Reserved.

@f pf_support
@a Stefan Manegold
@v 1.0
@t MIL primitives to support the XQuery front-end "Pathfinder"

@* Introduction
This module provides new MIL primitives to support the XQuery
implementation on top of MonetDB within the "Pathfinder" project.
@
@* Module Definition 
@m
.MODULE pf_support;

.USE malalgebra;
.USE lock;
.USE monettime;

@- XML shredder (shredder.mx)
@m
.COMMAND shred2bats(str location, str buffer, str opt) : BAT[oid, bat] = CMDshred2bats;
"PARAMETERS:
location - if this parameter contains some value, the document locates at this location is shredded. The content of the seconde parameter \"buffer\", if any, is discarded.
buffer - if the first parameter \"location\" doesn't contain any value, this parameter should point to a character array, which will then be shredded.
opt - options
DESCRIPTION:
C implementation of the document shredder"

@- XML print functions (serialize.mx)
@m
.COMMAND print_result(str mode, BAT[oid,bat] ws,
                      BAT[oid,any] loop, BAT[void,oid] iter,
                      BAT[void,oid] item, BAT[void,int] kind, 
                      BAT[oid,lng] int_values, BAT[oid,dbl] dbl_values, BAT[oid,str] str_values) : void = xquery_print_result_loop;
 "C interface to Workset result print routine, that can print multiple iters"

.COMMAND print_result(str,BAT[void,bat],BAT[void,oid],BAT[void,int],BAT[void,lng],BAT[void,dbl],BAT[void,dbl],BAT[void,str]) : void = xquery_print_result_main;
 "C interface to Workset result print routine"



@- Multi Join
@m
.COMMAND mposjoin( BAT[oid,oid] pre, BAT[oid,oid] frag, BAT[oid, bat] ws_item )
		: BAT[void,any] = CMDmposjoin;
"PARAMETERS:
BAT[oid,oid] - the values which have to be looked up
BAT[oid,oid] - the corresponding fragments in which the values have to be looked up
BAT[oid,BAT[oid,any]] - the list of bats where the values are looked up
All BAT-heads must be dense.
DESCRIPITON:
looks up the values in a list of bats. The first argument specifies the
value to be looked up (joined) and the second one saves which bat contains
the value (see also 'mvaljoin').
The result is a bat with the tail values from the batlist (any) and the same
void column like the first two arguments"

.COMMAND mvaljoin( BAT[oid,oid] pre, BAT[oid,oid] frag, BAT[oid, bat] ws_item )
		: BAT[oid,oid] = CMDmvaljoin;
"PARAMETERS:
BAT[oid,oid] - the values which have to be joined
BAT[oid,oid] - the corresponding fragments in which the values have to be looked up
BAT[oid,BAT[oid,oid]] - the list of bats where the tail values are joined
All BAT-heads must be dense.
DESCRIPITON:
joins the tail values of the first argument with the tail values of the bat
from one bat of the third argument. Which bat from the list is chosen is
specified by the second argument (see also 'mposjoin').
The result is a bat with the head values of the first two arguments in the head
and the head values from the batlist"


@- new algebraic primitives
@m
.COMMAND mark_grp( BAT[any::1,oid] b , BAT[oid,oid] g)
		: BAT[any::1,OID] = CMDmark_grp_1; 
"\"grouped mark\": Produces a new BAT with per group a locally unique dense
 ascending sequense of OIDs in the tail. The tail of the first BAT (b)
 identifies the group that each BUN of b belongs to. The second BAT (g)
 represents the group extend, i.e., the head is the unique list of group IDs
 from b's tail. The tail of g gives for each group the base value for the new
 OID sequence."

.COMMAND mark_grp( BAT[any::1,oid] b , BAT[oid,any] g, oid s)
		: BAT[any::1,OID] = CMDmark_grp_2; 
"\"grouped mark\": Produces a new BAT with per group a locally unique dense
 ascending sequense of OIDs in the tail. The tail of the first BAT (b)
 identifies the group that each BUN of b belongs to. The second BAT (g)
 represents the group extend, i.e., the head is the unique list of group IDs
 from b's tail. The third argument (s) gives the base value for the new
 OID sequence of each group."

.COMMAND merged_union( any left, any right, ..any.. )
		: BAT[void,BAT] = CMDmerged_union;
"PARAMETERS:
Even number of BAT[oid,any] with dense heads and pairs of equal tail type;
all odd BATs must be head-aligned and all even BATs must be head-aligned;
first two BATs must be sorted on tail values.
DESCRIPITON:
Merges pairs of bats according to the order as defined by the first pair's tails."
@(
"Returns the union of two *tail-sorted* BATs. All BUNs of both BATs appear
 in the result, i.e., duplicates are not eliminated. As opposed to standard
 "union", the sortedness on the tail column is maintained in the result and
 all BUNs in the result appear in the same order as in their respective
 input."
@)

.COMMAND ll_tokenize( BAT[void,str] strs, BAT[void,str] seps )
		: BAT[oid,str] = CMDll_strSplit;
"PARAMETERS:
BAT[void,str] - the strings which are going to be tokenized
BAT[void,str] - seperators for the strings
DESCRIPITON:
ll_tokenize is a special version of [split](bat(void,str),bat(void,str)), which
tokenizes a string using the aligned seperator string and adds a row for
each substring, with the oid of the input head identifying the original boundaries."

.COMMAND round_up(dbl x) : dbl = math_unary_up_ROUND;
"PARAMETERS:
dbl - the argument to round
DESCRIPTION:
round_up rounds to 0 digits after the point. The only difference to
round(dbl, 0) is that negative numbers with .5 are rounded up 
(e.g., round(-1.5) = -1.0)."

.COMMAND normSpace(str string)
		: str = CMDnormSpace;
"PARAMETERS:
BAT[void,str] - the strings which are going to be normalized
DESCRIPITON:
normSpace normalizes the whitespaces to a single space."

.COMMAND combine_text_string( BAT[void,oid] iter, BAT[void,oid] kind, BAT[void,str] str_value, int result_size )
		: BAT[oid,str] = CMDcombine_text_string;
"PARAMETERS:
BAT[void,oid] - iter values which have to be ordered
BAT[void,oid] - one of three different kinds (strings '2@0'; text-nodes '1@0' and other nodes '0@0')
BAT[void,str] - string values of the strings and text-nodes; an empty string for each other node
DESCRIPITON:
very specialized helper function for the translation of the item-sequence-to-node-sequence function in XQuery.
It expects three aligned columns and creates out of adjazent strings and text-nodes one string,
which can be translated into a text-node again. Every other node and every new iter divide the strings.
A space is inserted if two strings are adjazent and no space is inserted, if a text-node is in between. 
Empty strings are not added to the output."

.COMMAND string_join( BAT[oid,str] iter_str, BAT[oid,str] separator )
		: BAT[oid,str] = CMDstring_join;
"PARAMETERS:
BAT[oid,str] - sorted iters in the head, string values in the tail
BAT[oid,str] - separator which is added between strings, within an iter
DESCRIPITON:
string_join constructs for each iter one strings by appending the strings
with the separator for this iter in between."

.COMMAND enumerate( BAT[void,lng] startval, BAT[void,lng] length) : BAT[oid,lng] = CMDenumerate;
"PARAMETERS:
BAT[void,oid] - list of start values
BAT[void,oid] - list of length values
DESCRIPTION:
enumerate creates for each input row #length rows with the values beginning
at startval and increasing by one with every row."

.COMMAND ebv(BAT[oid, bit] b) : BAT[oid, bit] = CMDebv;
"PARAMETERS
BAT[oid, bit], sorted on head values.
DESCRIPTION:
This is a helper function to implement the XQuery ``effective boolean\n
value.'' Grouped by the head values, it will look at the tail values.\n
If for a head value there is exactly one BUN whose tail equals `true',\n
the result for this group will be `true' as well. In any other case\n
(a single `false' BUN, or multiple BUNs for this group), a `false'\n
tuple will be in the result for this group."

.COMMAND invalid_qname(BAT[any,str]) : str = CMDinvalid_qname;
"PARAMETERS
BAT[any, str] 
DESCRIPTION:
This is a helper function that tries to find an invalid qname
string. It returns the first invalid one it sees or str(nil) 
if all are ok." 

.COMMAND lastmod_time(str filename) : timestamp = CMDlastmod_time;
 "return the last modification time of a file"

@- Constant Columns

In XQuery, we often have the case that BAT[void,T] all contain the same tail value
'constant columns'. In this case, we represent the column variable by a MIL
constant. The new 'constant' MIL module mimicks the BAT algebra on such constants.

Regrettably, we cannot always represent constants as single MIL (non-bat) values.
Constants sometimes *need* to go into bats-of-bats. Particular cases in XQuery are 
the working set BAT[void,BAT] that contains a set of columns, and the result of staircase 
join (idem dito). 

Our solution here is to represent constant columns inside a bat of bats as a 'fake' 
BAT[void,T] with a single entry [nil,c].  The routines constant2bat/bat2constant switch
between the MIL constant and the 'fake' BAT[nil,c] representation (obviously, non-constant
bats are unaffected by these calls). The switching is done automatically when 
bats fetched from a bat-of-bats (using an overloaded fetch) and put into them (with
an overloaded insert).
@m
.COMMAND is_constant(any) : bit = CMDisFakeProject;
"checks whether the parameter is a BAT[nil,c] constant column"

.COMMAND constant2bat(any col) : bat[any,any] = CMDfakeProject;
"if a column is a MIL constant c, change it into a BAT[nil,c] constant column."

.COMMAND bat2constant(any col) : any = CMDdeFakeProject;
"convert BAT[nil,c] constant column into a simple MIL constant 'c'"

.COMMAND fetch(BAT[any,bat] b, int pos) : any = CMDfetchConvert;
"fetches a bat from a bat-of-bats, and if it is a fake-bat converts it to a MIL constant"

.COMMAND insert(BAT[any::1,bat] b, any::1 head, any tail) : BAT[any::1,bat] = CMDinsertConvert;
"insert into a bat-of-bats; if a non-bat tail is inserted, it is inserted as a fake-bat."

.COMMAND append(BAT[any::1,bat] b, any tail) : BAT[any::1,bat] = CMDappendConvert;
"append into a bat-of-bats; if a non-bat tail is appended, it is appended as a fake-bat."

@- Path steps (staircase join) 
@m
@:prec_foll(following)@
@:prec_foll(preceding)@

@= prec_foll
.COMMAND @1_void (BAT[void,int] pre_size,
               BAT[oid,any] ctx,
               BAT[void,oid] doc_pre,
	       int height,
               int upperbound) : BAT[oid,void] = PF@1_void;
"PARAMETERS
  pre_size: the complete size BAT (preorder rank, size)
  ctx: context node sequence (preorder rank, *)
  doc_pre: table of document fragments (doc id, preorder start value)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @1 axis from the given context."
@m
@:scj_cmd(descorself,descendant-or-self)@
@:scj_cmd(desc,descendant)@
@:scj_cmd(ancorself,ancestor-or-self)@
@:scj_cmd(anc,ancestor)@

@= scj_cmd
.COMMAND scj_@1(BAT[void,int] pre_size,
                BAT[oid,any] ctx,
                int height,
                int upperbound): BAT[oid,void] = PFscj_@1_void;
"PARAMETERS
  pre_size: the complete size BAT (preorder rank, size)
  ctx: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."
@m
@:ll_cmd(descendant)@
@:ll_cmd(descendant_or_self)@
@:ll_cmd(child)@

@= ll_cmd
.COMMAND ll_@1(BAT[oid,oid] iter,
                   BAT[oid,oid] ctx,
                   BAT[oid,int] pre_size,
                   BAT[void,oid] cands,
                   int height,
                   bit one_iter, bit one_ctx,
                   oid min_iter, oid max_iter,
                   bit no_iter_order): BAT[oid,oid] = PFll_@1;
"PARAMETERS:
BAT[void,oid] iter (grouping relation; sorted on tail within each ctx group)
BAT[void,oid] ctx (context set; sorted on tail)
BAT[void,int] pre_size (from the working set)
BAT[oid,oid]  cands (sorted list of result candidate OIDs in the tail)
int           height (height of the document)
bit           one_iter (only one iter?)
bit           one_ctx  (only one ctx node, i.e., the same for all iters?)
oid           min_iter,max_iter (smallest and largest iter id)
bit           no_iter_order (descendant & descendant_or_self, only: 
               result will be ordered on item, but not sub-ordered on iter)
DESCRIPITON:
returns all nodes on the @1 axis of the ctx-nodes duplicate free for each group."
@m
@:lev_cmd(child,child)@
@:lev_cmd(parent,parent)@
@:lev_cmd(fs,following-sibling)@
@:lev_cmd(ps,preceding-sibling)@

@= lev_cmd
.COMMAND lev_@1(BAT[void,chr] pre_level,
                BAT[oid,any] ctx,
		int height,
                int upperbound) : BAT[oid,void] = PFlev_@1;
"PARAMETERS
  pre_level: the complete level BAT (preorder rank, level)
  ctx: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."

@- bootstrap
@m
.COMMAND pflock() : lock = CMDpflock;
 "provide a pointer to the runtime lock"

.PRELUDE = pf_support_prelude;
.EPILOGUE = pf_support_epilogue;

.END pf_support;

@mil
module("xtables");
module("aggrX3");
module("bat_arith");
module("mmath");
module("pcre");

# global constants using in the MIL translation
const empty_bat := bat(void,oid,0).seqbase(0@0).access(BAT_READ);
const empty_kind_bat := bat(void,int,0).seqbase(0@0).access(BAT_READ);
const EMPTY_STRING := 0@0;
const empty_dbl__bat := bat(void,dbl,0).seqbase(0@0).access(BAT_READ);
const empty_dec__bat := empty_dbl__bat;
const empty_str__bat := bat(void,str,0).seqbase(0@0).access(BAT_READ);
const empty_int__bat := bat(void,lng,0).seqbase(0@0).access(BAT_READ);
const empty_bool__bat := bat(void,bit,0).seqbase(0@0).access(BAT_READ);
const bool_not := bat(void,oid,2).append(1@0).append(0@0).seqbase(0@0).access(BAT_READ);
const bool_values := bat(void,bit,2).append(false).append(true).seqbase(0@0).access(BAT_READ);

proc [bit](bat[any::1,str] b) : bat[any::1,bit]
{
    return [!=](b,"");
}

proc [bit](str b) : bit
{
    return !=(b,"");
}

proc castValues(bat[int,bat] tpe_vals, bat[void,any] _val, any item, any kind, any ipik, int tpe, str mil_tpe, str xq_tpe) : any {
    var _oid := empty_bat;
    tpe_vals@batloop() {
        var sel_oid := ipik;
        var sel_item := item;
        if (type(kind) = bat) {
            sel_oid := kind.ord_uselect($h).hmark(0@0);
            sel_item := sel_oid.leftfetchjoin(item);
        } else if (kind != $h) {
            sel_oid := empty_bat;
        }
        if (count(sel_oid) > 0) {
            sel_item := [*mil_tpe](sel_item.leftfetchjoin($t));
            if (count(_oid) > 0) {
                var res_mu := merged_union(_oid, sel_oid, _val, sel_item);
                _oid := res_mu.fetch(0);
                _val := res_mu.fetch(1);
            } else {
                _oid := sel_oid;
                _val := sel_item;
            }
        }
     }
     if (_val.texist(cast(nil,tpe)))
         ERROR ("err:FORG0001: could not cast value to %s.", xq_tpe);
     return _val;
}

proc addValues(bat[void,any::1] container, any::1 delta) : oid
{
    container.append(delta);
    return container.reverse().find(delta);
}

proc addValues(bat[void,any::1] container, bat[oid,any::1] delta) : bat[oid,oid]
{
    container.append(delta);
    return delta.leftjoin(container.reverse());
}

proc mposjoin( BAT[oid,oid] pre, oid frag, BAT[oid, bat] ws_item ) : BAT[void,any] 
{
    return pre.leftfetchjoin(bat2constant(ws_item.find(frag)));
}

proc mvaljoin( BAT[oid,oid] pre, oid frag, BAT[oid, bat] ws_item ) : BAT[oid,oid] 
{
    return pre.leftjoin(ws_item.find(frag).reverse());
}

proc tmark_unique( any::1 col, BAT[void,any] ipik) : BAT[oid,oid]
{
    return bat(void,oid).append(reverse(ipik).fetch(0)).seqbase(0@0).access(BAT_READ);
}

proc tmark_unique( BAT[oid,any] col, BAT[oid,any] ipik) : BAT[oid,oid]
{
    return tmark(kunique(reverse(col)),0@0);
}

proc tmark_grp_unique( any iter, BAT[oid,any] ipik) : BAT[oid,oid]
{
    return ipik.mark(1@0);
}

proc tmark_grp_unique( BAT[any,any] iter, BAT[oid,any] ipik) : BAT[oid,oid]
{
    if (is_constant(iter)) return ipik.mark(1@0);
    return iter.mark_grp(iter.tunique(), 1@0);
}

PROC get_type (bat[void,int] kind, int type_) : bat[oid,void]
{
        return kind.[and](63).ord_uselect(type_); # 63 = 2^6 - 1
}

PROC get_type_node (bat[void,int] kind) : bat[oid,void]
{
        return kind.ord_uselect(NODE, int(nil));
}

PROC get_type_atomic (bat[void,int] kind) : bat[oid,void]
{
        return kind.ord_uselect(int(nil), ATOMIC);
}

PROC get_fragment (int kind) : oid
{
        return kind.>>(6).oid();
}

PROC get_fragment (bat[void,int] kind) : bat[void,oid]
{
        return kind.[>>](6).[oid]();
}

PROC set_kind (oid frag, int type_) : int
{
        return frag.int().<<(6).or(type_);
}

PROC set_kind (bat[void,oid] frag, int type_) : bat[void,int]
{
        return frag.[int]().[<<](6).[or](type_);
}

PROC get_types (bat[void,int] kind) : bat[void,int]
{
        return kind.[and](63); # 63 = 2^6 - 1
}


@- order-preserving xquery join with existential semantics

The below proc handles xquery theta-joins between l[oid,any::1] and r[oid,any::1]
(iter,value) combinations with a join predicate PRED = { LT, LE, EQ, GE, GT }.

The result are the [oid,oid] iter numbers that should be ordered on head, and within 
head on tail (hence the term 'htordered') to preserve proper xquery sequence order.

We may also get optional lx[void,any] and rx[void,any] bats that substitute the
head and tail result oid-s for something else (backmapping). These lx/rx are not always 
present though.  They are pushed inside the thetajoin when sampling indicates the result 
will become big, or when the any types are smaller than oid-s (thus always make the 
result smaller).  In this case it is better to go into the join with the substitution 
already performed.  In other cases, the  substitution is done after computing the join.

The join is *existential*, that is, each [iter_l,iter_r] is unique in the result,
and should be there iff there exists any [iter_l,v_l] and [iter_r,v_r] for which 
(v_l PRED v_r) holds. 

For equi-joins, we compute the full join and then eliminate
duplicate [oid,oid] combinations. Given the htordered result characteristic, this will 
use a merge-algorithm. However for <,>,<=,>= we even *avoid* duplicates by joining {min}(l) 
with {max}(r) for <,<= (and vice versa for >,>=). Note  that these {min}() and {max}() 
are also efficient as they also can use a merge-algorithm for aggregation.

For non-equi-joins, use use either sort-merge or nested-loop join. Note that the latter join 
does not require any reordering to achieve htordered-ness. This is a plus, but nested-loop is 
of course quadratic in complexity. On the other hand, non-equi-joins tend to be quadratic 
in their result size anyway. We check this using run-time sampling. Nested-loop is chosen if 
sampling indicates a large join result.

Finally, the theta-join is loop-lifted, in that it may be executed between two loop-lifted
expressions. In that case, only matching outer iterations (lo and ro) should be joined on value. 
In effect, it requires a join condition "(l_val PRED r_val) and (lo = ro)". As MonetDB cannot 
handle such multi-column theta-joins efficiently, the current solution exploits the fact
that the loop-lifted iterations appear contiguous in both inputs. Thus, each iteration
is a slice of both input BATs. We just go through all outer iterations, take slices, and
execute the join for corresponding iter slices on l and r; concatenating all results.
@mil
var samp256 := bat(void,lng,256LL);
{ var i := 0LL; while(i < 256LL) { samp256.append(i); i :+= 1LL; } samp256.seqbase(0@0); }

proc htordered_unique_thetajoin( int mode,
                                 bat[oid,any::1] l, bat[oid,any::1] r,
                                 any lx, any rx) : bat[any,any]
{
    var lcnt := int(l).count();
    var rcnt := int(r).count();
    if ((lcnt = 0LL) or (rcnt = 0LL))
        return bat(oid,oid,1LL).access(BAT_READ);

    if (not(ordered(l)) or not(ordered(r)))
        ERROR("htordered_unique_thetajoin(): ordered left and right head columns (iters) expected.\n");

    if (rcnt = 1LL) {
        # it is a selection; not a join
        var v := r.fetch(0);
        var t := r.reverse().fetch(0);
        var lo := (mode >= EQ).ifthenelse(v,cast(nil,ttype(l)));
        var hi := (mode <= EQ).ifthenelse(v,cast(nil,ttype(l)));
        var sel;
        if ((mode = GT) or (mode = LT)) {
            sel := l.ord_select(lo,hi).[!=](v).ord_uselect(true);
        } else {
            sel := l.ord_uselect(lo,hi);
        }
        if (type(lx) = bat) sel := reverse(reverse(sel).leftfetchjoin(lx));
        if (type(rx) = bat) t := rx.find(t);
        return sel.project(t);
    }
    if (lcnt = 1LL) {
        return reverse(htordered_unique_thetajoin(-(mode), r, l, rx, lx));
    }
    if (mode != EQ) {
        # try to reduce footprint, first:
        # join with lx/rx only if smaller than l/r
        if (type(lx) = bat) {
            if (htype(lx) <= sht) { l := reverse(leftfetchjoin(reverse(l),lx)); lx := nil; }
        }
        if (type(rx) = bat) {
            if (htype(rx) <= sht) { r := reverse(leftfetchjoin(reverse(r),rx)); rx := nil; }
        }
        # trick: as we eliminate double matches anyway, let's not generate them to start with
        # pumps are efficient because merge-based
        if ((mode = GT) or (mode = GE)) {
            l := {max}(l);
            r := {min}(r);
        } else {
            l := {min}(l);
            r := {max}(r);
        }
        var samp := [oid]([*](samp256, int(l).count()/256LL)).leftfetchjoin(l.reverse().mark(0@0).reverse());
        var res := nlthetajoin(samp, reverse(r), mode, int(r).count() * 64LL);
        if (((2LL * batsize(res) * int(l).count()) / (1LL + int(samp).count())) > mem_maxsize()) {
            var cnt := int(res).count(); res := nil;
            # if not done, yet, join with lx/rx
            if (type(lx) = bat) l := reverse(leftfetchjoin(reverse(l),lx));
            if (type(rx) = bat) r := reverse(leftfetchjoin(reverse(r),rx));
            # a large intermediate result is better handled with nested loop (no reordering necessary)
            return nlthetajoin(l, reverse(r), mode, ((cnt+cnt) / int(samp).count())*int(r).count());
        }
    }
    var join_order := leftthetajoin(l, reverse(r), mode);

    # avoid error (lng(max(bat(oid,oid))) = nil)
    if (join_order.count() = 0) { return join_order; }

    var snd_iter := join_order.reverse().mark(0@0).reverse();
    var fst_iter := join_order.mark(0@0).reverse();
    var sorting := fst_iter.CTrefine(snd_iter); # this may hurt
    if (lng(max(sorting)) != int(sorting).count()) {
        # the output of CTrefine allows to easily check if it is kunique
        sorting := sorting.reverse().kunique().reverse(); # merge-based kunique
    }
    join_order := join_order.fetch(sorting); # this may hurt as well
    # joins with lx/rx can only be done after the CTrefine() and kunique()
    if (type(lx) = bat) join_order := reverse(leftfetchjoin(reverse(join_order),lx));
    if (type(rx) = bat) join_order := leftfetchjoin(join_order,rx);
    return join_order;
}

proc log2(lng i) : int 
{
  var n := 0;
  while(i >= 1LL)  {
     i >>= 1; n :+= 1;
  }
  return n;
}

var lng_oid := ifthenelse(isnil(oid(LNG_MAX)),lng,oid);

# loop-lifted variant; lo and ro are the outer iteration numbers that should match
proc ll_htordered_unique_thetajoin( int mode,
                                    bat[oid,any::2] l, bat[oid,any::2] r,
                                    bat[void,oid] lo, bat[void,oid] ro,
                                    any lx, any rx) : bat[any,any]
{
    var lo_histo := histogram(lo), lr_histo := reverse(lo_histo);
    var ro_histo := histogram(ro), rr_histo := reverse(ro_histo);
    var li := 0LL, lp := 0LL, lc := count(int(lo_histo));
    var ri := 0LL, rp := 0LL, rc := count(int(ro_histo));
    var b := new(void,bat,min(lc,rc));
    var tpe := ttype(l);

    if (not(reverse(lo).ordered()) or not(reverse(ro).ordered()))
        ERROR("htordered_unique_thetajoin(): ordered left and right outer columns (iters) expected.\n");

    # in case of integer equi-join, we shift iter and value together in a lng and do a single join on that
    if ((mode = EQ) and or(or((tpe = int), (tpe = oid)), (tpe = lng)))  {
        var iter_max := 32;
        var combine := true;
        if ((tpe = lng) or (lng_oid = lng)) {
            iter_max := log2(lng(max(max(lr_histo),max(rr_histo))));
            combine := (iter_max + log2(lng(max(max(l),max(r))))) < 64;
        }
        if (combine) {
            lo := [lng](lo).access(BAT_WRITE); 
            ro := [lng](ro).access(BAT_WRITE); 
	    [:+=](lo, [<<]([lng](l.tmark(0@0)), iter_max)).access(BAT_READ);
	    [:+=](ro, [<<]([lng](r.tmark(0@0)), iter_max)).access(BAT_READ);
	    l := l.mark(0@0).leftfetchjoin(lo); 
	    r := r.mark(0@0).leftfetchjoin(ro); 
            return htordered_unique_thetajoin(EQ, l, r, lx, rx);
        }
    }

    # otherwise iterate over the outer scopes; execute the join only for a single outer iter at a time
    while((lp < lc) and (rp < rc)) {
        var lv := lr_histo.fetch(lp);
        var rv := rr_histo.fetch(rp);
        var ln := lng(lo_histo.fetch(lp));
        var rn := lng(ro_histo.fetch(rp));
        if (lv = rv) {
            # only join corresponding slices of l an r
            var bn := htordered_unique_thetajoin(mode, l.slice(li,li+ln-1), r.slice(ri,ri+rn-1), lx, rx);
            if (count(int(bn)) > 0LL) b.append(bn);
        }
        if (lv <= rv) { lp :+= 1; li :+= ln; }
        if (rv <= lv) { rp :+= 1; ri :+= rn; }
    }

    # concatenate all results
    if (count(int(b)) = 1LL) return b.fetch(0);
    var bn := bat(oid, oid, sum_lng([count]([int](b)))).access(BAT_WRITE);
    if (count(int(b)) > 0LL) [insert](const bn,b);
    return bn.access(BAT_READ);
}

@- loop-lifted staircase join
@mil
#############################################
# MIL WRAPPER for AXIS STEPS 
#
# In order to simplify the invocation of the axis steps functions, this
# interface provides...
# 

@(
@:step(descendant,descendant,scj_desc,,@:sizes_code@,,)@
@:step(descendant_or_self,descendant-or-self,scj_descorself,,@:sizes_code@,,)@
@)

@:wrap(descendant)@
@:wrap(descendant_or_self)@

@:step(ancestor,ancestor,scj_anc,,@:sizes_code@,,)@
@:step(ancestor_or_self,ancestor-or-self,scj_ancorself,,@:sizes_code@,,)@

@(
@:step(child,child,lev_child,@:level_intro@,@:level_code@,,)@
@)

@:wrap(child)@

@:step(parent,parent,lev_parent,@:level_intro@,@:level_code@,,)@
@:step(following_sibling,following-sibling,lev_fs,@:level_intro@,@:level_code@,,)@
@:step(preceding_sibling,preceding-sibling,lev_ps,@:level_intro@,@:level_code@,,)@
@:step(following,following,following_void,,@:sizes_code@,@:foll_prec_code@,@:doc_pre@)@
@:step(preceding,preceding,preceding_void,,@:sizes_code@,@:foll_prec_code@,@:doc_pre@)@

@= chk_order
	if ( and(order,1) = @2 ) {
		@3 := @3.chk_order(); # just in case...
		if ( not(ordered(reverse(@3))) ) {
			ERROR("@1: tail of @3 must be sorted!");
		}
	}
@
@= one_iter_many_items
	# 1 iter, n items
	one_iter := TRUE;
	@:chk_order(@1@2,0,item)@
	# =>  we don't need to sort the input
	order := or(order,1);
@
@= many_iters_one_item
	# n iters, 1 item 
	one_item := TRUE;
	@:chk_order(@1@2,1,iter)@
	# =>  we don't need to sort the input
	order := or(order,1);
@
@= descs_per_item
	# "descendant" / "descendant_or_self"
	# => result for a single item is a simple slice of cands
	var fst := item.fetch(@2);
	var lst := oid(int(fst) + pre_size.fetch(fst));
        fst := oid(int(fst) + skip_self);
	var item_descs := cands.ord_select(fst,lst).reverse().chk_order();
@
@= wrap
PROC @1 (BAT[oid,oid] iter, BAT[oid,oid] item, oid frag, BAT[oid,bat] ws, int order, BAT[void,oid] cands) : BAT[void,bat]
{
	var result := nil;
	var one_iter := FALSE;
	var one_item := FALSE;
	var min_iter := oid(nil);
	var max_iter := oid(nil);
	var skip_self := 1;
	if ( "@1" = "descendant_or_self" ) {
		skip_self := 0;
	}

	# check consistency
	if ( isnil(seqbase(iter)) or isnil(seqbase(item)) ) {
		ERROR("@1(0): heads of iter & item/ctx must not be NIL!");
	}
	if ( (count(iter) != count(item)) or (seqbase(iter) != seqbase(item)) ) {
		ERROR("@1(1): heads of iter & item/ctx must be aligned!");
	}
	if ( ((tail(cands) = "void") or (ttype(cands) = 0)) and isnil(seqbase(reverse(cands))) ) {
		ERROR("@1(2): tail of cands must not be NIL!");
	}
	@:chk_order(@1(3),0,iter)@
	@:chk_order(@1(4),1,item)@
	cands := cands.chk_order(); # just in case...
	if ( not(ordered(reverse(cands))) ) {
		ERROR("@1(5): tail of cands must be sorted!");
	}

	var pre_size := ws.fetch(PRE_SIZE).fetch(frag);
	var height   := ws.fetch(HEIGHT).fetch(frag);

	# trivial cases	
	if ( (count(item) = 0) or (count(cands) = 0) or (count(pre_size) = 0) ) {
		result := new(void,bat,2).seqbase(0@0)
		          .append(bat(void,oid,0).seqbase(0@0).access(BAT_READ))
		          .append(bat(void,oid,0).seqbase(0@0).access(BAT_READ))
		          .access(BAT_READ);
		return result;
	}
	
	# special cases
	if ( count(item) = 1 ) {
		# 1 iter, 1 item
		one_iter := TRUE;
		one_item := TRUE;
		if ( "@1" != "child" ) {
			# "descendant" / "descendant_or_self"
			# =>  result is a simple slice of cands
			@:descs_per_item(@1,0)@
			result := new(void,bat,2).seqbase(0@0)
			          .append(constant2bat(iter.fetch(0)))
			          .append(item_descs.mark(0@0).reverse())
			          .access(BAT_READ);
			return result;
		}
		# =>  we don't need to sort neither input nor output
		order := 3;
		iter := iter.chk_order(); # just in case...
		item := item.chk_order(); # just in case...
	} else {
	# first: try cheap min==max checks on ordered columns
	if ( ordered(reverse(iter)) and (min(iter) = max(iter)) ) {
		@:one_iter_many_items(@1,(6))@
	} else {
	if ( ordered(reverse(item)) and (min(item) = max(item)) ) {
		@:many_iters_one_item(@1,(7))@
	} else {
	# then: invest in one scan to check order to save two scans for min/max
	iter := iter.chk_order(); # just in case...
	if ( ordered(reverse(iter)) and (min(iter) = max(iter)) ) {
		@:one_iter_many_items(@1,(8))@
	} else {
	item := item.chk_order(); # just in case...
	if ( ordered(reverse(item)) and (min(item) = max(item)) ) {
		@:many_iters_one_item(@1,(9))@
	}}}}}

	min_iter := min(iter);
	max_iter := max(iter);

	# pre-sort input
	if ( and(order,1) = 0 ) {
		var ord := item.tsort();
		    ord := ord.CTrefine(iter).mark(0@0).reverse();
		iter := ord.leftfetchjoin(iter);
		item := ord.leftfetchjoin(item);
		iter := iter.chk_order();
		item := item.chk_order();
	}

	# the actual location step
	if ( isnil(result) ) {
		var res := ll_@1 (iter, item, pre_size, cands,
		                   height, one_iter, one_item, 
		                   min_iter, max_iter, (and(order,2) = 0));
		result := new(void,bat,2).seqbase(0@0)
		          .append(res.mark(0@0).reverse())
		          .append(res.reverse().mark(0@0).reverse())
		          .access(BAT_READ);
	}
	
	# post-sort output
	if ( (and(order,2) = 2) and not(ordered(reverse(result.fetch(1)))) ) {
		iter := result.fetch(0);
		item := result.fetch(1);
		var ord := item.tsort();
		    ord := ord.CTrefine(iter).mark(0@0).reverse();
		result := new(void,bat,2).seqbase(0@0)
		          .append(ord.leftfetchjoin(iter).chk_order())
		          .append(ord.leftfetchjoin(item).chk_order())
		          .access(BAT_READ);
	}
	
	# post-sort output
	if ( (and(order,2) = 0) and not(ordered(reverse(result.fetch(0)))) ) {
		iter := result.fetch(0);
		item := result.fetch(1);
		var ord := iter.tsort();
		    ord := ord.CTrefine(item).mark(0@0).reverse();
		result := new(void,bat,2).seqbase(0@0)
		          .append(ord.leftfetchjoin(iter).chk_order())
		          .append(ord.leftfetchjoin(item).chk_order())
		          .access(BAT_READ);
	}
	
	return result;
}
ADDHELP("@1", "tsheyar", "Sep 2004",
"PARAMETERS:\n\
BAT[void,oid] iter (grouping relation)\n\
BAT[void,oid] item (context set)\n\
oid frag (the current fragment of the ws)\n\
BAT[void,bat] ws (working set)\n\
int order (input & output order properties:\n\
           bit 0: input is sorted on iter(0) or item(1)\n\
           bit 1: output must be sorted on iter(0) or item(1))\n\
BAT[oid,oid] cands (sorted list of result candidate OIDs in the tail)\n\
DESCRIPITON:\n\
returns all nodes on the @1 axis of the ctx-nodes duplicate free for each group.",
"pf_support");
@
@
# use size concept
@= sizes_code
pre_sizes
@
# use level concept
@= level_intro
    var pre_levels := ws.fetch(PRE_LEVEL).fetch(frag);
@
@= level_code
pre_levels
@
# code for following and preceding steps
@= foll_prec_code
    # dirty code to make possible, that old scj still works
    var doc_pre;
    if (frag = 0@0)
        { doc_pre := ws.fetch(WS_FRAG); }
    else
        { doc_pre := bat(void,oid,1).seqbase(0@0).append(1@0).access(BAT_READ); }
@
@= doc_pre
doc_pre,
@

@= step
PROC @1(BAT[void,oid] iter, BAT[void,oid] ctx, oid frag, BAT[void,bat] ws, int order) : BAT[void,bat]
{
    # "order" is not (yet?) used, here.

    var pre_sizes := ws.fetch(PRE_SIZE).fetch(frag);
    @4
    var heights := ws.fetch(HEIGHT).fetch(frag);

    var unq := {count}(iter.reverse(), iter.tunique(),FALSE);

    var offset := 0;
    var ctx_slice;

    @6

    var res_iter, res_item;
    if (count(unq) = 1) {
        res_iter := constant2bat(unq.reverse().fetch(0));
	ctx_slice := ctx.reverse().project(nil);
	ctx_slice := ctx_slice.chk_order(); # have to check because step expects it sorted
        res_item := @3( @5, ctx_slice, @7 heights, pre_sizes.count()).hmark(0@0);
        res_item := res_item.chk_order();
    } else {
        res_iter := bat(void,oid);
        res_item := bat(void,oid);
        unq@batloop () {
            ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().project(nil);
            ctx_slice := ctx_slice.chk_order(); # have to check because step expects it sorted
            var res := @3( @5, ctx_slice, @7 heights, pre_sizes.count()).reverse();
            res := res.chk_order();
            res_item.append(res);
            var l := count(res);
            if (l <= $t) {
                res_iter.append(iter.slice(offset, offset + l - 1));
            } else {
                res_iter.append(res.project($h));
            }
            offset := offset + $t;
        }
        res_iter := res_iter.seqbase(0@0).access(BAT_READ).chk_order();
        res_item := res_item.seqbase(0@0).access(BAT_READ).chk_order();
    }
    return new(void,bat,2).seqbase(0@0)
           .append(res_iter)
           .append(res_item)
           .access(BAT_READ);
}
ADDHELP("@1", "tsheyar", "Sep 2004",
"PARAMETERS:\n\
BAT[void,any] iter (grouping relation)\n\
BAT[void,any] ctx (context set)\n\
oid frag (the current fragment of the ws)\n\
BAT[void,bat] ws (working set)\n\
DESCRIPITON:\n\
returns all nodes on the @2 axis of the ctx-nodes duplicate free for each group.",
"pf_support");
@

@mil
@:loop_lifted_scj_step1(ancestor)@
@:loop_lifted_scj_step1(ancestor_or_self)@

@:loop_lifted_scj_wrap1(child)@
@:loop_lifted_scj_wrap1(descendant)@
@:loop_lifted_scj_wrap1(descendant_or_self)@

@:loop_lifted_scj_step1(parent)@
@:loop_lifted_scj_step1(following)@
@:loop_lifted_scj_step1(following_sibling)@
@:loop_lifted_scj_step1(preceding)@
@:loop_lifted_scj_step1(preceding_sibling)@
@
#==================================================================
# expansions of the loop lifted scj
# kind argument
@= kind_args
, chr kind
@
@= kind_params
, kind
@
# tagname argument
@= ns_args
, str ns
@
@= ns_params
, ns
@
@= loc_args
, str loc
@
@= loc_params
, loc
@
@= tgt_args
, str tgt
@
@= tgt_params
, tgt
@
@= nsloc_args
, str ns, str loc
@
@= nsloc_params
, ns, loc
@
@= params2
, cands
@

# code for tagname testing
@= nsloc_post
 {
	var pre_frag := ws.fetch(PRE_FRAG).fetch(theFrag);
	if (is_constant(pre_frag)) {
		var frag := pre_frag.fetch(0);
		pre_frag := nil;
		var qn_nsloc := ws.fetch(QN_LOC_URI).fetch(frag);
		    qn_nsloc  := qn_nsloc.ord_uselect(loc+str('\1')+ns);
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		if (flt(count(pre_prop)) <= (1.1 * flt(count(result_part_item)))) {
			var pre_nsloc;
			if (count(qn_nsloc) = 1) {
				pre_nsloc := pre_prop.ord_uselect(qn_nsloc.reverse().fetch(0));
			} else {
				pre_nsloc := pre_prop.leftjoin(qn_nsloc);
			}
			pre_prop := nil;
			qn_nsloc := nil;
			tmp_res := result_part_item.leftjoin(pre_nsloc).hmark(0@0);
		} else {
			var res_prop := result_part_item.leftjoin(pre_prop);
			pre_prop := nil;
			tmp_res := res_prop.leftjoin(qn_nsloc).hmark(0@0);
		}
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		    pre_frag := pre_prop.mirror().leftfetchjoin(pre_frag);
		var res_prop := result_part_item.leftjoin(pre_prop);
		    pre_prop := nil;
		var res_frag := result_part_item.leftjoin(pre_frag);
		    pre_frag := nil;
		var X_res    := res_prop.hmark(0@0);
		var X_prop   := res_prop.tmark(0@0);
		    res_prop := nil;
		var X_frag   := res_frag.tmark(0@0);
		    res_frag := nil;
		var X_nsloc  := mposjoin(X_prop, X_frag, ws.fetch(QN_LOC_URI));
		    X_prop   := nil;
		    X_frag   := nil;
		var _X       := X_nsloc.ord_uselect(loc+str('\1')+ns).reverse();
		    X_nsloc  := nil;
		tmp_res := _X.leftfetchjoin(X_res).tmark(0@0);
	}
	@:mapping_code@
 }
@
@= loc_post
	@:ns_loc_post(qn,loc,QN,LOC,ELEMENT)@
@
@= ns_post
	@:ns_loc_post(qn,ns,QN,URI,ELEMENT)@
@
@= target_post
        @:ns_loc_post(prop,tgt,PROP,TGT,1)@
@( FIXME: '1' is used instead of PI because we skip the other kinds @)
@
@= ns_loc_post
 {
	var pre_frag := ws.fetch(PRE_FRAG).fetch(theFrag);
	if (is_constant(pre_frag)) {
		var frag := pre_frag.fetch(0);
		pre_frag := nil;
		var @1_@2 := ws.fetch(@3_@4).fetch(frag);
		    @1_@2 := @1_@2.ord_uselect(@2);
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		if (flt(count(pre_prop)) <= (1.1 * flt(count(result_part_item)))) {
			var pre_@2;
			if (count(@1_@2) = 1) {
				pre_@2 := pre_prop.ord_uselect(@1_@2.reverse().fetch(0));
			} else {
				pre_@2 := pre_prop.leftjoin(@1_@2);
			}
			pre_prop := nil;
			@1_@2 := nil;
			tmp_res := result_part_item.leftjoin(pre_@2).hmark(0@0);
		} else {
			var res_prop := result_part_item.leftjoin(pre_prop);
			pre_prop := nil;
			tmp_res := res_prop.leftjoin(@1_@2).hmark(0@0);
		}
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		    pre_frag := pre_prop.mirror().leftfetchjoin(pre_frag);
		var res_prop := result_part_item.leftjoin(pre_prop);
		    pre_prop := nil;
		var res_frag := result_part_item.leftjoin(pre_frag);
		    pre_frag := nil;
		var X_res    := res_prop.hmark(0@0);
		var X_prop   := res_prop.tmark(0@0);
		    res_prop := nil;
		var X_frag   := res_frag.tmark(0@0);
		    res_frag := nil;
		var X_@2     := mposjoin(X_prop, X_frag, ws.fetch(@3_@4));
		    X_prop   := nil;
		    X_frag   := nil;
		var _X       := X_@2.ord_uselect(@2).reverse();
		    X_@2     := nil;
		tmp_res := _X.leftfetchjoin(X_res).tmark(0@0);
	}
	@:mapping_code@
 }
@
@= kind_post
 {
	var pre_kind := ws.fetch(KIND_PRE + int(@1)).fetch(theFrag).reverse();
	tmp_res := result_part_item.leftjoin(pre_kind).hmark(0@0);
	pre_kind := nil;
	@:mapping_code@
 }
@
@= mapping_code
	result_part_iter := tmp_res.leftfetchjoin(result_part_iter);
	result_part_item := tmp_res.leftfetchjoin(result_part_item);
	tmp_res := nil;
@
@= shrink_code
 {
	if ( (count(cands) > 0) and (count(result_part_item) > 0) ) {
		var min_cand := min(cands);
		var min_item := min(result_part_item);
		if ( min_cand < min_item ) {
			cands := cands.ord_select(min_item,oid(nil));
		}
	}
	if ( (count(cands) > 0) and (count(result_part_item) > 0) ) {
		var max_cand := max(cands);
		var max_item := max(result_part_item);
		if ( max_cand < max_item ) {
			tmp_res := result_part_item.ord_uselect(oid(nil),max_cand).hmark(0@0);
			@:mapping_code@
		}
	}
 }
@
@= no_pre
	cands := ws.fetch(PRE_SIZE).fetch(theFrag).project().reverse();
	cands := cands.chk_order();
@
@= kind_pre
	cands := ws.fetch(KIND_PRE + int(@1)).fetch(theFrag);
	cands := cands.chk_order();
	@:shrink_code@
@
@= nsloc_pre
 {
	var pre_frag := ws.fetch(PRE_FRAG).fetch(theFrag);
	if (is_constant(pre_frag)) {
		var frag := pre_frag.fetch(0);
		pre_frag := nil;
		var qn_nsloc := ws.fetch(QN_LOC_URI).fetch(frag);
		    qn_nsloc := qn_nsloc.ord_uselect(loc+str('\1')+ns);
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		if (count(qn_nsloc) = 1) {
			cands := pre_prop.ord_uselect(qn_nsloc.reverse().fetch(0)).project().reverse();
                        if ( not(ordered(reverse(cands))) ) {
                                printf("= nsloc_pre(1): cands not ordered on tail.\n");
                        }
		} else {
			cands := pre_prop.leftjoin(qn_nsloc).sort().project().reverse();
		}
		pre_prop := nil;
		qn_nsloc := nil;
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		    pre_frag := pre_prop.mirror().leftfetchjoin(pre_frag);
		var X_pre    := pre_prop.hmark(0@0);
		var X_prop   := pre_prop.tmark(0@0);
		    pre_prop := nil;
		var X_frag   := pre_frag.tmark(0@0);
		    pre_frag := nil;
		var X_nsloc  := mposjoin(X_prop, X_frag, ws.fetch(QN_LOC_URI));
		    X_prop   := nil;
		    X_frag   := nil;
		var _X       := X_nsloc.ord_uselect(loc+str('\1')+ns).reverse();
		    X_nsloc  := nil;
		cands := _X.leftfetchjoin(X_pre); #.reverse().sort().reverse()
                if ( not(ordered(reverse(cands))) ) {
                        printf("= nsloc_pre(3): cands not ordered on tail.\n");
                }
	}
	cands := cands.chk_order();
        if ( not(ordered(reverse(cands))) ) {
                printf("= nsloc_pre(4): cands not ordered on tail.\n");
        }
	@:shrink_code@
 }
@
@= loc_pre
	@:ns_loc_pre(qn,loc,QN,LOC,ELEMENT)@
@
@= ns_pre
	@:ns_loc_pre(qn,ns,QN,URI,ELEMENT)@
@
@= target_pre
	@:ns_loc_pre(prop,tgt,PROP,TGT,1)@ 
@( FIXME: '1' is used instead of PI because we skip the other kinds @)
@
@= ns_loc_pre
 {
	var pre_frag := ws.fetch(PRE_FRAG).fetch(theFrag);
	if (is_constant(pre_frag)) {
		var frag := pre_frag.fetch(0);
		pre_frag := nil;
		var @1_@2 := ws.fetch(@3_@4).fetch(frag);
		    @1_@2 := @1_@2.ord_uselect(@2);
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		if (count(@1_@2) = 1) {
			cands := pre_prop.ord_uselect(@1_@2.reverse().fetch(0)).project().reverse();
                        if ( not(ordered(reverse(cands))) ) {
                                printf("= ns_loc_pre(1): cands not ordered on tail.\n");
                        }
		} else {
			cands := pre_prop.leftjoin(@1_@2).sort().project().reverse();
		}
		pre_prop := nil;
		@1_@2 := nil;
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		    pre_frag := pre_prop.mirror().leftfetchjoin(pre_frag);
		var X_pre    := pre_prop.hmark(0@0);
		var X_prop   := pre_prop.tmark(0@0);
		    pre_prop := nil;
		var X_frag   := pre_frag.tmark(0@0);
		    pre_frag := nil;
		var X_@2     := mposjoin(X_prop, X_frag, ws.fetch(@3_@4));
		    X_prop   := nil;
		    X_frag   := nil;
		var _X       := X_@2.ord_uselect(@2).reverse();
		    X_@2     := nil;
		cands := _X.leftfetchjoin(X_pre); #.reverse().sort().reverse()
                if ( not(ordered(reverse(cands))) ) {
                        printf("= ns_loc_pre(3): cands not ordered on tail.\n");
                }
	}
	cands := cands.chk_order();
        if ( not(ordered(reverse(cands))) ) {
                printf("= ns_loc_pre(4): cands not ordered on tail.\n");
        }
	@:shrink_code@
 }
@

# expanding the scj for the different tests
@= loop_lifted_scj_wrap1
@:loop_lifted_scj_wrap_pre(@1)@
@
@= loop_lifted_scj_wrap_pre
@:loop_lifted_scj_step2(@1,,,,,                                             @:params2@,@:no_pre@        )@
@:loop_lifted_scj_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@,, @:params2@,@:kind_pre(kind)@)@
@:loop_lifted_scj_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,,@:params2@,@:nsloc_pre@     )@
@:loop_lifted_scj_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,,   @:params2@,@:ns_pre@        )@
@:loop_lifted_scj_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,,  @:params2@,@:loc_pre@       )@
@:loop_lifted_scj_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,,  @:params2@,@:target_pre@    )@
@
@= loop_lifted_scj_wrap_post
@:loop_lifted_scj_step2(@1,,,,,                                                               @:params2@,@:no_pre@)@
@:loop_lifted_scj_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@, @:kind_post(kind)@,@:params2@,@:no_pre@)@
@:loop_lifted_scj_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,@:nsloc_post@,     @:params2@,@:no_pre@)@
@:loop_lifted_scj_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   @:ns_post@,        @:params2@,@:no_pre@)@
@:loop_lifted_scj_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  @:loc_post@,       @:params2@,@:no_pre@)@
@:loop_lifted_scj_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  @:target_post@,    @:params2@,@:no_pre@)@
@
@= loop_lifted_scj_step1
@:loop_lifted_scj_step2(@1,,,,,,                                                               )@
@:loop_lifted_scj_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@, @:kind_post(kind)@,,)@
@:loop_lifted_scj_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,@:nsloc_post@     ,,)@
@:loop_lifted_scj_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   @:ns_post@        ,,)@
@:loop_lifted_scj_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  @:loc_post@       ,,)@
@:loop_lifted_scj_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  @:target_post@    ,,)@
@
#==================================================================
# actual definition of the scj proc
@= loop_lifted_scj_per_frag
	result_part_iter := result_part_iter.chk_order();
	result_part_item := result_part_item.chk_order();
        result_part_frag := nil;

	# pre-test
	@4

        var result := @1 (result_part_iter, result_part_item, theFrag, ws, order @3);
	result_part_iter := result.fetch(0);
	result_part_item := result.fetch(1);
        result_part_frag := constant2bat(theFrag);
	cands := nil;

	# post-test
	@2
@
@= loop_lifted_scj_step2
proc loop_lifted_@1_step@2 (bat[void, oid] iter, bat[void, oid] item, bat[void, oid] frag, bat[void, bat] ws @3) : bat[void,bat]
{
     return loop_lifted_@1_step@2 (iter, item, frag, ws, 0 @4);
}
proc loop_lifted_@1_step@2 (bat[void, oid] iter, bat[void, oid] item, bat[void, oid] frag, bat[void, bat] ws, int order @3) : bat[void,bat]
{
    # handle empty results correctly
    if (iter.count() = 0) {
	var empty := bat(void,oid,0).seqbase(0@0).access(BAT_READ);
	return bat(void,bat,3).seqbase(0@0)
			    .append(empty)
			    .append(empty)
			    .append(empty)
			    .access(BAT_READ);
    }

    var result;
    var result_iter;
    var result_item;
    var result_frag;
    var tmp_res;
    var cands;

    var uniqueFrag := frag.tunique().sort();
    var theFrag := uniqueFrag.reverse().fetch(0);
    if (uniqueFrag.count() = 1) {
        var result_part_frag := oid(nil);
        var result_part_iter := iter;
        var result_part_item := item;

        @:loop_lifted_scj_per_frag(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_frag := result_part_frag;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_frag := nil;
    } else {
        var result_part_frag := frag.ord_uselect(theFrag).hmark(0@0);
        var result_part_iter := result_part_frag.leftfetchjoin(iter);
        var result_part_item := result_part_frag.leftfetchjoin(item);

        @:loop_lifted_scj_per_frag(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_frag := result_part_frag;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_frag := nil;

        var res_mu;
	uniqueFrag.slice(1,uniqueFrag.count() - 1)@batloop () {
	    theFrag := $h;
            result_part_frag := frag.ord_uselect(theFrag).hmark(0@0);
            result_part_iter := result_part_frag.leftfetchjoin(iter);
            result_part_item := result_part_frag.leftfetchjoin(item);

            @:loop_lifted_scj_per_frag(@1,@5,@6,@7)@

            if ( and(order,2) = 2 )
            {
                res_mu := merged_union(result_item, result_part_item,
                                       result_iter, result_part_iter,
                                       result_frag, result_part_frag);
                result_part_iter := nil;
                result_part_item := nil;
                result_part_frag := nil;
                result_item := res_mu.fetch(0);
                result_iter := res_mu.fetch(1);
                result_frag := res_mu.fetch(2);
                res_mu := nil;
            }
            else
            {
                res_mu := merged_union(result_iter, result_part_iter,
                                       result_item, result_part_item,
                                       result_frag, result_part_frag);
                result_part_iter := nil;
                result_part_item := nil;
                result_part_frag := nil;
                result_iter := res_mu.fetch(0);
                result_item := res_mu.fetch(1);
                result_frag := res_mu.fetch(2);
                res_mu := nil;
            }
        }
    }
    
    result_iter.access(BAT_READ);
    result_item.access(BAT_READ);
    result_frag.access(BAT_READ);
    var result_scj := bat(void,bat,3).seqbase(0@0);
    result_scj.append(result_iter);
    result_scj.append(result_item);
    result_scj.append(result_frag);

    return result_scj.access(BAT_READ);
}
@

@* Module Implementation
@h
#ifndef PF_SUPPORT_H
#define PF_SUPPORT_H

#include <monet.h>
#include "pathfinder.h"
#include "pf_support.proto.h"
#include <monet_interpreter.h>
#include <monettime.h>

#endif
@c
#include "pathfinder.h"
#include "pf_support.h"
#include <gdk_scanselect.h> /* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include <algebra.h> /* needed for result size estimation in CMDenumerate */
#include <math.h> /* needed for round_up */
#if SIZEOF_OID == SIZEOF_INT
#define oidoid_bunfastins(b,h,t) intint_bunfastins(b,h,t);
#define oidoid_bunfastins_nocheck_noinc(b,p,h,t) intint_bunfastins_nocheck_noinc(b,p,h,t);
#else
#define oidoid_bunfastins(b,h,t) lnglng_bunfastins(b,h,t);
#define oidoid_bunfastins_nocheck_noinc(b,p,h,t) lnglng_bunfastins_nocheck_noinc(b,p,h,t);
#endif
@c
int 
CMDisFakeProject(bit *r, ptr v, int tpe) {
	*r = (tpe == TYPE_bat)?is_fake_project((BAT*) v):1;
	return GDK_SUCCEED;
}

int
CMDfakeProject(BAT **res, ptr val, int tpe) 
{
	assert(val);
	if (tpe == TYPE_bat) {
		*res = (BAT*) val;
		BBPfix((*res)->batCacheid);
		return GDK_SUCCEED;
	}
	*res = BATnew(TYPE_void, tpe, 1);
	if (*res) {
		if (BUNappend(*res, val, FALSE)) return GDK_SUCCEED;
		BBPreclaim(*res);
	}
	return GDK_FAIL;
}

#include <constant.proto.h> /* for CMDconstCopy */

int
CMDdeFakeProject(ptr ret, int *tpe, ptr val, int t) 
{
	if (t == TYPE_bat) {
		BAT *b = (BAT*) val;
		if (!is_fake_project(b)) {
			*tpe = TYPE_bat;
			*(BAT**) ret = b;
			BBPfix(b->batCacheid);
			return GDK_SUCCEED;
		}
		val = BUNtail(b, BUNfirst(b));
		t = ATOMtype(b->ttype);
	} 
	return CMDconstCopy(ret, val, *tpe = t);
}

int
CMDfetchConvert(ptr res, int *tpe, BAT* b, int* pos) 
{
	int ret = GDK_FAIL;
	if (*pos >= 0 || ((size_t) *pos) < BATcount(b)) {
		bat bid = *(bat*) BUNtail(b, BUNptr(b, BUNindex(b, BUNfirst(b))+*pos));
		int fix = BBPfix(bid);
		BAT *bn = NULL;
		if (fix == 0 || (bn=BBPdescriptor(bid)) == NULL) {
			if (fix) BBPunfix(bid);
			GDKerror("fetch(%s) illegal BAT at position %d.\n", BBP_logical(b->batCacheid), *pos); 
		} else if (is_fake_project(bn)) {
			ret = CMDconstCopy(res, BUNfirst(bn), *tpe = ATOMtype(bn->ttype));
			BBPunfix(bid);
		} else {
			ret = GDK_SUCCEED;
			*(BAT**)res = bn;
			*tpe = TYPE_bat;
		}
	} else {
		GDKerror("fetch(%s) illegal position %d.\n", BBP_logical(b->batCacheid), *pos); 
	}
	return ret;
}

int
CMDinsertConvert(BAT** res, BAT *b, ptr h, ptr t, int tpe) 
{
	int ret = GDK_FAIL;
	BAT *bn = NULL;
	assert(h);
	assert(t);
	if (CMDfakeProject(&bn, t, tpe) == GDK_SUCCEED) {
		if (BUNins(*res = b, BAThtype(b) == TYPE_bat ? (ptr) &((BAT *) h)->batCacheid : h, &bn->batCacheid, FALSE)) {
			BBPfix(b->batCacheid);
			ret = GDK_SUCCEED;
		}
		BBPunfix(bn->batCacheid);
	}
	return ret;
}

int
CMDappendConvert(BAT** res, BAT *b, ptr t, int tpe) 
{
	int ret = GDK_FAIL;
	BAT *bn = NULL;

	assert(t);
	if (CMDfakeProject(&bn, t, tpe) == GDK_SUCCEED) {
		if (BUNappend(*res = b, &bn->batCacheid, FALSE)) {
			BBPfix(b->batCacheid);
			ret = GDK_SUCCEED;
		}
		BBPunfix(bn->batCacheid);
	}
	return ret;
}

@= mark_grp_init
	BUN w;

	BUNfnd@1(w, g, (ptr)&v);
	if (w) {
		n = *(oid*) BUNtloc(g, w);
	} else {
		n = oid_nil;
	}
@
@= mark_grp_loop4
	oid u = oid_nil;
	oid n = oid_nil;
	BATloopFast(b, p, q, xx) {
		oid v = *(oid*)BUNt@2(b, p);

		if (v != u) {
			@3
			u = v;
		} else if (n != oid_nil) {
			n++;
		}
		anyoid_bunfastins_nocheck_noinc(bn, r, BUNh@1(b, p), &n);
		r += yy; 
	}
@
@= mark_grp_loop3
	BATloopFast(b, p, q, xx) {
		oid n = oid_nil;
		BUN w;
		ptr v = BUNt@2(b, p);

		BUNfnd@3(w, gc, v);
		if (w) {
			oid *m = (oid*) BUNtloc(gc, w);
			if (*m != oid_nil) {
				n = (*m)++;
			}
		}
		anyoid_bunfastins_nocheck_noinc(bn, r, BUNh@1(b, p), &n);
		r += yy; 
	}
@
@= mark_grp_loop2
	if (gc) {
		if (BAThdense(gc)) {
			@:mark_grp_loop3(@1,@2,VOID)@
		} else {
			@:mark_grp_loop3(@1,@2,OID)@
		}
	} else {
		if (s) {
			@:mark_grp_loop4(@1,@2,n = *s;,s);
		} else {
			if (BAThdense(g)) {
				@:mark_grp_loop4(@1,@2,@:mark_grp_init(VOID)@,VOID);
			} else {
				@:mark_grp_loop4(@1,@2,@:mark_grp_init(OID)@,OID);
			}
		}
	}
@
@= mark_grp_loop1
	if (b->ttype==TYPE_void) {
		@:mark_grp_loop2(@1,var)@
	} else {
		@:mark_grp_loop2(@1,loc)@
	}
@
@= mark_grp_loop
{	BUN p, q, r = BUNfirst(bn);
	int xx, yy = BUNsize(bn);
	if (b->hvarsized) {
		@:mark_grp_loop1(var)@
	} else {
		@:mark_grp_loop1(loc)@
	}
	bn->batBuns->free = r - bn->batBuns->base;
	BATsetcount(bn, BATcount(b));
}
@
@c
static BAT *BATmark_grp( BAT *b, BAT *g, oid *s )
{
        BAT *bn, *gc = NULL;
        bit trivprop = FALSE;
 
        BATcheck(b, "BATmark_grp");
        BATcheck(g, "BATmark_grp");
	ERRORcheck((b->ttype!=TYPE_void) && (b->ttype!=TYPE_oid),
	           "BATmark_grp: tail of BAT b must be oid.\n");
	ERRORcheck((g->htype!=TYPE_void) && (g->htype!=TYPE_oid),
	           "BATmark_grp: head of BAT g must be oid.\n");
	ERRORcheck((b->ttype==TYPE_void) && (b->tseqbase==oid_nil),
	           "BATmark_grp: tail of BAT b must not be nil.\n");
	ERRORcheck((g->htype==TYPE_void) && (g->hseqbase==oid_nil),
	           "BATmark_grp: head of BAT g must not be nil.\n");
	ERRORcheck(s && (*s == oid_nil),
	           "BATmark_grp: base oid s must not be nil.\n");
	ERRORcheck(!s && (g->ttype!=TYPE_oid),
	           "BATmark_grp: tail of BAT g must be oid.\n");

	if (BATcount(b) == 0 || BATcount(g) == 1) {
		if (s) {
			return BATmark(b, *s);
		} else {
			return BATmark(b, *(oid*)BUNtloc(g, BUNfirst(g)));
		}
	}

	if (!BATtordered(b)) {
		if (s) {
			BUN p, q, r;
			int xx, yy;
			if (BAThdense(g)) {
				gc = BATnew(TYPE_void, TYPE_oid, BATcount(g));
				if (gc == NULL) return NULL;
				r = BUNfirst(gc);
				yy = BUNsize(gc);
				BATloopFast(g, p, q, xx) {
					voidoid_bunfastins_nocheck_noinc(gc, r, NULL, s); 
					r += yy; 
				}
			} else {
				gc = BATnew(TYPE_oid,  TYPE_oid, BATcount(g));
				if (gc == NULL) return NULL;
				r = BUNfirst(gc);
				yy = BUNsize(gc);
				BATloopFast(g, p, q, xx) {
					oidoid_bunfastins_nocheck_noinc(gc, r, BUNhloc(g, p), s); 
					r += yy; 
				}
			}
			gc->batBuns->free = r - gc->batBuns->base;
			BATsetcount(gc, BATcount(g));
			gc->hdense = BAThdense(g);
			if (BAThdense(gc)) {
				BATseqbase(gc, g->hseqbase);
				gc->hsorted = GDK_SORTED;
			} else {
				gc->hsorted = BAThordered(g);
			}
			BATkey(gc, TRUE);
		} else {
			gc = BATcopy(g, g->htype, g->ttype, TRUE);
			if (gc == NULL) return NULL;
		}
	}
	bn = BATnew(b->htype, TYPE_oid, BATcount(b));
	if (bn == NULL) {
		if (gc) BBPreclaim(gc);
		return NULL;
	}

	@:mark_grp_loop@

	trivprop = (BATcount(bn) < 2);
	ALIGNsetH(bn,b);
	bn->hsorted = (trivprop ? GDK_SORTED : BAThordered(b));
	bn->hdense = (trivprop ? TRUE : BAThdense(b));
	if (BAThdense(bn)) {
		BATseqbase(bn, b->hseqbase);
	}
	BATkey(bn, (b->hkey!=0));
	bn->tsorted = (trivprop ? GDK_SORTED : FALSE);
	bn->tdense = (trivprop ? TRUE : FALSE);
	if (BATtdense(bn)) {
		BATseqbase(BATmirror(bn), *(oid*)BUNtloc(bn, BUNfirst(bn)));
	}
	BATkey(BATmirror(bn), FALSE);

	if (gc) BBPreclaim(gc);
        return bn;
bunins_failed:
	if (gc) BBPreclaim(gc);
	BBPreclaim(bn);
	return NULL;
}

int CMDmark_grp_1( BAT** res, BAT *b, BAT *g )
{
	return (*res=BATmark_grp(b, g, NULL))?GDK_SUCCEED:GDK_FAIL;
}

int CMDmark_grp_2( BAT** res, BAT *b, BAT *g, oid *s)
{
	return (*res=BATmark_grp(b, g, s))?GDK_SUCCEED:GDK_FAIL;
}


static int 
merged_union( BAT** res, int nbats, BAT **b) 
{
	BAT *bn[MAXPARAMS>>1], *BN;
	BUN cur[MAXPARAMS], dst[MAXPARAMS>>1], DST;
	int bs[MAXPARAMS], bns[MAXPARAMS>>1], BS;
	size_t idx[MAXPARAMS], cnt[MAXPARAMS];
	int npairs = 1, i, j, k, any, b0 = -1, b1 = -1;
	bit concat = FALSE;
	chr *w = NULL;
	size_t sze = 0, h = 0;
	
	*res = NULL;

	/* check arguments */
	ERRORcheck(BATcount(b[0])>1 && !(BATtordered(b[0])&1), "merged_union: tail of first BAT must be sorted.\n");
	ERRORcheck(BATcount(b[1])>1 && !(BATtordered(b[1])&1), "merged_union: tail of second BAT must be sorted.\n");
	if (nbats&1) {
		GDKerror("merged_union: uneven number of BATs: %d.\n", nbats);
		return GDK_FAIL;
	}
	npairs = nbats>>1;

	for (i=0; i<nbats; i+=2) {
		bit ci, cj;
		j = i+1;
		ci = !is_fake_project(b[i]);
		cj = !is_fake_project(b[j]);
		if (ci && b0 < 0) {
			b0 = i;
		}
		if (cj && b1 < 0) {
			b1 = j;
		}
		if (ci && !BAThdense(b[i])) {
			GDKerror("merged_union: BAT %d must have a dense head.\n", i+1);
			return GDK_FAIL;
		}
		if (cj && !BAThdense(b[j])) {
			GDKerror("merged_union: BAT %d must have a dense head.\n", j+1);
			return GDK_FAIL;
		}
		if (ATOMtype(b[i]->ttype) != ATOMtype(b[j]->ttype)) {
			GDKerror("merged_union: BATs %d & %d must have the same tail types.\n", i+1, j+1);
			return GDK_FAIL;
		}
		if (ci && b0 >= 0 && b[i]->hseqbase != b[b0]->hseqbase) {
			GDKerror("merged_union: BAT %d must have the same hseqbase as BAT %d.\n", i+1, b0+1);
			return GDK_FAIL;
		}
		if (cj && b1 >= 0 && b[j]->hseqbase != b[b1]->hseqbase) {
			GDKerror("merged_union: BAT %d must have the same hseqbase as BAT %d.\n", j+1, b1+1);
			return GDK_FAIL;
		}
		if (ci && b0 >= 0 && BATcount(b[i]) != BATcount(b[b0])) {
			GDKerror("merged_union: BAT %d must have the same size as BAT %d.\n", i+1, b0+1);
			return GDK_FAIL;
		}
		if (cj && b1 >= 0 && BATcount(b[j]) != BATcount(b[b1])) {
			GDKerror("merged_union: BAT %d must have the same size as BAT %d.\n", j+1, b1+1);
			return GDK_FAIL;
		}
	}
	if (b0 < 0) {
		GDKerror("merged_union: at least one of the 'odd' BATs must be materialized, i.e., no 'fake_project'.\n");
		return GDK_FAIL;
	}
	if (b1 < 0) {
		GDKerror("merged_union: at least one of the 'even' BATs must be materialized, i.e., no 'fake_project'.\n");
		return GDK_FAIL;
	}

	/* create result BATs */

	sze = BATcount(b[b0]) + BATcount(b[b1]);
	BN = BATnew(TYPE_void, TYPE_bat, npairs);
	if (BN == NULL) {
		GDKerror("merged_union: BATnew(TYPE_void, TYPE_bat, %d) failed.\n", npairs);
		return GDK_FAIL;
	}
	for (k=0; k<npairs; k++) {
		i = k<<1;
		bn[k] = BATnew(TYPE_void, ATOMtype(b[i]->ttype), sze);
		if (bn[k] == NULL) {
			GDKerror("merged_union: BATnew(TYPE_void, %s, " SZFMT ") failed.\n", ATOMname(ATOMtype(b[i]->ttype)), sze);
			while (k>0) {
				BBPreclaim(bn[--k]);
			}
			BBPreclaim(BN);
			return GDK_FAIL;
		}
	}
	if (sze > 0) {
		w = (chr*)GDKmalloc(sze);
		if (w == NULL) {
			GDKerror("merged_union: GDKmalloc(" SZFMT ") failed.\n", sze);
			goto cleanup;
		}
	}

	/* do the merged_union */

	for (k=0; k<npairs; k++) {
		bns[k] = BUNsize(bn[k]);
		dst[k] = BUNlast(bn[k]);
	}
	for (i=0; i<nbats; i++) {
		if (is_fake_project(b[i])) {
			bs[i] = 0;
		} else {
			bs[i] = BUNsize(b[i]);
		}
		cur[i] = BUNfirst(b[i]);
		idx[i] = 0;
		if (i&1) {
			cnt[i] = BATcount(b[b1]);
		} else {
			cnt[i] = BATcount(b[b0]);
		}
	}
@= merged_union_0
	/*  @1: ATOMstorage(b[@3]->ttype) (chr, sht, int, flt, lng, dbl, any=b[@3]->ttype)
	 *  @2: tloc, tvar, tail
	 *  @3: 0, 1
	 *  @5: tail value comparison,
		e.g.,	simple_LE(BUN@2(b[0],cur[0]), BUN@2(b[1],cur[1]), @1)
		or	atom_GT(BUN@2(b[0],cur[0]), BUN@2(b[1],cur[1]), @1)
	 */
	/* copy tails from BAT @3 to the results; 
	   for each BUN, remember in w, whether it came from BAT 0 or BAT 1 */
	while ((idx[@3] < cnt[@3]) && (@4)) {
		void@1_bunfastins_nocheck_noinc(bn[0],dst[0],0,BUN@2(b[@3],cur[@3]));
		idx[@3]++;
		cur[@3] += bs[@3];
		dst[0] += bns[0];
		w[h++] = (chr)@3;
	}
@= merged_union_1
	/*  @1: ATOMstorage(b[0]->ttype) (chr, sht, int, flt, lng, dbl, any=b[0]->ttype)
	 *  @2: tloc, tvar, tail (for BAT 0)
	 *  @3: tloc, tvar, tail (for BAT 1)
	 *  @4: simple, atom
	 */
	/* merge-union the first two BATs; regard and preserve tail-order */
	h = 0;
	concat = (BATcount(b[0])==0 || BATcount(b[1])==0);
	if (!concat) {
		concat = ( BATtordered(b[0])&BATtordered(b[1])&1 && \
		           @4_LE(BUN@2(b[0],BUNlast(b[0])-BUNsize(b[0])),BUN@3(b[1],cur[1]),@1) );
	}
	if (!concat) {
		while ((idx[0] < cnt[0]) && (idx[1] < cnt[1])) {
			@:merged_union_0(@1,@2,0,@4_LE(BUN@2(b[0],cur[0]),BUN@3(b[1],cur[1]),@1))@
			if (idx[0] < cnt[0]) {
				@:merged_union_0(@1,@3,1,@4_GT(BUN@2(b[0],cur[0]),BUN@3(b[1],cur[1]),@1))@
			}
		}
	}
	/* get remaining BUNs */
	@:merged_union_0(@1,@2,0,TRUE)@
	@:merged_union_0(@1,@3,1,TRUE)@
@= merged_union_2
	/*  @1: ATOMstorage(b[0]->ttype) (chr, sht, int, flt, lng, dbl, any=b[0]->ttype)
	 *  @2: tloc, tvar, tail (for BAT 0)
	 *  @3: simple, atom
	 */
	@:merged_union_1(@1,@2,@2,@3)@
	break;
@= merged_union_3
	/*  @1: ATOMstorage(b[@3]->ttype) (chr, sht, int, flt, lng, dbl, any=b[0]->ttype)
	 *  @2: tloc, tvar, tail
	 */
	/* merge-union each of the remaining BAT-pairs; 
	   w tell us, from which BAT we need to get the next BUN */
	for (h=0; h<sze; h++) {
		j = i + (int)w[h];
		void@1_bunfastins_nocheck_noinc(bn[k],dst[k],0,BUN@2(b[j],cur[j]));
		idx[j]++;
		cur[j] += bs[j];
		dst[k] += bns[k];
	}
@= merged_union_4
	/*  @1: ATOMstorage(b[@3]->ttype) (chr, sht, int, flt, lng, dbl, any=b[0]->ttype)
	 *  @2: tloc, tvar, tail
	 */
	@:merged_union_3(@1,@2)@
	break;
@c
	/* merge-union the first two BATs */
/* HACK(?): compare [v]oid (unsigned) as int/lng (signed) to get nil's first... */
#if SIZEOF_OID == SIZEOF_INT
	if (b[0]->ttype==TYPE_void && b[1]->ttype==TYPE_void) {
		@:merged_union_1(int,tvar,tvar,simple)@
	} else if (b[0]->ttype==TYPE_void && b[1]->ttype==TYPE_oid) {
		@:merged_union_1(int,tvar,tloc,simple)@
	} else if (b[0]->ttype==TYPE_oid && b[1]->ttype==TYPE_void) {
		@:merged_union_1(int,tloc,tvar,simple)@
	} else if (b[0]->ttype==TYPE_oid && b[1]->ttype==TYPE_oid) {
		@:merged_union_1(int,tloc,tloc,simple)@
#else
	if (b[0]->ttype==TYPE_void && b[1]->ttype==TYPE_void) {
		@:merged_union_1(lng,tvar,tvar,simple)@
	} else if (b[0]->ttype==TYPE_void && b[1]->ttype==TYPE_oid) {
		@:merged_union_1(lng,tvar,tloc,simple)@
	} else if (b[0]->ttype==TYPE_oid && b[1]->ttype==TYPE_void) {
		@:merged_union_1(lng,tloc,tvar,simple)@
	} else if (b[0]->ttype==TYPE_oid && b[1]->ttype==TYPE_oid) {
		@:merged_union_1(lng,tloc,tloc,simple)@
#endif
	} else {
		any = b[0]->ttype;
		switch(ATOMstorage(b[0]->ttype)) {
		case TYPE_chr:	@:merged_union_2(chr,tloc,simple)@
		case TYPE_sht:	@:merged_union_2(sht,tloc,simple)@
		case TYPE_int:	@:merged_union_2(int,tloc,simple)@
		case TYPE_flt:	@:merged_union_2(flt,tloc,simple)@
		case TYPE_lng:	@:merged_union_2(lng,tloc,simple)@
		case TYPE_dbl:	@:merged_union_2(dbl,tloc,simple)@
		default:
			if (b[0]->tvarsized) {
				@:merged_union_2(any,tvar,atom)@
			} else {
				@:merged_union_2(any,tloc,atom)@
			}
		}
	}
	/* merge-union each of the remaining BAT-pairs */
	for (k=1; k<npairs; k++) {
		i = (k<<1);
		j = i+1;
/* HACK(?): compare [v]oid (unsigned) at int/lng (signed) to get nil's first... */
#if SIZEOF_OID == SIZEOF_INT
		if (b[i]->ttype==TYPE_void || b[j]->ttype==TYPE_void) {
			@:merged_union_3(int,tail,simple)@
		} else if (b[i]->ttype==TYPE_oid && b[j]->ttype==TYPE_oid) {
			@:merged_union_3(int,tloc,simple)@
#else
		if (b[i]->ttype==TYPE_void || b[j]->ttype==TYPE_void) {
			@:merged_union_3(lng,tail,simple)@
		} else if (b[i]->ttype==TYPE_oid && b[j]->ttype==TYPE_oid) {
			@:merged_union_3(lng,tloc,simple)@
#endif
		} else {
			any = b[i]->ttype;
			switch(ATOMstorage(b[i]->ttype)) {
			case TYPE_chr:	@:merged_union_4(chr,tloc)@
			case TYPE_sht:	@:merged_union_4(sht,tloc)@
			case TYPE_int:	@:merged_union_4(int,tloc)@
			case TYPE_flt:	@:merged_union_4(flt,tloc)@
			case TYPE_lng:	@:merged_union_4(lng,tloc)@
			case TYPE_dbl:	@:merged_union_4(dbl,tloc)@
			default:
				if (b[i]->tvarsized) {
					@:merged_union_4(any,tvar)@
				} else {
					@:merged_union_4(any,tloc)@
				}
			}
		}
	}

	/* set BAT properties */

	for (k=0; k<npairs; k++) {
		BAT *b0 = b[2*k], *b1 = b[(2*k)+1];
		BATseqbase(bn[k], (oid)0);
		bn[k]->batBuns->free = dst[k] - bn[k]->batBuns->base;
		BATsetcount(bn[k], bn[k]->batBuns->free/BUNsize(bn[k]));
		if (!bn[k]->batDirty) bn[k]->batDirty = TRUE;
		BATkey(bn[k],TRUE);
		BATkey(BATmirror(bn[k]),FALSE);
		bn[k]->hsorted = GDK_SORTED;
		if (k==0 || (BATcount(b0)==0 && BATcount(b1)==0)) {
			bn[k]->tsorted = GDK_SORTED;
		} else
		  if (BATcount(b0)==0) {
			bn[k]->tsorted = (BATtordered(b1)&1 ? GDK_SORTED : FALSE);
		} else
		  if (BATcount(b1)==0) {
			bn[k]->tsorted = (BATtordered(b0)&1 ? GDK_SORTED : FALSE);
		} else {
			bn[k]->tsorted = ( ( concat && \
			                     BATtordered(b0)&BATtordered(b1)&1 && \
			                     atom_LE(BUNtail(b0,BUNlast(b0)-BUNsize(b0)),BUNtail(b1,BUNfirst(b1)),b0->ttype) ) \
			                  ? GDK_SORTED \
			                  : FALSE );
		}
		bn[k]->hdense = TRUE;
		bn[k]->tdense = FALSE;
	}

	/* insert bn[] BATs in BN BAT */

	DST = BUNlast(BN);
	BS = BUNsize(BN);
	BATseqbase(BN, (oid)0);
	for (k=0; k<npairs; k++) {
		voidany_bunfastins_nocheck_noinc(BN,DST,0,&bn[k]->batCacheid);
		BBPunfix(bn[k]->batCacheid);
		DST += BS;
	}
	BN->batBuns->free = DST - BN->batBuns->base;
	BATsetcount(BN, BN->batBuns->free/BS); 
	if (!BN->batDirty) BN->batDirty = TRUE;
	BATkey(BN,TRUE);
	BATkey(BATmirror(BN),TRUE);
	BN->hsorted = GDK_SORTED;
	BN->tsorted = FALSE;
	BN->hdense = TRUE;
	BN->tdense = FALSE;

	*res = BN;

	GDKfree(w);

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("merged_union: bunins failed.\n");
cleanup:
	BBPreclaim(BN);
	for (k=0; k<npairs; k++) {
		BBPreclaim(bn[k]);
	}
	return GDK_FAIL;
}

int CMDmerged_union( BAT** res, ptr L, int ltpe, ptr R, int rtpe, ... )
{
	int i, tpe, nbats = 0, ret = GDK_SUCCEED;
	BAT *b[MAXPARAMS];
	va_list ap;
        ptr p;

	/* first convert any constant parameters to fake projects */
	if (CMDfakeProject(b+nbats, L, ltpe) == GDK_SUCCEED) {
		nbats++;
		if (CMDfakeProject(b+nbats, R, rtpe) == GDK_SUCCEED) {
			nbats++;
			va_start(ap,rtpe);
			while((p = va_arg(ap, ptr)) != NULL) {
        		        tpe = va_arg(ap, int);
				if (CMDfakeProject(b+nbats, p, tpe) == GDK_SUCCEED) {
					nbats++;
				} else {
					ret = GDK_FAIL;
					break;
				}
			}
			va_end(ap);
		}
	}
	if (ret == GDK_SUCCEED) {
		ret = merged_union(res, nbats, b);
	}
	/* unfix all bats; this destroys any created fake projects */
	for(i=0; i<nbats; i++) 
		BBPunfix(b[i]->batCacheid);
	return ret;
}

int
CMDll_strSplit(BAT **res, BAT *strs, BAT *seps)
{
        BAT *bn;
        BUN p_str, p_sep, last_str_row;
        int bs_str, bs_sep;
        size_t cnt, seplen;
        oid base;
        char *actual_str;
        bit triv_prop;

        /* check arguments */

        BATcheck(strs, "ll_strSplit");
        BATcheck(seps, "ll_strSplit");

        cnt = BATcount(strs);
        base = strs->hseqbase;
        ERRORcheck(!BAThdense(strs) || !BAThdense(seps), 
                "ll_strSplit: input BATs (strs, seps) must be void-headed with non-nil seqbase.\n");
        ERRORcheck(BATcount(seps)!=cnt || seps->hseqbase!=base,
                "ll_strSplit: input BATs (strs, seps) must be head-aligned.\n");

        /* create result BAT */

        bn = BATnew(TYPE_oid, TYPE_str, 2*cnt);
        if (bn == NULL) {
                GDKerror("ll_strSplit: BATnew(TYPE_oid, TYPE_str, %d) failed.\n", 2*cnt);
                return GDK_FAIL;
        }

        /* do the ll_strSplit */

        bs_str = BUNsize(strs);
        bs_sep = BUNsize(seps);

        p_str = BUNfirst(strs);
        p_sep = BUNfirst(seps);

        for (last_str_row = BUNlast(strs) ;
             p_str < last_str_row ;
             p_str += bs_str, p_sep += bs_sep) {

                str sep = (str)BUNtvar(seps, p_sep);
                seplen = strlen(sep);
                actual_str = GDKstrdup((str)BUNtvar(strs, p_str));

                if (!seplen)
                {
                        bunfastins(bn, &base, actual_str);
                        base++;
                        continue;
                }
  
                while (actual_str) {
                        char *e = strstr(actual_str, sep);
  
                        if (!e)
                                break;
  
                        *e = 0;
                        bunfastins(bn, &base, actual_str);
                        actual_str = e + seplen;
                }
 
                if (actual_str && *actual_str)
                        bunfastins(bn, &base, actual_str);
                base++;
        }

        /* set result properties */

        if (!bn->batDirty) bn->batDirty = TRUE;
        triv_prop = (BATcount(bn) < 2);
        BATkey(bn,triv_prop);
        BATkey(BATmirror(bn),triv_prop);
        bn->hsorted = GDK_SORTED;
        bn->tsorted = triv_prop;
        bn->hdense = triv_prop;
        bn->tdense = FALSE;
        if (BATcount(bn) == 0) {
                BATseqbase(bn, (oid)0);
        } else if (BATcount(bn) == 1) {
                BATseqbase(bn, *(oid*)BUNhloc(bn,BUNfirst(bn)));
        }
        *res = bn;
        return GDK_SUCCEED;
bunins_failed:
        GDKerror("ll_strSplit: bunins failed.\n");
        return GDK_FAIL;
}


int
CMDnormSpace(str *res, str string)
{
        char *ws, *cur, *pointer;
        size_t n;

        pointer = GDKstrdup(string);
        if (pointer == NULL) {
                GDKerror("normSpace: GDKmalloc(" SZFMT ") failed.\n",
                         strlen (string) + 1);
                return GDK_FAIL;
        }

        *res = pointer;

        cur = string;
        ws = " \f\n\r\t\v";
        n = strspn (cur, ws);
        if (n)
        {
            *pointer = ' ';
            pointer++;
            cur += n;
        }

        while ((n = strcspn (cur, ws))) {
            while (n > 0)
            {
                *pointer = *cur;
                pointer++;
                cur++;
                n--;
            }
            n = strspn (cur, ws);
            if (n)
            {
                *pointer = ' ';
                pointer++;
                cur += n;
            }
        }
        *pointer = '\0';

        return GDK_SUCCEED;
}

int
math_unary_up_ROUND(dbl *res, dbl *x)
{
        if (*x == dbl_nil) {
                *res = dbl_nil;
        } else {
                double integral;
                double tmp = modf(*x, &integral);

                tmp = floor(tmp + 0.5);
                tmp += integral;

                *res = tmp;
        }

        return (GDK_SUCCEED);
}




#define KIND_NODE (oid)0
#define KIND_TEXT (oid)1
#define KIND_STR  (oid)2

int CMDcombine_text_string( BAT** res, BAT *iter, BAT *kind, BAT *str_value, int *result_size )
{
	BAT *bn;
	BUN qi, pi, pk, ps;
	int bsi, bsk, bss;
	size_t cnt, len, strsize = 1024;
	oid base0, base, i0, k0;
	str actual_str = NULL;
	bit triv_prop;
	
	*res = NULL;

	/* check arguments */

	BATcheck(iter, "combine_text_string");
	BATcheck(kind, "combine_text_string");
	BATcheck(str_value, "combine_text_string");

	cnt = BATcount(iter);
	base = iter->hseqbase;
	ERRORcheck(!BAThdense(iter) || !BAThdense(kind) || !BAThdense(str_value), 
		"combine_text_string: all input BATs (iter, kind, str_value) must be void-headed with non-nil seqbase.\n");
	ERRORcheck(BATcount(kind)!=cnt || BATcount(str_value)!=cnt || kind->hseqbase!=base || str_value->hseqbase!=base,
		"combine_text_string: all input BATs (iter, kind, str_value) must be head-aligned.\n");
	ERRORcheck(!(BATtordered(iter)&1),
		"combine_text_string: input BAT iter must be sorted on tail.\n");

	/* create result BAT */

	bn = BATnew(TYPE_oid, TYPE_str, *result_size);
	if (bn == NULL) {
		GDKerror("combine_text_string: BATnew(TYPE_oid, TYPE_str, %d) failed.\n", *result_size);
		return GDK_FAIL;
	}

	/* do the combine_text_string */

	bsi = BUNsize(iter);
	bsk = BUNsize(kind);
	bss = BUNsize(str_value);

	pi = BUNfirst(iter);
	pk = BUNfirst(kind);
	ps = BUNfirst(str_value);

	/* allocate str buffer */
	actual_str = (str)GDKmalloc(strsize);
	if (actual_str == NULL) {
		GDKerror("combine_text_string: GDKmalloc(" SZFMT ") failed.\n", strsize);
		goto cleanup;
	}
	len = 0;
	actual_str[0] = '\0';
	k0 = oid_nil;
	i0 = *(oid*)BUNtail(iter,pi); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
	base0 = oid_nil;

	for (qi = BUNlast(iter) ; pi < qi ; pi += bsi, pk += bsk, ps += bss) {
		oid i = *(oid*)BUNtail(iter,pi); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		oid k = *(oid*)BUNtail(kind,pk); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		str s = (str)BUNtvar(str_value,ps);
		size_t l = strlen(s) + 1;
		if ( i0 < i || k == KIND_NODE ) {
			/* new iter or new node */
			if (len > 0) {
				/* actual_str of (previous) iter is not empty => insert it into result */
				bunfastins(bn, &base0, actual_str);
				len = 0;
				actual_str[0] = '\0';
			}
			k0 = oid_nil;
		}
		if (len+l >= strsize) {
			/* extend str buffer */
			do {
				strsize *= 2;
			} while (len+l >= strsize);
			actual_str = GDKrealloc(actual_str, strsize);
			if (actual_str == NULL) {
				GDKerror("combine_text_string: GDKrealloc(" SZFMT ") failed.\n", strsize);
				goto cleanup;
			}
		}
		if (k0 == KIND_STR && k == KIND_STR) {
			/* insert ' '-separator between adjacent STRs */
			actual_str[len++] = ' ';
			actual_str[len] = '\0';
		}
        if (k != KIND_NODE)
        {
		    strcpy(actual_str + len, s); /* we know it fits */
		    len += l - 1;	/* compensate for +1 earlier on */
        }
		i0 = i;
		k0 = k;
		base0 = base++;
	}

	if (len > 0) {
		bunfastins(bn, &base0, actual_str);
	}

	/* set result properties */

	if (!bn->batDirty) bn->batDirty = TRUE;
	triv_prop = (BATcount(bn) < 2);
	BATkey(bn,TRUE);
	BATkey(BATmirror(bn),triv_prop);
	bn->hsorted = GDK_SORTED;
	bn->tsorted = triv_prop;
	bn->hdense = triv_prop;
	bn->tdense = FALSE;
	if (BATcount(bn) == 0) {
		BATseqbase(bn, (oid)0);
	} else if (BATcount(bn) == 1) {
		BATseqbase(bn, *(oid*)BUNhloc(bn,BUNfirst(bn)));
	}
	*res = bn;

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("combine_text_string: bunins failed.\n");
cleanup:
	if (actual_str) GDKfree(actual_str);
	BBPreclaim(bn);
	return GDK_FAIL;
}

int CMDstring_join ( BAT** res, BAT *iter_str, BAT *separator  )
{
	BAT *bn;
	BUN bun_iter_str, bun_sep, last_iter_str, last_sep;
	int bs_iter_str, bs_sep;
	size_t len, sep_len, strsize = 1024;
	oid i, i0, sep_oid, sep0;
	str s, sep, actual_str = NULL;
	bit triv_prop, first_string;
	
	*res = NULL;

	/* check arguments */

	BATcheck(iter_str, "string_join");
	BATcheck(separator, "string_join");

	ERRORcheck(!(BAThordered(iter_str)&1),
		"string_join: input BAT iter_str must be sorted on head.\n");
	ERRORcheck(!(BAThordered(separator)&1),
		"string_join: input BAT separator must be sorted on head.\n");

	/* create result BAT */

	bn = BATnew(TYPE_oid, TYPE_str, BATcount(separator));
	if (bn == NULL) {
		GDKerror("string_join: BATnew(TYPE_oid, TYPE_str, %d) failed.\n", BATcount(separator));
		return GDK_FAIL;
	}

	/* do the string_join */

	bs_iter_str = BUNsize(iter_str);
	bs_sep = BUNsize(separator);

	bun_iter_str = BUNfirst(iter_str);
	last_iter_str = BUNlast(iter_str);
	bun_sep = BUNfirst(separator);
	last_sep = BUNlast(separator);

	/* handling the empty cases */

	if (bun_iter_str == last_iter_str && bun_sep == last_sep) {
		/* ... head */
		BATkey (bn, TRUE);
                bn->hsorted = GDK_SORTED;
		bn->hdense = TRUE;
		BATseqbase (bn, (oid)0); /* does not really matter */
		/* ... tail */
		BATkey (BATmirror(bn), TRUE);
                bn->tsorted = GDK_SORTED;
		bn->tdense = FALSE;
		*res = bn;
 	       	return GDK_SUCCEED;
	}
	else if (bun_sep == last_sep) {
		GDKerror("string_join: expected oid %i@0 in iter_str "
                         "is missing in separator (0 rows).",
                         *(oid*)BUNhead(iter_str,bun_iter_str)); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
		return GDK_FAIL;
	}
	else if (bun_iter_str == last_iter_str) {
		sep0 = oid_nil;
		sep_oid = *(oid*)BUNhead(separator,bun_sep); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
		@:append_sep_and_set_props@
 	       	return GDK_SUCCEED;
	}

	/* allocate str buffer */
	actual_str = (str)GDKmalloc(strsize);
	if (actual_str == NULL) {
		GDKerror("string_join: GDKmalloc(" SZFMT ") failed.\n", strsize);
		goto cleanup;
	}
	len = 0;
	actual_str[0] = '\0';

	i0 = *(oid*)BUNhead(iter_str,bun_iter_str); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
	first_string = 1;
	sep0 = oid_nil;

@= get_next_separator
	/* - goes to the next row in the separator bat
	     to get the separator for the next iter value
	   - produces an error if oids are not aligned */
	sep_oid = *(oid*)BUNhead(separator,bun_sep); /* FIXME: "hvar" (void) vs. "hloc" (oid) */

	while (i0 > sep_oid && bun_sep != last_sep) {
		if (sep0 == sep_oid) {
			GDKerror("string_join: the head of separator has to be keyed.");
			return GDK_FAIL;
		}
		bunfastins(bn, &sep_oid, "");
		sep0 = sep_oid;
		bun_sep += bs_sep;
	        sep_oid = *(oid*)BUNhead(separator,bun_sep); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
	}
	if (i0 == sep_oid && bun_sep != last_sep) {
		sep = (str)BUNtvar(separator,bun_sep);
		sep_len = strlen(sep);
	}
	else {
		GDKerror("string_join: expected oid %i@0 in iter_str "
			 "is missing in separator.",
			 i0);
		return GDK_FAIL;
	}
@c
	@:get_next_separator@

	for (; bun_iter_str < last_iter_str ; bun_iter_str += bs_iter_str) {
		i = *(oid*)BUNhead(iter_str,bun_iter_str); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
		s = (str)BUNtvar(iter_str,bun_iter_str);

		size_t l;

		if (i0 < i) {
			bunfastins(bn, &i0, actual_str);
			len = 0;
			actual_str[0] = '\0';
			i0 = i;
			first_string = 1;

			sep0 = sep_oid;
			bun_sep += bs_sep;
			@:get_next_separator@
		}

		l = strlen(s) + sep_len + 1;

		if (len+l >= strsize) {
			/* extend str buffer */
			do {
				strsize *= 2;
			} while (len+l >= strsize);
			actual_str = GDKrealloc(actual_str, strsize);
			if (actual_str == NULL) {
				GDKerror("string_join: GDKrealloc(" SZFMT ") failed.\n", strsize);
				goto cleanup;
			}
		}

		/* adds the separator (starting before the second string) */

		if (first_string) {
			first_string = 0;
		}
		else {
			strcpy(actual_str+len, sep); /* we know it fits */
			len += sep_len;
		}

		strcpy(actual_str + len, s); /* we know it fits */
		len += l - sep_len - 1;	/* just strlen(s) */
	}

	/* inserts last row */

	if (len > 0) {
		bunfastins(bn, &i0, actual_str);
		sep0 = sep_oid;
		bun_sep += bs_sep;
	}

@= append_sep_and_set_props
	while (bun_sep != last_sep) {
	        sep_oid = *(oid*)BUNhead(separator,bun_sep); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
		if (sep0 == sep_oid) {
			GDKerror("string_join: the head of separator has to be keyed.");
			return GDK_FAIL;
		}
		bunfastins(bn, &sep_oid, "");
		sep0 = sep_oid;
		bun_sep += bs_sep;
	}

	GDKfree(actual_str);

	/* set result properties */

	if (!bn->batDirty) bn->batDirty = TRUE;
	triv_prop = (BATcount(bn) < 2);
	BATkey(bn,TRUE);
	BATkey(BATmirror(bn),triv_prop);
	bn->hsorted = GDK_SORTED;
	bn->tsorted = triv_prop;
	bn->hdense = triv_prop;
	bn->tdense = FALSE;
	if (BATcount(bn) == 0) {
		BATseqbase(bn, (oid)0);
	} else if (BATcount(bn) == 1) {
		BATseqbase(bn, *(oid*)BUNhloc(bn,BUNfirst(bn)));
	}
	*res = bn;
@c
	@:append_sep_and_set_props@

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("string_join: bunins failed.\n");
cleanup:
	if (actual_str) GDKfree(actual_str);
	BBPreclaim(bn);
	return GDK_FAIL;
}

int CMDenumerate ( BAT** res, BAT *startval, BAT *length )
{
        BAT *bn;
        BUN cur_bun, length_bun, bun_last;
        lng bs_startval, bs_length, number, counter, result_size;
        size_t cnt;
        oid base, head_oid;
        bit triv_prop;

        /* check arguments */

        BATcheck(startval, "enumerate");
        BATcheck(length, "enumerate");

        cnt = BATcount(startval);
        base = startval->hseqbase;
        ERRORcheck(!BAThdense(startval) || !BAThdense(length), 
                "enumerate: input BATs (startval, length) must be void-headed with non-nil seqbase.\n");
        ERRORcheck(BATcount(length)!=cnt || length->hseqbase!=base,
                "enumerate: input BATs (startval, length) must be head-aligned.\n");

        /* create result BAT */
        if (CMDsum_lng_lng(&result_size, length) == GDK_FAIL) {
                GDKerror("enumerate: summing up 'length' failed.\n");
                return GDK_FAIL;
        }

        bn = BATnew(TYPE_oid, TYPE_lng, result_size);
        if (bn == NULL) {
                GDKerror("enumerate: BATnew(TYPE_oid, TYPE_lng, %d) failed.\n", result_size);
                return GDK_FAIL;
        }

        /* do the enumerate */

        for (cur_bun = BUNfirst(startval), length_bun = BUNfirst(length),
             bun_last = BUNlast(startval),
             bs_startval = BUNsize(startval), bs_length = BUNsize(length);
             cur_bun < bun_last;
             cur_bun += bs_startval, length_bun += bs_length)
        {
	        head_oid = *(oid*)BUNhead(startval,cur_bun); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
                number = *(lng*) BUNtloc (startval, cur_bun);
                counter = *(lng*) BUNtloc (length, length_bun);
                while (counter)
                {
		        bunfastins(bn, &head_oid, &number);
                        number++;
                        counter--;
                }
        }

	if (!bn->batDirty) bn->batDirty = TRUE;
	triv_prop = (BATcount(bn) < 2);
	BATkey(bn,triv_prop);
	BATkey(BATmirror(bn),triv_prop);
	bn->hsorted = GDK_SORTED;
	bn->tsorted = triv_prop;
	bn->hdense = triv_prop;
	bn->tdense = FALSE;
	if (BATcount(bn) == 0) {
		BATseqbase(bn, (oid)0);
	} else if (BATcount(bn) == 1) {
		BATseqbase(bn, *(oid*)BUNhloc(bn,BUNfirst(bn)));
	}
	*res = bn;

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("enumerate: bunins failed.\n");
	return GDK_FAIL;
}

int CMDmposjoin ( BAT** res, BAT* pre, BAT* frag, BAT* ws_item )
{
	BAT *bn, **batlist = NULL, *the_frag_bat = NULL;
	BUN q, pp, pf, pw, dst;
	int bs, bsp, bsf, ii = 0, tt = 0;
	size_t cnt, len;
	oid base, wl, wh;
	bit triv_prop;
	bit fake_frag = FALSE;
	bit fake_ws_item = FALSE;
	
	*res = NULL;

	/* check arguments */

	BATcheck(pre, "mposjoin");
	BATcheck(frag, "mposjoin");
	BATcheck(ws_item, "mposjoin");

	len = BATcount(ws_item);
	cnt = BATcount(pre);
	base = pre->hseqbase;
	fake_frag = is_fake_project(frag);
	
	if (fake_frag) {
		ERRORcheck(!BAThdense(pre), 
			"mposjoin: input BAT pre must have a dense head.\n");
		ERRORcheck(!BAThdense(ws_item), 
			"mposjoin: input BAT ws_item must have a dense head.\n");
	} else {
		ERRORcheck(!BAThdense(pre) || !BAThdense(frag) || !BAThdense(ws_item), 
			"mposjoin: all input BATs (pre, frag, ws_item) must have a dense head.\n");
		ERRORcheck(BATcount(frag)!=cnt || frag->hseqbase!=base,
			"mposjoin: first two input BATs (pre & frag) must be head-aligned.\n");
	}
	ERRORcheck(len==0,
		"mposjoin: third input BAT (ws_item) must not be empty.\n");

	the_frag_bat = BATdescriptor(*(bat*)BUNtloc(ws_item, BUNfirst(ws_item)));
	tt = the_frag_bat->ttype;
	BBPunfix(the_frag_bat->batCacheid);
	the_frag_bat = NULL;

	if (cnt==0) {
		@:mpos_res_empty@
	}

	ii = 0;
	
	if (fake_frag) {
		oid the_frag_id = *(oid*)BUNtail(frag, BUNfirst(frag));
		len = 1;
		batlist = &the_frag_bat;
		BUNfndVOID(pw, ws_item, &the_frag_id);
		if (pw==NULL) {
			@:mpos_res_empty@
		}

		@:mpos_init_batlist@
		if (!fake_ws_item) {
			*res = bn = BATleftfetchjoin(pre, batlist[0], oid_nil);
			@:mpos_free_batlist@
			if (bn == NULL) {
				GDKerror("mposjoin: BATleftfetchjoin(pre, ws_item["SZFMT"]) failed.\n",
					 the_frag_id);
				return GDK_FAIL;
			}
			return GDK_SUCCEED;
		}
	
	} else {
		batlist = (BAT**)GDKmalloc(len * sizeof(BAT*));
		if (batlist == NULL) {
			GDKerror("mposjoin: GDKmalloc(" SZFMT ") failed.\n", len * sizeof(BAT*));
			return GDK_FAIL;
		}
		BATloopFast(ws_item, pw, q, bs) {
			@:mpos_init_batlist@
		}
	}

@= mpos_init_batlist
{
		bit fake_item = FALSE;
		bat bid = *(bat*)BUNtloc(ws_item, pw);
		batlist[ii] = BATdescriptor(bid);
		fake_item = is_fake_project(batlist[ii]);
		fake_ws_item |= fake_item;
		if (!(fake_item || BAThdense(batlist[ii]))) {
			GDKerror("mposjoin: all BATs in the tail of the third input BAT (ws_item) must have a dense head.\n");
			ii++;
			@:mpos_free_batlist@
			return GDK_FAIL;
		}
		if (ATOMtype(batlist[0]->ttype) != ATOMtype(batlist[ii]->ttype)) {
			GDKerror("mposjoin: all BATs in the tail of the third input BAT (ws_item) must have the same tail type (%d: %d != %d).\n",
				ii, batlist[ii]->ttype, batlist[0]->ttype);
			ii++;
			@:mpos_free_batlist@
			assert(0);
			return GDK_FAIL;
		}
		ii++;
}	
@
@= mpos_res_empty
	cnt = 0;
	@:mpos_res_create@
	@:mpos_res_prop@

	return GDK_SUCCEED;
@
@= mpos_res_create
	/* create result BAT */

	bn = BATnew(TYPE_void, ATOMtype(tt), cnt);
	if (bn == NULL) {
		GDKerror("mposjoin: BATnew(TYPE_void, %s, " SZFMT ") failed.\n", ATOMname(ATOMtype(tt)), cnt);
		@:mpos_free_batlist@
		return GDK_FAIL;
	}
	BATseqbase(bn, base);
@c
	@:mpos_res_create@
	bs = BUNsize(bn);
	dst = BUNlast(bn);

	/* do the mposjoin */

	wl = ws_item->hseqbase;
	wh = wl + len - 1;

	bsp = BUNsize(pre);
	if (fake_frag) {
		bsf = 0;
	} else {
		bsf = BUNsize(frag);
	}

	pp = BUNfirst(pre);
	pf = BUNfirst(frag);

@= mposjoin
	/*  @1: ATOMstorage(ATOMtype(batlist[0]->ttype)) (chr, sht, int, flt, lng, dbl, any)
	 *  @2: tloc, tvar, tail
	 */
	 if (fake_frag) {
	 	/* !fake_ws_item handled above */
	 	@:mposjoin_fake_fake(@1,@2)@
	 } else {
		if (fake_ws_item) {
			@:mposjoin_(@1,@2,is_fake_project(b))@
		} else {
			@:mposjoin_(@1,@2,FALSE)@
		}
	}
	break;
@
@= mposjoin_fake_fake
	/*  @1: ATOMstorage(ATOMtype(batlist[0]->ttype)) (chr, sht, int, flt, lng, dbl, any)
	 *  @2: tloc, tvar, tail
	 */
	BAT *b = batlist[0];
	ptr  w = BUN@2(b, BUNfirst(b));
	for (q = BUNlast(pre) ; pp < q ; pp += bsp) {
		void@1_bunfastins_nocheck_noinc(bn,dst,0,w);
		dst += bs;
	}
@
@= mposjoin_
	/*  @1: ATOMstorage(ATOMtype(batlist[0]->ttype)) (chr, sht, int, flt, lng, dbl, any)
	 *  @2: tloc, tvar, tail
	 *  @3: FALSE / is_fake_project(b)
	 */
	for (q = BUNlast(pre) ; pp < q ; pp += bsp, pf += bsf) {
		oid p = *(oid*)BUNtail(pre,pp);  /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		oid f = *(oid*)BUNtail(frag,pf); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		if (f >= wl && f <= wh) {
			BAT *b = batlist[f - wl];
			if (@3) {
				void@1_bunfastins_nocheck_noinc(bn,dst,0,BUN@2(b,BUNfirst(b)));
				dst += bs;
			} else {
				oid l = b->hseqbase;
				oid h = l + BATcount(b) - 1;
				if (p >= l && p <= h) {
					oid b0 = BUNindex(b,BUNfirst(b));
					void@1_bunfastins_nocheck_noinc(bn,dst,0,BUN@2(b,BUNptr(b,p-l+b0)));
					dst += bs;
				}
			}
		}
	}
@c

	switch(ATOMstorage(ATOMtype(batlist[0]->ttype))) {
	case TYPE_chr:	@:mposjoin(chr,tloc,simple)@
	case TYPE_sht:	@:mposjoin(sht,tloc,simple)@
#if SIZEOF_OID == SIZEOF_INT
	/* cannot use tloc on oid(void) */
	case TYPE_int:	@:mposjoin(int,tail,simple)@
#else
	case TYPE_int:	@:mposjoin(int,tloc,simple)@
#endif
	case TYPE_flt:	@:mposjoin(flt,tloc,simple)@
#if SIZEOF_OID == SIZEOF_LNG
	/* cannot use tloc on oid(void) */
	case TYPE_lng:	@:mposjoin(lng,tail,simple)@
#else
	case TYPE_lng:	@:mposjoin(lng,tloc,simple)@
#endif
	case TYPE_dbl:	@:mposjoin(dbl,tloc,simple)@
	default:
		if (batlist[0]->tvarsized) {
			@:mposjoin(any,tvar,atom)@
		} else {
			@:mposjoin(any,tloc,atom)@
		}
	}
	bn->batBuns->free = dst - bn->batBuns->base;
	BATsetcount(bn, bn->batBuns->free/BUNsize(bn));

@= mpos_res_prop
    /* check result size */
    if (BATcount(pre) > BATcount(bn)) {
		GDKerror("mposjoin: missing matches. The result requires the "
                 "same number of tuples as the first two input arguments.");
		@:mpos_free_batlist@
		return GDK_FAIL;
	}
    if (BATcount(pre) < BATcount(bn)) {
		GDKerror("mposjoin: more than one match per input tuple. "
                 "seqbase does not match anymore.");
		@:mpos_free_batlist@
		return GDK_FAIL;
	}

	/* set result properties */

	if (!bn->batDirty) bn->batDirty = TRUE;
	triv_prop = (BATcount(bn) < 2);
	BATkey(bn,TRUE);
	BATkey(BATmirror(bn),triv_prop);
	bn->hsorted = GDK_SORTED;
	bn->tsorted = triv_prop;
	bn->hdense = TRUE;
	bn->tdense = FALSE;

	*res = bn;
@c
	@:mpos_res_prop@
	@:mpos_free_batlist@

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("mposjoin: bunins failed.\n");
	BBPreclaim(bn);
@= mpos_free_batlist
	while (ii > 0) {
		BBPunfix(batlist[--ii]->batCacheid);
	}
	if (batlist && !fake_frag) {
		GDKfree(batlist);
	}
@c
	@:mpos_free_batlist@
	return GDK_FAIL;
}


int CMDmvaljoin ( BAT** res, BAT* pre, BAT* frag, BAT* ws_item )
{
	BAT *bn, **batlist = NULL, *the_frag_bat = NULL;
	BUN q, pp, pf, pw;
	int bsp, bsf, bsw, ii = 0;
	size_t cnt, len, sze;
	oid base, wl, wh;
	bit triv_prop, all_hash, all_sort, some_hash, some_sort, all_key, fake_frag = FALSE;
	
	*res = NULL;

	/* check arguments */

	BATcheck(pre, "mvaljoin");
	BATcheck(frag, "mvaljoin");
	BATcheck(ws_item, "mvaljoin");

	len = BATcount(ws_item);
	cnt = BATcount(pre);
	base = pre->hseqbase;
	fake_frag = is_fake_project(frag);
	
	if (fake_frag) {
		ERRORcheck(!BAThdense(pre) || !BAThdense(ws_item), 
			"mvaljoin: input BATs pre & ws_item must have a dense head.\n");
	} else {
		ERRORcheck(!BAThdense(pre) || !BAThdense(frag) || !BAThdense(ws_item), 
			"mvaljoin: all input BATs (pre, frag, ws_item) must have a dense head.\n");
		ERRORcheck(BATcount(frag)!=cnt || frag->hseqbase!=base,
			"mvaljoin: first two input BATs (pre & frag) must be head-aligned.\n");
	}
	ERRORcheck(len==0,
		"mvaljoin: third input BAT (ws_item) must not be empty.\n");

	sze = cnt;
	ii = 0;
	all_hash = all_sort = all_key = TRUE;
	some_hash = some_sort = FALSE;
	
	if (sze == 0) {
		@:mval_res_empty@
	}
	if (fake_frag) {
		oid the_frag_id = *(oid*)BUNtail(frag, BUNfirst(frag));
		len = 1;
		batlist = &the_frag_bat;
		BUNfndVOID(pw, ws_item, &the_frag_id);
		if (pw==NULL) {
			@:mval_res_empty@
		}

		@:mval_init_batlist@
		*res = bn = BATleftjoin(pre, BATmirror(batlist[0]), oid_nil);
		@:mval_free_batlist@
		if (bn == NULL) {
			GDKerror("mvaljoin: BATleftjoin(pre, BATmirror(ws_item["SZFMT"])) failed.\n",
				 the_frag_id);
			return GDK_FAIL;
		}
		return GDK_SUCCEED;

	} else {
		batlist = (BAT**)GDKmalloc(len * sizeof(BAT*));
		if (batlist == NULL) {
			GDKerror("mvaljoin: GDKmalloc(" SZFMT ") failed.\n", len * sizeof(BAT*));
			return GDK_FAIL;
		}
		BATloopFast(ws_item, pw, q, bsw) {
			@:mval_init_batlist@
		}
	}
	if (all_key) {
		sze = cnt;
	}

@= mval_init_batlist
{
		bit hsh, srt;
		bat bid = *(bat*)BUNtloc(ws_item, pw);
		batlist[ii] = BATdescriptor(bid);
		if (batlist[ii]->ttype != TYPE_oid &&
		    (batlist[ii]->ttype != TYPE_void || batlist[ii]->tseqbase == oid_nil)) {
			GDKerror("mvaljoin: all BATs in the tail of the third input BAT (ws_item) must have tail type OID.\n");
			ii++;
			@:mval_free_batlist@
			return GDK_FAIL;
		}
		hsh = (BAThash(BATmirror(batlist[ii]), 0) != NULL);
		srt = (BATtordered(batlist[ii])&1);
		all_hash &= hsh;
		all_sort &= srt;
		some_hash |= hsh;
		some_sort |= srt;
		all_key &= (batlist[ii]->tkey!=0);
		sze = MAX(sze, BATcount(batlist[ii]));
		ii++;
}	
@
@= mval_res_empty
	sze = 0;
	@:mval_res_create@
	@:mval_res_prop@

	return GDK_SUCCEED;
@
@= mval_res_create
	/* create result BAT */

	bn = BATnew(TYPE_oid, TYPE_oid, sze);
	if (bn == NULL) {
		GDKerror("mvaljoin: BATnew(TYPE_oid, TYPE_oid, " SZFMT ") failed.\n", sze);
		@:mval_free_batlist@
		return GDK_FAIL;
	}
@c
	@:mval_res_create@

	/* do the mvaljoin */

	wl = ws_item->hseqbase;
	wh = wl + len - 1;

	bsp = BUNsize(pre);
	bsf = BUNsize(frag);

	pp = BUNfirst(pre);
	pf = BUNfirst(frag);

@= hash_only
	hash_t h;
	BUN r;
	b = BATmirror(b);
	HASHloop_oid(b, b->hhash, h, (ptr)(&p), r) {
		oidoid_bunfastins(bn,&base,BUNtail(b,r)); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
	}
@= sort_only
	BUN rp, rq;
	int bs;
	SORTloop_oid(b, rp, rq, (ptr)(&p), (ptr)(&p), bs) {
		oidoid_bunfastins(bn,&base,BUNhead(b,rp)); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
	}
@= scan_only
	BUN rp, rq;
	int bs;
	BATloopFast(b, rp, rq, bs) {
		if (p == *(oid*)BUNtail(b,rp)) { /* FIXME: "tvar" (void) vs. "tloc" (oid) */
			oidoid_bunfastins(bn,&base,BUNhead(b,rp)); /* FIXME: "hvar" (void) vs. "hloc" (oid) */
		}
	}
@= hash_scan
	if (b->thash) {
		@:hash_only@
	} else {
		@:scan_only@
	}
@= sort_scan
	if (BATtordered(b)&1) {
		@:sort_only@
	} else {
		@:scan_only@
	}
@= hash_sort_scan
	if (b->thash) {
		@:hash_only@
	} else if (BATtordered(b)&1) {
		@:sort_only@
	} else {
		@:scan_only@
	}
@= mvaljoin
	for (q = BUNlast(pre) ; pp < q ; pp += bsp, pf += bsf) {
		oid p = *(oid*)BUNtail(pre,pp); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		oid f = *(oid*)BUNtail(frag,pf); /* FIXME: "tvar" (void) vs. "tloc" (oid) */
		if (f >= wl && f <= wh) {
			BAT *b = batlist[f - wl];
			@1
		}
		base++;
	}
@c

	if (all_hash) {
		@:mvaljoin(@:hash_only@)@
	} else if (all_sort) {
		@:mvaljoin(@:sort_only@)@
	} else if (some_hash && some_sort) {
		@:mvaljoin(@:hash_sort_scan@)@
	} else if (some_hash) {
		@:mvaljoin(@:hash_scan@)@
	} else if (some_sort) {
		@:mvaljoin(@:sort_scan@)@
	} else {
		@:mvaljoin(@:scan_only@)@
	}

@= mval_res_prop
	/* set result properties */

	if (!bn->batDirty) bn->batDirty = TRUE;
	triv_prop = (BATcount(bn) < 2);
	BATkey(bn,all_key);
	BATkey(BATmirror(bn),triv_prop);
	bn->hsorted = GDK_SORTED;
	bn->tsorted = triv_prop;
	bn->hdense = triv_prop;
	bn->tdense = triv_prop;
	if (BATcount(bn) == 0) {
		BATseqbase(bn, (oid)0);
		BATseqbase(BATmirror(bn), (oid)0);
	} else if (BATcount(bn) == 1) {
		BATseqbase(bn, *(oid*)BUNhloc(bn,BUNfirst(bn)));
		BATseqbase(BATmirror(bn), *(oid*)BUNtloc(bn,BUNfirst(bn)));
	}

	*res = bn;
@c
	@:mval_res_prop@
	@:mval_free_batlist@

	return GDK_SUCCEED;
bunins_failed:
	GDKerror("mvaljoin: bunins failed.\n");
	BBPreclaim(bn);
@= mval_free_batlist
	while (ii > 0) {
		BBPunfix(batlist[--ii]->batCacheid);
	}
	if (batlist && !fake_frag) {
		GDKfree(batlist);
	}
@c
	@:mval_free_batlist@
	return GDK_FAIL;
}



/*
 * Worker for the ebv() function.
 */
BAT *
BATebv (BAT *b)
{
    BAT *ret = NULL;    /* return value */
    BUN p = 0, q = 0;   /* BUN variables for iteration */
    int bunsz;          /* BUN size used for iteration (BATloopFast) */
    oid old;            /* Last head value we had seen */
    bit val;            /* Boolean result value that belongs to `old' */
    size_t cnt = 0;     /* "guess" of result cardinality */
    bit trivial;        /* indicator for "trivial" result properties */

    /* Just in case BATebv might be called from elsewhere than CMDebv:
     * check, that b in not NULL.
     */
    BATcheck(b, "BATebv");
    /* Input must be sorted by head value, tail must be boolean */
    ERRORcheck (!(BAThordered(b)&1), "BATebv: head of BAT must be sorted.\n");
    /* Needed only, if you want to disallow TYPE_void, 
     * which also matches the oid requirement of the signature;
     * or if BATebv could be called from somewhere/one else than CMDebv.
     */
    ERRORcheck (!(b->htype == TYPE_oid),
                "BATebv: head of BAT must have oid type.\n");
@(
    /* Not needed, if BATebv is only called from CMDebv,
     * since the signature only allows bit-tailed BATs.
     */
    ERRORcheck (!(b->ttype == TYPE_bit),
                "BATebv: tail of BAT must have bit type.\n");
@)

    /* Try to "guess" the result cardinality:
     * on the one hand, we don't want too allocate (far) too much memory;
     * on the other hand, we want to avoid BATextends (i.e., (large) memcpy's),
     * that occur if we initially allow too little space ... 
     * Obviously, BATcount(b) is the upper limit;
     * lower limit is just a "wild guess"...
     */
    if (BAThkey (b))
        cnt = BATcount (b);
    else
        cnt = MIN (200, BATcount (b));

    /* Create return BAT */
    ret = BATnew (b->htype, TYPE_bit, cnt);
    if (!ret)
        return ret;

    /*
     * Iterate over the input BAT.
     * Whenever we see a head value the first time, we record its tail
     * value in val. If we see the same head value a second (third,...)
     * time, we re-set val to false. When we reach the next head
     * value, (old, val) will be the correct BUN for the last group.
     */

    /* Initialize, ... */
    bunsz = BUNsize (b);
    p = BUNfirst (b);
    old = *(oid *) BUNhloc (b, p);
    val = *(bit *) BUNtloc (b, p);
    /* ... skip first, ... */
    p += bunsz;
    /* ... and process the rest. */
    for(q = BUNlast(b); p < q; p += bunsz) {
    	oid *head = (oid *) BUNhloc (b, p);
        if (*head == old)
            val = FALSE;
        else {
            bunfastins (ret, &old, &val);
            old = *head;
            val = *(bit *) BUNtloc (b, p);
        }
    }
    /* Don't forget to produce the last BUN. */
    bunfastins (ret, &old, &val);
    
    /* Set result properties ... */
    cnt = BATcount (ret);
    trivial = (cnt < 2) ? TRUE : FALSE;
    /* ... head ... */
    BATkey (ret, TRUE);
    ret->hsorted = GDK_SORTED;
    ret->hdense = trivial;
    if (trivial == TRUE) {
        if (cnt == 0)
            BATseqbase (ret, (oid)0); /* does not really matter */
        else /* (cnt == 1) */
            BATseqbase (ret, old);
    }
    /* ... tail */
    BATkey (BATmirror(ret), trivial);
    ret->tsorted = trivial;
    ret->tdense = FALSE;

    return ret;

/* required by bunfastins macro */
bunins_failed:
    BBPreclaim(ret);
    return NULL;
}

/*
 * Implementation of ebv(). Basically just calls BATebv().
 */
int
CMDebv (BAT **result, BAT *b)
{
    return (*result = BATebv (b)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDinvalid_qname(str *ret, BAT *b) 
{
        str s = ATOMnilptr(TYPE_str);
	BUN p, q;
	int xx;

	BATloopFast(b,p,q,xx) {
            char *r = BUNtail(b,p);
	    if ((*r >= 'a' && *r <= 'z') || (*r >= 'A' && *r <= 'Z') || *(unsigned char*) r >= 128) {
                r++;
                while((*r >= 'a' && *r <= 'z') || (*r >= 'A' && *r <= 'Z') || (*(unsigned char*) r >= 128) ||
                      (*r == '_') || (*r == '.') || (*r == '-') || (*r >= '0' && *r <= '9')) r++;
                if (*r == 0) continue; /* ok */
            }
	    s = (str) BUNtail(b,p); break;
	}
	*ret = GDKstrdup(s);
        return GDK_SUCCEED;

}


MT_Lock pf_runtime_lock;

int CMDpflock(ptr *ret) {
    *ret = (ptr) pf_runtime_lock;
    return GDK_SUCCEED;
}

int
CMDlastmod_time(timestamp *ret, str filename) {
	struct stat st;
	int year = 1970, one = 1, zero = 0;
	lng msecs;
	timestamp ts;
        daytime dt;
	date d;
	tzone tz;

	if (stat(filename, &st)) {
		return GDK_FAIL;
	}
	msecs = 1000*st.st_mtime;
        return date_create(&d, &year, &one, &one) &&
               daytime_create(&dt, &zero, &zero, &zero, &zero) &&
	       tzone_create(&tz, &zero) &&
               timestamp_create(&ts, &d, &dt, &tz) &&
               timestamp_add(ret, &ts, &msecs);
}

bat* pf_support_prelude() {
    pf_runtime_lock = MT_create_lock();
    return NULL;
}

void pf_support_epilogue() {
    MT_destroy_lock(pf_runtime_lock);
}

@- PROCs required by the algebraic translation ###
@mil
PROC doc_tbl (BAT[void, BAT] ws, BAT[void, str] item) : BAT[void,BAT]
{
    # consider each document only once
    var docs := item.tunique().mark (0@0).reverse ();

    # throw out documents we already have in the working set
    docs := docs.reverse ()
                .kdiff (ws.fetch (DOC_LOADED).reverse ())
                .mark (0@0)
                .reverse ();

    # load all remaining documents into the working set
    docs@batloop () {
        add_doc (ws, $t);
    }

    # The working set now contains all documents we need.

    # pick the according frag value for each document requested
    var ret_frag := item.leftjoin (ws.fetch (DOC_LOADED).reverse ())
                        .reverse ()
                        .mark (0@0)
                        .reverse ();

    # pre values will all be zero
    var ret_item := ret_frag.project (0@0);

    # return result as a BAT of BATs
    return new (void, BAT).append (ws)
                          .append (ret_item)
                          .append (ret_frag)
                          .seqbase (0@0);
}

ADDHELP("doc_tbl", "teubner", "Aug 2005",
                "PARAMETERS:\n\
ws    current working set; will be modified\n\
item  list of documents to add to the working set\n\
DESCRIPTION:\n\
Implementation of the algebra operator `doc_tbl' that\n\
loads persistent documents into the working set.\n\
Input is a list of document names. Output is a BAT of\n\
BATs with the components\n\
(a) the modified working set,\n\
(b) an `item' column with the pre values of the\n\
document roots, and\n\
(c) a `frag' column that encodes document\n\
container (within the working set) according to our\n\
working set representation.",
                "pf_support");

# primitive for supporting highly specific XQuery functionality
PROC merge_adjacent_text_nodes (BAT[void,oid] iter,
                                BAT[void,oid] pre,
                                BAT[void,oid] pfrag,
                                BAT[void,BAT] ws) : BAT[void,oid]
{
    var map := pre.ord_uselect(oid(nil),oid(nil)).hmark(0@0);
    iter := map.leftfetchjoin(iter);
    pre := map.leftfetchjoin(pre);
    pfrag := map.leftfetchjoin(pfrag);

    var kind := mposjoin (pre, pfrag, ws.fetch(PRE_KIND));
    var text := kind.[=](TEXT);
    var text_sel := text.select(true).hmark(0@0);
    var text_pre := text_sel.leftfetchjoin(pre).tmark(0@0);
    var text_frag := text_sel.leftfetchjoin(pfrag).tmark(0@0);

    var text_prop := mposjoin (mposjoin (text_pre, text_frag, ws.fetch(PRE_PROP)),
                               mposjoin (text_pre, text_frag, ws.fetch(PRE_FRAG)),
                               ws.fetch(PROP_TEXT));
    text_pre := nil;
    text_frag := nil;

    var pre_prop := pre.mirror()
                       .outerjoin(text_prop.reverse()
                                           .leftfetchjoin(text_sel)
                                           .reverse());
    var pre_enum := [oid](text);
    var res_size := (iter.tunique().count() 
                  + text.count() + 1)
                  - text_sel.count();

    var res_strs := combine_text_string (iter.chk_order(),
                                         pre_enum,
                                         pre_prop,
                                         res_size);
    iter := nil;
    pre_enum := nil;
    pre_prop := nil;
    res_size := nil;
    var res_texts := text_constr (res_strs.tmark(0@0), ws);
    ws := res_texts.fetch(0);
    var textnodes := res_texts.fetch(1);
    res_texts := nil;
    
    text_pre := pre.mirror()
                   .outerjoin(res_strs.mark(0@0)
                                      .leftfetchjoin(textnodes));
    text_frag := pre.mirror()
                    .outerjoin(res_strs.project(WS));
    res_strs := nil;
    textnodes := nil;
    pre := map.reverse()
              .leftfetchjoin([ifthenelse](text,text_pre,pre));
    pfrag := map.reverse()
                .leftfetchjoin([ifthenelse](text,text_frag,pfrag));

    # return result as a BAT of BATs
    return new (void, BAT).append (ws)
                          .append (pre)
                          .append (pfrag)
                          .seqbase (0@0);
}
ADDHELP("merge_adjacent_text_nodes", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void,str] iter : prefix of qname\n\
BAT[void,str] pre  : URI of the qname\n\
BAT[void,str] frag : local part of the qname\n\
BAT[void,BAT] ws   : working set that stores the qname\n\
DESCRIPTION:\n\
merge_adjacent_text_nodes takes an iter|pre|frag schema and\n\
combines within each iteration all adjacent text nodes.\n\
(Note that the order is given by the input order.)\n\
New textnodes are added into the working set ws and the result is\n\
a bat of bats (ws, modified_pres, modified_frags). The heads of the\n\
pre and frag are aligned to the input relations.",
        "pf_support");
                                
# add_qnames changes the working set as side effect
# without a 'prefix\1uri\1local' index this could be quite expensive
#
# it basically does:
# [ifthenelse]([isnil](local),local.project(nil),[add_qname](prefix,uri,local,local.project(ws)));
PROC add_qnames (BAT[void,str] prefix,
                 BAT[void,str] uri,
                 BAT[void,str] local,
                 BAT[void,BAT] ws) : BAT[void,oid]
{
    # lookup already stored qnames
    var prefix_uri := prefix.[+](str('\1')).[+](uri);
    var propIDs := ws.fetch(QN_PREFIX_URI)
                     .fetch(WS)
                     .leftjoin(prefix_uri.reverse()).mirror();
    var prop_str := propIDs.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    propIDs := prop_str.leftjoin(local.reverse());

    # add missing qnames, that are not the ``nil'' string, to the storage
    var missing := local.select(str(nil),str(nil)).kdiff(propIDs.tmark(0@0));
    var seqb := oid (ws.fetch(QN_LOC).fetch(WS).count() +
                     int (ws.fetch(QN_LOC).fetch(WS).seqbase()));
    var new_names := missing.leftfetchjoin(prefix).[+](str('\1')).[+](
                     missing.leftfetchjoin(uri).[+](str('\1')).[+](
                     missing.leftfetchjoin(local)));
        # only search unique values
        new_names := new_names.kunique();
        # create new key with references to the original ones
        new_names := new_names.hmark(seqb).leftfetchjoin(missing);

    var new_prefix := new_names.leftfetchjoin(prefix);
    var new_uri := new_names.leftfetchjoin(uri);
    var new_local := new_names.leftfetchjoin(local);
    ws.fetch(QN_URI).fetch(WS).insert(new_uri);
    ws.fetch(QN_PREFIX).fetch(WS).insert(new_prefix);
    ws.fetch(QN_LOC).fetch(WS).insert(new_local);
    ws.fetch(QN_PREFIX_URI).fetch(WS).insert(new_prefix.[+](str('\1')).[+](new_uri));
    ws.fetch(QN_LOC_URI).fetch(WS).insert(new_local.[+](str('\1')).[+](new_uri));

    # lookup IDs of the qnames
    var ns := ws.fetch(QN_PREFIX_URI)
                .fetch(WS)
                .leftjoin(prefix_uri.reverse());
    var loc := ws.fetch(QN_LOC).fetch(WS)
                 .leftjoin(local.reverse());
    propIDs := ns.intersect(loc);
    # add missing nil values again
    return local.mirror().outerjoin(propIDs.reverse()).tmark(seqbase(local));
                # the result head is aligned with the heads from the input
}
ADDHELP("add_qnames", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void,str] prefix : prefix of qname\n\
BAT[void,str] uri    : URI of the qname\n\
BAT[void,str] local  : local part of the qname\n\
BAT[void,BAT] ws     : working set that stores the qname\n\
DESCRIPTION:\n\
add_qnames adds qnames consisting of the three strings prefix,\n\
uri, and local to the working set (ws). The return value is the\n\
identifier that corresponds to the qname in the qname container\n\
of the transient nodes.\n\
NOTE: the working set 'ws' is changed as side effect!",
        "pf_support");

# add_qname changes the working set as side effect
PROC add_qname (str prefix, str uri, str local, BAT[void,BAT] ws) : oid
{
    var propID := ws.fetch(QN_PREFIX_URI)
                    .fetch(WS)
                    .ord_uselect(prefix + str('\1') + uri).mirror();
    var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    propID := prop_str.ord_uselect(local);
    prop_str := nil;
    var itemID;
    if (propID.count() = 0)
    {
        itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
        ws.fetch(QN_URI).fetch(WS).insert(itemID, uri);
        ws.fetch(QN_PREFIX).fetch(WS).insert(itemID, prefix);
        ws.fetch(QN_LOC).fetch(WS).insert(itemID, local);
        ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID, prefix + str('\1') + uri);
        ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID, local + str('\1') + uri);
    } else { 
        itemID := propID.reverse().fetch(0);
    }
    return itemID;
}
ADDHELP("add_qname", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
str           prefix : prefix of qname\n\
str           uri    : URI of the qname\n\
str           local  : local part of the qname\n\
BAT[void,BAT] ws     : working set that stores the qname\n\
DESCRIPTION:\n\
add_qname adds a qname consisting of the three strings prefix,\n\
uri, and local to the working set ws. The return value is the\n\
identifier that corresponds to the qname in the qname container\n\
of the transient nodes.\n\
NOTE: the working set 'ws' is changed as side effect!",
        "pf_support");

PROC text_constr (BAT[void, str] item, BAT[void, BAT] ws) : BAT[void,BAT]
{
    # find all strings that are not already in the working set ...
    var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
    var unq_str := item.tunique().hmark(0@0);
    var str_unq := unq_str.reverse().kdiff(ws_prop_text.reverse());
    unq_str := nil;
    # ... and add them to the PROP_TEXT container
    var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
    unq_str := str_unq.hmark(seqb);
    str_unq := nil;
    ws_prop_text := ws_prop_text.insert(unq_str);
    unq_str := nil;

    # get the property values of the strings;
    # we invest in sorting ws_prop_text &  X_strings/item on the TYPE_str 
    # join columns as the mergejoin proved to be faster and more robust with
    # large BATs than a hashjoin
    var ws_text_prop := ws_prop_text.reverse().sort();
    var X_item := item.mark(0@0);
    var X_strings := item.tmark(0@0).tsort();
    var X_prop := X_strings.leftjoin(ws_text_prop);
    X_strings := nil;
    ws_text_prop := nil;
    var newProp := X_item.leftjoin(X_prop);
    X_item := nil;
    X_prop := nil;

    # add new text nodes to the working set
    var seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS)) +
                    int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
    var newPre_prop := newProp.tmark(seqb);
    newProp := nil;
    ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
    ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
    ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
    ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
    ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));

    { # add index entries for optimized scj
        var kind_pre_ := newPre_prop.reverse().chk_order();
        ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).append(kind_pre_);
    }
    newPre_prop := nil;
    item := item.mark(seqb);
    seqb := nil;

    # return result as a BAT of BATs
    var res := new (void, BAT).append (ws)
                              .append (item)
                              .append (item.project(WS))
                              .seqbase (0@0);

    { # adding new fragments to the WS_FRAG bat
        var seqb := ws.fetch(WS_FRAG).count();
        seqb := oid(seqb);
        var new_pres := item.tmark(seqb);
        seqb := nil;
        ws.fetch(WS_FRAG).insert(new_pres);
        new_pres := nil;
        ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
    }

    return res;
}
ADDHELP("text_constr", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void,str] item : content of the text nodes\n\
BAT[void,BAT] ws   : working set that stores the document representations\n\
DESCRIPTION:\n\
text_constr is a generic text constructor that creates for each\n\
item a new textnode. These textnodes are added to the working\n\
set ws. Output is a BAT of BATs with the following components:\n\
(a) the modified working set,\n\
(b) the pre values of the textnodes, and\n\
(c) the frag values of the textnodes",
        "pf_support");

PROC attr_constr (BAT[void, oid] qn, BAT[void, str] item, BAT[void, BAT] ws) : BAT[void,BAT]
{
    # find all strings that are not already in the working set ...
    var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
    var unq_str := item.tunique().hmark(0@0);
    var str_unq := unq_str.reverse().kdiff(ws_prop_val.reverse());
    unq_str := nil;
    # ... and add them to the PROP_VAL container
    var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
    unq_str := str_unq.hmark(seqb);
    str_unq := nil;
    ws_prop_val := ws_prop_val.insert(unq_str);
    unq_str := nil;

    # get the property values of the strings;
    # we invest in sorting ws_prop_val &  X_strings/item on the TYPE_str 
    # join columns as the mergejoin proved to be faster and more robust with
    # large BATs than a hashjoin
    var ws_val_prop := ws_prop_val.reverse().sort();
    var X_item := item.mark(0@0);
    var X_strings := item.tmark(0@0).tsort();
    var X_prop := X_strings.leftjoin(ws_val_prop);
    X_strings := nil;
    ws_val_prop := nil;
    var newProp := X_item.leftjoin(X_prop);
    X_item := nil;
    X_prop := nil;

    # add new text nodes to the working set
    var seqb := oid(count(ws.fetch(ATTR_OWN).fetch(WS)) +
                    int(ws.fetch(ATTR_OWN).fetch(WS).seqbase()));
    var newAttr_prop := newProp.tmark(seqb);
    newProp := nil;
    ws.fetch(ATTR_PROP).fetch(WS).insert(newAttr_prop);
    ws.fetch(ATTR_OWN).fetch(WS).insert(newAttr_prop.project(oid(nil)));
    ws.fetch(ATTR_QN).fetch(WS).insert(qn.tmark(seqb));
    ws.fetch(ATTR_FRAG).fetch(WS).insert(newAttr_prop.project(WS));

    newAttr_prop := nil;
    item := item.mark(seqb);
    seqb := nil;

    # return result as a BAT of BATs
    var res := new (void, BAT).append (ws)
                              .append (item)
                              .append (item.project(WS))
                              .seqbase (0@0);

    return res;
}
ADDHELP("attr_constr", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void,oid] qn   : names of the attributes\n\
BAT[void,str] item : values of the attributes\n\
BAT[void,BAT] ws   : working set that stores the document representations\n\
DESCRIPTION:\n\
attr_constr is a generic attribute constructor that creates for\n\
each aligned qn|item pair a new attribute. These attributes are\n\
added to the working set ws. Output is a BAT of BATs with the\n\
following components:\n\
(a) the modified working set,\n\
(b) the attribute ids, and\n\
(c) the frag values of the attributes",
        "pf_support");

PROC elem_constr_empty (BAT[void, oid] qn, BAT[void, BAT] ws) : BAT[void,BAT]
{
    # add new element nodes to the working set
    var seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS)) +
                    int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
    var newPre_prop := qn.tmark(seqb);
    ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
    ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
    ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
    ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(ELEMENT));
    ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));

    { # add index entries for optimized scj
        var kind_pre_ := newPre_prop.reverse().chk_order();
        ws.fetch(KIND_PRE + int(ELEMENT)).fetch(WS).append(kind_pre_);
    }
    newPre_prop := nil;
    qn := qn.mark(seqb);
    seqb := nil;

    # return result as a BAT of BATs
    var res := new (void, BAT).append (ws)
                              .append (qn)
                              .append (qn.project(WS))
                              .seqbase (0@0);

    { # adding new fragments to the WS_FRAG bat
        var seqb := ws.fetch(WS_FRAG).count();
        seqb := oid(seqb);
        var new_pres := qn.tmark(seqb);
        seqb := nil;
        ws.fetch(WS_FRAG).insert(new_pres);
        new_pres := nil;
        ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
    }

    return res;
}
ADDHELP("elem_constr_empty", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void,oid] qn   : names of the elements\n\
BAT[void,BAT] ws   : working set that stores the document representations\n\
DESCRIPTION:\n\
elem_constr_empty is a generic element constructor for empty\n\
elements that creates for each qname qn a new element. These\n\
elements are added to the working set ws. Output is a BAT of\n\
BATs with the following components:\n\
(a) the modified working set,\n\
(b) the pre values, and\n\
(c) the frag values of the elements",
        "pf_support");

PROC elem_constr (BAT[void, oid] qn_iter,
                  BAT[void, oid] qn_item,
                  BAT[void, oid] iter,
                  BAT[oid, oid] pre,
                  BAT[oid, oid] pfrag,
                  BAT[void, oid] attr,
                  BAT[void, oid] afrag,
                  BAT[void, BAT] ws) : BAT[void,BAT]
{
    var root_iter;
    var root_size;
    var root_prop;
    var root_kind;
    var root_frag;
    var root_level;
    # attr
        var root_pre;
        var root_pre_frag;
        
    # throw out nil values and generate iter|item|frag representation
    # for attributes
    var selected := pre.select(oid(nil),oid(nil));
    var piter := selected.hmark(0@0).leftfetchjoin(iter).tmark(0@0); # make it void
    pre := selected.tmark(0@0);
    pfrag := pfrag.select(oid(nil),oid(nil)).tmark(0@0);
    selected := nil;

    # throw out nil values and generate iter|item|frag representation
    # for attributes
    selected := attr.select(oid(nil),oid(nil));
    var aiter := selected.hmark(0@0).leftfetchjoin(iter).tmark(0@0); # make it void
    attr := selected.tmark(0@0);
    afrag := afrag.select(oid(nil),oid(nil)).tmark(0@0);
    selected := nil;

    if (pre.count() != 0) {

        # use head to avoid elimination of duplicates
        # (this is additionally used in the content level determination
        var iter_unq := piter.mirror();
        # get all subtree copies
        var res_scj := loop_lifted_descendant_or_self_step 
                           (iter_unq, pre, pfrag, ws, 0);
        iter_unq := nil;

        # variables for the result of the scj 
        var res_iter := res_scj.fetch(0);
        var res_item := res_scj.fetch(1);
        # !be aware that res_frag is only a fake_project!
        var res_frag := res_scj.fetch(2);
        # !avoid being res_iter a fake_project!
        res_iter := materialize (res_iter, res_item);
        res_scj := nil;
            
        # create content_iter as sorting argument for the merged union
        var content_iter := res_iter.leftfetchjoin(piter).chk_order();
        # create subtree copies for all bats
        var content_size := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
        var content_prop := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
        var content_kind := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
        var content_frag := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
        var content_level := mposjoin(res_item, res_frag, ws.fetch(PRE_LEVEL));
        # change the level of the subtree copies
        content_level := content_level.[+](chr(1));
        var contentRoot_level := mposjoin(pre, pfrag, ws.fetch(PRE_LEVEL));
        # map Root_level to the result of the scj 
        #using the faked iteration values
        contentRoot_level := res_iter.leftfetchjoin(contentRoot_level);
        content_level := content_level.[-](contentRoot_level);
        content_level := content_level.tmark(0@0);
        contentRoot_level := nil;
            
        # attr
            # content_pre is needed for attribute subtree copies
            var content_pre := res_item;
            # as well as content_pre_frag
            var content_pre_frag := res_frag;
            
        # get the maximum level of the new constructed nodes
        # and set the maximum of the working set
        {
            var height := int(content_level.max()) + 1;
            ws.fetch(HEIGHT).replace(WS, 
                                     max(ws.fetch(HEIGHT).fetch(WS),
                                         height));
            height := nil;
        }
            
        root_iter := qn_iter.chk_order();
        # calculate the sizes for the root nodes
        root_size := {count}(content_iter.reverse(), qn_iter.reverse(), FALSE).tmark(seqbase(qn_iter));
        root_prop := qn_item;
        root_kind := constant2bat(ELEMENT);
        root_frag := constant2bat(WS);
        root_level := constant2bat(chr(0));

        # attr
            # root_pre is a dummy needed for merge union with content_pre 
            root_pre := constant2bat(oid(nil));
            # as well as root_frag_pre
            root_pre_frag := constant2bat(oid(nil));

        # merge union root and nodes
        {
        var merged_result := merged_union (
                                 root_iter, content_iter,
                                 root_size, content_size,
                                 root_level, content_level,
                                 root_kind, content_kind,
                                 root_prop, content_prop,
                                 root_frag, content_frag,
        # attr
                                 root_pre, content_pre,
                                 root_pre_frag, content_pre_frag);
        root_iter := nil;
        content_iter := nil;
        content_size := nil;
        content_level := nil;
        content_kind := nil;
        content_prop := nil;
        content_frag := nil;
        # attr
            content_pre := nil;
            content_pre_frag := nil;
        root_size := merged_result.fetch(1);
        root_level := merged_result.fetch(2);
        root_kind := merged_result.fetch(3);
        root_prop := merged_result.fetch(4);
        root_frag := merged_result.fetch(5);
        # attr
            root_pre := merged_result.fetch(6);
            root_pre_frag := merged_result.fetch(7);

        merged_result := nil;

        # printing output for debugging purposes
            # print("merged (root & content)");
            # print(root_size, [int](root_level), [int](root_kind), root_prop);
        }

    } else { # end of ``if (pre.count() != 0)''

        root_size := qn_iter.project(0);
        root_prop := qn_item; # !the seqbase of qn_item is later modified
        root_kind := qn_iter.project(ELEMENT);
        root_frag := qn_iter.project(WS);
        root_level := qn_iter.project(chr(0));
        # attr
            root_pre := qn_iter.project(oid(nil));
            root_pre_frag := qn_iter.project(oid(nil));

    }  # end of else in ``if (pre.count() != 0)''
        
    # set the offset for the new created trees
    {
        var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))
                        + int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
        root_size := root_size.seqbase(seqb);
        root_prop := root_prop.seqbase(seqb);
        root_kind := root_kind.seqbase(seqb);
        root_frag := root_frag.seqbase(seqb);
        root_level := root_level.seqbase(seqb);
        # attr
            # get the new pre values
            root_pre := root_pre.seqbase(seqb);
            root_pre_frag := root_pre_frag.seqbase(seqb);
        seqb := nil;
    }

    # insert the new trees into the working set
    ws.fetch(PRE_SIZE).fetch(WS).insert(root_size);
    ws.fetch(PRE_KIND).fetch(WS).insert(root_kind);
    ws.fetch(PRE_PROP).fetch(WS).insert(root_prop);
    ws.fetch(PRE_FRAG).fetch(WS).insert(root_frag);
    ws.fetch(PRE_LEVEL).fetch(WS).insert(root_level);

    # update indexes
    {
      var knd := ELEMENT;
      while ( knd <= DOCUMENT ) {
        var kind_root := root_kind.ord_uselect(knd).reverse().chk_order();
        ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind_root);
        if (knd = ELEMENT) {
          var prop_root := kind_root.reverse().mirror()
                                    .leftfetchjoin(root_prop)
                                    .reverse().chk_order();
          ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop_root);
        }
        if (knd = PI) {
          var prop_root := kind_root.reverse().mirror()
                                    .leftfetchjoin(root_prop)
                                    .reverse().chk_order();
          ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop_root);
        }
        knd :+= chr(1);
      }
    }

    # save the new roots for creation of the intermediate result
    var roots := root_level.ord_uselect(chr(0));
    # (note that all operations are order preserving and ``mark''
    # aligns the key with the qn_iter input 
    roots := roots.hmark(0@0);

    # resetting the temporary variables
    root_size := nil;
    root_prop := nil;
    root_kind := nil;
    root_frag := nil;
    root_level := nil;
        
    # adding the new constructed roots to the WS_FRAG bat of the
    # working set, that a following (preceding) step can check
    # the fragment boundaries
    {
        var seqb := oid(count(ws.fetch(WS_FRAG)));
        var new_pre_values := roots.tmark(seqb);
        seqb := nil;
        ws.fetch(WS_FRAG).insert(new_pre_values);
        new_pre_values := nil;
    }

    # ----------------------------------
    # ----- ATTRIBUTE TRANSLATION ------
    # ----------------------------------
    # 1. step: add subtree copies of attributes
    if (pre.count() != 0) { # but only if there are any subtree nodes
        # lookup the affected attributes using the old pre values
        var preNew_attr := mvaljoin(root_pre, 
                                    root_pre_frag,
                                    ws.fetch(ATTR_OWN));
        # lookup the first free attr value
        var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
        # split up result of mvaljoin and mark them with the correct seqbase
        var attrNew_preNew := preNew_attr.mark(seqb).reverse();
        var attrNew_attrOld := preNew_attr.reverse().mark(seqb).reverse();
        preNew_attr := nil;
        var attrNew_pre_frag := attrNew_preNew.leftfetchjoin(root_pre_frag);
        # help MIL to keep head void
        attrNew_pre_frag := attrNew_pre_frag.reverse().mark(seqb).reverse();
        seqb := nil;

        # get the values of the QN/OID offsets for the reference to the
        # string values
        var attrNew_qn := mposjoin(attrNew_attrOld,
                                   attrNew_pre_frag,
                                   ws.fetch(ATTR_QN));
        var attrNew_prop := mposjoin(attrNew_attrOld,
                                     attrNew_pre_frag,
                                     ws.fetch(ATTR_PROP));
        # get fragment where values are stored (not where attribute is stored)
        var attrNew_frag := mposjoin(attrNew_attrOld,
                                     attrNew_pre_frag,
                                     ws.fetch(ATTR_FRAG));
        attrNew_attrOld := nil;
        attrNew_pre_frag := nil;

        ws.fetch(ATTR_QN).fetch(WS).insert(attrNew_qn);
        ws.fetch(ATTR_PROP).fetch(WS).insert(attrNew_prop);
        ws.fetch(ATTR_OWN).fetch(WS).insert(attrNew_preNew);
        ws.fetch(ATTR_FRAG).fetch(WS).insert(attrNew_frag);
        attrNew_qn := nil;
        attrNew_prop := nil;
        attrNew_preNew := nil;
        attrNew_frag := nil;
    }

    # 2. step: add attribute binding for new elements
    if (attr.count() != 0) { # but only if there are any top level attributes
        
        # use iter, qn and frag to find unique combinations
        var attr_qn := mposjoin(attr, afrag, ws.fetch(ATTR_QN));
        var attr_frag := mposjoin(attr, afrag, ws.fetch(ATTR_FRAG));
        var sorting := aiter.tsort();
        sorting := sorting.CTrefine(mposjoin(attr_qn,
                                             attr_frag,
                                             ws.fetch(QN_LOC_URI)));
        var unq_attrs := sorting.tunique();
        sorting := nil;
        # test uniqueness
        if (unq_attrs.count() != aiter.count())
        {
           if (qn_item.count() > 0) {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.",
                      qn_item.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS))
                             .fetch(0));
           } else {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
           }
        }
        unq_attrs := nil;

        var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
        attr_qn := attr_qn.seqbase(seqb);
        var attr_own := aiter.leftjoin(qn_iter.reverse())
                             .leftfetchjoin(roots)
                             .reverse().mark(seqb).reverse();
        var attr_prop := mposjoin(attr, afrag, ws.fetch(ATTR_PROP));
        attr_prop := attr_prop.seqbase(seqb);
        attr_frag := attr_frag.seqbase(seqb);
        seqb := nil;

        ws.fetch(ATTR_QN).fetch(WS).insert(attr_qn);
        ws.fetch(ATTR_PROP).fetch(WS).insert(attr_prop);
        ws.fetch(ATTR_OWN).fetch(WS).insert(attr_own);
        ws.fetch(ATTR_FRAG).fetch(WS).insert(attr_frag);
        attr_qn := nil;
        attr_prop := nil;
        attr_own := nil;
        attr_frag := nil;
    }

    # create result as a BAT of BATs
    var res := new (void, BAT).append (ws)
                              .append (roots)
                              .append (roots.project(WS))
                              .seqbase (0@0);
    roots := nil;

    return res;
}
ADDHELP("elem_constr", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void, oid] qn_iter : iteration values of the qnames\n\
BAT[void, oid] qn_item : names of the elements\n\
BAT[void, oid] iter    : iteration values of the content\n\
BAT[oid, oid] pre      : pre values of the content (heads aligned with head of iter)\n\
BAT[oid, oid] pfrag    : node frag values of the content (heads aligned with head of iter)\n\
BAT[void, oid] attr    : attribute ids of the content (heads aligned with head of iter)\n\
BAT[void, oid] afrag   : attribute fragments of the content (heads aligned with head of iter)\n\
BAT[void, BAT] ws      : working set that stores the document representations\n\
DESCRIPTION:\n\
elem_constr is a full featured element constructor that requires\n\
qn|iter pairs for the name part and iteration, attribute, and node\n\
information for the content. These elements are added to the working\n\
set ws. Output is a BAT of BATs with the following components:\n\
(a) the modified working set,\n\
(b) the pre values, and\n\
(c) the frag values of the elements",
        "pf_support");
