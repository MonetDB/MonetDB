@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2007 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'

@f serialize
@a Jan Flokstra
@a Jan Rittinger
@t serialize

@c
/**
 * The serialization code consists of 8 different blocks:
 * 
 *    I. LOCAL HELPER FUNCTIONS
 *       * local error routine
 *       * timer functions
 *       
 *   II. TAGNAME STACK HANDLING FUNCTIONS
 *       * tagname stack access (push/pop/find item)
 *       
 *  III. NAMESPACE HANDLING FUNCTIONS
 *       * namespace stack intialization/disposal
 *       * namespace stack access (push/pop/find item)
 *       * namespace attribute generation
 *         - elements
 *         - attributes (also contains the 'real' attribute callbacks)
 * 
 *   IV. THE DOCUMENT MANAGEMENT FUNCTIONS
 *       * lookup of values/columns in the working set container
 *
 *    V. THE CONTEXT NODE SERIALIZATION PART
 *       * attribute/node function that collect the nodes of a given
 *         range and its values before triggering the node callbacks
 *
 *   VI. INITIALIZATION AND CLEANUP FUNCTIONS OF THE MAIN ROUTINES 
 *       * intialization/disposal of the structures required by
 *         result drivers (e.g. serialization mode selection)
 *
 *  VII. THE MAIN XML DOCUMENT PRINTING PART
 *       * functions that lookup the document container and
 *         trigger the CONTEXT NODE SERIALIZATION PART
 * 
 * VIII. THE MAIN PATHFINDER QUERY RESULT SERIALIZATION
 *       * driver that triggers the respective callbacks and 
 *         helper functions (I.- VI.)
 */
@h
#ifndef SERIALIZE_H
#define SERIALIZE_H

#include "gdk.h"

/* boolean type `bool' and constants `true', `false' */
#ifdef HAVE_STDBOOL_H
#include <stdbool.h>
#elif !defined(HAVE_BOOL)
#define bool    char
#define true    (char)1
#define false   (char)0
#endif

#define SUCCESS true
#define PROBLEM false

#define MAXTAGDEPTH        1024

#define WS_BATS     WS_SIZE

/* serialization modes */
#define MODE_XML       (1 << 0)
#define MODE_DM        (1 << 1)
#define MODE_SAX       (1 << 2)
#define MODE_MAPI      (1 << 3)
#define MODE_SEQ       (1 << 4)
#define MODE_NO_ROOT   (1 << 5)
#define MODE_NO_HEADER (1 << 6) /* without the line <?xml ...?> */
#define MODE_TYPED     (1 << 7)
#define MODE_XRPC      (1 << 8)

struct XmlNsFrame; /* forward */
typedef struct XmlNsFrame {
    char              *prefix;
    char              *uri;
    struct XmlNsFrame *prev;
    struct XmlNsFrame *next;
} XmlNsFrame;

typedef struct SerializeFrame {
    oid         limit;
    char       *prefix;
    char       *name;
    XmlNsFrame *nsMark;
} SerializeFrame;

/**
 * The definition of the working-set BAT structure. For every bat in the
 * working set there is a structure of this type in the wsMatrix matrix
 * representation of the working set. The first dimension is the container
 * of the bat and the second is the BAT id.
 */
typedef struct wsBatDescr {
    BAT *bat;
    ptr  fake_prj;
} wsBatDescr;

struct serializeFunStruct; /* forward */

/**
 * The serialization context structure. All context/runtime data is
 * accessed through this function.
 */
typedef struct XqueryCtx {
    stream*     out;      /* output stream */
    int         modes;     /* list of bit-wise encode modes */
    struct serializeFunStruct* driverFun; /* the output handling functions */
    void*       driverWs;  /* optional driver workspace */
    
    BAT*        ws;        /* working set BAT */
    int         wsConts;   /* The number of containers in the working set */
    wsBatDescr *wsMatrix;  /* the direct references to BATs collected in ws */
    
    XmlNsFrame *nsTop;     /* top of the namespace stack */
    /**
     * Next elements is a stack used during printing to store the
     * pre-value, name, namespace of the nodes currently being printed.
     */
    int            stackPtr;
    SerializeFrame tagStack[MAXTAGDEPTH];
} XqueryCtx;

/**
 * printing callback struct
 *
 * XqueryCtx is only used by the sequence layout handlers
 * and serialization modes that print into a user-defined
 * buffer (whose reference is stored in the XqueryCtx).
 */ 
typedef struct serializeFunStruct {
    const char* name;
    /* the initialization handler */
    bool (*init)(XqueryCtx* ctx, char* args, char* restag,
                 char* resprefix, char* module, char* method);
    /* the clean up handler */
    bool (*cleanup)(XqueryCtx* ctx);

    /* handlers of start/end of serialization.  These functions are
     * only executed _once_ for every serialization. */
    bool (*handle_startSerialize)(XqueryCtx* ctx);
    bool (*handle_endSerialize)(XqueryCtx* ctx);
    
    /* the (part of) document handler functions */
    bool (*handle_startDocument)(XqueryCtx* ctx, oid pre);
    bool (*handle_endDocument)(XqueryCtx* ctx);
    bool (*handle_startElement)(XqueryCtx* ctx,
                                str prefix, str name, oid pre);
    bool (*handle_endElement)(XqueryCtx* ctx, str prefix, str name);
    bool (*handle_characters)(XqueryCtx* ctx, str chars);
    bool (*handle_ignorableWhitespace)(XqueryCtx* ctx, str chars);
    bool (*handle_comment)(XqueryCtx* ctx, str comm);
    bool (*handle_processingInstruction)(XqueryCtx* ctx,
                                         str target, str data);

    /* additional callbacks for attributes and
       start tag completion */
    bool (*complete_startElement)(XqueryCtx* ctx);
    bool (*complete_startElementEmpty)(XqueryCtx* ctx);
    bool (*handle_attribute)(XqueryCtx* ctx, 
                             str prefix, str loc, str value);

    /* the top level item handlers 
       (except elements, comments, and processing-instructions) */
    bool (*seqEmitBool)(XqueryCtx* ctx, int bv);
    bool (*seqEmitInt)(XqueryCtx* ctx, lng iv);
    bool (*seqEmitDbl)(XqueryCtx* ctx, dbl dv);
    bool (*seqEmitStr)(XqueryCtx* ctx, str sv);
    bool (*seqEmitAttribute)(XqueryCtx* ctx,
                             str prefix, str loc, str value);
    bool (*seqEmitTextnodes)(XqueryCtx* ctx, str chars);

    /* and finally the sequence layout handlers */
    bool (*seqStart)(XqueryCtx* ctx, int count);
    bool (*complete_seqStart)(XqueryCtx* ctx);
    bool (*seqEnd)(XqueryCtx* ctx);
    bool (*seqItemStart)(XqueryCtx* ctx, int kind);
    bool (*seqItemEnd)(XqueryCtx* ctx, int kind);
    bool (*seqItemSeparator)(XqueryCtx* ctx, int kind_bef, int kind_aft);
} serializeFunStruct;

/* list of all available callback routines */
extern struct serializeFunStruct
    nullSerializeFun,
    saxSerializeFun,
    dmSerializeFun,
    mapi_dmSerializeFun,
    xmlSerializeFun,
    mapi_xmlSerializeFun,
    typed_xmlSerializeFun,
    mapi_typed_xmlSerializeFun,
    xrpc_xmlSerializeFun,
    mapi_xrpc_xmlSerializeFun,
    seqSerializeFun;

/* hack to allow direct calls in serialize_pftijah.mx */
int
xquery_print_doc_DRIVER (
    str                 mode, 
    serializeFunStruct *driverFun,
    char               *driverArg,
    BAT                *ws,
    str                 docName);

/* hack to allow direct calls in serialize_pftijah_options.mx */
int
xquery_print_result_DRIVER (
    str                 mode,
    str                 moduleNS,
    str                 method,
    serializeFunStruct *driverFun, /* unused */
    char               *driverArg, /* unused */
    BAT                *ws,
    size_t              niters,
    BAT                *loop,
    BAT                *iter,
    BAT                *item, 
    BAT                *kind,
    BAT                *intVAL,
    BAT                *dblVAL,
    BAT                *strVAL);

/* hack to allow direct calls in xrpc_client.mx */
int
xquery_print_result_driver (
    stream             *fp,
    str                 mode,
    str                 module,
    str                 method,
    serializeFunStruct *driverFun, /* unused */
    char               *driverArg, /* unused */
    BAT                *ws,
    size_t              niters,
    BAT                *loop,
    BAT                *iter,
    BAT                *item, 
    BAT                *kind,
    BAT                *intVAL,
    BAT                *dblVAL,
    BAT                *strVAL);

#endif /* SERIALIZE_H */
@c

/*******************************************
 * serialize.c : XML serialization
 *
 */

#include <pf_config.h>
#include "serialize.h"
#include "pf_support.h"

/**
 *
 * I. LOCAL HELPER FUNCTIONS
 *
 */

/**
 * The local error handler for the serialization.
 */
static void
fatal_err(XqueryCtx* ctx, const char *msg, ...)
{
    va_list msgs;
    char    errmsg[1024];

    (void)ctx;
    va_start (msgs, msg);
    vsnprintf (errmsg, 1024, msg, msgs);
    va_end (msgs);

    GDKerror("XML Generation: %s\n",errmsg);
}

/* some timer functions */
/* #define SHOW_TIMING */

#ifdef SHOW_TIMING

static char *
timer_str (long elapsed)
{
    char *tm, *str;

    tm = str = strdup ("000h 00m 00s 000ms 000us");

    if (elapsed / 3600000000UL) {
        str += sprintf (str, "%03ldh ", elapsed / 3600000000UL);
        elapsed %= 3600000000UL;
    }

    if (elapsed / 60000000UL) {
        str += sprintf (str, "%02ldm ", elapsed / 60000000UL);
        elapsed %= 60000000UL;
    }

    if (elapsed / 1000000UL) {
        str += sprintf (str, "%02lds ", elapsed / 1000000UL);
        elapsed %= 1000000UL;
    }

    if (elapsed / 1000UL) {
        str += sprintf (str, "%03ldms ", elapsed / 1000UL);
        elapsed %= 1000UL;
    }

    str += sprintf (str, "%03ldus", elapsed);

    return tm;
}

#define TIMER_START() \
        struct timeval now; \
        (void) gettimeofday (&now, 0); \
        long start = now.tv_sec * 1000000 + now.tv_usec;
#define TIMER_STOP(...) \
        gettimeofday (&now, 0); \
        long stop = now.tv_sec * 1000000 + now.tv_usec; \
        fprintf(stderr, __VA_ARGS__); \
        fprintf(stderr, ": %s\n", timer_str (abs (stop - start)));
#else
#define TIMER_START()
#define TIMER_STOP(...)
#endif


/**
 *
 * II. TAGNAME STACK HANDLING FUNCTIONS
 *
 */

/**
 * Three function to retrieve the pre-value, prefix or nodename of the
 * top element on the stack.
 */
#define topSF(ctx)    (&ctx->tagStack[(ctx)->stackPtr - 1])
#define topPrefix(ctx)    (topSF(ctx)->prefix)
#define topName(ctx)  (topSF(ctx)->name)

/**
 * Return true if there are still nodes on stack.
 */
#define moreTags(ctx) ((ctx)->stackPtr > 0)

/**
 * Push the pre-value, namespace and nodename of stack
 */
static bool
pushTag(XqueryCtx* ctx, oid pre, str prefix, str name) {
    ctx->tagStack[ctx->stackPtr].limit  = pre;
    ctx->tagStack[ctx->stackPtr].prefix = prefix;
    ctx->tagStack[ctx->stackPtr].name = name;
    ctx->tagStack[ctx->stackPtr].nsMark = NULL;
    ctx->stackPtr++;

    if (ctx->stackPtr == MAXTAGDEPTH)
        return PROBLEM;

    return SUCCESS;
}

/* forward declaration */
static void xmlNsPop2 (XmlNsFrame** top, XmlNsFrame* newTop);

/**
 * Pop the top element of the stack. Means that processing the node has
 * finished.
 */
static void
popTag (XqueryCtx* ctx) 
{
    XmlNsFrame *xnf;
    if ( (xnf = topSF(ctx)->nsMark) ) {
        xmlNsPop2(&ctx->nsTop,xnf->prev);
    }
    --ctx->stackPtr;
}


/**
 *
 * III. NAMESPACE HANDLING FUNCTIONS
 *
 */

/* #define DEBUGNS */

static void
xmlNsInit (XmlNsFrame** top)
{
#ifdef DEBUGNS
    stream_printf(GDKerr,"+NS:xmlNsInit()\n");
#endif

    *top = NULL;
}

static XmlNsFrame *
xmlNsPush (XmlNsFrame** top, char* prefix, char* uri)
{
    XmlNsFrame* fp = (XmlNsFrame*) GDKmalloc (sizeof (XmlNsFrame));

    if ( fp ) {
#ifdef DEBUGNS
        stream_printf (GDKerr, "+NS:xmlNsPush(\"%s\",\"%s\")\n", prefix, uri);
#endif
        fp->prefix = NULL;
        fp->uri    = NULL;

        if ( prefix && !(fp->prefix = GDKstrdup(prefix)) ) return NULL;
        if ( uri    && !(fp->uri    = GDKstrdup(uri))    ) return NULL;

        fp ->next  = NULL;
        if ( *top ) {
            (*top)->next = fp;
            fp->prev     = *top;
        } else {
            fp->prev = NULL;
        }
        *top     = fp;
    }
    return fp;
}

static void
xmlNsPop2 (XmlNsFrame** top, XmlNsFrame* newTop)
{
    XmlNsFrame* fp = (*top);

#ifdef DEBUGNS
    stream_printf(GDKerr,"+NS:xmlNsPop2(%d)\n",(int)newTop);
#endif

    while (fp != newTop ) {
        XmlNsFrame* old = fp;
        fp = fp->prev;
#ifdef DEBUGNS
        stream_printf(GDKerr,
                      "+NS:-popping(\"%s\",\"%s\")\n",
                      old->prefix, old->uri);
#endif
        GDKfree(old->prefix);
        GDKfree(old->uri);
        GDKfree(old);
    }
    
    *top = newTop;

    if (newTop) {
        (*top)->next = NULL;
    };
}

static void
xmlNsDispose(XmlNsFrame** top)
{
    xmlNsPop2(top,NULL);
}

static char *
xmlNsPrefixFind (XmlNsFrame** top, char* uri)
{
    XmlNsFrame* fp = (*top);

    while( fp ) {
        if (fp->uri != NULL &&
            !strcmp (uri, fp->uri)) {
#ifdef DEBUGNS
            stream_printf (GDKerr,
                           "+NS:xmlNsPrefixFind(\"%s\")=\"%s\")\n",
                           uri, fp->uri);
#endif
            return fp->prefix;
        }
        fp = fp->prev;
    }
    return NULL;
}

static char *
xmlNsUriFind (XmlNsFrame** top, char* prefix)
{
    XmlNsFrame* fp = (*top);

    while( fp ) {
        if (fp->prefix != NULL &&
            !strcmp (prefix, fp->prefix)) {
#ifdef DEBUGNS
            stream_printf (GDKerr,
                           "+NS:xmlNsUriFind(\"%s\")=\"%s\")\n",
                           prefix, fp->prefix);
#endif
            return fp->uri;
        }
        fp = fp->prev;
    }
    return NULL;
}

@= addNsLink
    /* link the current namespace entry (xnf)
       to the active element node (topSF(ctx)) */ 
    SerializeFrame* sf = topSF(ctx);

    if ( !sf->nsMark ) {
        /* not the first nsFrame in this context */
        sf->nsMark = xnf;
    }

@= checkElemNsChange
/**
 * Namespace checking function for element that introduces a namespace
 * attribute whenever necessary.
 *
 * This function relies on the fact that each element can redefine
 * every namespace (except the special ones) as it creates a new 
 * 'namespace scope'.
 */
static bool
check@1NsChange (XqueryCtx* ctx, str par_uri, str par_prefix)
{
    char *uri, *prefix;

    assert (par_uri && par_prefix);

    if (!strcmp (par_uri, str_nil))
        uri = NULL;
    else
        uri = par_uri;

    if (!strcmp (par_prefix, str_nil))
        prefix = NULL;
    else
        prefix = par_prefix;

    char* currentURI = xmlNsUriFind (&ctx->nsTop, prefix);
    
    /* either: matching prefix found and URIs differ 
       -> redefine namespace
       or: no matching prefix found and we have a namespace that differs from
           the default element namespace (prefix = "", uri = "")
       -> define namespace */
    if ( (currentURI && strcmp (currentURI, uri)) ||
         (!currentURI && (*par_prefix != 0 || *par_uri != 0)) ) {
        
        /* redefine this prefix with the new URI */
        XmlNsFrame* xnf;

        if ( !(xnf = xmlNsPush (&ctx->nsTop, prefix, uri)) ) {
            fatal_err(ctx,"xmlNsPush: out of memory\n");
            return PROBLEM;
        }
        /* generate the xmlns:xxx=uri tag */
        ctx->driverFun->@2 (ctx, "xmlns", prefix, uri);

        @3
    }
    return SUCCESS;
}
@c
@:checkElemNsChange(Elem,handle_attribute,@:addNsLink@)@
@:checkElemNsChange(TopAttrHelper,seqEmitAttribute,(void)xnf; /* pacify compiler */)@

@= checkAttrNsChange
static bool
check@1AttrNsChange (XqueryCtx* ctx,
                     str par_uri,
                     str par_prefix,
                     str loc,
                     str val)
{
    char *uri, *prefix;

    assert (par_uri && par_prefix);

    /* attributes without prefix do not have a namespace */
    if (*par_prefix == 0)
        return ctx->driverFun->@2 (ctx, par_prefix, loc, val);

    if (!strcmp (par_uri, str_nil))
        uri = NULL;
    else
        uri = par_uri;

    if (!strcmp (par_prefix, str_nil))
        prefix = NULL;
    else
        prefix = par_prefix;

/* @3 is bound to 1 in case of a top level attribute
   and 0 otherwise. This allows more readable C macros in-place
   instead of pasting the code with Mx macros */

#if @3 /* top level attribute */
    XmlNsFrame *fp = ctx->nsTop;
    
    /* check in current node context if a namespace
       with this prefix is declared */
    while (fp) {
        if (!strcmp (prefix, fp->prefix))
            break;
            
        fp = fp->prev;
    }
#else /* embedded attribute */
    XmlNsFrame *limit = topSF(ctx)->nsMark,
               *fp = ctx->nsTop;
    
    /* no namespace conflicts arise in the current element */
    if (!limit) {
        if (!check@4NsChange (ctx, par_uri, par_prefix))
            return PROBLEM;

        return ctx->driverFun->@2 (ctx, prefix, loc, val);
    }


    /* check in current node context if a namespace
       with this prefix is declared */
    while (fp) {
        if (!strcmp (prefix, fp->prefix))
            break;
            
        if (fp == limit)
            fp = NULL;
        else
            fp = fp->prev;
    }
#endif
    
    /* no namespace conflicts arise in the namespace stack */
    if (!fp) {
        if (!check@4NsChange (ctx, par_uri, par_prefix))
            return PROBLEM;

        return ctx->driverFun->@2 (ctx, prefix, loc, val);
    }


    /* uri and prefix match -> no namespace attribute needed */
    if (!strcmp (uri, fp->uri))
        return ctx->driverFun->@2 (ctx, prefix, loc, val);


    /* uri is defined with an available (but differing) prefix:
       use the alternative prefix */
    char *currentUri, *currentPrefix = xmlNsPrefixFind (&ctx->nsTop, uri);
    if (currentPrefix && 
        (currentUri = xmlNsUriFind (&ctx->nsTop, currentPrefix)) &&
        /* check if prefix has been redeclared */
        !strcmp (currentUri, uri))
        return ctx->driverFun->@2 (ctx, currentPrefix, loc, val);


    /* no alternatives left - generate new prefix */
    int i = 1;
    char *newPrefix = (char *) GDKmalloc (strlen (prefix) + sizeof ("_000"));
    sprintf (newPrefix, "%s_%i", prefix, i);
    
    /* check if new prefix is unused (and generate new one if used) */
    while (xmlNsUriFind (&ctx->nsTop, newPrefix)) {
        i++;
        if (i == 1000) { GDKfree (newPrefix); return PROBLEM; }
        sprintf (newPrefix, "%s_%i", prefix, i);
    }
        
    /* store this new prefix with the URI */
    XmlNsFrame* xnf;

    if ( !(xnf = xmlNsPush (&ctx->nsTop, newPrefix, uri)) ) {
        fatal_err(ctx,"xmlNsPush: out of memory\n");
        { GDKfree (newPrefix); return PROBLEM; }
    }
    /* generate the xmlns:xxx=uri tag */
    if (!ctx->driverFun->@2 (ctx, "xmlns", newPrefix, uri))
        { GDKfree (newPrefix); return PROBLEM; }

    @5 /* link the current namespace entry to the active element node */
        
    if (!ctx->driverFun->@2 (ctx, newPrefix, loc, val))
        { GDKfree (newPrefix); return PROBLEM; }

    GDKfree (newPrefix);

    return SUCCESS;
}        
@c
@:checkAttrNsChange(,   handle_attribute,0,Elem,         @:addNsLink@)@
@:checkAttrNsChange(Top,seqEmitAttribute,1,TopAttrHelper,(void)xnf; /* pacify compiler */)@


/**
 *
 * IV. THE DOCUMENT MANAGEMENT FUNCTIONS
 *
 */

/* #define DEBUGWS */

/**
 * Functions fills a new context() record with mode and BAT data and
 * initializes all other data structures.
 */

#define CHECKWSMI(CTX,F,B,R) if (((F)>=CTX->wsConts)||((B)>=WS_BATS)) \
    { fatal_err (CTX,"WSbat [%d,%d] out of range.",F,B); R; }
#define WSMI(F,B) ((F)*WS_BATS+B)

#define IS_FAKE_PROJECT(b) ((b->batCount == 1) & \
                            (b->hseqbase == oid_nil) & \
                            (b->htype == TYPE_void))

static bool
initWsMatrix(XqueryCtx* ctx)
{
    oid first = 0;
    BUN bun;
    BAT* batbat = NULL;
    if ( !(bun = BUNfnd(ctx->ws,&first)) ) {
        fatal_err(ctx,"initWsMatrix: cannot find ws-bat[0]");
        return PROBLEM;
    }
    if ( !( batbat = BATdescriptor(*(bat*)bun)) ) {
        fatal_err(ctx,"initWsMatrix: cannot find ws-bat[0]");
        return PROBLEM;
    }

    ctx->wsConts = BATcount(batbat);
    BBPunfix( BBPcacheid( batbat ) );
    if ( !( ctx->wsMatrix = (wsBatDescr*) GDKmalloc(ctx->wsConts*WS_BATS*sizeof(wsBatDescr))) ) {
        return PROBLEM;
    }
    for(int i=0; i<ctx->wsConts; i++) {
        for(int j=0; j<WS_BATS; j++) {
         CHECKWSMI(ctx,i,j,return PROBLEM);
         wsBatDescr* bd = &ctx->wsMatrix[WSMI(i,j)];

         bd->bat = NULL;
        }
    }
#ifdef DEBUGWS
    stream_printf(GDKerr, "+ initWsMatrix(wsConts=%d, wsBats=%d).\n",
                  ctx->wsConts, ctx->wsBats);
#endif

    return SUCCESS;
}

static bool
disposeWsMatrix(XqueryCtx* ctx)
{
    for(int i=0; i<ctx->wsConts; i++) {
        for(int j=0; j<WS_BATS; j++) {
         CHECKWSMI(ctx,i,j,continue);
         wsBatDescr* bd = &ctx->wsMatrix[WSMI(i,j)];

         if ( bd->bat ) {
#ifdef DEBUGWS
          stream_printf(GDKerr,
                              "+ disposeWsMatrix(close(cont=%d,bats=%d))\n",
                              i, j);
#endif
          BBPunfix( BBPcacheid( bd->bat ) );
          bd->bat = NULL;
         }
        }
    }
#ifdef DEBUGWS
    stream_printf(GDKerr,"+ disposeWsMatrix() finished.\n");
#endif
    return SUCCESS;
}

static BAT *
fetchWsBaseBAT(XqueryCtx* ctx, BAT* ws, int batID)
{
    BUN bun;
    oid BATid = (oid)batID;

    if ( !(bun = BUNfnd(ws,&BATid)) ) {
        fatal_err(ctx,"fetchWsContextBAT: NOT FOUND BAT[%d]",batID);
        return NULL;
    }
    BAT* batbat;
    if ( !( batbat = BATdescriptor(*(bat*)bun)) ) {
        fatal_err(ctx,
                  "fetchWsBaseBAT:FETCH BASEBAT for WS[%d] FAILED\n",
                  batID);
        return NULL;
    }
    return batbat;
}

/* lookup a BAT referenced in the working set BAT ws by batID and contID */
static BAT *
fetchWsContextBAT (XqueryCtx* ctx, BAT* ws, int contID, int batID)
{
    BUN bun;
    oid BATid = (oid)batID;
    oid CONTid  = (oid)contID;

    if ( contID < 0 ) {
        fatal_err(ctx,"fetchWsContextBAT: NO contID CONTEXT SELECTED");
        return NULL;
    }
    if ( !(bun = BUNfnd(ws,&BATid)) ) {
        fatal_err(ctx,"fetchWsContextBAT: NOT FOUND BAT[%d]",batID);
        return NULL;
    }
    BAT* batbat;
    if ( !( batbat = BATdescriptor(*(bat*)bun)) ) {
        fatal_err(ctx,
                  "fetchWsContextBAT:FETCH BATBAT for WS[%d][%d] FAILED\n",
                  batID, contID);
        return NULL;
    }
    BUN bbun = BUNfnd(batbat,&CONTid);
    BAT *res = NULL;
    if ( !bbun ) {
        BBPunfix( BBPcacheid( batbat ) );
        fatal_err(ctx,
                  "fetchWsContextBAT:NOT FOUND BAT[%d][%d] in WS!!!!\n",
                  batID, contID);
        return NULL;
    } else {
        if ( !(res = BATdescriptor(*(bat*)bbun)) ) {
            BBPunfix( BBPcacheid( batbat ) );
            fatal_err(ctx,
                      "fetchWsContextBAT:FETCH WS[%d][%d] FAILED\n",
                      batID,contID);
            return NULL;
        }
    }
    BBPunfix( BBPcacheid( batbat ) );
    return res;
}

/* lookup a BAT referenced by batID and contID.
   -- If the BAT is not already loaded it will be looked
   up in the working set BAT ws */
static wsBatDescr *
getMatrixBATrecord (XqueryCtx* ctx, int contID, int batID)
{
    wsBatDescr* bd;

    CHECKWSMI(ctx,contID,batID,return PROBLEM);
    bd = &ctx->wsMatrix[WSMI(contID,batID)];
    
    if ( !bd->bat ) {
        if ( !(bd->bat = fetchWsContextBAT(ctx,ctx->ws,contID,batID)) ) {
#ifdef DEBUGWS
         stream_printf(GDKerr,
                          "+ getMatrixBAT(open(cont=%d,bats=%d)) = FAIL\n",
                          contID, batID);
#endif
         return NULL;
        }
        if ( IS_FAKE_PROJECT(bd->bat) ) {
             bd->fake_prj = BUNtail(bd->bat,BUNfirst(bd->bat));
        } else
             bd->fake_prj = 0;
     
#ifdef DEBUGWS
     stream_printf(GDKerr,
                      "+ getMatrixBAT(open(cont=%d,bats=%d)) = SUCCES\n",
                      contID, batID);
#endif
    }
    return bd;
}

static INLINE BAT *
getMatrixBAT (XqueryCtx* ctx, int contID, int batID)
{
     wsBatDescr* res = getMatrixBATrecord(ctx,contID,batID);

     return (res?res->bat:NULL);
}

/**
 * The getWsBAT() function is responsible for the BAT with index
 * 'batID from container' contID in the working set
 */
#define getWsBAT(_b, ctx, contID, batID) {                            \
    _b = getMatrixBAT(ctx,contID,batID);                              \
    if ( _b == NULL ) {                                               \
        fatal_err(ctx, "getWsBAT(id=%d,cont=%d) fails",batID,contID); \
        return GDK_FAIL;                                              \
    }                                                                 \
}

static int
idxTVerror1 (XqueryCtx* ctx, BAT *b, oid oid_index)
{ 
    fatal_err(ctx, "%s BAT does not have a " OIDFMT " head.\n",
             b?BBP_logical(b->batCacheid):"NULL", oid_index);
    return GDK_FAIL;
}

static int
idxTVerror2 (XqueryCtx* ctx, BAT *b)
{ 
    BATprint(b); 
    fatal_err(ctx, "%s BAT is empty.\n",
             b?BBP_logical(b->batCacheid):"NULL");
    return GDK_FAIL;
}

static int
idxTVerror3 (XqueryCtx* ctx, BAT *b, oid oid_index)
{ 
    fatal_err(ctx, "%s BAT has a " OIDFMT " head, but tail is NULL.\n",
             b?BBP_logical(b->batCacheid):"NULL", oid_index);
    return GDK_FAIL;
}

/**
 * Utility function. It reads the tail value of an element in a
 * [void,any] BAT indexed by oid_index.
 */
#define findTailValue(res, ctx, b, oid_index) {                 \
    /* fprintf(stderr,"** idxTV()\n");*/               \
    if (IS_FAKE_PROJECT(b)) {                                   \
        res = BUNtail(b,BUNfirst(b)); /* fake project */        \
    } else if (b->batCount) {                                   \
        BUN _bun = NULL;                                        \
        BUNfndVOID(_bun, b, &oid_index);                        \
        if (_bun == NULL)                                       \
            return idxTVerror1(ctx,b,oid_index);                \
        res = BUNtail(b,_bun);                                  \
    } else                                                      \
        return idxTVerror2(ctx,b);                              \
    if (res == NULL)                                            \
        return idxTVerror3(ctx,b,oid_index);                    \
}

#define findTailValue2(fun, res, b, oid_index) {                \
    BUN _bun = NULL;                                            \
    _bun = fun (b, oid_index);                                  \
    if (_bun == NULL)                                           \
        return idxTVerror1 (ctx, b, oid_index);                 \
    res = BUNtail (b, _bun);                                    \
    if (res == NULL)                                            \
        return idxTVerror3(ctx,b,oid_index);                    \
}
        
#define getWsValue(RES, ctx, contID, batID, oid_index) {        \
    RES = readWsValue(ctx,contID,batID,oid_index);              \
    if ( RES == NULL )                                          \
        return idxTVerror3(ctx,NULL,oid_index);                 \
}

static ptr
readWsValue (XqueryCtx* ctx, int contID, int batID, oid oid_index)
{
    wsBatDescr* mr = getMatrixBATrecord(ctx,contID,batID);

    if ( mr ) {
        if ( mr->fake_prj)
          return mr->fake_prj;
        else {
            BAT* b = mr->bat;

            if (b->batCount) {
                BUN _bun = NULL;
                BUNfndVOID(_bun, b, &oid_index);
                if (_bun == NULL) {
                    idxTVerror1(ctx,b,oid_index);
                    return NULL;
                }
                return BUNtail(b,_bun);
            } else {
                idxTVerror2(ctx,b);
                return NULL;
            }
        }
    }
    return NULL;
}


/**
 *
 * V. THE CONTEXT NODE SERIALIZATION PART
 *
 */

/**
 * Handle the generation of an attribute with oid 'id'
 * stored in container 'cont'.
 */
@= process_attr
static bool
process_@1attr (XqueryCtx* ctx, int cont, oid id)
{
    str val, uri, prefix, loc; 
    oid qn_oid, prop_oid;
    int acont;
    ptr r;

    getWsValue(r, ctx, cont,  ATTR_PROP, id);       prop_oid = *(oid*)      r;
    getWsValue(r, ctx, cont,  ATTR_CONT, id);       acont    = (int)*(oid*) r;
    getWsValue(r, ctx, acont, PROP_VAL,  prop_oid); val      = (str)        r;
    getWsValue(r, ctx, cont,  ATTR_QN,   id);       qn_oid   = *(oid*)      r;
    getWsValue(r, ctx, acont, QN_URI,    qn_oid);   uri      = (str)        r;
    getWsValue(r, ctx, acont, QN_PREFIX, qn_oid);   prefix   = (str)        r;
    getWsValue(r, ctx, acont, QN_LOC,    qn_oid);   loc      = (str)        r;

    /* generate the attribute callbacks 
       (and if necessary the corresponding namespace attributes) */
    return check@2AttrNsChange (ctx, uri, prefix, loc, val);
}
@c
@:process_attr(top_,Top)@
@:process_attr(,)@

/**
 * Generate all the attributes linked to a certain node 'pre' 
 * in container 'cont'.
 */
static bool
process_node_attr (XqueryCtx* ctx, int cont, oid pre) {
    BAT *pre_nid, *attr_own_shr, *attr_own_prv, *attr_own_chk;
    hash_t idx;
    oid base, nid = oid_nil, *attr_own;
    BUN p, r;
    
    /* translate pre value into nid value */
    getWsBAT(pre_nid, ctx,cont,PRE_NID);
    BUNfndVOID(p, pre_nid, &pre);
    if ( p ) {
        nid = *(oid*)BUNtail(pre_nid,p);
    } else {
        fatal_err(ctx,"process_node_attr: "SZFMT" not within ["SZFMT","SZFMT"]", 
                  (size_t)pre, (size_t)(*(oid*)BUNhead(pre_nid,BUNfirst(pre_nid))), 
                  (size_t)(*(oid*)BUNhead(pre_nid,BUNlast(pre_nid)-BUNsize(pre_nid))));
        return PROBLEM;
    }

    /* look up all the attribute ids for a given nid 
     * for updatable bats, we had to create a hash table for each serialization (query).
     * the solution is to use an out-of-date shared attr_own bat with a hash table
     * in conjunction with a (presumably small) private new part.
     */

    /* first probe the private (i.e. last) part of the attr table */
    getWsBAT(attr_own_prv, ctx, cont, ATTR_OWN_PRIVATE);
    base = attr_own_prv->hseqbase - BUNindex(attr_own_prv, BUNfirst(attr_own_prv));
    attr_own_prv = BATmirror(attr_own_prv);
    if (BATprepareHash(attr_own_prv)) {
        fatal_err(ctx,"process_node_attr: hash table creation\n");
        return PROBLEM;
    }
    HASHloop_oid(attr_own_prv, attr_own_prv->hhash, idx, (ptr)&nid, r) {
        oid id = base + idx;
        if ( ! process_attr (ctx, cont, id) )
            return PROBLEM;
    }

    /* then check the old shared part that has a hash table. 
     * results need to be checked against the current version and nils filtered out.
     */
    getWsBAT(attr_own_chk, ctx, cont, ATTR_OWN);
    getWsBAT(attr_own_shr, ctx, cont, ATTR_OWN_SHARED);
    base = attr_own_shr->hseqbase - BUNindex(attr_own_shr, BUNfirst(attr_own_shr));
    attr_own = ((oid*) BUNfirst(attr_own_chk)) - base;
    attr_own_shr = BATmirror(attr_own_shr);
    if (BATprepareHash(attr_own_shr)) {
        fatal_err(ctx,"process_node_attr: hash table creation\n");
        return PROBLEM;
    }
    HASHloop_oid(attr_own_shr, attr_own_shr->hhash, idx, (ptr)&nid, r) {
        oid id = base + idx;
        if ( attr_own[id] != oid_nil && !process_attr (ctx, cont, id) )
            return PROBLEM;
    }
    return SUCCESS;
}

/**
 * Generate the subtree ranging from node 'pre' to node 'to'.
 */
static bool
emitNodesInRange (XqueryCtx* ctx, oid pre, oid to, BAT* pre_cont, oid cont)
{
    ptr res;
    chr kind;
    oid prop;
    int vCONT = cont;

    do {
        getWsValue(res,ctx,cont,PRE_KIND,pre);
        kind = *(chr*) res;
        
        /* jump over holes introduced by updates */
        if (kind == chr_nil) {
            getWsValue(res,ctx,cont,PRE_SIZE,pre);
            int size = (*(int*)res) & GDK_int_max;
            pre = pre + size + 1;
            continue;
        }
    
        /* print end element */
        while( moreTags(ctx) && pre > topSF(ctx)->limit ) {
            if ( !ctx->driverFun->handle_endElement(
                                      ctx,
                                      topPrefix(ctx),
                                      topName(ctx)) )
                return PROBLEM;
            popTag(ctx);
        }

        /* get container and value reference */
        if ( pre_cont ) {
            findTailValue(res,ctx,pre_cont,pre);
            vCONT = (int)*(oid*)res;
        }
        getWsValue(res,ctx,cont,PRE_PROP,pre);
        prop = *(oid*) res;
        
        switch( kind ) {
            case (char)0:
                {   /* ELEMENT */
                    str uri, prefix, name;
                    int size;
                    
                    getWsValue (res, ctx, vCONT, QN_URI, prop);
                    uri    = (str) res;
                    getWsValue (res, ctx, vCONT, QN_PREFIX, prop);
                    prefix = (str) res;
                    getWsValue (res, ctx, vCONT, QN_LOC, prop);
                    name   = (str) res;

                    if (!ctx->driverFun->handle_startElement(
                                             ctx,
                                             prefix,
                                             name,
                                             pre))
                        return PROBLEM;

                    getWsValue(res,ctx,cont,PRE_SIZE,pre);
                    size = *(int*)res;

                    /* We always have to push the tag as the
                       namespace resolution may refer to it. */
                    if (!pushTag(ctx,pre+size,prefix,name))
                        return PROBLEM;

                    /* check for change of prefix/uri.  */
                    if (!checkElemNsChange (ctx, uri, prefix))
                        return PROBLEM;
                        
                    /* trigger the serialization of the corresponding
                       attributes. */
                    if (!process_node_attr(ctx,cont,pre))
                        return PROBLEM;

                    if (size) {
                        if (!ctx->driverFun->complete_startElement(ctx))
                            return PROBLEM;
                    }
                    else {
                        popTag (ctx);
                        if (!ctx->driverFun->complete_startElementEmpty(ctx))
                            return PROBLEM;
                    }
                    break;
                }
            case (char)1:
                {   /* PFTEXT */
                    getWsValue(res,ctx,vCONT,PROP_TEXT,prop);
                    if (!ctx->driverFun->handle_characters (ctx, (str)res))
                        return PROBLEM;
                    break;
                }
            case (char)2:
                {   /* COMMENT */
                    getWsValue(res,ctx,vCONT,PROP_COM,prop);
                    if (!ctx->driverFun->handle_comment (ctx, (str)res))
                        return PROBLEM;
                    break;
                }
            case (char)3:
                {   /* PI */
                    str target, data;
                    getWsValue(res,ctx,vCONT,PROP_TGT,prop);
                    target = (str) res;
                    getWsValue(res,ctx,vCONT,PROP_INS,prop);
                    data = (str) res;
                    if (!ctx->driverFun->handle_processingInstruction (
                                             ctx, target, data))
                        return PROBLEM;
                    break;
                }
            case (char)4:
                {   /* DOCUMENT */
                    /* all callbacks are triggered in caller function */
                    break;
                }
            case (char)5:
                {   /* COLLECTION */
                    /* nothing to be done, here */
                    break;
                }
            default:
                fatal_err (ctx,
                           "Unknow kind %d IN xquery_node_print",
                           (int)kind);
                return PROBLEM;
        }
        pre++;
    } while (pre <= to);

    /* in case the last nodes where deleted 
       we skipped the end element handling */
    while( moreTags(ctx) ) {
        if ( !ctx->driverFun->handle_endElement(
                                  ctx,
                                  topPrefix(ctx),
                                  topName(ctx)) )
            return PROBLEM;
        popTag(ctx);
    }

    return SUCCESS;
}

/**
 *
 * VI. INITIALIZATION AND CLEANUP FUNCTIONS OF THE MAIN ROUTINES 
 *
 */
char* match(char* mode, char* key) {
    char *s = strstr(mode, key);
    char *t = s + strlen(key);
    if ((s != NULL) && (s == mode || s[-1] == '-') && (*t == 0 || *t == '-'))
        return s;
    return NULL;
}

static bool
createWsContext (XqueryCtx*        ctx,
                 BAT*              ws,
                 str               mode,
                 str               module,
                 str               method,
                 serializeFunStruct*    driverFun,
                 char*             driverArg,
                 stream*           fp)
{
    char *restag = NULL;
    char *resprefix = NULL;

    memset(ctx, 0, sizeof(XqueryCtx));

    /* set the output stream */
    ctx->out = fp;

    /* store the working set ws */
    ctx->ws = ws;
    
    /* initialize the namespace stack */
    xmlNsInit( &ctx->nsTop );
    
    /* reset the tagname stack */
    ctx->stackPtr  = 0;
    
    /* initialize the structure that stores the BAT
       references of the working set BATs */
    if ( !initWsMatrix(ctx) )
        return PROBLEM;
    
    /* reset the modes */
    ctx->modes = 0;

    /* choose a mode: {xml, dm, sax} */ 
    if (match(mode,"xml")) {
        ctx->modes = MODE_XML;

        /* four special options for xml mode:
           noroot, root-name, noheader, and typed */
        /* user specified result tag */
        restag = match(mode,"root");
        if (restag && restag[4]) {
            *restag = 0; /* cut off the suffix not to have false matches later */
            restag += 5; /* rest of mode is root tag */
        } else {
            restag = "XQueryResult"; /* default root tag */
        }
        if (match(mode,"noroot"))
            ctx->modes = ctx->modes | MODE_NO_ROOT;

        /* we may omit the synthetic root element */ 
        if (match(mode,"noheader"))
            ctx->modes = ctx->modes | MODE_NO_HEADER;

        /* we may wrap each item in an element
           specifying its type */
        if (match(mode, "xrpc")) {
            if (!module) {
                fatal_err (ctx,
                        "the namespace of called module is "
                        "required in \"xrpc\" mode");
                return PROBLEM;
            }
            if (!method) {
                fatal_err (ctx,
                        "the name of called function is "
                        "required in \"xrpc\" mode");
                return PROBLEM;
            }
            resprefix = "xrpc";
            ctx->modes = ctx->modes | MODE_XRPC;
            /* in "XRPC" mode, the line "<?xml ...?>" is printed by
             * handle_startSerialize() and we do not want to get this
             * line printed twice, so when "XRPC" mode is used,
             * "NO_HEADER" mode should also be used. */
            ctx->modes = ctx->modes | MODE_NO_HEADER;
        } else if (match(mode, "typed")) {
            resprefix = "result";
            ctx->modes = ctx->modes | MODE_TYPED;
        }
    }
    /* list seq mode before dm mode as it might be used a subclass */
    else if (match(mode, "seq"))
        ctx->modes = MODE_SEQ;
    else if (match(mode,"dm"))
        ctx->modes = MODE_DM;
    else if (match(mode,"sax")) {
        ctx->modes = MODE_SAX;

        /* sax stream can be also enclosed
           in additional root element (or not) */
        restag = match(mode,"root");
        if (restag && restag[4]) {
            *restag = 0; /* cut off the suffix not to have false matches later */
            restag += 5; /* rest of mode is root tag */
        } else {
            restag = "XQueryResult"; /* default root tag */
        }
        if (match(mode,"noroot"))
            ctx->modes = ctx->modes | MODE_NO_ROOT;
    }
    else {
        /* no format chosen - use xml (with default root tag) */
        ctx->modes = MODE_XML;
        restag = "XQueryResult"; /* default root tag */
    }

    /* add mapi = characters at the start of each line */
    if ((ctx->modes & (MODE_DM | MODE_XML)) && match(mode,"mapi"))
        ctx->modes = ctx->modes | MODE_MAPI;


    /* choose the correct set of callback functions */
    if (driverFun) {
        ctx->driverFun = driverFun;
    }
    else if ( ctx->modes & MODE_SAX ) {
        ctx->driverFun = & saxSerializeFun;
    }
    /* list seq mode before dm mode as it might be used a subclass */
    else if ( ctx->modes & MODE_SEQ ) {
        ctx->driverFun = & seqSerializeFun;
    }
    else if ( ctx->modes & MODE_DM ) {
        if ( ctx->modes & MODE_MAPI )
            ctx->driverFun = & mapi_dmSerializeFun;
        else
            ctx->driverFun = & dmSerializeFun;
    }
    else if ( ctx->modes & MODE_XML ) {
        if ( ctx->modes & MODE_MAPI &&  ctx->modes & MODE_TYPED )
            ctx->driverFun = & mapi_typed_xmlSerializeFun;
        else if ( ctx->modes & MODE_MAPI && ctx->modes & MODE_XRPC )
            ctx->driverFun = & mapi_xrpc_xmlSerializeFun;
        else if ( ctx->modes & MODE_TYPED )
            ctx->driverFun = & typed_xmlSerializeFun;
        else if ( ctx->modes & MODE_XRPC )
            ctx->driverFun = & xrpc_xmlSerializeFun;
        else if ( ctx->modes & MODE_MAPI )
            ctx->driverFun = & mapi_xmlSerializeFun;
        else
            ctx->driverFun = & xmlSerializeFun;
    }
    else
        return PROBLEM;
    
    if ( !ctx->driverFun->init(ctx, driverArg, restag, resprefix, module, method) )
        return PROBLEM;

    return SUCCESS;
}

static bool
disposeWsContext (XqueryCtx* ctx)
{
    xmlNsDispose( &ctx->nsTop );
    if ( !disposeWsMatrix(ctx) )
        return(0);
    return SUCCESS;
}

/**
 *
 * VII. THE MAIN XML DOCUMENT PRINTING PART
 *
 */

static BAT *
wsADMbat (BAT* ws, oid o)
{
    BAT* res = NULL;
    BUN b = BUNfnd(ws,&o);

    if ( !b ) {
        fatal_err(0,"wsADMbat: unable to find bat[%d@0] in WS",o);
    } else {
        res = BATdescriptor(*(bat*)b);
    }
    return res;
}

static int
ws_documentIndex (BAT* ws, str docName)
{
    int res = PROBLEM;
    BAT* open_name;
    if ( !(open_name=wsADMbat(ws,OPEN_NAME)) ) {
        fatal_err(0,"ws_documentIndex: unable to find CONT_NAME in WS");
        return PROBLEM;
    }
    BAT* open_cont;
    if ( !(open_cont=wsADMbat(ws,OPEN_CONT)) ) {
        fatal_err(0,"ws_documentIndex: unable to find CONT_COLLID in WS");
        BBPunfix( BBPcacheid( open_name ) );
        return PROBLEM;
    }
    open_name = BATmirror(open_name);
    if (!BATprepareHash(open_name)) {
        BUN p;
        HASHfnd_str(p, open_name, docName);
        if (p) {
            size_t idx = BUNindex(open_name, p) - BUNindex(open_name, BUNfirst(open_name));
            p = BUNptr(open_cont, BUNindex(open_cont, BUNfirst(open_cont)) + idx);
            if (p < BUNlast(open_cont)) {
                res = *(oid*) BUNtail(open_cont, p); 
            }
        }
    }
    BBPunfix( BBPcacheid( open_name ) );
    BBPunfix( BBPcacheid( open_cont ) );
    return res;
}

oid doc_startOid(XqueryCtx* ctx, oid docIndex) {
    BUN bun;

    BAT* open_docid;
    
    if ( !(open_docid = fetchWsBaseBAT(ctx,ctx->ws,OPEN_DOCID)) )
    	return oid_nil;
    if ( 0 ) BATprintf(GDKout,open_docid);

    oid bloody_guess = 1;
    if ( !(bun = BUNfnd(open_docid,&bloody_guess)) ) {
            fatal_err(ctx,"doc_startOid: cannot find startOid for doc[" OIDFMT "]",docIndex);
	          return oid_nil;
    }
    oid icdocId = *(oid*)BUNtail(open_docid,bun);
    /* stream_printf(GDKout,"# icdocId = " OIDFMT ".\n",icdocId); */
    BAT* frag_root;
    getWsBAT(frag_root, ctx, docIndex,FRAG_ROOT);
    if ( 0 ) BATprintf(GDKout,frag_root);
    /* */
    if ( !(bun = BUNfnd(frag_root,&icdocId)) ) {
            fatal_err(ctx,"doc_startOid: cannot find startOid for doc[" OIDFMT "]",docIndex);
	    return oid_nil;
    }
    return *(oid*)BUNtail(frag_root,bun);
}

int
xquery_print_doc_DRIVER (
    str                 mode, 
    serializeFunStruct *driverFun,
    char               *driverArg,
    BAT                *ws,
    str                 docName)
{
    TIMER_START();
    int docIndex = ws_documentIndex(ws,docName);
    int res = GDK_FAIL;
    if (!docIndex) {
        GDKerror("serialize.mx: unable to find document \"%s\" in working set!\n", docName);
    } else { 
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        if (createWsContext(ctx,ws,mode,NULL,NULL,driverFun,driverArg,GDKout)) {
	    oid start_oid = doc_startOid(ctx,docIndex);
	    if ( start_oid == oid_nil )
	        return GDK_FAIL;
            if (ctx->driverFun->handle_startDocument(ctx,start_oid)) {
                ptr p;

                if ( 0 /* old implementation, restore if necessary */ ) {
                  getWsValue(p, ctx, docIndex, PRE_SIZE, 0 /* start */);
		  if (emitNodesInRange (ctx, 0,  *(int*) p, NULL, docIndex))
		    if (ctx->driverFun->handle_endDocument(ctx))
		        res = GDK_SUCCEED;
		} else { /* the new container implementation */
                  getWsValue(p, ctx, docIndex, PRE_SIZE, start_oid);
		  oid sz = *(int*) p;
                  if (emitNodesInRange (ctx, start_oid,start_oid+sz, NULL, docIndex)) {
                    if (ctx->driverFun->handle_endDocument(ctx)) {
                        res = GDK_SUCCEED;
                    }
                  }
	        }
            }
        }
        if (!disposeWsContext(ctx)) {
            res = GDK_FAIL;
        }
    }
    TIMER_STOP("# serialization of \"%s\"",docName);
    return res;
}

/**
 *
 * VIII. THE MAIN PATHFINDER QUERY RESULT SERIALIZATION
 *
 */

static BUN
fake_lookup_bun (BAT *b, oid offset)
{
    BUN res = BUNfirst(b);
    (void) offset;
    return res;
}

static BUN
lookup_bun (BAT *b, oid offset)
{
    BUN res;
    BUNfndVOID(res, b, &offset);

    return res;
}

/* misuse the SET_CONT_KIND macro to overload
   the kind values with the node kind */
#define COMBN_NKIND_KIND(X,Y) SET_CONT_KIND(X,Y)

#define BATloop_off(b,p,q,w,o,s)\
        for(w=BUNsize(b), p=BUNptr(b,BUNindex(b,BUNfirst(b))+o), q=p+s*w; \
            p<q; \
            p+=w) 

/**
 * Main XQUERY/Pathfinder result sequence printing routine. 
 * Arguments are
 * mode: e.g. "xml", "sax", "seq", "dm", ("noroot", "typed")
 * ws : the working set
 * max_iter : often 1@0. we can also print multiple iters for XRPC or debugging
 * item/item/kind : sequence result BATs (iter as a constant bat)
 * intVAL,dblVAL,strVAL : BATSs containing the values of seq elements
 * remainder BATs: contains the data for the document nodes
 *
 * iter and kind may be 'fake' (i.e. constant) bats and quite often are;
 * item cannot be fake.
 *
 * The function iterates through the item/kind BAT's and retrieves either
 * the values from the xxxVAL BATs or the nodes. In the latter case it calls
 * one of the seqXXXXX() functions. The implementations of these callback
 * functions are provied in the serialize_*.mx files.
 */
int 
xquery_print_result_driver (
    stream*             fp,
    str                 mode,
    str                 module,
    str                 method,
    serializeFunStruct *driverFun, /* unused */
    char               *driverArg, /* unused */
    BAT                *ws,
    size_t              niters,
    BAT                *loop,
    BAT                *iter,
    BAT                *item, 
    BAT                *kind,
    BAT                *intVAL,
    BAT                *dblVAL,
    BAT                *strVAL)
{
    TIMER_START();

    size_t bs, yy, curcnt, maxcnt, buncnt;
    XqueryCtx ctx_struct, *ctx = &ctx_struct;
    static BUN (*fun_k) (BAT *, oid);

    /* prepare serialization */ 
    if ( !createWsContext (ctx, ws, mode, module, method, driverFun, driverArg, fp) )
        return GDK_FAIL;

    curcnt = 0;
    maxcnt = BATcount (item);
    buncnt = maxcnt;
    
    /* decide lookup method for BAT kind once for all items */
    if (IS_FAKE_PROJECT(kind))
        fun_k = fake_lookup_bun;
    else
        fun_k = lookup_bun;

    /* Start of serialization, print everything that should only be
     * printed once every serialization. */
    if ( !ctx->driverFun->handle_startSerialize(ctx) )
        return GDK_FAIL;

    /* loop over the iterations (usually only 1) */
    for(yy=0; yy < niters; yy++, curcnt += buncnt, maxcnt -= buncnt) {
        oid cur_iter = *(oid*) BUNhead(
                                   loop, 
                                   BUNptr(
                                       loop, 
                                       BUNindex (loop, BUNfirst(loop)) + yy));
        oid index, valoid;
        BUN p, q;
        ptr res;
        int cmbn_cont_kind, cur_kind, old_kind, cont = 0;
        char node_kind = 0;

        /* modify buncnt (only necessary for multiple iterations) */
        if (niters > 1) {
            if (IS_FAKE_PROJECT(iter)) {
                /* iterations do not match */
                if (*(oid*) BUNtail(iter, BUNfirst(iter)) != cur_iter)
                    buncnt = 0;
                else
                    buncnt = maxcnt;
            } else {
                /* in case of a non-constant iter bat, find out how many
                 * items we have in this iteration */
                BATloop_off (iter, p, q, bs, curcnt, maxcnt) 
                    if (*(oid*) BUNtail(iter, p) != cur_iter) break;
                buncnt = ((p - BUNfirst(iter)) / bs) - curcnt;
            }
        }

        /**
         *
         * the output for one item sequence (or rather one iteration)
         *
         */
        
        /* start of item sequence callback */
        if ( !ctx->driverFun->seqStart(
                  ctx,
                  buncnt - curcnt /* number of items to print */) )
            return GDK_FAIL;

        /* some serialization modes may print all attributes up front
           (here xml and sax mode, where xml mode is not typed) */
        if (ctx->modes & (MODE_XML | MODE_SAX) && 
            /* TYPED and XRPC modes take care of attribute themselves */
            !(ctx->modes & MODE_TYPED) && !(ctx->modes & MODE_XRPC) &&
            /* forget top-level attributes if we have no root nodes */
            !(ctx->modes & (MODE_NO_ROOT)) ) {

            /* scan of all attributes here and generate the appropriate
               calls to connect them to the head tag of the result document */
            BATloop_off (item, p, q, bs, curcnt, buncnt) { 
                index = *(oid*)BUNhead(item, p);
                valoid = *(oid*)BUNtail(item, p);
                findTailValue2 (fun_k, res, kind, index);
                cmbn_cont_kind = *(int*) res;

                if ( XTRACT_KIND(cmbn_cont_kind) == ATTR ) {
                    cont = XTRACT_CONT(cmbn_cont_kind);
                    if ( !process_top_attr (ctx, cont, valoid) )
                        return GDK_FAIL;
                }
            }
        }
        /* complete start of item sequence callback */
        if ( !ctx->driverFun->complete_seqStart(ctx) )
            return GDK_FAIL;

        /* process item sequence */
        old_kind = 0;

        BATloop_off (item, p, q, bs, curcnt, buncnt) {
            index = *(oid*)BUNhead(item, p);
            valoid = *(oid*)BUNtail(item, p);
            findTailValue2 (fun_k, res, kind, index);
            cmbn_cont_kind = *(int*) res;
            cur_kind = XTRACT_KIND(cmbn_cont_kind);
            
            /* get the node kind information for correct
               item start/end printing */
            if (cur_kind == ELEM) {
                cont = XTRACT_CONT(cmbn_cont_kind);
                /* lookup node kind */
                getWsValue (res, ctx, cont, PRE_KIND, valoid);
                node_kind = *(chr*) res;
            }
            
            if (old_kind) /* skip the first iteration */
                /* add an item separator */
                if ( !ctx->driverFun->seqItemSeparator(
                               ctx, old_kind, cur_kind) )
                    return GDK_FAIL;
                
            /* start of item callback */
            if ( !ctx->driverFun->seqItemStart(
                                      ctx, 
                                      COMBN_NKIND_KIND (node_kind,
                                                        cur_kind)) )
                return GDK_FAIL;
                 
            switch( cur_kind ) {
                case ATTR:
                    /* print attributes for all modes that were skipped
                       before */
                    if (!(ctx->modes & (MODE_XML | MODE_SAX)) ||
                        (ctx->modes & MODE_TYPED) ||
                        (ctx->modes & MODE_XRPC)) {
                        cont = XTRACT_CONT(cmbn_cont_kind);
                        if ( !process_top_attr (ctx, cont, valoid) )
                            return GDK_FAIL;

                        /* throw away all namespace declarations */
                        xmlNsDispose( &ctx->nsTop );
                    }
                    break;
                case ELEM:
                    {
                        /* node_kind and cont have been already looked up */

                        /* print top level text nodes */
                        if (node_kind == (char)1 /* TEXT */) {
                            oid prop, val_cont;
                            
                            /* get value container */
                            getWsValue(res, ctx, cont, PRE_CONT, valoid);
                            val_cont = *(oid*) res;
                            /* get value reference */
                            getWsValue(res, ctx, cont, PRE_PROP, valoid);
                            prop = *(oid*) res;

                            getWsValue (res, ctx, val_cont, PROP_TEXT, prop);
                            if ( !ctx->driverFun->seqEmitTextnodes (
                                                      ctx, (str)res) )
                                return GDK_FAIL; 
                            break;
                        }
                        /* print all other nodes (in most cases complete
                           subtrees) */
                        else {
                            oid pre = valoid, pre_size;
                            getWsValue(res, ctx, cont, PRE_SIZE, pre);
                            pre_size = pre + *(int*) res;

                            /* handle document start callback
                               if we have a document node */
                            if (node_kind == (char)4 /* DOCUMENT */)
                                if ( !ctx->driverFun->handle_startDocument (
                                                          ctx,pre) )
                                    return GDK_FAIL;

                            BAT *b;
                            getWsBAT(b, ctx, cont, PRE_CONT);
                            if ( !emitNodesInRange (ctx, 
                                                    pre,
                                                    pre_size, 
                                                    IS_FAKE_PROJECT(b)?NULL:b,
                                                    cont) )
                                return GDK_FAIL;
                                
                            /* handle document end callback
                               if we have a document node */
                            if (node_kind == (char)4 /* DOCUMENT */)
                                if ( !ctx->driverFun->handle_endDocument (
                                                          ctx) )
                                    return GDK_FAIL; 

                            break;
                        }
                        break;
                    };
                case BOOL:
                    if ( !ctx->driverFun->seqEmitBool(ctx, valoid) )
                        return GDK_FAIL;
                    break;
                case DBL:
                case DEC:
                    findTailValue(res, ctx, dblVAL, valoid);
                    if (!ctx->driverFun->seqEmitDbl(ctx,*(dbl*)res) )
                        return GDK_FAIL; /* INCOMPLETE ?diff between d and e */
                    break;
                case INT:
                    findTailValue(res, ctx, intVAL, valoid);
                    if ( !ctx->driverFun->seqEmitInt(ctx,*(lng*)res) )
                        return GDK_FAIL;
                    break;
                case STR:
                case U_A:
                    findTailValue(res, ctx, strVAL, valoid);
                    if ( !ctx->driverFun->seqEmitStr(ctx,(str)res) )
                        return GDK_FAIL;
                    break;
                default:
                    GDKerror ("serialize.mx:xquery_print_result_main: "
                              "[kind=%d, cont=%d]\n",
                              cur_kind,
                              XTRACT_CONT(cmbn_cont_kind));
                    fatal_err (ctx, "UNKNOW_TYPE(\'%c\'ch(%d))\n",
                               cmbn_cont_kind, cmbn_cont_kind);
                    return GDK_FAIL;
            }

            /* end of item callback */
            if ( !ctx->driverFun->seqItemEnd(
                                      ctx, 
                                      COMBN_NKIND_KIND (node_kind,
                                                        cur_kind)) )
                return GDK_FAIL;

            /* this avoids the separator printing for attributes
               in the XML mode (without the typed xml mode) that
               have been removed from the result sequence */
            if (!(ctx->modes & (MODE_XML | MODE_SAX)) ||
                ctx->modes & MODE_TYPED ||
                cur_kind != ATTR)
                /* the kind value in 'cur_kind' 
                   is the old one for the next iteration */
                old_kind = cur_kind;
        }

        /* end of item sequence callback */
        if ( !ctx->driverFun->seqEnd(ctx) ) return GDK_FAIL;
    } 

    /* End of serialization, print everything that should only be
     * printed once every serialization. */
    if ( !ctx->driverFun->handle_endSerialize(ctx) )
        return GDK_FAIL;
    
    if ( !disposeWsContext(ctx) )
        return GDK_FAIL;

    TIMER_STOP("# result serialization");

    return GDK_SUCCEED;
}

int 
xquery_print_result_DRIVER (
    str                 mode,
    str                 moduleNS,
    str                 method,
    serializeFunStruct *driverFun,
    char               *driverArg,
    BAT                *ws,
    size_t              niters,
    BAT                *loop,
    BAT                *iter,
    BAT                *item, 
    BAT                *kind,
    BAT                *intVAL,
    BAT                *dblVAL,
    BAT                *strVAL)
{
    (void) driverFun;
    (void) driverArg;
    return xquery_print_result_driver (
               GDKout,
               mode,
               moduleNS,
               method,
               driverFun, /* set of printing callback function */
               driverArg, /* optional arguments for the callback functions */
               ws,
               niters?niters:1, /* number of iterations */
               loop, /* loop relation */
               iter, /* iter relation */
               item, /* item relation */
               kind, /* kind relation */
               intVAL,
               dblVAL,
               strVAL);
}
