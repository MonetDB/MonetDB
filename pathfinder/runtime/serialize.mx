@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2005 University of Konstanz.  All Rights Reserved.
@'
@' $Id$

@f serialize
@a Jan Flokstra
@t serialize

@c

/*******************************************
 * serialize.c : XML serialization
 *
 */

#include <gdk.h>
#include <monet.h>

#include "pathfinder.h"

static bit is_fake_project (BAT* b)
{
    BATcheck(b, "is_fake_project");
    if ((BATcount(b)==1) && (b->hseqbase==oid_nil)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

#define MAXTAGDEPTH        1024

#define WS_BATS     HEIGHT

/**
 *
 * 0. SMALL UTILITY SECTION
 *
 * Here a structure is defined to prevent too much alloc/free actions.
 * If the size of a string is smaller then SMART_STR_SZ the value is
 * stored in stack_buff[] within the structure. Otherwise it is strdupped and
 * freed like usual.
 */


#define SMART_STR_SZ    32

typedef struct {
    char stack_buff[SMART_STR_SZ];
    str  val;
} SmartStrBuff;

static int ssb_alloc(SmartStrBuff* ssb, str s) {
    if ( s ) {
        size_t l = strlen(s)+1;

        if ( l <= SMART_STR_SZ )
            return (ssb->val = memcpy(&ssb->stack_buff,s,l)) != NULL;
        else
            return (ssb->val = strdup(s)) != NULL;
    } else
        ssb->val = NULL;
    return 1;
}

static void ssb_free(SmartStrBuff* ssb) {
    if ( ssb->val && (ssb->val != (str)&ssb->stack_buff) ) {
        free( ssb->val );
    }
    ssb->val = NULL;
}

/**
 *
 */

/* #define DEBUGNS */

struct XmlNsFrame; /* forward */
typedef struct XmlNsFrame {
    char*			prefix;
    char*			uri;
    struct XmlNsFrame*	prev;
    struct XmlNsFrame*	next;
} XmlNsFrame;

int xmlNsInit(XmlNsFrame** top) {
#ifdef DEBUGNS
    stream_printf(GDKout,"+NS:xmlNsInit()\n");
#endif
    *top = NULL;
    return 1;
}

char* xmlNsFind(XmlNsFrame** top, char* prefix) {
    XmlNsFrame* fp = (*top);

    while( fp ) {
        if ( strcmp(prefix,fp->prefix) == 0) {
#ifdef DEBUGNS
            stream_printf(GDKout,"+NS:xmlNsFind(\"%s\")=\"%s\")\n",prefix,fp->uri);
#endif
            return fp->uri;
        }
        fp = fp->prev;
    }
    return NULL;
}

XmlNsFrame* xmlNsPush(XmlNsFrame** top, char* prefix, char* uri) {
    XmlNsFrame* fp = (XmlNsFrame*)malloc(sizeof(XmlNsFrame));

    if ( fp ) {
#ifdef DEBUGNS
        stream_printf(GDKout,"+NS:xmlNsPush(\"%s\",\"%s\")\n",prefix,uri);
#endif
        if ( !( fp->prefix = strdup(prefix)) ) return NULL;
        if ( !(fp->uri    = strdup(uri)) ) return NULL;
        /* */
        fp ->next  = NULL;
        if ( *top ) {
            (*top)->next = fp;
            fp->prev     = *top;
        } else {
            fp->prev = NULL;
        }
        *top     = fp;
    }
    return fp;
}

int xmlNsPop2(XmlNsFrame** top, XmlNsFrame* newTop) {
    XmlNsFrame* fp = (*top);

#ifdef DEBUGNS
    stream_printf(GDKout,"+NS:xmlNsPop2(%d)\n",(int)newTop);
#endif
    while (fp != newTop ) {
        XmlNsFrame* old = fp;
        fp = fp->prev;
#ifdef DEBUGNS
        stream_printf(GDKout,"+NS:-popping(\"%s\",\"%s\")\n",old->prefix,old->uri);
#endif
        free(old->prefix);
        free(old->uri);
        free(old);
    }
    if ( (*top = newTop) ) {
        (*top)->next = NULL;
    };
    return 1;
}

int xmlNsDispose(XmlNsFrame** top) { return xmlNsPop2(top,NULL); }

/**
 *
 * I. THE CONTEXT NODE DEFINITION AND USAGE PART
 *
 * This structure contains the context of the print session.
 * It has several functions. But its main use is the administration
 * of all BATs containing the XML documents.
 *
 */

typedef struct SerializeFrame {
    oid             pre;
    int             empty;  /* boolean indicating node is empty */
    XmlNsFrame*		nsMark;
    SmartStrBuff    ssb_ns;
    SmartStrBuff    ssb_name;
} SerializeFrame;

typedef struct {
    int     dmMode;         /* Data model flag, true if printing in
                             * data-model mode, eg. look like GALAX */
    int     saxMode;        /* true if printing a Sax-O-Phone stream */
    int     mapiMode;       /* for DM or XML mode that should go on a MapiClient stream */
    int     norootMode;     /* do not generate <XQueryResult> root node */
    int     printMode;      /* documentation please???? */
    char*   dmSeparator;    /* seperation char in DM mode */
    BAT*    ws;             /* working set BAT */
    int     curFRAG;        /* current fragment used by working set */
    BAT*    curBAT[WS_BATS];/* The BAT's of the current fragment*/
    /* */
    XmlNsFrame* nsTop;	/* top of the namespace stack */
    /**
     * Next elements is a stack used during printing to store the
     * pre-value, name, namespace of the nodes currently being printed.
     */
    int     stackPtr;
    SerializeFrame	tagStack[MAXTAGDEPTH];
    /* */
    int     nAttrOnLine; /* used by top result print routine to count the
                          * number of top-level result items printed on
                          * the current line.
                          */
} XqueryCtx;

/**
 * The local error handler for the serialization.
 */
static int fatal_err(XqueryCtx* ctx, const char *msg, ...) {
    va_list msgs;
    char    errmsg[1024];

    (void)ctx;
    va_start (msgs, msg);
    vsnprintf (errmsg, 1024, msg, msgs);
    va_end (msgs);
    /* */
    GDKerror("XML Generation: %s\n",errmsg);
    /* */
    return 0;
}

/**
 * Functions fills a new context() record with mode and BAT data and
 * initializes all other data structures.
 */

static BAT* fetchWsContextBAT(XqueryCtx* ctx, BAT* ws, int batID, int wsID) {
    BUN bun;
    oid BATid = (oid)batID;
    oid WSid  = (oid)wsID;

    if ( wsID < 0 ) {
        fatal_err(ctx,"fetchWsContextBAT: NO wsID CONTEXT SELECTED");
        return NULL;
    }
    if ( !(bun = BUNfnd(ws,&BATid)) ) {
        fatal_err(ctx,"fetchWsContextBAT: NOT FOUND BAT[%d]",batID);
        return NULL;
    }


    BAT* batbat;

    if ( !( batbat = BATdescriptor(*(bat*)bun)) ) {
        fatal_err(ctx,"fetchWsContextBAT:FETCH BATBAT for WS[%d][%d] FAILED\n",batID ,wsID);
        return NULL;
    }

    BUN bbun = BUNfnd(batbat,&WSid);
    BAT *res = NULL;
    if ( !bbun ) {
        BBPunfix( BBPcacheid( batbat ) );
        fatal_err(ctx,"fetchWsContextBAT:NOT FOUND BAT[%d][%d] in WS!!!!\n",batID,wsID);
        return NULL;
    } else {
        if ( !(res = BATdescriptor(*(bat*)bbun)) ) {
            BBPunfix( BBPcacheid( batbat ) );
            fatal_err(ctx,"fetchWsContextBAT:FETCH WS[%d][%d] FAILED\n",batID,wsID);
            return NULL;
        }
    }
    BBPunfix( BBPcacheid( batbat ) );
    return res;
}

/**
 * The wsBAT() function is responsible for 'demand-loading' the BAT with index
 * 'batId in the current working set. No BAT is loaded until it is needed. This
 * solves some funny problems with loading BAT's which were not needed
 * anyway.
 */
static BAT* wsBAT(XqueryCtx* ctx, int batId) {
    if ( !ctx->curBAT[batId] ) {
        if ( !( ctx->curBAT[batId] =
                    fetchWsContextBAT(ctx,ctx->ws,batId,ctx->curFRAG)) ) {
            fatal_err(ctx,"unable to load wsBAT[%d]",batId);
            return NULL;
        }
    }
    return ctx->curBAT[batId];
}

static int switchWsContext(XqueryCtx* ctx, int wsID) {
    int res = ctx->curFRAG;

    if ( ctx->curFRAG != wsID ) {
        int i;

        if ( ctx->curFRAG >= 0 ) {
            /* close the old open context BAT's */
            for(i=0; i<WS_BATS; i++) {
                if ( ctx->curBAT[i] ) {
                    BBPunfix( BBPcacheid(ctx->curBAT[i]));
                    ctx->curBAT[i] = NULL;
                }
            }
        }
        ctx->curFRAG   = wsID;
    }
    return res;
}

static int createWsContext(XqueryCtx* ctx, BAT* ws, int wsID, str mode) {
    int i;

    ctx->dmMode = ctx->mapiMode = ctx->printMode = ctx->norootMode = 0;
    ctx->saxMode = 1;
    xmlNsInit( &ctx->nsTop );

    /* choose a mode: {dm,xml,sax} */ 
    if ( strstr(mode,"dm")) {
        ctx->dmMode = 1; ctx->saxMode = 0;
    } else if (strstr(mode,"xml")) {
        ctx->dmMode = ctx->saxMode = 0;
    }
    /* we may omit the synthetic root element */ 
    if (strstr(mode,"noroot")) {
        ctx->norootMode = 1;
    }
    if (!ctx->saxMode) {
        /* add mapi = characters at the start of each line */
        if (strstr(mode,"mapi")) {
                ctx->mapiMode = 1;
        }
        /* add something that was not documented by the person who added this mode */
        if (strstr(mode, "seq")) {
                ctx->printMode = 1;
        }
    }
    ctx->dmSeparator =
        (ctx->mapiMode ? ",\n=" : (ctx->printMode ? ",\\n" : ",\n"));
    ctx->ws        = ws;
    ctx->curFRAG   = -1; /* empty, no frag loaded */

    /* initialize with all wsBAT()'s closed */
    for(i=0; i<WS_BATS; i++) {
        ctx->curBAT[i] = NULL;
    }
    /* */
    if ( wsID >= 0 )
        switchWsContext(ctx, wsID);
    /* */
    ctx->stackPtr  = 0;
    /* */
    return 1;
}

static int disposeWsContext(XqueryCtx* ctx) {
    xmlNsDispose( &ctx->nsTop );
    return 1;
}

/**
 * Return if there are still nodes on stack.
 */
static int moreTags(XqueryCtx* ctx) {
    return (ctx->stackPtr > 0);
}

/**
 * Push the pre-value, namespace and nodename of stack
 */
static int pushTag(XqueryCtx* ctx, oid pre, str ns, str name, int empty) {
    ctx->tagStack[ctx->stackPtr].pre    = pre;
    ctx->tagStack[ctx->stackPtr].empty  = empty;
    ctx->tagStack[ctx->stackPtr].nsMark = NULL;
    if (!ssb_alloc(&ctx->tagStack[ctx->stackPtr].ssb_ns,   ns) )
        return 0;
    if (!ssb_alloc(&ctx->tagStack[ctx->stackPtr].ssb_name, name) )
        return 0;;
    ctx->stackPtr++;
    return 1;
}

/**
 * Three function to retrieve the pre-value, namespace or nodename of the
 * top element on the stack.
 */
static INLINE SerializeFrame* topSF(XqueryCtx* ctx) {
    return &ctx->tagStack[ctx->stackPtr-1];
}

static str topNs(XqueryCtx* ctx)    {return topSF(ctx)->ssb_ns.val;}
static str topName(XqueryCtx* ctx)  {return topSF(ctx)->ssb_name.val;}


/**
 * Pop the top element of the stack. Means that processing the node has
 * finished.
 */
static void popTag(XqueryCtx* ctx) {
    /* de-alloc the ns and name strings */
    ssb_free(&topSF(ctx)->ssb_ns);
    ssb_free(&topSF(ctx)->ssb_name);

    XmlNsFrame *xnf;
    if ( (xnf = topSF(ctx)->nsMark) ) {
        xmlNsPop2(&ctx->nsTop,xnf->prev);
    }
    --ctx->stackPtr;
}

static int handle_attribute(XqueryCtx* ctx, str uri, str prefix, str loc, str value, int top); /* forward */

static int checkNsChange(XqueryCtx* ctx, str par_uri, str par_prefix, int top) {
    char *uri, *prefix;

    if ( strcmp(par_uri,str_nil) == 0 || strcmp(par_uri,"") == 0 )
        uri = NULL;
    else
        uri = par_uri;
    if ( strcmp(par_prefix,str_nil) == 0 || strcmp(par_prefix,"") == 0 )
        prefix = NULL;
    else
        prefix = par_prefix;
    if ( prefix && uri ) {
        char* currentURI = xmlNsFind(&ctx->nsTop,prefix);

        if ( !(currentURI && (strcmp(currentURI,uri) == 0)) ) {
            /* change of URI for this prefix */
            XmlNsFrame* xnf;

            if ( !(xnf = xmlNsPush(&ctx->nsTop,prefix,uri)) ) {
                fatal_err(ctx,"xmlNsPush: out of memory\n");
                return 0;
            }
            /* generate the xmlns:xxx=uri tag */
            handle_attribute(ctx,str_nil,"xmlns",prefix,uri,top);

            SerializeFrame* sf = topSF(ctx);

            if ( !sf->nsMark ) {
                /* not the first nsFrame in this context */
                sf->nsMark = xnf;
            }
        }
    }
    return 1;
}

/**
 *
 * II. THE OUTPUT HANDLER PART
 *
 * The emit functions are used to encapsulate the Sax-O-Phone event
 * emission functions.
 * The current implementation emits the Sax-O-Phone events as if they are
 * a BAT.
 *
 * TODO: solve characters() newline in string problem.
 *
 */

static int emit_start() {
    stream_printf(GDKout,"#-------------------------#\n");
    stream_printf(GDKout,"# h     SAXtape           #\n");
    stream_printf(GDKout,"# str   str               #\n");
    stream_printf(GDKout,"#-------------------------#\n");
    return 1;
}

/**
 * The character translation section responsible for the special
 * character recognition and XML entity characters.  It consists of a
 * small main table 'isspecial_tab' containing the flags for every
 * possible character.
 * v=0: no special char
 * v<3: special char, should be presented as octal char in output
 * v>=3: special char, string repr of char is isspecial_val[v+mode]
 *
 * mode = 0 sax
 * mode = 1 dm/xml
 * mode = 2 dm/xml (mapi)
 */

static unsigned char  isspecial_tab[UCHAR_MAX+1] = { 0 }; /* the main table */
static char*          isspecial_val[32]; /* the values of the special chars */

static void init_isspecial() {
    int i;
    for(i=0; i<32; i++) isspecial_tab[i] = 1; /* means write as octal */
    isspecial_val[0] = "[*ERROR*]"; /* not used */
    isspecial_tab[(int)(unsigned char)'\377'] = 1; /* means write as octal */
    isspecial_val[1] = "[*ERROR*]"; /* not used, 1 = write as octal */
    isspecial_val[2] = "[*ERROR*]"; /* not used, 2 = write as octal */
    isspecial_val[3] = "[*ERROR*]"; /* not used, 3 = write as octal */
    isspecial_tab[(int)'\t'] = 4;
    isspecial_val[4] = "\\t";
    isspecial_val[5] = "\t"; /* don't escape */
    isspecial_val[6] = isspecial_val[5];
    isspecial_tab[(int)'\n'] = 7;
    isspecial_tab[(int)'\r'] = 7;	/* map \r on \n */
    isspecial_val[7] = "\\n";
    isspecial_val[8] = "\n"; /* don't escape */
    isspecial_val[9] = "\n="; /* this is the only diff between mapi and non-mapi */
    isspecial_tab[(int)'\\'] = 10;
    isspecial_val[10] = "\\\\";
    isspecial_val[11] = "\\"; /* don't escape */
    isspecial_val[12] = isspecial_val[11];
    isspecial_tab[(int)'\"'] = 13;
    isspecial_val[13] = "&quot;";
    isspecial_val[14] = isspecial_val[13];
    isspecial_val[15] = isspecial_val[13];
    isspecial_tab[(int)'\''] = 16;
    isspecial_val[16] = "&apos;";
    isspecial_val[17] = isspecial_val[16];
    isspecial_val[18] = isspecial_val[16];
    isspecial_tab[(int)'&'] = 19;
    isspecial_val[19] = "&amp;";
    isspecial_val[20] = isspecial_val[19];
    isspecial_val[21] = isspecial_val[19];
    isspecial_tab[(int)'<'] = 22;
    isspecial_val[22] = "&lt;";
    isspecial_val[23] = isspecial_val[22];
    isspecial_val[24] = isspecial_val[22];
    isspecial_tab[(int)'>'] = 25;
    isspecial_val[25] = "&gt;";
    isspecial_val[26] = isspecial_val[25];
    isspecial_val[27] = isspecial_val[25];
}

/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 */
static int emit_escaped(char* src, int mode, int onlyEntity) {
    /* Emit a string with all special character escaped. Inspired by
     * function strToStr() in gdk_atoms.mx
     */
    int start=0,end;
    unsigned char isspecial_ch;

    if (isspecial_tab[0] == 0) /* module not initialized yet */
        init_isspecial();
    for(end = 0; src[end]; end++) {
        if ( (isspecial_ch = isspecial_tab[(int)(unsigned char)src[end]]) ) {
            stream_write(GDKout,&src[start],end-start,1);
            start = end + 1;

            if ( isspecial_ch < 3 ) {
                stream_printf(GDKout,"\\%03o",(unsigned char)src[end]);
            } else {
                char *emit_val = isspecial_val[mode+(int)isspecial_ch];

                /* if ( onlyEntity && (*emit_val!='&') ) */
                if (
                        onlyEntity &&
                        src[end] !='<' &&
                        src[end] !='>' &&
                        src[end] !='&' &&
                        src[end] != '\n'
                   ) {
                    start--; /* char should normally be printed */
                } else {
                    stream_write(GDKout,emit_val,strlen(emit_val),1);
                }
            }
        }
    }
    if ( start < end ) {
        stream_write(GDKout,&src[start],end-start,1);
    }
    return 1;
}

static int emit(char* eventName, char* val, int escaped) {
    if ( val ) {
        if ( escaped ) {
            stream_printf(GDKout,"[\"%s\",\t\"",eventName);
            if ( !emit_escaped(val, escaped-1, 0/*ALL*/) )
                return 0;
            stream_printf(GDKout,"\"]\n");
        } else {
            stream_printf(GDKout,"[\"%s\",\t\"%s\"]\n",eventName,val);
        }
    } else
        stream_printf(GDKout,"[\"%s\",\tnil]\n",eventName);
    return 1;
}

static int emit_end() {
    return 1;
}

/*
 *
 * The output handlers. Responslibe for generating the output representing
 * the handles xml structure. Cuurently 3 output structures are used:
 *
 * 1) plain xml text (ctx->saxMode is false)
 * 2) xml Sax-O-Phone stream (ctx->saxMode is true AND SAXOPHONE=1 )
 * 3) My own SAX event stream (ctx->saxMode is true AND SAXOPHONE=0 )
 *
 */

/* The SAXOPHONE define is a temporary flag used by JF to compile 'in'
 * his own Sax-O-Phone version which he thinks is much more efficient
 * than the original (but not as fancy) of course.
 */
#define SAXOPHONE 1

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static int handle_startDocument(XqueryCtx* ctx) {
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( !emit_start() )
                return 0;
        } else
            stream_printf(GDKout,"<S\n");
    } else if (ctx->mapiMode) { /* xml mode (mapi) */
        stream_printf(GDKout,"=<?xml version=\"1.0\" encoding=\"utf-8\"?>\n=");
    } else if (ctx->printMode) { /* SQL-ish mapi */
        stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n");
    } else { /* xml mode */
        stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
static int handle_endDocument(XqueryCtx* ctx) {
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( !emit_end() )
                return 0;
        } else
            stream_printf(GDKout,"<E\n");
    } else { /* xmlMode */
        stream_printf(GDKout,"\n");
    }
    return 1;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
    static int handle_attribute(XqueryCtx* ctx, str uri, str prefix, str loc, str value, int top) {
        if ( !checkNsChange(ctx,uri,prefix,top) )
            return 0;
        if (ctx->saxMode ) {
            if ( SAXOPHONE ) {
                if ( !emit(" attribute",loc,0) )
                    return 0;
                if ( prefix && (strlen(prefix)>0) )
                    if ( !emit(" attribute prefix",prefix,0) )
                        return 0;
                if ( !emit(" attribute value",value,0) )
                    return 0;
            } else {
                stream_printf(GDKout,"<A %s=\"%s\"\n",loc,value);
            }
        } else if (ctx->printMode) {
            if ( prefix && strlen(prefix)>0 ) {
                stream_printf(GDKout," %s:%s=\\\"%s\\\"",prefix,loc,value);
            } else {
                stream_printf(GDKout," %s=\\\"%s\\\"",loc,value);
            }
        } else if (ctx->dmMode && top) { /* dmMode */
            if ( prefix && strlen(prefix)>0 ) {
                if ( strcmp(prefix,"xmlns")==0 )
                    stream_printf(GDKout,"attribute %s:%s { %s }%s",prefix,loc,value,ctx->dmSeparator);
                else
                    stream_printf(GDKout,"attribute %s:%s { %s }",prefix,loc,value);
            } else {
                stream_printf(GDKout,"attribute %s { %s }",loc,value);
            }
        } else { /* xmlMode */
            if ( prefix && strlen(prefix)>0 ) {
                stream_printf(GDKout," %s:%s=",prefix,loc);
            } else {
                stream_printf(GDKout," %s=",loc);
            }
            /* stream_printf(GDKout,"\"%s\"",value); */
            stream_printf(GDKout,"\"");
            emit_escaped(value, 1+ctx->mapiMode, 0/*ALL*/);
            stream_printf(GDKout,"\"");
        }
        return 1;
    }

/**
 * Output generation handler. This one of my own invented event indicating
 * there will be no more attribute events for this node.
 */
static int handle_attributeEnd(XqueryCtx* ctx, int emptyNode) {
    if (ctx->saxMode ) {
    } else { /* xmlMode */
        if ( emptyNode )
            stream_printf(GDKout,"/");
        stream_printf(GDKout,">");
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static int handle_startElement(XqueryCtx* ctx, str ns, str name /*,str *atts*/) {
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( !emit("startElement",NULL,0) )
                return 0;
            if ( ns && (strlen(ns)>0) )
                if ( !emit(" prefix",ns,0) )
                    return 0;
            if ( !emit(" localname",name,0) )
                return 0;
        } else {
            stream_printf(GDKout,"<s %s\n",name);
        }
    } else { /* xmlMode */
        if ( ns && strlen(ns)>0 ) {
            stream_printf(GDKout,"<%s:%s",ns,name);
        } else {
            stream_printf(GDKout,"<%s",name);
        }
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static int handle_endElement(XqueryCtx* ctx, str ns, str name, int emptyNode) {
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( !emit("endElement",NULL,0) )
                return 0;
            if ( ns && (strlen(ns)>0) )
                if ( !emit(" prefix",ns,0) )
                    return 0;
            if ( !emit(" localname",name,0) )
                return 0;
        } else {
            stream_printf(GDKout,"<e %s\n",name);
        }
    } else { /* xmlMode */
        if ( !emptyNode ) {
            if ( ns && strlen(ns)>0 ) {
                stream_printf(GDKout,"</%s:%s>",ns,name);
            } else {
                stream_printf(GDKout,"</%s>",name);
            }
        }
    }
    return 1;
}

/**
 * Output generation handler. One on my own again. This one should handle a
 * reference. Don't know wat to to about it now.
 */
static int handle_reference(XqueryCtx* ctx, str name) {
    (void)ctx;
    (void)name;
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static int handle_characters(XqueryCtx* ctx, str ch, str top) {
    /* INCOMPLETE, we need to escape stuff here
    */
    if ( ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if (!emit("characters",NULL,0))
                return 0;
            if (!emit(" pcdata",ch,1))
                return 0;
        } else {
            stream_printf(GDKout,"%s\n",ch); /* ESCAPE !! */
        }
    } else { /* xmlMode */
        if ( ctx->printMode ) {
            if ( ctx->dmMode && top )
                stream_printf(GDKout,"%s {\\\"", top);

            /* we need to escape newlines */
            emit_escaped(ch, ctx->saxMode, 1 /*JUST ENTITIES*/ );

            if ( ctx->dmMode && top )
                stream_printf(GDKout,"\\\"}");
        } else if ( ctx->mapiMode ) {
            /* we need to prepend "=" to each line, so
               make sure that we print one after each
               newline */
            /*
             * str nl;
             * while ((nl = strchr(ch, '\n')) != NULL) {
             * 	nl++;
             * 	stream_printf(GDKout, "%.*s=", (nl - ch), ch);
             * 	ch = nl;
             * }
             */
            if ( ctx->dmMode && top )
                stream_printf(GDKout,"%s {\"", top);

            emit_escaped(ch,1+ctx->mapiMode, 1/*JUST ENTITIES*/ );

            if ( ctx->dmMode && top )
                stream_printf(GDKout,"\"}");
        } else {
            /*
             * stream_printf(GDKout,"%s",ch);
             */
            if ( ctx->dmMode && top )
                stream_printf(GDKout,"%s {\"", top);

            emit_escaped(ch,1+ctx->mapiMode, 1/*JUST ENTITIES*/ );

            if ( ctx->dmMode && top )
                stream_printf(GDKout,"\"}");
        }
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static int handle_ignorableWhitespace(XqueryCtx* ctx, str ch) {
    return handle_characters(ctx,ch,0); /* dispatch */
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by  Pathfinder.
 */
static int handle_comment(XqueryCtx* ctx, str comm) {
    if (ctx->saxMode ) {
        /* incomplete */
    } else { /* xmlMode */
        stream_printf(GDKout,"<!--%s-->",comm);
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX processingInstruction() event.
 */
static int handle_processingInstruction(XqueryCtx* ctx, str target, str data) {
    if (ctx->saxMode ) {
        /* incomplete */
    } else { /* xmlMode */
        stream_printf(GDKout,"<?%s %s?>",target,data);
    }
    return 1;
}

/**
 * Utility function. It reads the tail value of an element in a
 * [void,any] BAT indexed by oid_index.
 */
static ptr idxTV(XqueryCtx* ctx, str name, BAT* b, oid oid_index) {
    ptr res = NULL;

    if ( !b ) {
        fatal_err(ctx,"idxTV: NIL BAT[\"%s\"]",name);
        return NULL;
    } else if ( BATcount(b) == 0 ) {
        fatal_err(ctx,"idxTV: BAT[%s] is empty",name);
        return NULL;
    } else if ( is_fake_project(b) ) {
        res = BUNtail(b,BUNfirst(b));
    } else {
        BUN bun = NULL;

        BUNfndVOID(bun, b, &oid_index);
        if ( bun ) {
            res = BUNtail(b,bun);
        } else {
            fatal_err(ctx,"idxTV, BAT[%s]: "SZFMT" not within ["SZFMT","SZFMT"]",
                    name, (size_t)oid_index, (size_t)(*(oid*)BUNhead(b,BUNfirst(b))),
                    (size_t)(*(oid*)BUNhead(b,BUNlast(b)-BUNsize(b))));
            return NULL;
        }
    }
    if ( ! res ) {
        fatal_err(ctx,"idxTV: BAT[%s]["SZFMT"], NULL (ptr) result",name,(size_t)oid_index);
        return NULL;
    }
    return res;
}

/**
 * Reads the index tailvalue in a Working Set BAT
 */

static ptr idxTVinWS(XqueryCtx* ctx, int batId, oid oid_index) {
    BAT* b;

    if ( (b = wsBAT(ctx, batId)) ) {
        return idxTV(ctx,"tmp",b,oid_index);
    } else {
        return NULL;
    }
}

/**
 * Reads the index tailvalue in a Working Set BAT or when fragId is not the
 * current working set it reads in the BAT outside the working set.
 */
    static ptr idxTVinWSorFRGN(XqueryCtx* ctx, int fragId, int batId, oid oid_index) {
        if ( ctx->curFRAG == fragId )
            return idxTVinWS(ctx,batId,oid_index);
        else {
            BAT* b;

            if ( !(b = fetchWsContextBAT(ctx,ctx->ws,batId,fragId)) )
                return NULL;
            else {
                ptr res;

                res = idxTV(ctx,"tmp",b,oid_index);
                BBPunfix( BBPcacheid( b ) );
                return res;
            }
        }
    }

/**
 * Handle the generation of the attributes of the node with oid 'pre'. This
 * function is only called from the xquery_node_print() function.
 */

#define CHKVP(P)	if (!(P)) return 0

static int process_attr(XqueryCtx* ctx, int frag, oid id, int top) {
    ptr vp;

    CHKVP(vp = idxTVinWSorFRGN(ctx,frag,ATTR_PROP,id));
    oid prop_oid = *(oid*)vp;
    CHKVP(vp = idxTVinWSorFRGN(ctx,frag,ATTR_FRAG,id));
    int afrag    = (int)*(oid*)vp;
    CHKVP(vp = idxTVinWSorFRGN(ctx,afrag,PROP_VAL,prop_oid));
    str val      = (str)vp;
    /* */
    CHKVP(vp = idxTVinWSorFRGN(ctx,frag,ATTR_QN,id));
    oid qn_oid = *(oid*)vp;
    CHKVP(vp = idxTVinWSorFRGN(ctx,afrag,QN_URI,qn_oid));
    str uri     = (str)vp;
    CHKVP(vp = idxTVinWSorFRGN(ctx,afrag,QN_PREFIX,qn_oid));
    str prefix     = (str)vp;
    CHKVP(vp = idxTVinWSorFRGN(ctx,afrag,QN_LOC,qn_oid));
    str loc   = (str)vp;
    /* */
    return handle_attribute(ctx,uri,prefix,loc,val,top);
}

static int process_node_attr(XqueryCtx* ctx, int nFRAG, oid pre, int emptyNode) {
    BAT *b;

    if ( !(b  = BATuselect(wsBAT(ctx,ATTR_OWN),&pre,&pre)) )
        return fatal_err(ctx,"process_node_attr: uselect fails\n");
    BUN p, q;
    BATloop(b, p, q) {
        oid id = *(oid*)BUNhead(b, p);
        if ( ! process_attr(ctx,nFRAG,id,0/*top*/) ) {
            BBPunfix( BBPcacheid( b ) );
            return 0;
        }
    }
    BBPunfix( BBPcacheid( b ) );
    return handle_attributeEnd(ctx,emptyNode);
}

/**
 * Handle the generation of the node with oid 'pre'.
 */
static int xquery_node_print(XqueryCtx* ctx, oid pre, BAT* pre_frag, int top) {
    ptr vp;
    chr kind;
    oid prop;

    CHKVP(vp = idxTVinWS(ctx,PRE_KIND,pre));
    kind = *(chr*)vp;
    CHKVP(vp = idxTVinWS(ctx,PRE_PROP,pre));
    prop = *(oid*)vp;
    int vFRAG = ctx->curFRAG;
    if ( pre_frag ) {
        CHKVP(vp = idxTV(ctx,"par_pre_frag",pre_frag,pre));
        vFRAG = (int)*(oid*)vp;
    }
    switch( kind ) {
        case (char)0:
            {	/* ELEMENT */
                str uri, prefix, loc;
                CHKVP(vp = idxTVinWSorFRGN(ctx,vFRAG,QN_URI,prop));
                uri   = (str)vp;
                CHKVP(vp = idxTVinWSorFRGN(ctx,vFRAG,QN_PREFIX,prop));
                prefix   = (str)vp;
                CHKVP(vp = (str)idxTVinWSorFRGN(ctx,vFRAG,QN_LOC,prop));
                loc = (str)vp;
                if ( !handle_startElement(ctx,prefix,loc) )
                    return 0;
                CHKVP(vp = idxTVinWS(ctx,PRE_SIZE,pre));
                int size = *(int*)vp;
                if (!pushTag(ctx,pre+size,prefix,loc,(size==0)))
                    return 0;
                /* check for change of prefix/uri. 'top' is not
                 * propagated here because an attribute inside an
                 * element can never be top-level.
                 */
                if ( ! checkNsChange(ctx,uri,prefix,0) )
                    return 0;
                if ( !process_node_attr(ctx,ctx->curFRAG,pre,(size==0)))
                    return 0;
                break;
            }
        case (char)1:
            {	/* PFTEXT */
                if ( !handle_characters(ctx,(str)idxTVinWSorFRGN(ctx,vFRAG,PROP_TEXT,prop),(top?"text":0)))
                    return 0;
                break;
            }
        case (char)2:
            {	/* COMMENT */
                if ( !handle_comment(ctx,(str)idxTVinWSorFRGN(ctx,vFRAG,PROP_COM,prop)))
                    return 0;
                break;
            }
        case (char)3:
            {	/* PI */
                str target, data;
                CHKVP(target = idxTVinWSorFRGN(ctx,vFRAG,PROP_TGT,prop));
                CHKVP(data = idxTVinWSorFRGN(ctx,vFRAG,PROP_INS,prop));
                if (!handle_processingInstruction(ctx,target,data))
                    return 0;
                break;
            }
        case (char)4:
            {	/* DOCUMENT */
                /* The node represents an entire document */
                CHKVP(vp = idxTVinWS(ctx,PRE_SIZE,pre));
                int offset = *(int*)vp;
                if (!pushTag(ctx,pre+offset,"","",0/*false*/))
                    return 0;
                break;
            }
        default:
            return fatal_err(ctx,"Unknow kind IN xquery_node_print");
    }
    return 1;
}

#define ALLTAGS INT_MAX

/**
 * handle the closing tag of a document.
 */
static int xquery_endtag_print(XqueryCtx* ctx, oid pre) {
    while( moreTags(ctx) && ((pre==ALLTAGS)||(pre > topSF(ctx)->pre)) ) { /*?? */
        if ( strlen(topName(ctx)) > 0 )
            if ( !handle_endElement(ctx,topNs(ctx),topName(ctx),topSF(ctx)->empty))
                return 0;
        popTag(ctx);
    }
    return 1;
}

/**
 * handle the range of pre numbers [from .. to]
 */
static int xquery_pre_range(XqueryCtx* ctx, BAT* b, oid from, oid to) {
    BUN p, q;
    if ( from == 0 ) /* first BUN, because of 1..n/0..n-1 problem */
        p = BUNfirst(b);
    else
        BUNfndOID(p, b, (ptr)(&from));
    for(q = BUNlast(b); p<q; p = BUNnext(b, p)) {
        oid pre = *(oid*)BUNhead(b, p);
        do {
            if ( !xquery_node_print(ctx, pre, 0 /*pre_frag*/, 0 /*false*/))
                return 0;
            if ( !xquery_endtag_print(ctx,++pre) )
                return 0;
        } while( moreTags(ctx) && (pre<to) );
    }
    if ( moreTags(ctx) ) {
        /* INCOMPLETE, the next line works but WHY? Should work without */
        if ( !xquery_endtag_print(ctx,ALLTAGS) )
            return 0;
    }
    return 1;
}

static int MY_xquery_pre_range(XqueryCtx* ctx, oid from, oid to, BAT* pre_frag, int top) {
    oid pre = from;

    do {
        if ( !xquery_node_print(ctx, pre,pre_frag,top&&(from==to)) /*cheat*/ )
            return 0;
        if ( !xquery_endtag_print(ctx,++pre) )
            return 0;
    } while( moreTags(ctx) && (pre<=to) );
    return 1;
}

/**
 *
 * X. THE MAIN XML DOCUMENT PRINTING PART
 *
 * Main XML document printing routine
 */

static int ws_documentIndex(BAT* ws, str docName) {
    oid doc_loaded_idx = (oid)DOC_LOADED;

    BUN b = BUNfnd(ws,&doc_loaded_idx);

    if ( !b )
        return fatal_err(0,"ws_documentIndex: unable to find docbat in WS");

    BAT* doc_loaded = BATdescriptor(*(bat*)b);

    BUN p, q;
    BATloop(doc_loaded, p, q) {
        oid docId = *(oid*)BUNhead(doc_loaded, p);
        str docNm = (str)BUNtail(doc_loaded, p);

        if ( strcmp(docName,docNm) == 0 ) {
            BBPunfix( BBPcacheid( doc_loaded ) );
            return docId;
        }
    }
    BBPunfix( BBPcacheid( doc_loaded ) );
    return -1;
}

int xquery_print_doc_main(str mode, BAT* ws, str docName) {
    int docIndex = ws_documentIndex(ws,docName);
    if ( docIndex < 0 ) {
        GDKwarning("serialize.mx:xquery_print_doc_main: unable to find document \"%s\" in working set!\n",docName);
        return GDK_SUCCEED;
    }
    /* */
    XqueryCtx  ctx_struct, *ctx = &ctx_struct;
    if ( !createWsContext(ctx,ws,docIndex,mode) )
        return GDK_FAIL;
    /* */
    if ( !handle_startDocument(ctx) )
        return GDK_FAIL;
    if ( !xquery_pre_range(ctx,wsBAT(ctx,PRE_SIZE),0/*start*/,1 /* first is doc ? */) )
        return GDK_FAIL;
    if ( !handle_endDocument(ctx) )
        return GDK_FAIL;
    switchWsContext(ctx,-1); /* close all open context BAT's */
    /* */
    if ( !disposeWsContext(ctx) )
        return GDK_FAIL;
    /* */
    return GDK_SUCCEED;
}

/**
 * XI. THE MAIN PATHFINDER QUERY RESULT PART
 *
 * First the event/emit handlers for the sequnce are defined and after that
 * the main function
 */

#define XQRESTAG        "XQueryResult"

/*
 * BAT format definitions. These must be equal to the definitions
 * in pathfinder.mx
 */

#define XTRACT_KIND(X)  (X & 63)
#define XTRACT_FRAG(X)  (X >> 6)

#define QNAME 2
#define BOOL  3
#define INT   4
#define DEC   5
#define DBL   6
#define STR   7
#define U_A   8
#define NODE  32
#define ELEM  33
#define ATTR  34

/**
 * Handle the start() of an XQUERY/Pathfinder result sequence
 */
static int id_sequence_counter = 0;
static int  seqHeadStart(
        XqueryCtx* ctx,
        BAT* item)
{
    if (ctx->printMode) {
        /* write SQL-ish header */
        stream_printf(GDKout,"#-\n");
        stream_printf(GDKout,"# 3\t# querytype\n");
        stream_printf(GDKout,"# xquery_result\t# table_name\n");
        stream_printf(GDKout,"# xml\t# name\n");
        stream_printf(GDKout,"# varchar\t# type\n");
        stream_printf(GDKout,"# %d\t# length\n", 60);
        stream_printf(GDKout,"# %d\t# tuplecount\n", BATcount(item));
        stream_printf(GDKout,"# %d\t# id\n", id_sequence_counter++);
    } else if (!ctx->dmMode) { /* dmMode has no header */
        if (!ctx->norootMode) {
            if (ctx->mapiMode) {
                stream_printf(GDKout,"=<?xml version=\"1.0\" encoding=\"utf-8\"?>\n=");
            } else if ( !ctx->saxMode ) {
                stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
            }
            handle_startElement(ctx, NULL, XQRESTAG);
        }
        ctx->nAttrOnLine = 0;
    }
    return 1;
}

static int seqHeadEnd(XqueryCtx* ctx) {
    if ( ! ctx->dmMode ) { /* dmMode has no header */
        handle_attributeEnd(ctx, 0);
        if ( !ctx->saxMode )
            stream_printf(GDKout,
                    (ctx->mapiMode ? "\n=" : (ctx->printMode ? "\\n" : "\n")));
    }
    return 1;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static int  seqEnd(XqueryCtx* ctx) {
    if ( ctx->saxMode ) {
        if (!ctx->norootMode) {
            handle_endElement(ctx, NULL, XQRESTAG, 0 /* not empty*/);
        }
    } else if (ctx->printMode) {
        /* do nothing! */
    } else if (ctx->dmMode) {
        stream_printf(GDKout, "\n");
    } else if (ctx->mapiMode) {
        stream_write(GDKout,"\n=", 2, 1);
        if (!ctx->norootMode) stream_printf(GDKout,"</%s>\n", XQRESTAG);
    } else {
        stream_write(GDKout,"\n", 1, 1);
        if (!ctx->norootMode) stream_printf(GDKout, "</%s>\n", XQRESTAG);
    }
    return 1;
}


/**
 * Emit a NODE element of an XQUERY/Pathfinder result sequence
 */
static int seqEmitNode(XqueryCtx* ctx, oid preVal, BAT* pre_frag, int top) {
    ptr vp;

    /* incomplete, different for dmMode ?? */
    CHKVP(vp = idxTVinWS(ctx,PRE_SIZE,preVal));
    int size = *(int*)vp;
    return MY_xquery_pre_range(ctx,preVal,preVal+size, pre_frag, top);
}

/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
static int  seqEmitBool(XqueryCtx* ctx, int bv) {
    char *bool_str = (char*)(bv ? "true" : "false");

    if ( ctx->saxMode ) {
        return handle_characters(ctx,bool_str,0);
    } else if ( ctx->dmMode ) {
        stream_printf(GDKout,"%s ",bool_str);
    } else {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"%s ",bool_str);
    }
    return 1;
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
static int  seqEmitInt(XqueryCtx* ctx, int iv) {
    if ( ctx->saxMode ) {
        char buff[32];

        sprintf(buff,"%d",iv);
        return handle_characters(ctx,buff,0);
    } else if ( ctx->dmMode ) {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"%d",iv);
    } else {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"%d ",iv);
    }
    return 1;
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
static int  seqEmitDbl(XqueryCtx* ctx, dbl dv) {
    if ( ctx->saxMode ) {
        char buff[32];

        sprintf(buff,"%f",dv);
        return handle_characters(ctx,buff,0);
    } else if ( ctx->dmMode ) {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"%f",dv);
    } else {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"%f ",dv);
    }
    return 1;
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
static int  seqEmitStr(XqueryCtx* ctx, str sv) {
    if ( ctx->saxMode ) {
        return handle_characters(ctx,sv,"text");
    } else if ( ctx->printMode ) {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"\\\"");
        emit_escaped(sv, ctx->saxMode, 0 /*ALL*/);
        stream_printf(GDKout,"\\\"");
    } else if ( ctx->dmMode ) {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"\"");
        emit_escaped( sv, 1+ctx->mapiMode, 0/*ALL*/ );
        stream_printf(GDKout,"\"");
    } else {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"\"");
        emit_escaped( sv, 1+ctx->mapiMode, 0/*ALL*/);
        stream_printf(GDKout,"\" ");
    }
    return 1;
}

/**
 * Main XQUERY/Pathfinder result sequence printing routine. Arguments are
 * mode: "xml" or "sax"
 * ws : the working set
 * item/kind : sequence result BATs
 * intVAL,dblVAL,decVAL,strVAL : BATSs containing the values of seq elements
 * remainder BATs: conatins the data for the document nodes
 *
 * The function iterates through the item/kind BAT's and retrieves the values
 * from the xxxVAL BATs. Then it calls one of the seqXXXXX() functions
 * defined above to handle the output generation.
 */

int xquery_print_result_main(
        str  mode,
        BAT* ws,
        BAT* item,
        BAT* kind,
        BAT* intVAL,
        BAT* dblVAL,
        BAT* decVAL,
        BAT* strVAL)
{
    ptr vp;

    XqueryCtx  ctx_struct, *ctx = &ctx_struct;
    if ( !createWsContext(ctx,ws,-1,mode) )
        return GDK_FAIL;
    /* */
    if ( !seqHeadStart(ctx, item) )
        return GDK_FAIL;
    if ( ! ctx->dmMode ) {
        /* If the mode is not the DM mode do a scan of all attributes here
         * and generate the appropriate calls to connect them to the
         * head tag of the result document
         */
        BUN p, q;
        BATloop(item, p, q) {
            oid pre, valoid;
            pre = *(oid*)BUNhead(item, p);
            valoid = *(oid*)BUNtail(item, p);
            CHKVP( vp = idxTV(ctx,"kind",kind,pre) );
            int cmbn_frag_kind = *(int*)vp;

            if ( XTRACT_KIND(cmbn_frag_kind) == ATTR ) {
                int frag = XTRACT_FRAG(cmbn_frag_kind);
                if ( !process_attr(ctx,frag,valoid,1/* top */) )
                    return GDK_FAIL;
            }
        }
    }
    if ( !seqHeadEnd(ctx) )
        return GDK_FAIL;
    /* */
    int cnt = 0; /* loopcounter, used for checking when to print commas. */
    BUN p, q;
    BATloop(item, p, q) {
        oid pre = *(oid*)BUNhead(item, p);
        oid valoid = *(oid*)BUNtail(item, p);
        CHKVP( vp = idxTV(ctx,"kind",kind,pre) );
        int cmbn_frag_kind = *(int*)vp;
        if (ctx->printMode) {
            stream_printf(GDKout, "[ \"");
        } else if ( cnt++ && ctx->dmMode  ) {
            /* should print a separator here */
            stream_printf(GDKout,"%s",ctx->dmSeparator);
        }
        switch( XTRACT_KIND(cmbn_frag_kind) ) {
            case ATTR:
                {
                    if ( ctx->dmMode ) {
                        int frag = XTRACT_FRAG(cmbn_frag_kind);
                        if ( !process_attr(ctx,frag,valoid,1/* top */) )
                            return GDK_FAIL;
                    }
                    break;
                };
            case ELEM:
                {
                    int frag = XTRACT_FRAG(cmbn_frag_kind);
                    /* if ( ctx->dmMode ),check for first kind text { "t" }
                     * check idxTVinWSorFRGN(ctx,frag,PRE_KIND,valoid);
                     * for TEXT
                     */
                    int oldCtx = switchWsContext(ctx,frag);
                    if ( !seqEmitNode(ctx, valoid, wsBAT(ctx,PRE_FRAG),1/*top*/) )
                        return GDK_FAIL;
                    switchWsContext(ctx,oldCtx);
                    break;
                };
            case NODE:
                {
                    /* INCOMPLETE, suppose just ignore ?*/
                    break;
                };
            case BOOL:
                {
                    if ( !seqEmitBool(ctx,valoid) )
                        return GDK_FAIL;
                    break;
                }
            case DBL:
                {
                    CHKVP(vp = idxTV(ctx,"dblVAL",dblVAL,valoid));
                    dbl dv = *(dbl*)vp;
                    if (!seqEmitDbl(ctx,dv) )
                        return GDK_FAIL; /* INCOMPLETE ?diff between d and e */
                    break;
                }
            case DEC:
                {
                    CHKVP(vp = idxTV(ctx,"decCVAL",decVAL,valoid));
                    dbl dv = *(dbl*)vp;
                    if ( !seqEmitDbl(ctx,dv) )
                        return GDK_FAIL; /* INCOMPLETE ?diff between d and e */
                    break;
                }
            case INT:
                {
                    CHKVP(vp = idxTV(ctx,"intVAL",intVAL,valoid));
                    int iv = *(int*)vp;
                    if ( !seqEmitInt(ctx,iv) )
                        return GDK_FAIL;
                    break;
                }
            case STR:
                {
                    CHKVP(vp = idxTV(ctx,"strVAL",strVAL,valoid));
                    str sv = (str)vp;
                    if ( !seqEmitStr(ctx,sv) )
                        return GDK_FAIL;
                    break;
                }
            case U_A:
                {
                    CHKVP(vp = idxTV(ctx,"strVAL",strVAL,valoid));
                    str sv = (str)vp;
                    if ( !seqEmitStr(ctx,sv) )
                        return GDK_FAIL;
                    break;
                }
            default:
                GDKerror("serialize.mx:xquery_print_result_main: [kind=%d, frag=%d]\n",
                         XTRACT_KIND(cmbn_frag_kind),XTRACT_FRAG(cmbn_frag_kind));
                fatal_err(ctx,"UNKNOW_TYPE(\'%c\'ch(%d))\n",cmbn_frag_kind,cmbn_frag_kind);
                return GDK_FAIL;
        }
        if (ctx->printMode) {
            stream_printf(GDKout,"\"\t]\n");
        }
    }
    /* */
    if ( !seqEnd(ctx) )
        return GDK_FAIL;
    /* */
    switchWsContext(ctx,-1); /* close all open context BAT's */
    /* */
    if ( !disposeWsContext(ctx) )
        return GDK_FAIL;
    /* */
    return GDK_SUCCEED;
}
/* vim:set shiftwidth=4 expandtab: */
