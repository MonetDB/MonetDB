@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2006 University of Konstanz.  All Rights Reserved.
@'

@f serialize
@a Jan Flokstra
@t serialize

@h

/* #define SHOW_TIMING */

/**
 * The SmartStrBuff structure is defined to prevent too much alloc/free actions.
 * If the size of a string is smaller then SMART_STR_SZ the value is
 * stored in stack_buff[] within the structure. Otherwise it is strdupped and
 * freed like usual.
 */

#define SMART_STR_SZ    16

typedef struct {
    char stack_buff[SMART_STR_SZ];
    str  val;
} SmartStrBuff;


struct XmlNsFrame; /* forward */
typedef struct XmlNsFrame {
    char*			prefix;
    char*			uri;
    struct XmlNsFrame*	prev;
    struct XmlNsFrame*	next;
} XmlNsFrame;

typedef struct SerializeFrame {
    oid             pre;
    int             empty;  /* boolean indicating node is empty */
    XmlNsFrame*	    nsMark;
    SmartStrBuff    ssb_ns;
    SmartStrBuff    ssb_name;
} SerializeFrame;

#define MAXTAGDEPTH        1024

#define WS_BATS     WS_SIZE

/**
 * The XqueryCtx structure contains the context of the print session.
 * It has several functions. But its main use is the administration
 * of all BATs containing the XML documents.
 *
 */


#define IS_FAKE_PROJECT(b) ((b->batCount == 1) & (b->hseqbase == oid_nil) & (b->htype == TYPE_void))

/**
 * The definition of the working-set BAT structure. For every bat in the
 * working set there is a structure of this type in the wsMatrix matrix
 * representation of the working set. The first dimension is the container
 * of the bat and the second is the BAT id.
 */
typedef struct wsBatDescr {
	BAT*	bat;
	ptr	fake_prj;
} wsBatDescr;

struct serializeFunStruct; /* forward */

/**
 * The serialization context structure. All context/runtime data is
 * accessed through this function.
 */
typedef struct {
    int     dmMode;         /* Data model flag, true if printing in
                             * data-model mode, eg. look like GALAX */
    int     saxMode;        /* true if printing a Sax-O-Phone stream */
    int     mapiMode;       /* for DM or XML mode that should go on a
                               MapiClient stream */
    int     norootMode;     /* do not generate <XQueryResult> root node */
    int     noheaderMode;   /* do not generate xml header */
    int     typedMode;      /* surrant every single value with an extra
                               tag, with the XQuery type of this value
                               as the tag name */
    int     printMode;      /* true if printing SQL-ish/MCL-ish output,
                               is used by JDBC/XML:DB at the moment */
    char*   restag;         /* root element name XQueryResult */
    char*   dmSeparator;    /* separation char in DM mode */
    BAT*    ws;             /* working set BAT */
    int     curCONT;        /* current container used by working set */
    /* */
    XmlNsFrame* nsTop;	/* top of the namespace stack */
    /**
     * Next elements is a stack used during printing to store the
     * pre-value, name, namespace of the nodes currently being printed.
     */
    int     stackPtr;
    SerializeFrame	tagStack[MAXTAGDEPTH];
    /* */
    int     nAttrOnLine; /* used by top result print routine to count the
                          * number of top-level result items printed on
                          * the current line.
                          */
    struct serializeFunStruct*	driverFun; /* the output handling functions */
    void*			driverWs;  /* optional workspace for the driver */
    int		wsFrags; /* The number of containers in the working set */
    wsBatDescr	*wsMatrix;
} XqueryCtx;

typedef struct serializeFunStruct {
	const char* name;
	/* the initialization handler */
	int (*init)(XqueryCtx* ctx, char* args);
	/* the (part of ) document handler functions */
	int (*handle_startDocument)(XqueryCtx* ctx);
	int (*handle_endDocument)(XqueryCtx* ctx);
	int (*handle_attribute)(XqueryCtx* ctx, str uri, str prefix, str loc, str value, int top);
	int (*handle_attributeEnd)(XqueryCtx* ctx, int emptyNode);
	int (*handle_startElement)(XqueryCtx* ctx, str ns, str name, oid pre);
	int (*handle_endElement)(XqueryCtx* ctx, str ns, str name, int emptyNode);
	int (*handle_characters)(XqueryCtx* ctx, str ch, str top);
	int (*handle_ignorableWhitespace)(XqueryCtx* ctx, str ch);
	int (*handle_comment)(XqueryCtx* ctx, str comm);
	int (*handle_processingInstruction)(XqueryCtx* ctx, str target, str data);
	/* and now the sequence handlers */
	int (*seqStart)(XqueryCtx* ctx, BAT* item);
	int (*seqDmAttrStart)(XqueryCtx* ctx);
	int (*seqDmAttrEnd)(XqueryCtx* ctx);
	int (*seqElementStart)(XqueryCtx* ctx, int cnt);
	int (*seqElementEnd)(XqueryCtx* ctx, int cnt);
	int (*seqEnd)(XqueryCtx* ctx);
	int (*seqEmitBool)(XqueryCtx* ctx, int bv, int lastVal);
	int (*seqEmitInt)(XqueryCtx* ctx, lng iv, int lastVal);
	int (*seqEmitDbl)(XqueryCtx* ctx, dbl dv, int lastVal);
	int (*seqEmitStr)(XqueryCtx* ctx, str sv, int lastVal);
} serializeFunStruct;

extern struct serializeFunStruct dfltSerializeFun, saxSerializeFun;

extern int xquery_print_doc_DRIVER(
	str			mode, 
	serializeFunStruct*	driverFun,
	char*			driverArg,
	BAT*			ws,
	str			docName);

pf_support_export int xquery_print_result_main(
        str  mode,
        BAT* ws,
        BAT* item, 
        BAT* kind,
        BAT* intVAL,
        BAT* dblVAL,
        BAT* decVAL,
        BAT* strVAL);

extern int xquery_print_result_DRIVER(
        str 			mode,
	serializeFunStruct*	driverFun,
	char*			driverArg,
        BAT*			ws,
        size_t			niters,
        BAT*			loop,
        BAT*			iter,
        BAT*			item, 
        BAT*			kind,
        BAT*			intVAL,
        BAT*			dblVAL,
        BAT*			strVAL);


/* INCOMPLETE, should not be neccesary here */
extern int checkNsChange(XqueryCtx* ctx, str par_uri, str par_prefix, int top);

extern int emit_escaped(char* src, int mode, int onlyEntity);

@c

/*******************************************
 * serialize.c : XML serialization
 *
 */

#include <gdk.h>
#include <monet.h>

#include "pathfinder.h"
#include "pf_support.proto.h"
#include "serialize.h"

/**
 *
 * 0. SMALL UTILITY SECTION
 *
 * Here a structure is defined to prevent too much alloc/free actions.
 * If the size of a string is smaller then SMART_STR_SZ the value is
 * stored in stack_buff[] within the structure. Otherwise it is strdupped and
 * freed like usual.
 */

static int ssb_alloc(SmartStrBuff* ssb, str s) {
    if ( s ) {
        size_t l = strlen(s)+1;

        if ( l <= SMART_STR_SZ )
            return (ssb->val = memcpy(&ssb->stack_buff,s,l)) != NULL;
        else
            return (ssb->val = strdup(s)) != NULL;
    } else
        ssb->val = NULL;
    return 1;
}

static void ssb_free(SmartStrBuff* ssb) {
    if ( ssb->val && (ssb->val != (str)&ssb->stack_buff) ) {
        free( ssb->val );
    }
    ssb->val = NULL;
}

/**
 *
 */

/* #define DEBUGNS */

int xmlNsInit(XmlNsFrame** top) {
#ifdef DEBUGNS
    stream_printf(GDKout,"+NS:xmlNsInit()\n");
#endif
    *top = NULL;
    return 1;
}

char* xmlNsFind(XmlNsFrame** top, char* prefix) {
    XmlNsFrame* fp = (*top);

    while( fp ) {
        if (prefix == NULL) {
            if (fp->prefix == NULL) {
#ifdef DEBUGNS
                stream_printf(GDKout,"+NS:xmlNsFind(NULL)=NULL)\n");
#endif
                return fp->uri;
            }
        } else if (fp->prefix != NULL && strcmp(prefix,fp->prefix) == 0) {
#ifdef DEBUGNS
            stream_printf(GDKout,"+NS:xmlNsFind(\"%s\")=\"%s\")\n",prefix,fp->uri);
#endif
            return fp->uri;
        }
        fp = fp->prev;
    }
    return NULL;
}

XmlNsFrame* xmlNsPush(XmlNsFrame** top, char* prefix, char* uri) {
    XmlNsFrame* fp = (XmlNsFrame*)malloc(sizeof(XmlNsFrame));

    if ( fp ) {
#ifdef DEBUGNS
        stream_printf(GDKout,"+NS:xmlNsPush(\"%s\",\"%s\")\n",prefix,uri);
#endif
        fp->prefix = NULL;
        if ( prefix && !( fp->prefix = strdup(prefix)) ) return NULL;
        if ( !(fp->uri    = strdup(uri)) ) return NULL;
        /* */
        fp ->next  = NULL;
        if ( *top ) {
            (*top)->next = fp;
            fp->prev     = *top;
        } else {
            fp->prev = NULL;
        }
        *top     = fp;
    }
    return fp;
}

int xmlNsPop2(XmlNsFrame** top, XmlNsFrame* newTop) {
    XmlNsFrame* fp = (*top);

#ifdef DEBUGNS
    stream_printf(GDKout,"+NS:xmlNsPop2(%d)\n",(int)newTop);
#endif
    while (fp != newTop ) {
        XmlNsFrame* old = fp;
        fp = fp->prev;
#ifdef DEBUGNS
        stream_printf(GDKout,"+NS:-popping(\"%s\",\"%s\")\n",old->prefix,old->uri);
#endif
        free(old->prefix);
        free(old->uri);
        free(old);
    }
    if ( (*top = newTop) ) {
        (*top)->next = NULL;
    };
    return 1;
}

int xmlNsDispose(XmlNsFrame** top) { return xmlNsPop2(top,NULL); }

/**
 *
 * I. THE CONTEXT NODE DEFINITION AND USAGE PART
 *
 */

/**
 * The local error handler for the serialization.
 */
static int fatal_err(XqueryCtx* ctx, const char *msg, ...) {
    va_list msgs;
    char    errmsg[1024];

    (void)ctx;
    va_start (msgs, msg);
    vsnprintf (errmsg, 1024, msg, msgs);
    va_end (msgs);
    /* */
    GDKerror("XML Generation: %s\n",errmsg);
    /* */
    return 0;
}


/* #define DEBUGWS */

/**
 * Functions fills a new context() record with mode and BAT data and
 * initializes all other data structures.
 */

#define CHECKWSMI(CTX,F,B) if (((F)>=CTX->wsFrags)||((B)>=WS_BATS)) { fatal_err(CTX,"WSbat [%d,%d] out of range.",F,B); return 0; }
#define WSMI(F,B) ((F)*WS_BATS+B)

static int initWsMatrix(XqueryCtx* ctx) {
    oid first = 0;
    BUN bun;
    BAT* batbat = NULL;
    if ( !(bun = BUNfnd(ctx->ws,&first)) ) {
        fatal_err(ctx,"initWsMatrix: cannot find ws-bat[0]");
        return 0;
    }
    if ( !( batbat = BATdescriptor(*(bat*)bun)) ) {
        fatal_err(ctx,"initWsMatrix: cannot find ws-bat[0]");
        return 0;
    }
    /* */
    ctx->wsFrags = BATcount(batbat);
    BBPunfix( BBPcacheid( batbat ) );
    if ( !( ctx->wsMatrix = (wsBatDescr*)malloc(ctx->wsFrags*WS_BATS*sizeof(wsBatDescr))) ) {
    	return 0;
    }
    for(int i=0; i<ctx->wsFrags; i++) {
        for(int j=0; j<WS_BATS; j++) {
	    CHECKWSMI(ctx,i,j);
	    wsBatDescr* bd = &ctx->wsMatrix[WSMI(i,j)];

	    bd->bat = NULL;
        }
    }
#ifdef DEBUGWS
    stream_printf(GDKout,"+ initWsMatrix(wsFrags=%d, wsBats=%d).\n",ctx->wsFrags,ctx->wsBats);
#endif
    /* */
    return 1;
}

static int disposeWsMatrix(XqueryCtx* ctx) {
    for(int i=0; i<ctx->wsFrags; i++) {
        for(int j=0; j<WS_BATS; j++) {
	    CHECKWSMI(ctx,i,j);
	    wsBatDescr* bd = &ctx->wsMatrix[WSMI(i,j)];

	    if ( bd->bat ) {
#ifdef DEBUGWS
    		stream_printf(GDKout,"+ disposeWsMatrix(close(cont=%d,bats=%d))\n",i,j);
#endif
    		BBPunfix( BBPcacheid( bd->bat ) );
	    	bd->bat = NULL;
	    }
        }
    }
#ifdef DEBUGWS
    stream_printf(GDKout,"+ disposeWsMatrix() finished.\n");
#endif
    return 1;
}

static BAT* fetchWsContextBAT(XqueryCtx* ctx, BAT* ws, int contID, int batID) {
    BUN bun;
    oid BATid = (oid)batID;
    oid CONTid  = (oid)contID;

    if ( contID < 0 ) {
        fatal_err(ctx,"fetchWsContextBAT: NO contID CONTEXT SELECTED");
        return NULL;
    }
    if ( !(bun = BUNfnd(ws,&BATid)) ) {
        fatal_err(ctx,"fetchWsContextBAT: NOT FOUND BAT[%d]",batID);
        return NULL;
    }
    BAT* batbat;
    if ( !( batbat = BATdescriptor(*(bat*)bun)) ) {
        fatal_err(ctx,"fetchWsContextBAT:FETCH BATBAT for WS[%d][%d] FAILED\n",batID ,contID);
        return NULL;
    }
    BUN bbun = BUNfnd(batbat,&CONTid);
    BAT *res = NULL;
    if ( !bbun ) {
        BBPunfix( BBPcacheid( batbat ) );
        fatal_err(ctx,"fetchWsContextBAT:NOT FOUND BAT[%d][%d] in WS!!!!\n",batID,contID);
        return NULL;
    } else {
        if ( !(res = BATdescriptor(*(bat*)bbun)) ) {
            BBPunfix( BBPcacheid( batbat ) );
            fatal_err(ctx,"fetchWsContextBAT:FETCH WS[%d][%d] FAILED\n",batID,contID);
            return NULL;
        }
    }
    BBPunfix( BBPcacheid( batbat ) );
    return res;
}

static wsBatDescr* getMatrixBATrecord(XqueryCtx* ctx, int contID, int batID) {
    wsBatDescr* bd;

    CHECKWSMI(ctx,contID,batID);
    bd = &ctx->wsMatrix[WSMI(contID,batID)];
    if ( !bd->bat ) {
        if ( !(bd->bat = fetchWsContextBAT(ctx,ctx->ws,contID,batID)) ) {
#ifdef DEBUGWS
    	    stream_printf(GDKout,"+ getMatrixBAT(open(cont=%d,bats=%d)) = FAIL\n",contID,batID);
#endif
	    return NULL;
        }
        if ( IS_FAKE_PROJECT(bd->bat) ) {
             bd->fake_prj = BUNtail(bd->bat,BUNfirst(bd->bat));
        } else
             bd->fake_prj = 0;
	
#ifdef DEBUGWS
    	stream_printf(GDKout,"+ getMatrixBAT(open(cont=%d,bats=%d)) = SUCCES\n",contID,batID);
#endif
    }
    return bd;
}

static INLINE BAT* getMatrixBAT(XqueryCtx* ctx, int contID, int batID) {
	wsBatDescr* res = getMatrixBATrecord(ctx,contID,batID);

	return (res?res->bat:NULL);
}

/**
 * The getWsBAT() function is responsible for the BAT with index
 * 'batID from container' contID in the working set
 */
#define getWsBAT(_b, ctx, contID, batID) {                                  \
    _b = getMatrixBAT(ctx,contID,batID);                                    \
    if ( _b == NULL )                                                       \
        return fatal_err(ctx, "getWsBAT(id=%d,cont=%d) fails",batID,ctx->curCONT); \
}

#define IS_FAKE_PROJECT(b) ((b->batCount == 1) & (b->hseqbase == oid_nil) & (b->htype == TYPE_void))

static int idxTVerror1(XqueryCtx* ctx, BAT *b, oid oid_index)
{ 
    return fatal_err(ctx, "%s BAT does not have a " OIDFMT " head.\n",
                    b?BBP_logical(b->batCacheid):"NULL", oid_index);
}

static int idxTVerror2(XqueryCtx* ctx, BAT *b)
{ 
    BATprint(b); 
    return fatal_err(ctx, "%s BAT is empty.\n",
                    b?BBP_logical(b->batCacheid):"NULL");
}

static int idxTVerror3(XqueryCtx* ctx, BAT *b, oid oid_index)
{ 
    return fatal_err(ctx, "%s BAT has a " OIDFMT " head, but tail is NULL.\n",
                    b?BBP_logical(b->batCacheid):"NULL", oid_index);
}

/**
 * Utility function. It reads the tail value of an element in a
 * [void,any] BAT indexed by oid_index.
 */
#define findTailValue(res, ctx, b, oid_index) {                 \
    /* fprintf(stderr,"** idxTV()\n");*/			\
    if (IS_FAKE_PROJECT(b)) {                                   \
        res = BUNtail(b,BUNfirst(b)); /* fake project */        \
    } else if (b->batCount) {                                   \
        BUN _bun = NULL;                                        \
        BUNfndVOID(_bun, b, &oid_index);                        \
        if (_bun == NULL)                                       \
            return idxTVerror1(ctx,b,oid_index);                \
        res = BUNtail(b,_bun);                                  \
    } else                                                      \
        return idxTVerror2(ctx,b);                              \
    if (res == NULL)                                            \
        return idxTVerror3(ctx,b,oid_index);                    \
}

#define getWsValue(RES, ctx, contID, batID, oid_index) {        \
    RES = readWsValue(ctx,contID,batID,oid_index);              \
    if ( RES == NULL )                                          \
        return idxTVerror3(ctx,NULL,oid_index);                 \
}

static ptr readWsValue(XqueryCtx* ctx, int contID, int batID, oid oid_index) {
    wsBatDescr* mr = getMatrixBATrecord(ctx,contID,batID);

    if ( mr ) {
        if ( mr->fake_prj)
	     return mr->fake_prj;
    	else {
	    BAT* b = mr->bat;

            if (b->batCount) {
                 BUN _bun = NULL;
                 BUNfndVOID(_bun, b, &oid_index);
                 if (_bun == NULL) {
                     idxTVerror1(ctx,b,oid_index);
		     return NULL;
		 }
                 return BUNtail(b,_bun);
            } else {
                 idxTVerror2(ctx,b);
		 return NULL;
	    }
	}
    }
    return NULL;
}


static INLINE void setDefaultCONT(XqueryCtx* ctx, int contID) {
    ctx->curCONT   = contID;
}

static int createWsContext(
		XqueryCtx*		ctx,
		BAT*			ws,
		int			contID,
		str			mode,
		serializeFunStruct*	driverFun,
		char*			driverArg
	) {
    ctx->dmMode = ctx->mapiMode = ctx->printMode = 0;
    ctx->norootMode = ctx->noheaderMode = ctx->typedMode = 0;
    ctx->saxMode = 1;
    xmlNsInit( &ctx->nsTop );

    /* choose a mode: {dm,xml,sax} */ 
    if ( strstr(mode,"dm")) {
        ctx->dmMode = 1; ctx->saxMode = 0;
    } else if (strstr(mode,"xml")) {
        ctx->dmMode = ctx->saxMode = 0;
        /* we may omit the synthetic root element */ 
        if (strstr(mode,"noheader")) {
            ctx->noheaderMode = 1;
        }
        if (strstr(mode, "typed")) {
            ctx->typedMode = 1;
        }
        if (strstr(mode,"noroot")) {
            ctx->norootMode = 1;
        } else {
            ctx->restag = strstr(mode,"root-");
            if (ctx->restag == NULL) {
                ctx->restag = "XQueryResult"; /* default root tag */
            } else {
                ctx->restag += 5; /* rest of mode is root tag */
            }
        }
    }
    /* */
    if ( driverFun )
    	ctx->driverFun = driverFun;
    else
	if ( ctx->saxMode )
    	    ctx->driverFun = & saxSerializeFun;
	else
    	    ctx->driverFun = & dfltSerializeFun;
    if ( !ctx->driverFun->init(ctx,driverArg) )
        return GDK_FAIL;
    /* */
    if (!ctx->saxMode) {
        /* add mapi = characters at the start of each line */
        if (strstr(mode,"mapi")) {
            ctx->mapiMode = 1;
        }
        /* go into SQL-ish/MCL-ish mode */
        if (strstr(mode, "seq")) {
            ctx->dmMode = ctx->printMode = 1;
        }
    }
    ctx->dmSeparator =
        (ctx->mapiMode ? ",\n=" : (ctx->printMode ? ",\\n" : ",\n"));


    ctx->ws        = ws;
    /* */
    if ( contID >= 0 )
        setDefaultCONT(ctx, contID);
    /* */
    ctx->stackPtr  = 0;
    if ( !initWsMatrix(ctx) )
    	return GDK_FAIL;
    return 1;
}

static int disposeWsContext(XqueryCtx* ctx) {
    xmlNsDispose( &ctx->nsTop );
    if ( !disposeWsMatrix(ctx) )
    	return(0);
    return 1;
}

/**
 * Return if there are still nodes on stack.
 */
#define moreTags(ctx) (ctx->stackPtr>0)

/**
 * Push the pre-value, namespace and nodename of stack
 */
static int pushTag(XqueryCtx* ctx, oid pre, str ns, str name, int empty) {
    ctx->tagStack[ctx->stackPtr].pre    = pre;
    ctx->tagStack[ctx->stackPtr].empty  = empty;
    ctx->tagStack[ctx->stackPtr].nsMark = NULL;
    if (!ssb_alloc(&ctx->tagStack[ctx->stackPtr].ssb_ns,   ns) )
        return 0;
    if (!ssb_alloc(&ctx->tagStack[ctx->stackPtr].ssb_name, name) )
        return 0;;
    ctx->stackPtr++;
    return 1;
}

/**
 * Three function to retrieve the pre-value, namespace or nodename of the
 * top element on the stack.
 */
/* 
 * static INLINE SerializeFrame* topSF(XqueryCtx* ctx) {
 *  return &ctx->tagStack[ctx->stackPtr-1];
 * }
 */

#define topSF(ctx)    (&ctx->tagStack[ctx->stackPtr-1])
#define topNs(ctx)    (topSF(ctx)->ssb_ns.val)
#define topName(ctx)  (topSF(ctx)->ssb_name.val)


/**
 * Pop the top element of the stack. Means that processing the node has
 * finished.
 */
static void popTag(XqueryCtx* ctx) {
    /* de-alloc the ns and name strings */
    ssb_free(&topSF(ctx)->ssb_ns);
    ssb_free(&topSF(ctx)->ssb_name);

    XmlNsFrame *xnf;
    if ( (xnf = topSF(ctx)->nsMark) ) {
        xmlNsPop2(&ctx->nsTop,xnf->prev);
    }
    --ctx->stackPtr;
}

int checkNsChange(XqueryCtx* ctx, str par_uri, str par_prefix, int top) {
    char *uri, *prefix;

    if ( strcmp(par_uri,str_nil) == 0 || *par_uri == 0 )
        uri = NULL;
    else
        uri = par_uri;
    if ( strcmp(par_prefix,str_nil) == 0 || *par_prefix == 0 )
        prefix = NULL;
    else
        prefix = par_prefix;
    if ( uri ) {
        char* currentURI = xmlNsFind(&ctx->nsTop,prefix);

        if ( !(currentURI && (strcmp(currentURI,uri) == 0)) ) {
            /* change of URI for this prefix */
            XmlNsFrame* xnf;

            if ( !(xnf = xmlNsPush(&ctx->nsTop,prefix,uri)) ) {
                fatal_err(ctx,"xmlNsPush: out of memory\n");
                return 0;
            }
            /* generate the xmlns:xxx=uri tag */
    	    if ( 0 && !checkNsChange(ctx,(str)str_nil,(str)"xmlns",top) )
      	        return 0;
            ctx->driverFun->handle_attribute(ctx,(str)str_nil,"xmlns",prefix,uri,top);

            SerializeFrame* sf = topSF(ctx);

            if ( !sf->nsMark ) {
                /* not the first nsFrame in this context */
                sf->nsMark = xnf;
            }
        }
    }
    return 1;
}

/**
 *
 * II. THE OUTPUT HANDLER PART
 *
 * The emit functions are used to encapsulate the Sax-O-Phone event
 * emission functions.
 * The current implementation emits the Sax-O-Phone events as if they are
 * a BAT.
 *
 * TODO: solve characters() newline in string problem.
 *
 */

/**
 * The character translation section responsible for the special
 * character recognition and XML entity characters.  It consists of a
 * small main table 'isspecial_tab' containing the flags for every
 * possible character.
 * v=0: no special char
 * v<3: special char, should be presented as octal char in output
 * v>=3: special char, string repr of char is isspecial_val[v+mode]
 *
 * mode = 0 sax
 * mode = 1 dm/xml
 * mode = 2 dm/xml (mapi)
 */

static unsigned char  isspecial_tab[UCHAR_MAX+1] = { 0 }; /* the main table */
static char*          isspecial_val[32]; /* the values of the special chars */

static void init_isspecial() {
    int i;
    for(i=0; i<32; i++) isspecial_tab[i] = 1; /* means write as octal */
    isspecial_val[0] = "[*ERROR*]"; /* not used */
    isspecial_tab[(int)(unsigned char)'\377'] = 1; /* means write as octal */
    isspecial_val[1] = "[*ERROR*]"; /* not used, 1 = write as octal */
    isspecial_val[2] = "[*ERROR*]"; /* not used, 2 = write as octal */
    isspecial_val[3] = "[*ERROR*]"; /* not used, 3 = write as octal */
    isspecial_tab[(int)'\t'] = 4;
    isspecial_val[4] = "\\t";
    isspecial_val[5] = "\t"; /* don't escape */
    isspecial_val[6] = isspecial_val[5];
    isspecial_tab[(int)'\n'] = 7;
    isspecial_tab[(int)'\r'] = 7;	/* map \r on \n */
    isspecial_val[7] = "\\n";
    isspecial_val[8] = "\n"; /* don't escape */
    isspecial_val[9] = "\n="; /* this is the only diff between mapi and non-mapi */
    isspecial_tab[(int)'\\'] = 10;
    isspecial_val[10] = "\\\\";
    isspecial_val[11] = "\\"; /* don't escape */
    isspecial_val[12] = isspecial_val[11];
    isspecial_tab[(int)'\"'] = 13;
    isspecial_val[13] = "&quot;";
    isspecial_val[14] = isspecial_val[13];
    isspecial_val[15] = isspecial_val[13];
    isspecial_tab[(int)'\''] = 16;
    isspecial_val[16] = "&apos;";
    isspecial_val[17] = isspecial_val[16];
    isspecial_val[18] = isspecial_val[16];
    isspecial_tab[(int)'&'] = 19;
    isspecial_val[19] = "&amp;";
    isspecial_val[20] = isspecial_val[19];
    isspecial_val[21] = isspecial_val[19];
    isspecial_tab[(int)'<'] = 22;
    isspecial_val[22] = "&lt;";
    isspecial_val[23] = isspecial_val[22];
    isspecial_val[24] = isspecial_val[22];
    isspecial_tab[(int)'>'] = 25;
    isspecial_val[25] = "&gt;";
    isspecial_val[26] = isspecial_val[25];
    isspecial_val[27] = isspecial_val[25];
}

/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 */
int emit_escaped(char* src, int mode, int onlyEntity) {
    /* Emit a string with all special character escaped. Inspired by
     * function strToStr() in gdk_atoms.mx
     */
    int start=0,end;
    unsigned char isspecial_ch;

    if (isspecial_tab[0] == 0) /* module not initialized yet */
        init_isspecial();
    for(end = 0; src[end]; end++) {
        if ( (isspecial_ch = isspecial_tab[(int)(unsigned char)src[end]]) ) {
            stream_write(GDKout,&src[start],end-start,1);
            start = end + 1;

            if ( isspecial_ch < 3 ) {
                stream_printf(GDKout,"\\%03o",(unsigned char)src[end]);
            } else {
                char *emit_val = isspecial_val[mode+(int)isspecial_ch];

                /* if ( onlyEntity && (*emit_val!='&') ) */
                if (
                        onlyEntity &&
                        src[end] !='<' &&
                        src[end] !='>' &&
                        src[end] !='&' &&
                        src[end] != '\n'
                   ) {
                    start--; /* char should normally be printed */
                } else {
                    stream_write(GDKout,emit_val,strlen(emit_val),1);
                }
            }
        }
    }
    if ( start < end ) {
        stream_write(GDKout,&src[start],end-start,1);
    }
    return 1;
}

/**
 * Handle the generation of the attributes of the node with oid 'pre'. This
 * function is only called from the xquery_node_print() function.
 */

static int process_attr(XqueryCtx* ctx, int cont, oid id, int top) {
    str val, uri, prefix, loc; 
    oid qn_oid, prop_oid;
    int acont;
    ptr res;

    getWsValue(res, ctx, cont,  ATTR_PROP, id);       prop_oid = *(oid*)      res;
    getWsValue(res, ctx, cont,  ATTR_CONT, id);       acont    = (int)*(oid*) res;
    getWsValue(res, ctx, acont, PROP_VAL,  prop_oid); val      = (str)        res;
    getWsValue(res, ctx, cont,  ATTR_QN,   id);       qn_oid   = *(oid*)      res;
    getWsValue(res, ctx, acont, QN_URI,    qn_oid);   uri      = (str)        res;
    getWsValue(res, ctx, acont, QN_PREFIX, qn_oid);   prefix   = (str)        res;
    getWsValue(res, ctx, acont, QN_LOC,    qn_oid);   loc      = (str)        res;

    
    if ( 0 && !checkNsChange(ctx,uri,prefix,top) )
      return 0;
    return ctx->driverFun->handle_attribute(ctx, uri, prefix, loc, val, top);
}

static int process_node_attr(XqueryCtx* ctx, int nCONT, oid pre, int emptyNode) {
    BAT *b;
    oid nid = oid_nil;
    BUN p, q; 

    getWsBAT(b, ctx,ctx->curCONT,PRE_NID);
    BUNfndVOID(p, b, &pre);
    if ( p ) {
        nid = *(oid*)BUNtail(b,p);
    } else {
        fatal_err(ctx,"process_node_attr: "SZFMT" not within ["SZFMT","SZFMT"]", 
                  (size_t)pre, (size_t)(*(oid*)BUNhead(b,BUNfirst(b))), 
                  (size_t)(*(oid*)BUNhead(b,BUNlast(b)-BUNsize(b))));
        return 0;
    }
    getWsBAT(b, ctx,ctx->curCONT, ATTR_OWN);
    if ( !(b  = BATuselect(b,&nid,&nid)) )
        return fatal_err(ctx,"process_node_attr: uselect fails\n");
    BATloop(b, p, q) {
        oid id = *(oid*)BUNhead(b, p);
        if ( ! process_attr(ctx,nCONT,id,0/*top*/) ) {
            BBPunfix( BBPcacheid( b ) );
            return 0;
        }
    }
    BBPunfix( BBPcacheid( b ) );
    return ctx->driverFun->handle_attributeEnd(ctx,emptyNode);
}

/**
 * Handle the generation of the node with oid 'pre'.
 */
static int xquery_node_print(XqueryCtx* ctx, oid pre, BAT* pre_cont, int top) {
    ptr res;
    chr kind;
    oid prop;

    getWsValue(res,ctx,ctx->curCONT,PRE_KIND,pre);
    kind = *(chr*) res;
    getWsValue(res,ctx,ctx->curCONT,PRE_PROP,pre);
    prop = *(oid*) res;
    int vCONT = ctx->curCONT;
    if ( pre_cont ) {
        findTailValue(res,ctx,pre_cont,pre);
        vCONT = (int)*(oid*)res;
    }
    if (kind == chr_nil) return -1;
    switch( kind ) {
        case (char)0:
            {	/* ELEMENT */
                str uri, prefix, loc;
                getWsValue(res,ctx,vCONT,QN_URI,prop);
                uri   = (str)res;
                getWsValue(res,ctx,vCONT,QN_PREFIX,prop);
                prefix   = (str)res;
                getWsValue(res,ctx,vCONT,QN_LOC,prop);
                loc = (str)res;
                if ( !ctx->driverFun->handle_startElement(ctx,prefix,loc,pre) )
                    return 0;
                getWsValue(res,ctx,ctx->curCONT,PRE_SIZE,pre);
                int size = *(int*)res;
                if (!pushTag(ctx,pre+size,prefix,loc,(size==0)))
                    return 0;
                /* check for change of prefix/uri. 'top' is not
                 * propagated here because an attribute inside an
                 * element can never be top-level.
                 */
                if ( ! checkNsChange(ctx,uri,prefix,0) )
                    return 0;
                if ( !process_node_attr(ctx,ctx->curCONT,pre,(size==0)))
                    return 0;
                break;
            }
        case (char)1:
            {	/* PFTEXT */
        
                getWsValue(res,ctx,vCONT,PROP_TEXT,prop);
                if ( !ctx->driverFun->handle_characters(ctx,(str)res,(top?"text":0)))
                    return 0;
                break;
            }
        case (char)2:
            {	/* COMMENT */
                getWsValue(res,ctx,vCONT,PROP_COM,prop);
                if ( !ctx->driverFun->handle_comment(ctx,(str)res))
                    return 0;
                break;
            }
        case (char)3:
            {	/* PI */
                str target, data;
                getWsValue(res,ctx,vCONT,PROP_TGT,prop);
                target = (str) res;
                getWsValue(res,ctx,vCONT,PROP_INS,prop);
                data = (str) res;
                if (!ctx->driverFun->handle_processingInstruction(ctx,target,data))
                    return 0;
                break;
            }
        case (char)4:
            {	/* DOCUMENT */
                /* The node represents an entire document */
                int offset;
                getWsValue(res,ctx,ctx->curCONT,PRE_SIZE,pre);
                offset = *(int*)res;
                if (!pushTag(ctx,pre+offset,"","",0/*false*/))
                    return 0;
                break;
            }
        default:
            return fatal_err(ctx,"Unknow kind %d IN xquery_node_print", (int)kind);
    }
    return 1;
}

#define ALLTAGS INT_MAX

/**
 * handle the closing tag of a document.
 */
static int xquery_endtag_print(XqueryCtx* ctx, oid pre) {
    while( moreTags(ctx) && ((pre==ALLTAGS)||(pre > topSF(ctx)->pre)) ) { /*?? */
        if ( *topName(ctx) )
            if ( !ctx->driverFun->handle_endElement(ctx,topNs(ctx),topName(ctx),topSF(ctx)->empty))
                return 0;
        popTag(ctx);
    }
    return 1;
}

/**
 * handle the range of pre numbers [from .. to]
 */
static int xquery_pre_range(XqueryCtx* ctx, BAT* b, oid from, oid to) {
    BUN p, q;
    if ( from == 0 ) /* first BUN, because of 1..n/0..n-1 problem */
        p = BUNfirst(b);
    else
        BUNfndOID(p, b, (ptr)(&from));
    for(q = BUNlast(b); p<q; p = BUNnext(b, p)) {
        oid pre = *(oid*)BUNhead(b, p);
        do {
            if ( !xquery_node_print(ctx, pre, 0 /*pre_cont*/, 0 /*false*/))
                return 0;
            if ( !xquery_endtag_print(ctx,++pre) )
                return 0;
        } while( moreTags(ctx) && (pre<to) );
    }
    if ( moreTags(ctx) ) {
        /* INCOMPLETE, the next line works but WHY? Should work without */
        if ( !xquery_endtag_print(ctx,ALLTAGS) )
            return 0;
    }
    return 1;
}

static int MY_xquery_pre_range(XqueryCtx* ctx, oid from, oid to, BAT* pre_cont, int top) {
    oid pre = from;

    if ( ctx->typedMode ){
        stream_printf(GDKout, "<xs:anyNode>\n");
    }

    do {
        if ( !xquery_node_print(ctx, pre,pre_cont,top&&(from==to)) /*cheat*/ ) {
            return 0;
        }
        if ( !xquery_endtag_print(ctx,++pre) ) {
            return 0;
        }
    } while( moreTags(ctx) && (pre<=to) );

    if ( ctx->typedMode ) {
        stream_printf(GDKout,"\n</xs:anyNode>\n");
    }
    return 1;
}

/**
 *
 * X. THE MAIN XML DOCUMENT PRINTING PART
 *
 * Main XML document printing routine
 */

static BAT* wsADMbat(BAT* ws, oid o) {
    BAT* res = NULL;
    BUN b = BUNfnd(ws,&o);

    if ( !b ) {
        fatal_err(0,"wsADMbat: unable to find bat[%d@0] in WS",o);
    
    } else {
        res = BATdescriptor(*(bat*)b);
    }
    return res;
}

static int ws_documentIndex(BAT* ws, str docName) {
    /* INCOMPLETE, updated algorith for the extra CONT_DOCID indirection.
     * but am not really sure if all is ok now. PeterB ?????
     */
    
    BAT* docid_name;
    if ( !(docid_name=wsADMbat(ws,DOCID_NAME)) )
        return fatal_err(0,"ws_documentIndex: unable to find DOCID_NAME in WS");
    if ( 0 ) BATprintf(GDKout,docid_name);

    BAT* cont_docid;
    if ( !(cont_docid=wsADMbat(ws,CONT_DOCID)) )
        return fatal_err(0,"ws_documentIndex: unable to find CONT_DOCID in WS");
    if ( 0 ) BATprintf(GDKout,cont_docid);
   
    /* 
     * BAT* cont_coll;
     * if ( !(cont_coll=wsADMbat(ws,CONT_COLL)) )
     *   return fatal_err(0,"ws_documentIndex: unable to find CONT_COLL in WS");
     * if ( 1 ) BATprintf(GDKout,cont_coll);
     */

    BUN p, q;
    BATloop(docid_name, p, q) {
        str docNm = (str)BUNtail(docid_name, p);

        if ( strcmp(docName,docNm) == 0 ) {
	    int res;
            BUN b;
            oid docId = *(oid*)BUNhead(docid_name, p);
	    BAT* mcd  = BATmirror(cont_docid);

	    if ( (b=BUNfnd(mcd,&docId)) ) {
	       res = *(oid*)BUNtail(mcd,b);
	    } else {
               fatal_err(0,"ws_documentIndex: unable to find %d@0 in CONT_DOCID",docId);
	       res = 0;
	    }
            BBPunfix( BBPcacheid( docid_name ) );
            BBPunfix( BBPcacheid( cont_docid ) );
            return res;
        }
    }
    BBPunfix( BBPcacheid( docid_name ) );
    BBPunfix( BBPcacheid( cont_docid ) );
    return -1;
}

#ifdef SHOW_TIMING

static char *
timer_str (long elapsed)
{
    char *tm, *str;

    tm = str = strdup ("000h 00m 00s 000ms 000us");

    if (elapsed / 3600000000UL) {
        str += sprintf (str, "%03ldh ", elapsed / 3600000000UL);
        elapsed %= 3600000000UL;
    }

    if (elapsed / 60000000UL) {
        str += sprintf (str, "%02ldm ", elapsed / 60000000UL);
        elapsed %= 60000000UL;
    }

    if (elapsed / 1000000UL) {
        str += sprintf (str, "%02lds ", elapsed / 1000000UL);
        elapsed %= 1000000UL;
    }

    if (elapsed / 1000UL) {
        str += sprintf (str, "%03ldms ", elapsed / 1000UL);
        elapsed %= 1000UL;
    }

    str += sprintf (str, "%03ldus", elapsed);

    return tm;
}

#define TIMER_START() \
	struct timeval now; \
	(void) gettimeofday (&now, 0); \
	long start = now.tv_sec * 1000000 + now.tv_usec;
#define TIMER_STOP(T,V) \
	gettimeofday (&now, 0); \
	long stop = now.tv_sec * 1000000 + now.tv_usec; \
	fprintf(stderr,T,V); \
	fprintf(stderr,": %s\n",timer_str (abs (stop - start)));
#else
#define TIMER_START()
#define TIMER_STOP(T,V)
#endif

int xquery_print_doc_DRIVER(
	str			mode, 
	serializeFunStruct*	driverFun,
	char*			driverArg,
	BAT*			ws,
	str			docName
    ) {
    TIMER_START();
    int docIndex = ws_documentIndex(ws,docName);
    BAT *b;
    if ( docIndex < 0 ) {
        GDKwarning("serialize.mx:xquery_print_doc_main: unable to find document \"%s\" in working set!\n",docName);
        return GDK_SUCCEED;
    } 
    if ( 0 ) stream_printf(GDKout,"*** docIndex=%d.\n",docIndex);
    /* */
    XqueryCtx  ctx_struct, *ctx = &ctx_struct;
    if ( !createWsContext(ctx,ws,docIndex,mode,driverFun,driverArg) )
        return GDK_FAIL;
    /* */
    getWsBAT(b,ctx,ctx->curCONT,PRE_SIZE);
    if ( !ctx->driverFun->handle_startDocument(ctx) )
        return GDK_FAIL;
    if ( !xquery_pre_range(ctx,b,0/*start*/,1 /* first is doc ? */) )
        return GDK_FAIL;
    if ( !ctx->driverFun->handle_endDocument(ctx) )
        return GDK_FAIL;
    setDefaultCONT(ctx,-1); /* close all open context BAT's */
    /* */
    if ( !disposeWsContext(ctx) )
        return GDK_FAIL;
    /* */
    TIMER_STOP("# serialization of \"%s\"",docName);
    /* */
    return GDK_SUCCEED;
}

int xquery_print_doc_main(str mode, BAT* ws, str docName) {
    return xquery_print_doc_DRIVER(mode,NULL,NULL,ws,docName);
}


/**
 * XI. THE MAIN PATHFINDER QUERY RESULT PART
 *
 * First the event/emit handlers for the sequnce are defined and after that
 * the main function
 */

/**
 * Emit a NODE element of an XQUERY/Pathfinder result sequence
 */
static int emitNodeInSeq(XqueryCtx* ctx, oid preVal, BAT* pre_cont, int top) {
    ptr res;
    /* incomplete, different for dmMode ?? */
    getWsValue(res,ctx,ctx->curCONT,PRE_SIZE,preVal);
    return MY_xquery_pre_range(ctx,preVal,preVal+*(int*) res, pre_cont, top);
}

/**
 * Main XQUERY/Pathfinder result sequence printing routine. Arguments are
 * mode: "xml" or "sax"
 * ws : the working set
 * max_iter : often 1@0. we can also print multiple iters for soap or debugging
 * item/item/kind : sequence result BATs (iter as a constant bat)
 * intVAL,dblVAL,strVAL : BATSs containing the values of seq elements
 * remainder BATs: conatins the data for the document nodes
 *
 * iter and kind may be 'fake' (i.e. constant) bats and quite often are; item cannot be fake.
 *
 * The function iterates through the item/kind BAT's and retrieves the values
 * from the xxxVAL BATs. Then it calls one of the seqXXXXX() functions
 * defined above to handle the output generation.
 */

#define BATloop_off(b,p,q,w,o,s)\
        for(w=BUNsize(b), p=BUNptr(b,BUNindex(b,BUNfirst(b))+o), q=p+s*w; p<q; p+=w) 

int xquery_print_result_DRIVER(
        str 			mode,
	serializeFunStruct*	driverFun,
	char*			driverArg,
        BAT*			ws,
        size_t			niters,
        BAT*			loop,
        BAT*			iter,
        BAT*			item, 
        BAT*			kind,
        BAT*			intVAL,
        BAT*			dblVAL,
        BAT*			strVAL)
{
    /* { FILE* x=fopen("/tmp/x","w+"); fprintf(x,"HERE-1\n");fclose(x); } */
    TIMER_START();
    size_t xx, yy, curcnt = 0, maxcnt = BATcount(item), buncnt;
    XqueryCtx ctx_struct, *ctx = &ctx_struct;
    if ( !createWsContext(ctx,ws,-1,mode,driverFun,driverArg) )
        return GDK_FAIL;

    /* loop over the iterations (usually only 1) */
    for(yy=0; yy<niters; yy++, curcnt += buncnt, maxcnt -= buncnt) {
        oid it = *(oid*) BUNhead(loop, BUNptr(loop, BUNindex(loop, BUNfirst(loop))+yy));
        BUN p, q;
        ptr res;

        buncnt = maxcnt;
        if (niters > 1) {
            if (IS_FAKE_PROJECT(iter)) {
                if (*(oid*) BUNtail(iter, BUNfirst(iter)) != it) buncnt = 0;
            } else {
                /* in case of a non-constant iter bat, find out how many
                 * items we have in this iteration */
                BATloop_off(iter,p,q,xx,curcnt,maxcnt) 
                    if (*(oid*) BUNtail(iter,p) != it) break;
                buncnt = ((p - BUNfirst(iter)) / xx) - curcnt;
            }
        } 

        if ( !ctx->driverFun->seqStart(ctx, item) )
            return GDK_FAIL;
        if ( !ctx->driverFun->seqDmAttrStart(ctx) )
            return GDK_FAIL;
        if ( ! ctx->dmMode ) {
            /* If the mode is not the DM mode do a scan of all attributes here
             * and generate the appropriate calls to connect them to the
             * head tag of the result document
             */
            BATloop_off(item,p,q,xx,curcnt,buncnt) { 
                oid pre = *(oid*)BUNhead(item, p);
                oid valoid = *(oid*)BUNtail(item, p);
                int cmbn_cont_kind;
                findTailValue(res,ctx,kind,pre);
                cmbn_cont_kind = *(int*)res;

                if ( XTRACT_KIND(cmbn_cont_kind) == ATTR ) {
                    int cont = XTRACT_CONT(cmbn_cont_kind);
                    if ( !process_attr(ctx,cont,valoid,1/* top */) )
                        return GDK_FAIL;
                }
            }
        }
        if ( !ctx->driverFun->seqDmAttrEnd(ctx) )
            return GDK_FAIL;
        /* */
        int cnt = 0; /* loopcounter, used for checking when to print commas. */
        BATloop_off(item,p,q,xx,curcnt,buncnt) {
            oid pre = *(oid*)BUNhead(item, p);
            oid valoid = *(oid*)BUNtail(item, p);
            int cmbn_cont_kind, lastVal = (p + xx < q ) ? 0 : 1;
            findTailValue(res,ctx,kind,pre);
            cmbn_cont_kind = *(int*)res;
	    if ( !ctx->driverFun->seqElementStart(ctx,cnt) )
	    	 return GDK_FAIL;
            switch( XTRACT_KIND(cmbn_cont_kind) ) {
                case ATTR:
                    if ( ctx->dmMode ) {
                        int cont = XTRACT_CONT(cmbn_cont_kind);
                        if ( !process_attr(ctx,cont,valoid,1/* top */) )
                            return GDK_FAIL;
                    }
                    break;
                case ELEM:
                    {
                        int cont = XTRACT_CONT(cmbn_cont_kind);
                        /* if ( ctx->dmMode ),check for first kind text { "t" }
                         * check getWsValue(ctx,cont,PRE_KIND,valoid);
                         * for TEXT
                         */
                        int oldCtx = ctx->curCONT;
			setDefaultCONT(ctx,cont);
                        BAT *b;
                        getWsBAT(b,ctx,ctx->curCONT,PRE_CONT)
                        if ( !emitNodeInSeq(ctx, valoid, b, 1/*top*/) )
                            return GDK_FAIL;
                        setDefaultCONT(ctx,oldCtx);
                        break;
                    };
                case NODE:
                    /* INCOMPLETE, suppose just ignore ?*/
                    break;
                case BOOL:
                    if ( !ctx->driverFun->seqEmitBool(ctx,valoid, lastVal) )
                        return GDK_FAIL;
                    break;
                case DBL:
                case DEC:
                    findTailValue(res,ctx,dblVAL,valoid);
                    if (!ctx->driverFun->seqEmitDbl(ctx,*(dbl*)res, lastVal) )
                        return GDK_FAIL; /* INCOMPLETE ?diff between d and e */
                    break;
                case INT:
                    findTailValue(res,ctx,intVAL,valoid);
                    if ( !ctx->driverFun->seqEmitInt(ctx,*(lng*)res, lastVal) )
                        return GDK_FAIL;
                    break;
                case STR:
                case U_A:
                    findTailValue(res,ctx,strVAL,valoid);
                    if ( !ctx->driverFun->seqEmitStr(ctx,(str)res, lastVal) )
                        return GDK_FAIL;
                    break;
                default:
                    GDKerror("serialize.mx:xquery_print_result_main: [kind=%d, cont=%d]\n",
                            XTRACT_KIND(cmbn_cont_kind),XTRACT_CONT(cmbn_cont_kind));
                    fatal_err(ctx,"UNKNOW_TYPE(\'%c\'ch(%d))\n",cmbn_cont_kind,cmbn_cont_kind);
                    return GDK_FAIL;
            }
	    if ( !ctx->driverFun->seqElementEnd(ctx,cnt) )
	    	 return GDK_FAIL;
            cnt++;
        }
        /* */
        if ( !ctx->driverFun->seqEnd(ctx) )
            return GDK_FAIL;
    } 
    setDefaultCONT(ctx,-1);
    TIMER_STOP("# serialization of result%s","");
    return disposeWsContext(ctx)?GDK_SUCCEED:GDK_FAIL;
}

int xquery_print_result_loop(
        str  mode,
        BAT* ws,
        BAT* loop, 
        BAT* iter, 
        BAT* item, 
        BAT* kind,
        BAT* intVAL,
        BAT* dblVAL,
        BAT* strVAL)
{
    size_t niters = BATcount(loop);
    return xquery_print_result_DRIVER(mode, NULL, NULL, ws, niters?niters:1, loop, iter, item, kind, intVAL, dblVAL, strVAL);
}

int xquery_print_result_main(
        str  mode,
        BAT* ws,
        BAT* item, 
        BAT* kind,
        BAT* intVAL,
        BAT* dblVAL,
        BAT* decVAL,
        BAT* strVAL)
{
    (void) decVAL;
    return xquery_print_result_DRIVER(mode, NULL, NULL, ws, 1, item, item, item, kind, intVAL, dblVAL, strVAL);
}
