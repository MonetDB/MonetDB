@ Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' the Database Group at the Technische Universitaet Muenchen, Germany.
@' It is now maintained by the Database Systems Group at the Eberhard
@' Karls Universitaet Tuebingen, Germany.  Portions created by the
@' University of Konstanz, the Technische Universitaet Muenchen, and the
@' Universitaet Tuebingen are Copyright (C) 2000-2005 University of
@' Konstanz, (C) 2005-2008 Technische Universitaet Muenchen, and (C)
@' 2008-2009 Eberhard Karls Universitaet Tuebingen, respectively.  All
@' Rights Reserved.
@'
@' $Id$
@'

@f xrpc_client
@a Ying Zhang

@t MIL primitives of XRPC client

@* Introduction
This module provides new MIL primitives for the client side support of
remote XQuery execution using HTTP connection on top of MonetDB for
the "AmbientDB" project.
@
@* Module Definition
@m
.MODULE xrpc_client;

@- HTTP client function(s)
@m

.USE lock;

.COMMAND http_post(
        str genType,
        str mode,
        str qid,
        str xrpc_hostport,
        bit firstCaller,
        lng seqnr,
        lng timeout,
        str dst,
        str module,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng itercnt,
        BAT[void, bat] ws,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[str, bat] = CMDhttp_post;
"Create and send a RPC request message to the specified destination"

.COMMAND get_rpc_res ( 
        oid cont, 
        BAT[void, bat] ws, 
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values, 
        BAT[void, str] str_values) : BAT[void, bat] = CMDget_rpc_res;
"Retrieve values from the response message and return as a iter|item|kind bat"

.COMMAND xrpc_commit(str qid, str mode, BAT[void,str] participants) : void = CMDxrpc_2pc_commit;
"coordinate a 2pc commit"

.END xrpc_client;

@mil

PROC doLoopLiftedRPC(
        str modname,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng niters,
        BAT[void, BAT] ws,
        BAT[oid,  str] dsts,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[void,bat]
{
    var unq_dsts := dsts.tunique().hmark(0@0);
    var steps := unq_dsts.count();
    var rpcerr_lock := lock_create(); # guards rpc_errors
    var rpc_errors := ""; # holds errors from each destination
    var rpcres_lock := lock_create(); # guards rpc_results and rpc_iter
    var rpc_results := bat(str,bat);
    var rpc_iter := bat(void,bat).seqbase(0@0);
    var off := count(ws.fetch(CONT_NAME));

    # unlock the working set while making the calls (enables circular patterns nested 2PC xrpc calls)
    var wslock;
    if (xrpc_qid != "") {  
        lock_set(xrpc_lock);
        var err := CATCH(wslock := xrpc_locks.fetch(reverse(xrpc_qids).find(xrpc_qid)));
        lock_unset(xrpc_lock);
        if (not(isnil(err))) ERROR(err);
        lock_unset(wslock);
    }
    unq_dsts @ [steps] batloop(){
        var time_xrpcClntSeria := usec();

        # get iteration numbers for this destination
        var iter_dst := [oid](rpc_dsts.ord_uselect($t).reverse());
            iter_dst := iter_dst.reverse().mirror();
        var itercnt := iter_dst.count().lng();

        # retrieve the frag of fun_vid, fun_iter, fun_item and fun_kind
        # for this iteration.

        # order of 'fun_iter' needs to be preserved, so use 'leftjoin',
        # iso. 'join'.
        var fun_iter_dst := fun_iter.leftjoin(iter_dst);
        var indices      := fun_iter_dst.hmark(0@0);
        var fun_vid_dst  := indices.leftfetchjoin(fun_vid);
        var fun_item_dst := indices.leftfetchjoin(fun_item);
        var fun_kind_dst := indices.leftfetchjoin(fun_kind);

        # renumber the iters, starting from 1
        fun_iter_dst := fun_iter_dst.leftjoin(iter_dst.mark(1@0));
        fun_iter_dst := [oid](fun_iter_dst.tmark(0@0));

        time_xrpcClntSeria := usec() - time_xrpcClntSeria;
        if (genType.search("timing") >= 0) {
            printf("XRPC_Client_Serialisation (get_dst_params):   %lld microsec\n",
                    time_xrpcClntSeria);
        }

        var local_name := "rpc_res_00" + str(int($h)+off);
        var rpc_res, timeout := max(0LL,xrpc_timeout - ((usec() - time_start)/1000));
        var rpc_err := CATCH(rpc_res := http_post(genType, xrpc_mode, xrpc_qid,
                    xrpc_hostport, (xrpc_caller = ""),
                    xrpc_seqnr, timeout, $t, modname, location, method,
                    updCall, arity, itercnt, ws, fun_vid_dst, fun_iter_dst, fun_item_dst,
                    fun_kind_dst, int_values, dbl_values, dec_values, str_values));

        var time_xrpcClntDeSeria := usec();

        if (isnil(rpc_err)) {
            lock_set(rpcres_lock);
            rpc_results.insert(local_name,rpc_res);
            rpc_iter.append(iter_dst.hmark(0@0));
            lock_unset(rpcres_lock);

            time_xrpcClntDeSeria := usec() - time_xrpcClntDeSeria;
            if (genType.search("timing") >= 0) {
                printf("XRPC_Client_DeSerialisation (insert_rpc_res): %lld microsec\n",
                        time_xrpcClntDeSeria);
            }
        } else {
            printf("doLoopLiftedRPC: error occurred at %s:\n%s\n", $t, rpc_err);
            # A none-isolation XRPC query: we do not want to discard
            # results from other destinations where executions might
            # have succeeded, so we only print a message by error,
            # iso. terminate the execution with 'ERROR'
            lock_set(rpcerr_lock);
            CATCH({ rpc_errors := rpc_errors + $t + ": " + rpc_err + "\n"; });
            lock_unset(rpcerr_lock);
        }
    }
    if (xrpc_qid != "") lock_set(wslock);
    lock_destroy(rpcres_lock);
    lock_destroy(rpcerr_lock);

    var time_xrpcClntDeSeria := usec();

    var res_iter := bat(void,oid).seqbase(0@0);
    var res_item := bat(void,oid).seqbase(0@0);
    var res_kind := bat(void,int).seqbase(0@0);
    var res_bats := bat(void,bat,4).seqbase(0@0);

    if(count(rpc_results) = 0) {
        ERROR("doLoopLiftedRPC: execution failed at all destinations:\n%s\n", rpc_errors);
    } else if(rpc_errors != "") {
        ERROR("doLoopLiftedRPC: execution failed at some destinations:\n%s\n", rpc_errors);
    }

    # retrieve results for this destination, and map the results back to
    # the original iteration number
    var proc_res := [get_rpc_res](
            [ws_opencoll](const ws, rpc_results.tmark(0@0), rpc_results.hmark(0@0), TEMP_DOC),
            const ws, const int_values, const dbl_values, const str_values);

    res_iter := bat(void,bat).seqbase(0@0); 
                proc_res.[fetch](0)@batloop() res_iter.append($t.leftfetchjoin(rpc_iter.find($h)));
    res_item := proc_res.[fetch](1);
    res_kind := proc_res.[fetch](2);

    # initialize res_bat with the results for the first destination
    res_bats.append(res_iter.fetch(0));
    res_bats.append(res_item.fetch(0));
    res_bats.append(res_kind.fetch(0));

    # if there were more destinations, merge the result tables 
    var i := 0;
    while ((i :+= 1) < steps) {
        # initialize res_bat with the results for the first destination 
        res_bats := merged_union(res_bats.fetch(0), res_iter.fetch(i), 
                                 res_bats.fetch(1), res_item.fetch(i), 
                                 res_bats.fetch(2), res_kind.fetch(i));
    }

    time_xrpcClntDeSeria := usec() - time_xrpcClntDeSeria;
    if (genType.search("timing") >= 0) {
        printf("XRPC_Client_DeSerialisation (get_rpc_res):    %lld microsec\n",
                time_xrpcClntDeSeria);
    }
    return res_bats;
}
ADDHELP("doLoopLiftedRPC", "zhang", "April 2006",
"DESCRIPTION: implementation of the loop-lifted RPC",
"xrpc_client");

PROC doIterativeRPC(
        str modname,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng niters,
        BAT[void,BAT] ws,
        BAT[oid, str] dsts,
        BAT[void,oid] fun_vid,
        BAT[void,oid] fun_iter,
        BAT[void,oid] fun_item,
        BAT[void,int] fun_kind,
        BAT[void,lng] int_values,
        BAT[void,dbl] dbl_values,
        BAT[void,dbl] dec_values,
        BAT[void,str] str_values) : BAT[void,bat]
{
    # unlock the working set while making the calls (enables circular patterns nested 2PC xrpc calls)
    var wslock;
    if (xrpc_qid != "") {  
        lock_set(xrpc_lock);
        var err := CATCH(wslock := xrpc_locks.fetch(reverse(xrpc_qids).find(xrpc_qid)));
        lock_unset(xrpc_lock);
        if (not(isnil(err))) ERROR(err);
    }

    var time_xrpcClntSeria := 0;
    var time_xrpcClntDeSeria := 0;

    var res_bats := nil;
    var h := 0;
    var t := 1;
    while (lng(h) < niters){
        # get function parameters for this destination
        var time_xrpcClntSeriaStart := usec();
        var dst := dsts.fetch(h);
        var cur_fun_iter := fun_iter.select(oid(t));
        var cur_fun_vid  := fun_vid.fetch(cur_fun_iter.mirror()).tmark(0@0);
        var cur_fun_item := fun_item.fetch(cur_fun_iter.mirror()).tmark(0@0);
        var cur_fun_kind := fun_kind.fetch(cur_fun_iter.mirror()).tmark(0@0);
        # renumber cur_fun_iter, we only have one iteration
        cur_fun_iter := cur_fun_iter.tmark(0@0).project(1@0);
        time_xrpcClntSeria := time_xrpcClntSeria + (usec() - time_xrpcClntSeriaStart);

        var local_name := "rpc_res_00" + str(h+1);
        if (xrpc_qid != "") lock_unset(wslock);
        var rpc_res, timeout := max(0LL,xrpc_timeout - ((usec() - time_start)/1000));
        var rpc_err := CATCH(rpc_res := http_post(genType, xrpc_mode, xrpc_qid, xrpc_hostport, (xrpc_caller = ""), 
                    xrpc_seqnr, timeout, dst, modname, location, method,
                    updCall, arity, lng(1), ws, cur_fun_vid, cur_fun_iter, cur_fun_item,
                    cur_fun_kind, int_values, dbl_values, dec_values, str_values));
        if (xrpc_qid != "") lock_set(wslock);


        # add result of this iteration to result BATs
        var time_xrpcClntDeSeriaStart := usec();
        if (isnil(rpc_err)) {
            var rpc_oid := ws_opencoll(ws, rpc_res, local_name, TEMP_DOC);
            var res := get_rpc_res(rpc_oid, ws, int_values, dbl_values, str_values);
            if (isnil(res_bats)){
                res_bats := res;
            } else {
                # merge results of this iteration into existing results.
                res_bats := merged_union(res_bats.fetch(0), res.fetch(0), 
                                         res_bats.fetch(1), res.fetch(1), 
                                         res_bats.fetch(2), res.fetch(2));
            }
        } else {
            # We do not want to discard results from other destinations
            # where executions might have succeeded, so we only print a
            # WARNING by error, iso. terminate the execution with 'ERROR'
            printf("!WARNING: doIterativeRPC: ");
            printf("error occurred during RPC call to \"%s\".\n", dst);
            printf("!WARNING: Received error was: \n%s\n", rpc_err);
        }
        h := h + 1;
        t := t + 1;

        time_xrpcClntDeSeria := time_xrpcClntDeSeria + (usec() - time_xrpcClntDeSeriaStart);
    }

    var time_xrpcClntDeSeriaStart := usec();
    time_xrpcClntDeSeria := time_xrpcClntDeSeria + (usec() - time_xrpcClntDeSeriaStart);

    if (genType.search("timing") >= 0) {
        printf("XRPC_Client_Serialisation (get_dst_params):   %lld microsec\n",
                time_xrpcClntSeria);
        printf("Client_DeSerialisation (get_rpc_res):        %lld msec\n",
                time_xrpcClntDeSeria);
    }

    if(isnil(res_bats)) {
        ERROR("doIterativeRPC: execution of all iterations failed");
    }

    return res_bats;
}
ADDHELP("doIterativeRPC", "zhang", "April 2006",
"DESCRIPTION: make a separate RPC call for ever iteration",
"xrpc_client");

PROC doRPC(
        str modname,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng niters,
        BAT[void, BAT] ws,
        BAT[oid,  str] dsts,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[void,bat]
{
    if (search(xrpc_mode,"iterative") >= 0) 
        return doIterativeRPC(modname, location, method, updCall, arity, niters,
                              ws, dsts, fun_vid, fun_iter, fun_item, fun_kind, int_values, dbl_values, dec_values, str_values);
    else
        return doLoopLiftedRPC(modname, location, method, updCall, arity, niters,
                               ws, dsts, fun_vid, fun_iter, fun_item, fun_kind, int_values, dbl_values, dec_values, str_values);
}


@h
#ifndef XRPC_CLIENT_H
#define XRPC_CLIENT_H

#define MAX_BUF_SIZE            (1024*1024)
#define NR_RETRIES              3

#endif /* XRPC_CLIENT_H */

@c
#include "pf_config.h"
#include <gdk.h>
#include <stream_socket.h>
#ifdef _WIN32   /* Windows specific */
    #include <winsock.h>
    #define snprintf _snprintf
    #ifndef __MINGW32__
        #pragma comment(lib, "ws2_32")
    #endif
#else           /* UNIX specific */
    #include <sys/select.h>
    #include <sys/types.h>  /* used by socket */
    #include <sys/socket.h>
    #include <unistd.h>     /* gethostname() */
    #include <netinet/in.h> /* hton and ntoh */
    #include <arpa/inet.h>  /* dotted IP addr to and from 32-bits int */
    #include <netdb.h>      /* gethostbyname() */
    #include <ctype.h>
#endif
#include "pathfinder.h"
#include "pf_support.h"
#include "shredder.h"
#include "serialize.h"
#include "xrpc_common.h"
#include "xrpc_client.h"

int 
CMDget_rpc_res(BAT **res, 
        oid *cont, 
        BAT *ws, 
        BAT *int_values,
        BAT *dbl_values, 
        BAT *str_values) 
{
    lng ok = GDK_FAIL;
    oid i, j, it;
    char err[4098];
    BATiter wi = bat_iterator(ws);
    BAT *participants = BATdescriptor(*(bat*) BUNtail(wi, XRPC_PARTICIPANTS));

    if (participants) {
        BAT *shredBAT = BATnew(TYPE_void, TYPE_bat, BATTINY);
        if (shredBAT) {
            XRPCreq_t *req;
            /* create a list of all main document bats (as parse_message likes it that way) */
            for(i=0; i <= ATTR_PROP; i++) {
                BAT *b = BATdescriptor(*(bat*) BUNtail(wi, i));
                if (b) {
                    BATiter bi = bat_iterator(b);
                    BUNappend(shredBAT, BUNtail(bi, *cont), FALSE);
                    BBPunfix(b->batCacheid);
                }
            }
            err[0] = '\0';
            req = xrpc_parse_message(err, 4098, shredBAT, participants);
            if (req) { 
                BAT *res_iter = BATnew(TYPE_void, TYPE_oid, req->nr_args);
                if (res_iter) {
                    BAT *res_item = BATnew(TYPE_void, TYPE_oid, req->nr_args);
                    if (res_item) {
                        BAT *res_kind = BATnew(TYPE_void, TYPE_int, req->nr_args);
                        if (res_kind) {
                            *res = BATnew(TYPE_void, TYPE_bat, 3);
                            if (*res) {
                                lng *argcnt = req->argcnt[0];
                                char *err = NULL;
                                BUNappend(*res, &res_iter->batCacheid, FALSE);
                                BUNappend(*res, &res_item->batCacheid, FALSE);
                                BUNappend(*res, &res_kind->batCacheid, FALSE);
                                BATseqbase(res_iter, 0);
                                BATseqbase(res_item, 0);
                                BATseqbase(res_kind, 0);
                                BATseqbase(*res, 0);
       
                                /* get all values fro all result sequences one by one */ 
                                for(it=i=j=0; i<req->nr_args; i++,j++) {
                                    char* err = xquery_parse_val(req->argtpe[i], req->argval[i], res_item, res_kind,
                                                                 int_values, dbl_values, str_values, NULL, *cont);
                                    if (err) break;

                                    /* set the correct iteration number */
                                    while (j == (unsigned) argcnt[it]) { 
                                        j=0; it++; 
                                    }
                                    BUNappend(res_iter, &it, FALSE);
                                }
                                if (err) GDKerror(err); 
                                else ok = GDK_SUCCEED;
                            }
                            BBPunfix(res_kind->batCacheid);
                        }  
                        BBPunfix(res_item->batCacheid);
                    }
                    BBPunfix(res_iter->batCacheid);
                }
                XRPCreq_free(req);
            } else {
                GDKerror(err);
            }
            BBPreclaim(shredBAT);
        }
        BBPunfix(participants->batCacheid);
    }
    return ok;
}


static buffer *
clean_up(stream *bs, lng **argcnt, lng iterc)
{
    lng i = 0;
    if(bs){
        buffer_destroy(stream_get_buffer(bs));
        stream_close(bs); stream_destroy(bs);
    }
    if(argcnt) {
        for(i = 0; i < iterc; i++) GDKfree(argcnt[i]);
        GDKfree(argcnt);
    }
    return NULL;
}

static void
handle_error_msg(char *errmsg)
{
    char *strptr, *strptr2;

    strptr = strstr(errmsg, "<env:Value");
    if(!strptr) {
        GDKerror(errmsg);
        return;
    }
    strptr = strchr(strptr, '>'); assert(strptr);
    strptr2 = strstr(++strptr, "</env:Value>");
    if( (!strptr) || (!strptr2) ) {
        GDKerror("handle_error_msg: SOAP Fault message not "
                 "well-formed at \"<env:Value>.\n%s\n", errmsg);
        return;
    }
    strptr2[0] = '\0';
    GDKerror("SOAP Fault Code  : %s\n", strptr);
    strptr2[0] = '<';

    strptr = strstr(strptr2+12, "<env:Text");
    if(!strptr) {
        GDKerror("handle_error_msg: SOAP Fault message not "
                 "well-formed: could not find \"<env:Text\".\n%s\n",
                 errmsg);
        return;
    }
    strptr = strchr(strptr, '>') + 1;
    strptr2 = strstr(strptr, "</env:Text>");
    if( (!strptr) || (!strptr2) ) {
        GDKerror("handle_error_msg: SOAP Fault message not "
                 "well-formed at \"<env:Text>\".\n%s\n", errmsg);
        return;
    }
    strptr2[0] = '\0';
    GDKerror("SOAP Fault Reason:\n%s\n", strptr);
}

/* Create a HTTP client socket.
 *
 * Returns: a socket number if succeeded, -1 otherwise.
 */
static int
setup_connection(str dst, int *port)
{
    struct in_addr      addr;
    struct sockaddr_in  sockaddr;
    struct hostent     *resolv = NULL;
    int i, ret, sock = -1, p = 0;
    str strptr = NULL;
   
    /* remove whitespace characters at the beginning and the end of the
     * string */
    while(dst[0] == ' '  || dst[0] == '\t' ||
          dst[0] == '\r' || dst[0] == '\n')
        dst++;
    i = strlen(dst) -1;
    while(dst[i] == ' '  || dst[i] == '\t' ||
          dst[i] == '\r' || dst[i] == '\n')
        i--;
    dst[i + 1] = '\0';

    strptr = strstr(dst, "://");
    if (strptr) strptr += 3; 
    else strptr = dst;

    /* 'dst' has the form 'URL[:port]' */
    if ((strptr = strchr(strptr, (int)':')) != NULL) {
        strptr[0] = '\0'; strptr++;
        p = strtol(strptr, (char **)NULL, 10);
        if (p <= 0) {
            GDKerror("setup_connection: invalid port number: %s\n", strptr);
            return -1;
        }
    } else { /* find the default port number from "monet_environment" */
        if( !(strptr = GDKgetenv("xrpc_port")) || !(*strptr) ){
            if( !(strptr = GDKgetenv("mapi_port")) ){
                GDKerror("setup_connection: could not find \"mapi_port\"\n");
                return -1;
            }
            p = atoi(strptr) + 1; 
        } else {
            p = atoi(strptr);
        }
    }

    if (isdigit((int)dst[0])) {
        if ((i = inet_addr(dst)) < 0) {
            GDKerror("setup_connection: invalid IP address \"%s\"\n", dst);
            return -1;
        }
        addr.s_addr = (unsigned) i;
    } else {
        if (!(resolv = gethostbyname(dst))) {
            GDKerror("setup_connection: invalid IP address \"%s\"\n", dst);
            return -1;
        }
        addr.s_addr = ((struct in_addr *)resolv->h_addr_list[0])->s_addr;
    }

    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port   = htons(p);
    sockaddr.sin_addr.s_addr = addr.s_addr;
    memset(&(sockaddr.sin_zero), '\0', 8);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        GDKerror("setup_connection: failed to create socket\n");
        return -1;
    }

    ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    for (i = NR_RETRIES; i > 0 && ret < 0; i--) {
        MT_sleep_ms(1);
        ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    }

    if (ret < 0) {
        GDKerror("setup_connection: failed to setup connection with %s:%d\n", dst, p);
        close(sock);
        return -1;
    }

    *port = p;
    return sock;
}

/**
 * contID < 0 indicates ws[batID] is a simple BAT, i.e., a BAT without a
 * BAT tail.
 *
 * @return ws[batID] or ws[batID][contID] or NULL on error
 */
static BAT *
getBatFromContainer(BAT *ws, int batID, int contID)
{
    BAT *b = NULL, *batbat = NULL;
    BUN bun = BUN_NONE, bbun = BUN_NONE;
    oid CONTid = (oid)contID, BATid  = (oid)batID;
    BATiter wsi, batbati;

    assert(ws && batID >= 0);

    wsi = bat_iterator(ws);
    BUNfndOID(bun, wsi, (ptr)&BATid);
    if(bun == BUN_NONE) {
        GDKerror("getBatFromContainer: BAT ws[%d] not found\n",batID);
        return NULL;
    }
    if( !(batbat = BATdescriptor(*(bat*)Tloc(ws,bun))) ) {
        GDKerror("getBatFromContainer: failed to fetch BAT ws[%d]\n", batID);
        return NULL;
    }

    if(contID < 0) return batbat; /* this is a simple BAT, just return it */

    batbati = bat_iterator(batbat);
    BUNfndOID(bbun, batbati, (ptr)&CONTid);
    if(bbun == BUN_NONE) {
        BBPunfix(BBPcacheid(batbat));
        GDKerror("getBatFromContainer: BAT ws[%d][%d] not found\n", batID, contID);
        return NULL;
    }
    if( !(b = BATdescriptor(*(bat*)Tloc(batbat,bbun))) ) {
        BBPunfix(BBPcacheid(batbat));
        GDKerror("getBatFromContainer: failed to fetch BAT ws[%d][%d]\n", batID, contID);
        return NULL;
    }

    BBPunfix(BBPcacheid(batbat));
    return b;
}

/**
 * Find the 'pre_kind' value of 'item_index'-th BUN of the PRE_KIND BAT
 * of the container 'contID' from the working set.
 *
 * @param ws The whole working set.
 * @param contID container ID.
 * @param item_index BUN index in the PRE_KIND BAT.
 * @return the 'pre_kind' value, or
 *         GDK_chr_min by error
 */
static chr
getELEMkind(BAT *ws, int contID, oid item_index)
{
    BATiter bi;
    BAT *b  = NULL;
    BUN bun = BUN_NONE;
    chr ret;

    if(!(b = getBatFromContainer(ws, PRE_KIND, contID)))
        return GDK_chr_min;

    if (!b->batCount){
        GDKerror("getELEMkind: %s BAT is empty.\n",
                b?BBP_logical(b->batCacheid):"NULL");
        return GDK_chr_min;
    }
    bi.b = b;
    BUNfndVOID(bun, bi, &item_index);
    if (bun == BUN_NONE){
        GDKerror("%s BAT does not contain value " OIDFMT
                 " in its head column.\n",
                 b?BBP_logical(b->batCacheid):"NULL", item_index);
        return GDK_chr_min;
    }

    ret = *(chr*)BUNtail(bi,bun);
    BBPunfix( BBPcacheid(b));
    return ret;
}

/**
 * try to receive the response message and shred it into shredBAT
 * Returns shredBAT, or
 *         NULL on error
 */
static BAT *
response2bat(
        bool timing,
        stream *in,
        char *host,
        int port,
        bool updCall)
{
    char respStatus[1024];
    int ret;
    buffer *resp;
    BAT *shredBAT;
    (void) updCall;

    /* Create buffer for the RPC response message */
    resp = buffer_create(MAX_BUF_SIZE);
    if (!resp || resp->len == 0) {
        GDKerror("response2bat: failed to create buffer for XRPC response message\n");
        if (resp)
            buffer_destroy(resp);
        return NULL;
    }

    if( !(ret = stream_readline(in, respStatus, 1024)) ){
        GDKerror("response2bat: failed to receive response from %s:%d", host, port);
        buffer_destroy(resp);
        return NULL;
    }

    /* We only speak HTTP/1.1 */
    if( ret < 13 || /* we should have at least "HTTP/1.1 nnn ", 13 chars */
        /* FIXME: could use strncmp here */
        strstr(respStatus, "HTTP/1.1 ") != respStatus ||
        respStatus[12] != ' ' ||
        respStatus[ret -2] != '\r' ) {
        GDKerror("response2bat: invalid response from \"%s:%d\":\n", host, port);
        do{ /* read and print everything we can receive */
            if(respStatus[ret-2] == '\r')
                respStatus[ret -2] = '\0'; /* overwrite '\r' */
            GDKerror("%s\n", respStatus);
            ret = stream_readline(in, respStatus, 1024);
        } while (ret > 0);
        buffer_destroy(resp);
        return NULL;
    }
    respStatus[ret -2] = '\0';

    do{ /* read the HTTP header and throw it away */
        ret = stream_readline(in, resp->buf, 1024);
        if(ret == 2 && resp->buf[0] == '\r')
            ret = 0; /* end-of-HTTP-header found */
    } while (ret > 0);
    if (ret < 0) {
        GDKerror("response2bat: failed to receive response from %s:%d", host, port);
        buffer_destroy(resp);
        return NULL;
    }

    /* Now, we can check the response status */
    if(respStatus[9] != '2' || respStatus[10] != '0' || respStatus[11] != '0') {
        GDKerror("HTTP Error Code  : %s\n", respStatus+9);

        resp->pos = 0;
        do{ /* read the SOAP Fault message */
            ret = stream_read(in, (resp->buf + resp->pos), 1, (resp->len - resp->pos));
            if (ret > 0) resp->pos += ret;
        } while (ret > 0);
        if (ret < 0) {
            GDKerror("response2bat: failed to receive response from %s:%d", host, port);
            return NULL;
        }
        resp->buf[resp->pos] = 0;
        handle_error_msg(resp->buf);
        buffer_destroy(resp);
        return NULL;
    }

    /* Start timing Client DeSerialisation */
    lng time_xrpcClntDeSeria = GDKusec();
    if (!(shredBAT = BATnew(TYPE_str, TYPE_bat, 32))){
        GDKerror("response2bat: failed to malloc shredBAT\n");
        buffer_destroy(resp);
        return NULL;
    }

    if(shred(shredBAT, NULL, NULL, in, 0, NULL, NULL, NULL) ==GDK_FAIL) {
        GDKerror("response2bat: invalid XRPC response received\n");
        BBPreclaim(shredBAT);
        buffer_destroy(resp);
        return NULL;
    }
    /* Stop timing Client DeSerialisation */
    time_xrpcClntDeSeria = GDKusec() - time_xrpcClntDeSeria;
    if (timing) {
        stream_printf(GDKout,
                "XRPC_Client_DeSerialisation (response2bat):   " LLFMT " microsec\n",
                time_xrpcClntDeSeria);
    }

    return shredBAT;
}

static buffer *
byvalue_request(
        bool timing,
        str genType,
        str rpc_mode,
        str qid,
        str xrpc_hostport,
        bool firstCaller,
        lng seqnr,
        lng timeout,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        bool updCall,
        lng arity,
        lng iterc,
        BAT *ws,
        BAT *fun_vid,
        BAT *fun_iter,
        BAT *fun_item,
        BAT *fun_kind,
        BAT *int_values,
        BAT *dbl_values,
        BAT *dec_values,
        BAT *str_values)
{
    BATiter fun_itemi = bat_iterator(fun_item), fun_kindi = bat_iterator(fun_kind);
    int ret = -1;
    buffer *b = NULL;
    stream *bs = NULL;
    /* Hold the temp BATs after the RPC response has been shredded: */
    /* Might be NULL if the oid tail of a fun_* BAT is dense */
    oid *fvid_lst = NULL, *fiter_lst = NULL, *fitem_lst = NULL;
    oid fvid_seqbase = 0, fiter_seqbase = 0, fitem_seqbase = 0;
    int *fkind_lst = NULL;
    lng *intVals = NULL;
    dbl *dblVals = NULL;
    oid cnt = oid_nil;
    /* BATs hold item|kind of a node parameter */
    BAT *node_item = NULL, *node_kind = NULL;

    (void) genType;

    lng i, a, arg_offset = 0;
    lng my_argc = 0, my_iter = 0;
    lng **argcnt = NULL; /* #items each [iter][param] contains */

    /* BATs needed for serializing attributes */
    BAT *attr_qn = NULL, *attr_prop = NULL;
    BAT *qn_prefix = NULL, *qn_loc = NULL, *prop_val = NULL;
    BATiter strValsi;

    (void) dec_values;

    /* Start timing Client Serialisation */
    lng time_xrpcClntSeria = GDKusec();

    fvid_lst  = (oid*) Tloc(fun_vid, BUNfirst(fun_vid));
    fiter_lst = (oid*) Tloc(fun_iter, BUNfirst(fun_iter));
    fitem_lst = (oid*) Tloc(fun_item, BUNfirst(fun_item));
    fkind_lst = (int*) Tloc(fun_kind, BUNfirst(fun_kind));
    intVals   = (lng*) Tloc(int_values, BUNfirst(int_values));
    dblVals   = (dbl*) Tloc(dbl_values, BUNfirst(dbl_values));
    strValsi  = bat_iterator(str_values);
    fvid_seqbase = fun_vid->hseqbase;
    fiter_seqbase = fun_iter->hseqbase;
    fitem_seqbase = fun_item->hseqbase;
    
    /* Create buffer for the RPC request message */
    if((b = buffer_create(MAX_BUF_SIZE)) && b->len > 0) {
        if (!(bs = buffer_wastream(b, "xrpcrequest"))) {
            GDKerror("byvalue_request: failed to create buffer_wastream\n");
            buffer_destroy(b);
            return NULL;
        }
    } else {
        GDKerror("byvalue_request: failed to create outgoing buffer\n");
        if (b)
            buffer_destroy(b);
        return NULL;
    }

    if (!(argcnt = GDKmalloc(iterc * sizeof(lng*)))) {
        GDKerror("byvalue_request: failed to malloc argcnt\n");
        return clean_up(bs, argcnt, iterc);
    }
    for (i = 0; i < iterc; i++) {
        /* we allocate at least _one_ argcnt for each parameter, so that
         * we have a place to note that a function has zero parameter */
        if (!(argcnt[i] = GDKmalloc((arity>0?arity:1) * sizeof(lng)))) {
            GDKerror("byvalue_request: failed to malloc argcnt[" LLFMT "]\n", i);
            return clean_up(bs, argcnt, iterc);
        }
        argcnt[i][0] = 0;
        for (a = 1; a < arity; a++) {
            argcnt[i][a] = 0;
        }
    }

    /* Calculate the number of values contained by every parameter of
     * every iteration. */
    i = a = 0; /* i: iter counter; a: arg counter */
    for (cnt = 0; cnt < BATcount(fun_vid); cnt++){
        i = fiter_lst ? fiter_lst[cnt] : cnt + fiter_seqbase;
        a = fvid_lst ? fvid_lst[cnt] : cnt + fvid_seqbase;
        argcnt[i-1][a]++;
    }

    /* soap env header and xrpc request header */
    ret = stream_printf(bs, SOAP_ENVELOPE);
    if (ret < 0) 
        return clean_up(bs, argcnt, iterc);

    if(qid && *qid) { /* an XRPC query that requires 2PC */
        ret = stream_printf(bs, "<env:Header>" XRPC_WS_QID "</env:Header>" , qid, timeout, rpc_mode);
        if (ret < 0) 
            return clean_up(bs, argcnt, iterc);
    }

    if(firstCaller) {
        ret = stream_printf(bs, XRPC_REQ_BODY_FIRST_CALLER,
                rpc_module, rpc_uri, rpc_method, arity, iterc,
                updCall?"true":"false");
    } else {
        ret = stream_printf(bs, XRPC_REQ_BODY, rpc_module, rpc_uri,
                rpc_method, arity, iterc, updCall?"true":"false",
                xrpc_hostport, seqnr);
    }
    if (ret < 0) 
        return clean_up(bs, argcnt, iterc);

    for (my_iter = 0; my_iter < iterc; my_iter++) {
        if (arity == 0) {
            ret = stream_write(bs, "<xrpc:call/>", 1, 12);
            if (ret != 12) return clean_up(bs, argcnt, iterc);
            continue;
        }

        ret = stream_write(bs, "<xrpc:call>", 1, 11); /* start an iteration */
        if (ret != 11) return clean_up(bs, argcnt, iterc);
        for (my_argc = 0; my_argc < arity; my_argc++) {
            if (argcnt[my_iter][my_argc] == 0) {
                ret = stream_write(bs, "<xrpc:sequence/>", 1, 16);
                if (ret != 16) return clean_up(bs, argcnt, iterc);
                continue;
            }
            arg_offset = 0;
            /* add the 'argcnt' of all arg-s before 'me': */
            for (a = 0; a < my_argc; a++) {
                for (i = 0; i < iterc; i++)
                    arg_offset += argcnt[i][a];
            }
            /* add the 'argcnt' of iter-s before 'me': */
            for (i = 0; i < my_iter; i++) {
                arg_offset += argcnt[i][my_argc];
            }
            /* now 'arg_offset' contains the start position of the
             * values of my_iter and my_argc in the fun_* BATs */

            ret = stream_write(bs, "<xrpc:sequence>", 1, 15); /* start a parameter */
            if (ret != 15) return clean_up(bs, argcnt, iterc);
            int k;
            chr elem_kind = 0;
            oid item = 0;
            int cmbn_cont_kind = 0, cur_kind = 0, contID = 0;
            for (k= 0; k < argcnt[my_iter][my_argc]; k++) {

                a = arg_offset + k; /* index into fun_item|fun_kind */
                item = fitem_lst ? fitem_lst[a] : a + fitem_seqbase;
                cmbn_cont_kind = fkind_lst[a];
                cur_kind = XTRACT_KIND(cmbn_cont_kind);
                contID = XTRACT_CONT(cmbn_cont_kind);

                switch (cur_kind) {
                    case BOOL:
                        ret = stream_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:boolean\">%s</xrpc:atomic-value>",
                                intVals[item] == TRUE ? "true" : "false");
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    case INT:
                        ret = stream_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:integer\">%lld</xrpc:atomic-value>",
                                intVals[item]);
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    case DEC:
                        ret = stream_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:decimal\">%f</xrpc:atomic-value>",
                                dblVals[item]);
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    case DBL:
                        ret = stream_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:double\">%f</xrpc:atomic-value>",
                                dblVals[item]);
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    case STR:
                    case U_A:
                        ret = stream_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:string\">%s</xrpc:atomic-value>",
                                (char*)BUNtail(strValsi, item));
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    case ATTR:
                    {
                        contID = XTRACT_CONT(cmbn_cont_kind);

                        attr_qn   = getBatFromContainer(ws, ATTR_QN, contID);
                        attr_prop = getBatFromContainer(ws, ATTR_PROP, contID);
                        prop_val  = getBatFromContainer(ws, PROP_VAL, contID);
                        qn_prefix = getBatFromContainer(ws, QN_PREFIX, contID);
                        qn_loc    = getBatFromContainer(ws, QN_LOC, contID);
                        if( (!attr_qn) || (!attr_prop) || (!prop_val) ||
                            (!qn_prefix) || (!qn_loc) ){
                            return clean_up(bs, argcnt, iterc);
                        }

                        BATiter attr_qni = bat_iterator(attr_qn);
                        BATiter qn_prefixi = bat_iterator(qn_prefix);
                        BATiter qn_loci = bat_iterator(qn_loc);
                        BATiter attr_propi = bat_iterator(attr_prop);
                        BATiter prop_vali = bat_iterator(prop_val);
                        
                        i = *(oid*)BUNtail(fun_itemi, a);
                        a = *(oid*)BUNtail(attr_qni, i);
                        char *prefix = (char*)BUNtail(qn_prefixi, a);
                        char *loc    = (char*)BUNtail(qn_loci,    a);
                        a = *(oid*)BUNtail(attr_propi, i);
                        char *attr_val = (char*)BUNtail(prop_vali, a);

                        ret = stream_write(bs, "<xrpc:attribute ", 1, 16);
                        if (ret != 16) return clean_up(bs, argcnt, iterc);
                        if (prefix && *prefix){
                            ret = stream_printf(bs, "%s:", prefix);
                            if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        }
                        ret = stream_printf(bs, "%s=\"%s\"/>", loc, attr_val);
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    }
                    case ELEM:
                    {
                        contID = XTRACT_CONT(cmbn_cont_kind);
                        elem_kind = getELEMkind(ws, contID, item);
                        if (elem_kind == GDK_chr_min) {
                            return clean_up(bs, argcnt, iterc);
                        }
                        switch(elem_kind) {
                            case 0: ret = stream_write(bs, "<xrpc:element>", 1, 14);
                                    if (ret != 14) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 1: ret = stream_write(bs, "<xrpc:text>", 1, 11);
                                    if (ret != 11) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 2: ret = stream_write(bs, "<xrpc:comment>", 1, 14);
                                    if (ret != 14) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 3: ret = stream_write(bs, "<xrpc:processing-instruction>", 1, 29);
                                    if (ret != 29) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 4: ret = stream_write(bs, "<xrpc:document>", 1, 15);
                                    if (ret != 15) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 5: /* COLLECTION: nothing to be done, here */   break;
                            default:
                                GDKerror("byvalue_request: call%d/sequence%d/item%d has "
                                        "invalid type %d\n", my_iter, my_argc, i);
                                return clean_up(bs, argcnt, iterc);
                        }
                        /* print body of the node */
                        node_item = BUNins( BATnew(TYPE_void, TYPE_oid, 1),
                                            BUNhead(fun_itemi, a),
                                            BUNtail(fun_itemi, a), FALSE );
                        node_kind = BUNins( BATnew(TYPE_void, TYPE_int, 1),
                                            BUNhead(fun_kindi, a),
                                            BUNtail(fun_kindi, a), FALSE );
                        xquery_print_result_driver( bs, "xml-noheader-noroot",
                                NULL, NULL, ws, 1,
                                node_item, node_item, node_item, node_kind,
                                int_values, dbl_values, str_values,
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

                        if(BBPreclaim(node_item) == -1){
                            GDKerror("byvalue_request: failed to destroy BAT \"node_item\", "
                                    "because it is in use by other process!");
                            GDKerror("THIS SHOULD NEVER HAPPEN!!!");
                            return clean_up(bs, argcnt, iterc);
                        }

                        if(BBPreclaim(node_kind) == -1){
                            GDKerror("byvalue_request: failed to destroy BAT \"node_item\", "
                                    "because it is in use by other process!");
                            GDKerror("THIS SHOULD NEVER HAPPEN!!!");
                            return clean_up(bs, argcnt, iterc);
                        }

                        switch(elem_kind) {
                            case 0: ret = stream_write(bs, "</xrpc:element>", 1, 15);
                                    if (ret != 15) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 1: ret = stream_write(bs, "</xrpc:text>", 1, 12);
                                    if (ret != 12) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 2: ret = stream_write(bs, "</xrpc:comment>", 1, 15);
                                    if (ret != 15) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 3: ret = stream_write(bs, "</xrpc:processing-instruction>", 1, 30);
                                    if (ret != 30) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 4: ret = stream_write(bs, "</xrpc:document>", 1, 16);
                                    if (ret != 16) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 5: /* COLLECTION: nothing to be done, here */    break;
                            default:
                                GDKerror("byvalue_request: should have never reached here!");
                                return clean_up(bs, argcnt, iterc);
                        }
                    }   break;
                    default:
                        GDKerror("byvalue_request: call%d/sequence%d/item%d has invalid type %d\n",
                                my_iter, my_argc, i);
                        return clean_up(bs, argcnt, iterc);
                }
            }
            ret = stream_write(bs, "</xrpc:sequence>", 1, 16);
            if (ret != 16) return clean_up(bs, argcnt, iterc);
        }
        ret = stream_write(bs, "</xrpc:call>", 1, 12);
        if (ret != 12) return clean_up(bs, argcnt, iterc);
    }
    ret = stream_write(bs, "</xrpc:request></env:Body></env:Envelope>\n", 1, 42);
    if (ret != 42) return clean_up(bs, argcnt, iterc);
    /* Stop timing Client Serialisation */
    time_xrpcClntSeria = GDKusec() - time_xrpcClntSeria;
    if (timing) {
        stream_printf(GDKout,
                "XRPC_Client_Serialisation (create_req_msg):   " LLFMT " microsec\n",
                time_xrpcClntSeria);
    }

    return stream_get_buffer(bs);
}

int
CMDhttp_post(
        BAT **res,
        str genType,
        str rpc_mode,
        str qid,
        str xrpc_hostport,
        bool *firstCaller,
        lng *seqnr,
        lng *timeout,
        str dst,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        bool *updCall,
        lng *arity,
        lng *itercnt,
        BAT *ws,
        BAT *fun_vid,
        BAT *fun_iter,
        BAT *fun_item,
        BAT *fun_kind,
        BAT *int_values,
        BAT *dbl_values,
        BAT *dec_values,
        BAT *str_values)
{
    int sock = -1, port = -1;
    stream *in = NULL, *out = NULL;
    buffer *req = NULL;
    size_t bytes_sent = 0;
    BAT *shredBAT = NULL;
    bool timing = (genType && strstr(genType, "timing")) ? TRUE : FALSE;

    ERRORcheck((*itercnt) < 0, "CMDhttp_post: itercnt must not be negative (<0).\n");
    ERRORcheck((*arity) < 0, "CMDhttp_post: arity must not be negative (<0).\n");
    ERRORcheck(!BAThdense(ws), "CMDhttp_post: head of 'ws' must be dense.\n");
    ERRORcheck(!BAThdense(fun_vid), "CMDhttp_post: head of 'fun_vid' must be dense.\n");
    ERRORcheck(!BAThdense(fun_iter), "CMDhttp_post: head of 'fun_iter' must be dense.\n");
    ERRORcheck(!BAThdense(fun_item), "CMDhttp_post: head of 'fun_item' must be dense.\n");
    ERRORcheck(!BAThdense(fun_kind), "CMDhttp_post: head of 'fun_kind' must be dense.\n");
    ERRORcheck(!BAThdense(int_values), "CMDhttp_post: head of 'int_values' must be dense.\n");
    ERRORcheck(!BAThdense(dbl_values), "CMDhttp_post: head of 'dbl_values' must be dense.\n");
    ERRORcheck(!BAThdense(dec_values), "CMDhttp_post: head of 'dec_values' must be dense.\n");
    ERRORcheck(!BAThdense(str_values), "CMDhttp_post: head of 'str_values' must be dense.\n");

    if ((sock = setup_connection(dst, &port)) < 0)
        return GDK_FAIL;
    if (!(out = socket_wastream(sock, "http_send"))) {
        GDKerror("do_simple_query: failed to create socket_wastream for sending XRPC request\n");
        close(sock);
        return GDK_FAIL;
    }

    if(!(req = byvalue_request(timing, genType, rpc_mode, qid, xrpc_hostport, *firstCaller, *seqnr, *timeout, rpc_module, rpc_uri, rpc_method,
                    *updCall, *arity, *itercnt, ws, fun_vid, fun_iter,
                    fun_item, fun_kind, int_values, dbl_values,
                    dec_values, str_values))){
        stream_close(out); stream_destroy(out);
        return GDK_FAIL;
    }
    req->buf[req->pos] = '\0';

    /* Start timing Network Send Client2Server */
    lng time_xrpcClnt2Serv = GDKusec();
    bytes_sent = stream_printf(out,
            "POST %s HTTP/1.1\r\n"
            "Host: %s:%d\r\n"
            "Accept: text/html, text/xml, application/soap+xml\r\n"
            "Accept-Language: en-uk en-us\r\n"
            "Content-Type: text/html; charset=\"utf-8\"\r\n"
            "Content-Length: " SZFMT "\r\n\r\n"
            "%s",
            XRPC_REQ_CALLBACK, dst, port, req->pos, req->buf);
    if (bytes_sent < req->pos) {
        GDKerror("do_simple_query: failed to send XRPC request.");
        stream_close(out); stream_destroy(out);
        buffer_destroy(req);
        close(sock);
        return GDK_FAIL;
    }
    /* Stop timing Network Send Client2Server */
    time_xrpcClnt2Serv= GDKusec() - time_xrpcClnt2Serv;
    if (timing) {
        stream_printf(GDKout,
                "XRPC_Network_Client_2_Server:  " LLFMT " microsec\n"
                "XRPC_Data_Sent:                " SZFMT " bytes\n\n",
                time_xrpcClnt2Serv,
                bytes_sent);
    }

    if( !(in = socket_rastream(sock, "http_receive")) ){
        GDKerror("do_simple_query: failed to create socket_rastream\n");
        return GDK_FAIL;
    }
    shredBAT = response2bat(timing, in, dst, port, *updCall);

    stream_close(out); stream_destroy(out);
    stream_close(in); stream_destroy(in);
    buffer_destroy(req);

    if(!shredBAT) return GDK_FAIL;
    *res = shredBAT;
    return GDK_SUCCEED;
}



/* send a WSAT request */
static int
xrpc_2pc_send(int sock, char* dst, int port, str msg) { 
    stream *out = NULL;
    
    if (!(out = socket_wastream(sock, "http_send"))) {
        GDKerror("xrpc_2pc_commit: failed to create socket_wastream for sending XRPC request\n");
        return GDK_FAIL;
    }
    if (stream_printf(out,
            "POST %s HTTP/1.1\r\n"
            "Host: %s:%d\r\n"
            "Accept: text/html, text/xml, application/soap+xml\r\n"
            "Accept-Language: en-uk en-us\r\n"
            "Content-Type: text/html; charset=\"utf-8\"\r\n"
            "Content-Length: " SZFMT "\r\n\r\n"
            XRPC_WSAT_CALLBACK, dst, port, strlen(msg), msg) < 0) 
    {
        GDKerror("xrpc_2pc_commit: failed to send XRPC request header.");
        return GDK_FAIL;
    }
    if (stream_write(out, msg, 1, strlen(msg)) < 0) {
        GDKerror("xrpc_2pc_commit: failed to send XRPC request.");
        return GDK_FAIL;
    }
    stream_close(out);
    stream_destroy(out);
    return GDK_SUCCEED;
}

/* get a WSAT response */
static int
xrpc_2pc_recv(int sock, char* dst, int port, str msg) { 
    stream *in = NULL;
    BAT* shredBAT;
    int ret = GDK_FAIL;

    if( !(in = socket_rastream(sock, "http_receive")) ){
        GDKerror("do_simple_query: failed to create socket_rastream\n");
        return GDK_FAIL;
    }
    shredBAT = response2bat(0, in, dst, port, 0);
    if (shredBAT) {
        BATiter si = bat_iterator(shredBAT);
        BAT *qn_uri_loc = BATdescriptor(*(bat*) BUNtail(si, QN_URI_LOC));
        if (qn_uri_loc) {
            if (BUNfnd(qn_uri_loc, msg)) ret = GDK_SUCCEED;
            BBPunfix(qn_uri_loc->batCacheid);
        }
    }
    BBPreclaim(shredBAT);
    stream_close(in);
    stream_destroy(in);
    return ret;
}
    
int
CMDxrpc_2pc_commit(str qid, str mode, lng* xrpc_timeout, lng* time_start, BAT* participants) {
    int i, j, ret=GDK_FAIL, cnt=0, npart = BATcount(participants);
    str *part = (str*) alloca(npart*sizeof(npart));
    int *port = (int*) alloca(npart*sizeof(int));
    int *sock = (int*) alloca(npart*sizeof(int)), xrpc_updating;
    char dst[1024], msg[1024], *r; 
    BATiter pi = bat_iterator(participants);
    BUN p,q;
  
    /* get all URIs of peers that performed updates */ 
    BATloop(participants, p, q) {
        str s = (str) BUNtail(pi, p); 
        if (sscanf(s, "%[^','],%[^','],%[^','],%s,%d", 
                   msg, dst, msg, msg, &xrpc_updating) != 5 
            || (r=strrchr(dst,':')) == NULL) 
        {
            GDKerror("draw_queryflow: sscanf failed");
            goto cleanup;
        }
        if (xrpc_updating == 1) { /* a request that did updates */
            *r = 0;
            for(i=0; i<cnt; i++) 
                if (strcmp(part[i],dst) == 0) break;

            if (i == cnt) { /* not already in the list? */
                char* p = strchr(part[i] = GDKstrdup(dst), ':');
                port[i] = 80;
                if (p) { *p = 0; port[i] = atoi(p+1); }
                if ((sock[i] = setup_connection(part[i], port+i)) < 0) goto cleanup;
                cnt++;
            }
        }
    }

    /* create Prepare and Commit SOAP messages */
    snprintf(msg, 1024, XRPC_WSAT_REQ, mode, qid, *xrpc_timeout - (GDKusec() - *time_start), "Prepare");
    for(i=0; i<cnt; i++) 
       if (xrpc_2pc_send(sock[i], part[i], port[i], msg) == GDK_FAIL) break;
    for(j=0; j<i; j++) 
       if (xrpc_2pc_recv(sock[j], part[j], port[j], WSAT_NS"|Prepared") == GDK_FAIL) break;

    if (j == cnt) ret = GDK_SUCCEED;
    snprintf(msg, 1024, XRPC_WSAT_REQ, mode, qid, *xrpc_timeout - (GDKusec() - *time_start), (ret == GDK_SUCCEED) ? "Commit" : "Abort");
    for(j=0; j<cnt; j++) 
       if (xrpc_2pc_send(sock[j], part[j], port[j], msg) == GDK_FAIL) ret = GDK_FAIL;
    for(i=0; i<j; i++) 
       if (xrpc_2pc_recv(sock[i], part[i], port[i], WSAT_NS"|Committed") == GDK_FAIL) ret = GDK_FAIL;
cleanup:
    for(i=0; i<cnt; i++) {
        if (part[i]) GDKfree(part[i]);
        if (sock[i] >= 0) close(sock[i]);
    }
    return ret;
}
/* vim:set shiftwidth=4 expandtab: */
