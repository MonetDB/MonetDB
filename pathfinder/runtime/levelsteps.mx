@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2006 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$

@f levelsteps
@a Henning Rode
@t levelsteps

@c

/*******************************************
* levelsteps.c : axis step operators based on level table
*
*/
#include "pf_config.h"
#include <gdk.h>
#include "pathfinder.h"

/**
 * This file contains all axis step algoritms that work mainly on the
 * level table:
 *
 * - child step
 * - parent step
 * - following-sibling
 * - preceding-sibling
 * 
 * All 4 algorithms use basically the same approach:
 * 
 * - evaluation is done during a single sequential scan of the
 *   level table and the context set
 * - for every context node an exact defined region is scanned for
 *   nodes that qualify a certain level condition (to be parents, 
 *   childs or siblings) 
 * - for context nodes on descendant/ancestor axis a stack is used
 *   to avoid interruption of sequential scanning
 *
 * All 4 algorithms need the presence of the complete level table.
 * hence, this axis steps do not represent joins on 2 independent sets,
 * as in case of the staircase join.  
 */

/* CHILD STEP */
@:lev_head(child)@
@:lev_specialcases@
@:lev_init_forward( + 1)@
@:lev_main( + 1,TRUE,++,+=,<=)@
@:lev_end_forward@

/* FOLLOWING-SIBLING STEP */
@:lev_head(fs)@
@:lev_specialcases@
@:lev_init_forward()@
@:lev_main(,level[level_cur] != search_level,++,+=,<=)@
@:lev_end_forward@

/* PARENT STEP */
@:lev_head(parent)@
@:lev_specialcases@
@:lev_init_reverse( - 1)@
@:lev_main_par@
@:lev_end_reverse@

/* PRECEDING-SIBLING STEP */
@:lev_head(ps)@
@:lev_specialcases@
@:lev_init_reverse()@
@:lev_main(,level[level_cur] != search_level,--,-=,>=)@
@:lev_end_reverse@
@-

PARAMETERS: function name
@= lev_head
int
PFlev_@1 (BAT **result, BAT *pre_level, BAT *ctx, int *upperbound)
{
    /* --------------------------- declaration ----------------------------- */

    char *name = "PFlev_@1";
    int ctx_bunsize, stack_top;
    BUN ctx_cur, ctx_last;
    oid ctx_next_pre, level_cur, level_last, *res_cur;
    chr search_level, *level, *stack;

    /* result bat allocation. for result size use upperbound parameter */
    BAT *res = BATnew(TYPE_oid, TYPE_void, *upperbound);

@= lev_specialcases
    /* --------------------------- special cases --------------------------- */
    if (!(BAThordered(ctx) & 1))
    {
        GDKerror("%s: context must be ordered on head.\n", name);
        return GDK_FAIL;
    }
    if (BATcount(ctx) == 0 || BATcount(pre_level) == 0)
    {
        *result = BATnew (TYPE_oid, TYPE_void, 0);
        return GDK_SUCCEED;
    }
    if (res == NULL) 
    { 
        GDKerror("%s: could not allocate a result BAT of size %d.\n", name, *upperbound);
        return GDK_FAIL;
    }
@-
PARAMETERS: search level 
@= lev_init_forward
    /* ----------------- initialization of table cursors ------------------- */

    ctx_bunsize = BUNsize(ctx);

    ctx_cur = BUNfirst(ctx);
    ctx_last = BUNlast(ctx) - ctx_bunsize;
    ctx_next_pre = *(oid*) BUNhead(ctx, ctx_cur);

    res_cur = (oid*)BUNfirst(res);

    level_cur = ctx_next_pre;
    level_last = pre_level->hseqbase + BATcount(pre_level) -1;

    /* definition for "array-like" access on level values of given nodes */
    level = ((chr*) BUNfirst(pre_level)) - pre_level->hseqbase;

    /* for the child step search level is the level of the context node + 1 */
    search_level = level[level_cur]@1;

    /* stack for context set nodes will never grow over height of doc. tree */
    stack = GDKmalloc(sizeof(chr) * XML_DEPTH_MAX);
    stack_top = 0;

    ALGODEBUG
        THRprintf(GDKout, "%s: node set of %u buns, context set of %u buns\n",
                          name, BATcount(pre_level), BATcount(ctx));

    level_cur++;
    while (level[level_cur] == chr_nil && (int)level_cur <= (int)level_last)
        level_cur++;
    ctx_cur += ctx_bunsize;
@-
PARAMETERS: search level 
@= lev_init_reverse
    /* ----------------- initialization of table cursors ------------------- */

    ctx_bunsize = BUNsize(ctx);

    /* reverse processing of context nodes and level table */
    ctx_cur = BUNlast(ctx) - ctx_bunsize;
    ctx_last = BUNfirst(ctx);
    ctx_next_pre = *(oid*) BUNhead(ctx, ctx_cur);

    /* for reverse insert */
    res->batBuns->free = (*upperbound) * BUNsize(res);
    BATsetcount(res, (*upperbound));
    res_cur = (oid*)BUNlast(res); res_cur--;

    level_cur = ctx_next_pre;
    level_last = pre_level->hseqbase;

    /* definition for "array-like" access on level values of given nodes */
    level = ((chr*) BUNfirst(pre_level)) - pre_level->hseqbase;

    /* for the parent step search level is the level of the context node - 1 */
    search_level = level[level_cur]@1;

    /* stack for context set nodes will never grow over height of doc. tree */
    stack = GDKmalloc(sizeof(chr) * XML_DEPTH_MAX);
    stack_top = 0;

    ALGODEBUG
        THRprintf(GDKout, "%s: node set of %u buns, context set of %u buns\n",
                          name, BATcount(pre_level), BATcount(ctx));

    level_cur--;
    while (level[level_cur] == chr_nil && (int)level_cur >= (int)level_last)
        level_cur--;
    ctx_cur -= ctx_bunsize;
@-
PARAMETERS: search level, stack condition, forward res/level cursor, forward ctx cursor, outer loop end 
@= lev_main
    /* ---------------------------- main part ----------------------------- 
     * - the outer loop traverses all context nodes
     * - the inner loop traverses the defined search region of the current
     *   context node
     *
     * search region: if we select a context node v in a complete level table, 
     * the first node w following v in ascending preorder with 
     *                         level(w) <= level(v)
     * indicates the end of the descendants of v. 
     * within this block we collect all nodes y with 
     *                       level(y) = search-level(v). 
     */

outer_loop:
    while (ctx_cur @5 ctx_last)
    {
        ctx_next_pre = *(oid*) BUNhead(ctx, ctx_cur);

        /* check all descendants of current context node 
         */
        while (level[level_cur] >= search_level)
        { 
            /* copy to result
             */
            if (level[level_cur] == search_level)
                *res_cur@3 = level_cur;

            if (level_cur == ctx_next_pre) 
            { 
                if (@2)
                {
                    stack[stack_top++] = search_level;
                    search_level = level[level_cur]@1;
                }   
                ctx_cur @4 ctx_bunsize;
                level_cur@3;
                while (level[level_cur] == chr_nil && (int)level_cur @5 (int)level_last)
                    level_cur@3;
                goto outer_loop;
            }
            level_cur@3;
            while (level[level_cur] == chr_nil && (int)level_cur @5 (int)level_last)
                level_cur@3;
        }

        if (stack_top > 0)
            search_level = stack[--stack_top];
        else 
        {
            level_cur = ctx_next_pre;
            search_level = level[level_cur]@1;
            level_cur@3;
            while (level[level_cur] == chr_nil && (int)level_cur @5 (int)level_last)
                level_cur@3;
            ctx_cur @4 ctx_bunsize;
        }
    }   

    /* now we still have to handle the last context node
     * and those context nodes still living on stack
     */

    while (TRUE)
    {
        /* check search-region of current context node 
         */
        while ((int)level_cur @5 (int)level_last && level[level_cur] >= search_level)
        { 
            /* copy to result
             */
            if (level[level_cur] == search_level)
                *res_cur@3 = level_cur;
            level_cur@3;
            while (level[level_cur] == chr_nil && (int)level_cur @5 (int)level_last)
                level_cur@3;
        }  
        if (stack_top > 0)
            search_level = stack[--stack_top];
        else
            break;
    }   
@-

PARAMETERS: search level, stack condition, forward res/level cursor, forward ctx cursor, outer loop end 
@= lev_main_par
    /* ---------------------------- main part ----------------------------- 
     * - the outer loop traverses all context nodes
     * - the inner loop traverses the defined search region of the current
     *   context node
     *
     * search region: if we select a context node v in a complete level table, 
     * the first node w following v in ascending preorder with 
     *                         level(w) <= level(v)
     * indicates the end of the descendants of v. 
     * within this block we collect all nodes y with 
     *                       level(y) = search-level(v). 
     */

    /* filter out document nodes because they have no parents */
    while (search_level == -2 && ctx_cur >= ctx_last) 
    {
        ctx_cur -= ctx_bunsize;
        level_cur = *(oid*) BUNhead(ctx, ctx_cur);
        search_level = level[level_cur] - 1;
    } 
           
outer_loop:
    while (ctx_cur >= ctx_last)
    {
        ctx_next_pre = *(oid*) BUNhead(ctx, ctx_cur);

        /* check all descendants of current context node 
         */
        while (level[level_cur] > search_level)
        { 
            if (level_cur == ctx_next_pre) 
            { 
                if (level[level_cur] - 1 != search_level)
                {
                    stack[stack_top++] = search_level;
                    search_level = level[level_cur] - 1;
                }   
                ctx_cur -= ctx_bunsize;
                level_cur--;
                while (level[level_cur] == chr_nil && (int)level_cur >= (int)level_last)
                    level_cur--;
                goto outer_loop;
            }
            level_cur--;
            while (level[level_cur] == chr_nil && (int)level_cur >= (int)level_last)
                level_cur--;
        }

	/* copy to result */
	*res_cur-- = level_cur;

        if (stack_top > 0)
            search_level = stack[--stack_top];
        else 
        {
            level_cur = ctx_next_pre;
            search_level = level[level_cur] - 1;
            
            /* filter out document nodes because they have no parents */
            while (search_level == -2 && ctx_cur >= ctx_last) 
            {
                ctx_cur -= ctx_bunsize;
                level_cur = *(oid*) BUNhead(ctx, ctx_cur);
                search_level = level[level_cur] - 1;
            } 
            
            level_cur--;
            while (level[level_cur] == chr_nil && (int)level_cur >= (int)level_last)
                level_cur--;
            ctx_cur -= ctx_bunsize;
        }
    }   

    /* now we still have to handle the last context node
     * and those context nodes still living on stack
     */

    while (search_level != -2)
    {
        /* check search-region of current context node 
         */
        while ((int)level_cur >= (int)level_last && level[level_cur] > search_level) {
            level_cur--;
            while (level[level_cur] == chr_nil && (int)level_cur >= (int)level_last)
                level_cur--;
        }
	
	/* copy to result */
	*res_cur-- = level_cur;
        
	if (stack_top > 0)
            search_level = stack[--stack_top];
        else
            break;
    }   
@-

@= lev_end_forward
    /* ------------------------------ end part -----------------------------
     * tidy up and propagate result properties
     */

    GDKfree(stack);

    /* mark the end point of the BUNs section in the BUNheap 
     */
    res->batBuns->free = ((BUN)res_cur) - res->batBuns->base;
    BATsetcount(res, res->batBuns->free/BUNsize(res));
    
    res->batDirty = TRUE;
    res->hsorted = GDK_SORTED;
    BATkey(res, TRUE);
    BATseqbase(BATmirror(res), oid_nil);
    *result = res;

    return GDK_SUCCEED;
}

@= lev_end_reverse
    /* ------------------------------ end part -----------------------------
     * tidy up and propagate result properties
     */

    GDKfree(stack);

    /* set the real starting point of the inserted BUNs;
     * here, we use a feature of the BATdescriptor that has been
     * introduced for delta- (i.e., insertion- & deletion-) management:
     * the "real" BUNs section doesn't start at b->batBuns->base,
     * but only at b->batFirst
     */
    res->batDeleted = res->batInserted = res->batFirst = (ptr)(res_cur+1);
    BATsetcount(res, (res->batBuns->free+Bunbase(res)-BUNfirst(res))/BUNsize(res));

    res->batDirty = TRUE;
    res->hsorted = GDK_SORTED;
    BATkey(res, TRUE);
    BATseqbase(BATmirror(res), oid_nil);
    *result = res;

    return GDK_SUCCEED;
}
@c
/* vim:set shiftwidth=4 expandtab: */
