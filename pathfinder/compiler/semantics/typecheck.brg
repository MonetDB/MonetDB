%{

/**
 * @file
 *
 * Type check XQuery Core tree.
 *
 * This phase attaches static type information to the XQuery Core
 * tree and checks for correct typedness.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2008 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 *
 * $Id$
 */ 

/* always include pathfinder.h first! */
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "oops.h"
#include "core.h"
#include "qname.h"
/* #include "mem.h" */

/* PFvar_t */
#include "variable.h"

#include "subtyping.h"

/* Easily access subtree-parts */
#include "child_mnemonic.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFcnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/core.h!
 */
%term var                =  1 /**< variable */
%term lit_str            =  2 /**< string literal */
%term lit_int            =  3 /**< integer literal */
%term lit_dec            =  4 /**< decimal literal */
%term lit_dbl            =  5 /**< double literal */
%term nil                =  6 /**< end-of-sequence marker */

%term seq                =  7 /**< sequence construction */
%term twig_seq           =  8 /**< sequence construction within twigs */
%term ordered            =  9
%term unordered          = 10

%term flwr               = 14 /**< flwr expression */
%term let                = 15 /**< let expression */
%term letbind            = 16 /**< binding part of a let expression */
%term for_               = 17 /**< for expression */
%term forbind            = 18 /**< binding part of a for expression */
%term forvars            = 19 /**< variable pair (var + pos. var) of a for */

%term orderby            = 20 /**< orderby clause */
%term orderspecs         = 21 /**< list of order specs */

%term apply              = 22 /**< function application */
%term arg                = 23 /**< function argument (list) */

%term typesw             = 25 /**< typeswitch clause */
%term cases              = 26 /**< case concatenation for typeswitch */
%term case_              = 27 /**< single case for typeswitch */
%term default_           = 28 /**< default branch in typeswitch */
%term seqtype            = 29 /**< a SequenceType */
%term seqcast            = 30 /**< cast along <: */
%term proof              = 31 /**< typechecker only: prove <: relationship */
%term subty              = 32 /**< subtype condition for proof() */
%term stattype           = 33 /**< static type of expression. Required for
                                fs:convert-operand. Will be removed during
                                typechecking and replaced by seqtype, as
                                soon as types are known. */

%term if_                = 34 /**< if-then-else conditional */
%term then_else          = 35 /**< then- and else-branches of an
                                if-then-else conditional */

%term locsteps           = 40 /**< path of location steps only */

  /* XPath axes */
%term ancestor           = 41 /**< the parent, the parent's parent,... */
%term ancestor_or_self   = 42 /**< the parent, the parent's parent,... + self */
%term attribute          = 43 /**< attributes of the context node */
%term child              = 44 /**< children of the context node */
%term descendant         = 45 /**< children, children's children,... + self */
%term descendant_or_self = 46 /**< children, children's children,... */
%term following          = 47 /**< nodes after current node (document order) */
%term following_sibling  = 48 /**< all following nodes with same parent */
%term parent             = 49 /**< parent node (exactly one or none) */
%term preceding          = 50 /**< nodes before context node (document order) */
%term preceding_sibling  = 51 /**< all preceding nodes with same parent */
%term self               = 52 /**< the context node itself */
/* [STANDOFF] */
%term select_narrow      = 100 /**< regions contained in a context-node */
%term select_wide        = 101 /**< regions overlapping a context-node */
%term reject_narrow      = 102 /**< all regions except the contained regions */
%term reject_wide        = 103 /**< all regions except the overlapping regions */
/* [/STANDOFF] */

  /* Constructor Nodes */
%term elem               = 55 /**< the element constructor */
%term attr               = 56 /**< the attribute constructor */
%term text               = 57 /**< the text constructor */
%term doc                = 58 /**< the document constructor */
%term comment            = 59 /**< the comment constructor */
%term pi                 = 60 /**< the processing-instruction constructor */
%term tag                = 61 /**< the tagname for elem. and attr. constr. */

%term true_              = 65 /**< built-in function `fn:true ()' */
%term false_             = 66 /**< built-in function `fn:false ()' */
%term empty              = 67 /**< built-in function `empty' */

%term main               = 68 /**< tree root.
                                   Separates function declarations from
                                   the query body. */
%term fun_decls          = 69 /**< list of function declarations */
%term fun_decl           = 70 /**< function declaration */
%term params             = 71 /**< function declaration parameter list */
%term param              = 72 /**< function declaration parameter */
%term cast               = 73 /**< function declaration parameter */

  /* Pathfinder extension: recursion */
%term recursion          = 74 /**< "with $v seeded by..." expression */
%term seed               = 75

  /* Pathfinder extension: XRPC */
%term xrpc               = 76 /**< XRPC calls: "execute at" */

%%

Query:              main (FunctionDecls, CoreExpr)              =   1 (10);
Query:              CoreExpr                                    =   2 (10);

CoreExpr:           Atom                                        =   3 (10);
CoreExpr:           SequenceTypeCast                            =   4 (10);

CoreExpr:           flwr (OptBindExpr, CoreExpr)                =   5 (10);
                                                                     
OptBindExpr:        for_ (forbind (forvars (var, nil),
                                   CoreExpr),
                          OptBindExpr)                          =   6 (10);
OptBindExpr:        for_ (forbind (forvars (var, var),
                                   CoreExpr),
                          OptBindExpr)                          =   7 (10);

OptBindExpr:        let (letbind (var, CoreExpr), OptBindExpr)  =   8 (10);

OptBindExpr:        nil                                         =   9 (10);
                                                                     
CoreExpr:           if_ (CoreExpr,
                         then_else (CoreExpr, CoreExpr))        =  10 (10);

CoreExpr:           seq (CoreExpr, CoreExpr)                    =  15 (10);
CoreExpr:           twig_seq (CoreExpr, CoreExpr)               =  16 (10);

CoreExpr:           typesw (CoreExpr,
                            cases (case_ (SequenceType,
                                          CoreExpr),
                                   default_ (CoreExpr)))        =  17 (10);

SequenceTypeCast:   seqcast (SequenceType, CoreExpr)            =  18 (10);

CoreExpr:           proof (subty (CoreExpr, SequenceType),
                           CoreExpr)                            =  19 (10);

SequenceType:       seqtype                                     =  21 (10);
SequenceType:       stattype (CoreExpr)                         =  22 (10);

CoreExpr:           LocationSteps                               =  25 (10);

LocationStep:       ancestor (SequenceType)                     =  26 (10);
LocationStep:       ancestor_or_self (SequenceType)             =  27 (10);
LocationStep:       attribute (SequenceType)                    =  28 (10);
LocationStep:       child (SequenceType)                        =  29 (10);
LocationStep:       descendant (SequenceType)                   =  30 (10);
LocationStep:       descendant_or_self (SequenceType)           =  31 (10);
LocationStep:       following (SequenceType)                    =  32 (10);
LocationStep:       following_sibling (SequenceType)            =  33 (10);
LocationStep:       parent (SequenceType)                       =  34 (10);
LocationStep:       preceding (SequenceType)                    =  35 (10);
LocationStep:       preceding_sibling (SequenceType)            =  36 (10);
LocationStep:       self (SequenceType)                         =  37 (10);
/* [STANDOFF] */
LocationStep:       select_narrow (SequenceType)                =  100 (10);
LocationStep:       select_wide (SequenceType)                  =  101 (10);
LocationStep:       reject_narrow (SequenceType)                =  102 (10);
LocationStep:       reject_wide (SequenceType)                  =  103 (10);
/* [/STANDOFF] */

LocationSteps:      locsteps (LocationStep, LocationSteps)      =  40 (10);
LocationSteps:      locsteps (LocationStep, CoreExpr)           =  41 (10);

CoreExpr:           apply (FunctionArgs)                        =  42 (10);

FunctionArgs:       nil                                         =  43 (10);
FunctionArgs:       arg (FunctionArg, FunctionArgs)             =  44 (10);

FunctionArg:        CoreExpr                                    =  45 (10);
/*
 * FIXME: Should we also need this one here?
FunctionArg:        SequenceTypeCast;
 */

CoreExpr:           elem (tag, CoreExpr)                        =  46 (10);
CoreExpr:           elem (CoreExpr, CoreExpr)                   =  47 (10);

CoreExpr:           attr (tag, CoreExpr)                        =  48 (10);
CoreExpr:           attr (CoreExpr, CoreExpr)                   =  49 (10);

CoreExpr:           text (CoreExpr)                             =  50 (10);
CoreExpr:           doc (CoreExpr)                              =  51 (10);
CoreExpr:           comment (CoreExpr)                          =  52 (10);
CoreExpr:           pi (CoreExpr, CoreExpr)                     =  53 (10);
CoreExpr:           pi (lit_str, CoreExpr)                      =  54 (10);

CoreExpr:           ordered (CoreExpr)                          =  60 (10);
CoreExpr:           unordered (CoreExpr)                        =  61 (10);

CoreExpr:           orderby (OrderSpecs, CoreExpr)              =  62 (10);

OrderSpecs:         orderspecs (CoreExpr, nil)                  =  63 (10);
OrderSpecs:         orderspecs (CoreExpr, OrderSpecs)           =  64 (10);

CoreExpr:           cast (SequenceType, CoreExpr)               =  65 (10);

Atom:               var                                         =  66 (10);
Atom:               LiteralValue                                =  67 (10);

LiteralValue:       lit_str                                     =  68 (10);
LiteralValue:       lit_int                                     =  69 (10);
LiteralValue:       lit_dec                                     =  70 (10);
LiteralValue:       lit_dbl                                     =  71 (10);
LiteralValue:       true_                                       =  72 (10);
LiteralValue:       false_                                      =  73 (10);
LiteralValue:       empty                                       =  74 (10);

FunctionDecls:      nil                                         =  80 (10);
FunctionDecls:      fun_decls (FunctionDecl, FunctionDecls)     =  81 (10);

FunctionDecl:       fun_decl (ParamList, FunctionBody)          =  82 (10);

ParamList:          nil                                         =  83 (10);
ParamList:          params (FunParam, ParamList)                =  84 (10);

FunctionBody:       CoreExpr                                    =  85 (10);

FunParam:           param (SequenceType, var)                   =  86 (10);

/* Pathfinder extension: recursion */
CoreExpr:           recursion (var, seed (CoreExpr, CoreExpr))  =  87 (10);

/* Pathfinder extension: XRPC */
CoreExpr:           xrpc (CoreExpr, CoreExpr)                   =  88 (10);

%%

/** Type of a core tree node */
#define TY(p) ((p)->type)

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

/** mnemonic XQuery Core constructors */
#include "core_mnemonic.h"

static PFfun_t * overload (PFqname_t qn, PFcnode_t *args);
static PFty_t specific (PFfun_t *fn, PFcnode_t *args);

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFcnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFcnode_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */

    /* guard against too dep recursion */
    PFrecursion_fence();

    /* determine rule that matches for this non-terminal */
    rule = PFtypecheck_rule (STATE_LABEL (p), goalnt);
    assert (rule);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFtypecheck_nts[rule];
    PFtypecheck_kids (p, rule, kids);

    /* PFinfo (OOPS_NOTICE, "in rule %u", rule); */

    /* evaluate top-down in a number of cases */
    switch (rule) {
        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:
        /* OptBindExpr:        for_ (forbind (forvars (var, nil),
                                              CoreExpr),
                                     OptBindExpr) */
        case 6:

        /* OptBindExpr:        for_ (forbind (forvars (var, var),
                                              CoreExpr),
                                     OptBindExpr) */
        case 7:

        /* OptBindExpr:        let (letbind (var, CoreExpr), OptBindExpr) */
        case 8:

        /* CoreExpr:           recursion (var, seed (CoreExpr, CoreExpr)) */
        case 87:

            break;

        default:
            /*
             * Recursively invoke compilation.
             * This means bottom-up compilation.
             */
            for (unsigned short i = 0; nts[i]; i++)
                reduce (kids[i], nts[i]);
    }

    switch (rule) {

        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:
            /* TOPDOWN */

            /*
             * Type-check query body before any user-defined function.
             * This way we type all global variables (they have been
             * replaced by `let ...' clauses around the query body),
             * before we type any function body. (Note that function
             * bodies may refer global variables.)
             */
            reduce (kids[1], nts[1]);
            reduce (kids[0], nts[0]);

            if (PFty_subtype (TY(R(p)), PFty_plus (PFty_none ())))
                /*
                 * Not really okay, but we let it go through with
                 * a warning: the query *statically* evaluated to
                 * the error type (none).
                 *
                 * NOTE: `none' is a subtype of all other types (but
                 *       nothing is a subtype of `none').  Hence,
                 *       do this check before any other check.
                 */
                PFinfo (OOPS_WARNING, "query will always return an error");
            else if (PFty_subtype (TY(R(p)), PFty_star (PFty_item ())))
                /* okay, this is a normal query */
                ;
            else if (PFty_subtype (TY(R(p)), PFty_star (PFty_stmt ())))
                /* okay, this is an update query */
                ;
            else if (PFty_subtype (TY(R(p)), PFty_star (PFty_docmgmt ())))
                /* okay, this is a document management query */
                ;
            else
                PFoops (OOPS_TYPECHECK,
                        "illegal combination of query and update features "
                        "(result type is `%s')", PFty_str (TY(R(p))));

            break;

        /* Query:              CoreExpr */
        case 2:
            break;

        /* CoreExpr:           Atom */
        case 3:
            break;

        /* CoreExpr:           SequenceTypeCast */
        case 4:
            break;

        /* CoreExpr:           flwr (OptBindExpr, CoreExpr) */
        case 5:
            TY(p) = *PFty_simplify (L(p)->sem.flwr.quantifier (TY(R(p))));
            break;

        /* OptBindExpr:        for_ (forbind (forvars (var, nil),
                                              CoreExpr),
                                     OptBindExpr) */
        case 6:
        {   /* TOPDOWN */

            /* W3C XQuery, 5.8.2
             *
             *   E |- CoreExpr : t1   E[Var : prime (t1)] |- CoreExpr : t2
             * -------------------------------------------------------------
             * for_ (Var, nil, CoreExpr, OptBindExpr) : t2 . quantifier (t1)
             */
            PFty_t t1;

            /* nil : none */
            TY(LLR(p)) = PFty_none ();

            /* E |- CoreExpr : t1 */
            reduce (kids[0], nts[0]);
            t1 = TY(LR(p));

            /*
             * The specs prohibit the (statically typed) empty sequence
             * in many places.  (see XQuery FS, beginning of Section 4)
             */
            if (PFty_subtype (t1, PFty_empty ()))
                PFoops (OOPS_TYPECHECK,
                        "binding sequence in a for clause has static "
                        "type `empty'");

            /*
             * XQuery Update Facility disallows updates in the `for'
             * part.
             */
            if (!PFty_disjoint (PFty_stmt (),
                                PFty_prime (PFty_defn (t1))))
                PFoops (OOPS_TYPECHECK,
                        "err:XUST0101: binding sequence may not contain "
                        "an updating expression (has type `%s')",
                        PFty_str (t1));

            /* sanity check */
            if (!PFty_subtype (t1, PFty_star (PFty_item ())))
                PFoops (OOPS_TYPECHECK,
                        "illegal binding in for clause, cannot iterate over "
                        "type `%s'",
                        PFty_str (t1));

            /* Var : prime (t1) */
            TY(LLL(p)) = *PFty_simplify (PFty_prime (PFty_defn (t1)));

            /* Var1 should now have a sensible type (not `none') */
            assert (PFty_subtype (TY(LLL(p)), PFty_star (PFty_item ())));

            /* E[Var : prime (t1)] |- CoreExpr : t2 */
            assert (LLL(p)->sem.var);
            TY( LLL(p)->sem.var ) = TY(LLL(p));
            reduce (kids[1], nts[1]);

            p->sem.flwr.quantifier = PFty_quantifier 
                                     (R(p)->sem.flwr.quantifier (
                                          PFty_defn (t1)));

        } break;

        /* OptBindExpr:        for_ (forbind (forvars (var, var),
                                              CoreExpr),
                                     OptBindExpr) */
        case 7:
        {   /* TOPDOWN */

            /* W3C XQuery, 5.8.2
             *
             *                    E |- CoreExpr : t1   
             *  E[Var1:prime (t1), Var2:xs:integer] |- OptBindExpr : t2
             * --------------------------------------------------------------
             *  for_ (Var1, Var2, CoreExpr, CoreExpr) : t2 . quantifier (t1)
             */
            PFty_t t1;

            /* E |- CoreExpr : t1 */
            reduce (kids[0], nts[0]);
            t1 = TY(LR(p));

            /*
             * The specs prohibit the (statically typed) empty sequence
             * in many places.  (see XQuery FS, beginning of Section 4)
             */
            if (PFty_subtype (t1, PFty_empty ()))
                PFoops (OOPS_TYPECHECK,
                        "binding sequence in a for clause has static "
                        "type `empty'");

            /*
             * XQuery Update Facility disallows updates in the `for'
             * part.
             */
            if (!PFty_disjoint (PFty_stmt (),
                                PFty_prime (PFty_defn (t1))))
                PFoops (OOPS_TYPECHECK,
                        "err:XUST0101: binding sequence may not contain "
                        "an updating expression (has type `%s')",
                        PFty_str (t1));

            /* sanity check */
            if (!PFty_subtype (t1, PFty_star (PFty_item ())))
                PFoops (OOPS_TYPECHECK,
                        "illegal binding in for clause, cannot iterate over "
                        "type `%s'",
                        PFty_str (t1));

            /* Var2 : xs:integer */
            TY(LLR(p)) = PFty_xs_integer ();
            assert (LLR(p)->sem.var);
            TY( LLR(p)->sem.var ) = TY(LLR(p));

            /* Var1 : prime (t1) */
            TY(LLL(p)) = *PFty_simplify (PFty_prime (PFty_defn (t1)));

            /* Var1 should now have a sensible type (not `none') */
            assert (PFty_subtype (TY(LLL(p)), PFty_star (PFty_item ())));

            /* E[Var1 : prime (t1), Var2 : xs:integer] |- CoreExpr : t2 */
            assert (LLL(p)->sem.var);
            TY( LLL(p)->sem.var ) = TY(LLL(p));
            reduce (kids[1], nts[1]);

            p->sem.flwr.quantifier = PFty_quantifier 
                               (R(p)->sem.flwr.quantifier (PFty_defn (t1)));

        } break;

        /* OptBindExpr:        let (letbind (var, CoreExpr), OptBindExpr) */
        case 8:
        {   /* TOPDOWN */
            
            /* W3C XQuery, 5.8.3
             * 
             * E |- CoreExpr1 : t1   E[Var : t1] |- CoreExpr2 : t2
             * ----------------------------------------------------
             *      E |- let (Var, CoreExpr1, CoreExpr2) : t2
             */
            PFty_t t1;

            /* E |- CoreExpr1 : t1 */
            reduce (kids[0], nts[0]);
            t1 = TY(LR(p));
            TY(LL(p)) = t1;

            /*
             * NOTE:
             *   The XQuery Update Facility disallows updating
             *   expressions in the `let' part of a FLWOR clause.
             *   However, our compilation into XQuery Core has
             *   introduced lots of `let' clauses, such that any
             *   update expression would fail if we really enforce
             *   this semantics.
             */

            /* E[Var : t1] |- CoreExpr : t2 */
            assert (LL(p)->sem.var);
            TY( LL(p)->sem.var ) = t1;
            reduce (kids[1], nts[1]);

            p->sem.flwr.quantifier = R(p)->sem.flwr.quantifier;
        } break;

        /* OptBindExpr:        nil */
        case 9:
            p->sem.flwr.quantifier = PFty_one;
            break;

        /* CoreExpr:           if_ (CoreExpr, then_else (CoreExpr, CoreExpr)) */
        case 10:
            /* W3C XQuery, 5.10
             *
             * E |- CoreExpr1:boolean  E |- CoreExpr2:t1  E |- CoreExpr3:t2
             * ------------------------------------------------------------
             *  E |- ifthenelse (CoreExpr1, CoreExp2, CoreExpr3) : t1 | t2
             */
            if (PFty_eq (PFty_defn (TY(L(p))), PFty_xs_boolean ()))
                TY(p) = *PFty_simplify (PFty_choice (TY(RL(p)), TY(RR(p))));
            else
                PFoops (OOPS_TYPECHECK,
                        "if-then-else condition of type %s (expected %s)",
                        PFty_str (TY(L(p))), PFty_str (PFty_xs_boolean ()));

            /*
             * no mixture of updates and expressions
             */
            if (!PFty_disjoint (PFty_stmt (),
                                PFty_prime (PFty_defn (TY(p))))
                && !PFty_disjoint (PFty_item (),
                                   PFty_prime (PFty_defn (TY(p)))))
                PFoops (OOPS_TYPECHECK,
                        "err:XUST0101: illegal mix of updating and "
                        "non-updating expressions (got type `%s')",
                        PFty_str (TY(p)));

            break;

        /* CoreExpr:           seq (CoreExpr, CoreExpr) */
        case 15:
        /* CoreExpr:           twig_seq (CoreExpr, CoreExpr) */
        case 16:
            /* W3C XQuery, 5.3.1
             * 
             * E |- CoreExpr1 : t1    E |- CoreExpr2 : t2
             * ------------------------------------------
             *  E |- seq (CoreExpr1, CoreExpr2) : t1, t2
             */
            TY(p) = *PFty_simplify (PFty_seq (TY(L(p)), TY(R(p))));

            /*
             * no mixture of updates and expressions
             */
            if (!PFty_disjoint (PFty_stmt (),
                                PFty_prime (PFty_defn (TY(p))))
                && !PFty_disjoint (PFty_item (),
                                   PFty_prime (PFty_defn (TY(p)))))
                PFoops (OOPS_TYPECHECK,
                        "err:XUST0101: illegal mix of updating and "
                        "non-updating expressions (got type `%s')",
                        PFty_str (TY(p)));

            break;

        /* CoreExpr:           typesw (CoreExpr,
                                       cases (case_ (SequenceType,
                                                     CoreExpr),
                                              default_ (CoreExpr))) */
        case 17:
        {   /* W3C XQuery, 5.12.2
             *
             *                   E |- CoreExpr:t1  E |- SequenceType:t2  
             *           E |- CoreExpr1:t3    E |- CoreExpr2:t4    t1 <: t2
             * ---------------------------------------------------------------
             *  E |- typeswitch (CoreExpr, cases (
             *                                 case_ (SequenceType, CoreExpr1),
             *                                 default (CoreExpr2))) : t3
             *
             *                   E |- CoreExpr:t1  E |- SequenceType:t2  
             *           E |- CoreExpr1:t3    E |- CoreExpr2:t4    t1 || t2
             * ---------------------------------------------------------------
             *  E |- typeswitch (CoreExpr, cases (
             *                                 case_ (SequenceType, CoreExpr1),
             *                                 default (CoreExpr2))) : t4
             *
             *                   E |- CoreExpr:t1  E |- SequenceType:t2  
             *                 E |- CoreExpr1:t3    E |- CoreExpr2:t4  
             * ---------------------------------------------------------------
             *  E |- typeswitch (CoreExpr, cases (
             *                                 case_ (SequenceType, CoreExpr1),
             *                                 default (CoreExpr2))) : t3 | t4
             */
            PFty_t t1, t2;

            t1 = TY(L(p));
            t2 = TY(RLL(p));

            /*
             * XQuery Update Facility disallows updates in the
             * operand expression of a typeswitch.
             */
            if (!PFty_disjoint (PFty_stmt (),
                                PFty_prime (PFty_defn (t1))))
                PFoops (OOPS_TYPECHECK,
                        "err:XUST0101: operand in `typeswitch' may not contain "
                        "an updating expression (has type `%s')",
                        PFty_str (t1));

            if (PFty_subtype (t1, t2))
                TY(p) = TY(RLR(p));
            else if (PFty_disjoint (t1, t2))
                TY(p) = TY(RRL(p));
            else
                TY(p) = *PFty_simplify (PFty_choice (TY(RLR(p)), TY(RRL(p))));

            /*
             * no mixture of updates and expressions
             */
            if (!PFty_disjoint (PFty_stmt (),
                                PFty_prime (PFty_defn (TY(p))))
                && !PFty_disjoint (PFty_item (),
                                   PFty_prime (PFty_defn (TY(p)))))
                PFoops (OOPS_TYPECHECK,
                        "err:XUST0101: illegal mix of updating and "
                        "non-updating expressions (got type `%s')",
                        PFty_str (t1));

        } break;

        /* SequenceTypeCast:   seqcast (SequenceType, CoreExpr) */
        case 18:
            TY(p) = TY(L(p));
            break;

        /* CoreExpr:           proof (subty (CoreExpr, SequenceType),
                                      CoreExpr) */
        case 19:
            /*
             *    E |- CoreExpr1 : t1   E |- SequenceType : t2
             *                      t1 <: t2
             *                 E |- CoreExpr2 : t3
             * ----------------------------------------------------
             * E |- proof (CoreExpr1, SequenceType, CoreExpr2) : t3
             */

            /* perform the <: proof */
            if (! (PFty_subtype (TY(LL(p)), TY(LR(p)))))
                PFoops (OOPS_TYPECHECK,
                        "%s is not a subtype of %s",
                        PFty_str (TY(LL(p))),
                        PFty_str (TY(LR(p))));

            /* remove the successful proof and simply return the guarded
             * expression 
             */
            *p = *R(p);
            break;
            
        /* SequenceType:       seqtype */
        case 21:
            TY(p) = p->sem.type;
            break;

        /* SequenceType:       stattype (CoreExpr) */
        case 22:
        {   /*
             * We now know the static type of the argument expression.
             * We can thus replace the stattype node by a seqtype node
             * carrying the respective type.
             * After typechecking there should be no more stattype nodes
             * left.
             */
            PFcnode_t *ret = PFcore_seqtype ( TY(L(p)) );
            ret->type = ret->sem.type;

            /* Set state label correctly before we return. */
            STATE_LABEL(ret) = PFtypecheck_state (OP_LABEL(ret), 0, 0);

            *p = *ret;
        }

        /* CoreExpr:           LocationSteps */
        case 25:
            break;

        /* LocationStep:       ancestor (SequenceType) */
        case 26:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       ancestor_or_self (SequenceType) */
        case 27:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       attribute (SequenceType) */
        case 28:
            /*
             * For attribute steps that do not contain any wildcards,
             * we know that there can be at most one match for each
             * context node.
             */
            assert (TY(L(p)).type == ty_attr);
            if (! (PFQNAME_NS_WILDCARD (TY(L(p)).name)
                   || PFQNAME_LOC_WILDCARD (TY(L(p)).name)))
                TY(p) = PFty_opt (TY(L(p)));
            else
                TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       child (SequenceType) */
        case 29:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       descendant (SequenceType) */
        case 30:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       descendant_or_self (SequenceType) */
        case 31:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       following (SequenceType) */
        case 32:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       following_sibling (SequenceType) */
        case 33:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       parent (SequenceType) */
        case 34:
        {
            PFty_t possible_parent_types
                = PFty_choice (PFty_xs_anyElement (),
                               PFty_doc (PFty_xs_anyNode ()));

            if (PFty_subtype (possible_parent_types,
                              TY(L(p))))
                TY(p) = PFty_opt (possible_parent_types);
            else
                TY(p) = PFty_opt (TY(L(p)));
        } break;

        /* LocationStep:       preceding (SequenceType) */
        case 35:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       preceding_sibling (SequenceType) */
        case 36:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       self (SequenceType) */
        case 37:
            TY(p) = TY(L(p));
            break;
/* [STANDOFF] */
        case 100:
        /* LocationStep:       select_narrow (SequenceType) */
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       select_wide (SequenceType) */
        case 101:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       reject_narrow (SequenceType) */
        case 102:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       reject_wide (SequenceType) */
        case 103:
            TY(p) = PFty_star (TY(L(p)));
            break;
/* [/STANDOFF] */

        /* LocationSteps:      locsteps (LocationStep, LocationSteps) */
        case 40:
            TY(p) = *PFty_simplify (PFty_quantifier (TY(R(p))) (TY(L(p))));
            break;

        /* LocationSteps:      locsteps (LocationStep, CoreExpr) */
        case 41:
            TY(p) = *PFty_simplify (PFty_quantifier (TY(R(p))) (TY(L(p))));
            break;

        /* CoreExpr:           apply (FunctionArgs) */
        case 42:
            /* resolve overloading,
             * any type errors will be detected during resolution
             */
            p->sem.fun = overload (p->sem.fun->qname, L(p));

            /* invoke specific typing rules for standard F&O functions 
             * (W3C XQuery Formal Semantics 6.2)
             */
            TY(p) = specific (p->sem.fun, L(p));

            break;

        /* FunctionArgs:       nil */
        case 43:
            break;

        /* FunctionArgs:       arg (FunctionArg, FunctionArgs) */
        case 44:
            TY(p) = TY(L(p));
            break;

        /* FunctionArg:        CoreExpr */
        case 45:
            break;


        /* CoreExpr:           elem (tag, CoreExpr) */
        case 46:
            TY(p) = *PFty_simplify (PFty_elem (L(p)->sem.qname, TY(R(p))));
            break;

        /* CoreExpr:           elem (CoreExpr, CoreExpr) */
        case 47:
        {   
            PFty_t t1 = TY(R(p));
            PFqname_t wild = PFqname (PFns_wild, NULL);

            if (!PFty_promotable (TY(L(p)), PFty_xs_QName ()))
                PFoops (OOPS_TYPECHECK,
                        "tag name in computed element constructor"
                        " has illegal type `%s'",
                        PFty_str (TY(L(p))));

            TY(p) = *PFty_simplify (PFty_elem (wild, t1));
        } break;

        /* CoreExpr:           attr (tag, CoreExpr) */
        case 48:
            TY(p) = *PFty_simplify (PFty_attr (L(p)->sem.qname,
                                               PFty_untypedAtomic ()));
            break;
            
        /* CoreExpr:           attr (CoreExpr, CoreExpr) */
        case 49:
        {
            PFqname_t wild = PFqname (PFns_wild, NULL);

            if (!PFty_promotable (TY(L(p)), PFty_xs_QName ()))
                PFoops (OOPS_TYPECHECK,
                        "tag name in computed attribute constructor"
                        " has illegal type '%s'",
                        PFty_str (TY(L(p))));

            TY(p)= *PFty_simplify (PFty_attr (wild, PFty_untypedAtomic ()));
        } break;

        /* CoreExpr:           text (CoreExpr) */
        case 50:
            /*
             * XQuery Draft, 3.7.3.4 (Sep 15, 2005 version):
             *
             * "If the result of atomization is an empty sequence,
             *  no text node is constructed."
             */
            if (PFty_subtype (PFty_empty (), TY(L(p))))
                TY(p) = PFty_opt (PFty_text ());
            else
                TY(p) = PFty_text ();
            break;

        /* CoreExpr:           doc (CoreExpr) */
        case 51:
            TY(p) = *PFty_simplify (PFty_doc (TY(L(p))));
            break;

        /* CoreExpr:           comment (CoreExpr) */
        case 52:
            TY(p) = PFty_comm ();
            break;

        /* CoreExpr:           pi (CoreExpr, CoreExpr) */
        case 53:
            if (!PFty_promotable (TY(L(p)), PFty_xs_string ()))
                PFoops (OOPS_TYPECHECK,
                        "target name in processing-instruction constructor"
                        " has illegal type '%s'",
                        PFty_str (TY(L(p))));
            TY(p) = PFty_pi (NULL);
            break;

        /* CoreExpr:           pi (lit_str, CoreExpr) */
        case 54:
            TY(L(p)) = PFty_xs_string ();
            TY(p) = PFty_pi (L(p)->sem.str);
            break;

        /* CoreExpr:           ordered (CoreExpr) */
        case 60:
            TY(p) = TY(L(p));
            break;

        /* CoreExpr:           unordered (CoreExpr) */
        case 61:
            TY(p) = TY(L(p));
            break;

        /* CoreExpr:           orderby (OrderSpecs, CoreExpr) */
        case 62:
            TY(p) = TY(R(p));
            break;

        /* OrderSpecs:         orderspecs (CoreExpr, nil) */
        case 63:
        /* OrderSpecs:         orderspecs (CoreExpr, OrderSpecs) */
        case 64:
            /*
             * XQuery Update Facility disallows updates in `order by'
             * clauses.
             */
            if (!PFty_disjoint (PFty_stmt (),
                                PFty_prime (PFty_defn (TY(L(p))))))
                PFoops (OOPS_TYPECHECK,
                        "err:XUST0101: `order by' may not contain "
                        "an updating expression (has type `%s')",
                        PFty_str (TY(L(p))));

            if (!PFty_subtype (TY(L(p)), PFty_opt (PFty_atomic ())))
                PFoops (OOPS_TYPECHECK,
                        "[err:XPTY0004]"
                        " Orderspec requires at most one atomic item "
                        "(given: %s).", PFty_str (TY(L(p))));

            if (!PFty_subtype (TY(L(p)), PFty_opt (PFty_xs_string ())) &&
                !PFty_subtype (TY(L(p)), PFty_opt (PFty_xs_decimal ())) &&
                !PFty_subtype (TY(L(p)), PFty_opt (PFty_xs_double ())))
                PFoops (OOPS_TYPECHECK,
                        "[err:XPTY0004]"
                        " Orderspec requires an type whose order can be "
                        "decided using 'gt' (given: %s).", PFty_str (TY(L(p))));
            break;

        /* CoreExpr:           cast (SequenceType, CoreExpr) */
        case 65:
            if (!PFty_subtype (TY(L(p)), PFty_opt (PFty_atomic ())))
                PFoops (OOPS_TYPECHECK,
                        "err:XPTY0004: "
                        "casting is only allowed to an atomic type");

            /* check for occurrence indicator + */
            if (PFty_subtype (TY(R(p)), PFty_plus (PFty_item ())) &&
                !PFty_subtype (TY(R(p)), PFty_item ()))
                PFoops (OOPS_TYPECHECK, "err:XPTY0004");

            /* check for occurrence indicator ? */
            if (PFty_subtype (TY(L(p)), PFty_item ()) &&
                !PFty_subtype (TY(R(p)), PFty_item ()))
                PFoops (OOPS_TYPECHECK, "err:XPTY0004");

            TY(p) = TY(L(p));
            break;

        /* Atom:               var */
        case 66:
            /* W3C XQuery, 5.1.2
             *
             * E.varType(Var) = t
             * -------------------
             *    E |- Var : t
             */
            assert (p->sem.var);
            TY(p) = TY( p->sem.var );
            break;

        /* Atom:               LiteralValue */
        case 67:
            break;

        /* LiteralValue:       lit_str */
        case 68:
            /* W3C XQuery, 5.1.1
             *
             * --------------------------
             * Env |- lit_str : xs:string
             */
            TY(p) = PFty_xs_string ();
            break;
     
        /* LiteralValue:       lit_int */
        case 69:
            /* W3C XQuery, 5.1.1
             *
             * ---------------------------
             * Env |- lit_int : xs:integer
             */
            TY(p) = PFty_xs_integer ();
            break;

        /* LiteralValue:       lit_dec */
        case 70:
            /* W3C XQuery, 5.1.1
             *
             * ---------------------------
             * Env |- lit_dec : xs:decimal
             */
            TY(p) = PFty_xs_decimal ();
            break;

        /* LiteralValue:       lit_dbl */
        case 71:
            /* W3C XQuery, 5.1.1
             *
             * --------------------------
             * Env |- lit_dec : xs:double
             */
            TY(p) = PFty_xs_double ();
            break;

        /* LiteralValue:       true_ */
        case 72:
            /* 
             * -------------------------
             * Env |- true_ : xs:boolean
             */
            TY(p) = PFty_xs_boolean ();
            break;

        /* LiteralValue:       false_ */
        case 73:
            /* 
             * --------------------------
             * Env |- false_ : xs:boolean
             */
            TY(p) = PFty_xs_boolean ();
            break;

        /* LiteralValue:       empty */
        case 74:
            /*
             * ------------------
             * Env |- empty_ : ()
             */
            TY(p) = PFty_empty ();
            break;
     
        /* FunctionDecls:      nil */
        case 80:
            break;

        /* FunctionDecls:      fun_decls (FunctionDecl, FunctionDecls) */
        case 81:
            break;

        /* FunctionDecl:       fun_decl (ParamList, FunctionBody) */
        case 82:
            /*
             * See if function body matches function return type.
             */
	    assert (p->sem.fun->sig_count == 1);
            if (!PFty_subtype (TY(R(p)), p->sem.fun->sigs[0].ret_ty))
                PFoops (OOPS_TYPECHECK,
                        "body of %s() evaluates to `%s' which is not "
                        "a subtype of `%s'",
                        PFqname_str (p->sem.fun->qname),
                        PFty_str (TY(R(p))), 
			PFty_str (p->sem.fun->sigs[0].ret_ty));
            break;

        /* ParamList:          nil */
        case 83:
            break;

        /* ParamList:          param (FunParam, ParamList) */
        case 84:
            break;

        /* FunctionBody:       CoreExpr */
        case 85:
            break;

        /* FunParam:           param (SequenceType, var) */
        case 86:
            /*
             * Bind parameter variable to the given type. We need this
             * to type-check the function body.
             */
            TY(R(p)) = TY(L(p));
            TY(R(p)->sem.var) = TY(L(p));
            break;

        /* CoreExpr:           recursion (var, seed (CoreExpr, CoreExpr)) */
        case 87:
            /* TOPDOWN */

            /*
             * Reduce the seed expression first.  We made sure that
             * the static type of the seed expression will be the type
             * given in the `with $var as ...' part of the input query
             * (or the default type `node*') in the translation to
             * Core.
             */
            reduce (kids[0], nts[0]);

            /*
             * Now attach this type to the recursion variable
             */
            TY(L(p)) = TY(RL(p));
            TY(L(p)->sem.var) = TY(RL(p));

            /*
             * Of course, that same type must also be a node type
             */
            if (! PFty_subtype (TY(RL(p)), PFty_star (PFty_node ())))
                PFoops (OOPS_TYPECHECK,
                        "recursion is only possible on node types "
                        "(got %s)", PFty_str (TY(RL(p))));

            /*
             * The type must also allow more than one node
             */
            if (! PFty_subtype (PFty_plus (TY(RL(p))), TY(RL(p))))
                PFoops (OOPS_TYPECHECK,
                        "the type given in a recursive expression "
                        "must allow sequences of length greater than one "
                        "(got %s)", PFty_str (TY(RL(p))));

            /*
             * Now we are ready to type-check the recursion body
             * (which may use the variable)
             */
            reduce (kids[1], nts[1]);

            /*
             * The same type is also the type of the overall expression.
             */
            TY(p) = TY(RL(p));

            break;

        /* CoreExpr:           xrpc (CoreExpr, CoreExpr) */
        case 88:
            if (! PFty_subtype (TY(L(p)), PFty_xs_string ()))
                PFoops (OOPS_TYPECHECK,
                        "the location specified in an `execute at' statement "
                        "must be a subtype of xs:string (got %s)",
                        PFty_str (TY(L(p))));
            TY(p) = TY(R(p));
            break;

        default:
            PFoops (OOPS_FATAL, "untranslated expression");
            break;
    }
}

static void fun_not_found (PFqname_t qn, PFcnode_t *args) 
{
    PFarray_t *fns = PFenv_lookup (PFfun_env, qn);
    assert (fns);

    /* construct (error) message listing the actual argument types:
     * ": t1; t2; ...; tn" (NB: n >= 1 is guaranteed here)
     */
    PFarray_t *args_str = PFarray (sizeof (char));
    char semi = ':';

    do {
        PFarray_printf (args_str, "%c %s", 
                        semi,
                        PFty_str (args->child[0]->type));
        semi = ';';
        args = args->child[1];
    } while (args->kind != c_nil);

    PFinfo (OOPS_TYPECHECK, 
            "no variant of function %s accepts the given argument type(s)%s",
            PFqname_str (qn),
            (char *) PFarray_at (args_str, 0));

    PFinfo (OOPS_TYPECHECK, "maybe you meant:");

    for (unsigned int i = 0; i < PFarray_last (fns); i++) {

        PFfun_t *fn       = *(PFfun_t **) PFarray_at (fns, i);
	
	for (unsigned j = 0; j < fn->sig_count; j++) {
	     args_str = PFarray (sizeof (char));

	     PFfun_sig_t *sig = fn->sigs + j;

	     PFarray_printf (args_str, "%s (", PFqname_str (fn->qname));
		  
	     for (unsigned int k = 0; k < fn->arity; k++) {
		  PFarray_printf (args_str, "%s%s",
				  k ? ", " : "", 
				  PFty_str (sig->par_ty[k]));
	     }
	     
	     PFarray_printf (args_str, ") as %s", 
			     PFty_str (sig->ret_ty));

	     PFinfo (OOPS_TYPECHECK, "  %s", 
		     (char *) PFarray_at (args_str, 0));
	}
    }

    PFoops (OOPS_TYPECHECK,
            "illegal arguments for function %s", PFqname_str (qn));
}


/**
 * Resolve function overloading.  In the list of functions of the same
 * name @a qn, find the first (most specific) to match the actual
 * argument types @a args (matching is based on `can be promoted to'
 * relationship).
 *
 * @attention NB. This relies on the list of functions for name @a qn
 * to be sorted: the most specific instance comes first (see
 * semantics/xquery_fo.c)
 *
 * @param qn name of (overloaded) function
 * @param args right-deep core tree of function arguments 
 *             arg (e1, arg (e2, ..., arg (en, nil)...))
 */
static PFfun_t *
overload (PFqname_t qn, PFcnode_t *args)
{
    PFty_t     zoo_ty;
    PFarray_t *fns;
    PFcnode_t *arg;
    PFfun_t *fn;
    unsigned int i, a;
    bool match, zoo_match, arg_match;

    assert (args && (args->kind == c_nil || args->kind == c_arg));

    fns = PFenv_lookup (PFfun_env, qn);
    assert (fns);

    for (i = 0; i < PFarray_last (fns); i++) {
        fn    = *(PFfun_t **) PFarray_at (fns, i);
        arg   = args;

        /* can all actual argument types be promoted to
         * expected formal parameter types?
         */
        if (fn->sig_count == 1) {
            match     = true;
            zoo_match = true;
            a         = 0;
            while (a < fn->arity) {
                /* test if function has at least the same
                   number of arguments as the tested function */
                if (arg->kind == c_nil)
                {
                    match = false;
                    break;
                }

                arg_match = PFty_promotable (arg->child[0]->type,
                                             (fn->sigs[0].par_ty)[a]);
                
                match = match && arg_match;
                
                /* apply function zero-or-one on the type of the argument */
                zoo_ty = *PFty_simplify (
                              PFty_opt (
                                  PFty_prime (
                                      PFty_defn (
                                          arg->child[0]->type))));
                
                /* and check if this type would be ok */
                zoo_match = PFty_promotable (zoo_ty, (fn->sigs[0].par_ty)[a]);

                /* if neither the original type
                   nor the zero-or-one type match
                   we give up */
                if (!match && !zoo_match)
                    break;

                /* if the original type does not match
                   but the zero-or-one type matches 
                   we apply function zero-or-one on the input
                   and check the argument again */
                if (!arg_match && zoo_match) {
                    /* create the function fn:zero-or-one */
                    PFfun_t *zoo = function (PFqname (PFns_fn, "zero-or-one"));
                    PFcnode_t *ret = PFcore_apply (
                                         zoo,
                                         PFcore_arg (
                                             L(arg),
                                             PFcore_nil ()));
                    
                    /* Set state label correctly before we return. */
                    STATE_LABEL(LR(ret)) = PFtypecheck_state (
                                               OP_LABEL(LR(ret)), 0, 0);
                    STATE_LABEL(L(ret))  = PFtypecheck_state (
                                               OP_LABEL(L(ret)),
                                               STATE_LABEL(LL(ret)),
                                               STATE_LABEL(LR(ret)));
                    STATE_LABEL(ret)     = PFtypecheck_state (
                                               OP_LABEL(ret),
                                               STATE_LABEL(L(ret)),
                                               0);
                    
                    /* fix the types correctly */
                    TY(L(ret)) = TY(L(arg));
                    TY(ret)    = zoo_ty;
                    TY(arg)    = zoo_ty;
                    
                    /* replace the argument by the function
                       zero-or-one applied to the argument */
                    L(arg) = ret;

                    /* re-check */
                }
                else {
                    /* continue */
                    a++;
                    arg = arg->child[1];
                }
                
                assert (arg);
            }

            /* yes, return this function (its the most specific match) */
            /* and it has the same number of arguments */
            if (match && arg->kind == c_nil)
                return fn;
        }
        else
            /* function with multiple signatures (dynamic overloading).
             * Type checking is a little bit tricky and is done in
             * specific. We assume that this is always the right function.
             */
            return fn;
    }
 
    fun_not_found (qn, args);

    /* just to pacify picky compilers; never reached due to "exit" in PFoops */
    return 0;
}

static PFty_t next_choice (PFty_t t) {
     if (t.type == ty_choice)
	  return *(t.child[0]);
     return PFty_none ();
}

static PFty_t next_type (PFty_t t) {
     if (t.type == ty_choice)
	  return *(t.child[1]);
     return t;
}

/**
 * Apply specific typing rules for standard XQuery F&O functions
 * (see W3C XQuery, 7.2)
 *
 * @bug
 *   This function has two arguments, both of which are even
 *   documented. But only one of them is actually used.
 *
 * @param fn function reference
 * @param args right-deep core tree of function arguments 
 * @return return type of @a fn when applied to arguments @a args
 */
static PFty_t
specific (PFfun_t *fn, PFcnode_t *args)
{
    assert (fn);
    assert (args && (args->kind == c_nil || args->kind == c_arg));

    /* Typing rules for fn:data() are described by the special
     * judgement `data on' (W3C FS 6.2.3), implemented in PFty_data_on()
     */
    if ((! PFqname_eq (fn->qname, PFqname (PFns_fn, "data")))
        || (! PFqname_eq (fn->qname, PFqname (PFns_pf, "typed-value")))) {
        /* fn:data() gets exactly one argument */
        assert (args->kind == c_arg && R(args)->kind == c_nil);
        return *PFty_simplify (
                (PFty_quantifier (TY(L(args)))
                    (PFty_data_on (PFty_defn (TY(L(args)))))));
    }

    /* specific typing rules for fn:insert-before() */
    if (! PFqname_eq (fn->qname, PFqname (PFns_fn, "insert-before"))) {
        assert (args->kind == c_arg && R(args)->kind == c_arg &&
                R(R(args))->kind == c_arg && R(R(R(args)))->kind == c_nil);
        
        PFty_t seq_type = PFty_seq (PFty_defn (TY(L(args))),
                                    PFty_defn (TY(L(R(R(args))))));
        
        return *PFty_simplify (PFty_quantifier (seq_type)
                                   (PFty_prime (seq_type)));
    }

    /* specific typing rules for fn:remove() */
    if (! PFqname_eq (fn->qname, PFqname (PFns_fn, "remove"))) {
        assert (args->kind == c_arg && R(args)->kind == c_arg &&
                R(R(args))->kind == c_nil);
        return *PFty_simplify (
                    PFty_opt (PFty_quantifier (TY(L(args)))
                                  (PFty_prime (PFty_defn(TY(L(args)))))));
    }

    /* specific typing rules for fn:subsequence() */
    if (! PFqname_eq (fn->qname, PFqname (PFns_fn, "subsequence"))) {

        assert (args->kind == c_arg);

        /*
         * The W3C Formal Semantics demands a special treatment of the
         * case
         *    fn:subsequence (Expr, Num, 1)
         * (Use quantifier `?' if last argument is literal 1.)
         *
         * However, we won't see any literal constants here, as they
         * have been wrapped into fn:data() and others.  We just ignore
         * that W3C rule.  (Current draft is buggy with that respect
         * anyway.  No one knows, how those rules will look like in
         * upcoming drafts...)
         */

        /* use occurrence indicator `?' if expr contains at most one item */
        if (PFty_subtype (TY(L(args)), PFty_opt (PFty_item ())))
            return *PFty_simplify (PFty_opt (
                        PFty_prime (PFty_defn(TY(L(args))))));
        /* otherwise we cannot do more than `*' */
        else
            return *PFty_simplify (PFty_star (
                        PFty_prime (PFty_defn (TY(L(args))))));
    }

    if (! PFqname_eq (fn->qname, PFqname (PFns_fn, "distinct-values")) ||
        ! PFqname_eq (fn->qname, PFqname (PFns_fn, "reverse")) ||
        ! PFqname_eq (fn->qname, PFqname (PFns_fn, "trace")) ||
        ! PFqname_eq (fn->qname, PFqname (PFns_fn, "unordered"))) {
        return *PFty_simplify (
                    (PFty_quantifier (PFty_defn (TY(L(args))))
                         (PFty_prime (PFty_defn (TY(L(args)))))));
    }
    
    if (! PFqname_eq (fn->qname, PFqname (PFns_fn, "zero-or-one"))) {
        return *PFty_simplify (PFty_opt (PFty_prime (PFty_defn (TY(L(args))))));
    }

    if (! PFqname_eq (fn->qname, PFqname (PFns_fn, "exactly-one"))) {
        return *PFty_simplify (PFty_prime (PFty_defn (TY(L(args)))));
    }

    if (! PFqname_eq (fn->qname, PFqname (PFns_op, "union"))) {
        PFty_t seq_type = PFty_seq (PFty_defn (TY(L(args))),
                                    PFty_defn (TY(RL(args))));
        return *PFty_simplify (
                    (PFty_quantifier (seq_type))
                        (PFty_prime (seq_type)));
    }

    if (! PFqname_eq (fn->qname, PFqname (PFns_op, "intersect"))) {
        PFty_t seq_type = PFty_seq (PFty_defn (TY(L(args))),
                                    PFty_defn (TY(RL(args))));
        return *PFty_simplify (
                    PFty_opt (
                        (PFty_quantifier (seq_type))
                            (PFty_prime (seq_type))));
    }
    
    if (! PFqname_eq (fn->qname, PFqname (PFns_op, "except"))) {
        PFty_t left_type = PFty_defn (TY(L(args)));
        return *PFty_simplify (
                    PFty_opt (
                        (PFty_quantifier (left_type))
                            (PFty_prime (left_type))));
    }

    /* #pf:distinct-doc-order-or-atomic-sequence() splits up the typing
       into a case for atomic values and one for node values */
    if (! PFqname_eq (fn->qname, 
                      PFqname (
                          PFns_pf, 
                          "distinct-doc-order-or-atomic-sequence"))) {
        /* #pf:distinct-doc-order-or-atomic-sequence 
           gets exactly one argument */
        assert (args->kind == c_arg && R(args)->kind == c_nil);

        if (PFty_subtype (TY(L(args)), PFty_star (PFty_node ())))
            return *PFty_simplify (
                    (PFty_quantifier (TY(L(args))))
                        (PFty_prime (PFty_defn (TY(L(args))))));
        else if (PFty_subtype (TY(L(args)), PFty_star (PFty_atomic ())))
            return TY(L(args));
        else
            PFoops (OOPS_TYPECHECK,
                    "err:XPTY0018: the result of the last step "
                    "in a path expression contains both nodes "
                    "and atomic values");
    }

    /* #pf:distinct-doc-order() more or less returns its input */
    if (! PFqname_eq (fn->qname, PFqname (PFns_pf, "distinct-doc-order"))) {
        /* #pf:distinct-doc-order gets exactly one argument */
        assert (args->kind == c_arg && R(args)->kind == c_nil);

        return *PFty_simplify (
                (PFty_quantifier (TY(L(args))))
                    (PFty_prime (PFty_defn (TY(L(args))))));
    }

    /* Typing rules for #pf:item-sequence-to-node-sequence() are described
     * by the special judgment `is2ns', implemented in PFty_is2ns(),
     * which reduces atomic types to text().
     */
    if ((! PFqname_eq (fn->qname,
                       PFqname (PFns_pf, "item-sequence-to-node-sequence")))) {
        assert (args->kind == c_arg && R(args)->kind == c_nil);
        return *PFty_simplify ((PFty_is2ns (PFty_defn (TY(L(args))))));
    }


    if (fn->sig_count > 1) {
	 /* special handing for functions with multiple signatures,
	  * but one implementation ("dynamic overloading")
	  */
	 /* currently, only functions with 2 parameters are supported.
	  * So we can use simple for loops and we do not need complex
	  * permutation stuff.
	  */	     
	 assert (fn->arity == 2);
	 PFty_t ret_type = PFty_none ();
	 PFty_t arg1_type = PFty_defn (TY(L(args)));
	 PFty_t arg2_type = PFty_defn (TY(L(R(args))));

	 /* iterate through the possible types of argument 1 */
	 for (PFty_t c1 = PFty_normalize_choice (arg1_type); 
	      c1.type != ty_none;
	      c1 = next_choice (c1)) 
	 {
	      PFty_t t1 = next_type (c1);

              /* iterate through the possible types of argument 2 */
	      for (PFty_t c2 = PFty_normalize_choice (arg2_type); 
		   c2.type != ty_none;
		   c2 = next_choice (c2))
	      {
		   PFty_t t2 = next_type (c2);

		   bool found = false;
		   /* for every combination, check if we have a matching
		    * signature.
		    */
		   for (unsigned int i = 0; 
			i < fn->sig_count && !found; i++) {
			PFfun_sig_t *sig = fn->sigs + i;

			if (PFty_promotable (t1, sig->par_ty[0])
			    && PFty_promotable (t2, sig->par_ty[1]))
			{
			     found = true;
			     /* the return type is the combination of
			      * the return types of every matching signature
			      */
			     if (ret_type.type != ty_none)
				  ret_type =
				       PFty_choice (ret_type,
						    sig->ret_ty);
			     else
				  ret_type = sig->ret_ty;
			}
		   }
		   if (!found)
		     fun_not_found (fn->qname, args);
	      }
	 }

	 return ret_type;
    }

    return fn->sigs[0].ret_ty;
}



/**
 * Type check XQuery Core tree.
 *
 * @param r root of the XQuery Core tree
 * @return @a r
 */
PFcnode_t *
PFty_check (PFcnode_t *r)
{
    assert (r);

    /* label the core tree bottom up */
    PFtypecheck_label (r);

    /* invoke compilation */
    reduce (r, 1);

    return r;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
