%{

/**
 * @file
 *
 * Remove ambiguities from the parse tree and bring it
 * into normalized form.
 *
 * Copyright Notice:
 * -----------------
 *
 *  The contents of this file are subject to the MonetDB Public
 *  License Version 1.0 (the "License"); you may not use this file
 *  except in compliance with the License. You may obtain a copy of
 *  the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
 *
 *  Software distributed under the License is distributed on an "AS
 *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 *  implied. See the License for the specific language governing
 *  rights and limitations under the License.
 *
 *  The Original Code is the ``Pathfinder'' system. The Initial
 *  Developer of the Original Code is the Database & Information
 *  Systems Group at the University of Konstanz, Germany. Portions
 *  created by U Konstanz are Copyright (C) 2000-2005 University
 *  of Konstanz. All Rights Reserved.
 *
 *
 * $Id$
 */ 


#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "oops.h"
#include "abssyn.h"
#include "qname.h"
#include "mem.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFpnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/abssyn.h!
 */
%term    and            =   1
/* %term apply          =   2  introduced in function checking */
%term    args           =   3
%term    atom_ty        =   4
%term    attr           =   5
%term    base_uri       =   6
%term    bind           =   7
%term    binds          =   8
%term    case_          =   9
%term    cases          =  10
%term    cast           =  11
%term    castable       =  12
%term    coll_decl      =  13
%term    comment        =  14
%term    constr_decl    =  15
%term    contseq        =  16
%term    decl_imps      =  17
%term    def_order      =  18
%term    default_       =  19
%term    div            =  20
%term    doc            =  21
%term    dot            =  22
%term    elem           =  23
%term    empty_seq      =  24
%term    empty_ty       =  25
%term    ens_decl       =  26
%term    eq             =  27
%term    every          =  28
%term    except         =  29
%term    exprseq        =  30
%term    external       =  31
%term    flwr           =  32
%term    fns_decl       =  33
/* %term fun            =  34  introduced in function checking */
%term    fun_decl       =  35
%term    fun_ref        =  36
%term    fun_sig        =  37
%term    ge             =  38
%term    gt             =  39
%term    gtgt           =  40
%term    idiv           =  41
%term    if_            =  42
%term    inherit_ns     =  43
%term    instof         =  44
%term    intersect      =  45
%term    is             =  46
%term    item_ty        =  47
%term    le             =  48
%term    let            =  49
%term    lib_mod        =  50
%term    lit_dbl        =  51
%term    lit_dec        =  52
%term    lit_int        =  53
%term    lit_str        =  54
%term    locpath        =  55
%term    lt             =  56
%term    ltlt           =  57
%term    main_mod       =  58
%term    minus          =  59
%term    mod            =  60
%term    mod_imp        =  61
%term    mod_ns         =  62
%term    mult           =  63
%term    named_ty       =  64
%term    ne             =  65
%term    nil            =  66
%term    nis            =  67
%term    node_ty        =  68
%term    ns_decl        =  69
%term    or             =  70
%term    ord_ret        =  71
%term    orderby        =  72
%term    ordered        =  73
%term    ordering_mode  =  74
%term    orderspecs     =  75
%term    param          =  76
%term    params         =  77
%term    pi             =  78
%term    plus           =  79
%term    pred           =  80
%term    range          =  81
%term    req_name       =  82
%term    req_ty         =  83
%term    root_          =  84
%term    schm_ats       =  85
%term    schm_attr      =  86
%term    schm_elem      =  87
%term    schm_imp       =  88
%term    seq_ty         =  89
%term    some           =  90
%term    step           =  91
%term    tag            =  92
%term    text           =  93
%term    then_else      =  94
%term    treat          =  95
%term    typeswitch     =  96
%term    uminus         =  97
%term    union_         =  98
%term    unordered      =  99
%term    uplus          = 100
%term    val_eq         = 101
%term    val_ge         = 102
%term    val_gt         = 103
%term    val_le         = 104
%term    val_lt         = 105
%term    val_ne         = 106
%term    validate       = 107
/* %term var            = 108  introduced after var scoping */
%term    var_decl       = 109
%term    var_type       = 110
%term    varref         = 111
%term    vars           = 112
%term    where          = 113
%term    xmls_decl      = 114

%%

Query:                  main_mod (Prolog, QueryBody)                =   1 (10);
Query:                  lib_mod (ModuleDecl, Prolog)                =   2 (10);

ModuleDecl:             mod_ns (lit_str)                            =   3 (10);
Prolog:                 DeclsImports                                =   4 (10);

DeclsImports:           decl_imps (DeclImport, DeclsImports)        =   5 (10);
DeclsImports:           decl_imps (nil, DeclsImports)               =   6 (1);
DeclsImports:           nil                                         =   7 (10);

DeclImport:             DefaultNamespaceDecl                        =   8 (10);
DeclImport:             XMLSpaceDecl                                =   9 (10);
DeclImport:             DefaultCollationDecl                        =  10 (10);
DeclImport:             BaseURIDecl                                 =  11 (10);
DeclImport:             ConstructionDecl                            =  12 (10);
DeclImport:             OrderingModeDecl                            =  13 (10);
DeclImport:             EmptyOrderingDecl                           =  14 (10);
DeclImport:             InheritNamespacesDecl                       =  15 (10);
DeclImport:             NamespaceDecl                               =  16 (10);
DeclImport:             SchemaImport                                =  17 (10);
DeclImport:             ModuleImport                                =  18 (10);
DeclImport:             FunctionDeclaration                         =  19 (10);
DeclImport:             VariableDeclaration                         =  20 (10);

DefaultNamespaceDecl:   ens_decl (lit_str)                          =  21 (10);
DefaultNamespaceDecl:   fns_decl (lit_str)                          =  22 (10);

XMLSpaceDecl:           xmls_decl                                   =  23 (10);

DefaultCollationDecl:   coll_decl (lit_str)                         =  24 (10);

BaseURIDecl:            base_uri (lit_str)                          =  25 (10);

ConstructionDecl:       constr_decl                                 =  26 (10);

OrderingModeDecl:       ordering_mode                               =  27 (10);

EmptyOrderingDecl:      def_order                                   =  28 (10);

InheritNamespacesDecl:  inherit_ns                                  =  29 (10);

NamespaceDecl:          ns_decl (lit_str)                           =  30 (10);

SchemaImport:           schm_imp (lit_str, OptImportLoc_)           =  31 (10);

ModuleImport:           mod_imp (lit_str, OptImportLoc_)            =  32 (10);

OptImportLoc_:          nil                                         =  33 (10);
OptImportLoc_:          schm_ats (lit_str, OptImportLoc_)           =  34 (10);

FunctionDeclaration:    fun_decl (fun_sig (OptParamList_,
                                           SequenceType),
                                  OptExpr)                          =  35 (10);
FunctionDeclaration:    fun_decl (fun_sig (OptParamList_,
                                           SequenceType),
                                  external)                         =  36 (10);

OptParamList_:          nil                                         =  37 (10);
OptParamList_:          ParamList_                                  =  38 (10);

ParamList_:             nil                                         =  39 (10);
ParamList_:             params (Param, ParamList_)                  =  40 (10);

Param:                  param (OptSequenceType_, varref)            =  41 (10);

OptSequenceType_:       nil                                         =  42 (10);
OptSequenceType_:       SequenceType                                =  43 (10);

VariableDeclaration:    var_decl (var_type (varref,
                                            OptSequenceType_),
                                  OptExpr)                          =  44 (10);
VariableDeclaration:    var_decl (var_type (varref,
                                            OptSequenceType_),
                                  external)                         =  45 (10);

QueryBody:              OptExpr                                     =  46 (10);

OptExpr:                empty_seq                                   =  47 (10);
OptExpr:                Expr                                        =  48 (10);

Expr:                   exprseq (Expr, OptExpr)                     =  49 (10);
Expr:                   exprseq (empty_seq, OptExpr)                =  50 (10);
Expr:                   exprseq (exprseq (Expr, OptExpr), OptExpr)  =  51 (1);
Expr:                   ExprSingle                                  =  52 (10);

ExprSingle:             FLWORExpr                                   =  53 (10);
ExprSingle:             QuantifiedExpr                              =  54 (10);
ExprSingle:             TypeswitchExpr                              =  55 (10);
ExprSingle:             IfExpr                                      =  56 (10);
ExprSingle:             OrExpr                                      =  57 (10);

FLWORExpr:              flwr (binds (VarBinding, nil),
                              where (OptWhereClause_,
                                     ord_ret (OptOrderByClause_,
                                              OptExpr)))            =  58 (10);
FLWORExpr:              flwr (binds (VarBinding, VarBindings),
                              where (OptWhereClause_,
                                     ord_ret (OptOrderByClause_,
                                              OptExpr)))            =  59 (10);

VarBindings:            binds (VarBinding, nil)                     =  60 (10);
VarBindings:            binds (VarBinding, VarBindings)             =  61 (10);

VarBinding:             VarPosBinding                               =  62 (10);
VarBinding:             LetClause                                   =  63 (10);

LetClause:              LetBinding_                                 =  64 (10);

VarPosBinding:          bind (vars (var_type (varref,
                                              OptTypeDeclaration_),
                                    OptPositionalVar_),
                              OptExpr)                              =  65 (10);

LetBinding_:            let (var_type (varref, OptTypeDeclaration_),
                             OptExpr)                               =  66 (10);

OptPositionalVar_:      nil                                         =  67 (10);
OptPositionalVar_:      PositionalVar                               =  68 (10);

PositionalVar:          varref                                      =  69 (10);

OptTypeDeclaration_:    nil                                         =  70 (10);
OptTypeDeclaration_:    TypeDeclaration                             =  71 (10);

TypeDeclaration:        SequenceType                                =  72 (10);

OptWhereClause_:        nil                                         =  73 (10);
OptWhereClause_:        WhereClause                                 =  74 (10);

OptOrderByClause_:      nil                                         =  75 (10);
OptOrderByClause_:      OrderByClause                               =  76 (10);

WhereClause:            OptExpr                                     =  77 (10);

OrderByClause:          orderby (OrderSpecList)                     =  78 (10);

OrderSpecList:          orderspecs (OptExpr, nil)                   =  79 (10);
OrderSpecList:          orderspecs (OptExpr, OrderSpecList)         =  80 (10);

QuantifiedExpr:         some (VarBindings, OptExpr)                 =  81 (10);
QuantifiedExpr:         some (binds (VarBinding, VarBindings),
                              OptExpr)                              =  82 (10);
QuantifiedExpr:         every (VarBindings, OptExpr)                =  83 (10);
QuantifiedExpr:         every (binds (VarBinding, VarBindings),
                               OptExpr)                             =  84 (10);

TypeswitchExpr:         typeswitch (OptExpr,
                                    cases (CaseClause,
                                           cases (DefaultClause_,
                                                  nil)))            =  85 (10);
TypeswitchExpr:         typeswitch (OptExpr,
                                    cases (CaseClause,
                                           CaseClauses_))           =  86 (10);

CaseClauses_:           cases (CaseClause,
                               cases (DefaultClause_, nil))         =  87 (10);
CaseClauses_:           cases (CaseClause, CaseClauses_)            =  88 (10);

DefaultClause_:         default_ (OptVarName_, OptExpr)             =  89 (10);

OptVarName_:            nil                                         =  90 (10);
OptVarName_:            varref                                      =  91 (10);

CaseClause:             case_ (var_type (OptVarName_, SequenceType),
                               OptExpr)                             =  92 (10);

SequenceType:           seq_ty (ItemType)                           =  93 (10);
SequenceType:           seq_ty (empty_ty)                           =  94 (10);

SingleType:             seq_ty (atom_ty (nil))                      =  95 (10);

ItemType:               NodeTest                                    =  96 (10);
ItemType:               item_ty (nil)                               =  97 (10);
ItemType:               atom_ty (nil)                               =  98 (10);
ItemType:               schm_elem                                   =  99 (10);
ItemType:               schm_attr                                   = 100 (10);

NodeTest:               node_ty (OptElemOrAttrType_)                = 101 (10);
NodeTest:               node_ty (lit_str)                           = 102 (10);
NodeTest:               node_ty (node_ty (OptElemOrAttrType_))      = 103 (10);

OptElemOrAttrType_:     nil                                         = 104 (10);
OptElemOrAttrType_:     ElemOrAttrType                              = 105 (10);

ElemOrAttrType:         req_ty (nil, nil)                           = 106 (10);
ElemOrAttrType:         req_ty (nil, named_ty)                      = 107 (10);
ElemOrAttrType:         req_ty (req_name, nil)                      = 108 (10);
ElemOrAttrType:         req_ty (req_name, named_ty)                 = 109 (10);

IfExpr:                 if_ (OptExpr,
                             then_else (OptExpr, OptExpr))          = 110 (10);

OrExpr:                 AndExpr                                     = 111 (10);
OrExpr:                 or (AndExpr, OrExpr)                        = 112 (10);

AndExpr:                ComparisonExpr                              = 113 (10);
AndExpr:                and (ComparisonExpr, AndExpr)               = 114 (10);

ComparisonExpr:         RangeExpr                                   = 115 (10);
ComparisonExpr:         eq (RangeExpr, RangeExpr)                   = 116 (10);
ComparisonExpr:         ne (RangeExpr, RangeExpr)                   = 117 (10);
ComparisonExpr:         lt (RangeExpr, RangeExpr)                   = 118 (10);
ComparisonExpr:         le (RangeExpr, RangeExpr)                   = 119 (10);
ComparisonExpr:         gt (RangeExpr, RangeExpr)                   = 120 (10);
ComparisonExpr:         ge (RangeExpr, RangeExpr)                   = 121 (10);
ComparisonExpr:         val_eq (RangeExpr, RangeExpr)               = 122 (10);
ComparisonExpr:         val_ne (RangeExpr, RangeExpr)               = 123 (10);
ComparisonExpr:         val_lt (RangeExpr, RangeExpr)               = 124 (10);
ComparisonExpr:         val_le (RangeExpr, RangeExpr)               = 125 (10);
ComparisonExpr:         val_gt (RangeExpr, RangeExpr)               = 126 (10);
ComparisonExpr:         val_ge (RangeExpr, RangeExpr)               = 127 (10);
ComparisonExpr:         is (RangeExpr, RangeExpr)                   = 128 (10);
ComparisonExpr:         nis (RangeExpr, RangeExpr)                  = 129 (10);
ComparisonExpr:         ltlt (RangeExpr, RangeExpr)                 = 130 (10);
ComparisonExpr:         gtgt (RangeExpr, RangeExpr)                 = 131 (10);

RangeExpr:              AdditiveExpr                                = 132 (10);
RangeExpr:              range (RangeExpr, RangeExpr)                = 133 (10);

AdditiveExpr:           MultiplicativeExpr                          = 134 (10);
AdditiveExpr:           plus (AdditiveExpr, MultiplicativeExpr)     = 135 (10);
AdditiveExpr:           minus (AdditiveExpr, MultiplicativeExpr)    = 136 (10);

MultiplicativeExpr:     UnionExpr                                   = 137 (10);
MultiplicativeExpr:     mult (UnionExpr, MultiplicativeExpr)        = 138 (10);
MultiplicativeExpr:     div (UnionExpr, MultiplicativeExpr)         = 139 (10);
MultiplicativeExpr:     idiv (UnionExpr, MultiplicativeExpr)        = 140 (10);
MultiplicativeExpr:     mod (UnionExpr, MultiplicativeExpr)         = 141 (10);

UnionExpr:              IntersectExceptExpr                         = 142 (10);
UnionExpr:              union_ (IntersectExceptExpr, UnionExpr)     = 143 (10);

IntersectExceptExpr:    InstanceofExpr                              = 144 (10);
IntersectExceptExpr:    intersect (InstanceofExpr,
                                   IntersectExceptExpr)             = 145 (10);
IntersectExceptExpr:    except (InstanceofExpr,
                                IntersectExceptExpr)                = 146 (10);

InstanceofExpr:         TreatExpr                                   = 147 (10);
InstanceofExpr:         instof (TreatExpr, SequenceType)            = 148 (10);

TreatExpr:              CastableExpr                                = 149 (10);
TreatExpr:              treat (CastableExpr, SequenceType)          = 150 (10);

CastableExpr:           CastExpr                                    = 151 (10);
CastableExpr:           castable (CastExpr, SingleType)             = 152 (10);

CastExpr:               UnaryExpr                                   = 153 (10);
CastExpr:               cast (UnaryExpr, SingleType)                = 154 (10);

UnaryExpr:              ValueExpr                                   = 155 (10);
UnaryExpr:              uminus (ValueExpr)                          = 156 (10);
UnaryExpr:              uplus (ValueExpr)                           = 157 (10);

ValueExpr:              ValidateExpr                                = 158 (10);
ValueExpr:              PathExpr                                    = 159 (10);

ValidateExpr:           validate (OptExpr)                          = 160 (10);

PathExpr:               root_                                       = 161 (10);
PathExpr:               RelativePathExpr                            = 162 (10);

RelativePathExpr:       StepExpr                                    = 163 (10);
RelativePathExpr:       step (NodeTest)                             = 164 (1);
RelativePathExpr:       locpath (StepExpr, RelativePathExpr)        = 165 (10);

StepExpr:               Step_                                       = 166 (10);
StepExpr:               FilterExpr                                  = 167 (10);

FilterExpr:             PrimaryExpr                                 = 168 (10);
FilterExpr:             pred (RelativePathExpr, OptExpr)            = 169 (10);

Step_:                  step (NodeTest)                             = 170 (10);

PrimaryExpr:            Literal                                     = 171 (10);
PrimaryExpr:            varref                                      = 172 (10);
PrimaryExpr:            ParenthesizedExpr                           = 173 (10);
PrimaryExpr:            ContextItemExpr                             = 174 (10);
PrimaryExpr:            FunctionCall                                = 175 (10);
PrimaryExpr:            Constructor                                 = 176 (10);
PrimaryExpr:            OrderedExpr                                 = 177 (10);
PrimaryExpr:            UnorderedExpr                               = 178 (10);

Literal:                NumericLiteral                              = 179 (10);
Literal:                StringLiteral                               = 180 (10);

NumericLiteral:         IntegerLiteral                              = 181 (10);
NumericLiteral:         DecimalLiteral                              = 182 (10);
NumericLiteral:         DoubleLiteral                               = 183 (10);

IntegerLiteral:         lit_int                                     = 184 (10);
DecimalLiteral:         lit_dec                                     = 185 (10);
DoubleLiteral:          lit_dbl                                     = 186 (10);

StringLiteral:          lit_str                                     = 187 (10);

ParenthesizedExpr:      OptExpr                                     = 188 (10);

ContextItemExpr:        dot                                         = 189 (10);

FunctionCall:           fun_ref (OptFuncArgList_)                   = 190 (10);

OptFuncArgList_:        nil                                         = 191 (10);
OptFuncArgList_:        FuncArgList_                                = 192 (10);

FuncArgList_:           args (OptExpr, nil)                         = 193 (10);
FuncArgList_:           args (OptExpr, FuncArgList_)                = 194 (10);

OrderedExpr:            ordered (OptExpr)                           = 195 (10);
UnorderedExpr:          unordered (OptExpr)                         = 196 (10);

Constructor:            ElementConstructor                          = 197 (10);
Constructor:            AttributeConstructor                        = 198 (10);
Constructor:            TextConstructor                             = 199 (10);
Constructor:            CommentConstructor                          = 200 (10);
Constructor:            PIConstructor                               = 201 (10);
Constructor:            DocumentConstructor                         = 202 (10);

ElementConstructor:     elem (TagName, OptContentExpr)              = 203 (10);

AttributeConstructor:   attr (TagName, OptContentExpr)              = 204 (10);

TextConstructor:        text (OptContentExpr)                       = 205 (10);

CommentConstructor:     comment (OptContentExpr)                    = 206 (10);

PIConstructor:          pi (OptContentExpr)                         = 207 (10);

DocumentConstructor:    doc (OptContentExpr)                        = 208 (10);

TagName:                tag                                         = 209 (10);
TagName:                OptExpr                                     = 210 (10);

OptContentExpr:         OptExpr                                     = 211 (10);
OptContentExpr:         contseq (OptContentExpr, OptContentExpr)    = 212 (10);
OptContentExpr:         contseq (empty_seq, empty_seq)              = 213 (1);
OptContentExpr:         contseq (contseq (OptContentExpr,
                                          OptContentExpr),
                                 OptContentExpr)                    = 214 (1);

%%

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

static void relabel (PFpnode_t *p,  PFpnode_t **kids);

/* construct a nil node */
#define nil(loc) leaf (p_nil, (loc))

#define leaf(t,loc)       p_leaf ((t), (loc))
#define wire1(t,loc,a)    p_wire1 ((t), (loc), (a))
#define wire2(t,loc,a,b)  p_wire2 ((t), (loc), (a), (b))

static PFpnode_t * varref (PFqname_t q, PFloc_t loc);
static PFqname_t new_varname (char *prefix);

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFpnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpnode_t *   kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          rewritten;
    short         old_state_label;
    PFpnode_t *   c;

    do {
        /* determine rule that matches for this non-terminal */
        rule = PFnormalize_rule (STATE_LABEL (p), goalnt);

        /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */

        /* initialize the kids[] vector */
        for (unsigned short i = 0; i < MAX_KIDS; i++)
            kids[i] = NULL;

        /*
         * prepare recursive traversal: get information on leaf nodes of
         * this rule
         */
        nts = PFnormalize_nts[rule];
        PFnormalize_kids (p, rule, kids);

        /*
         * Recursively invoke compilation.  This means bottom-up compilation.
         */
        unsigned short i;
        rewritten = false;
        for (i = 0; nts[i]; i++)
            if ((rewritten = reduce (kids[i], nts[i])))
                break;  /* abort if a subtree was rewritten */

        if (rewritten) {
            /*
             * If a subtree has been rewritten, we have to
             *  - re-label that part of the tree, and
             *  - possibly propagate the `rewritten' information upwards.
             */

            /* remember our old state_label (so we know if it has changed) */
            old_state_label = STATE_LABEL(p);

            /*
             * Re-label current tree pattern.
             * (at most down to the pattern leaves, as they should already be
             * correctly labeled by the above reduce() call)
             */
            relabel (p, kids);

            /* If our own state_label has changed, notify our caller. */
            if (old_state_label != STATE_LABEL(p))
                return true;
        }
    } while (rewritten);

    rewritten = false;

    switch (rule) {
        /* DeclsImports: decl_imps (nil, DeclsImports) */
        case 6:
            *p = *R(p);
            rewritten = true;
            break;

        /* Expr: exprseq (empty_seq, ExprSingle) */
        case 50:
            *p = *(R(p));
            rewritten = true;
            break;

        /* Expr: exprseq (exprseq (Expr, OptExpr), OptExpr) */
        case 51:
            c = wire2 (p_exprseq, p->loc,
                       LL(p),
                       wire2 (p_exprseq, p->loc, LR(p), R(p)));
            *p = *c;
            relabel (p, kids);
            rewritten = true;
            break;

        /* FLWORExpr: flwr (binds (VarBinding, VarBindings),
                            where (OptWhereClause_,
                                   ord_ret (OptOrderByClause_,
                                            OptExpr))) */
        case 59:
            /* Current parse tree situation: multi-bind FLWOR
             * (may bind any number n >= 2 variables):
             *
             * for $a as t1 at $b in e1, $c as t2 at $d in e2
             *   where p
             *   order by o
             *   return e0
             *
             *                           flwr
             *                         /      \
             *                   binds          where
             *                  /    \          /    \
             *              bind    binds      p     ord_ret
             *            /    \    /   \            /     \
             *          vars   e1  bind  ...        o       e0
             *         /   \       /  \
             *  var_type   $b    vars  e2
             *  /     \         /    \
             * $a     t1    var_type  $d
             *              /     \
             *             $c     t2
             *
             * Rewrite this into n nested single-bind FLWORs:
             *
             * for $a as t1 at $b in e1 return
             *   for $c as t2 at $d in e2
             *     where p
             *     order by o
             *     return e0
             *
             *                   flwr
             *                 /      \
             *             binds     where
             *             /   \     /    \
             *           bind  nil nil    ord_ret         
             *           /   \           /       \
             *         vars  e1         nil      flwr
             *        /    \                   /      \ 
             *    var_type  $b             binds     where
             *     /     \                 /   \     /   \
             *    $a     t1              bind  ...  p   ord_ret
             *                           /   \           /   \
             *                         vars  e2         o    e0
             *                        /    \
             *                    var_type  $d
             *                     /     \
             *                    $c     t2
             */
            c = wire2 (p_flwr, p->loc,
                       L(p),
                       wire2 (p_where, p->loc,
                              nil (p->loc),
                              wire2 (p_ord_ret, p->loc,
                                     nil (p->loc),
                                     wire2 (p_flwr, p->loc,
                                            LR(p),
                                            R(p)))));
            LR (c) = nil (L(c)->loc);
            *p = *c;
            relabel (p, kids);
            rewritten = true;
            break;

        /* QuantifiedExpr: some (binds (VarBinding, VarBindings),
                                 OptExpr) */
        case 82:
            /* fall through (treat some and every equivalently) */

        /* QuantifiedExpr: every (binds (VarBinding, VarBindings),
                                  OptExpr) */
        case 84:
            /*
             * Current parse tree situation: multi-bind some/every
             * (may bind any number n >= 2 variables):
             *
             * some/every $a as t1 in e1, $b as t2 in e2
             *   satisfies e0
             *
             *                         some/every
             *                         /       \
             *                   binds          e0
             *                  /    \
             *              bind    binds
             *            /    \    /   \
             *          vars   e1  bind  ...
             *         /   \       /  \
             *  var_type   nil   vars  e2
             *  /     \         /    \
             * $a     t1    var_type  nil
             *              /     \
             *             $b     t2
             *
             * Rewrite this into n nested single-bind some/every:
             *
             * some $a as t1 in e1 satisfies
             *   some $b as t2 in e2 satisfies e0
             *
             *
             *                 some/every
             *                 /        \
             *             binds         some/every
             *             /   \           /      \
             *           bind  nil      binds     e0
             *           /   \          /   \  
             *         vars  e1       bind  nil
             *        /    \          /   \
             *    var_type  nil     vars  e2
             *     /     \         /    \
             *    $a     t1    var_type  nil
             *                  /     \
             *                 $b     t2
             */
            c = wire2 (p->kind, p->loc,
                       L(p),
                       wire2 (p->kind, p->loc,
                              LR(p),
                              R(p)));
            LR(c) = nil (p->loc);
            *p = *c;
            relabel (p, kids);
            rewritten = true;
            break;

        /* TypeswitchExpr: typeswitch (OptExpr,
                                       cases (CaseClause,
                                              CaseClauses_)) */
        case 86:
        {
            /*
             * Unnest typeswitch expressions.
             *
             * Rewrite
             *
             *   typeswitch e1
             *     case $a as type1    return ret1
             *     case $b as type2    return ret2
             *     case $c as type3    return ret3
             *     ...
             *     default $d          return def
             *
             * to
             *
             *   typeswitch e1
             *     case $a as type1              return ret1
             *     default $v1 return
             *       typeswitch $v1
             *         case $b as type2          return ret2
             *         default $v2 return
             *           typeswitch $v2
             *             case $c as type3      return ret3
             *             default $v3 return
             *               typeswitch
             *                 ...
             *                   default $d      return def
             *
             * That is:
             *
             *              typeswitch
             *             /          \
             *           e1           cases
             *                       /     \
             *                   case       cases
             *                  /   \      /     \
             *           var_type  ret1   case    ...
             *          /     \          /    \      \   
             *         $a    type1   var_type  ret2   cases
             *                        /   \           /     \
             *                       $b  type2   default    nil
             *                                   /    \
             *                                 $d     def
             *
             * becomes
             *
             *          typeswitch
             *         /          \
             *       e1           cases
             *                   /     \
             *               case       cases
             *              /   \      /     \
             *        var_type  ret1 default  nil
             *        /     \        /     \
             *       $a    type1    $v1    typeswitch
             *                            /        \
             *                          $v1       cases
             *                                   /     \
             *                             var_type     ...
             *                            /      \         \
             *                           $b     type2      cases
             *                                            /    \
             *                                      default    nil
             *                                      /    \
             *                                     $d    def
             */
            PFqname_t v1 = new_varname ("tsw");

            c = wire2 (p_typeswitch, p->loc,
                       L(p),
                       wire2 (p_cases, R(p)->loc,
                              RL(p),
                              wire2 (p_cases, RR(p)->loc,
                                     wire2 (p_default, RR(p)->loc,
                                            varref (v1, RR(p)->loc),
                                            wire2 (p_typeswitch, RR(p)->loc,
                                                   varref (v1, RR(p)->loc),
                                                   RR(p))),
                                     nil (RR(p)->loc))));
            *p = *c;
            relabel (p, kids);
            rewritten = true;
        } break;

        /* RelativePathExpr: step (NodeTest) */
        case 164:
            /*
             * Make sure any relative path expression starts from
             * the context node `.'
             */
            c = wire2 (p_locpath, p->loc,
                       wire1 (p_step, p->loc, L(p)),
                       leaf (p_dot, p->loc));
            c->child[0]->sem.axis = p->sem.axis;
            *p = *c;
            relabel (p, kids);
            rewritten = true;
            break;

        /* OptContentExpr: contseq (empty_seq, empty_seq) */
        case 213:
            *p = *R(p);
            rewritten = true;
            break;

        /* OptContentExpr: contseq (contseq (OptContentExpr,
                                             OptContentExpr),
                                    OptContentExpr)              */
        case 214:
            c = wire2 (p_contseq, p->loc,
                       LL(p),
                       wire2 (p_contseq, p->loc, LR(p), R(p)));
            *p = *c;
            relabel (p, kids);
            rewritten = true;
            break;

        default:
            break;
    }

    return rewritten;
}

/*
 * Re-label a match pattern.
 *
 * Start with node @a p and relabel the subtree below. However, stop
 * if @a p is one of the pattern leaves, passed as the argument @a kids.
 */
static void 
relabel (PFpnode_t *p,  PFpnode_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    /* Relabel p's children. */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFnormalize_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        relabel (L(p), kids);
        STATE_LABEL(p) = PFnormalize_state (OP_LABEL(p),
                                            STATE_LABEL(L(p)),
                                            0);
    }
    else if (!L(p) && R(p)) {
        relabel (R(p), kids);
        STATE_LABEL(p) = PFnormalize_state (OP_LABEL(p),
                                            STATE_LABEL(R(p)),
                                            0);
    }
    else {
        relabel (L(p), kids);
        relabel (R(p), kids);
        STATE_LABEL(p) = PFnormalize_state (OP_LABEL(p),
                                            STATE_LABEL(L(p)),
                                            STATE_LABEL(R(p)));
    }

}

/**
 * Generate a parse tree node for a variable reference
 * @param q   QName for the variable
 * @param loc location information as #PFloc_t struct
 * @return    a parse tree node representing the variable
 */
static PFpnode_t *
varref (PFqname_t q, PFloc_t loc)
{
    PFpnode_t * n = p_leaf (p_varref, loc);
    
    n->sem.qname = q;
    
    return n;
}

/**
 * Generate a new (unique) variable name. This unique name is created
 * by incrementing a number that is appended to the variable name.
 * A prefix may be given that may not be longer than 3 characters
 * (the length of 'dot'). If no prefix is given (by passing NULL),
 * the default 'v' is used. The namespace for the newly created
 * variable is the internal Pathfinder namespace `pf:...' (PFns_pf).
 *
 * @param prefix The prefix to use. The variable name will be
 *   "[prefix]_[num]", where [prefix] is the prefix and [num] is
 *   a three digit, zero-padded integer number
 * @return A QName describing the new variable name
 */
static PFqname_t
new_varname (char *prefix)
{
    static unsigned int varcount = 0;
    char                varname[sizeof("dot_000")];
    PFqname_t           qn;
    
    /* construct new variable name */
    if (prefix)
        snprintf (varname, sizeof ("dot_000"), "%3s_%03u", prefix, varcount++);
    else
        snprintf (varname, sizeof ("dot_000"), "v_%03u", varcount++);
    
    /* assign internal Pathfinder namespace `pf:...' */
    qn.ns  = PFns_pf;
    qn.loc = PFstrdup (varname);
    
    return qn;
}


/**
 * Normalize abstract syntax tree.
 *
 * Remove ambiguities in abstract syntax tree and bring it into
 * normal form.
 * 
 * @param r root of the abstract syntax tree (note that this
 *   might change during normalization)
 * @return the normalized abstract syntax tree
 */
PFpnode_t *
PFnormalize_abssyn (PFpnode_t *r)
{
    assert (r);

    /* label the parse tree bottom up */
    PFnormalize_label (r);

    /* invoke rewriting */
    while (reduce (r, 1))
        /* rewrite as long as there is something to do. */;

    return r;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
