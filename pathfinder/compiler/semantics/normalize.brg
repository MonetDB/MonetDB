%{

/**
 * @file
 *
 * Remove ambiguities from the parse tree and bring it
 * into normalized form.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2006 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 *
 * $Id$
 */ 


#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "oops.h"
#include "abssyn.h"
#include "qname.h"
#include "mem.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFpnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/abssyn.h!
 */
%term    and            =   1
/* %term apply          =   2  introduced in function checking */
%term    args           =   3
%term    atom_ty        =   4
%term    attr           =   5
%term    base_uri       =   6
%term    bind           =   7
%term    binds          =   8
%term    case_          =   9
%term    cases          =  10
%term    cast           =  11
%term    castable       =  12
%term    coll_decl      =  13
%term    comment        =  14
%term    constr_decl    =  15
%term    contseq        =  16
%term    decl_imps      =  17
%term    def_order      =  18
%term    default_       =  19
%term    div            =  20
%term    doc            =  21
%term    dot            =  22
%term    elem           =  23
%term    empty_seq      =  24
%term    empty_ty       =  25
%term    ens_decl       =  26
%term    eq             =  27
%term    every          =  28
%term    except         =  29
%term    exprseq        =  30
%term    external       =  31
%term    flwr           =  32
%term    fns_decl       =  33
/* %term fun            =  34  introduced in function checking */
%term    fun_decl       =  35
%term    fun_ref        =  36
%term    fun_sig        =  37
%term    ge             =  38
%term    gt             =  39
%term    gtgt           =  40
%term    idiv           =  41
%term    if_            =  42
%term    inherit_ns     =  43
%term    instof         =  44
%term    intersect      =  45
%term    is             =  46
%term    item_ty        =  47
%term    le             =  48
%term    let            =  49
%term    lib_mod        =  50
%term    lit_dbl        =  51
%term    lit_dec        =  52
%term    lit_int        =  53
%term    lit_str        =  54
%term    locpath        =  55
%term    lt             =  56
%term    ltlt           =  57
%term    main_mod       =  58
%term    minus          =  59
%term    mod            =  60
%term    mod_imp        =  61
%term    mod_ns         =  62
%term    mult           =  63
%term    named_ty       =  64
%term    ne             =  65
%term    nil            =  66
%term    node_ty        =  67
%term    ns_decl        =  68
%term    or             =  69
%term    ord_ret        =  70
%term    orderby        =  71
%term    ordered        =  72
%term    ordering_mode  =  73
%term    orderspecs     =  74
%term    param          =  75
%term    params         =  76
%term    pi             =  77
%term    plus           =  78
%term    pred           =  79
%term    range          =  80
%term    req_name       =  81
%term    req_ty         =  82
%term    root_          =  83
%term    schm_ats       =  84
%term    schm_attr      =  85
%term    schm_elem      =  86
%term    schm_imp       =  87
%term    seq_ty         =  88
%term    some           =  89
%term    step           =  90
%term    tag            =  91
%term    text           =  92
%term    then_else      =  93
%term    treat          =  94
%term    typeswitch     =  95
%term    uminus         =  96
%term    union_         =  97
%term    unordered      =  98
%term    uplus          =  99
%term    val_eq         = 100
%term    val_ge         = 101
%term    val_gt         = 102
%term    val_le         = 103
%term    val_lt         = 104
%term    val_ne         = 105
%term    validate       = 106
/* %term var            = 107  introduced after var scoping */
%term    var_decl       = 108
%term    var_type       = 109
%term    varref         = 110
%term    vars           = 111
%term    where          = 112
%term    xmls_decl      = 113

%%

Query:                  MainModule                                  =   1 (10);
Query:                  LibraryModule                               =   2 (10);

MainModule:             main_mod (Prolog, QueryBody)                =   3 (10);

LibraryModule:          lib_mod (ModuleDecl, Prolog)                =   4 (10);

ModuleDecl:             mod_ns (lit_str)                            =   5 (10);
Prolog:                 DeclsImports                                =   6 (10);

DeclsImports:           decl_imps (DeclImport, DeclsImports)        =   7 (10);
DeclsImports:           decl_imps (nil, DeclsImports)               =   8 (1);
DeclsImports:           nil                                         =   9 (10);

DeclImport:             DefaultNamespaceDecl                        =  10 (10);
DeclImport:             XMLSpaceDecl                                =  11 (10);
DeclImport:             DefaultCollationDecl                        =  12 (10);
DeclImport:             BaseURIDecl                                 =  13 (10);
DeclImport:             ConstructionDecl                            =  14 (10);
DeclImport:             OrderingModeDecl                            =  15 (10);
DeclImport:             EmptyOrderingDecl                           =  16 (10);
DeclImport:             InheritNamespacesDecl                       =  17 (10);
DeclImport:             NamespaceDecl                               =  18 (10);
DeclImport:             SchemaImport                                =  19 (10);
DeclImport:             ModuleImport                                =  20 (10);
DeclImport:             FunctionDeclaration                         =  21 (10);
DeclImport:             VariableDeclaration                         =  22 (10);
DeclImport:             LibraryModule                               =  23 (10);

DefaultNamespaceDecl:   ens_decl (lit_str)                          =  24 (10);
DefaultNamespaceDecl:   fns_decl (lit_str)                          =  25 (10);

XMLSpaceDecl:           xmls_decl                                   =  26 (10);

DefaultCollationDecl:   coll_decl (lit_str)                         =  27 (10);

BaseURIDecl:            base_uri (lit_str)                          =  28 (10);

ConstructionDecl:       constr_decl                                 =  29 (10);

OrderingModeDecl:       ordering_mode                               =  30 (10);

EmptyOrderingDecl:      def_order                                   =  31 (10);

InheritNamespacesDecl:  inherit_ns                                  =  32 (10);

NamespaceDecl:          ns_decl (lit_str)                           =  33 (10);

SchemaImport:           schm_imp (lit_str, OptImportLoc_)           =  34 (10);

ModuleImport:           mod_imp (lit_str, OptImportLoc_)            =  35 (10);

OptImportLoc_:          nil                                         =  36 (10);
OptImportLoc_:          schm_ats (lit_str, OptImportLoc_)           =  37 (10);

FunctionDeclaration:    fun_decl (fun_sig (OptParamList_,
                                           SequenceType),
                                  OptExpr)                          =  38 (10);
FunctionDeclaration:    fun_decl (fun_sig (OptParamList_,
                                           SequenceType),
                                  external)                         =  39 (10);

OptParamList_:          nil                                         =  40 (10);
OptParamList_:          ParamList_                                  =  41 (10);

ParamList_:             nil                                         =  42 (10);
ParamList_:             params (Param, ParamList_)                  =  43 (10);

Param:                  param (OptSequenceType_, varref)            =  44 (10);

OptSequenceType_:       nil                                         =  45 (10);
OptSequenceType_:       SequenceType                                =  46 (10);

VariableDeclaration:    var_decl (var_type (varref,
                                            OptSequenceType_),
                                  OptExpr)                          =  47 (10);
VariableDeclaration:    var_decl (var_type (varref,
                                            OptSequenceType_),
                                  external)                         =  48 (10);

QueryBody:              OptExpr                                     =  49 (10);

OptExpr:                empty_seq                                   =  50 (10);
OptExpr:                Expr                                        =  51 (10);

Expr:                   exprseq (Expr, OptExpr)                     =  52 (10);
Expr:                   exprseq (empty_seq, OptExpr)                =  53 (10);
Expr:                   exprseq (exprseq (Expr, OptExpr), OptExpr)  =  54 (1);
Expr:                   ExprSingle                                  =  55 (10);

ExprSingle:             FLWORExpr                                   =  56 (10);
ExprSingle:             QuantifiedExpr                              =  57 (10);
ExprSingle:             TypeswitchExpr                              =  58 (10);
ExprSingle:             IfExpr                                      =  59 (10);
ExprSingle:             OrExpr                                      =  60 (10);

FLWORExpr:              flwr (binds (VarBinding, nil),
                              where (OptWhereClause_,
                                     ord_ret (OptOrderByClause_,
                                              OptExpr)))            =  61 (10);
FLWORExpr:              flwr (binds (VarBinding, VarBindings),
                              where (OptWhereClause_,
                                     ord_ret (OptOrderByClause_,
                                              OptExpr)))            =  62 (10);

VarBindings:            binds (VarBinding, nil)                     =  63 (10);
VarBindings:            binds (VarBinding, VarBindings)             =  64 (10);

VarBinding:             VarPosBinding                               =  65 (10);
VarBinding:             LetClause                                   =  66 (10);

LetClause:              LetBinding_                                 =  67 (10);

VarPosBinding:          bind (vars (var_type (varref,
                                              OptTypeDeclaration_),
                                    OptPositionalVar_),
                              OptExpr)                              =  68 (10);

LetBinding_:            let (var_type (varref, OptTypeDeclaration_),
                             OptExpr)                               =  69 (10);

OptPositionalVar_:      nil                                         =  70 (10);
OptPositionalVar_:      PositionalVar                               =  71 (10);

PositionalVar:          varref                                      =  72 (10);

OptTypeDeclaration_:    nil                                         =  73 (10);
OptTypeDeclaration_:    TypeDeclaration                             =  74 (10);

TypeDeclaration:        SequenceType                                =  75 (10);

OptWhereClause_:        nil                                         =  76 (10);
OptWhereClause_:        WhereClause                                 =  77 (10);

OptOrderByClause_:      nil                                         =  78 (10);
OptOrderByClause_:      OrderByClause                               =  79 (10);

WhereClause:            OptExpr                                     =  80 (10);

OrderByClause:          orderby (OrderSpecList)                     =  81 (10);

OrderSpecList:          orderspecs (OptExpr, nil)                   =  82 (10);
OrderSpecList:          orderspecs (OptExpr, OrderSpecList)         =  83 (10);

QuantifiedExpr:         some (VarBindings, OptExpr)                 =  84 (10);
QuantifiedExpr:         some (binds (VarBinding, VarBindings),
                              OptExpr)                              =  85 (10);
QuantifiedExpr:         every (VarBindings, OptExpr)                =  86 (10);
QuantifiedExpr:         every (binds (VarBinding, VarBindings),
                               OptExpr)                             =  87 (10);

TypeswitchExpr:         typeswitch (OptExpr,
                                    cases (CaseClause,
                                           cases (DefaultClause_,
                                                  nil)))            =  88 (10);
TypeswitchExpr:         typeswitch (OptExpr,
                                    cases (CaseClause,
                                           CaseClauses_))           =  89 (10);

CaseClauses_:           cases (CaseClause,
                               cases (DefaultClause_, nil))         =  90 (10);
CaseClauses_:           cases (CaseClause, CaseClauses_)            =  91 (10);

DefaultClause_:         default_ (OptVarName_, OptExpr)             =  92 (10);

OptVarName_:            nil                                         =  93 (10);
OptVarName_:            varref                                      =  94 (10);

CaseClause:             case_ (var_type (OptVarName_, SequenceType),
                               OptExpr)                             =  95 (10);

SequenceType:           seq_ty (ItemType)                           =  96 (10);
SequenceType:           seq_ty (empty_ty)                           =  97 (10);

SingleType:             seq_ty (atom_ty (nil))                      =  98 (10);

ItemType:               NodeTest                                    =  99 (10);
ItemType:               item_ty (nil)                               = 100 (10);
ItemType:               atom_ty (nil)                               = 101 (10);
ItemType:               schm_elem                                   = 102 (10);
ItemType:               schm_attr                                   = 103 (10);

NodeTest:               node_ty (OptElemOrAttrType_)                = 104 (10);
NodeTest:               node_ty (lit_str)                           = 105 (10);
NodeTest:               node_ty (node_ty (OptElemOrAttrType_))      = 106 (10);

OptElemOrAttrType_:     nil                                         = 107 (10);
OptElemOrAttrType_:     ElemOrAttrType                              = 108 (10);

ElemOrAttrType:         req_ty (nil, nil)                           = 109 (10);
ElemOrAttrType:         req_ty (nil, named_ty)                      = 110 (10);
ElemOrAttrType:         req_ty (req_name, nil)                      = 111 (10);
ElemOrAttrType:         req_ty (req_name, named_ty)                 = 112 (10);

IfExpr:                 if_ (OptExpr,
                             then_else (OptExpr, OptExpr))          = 113 (10);

OrExpr:                 AndExpr                                     = 114 (10);
OrExpr:                 or (AndExpr, OrExpr)                        = 115 (10);

AndExpr:                ComparisonExpr                              = 116 (10);
AndExpr:                and (ComparisonExpr, AndExpr)               = 117 (10);

ComparisonExpr:         RangeExpr                                   = 118 (10);
ComparisonExpr:         eq (RangeExpr, RangeExpr)                   = 119 (10);
ComparisonExpr:         ne (RangeExpr, RangeExpr)                   = 120 (10);
ComparisonExpr:         lt (RangeExpr, RangeExpr)                   = 121 (10);
ComparisonExpr:         le (RangeExpr, RangeExpr)                   = 122 (10);
ComparisonExpr:         gt (RangeExpr, RangeExpr)                   = 123 (10);
ComparisonExpr:         ge (RangeExpr, RangeExpr)                   = 124 (10);
ComparisonExpr:         val_eq (RangeExpr, RangeExpr)               = 125 (10);
ComparisonExpr:         val_ne (RangeExpr, RangeExpr)               = 126 (10);
ComparisonExpr:         val_lt (RangeExpr, RangeExpr)               = 127 (10);
ComparisonExpr:         val_le (RangeExpr, RangeExpr)               = 128 (10);
ComparisonExpr:         val_gt (RangeExpr, RangeExpr)               = 129 (10);
ComparisonExpr:         val_ge (RangeExpr, RangeExpr)               = 130 (10);
ComparisonExpr:         is (RangeExpr, RangeExpr)                   = 131 (10);
ComparisonExpr:         ltlt (RangeExpr, RangeExpr)                 = 133 (10);
ComparisonExpr:         gtgt (RangeExpr, RangeExpr)                 = 134 (10);

RangeExpr:              AdditiveExpr                                = 135 (10);
RangeExpr:              range (RangeExpr, RangeExpr)                = 136 (10);

AdditiveExpr:           MultiplicativeExpr                          = 137 (10);
AdditiveExpr:           plus (AdditiveExpr, MultiplicativeExpr)     = 138 (10);
AdditiveExpr:           minus (AdditiveExpr, MultiplicativeExpr)    = 139 (10);

MultiplicativeExpr:     UnionExpr                                   = 140 (10);
MultiplicativeExpr:     mult (UnionExpr, MultiplicativeExpr)        = 141 (10);
MultiplicativeExpr:     div (UnionExpr, MultiplicativeExpr)         = 142 (10);
MultiplicativeExpr:     idiv (UnionExpr, MultiplicativeExpr)        = 143 (10);
MultiplicativeExpr:     mod (UnionExpr, MultiplicativeExpr)         = 144 (10);

UnionExpr:              IntersectExceptExpr                         = 145 (10);
UnionExpr:              union_ (IntersectExceptExpr, UnionExpr)     = 146 (10);

IntersectExceptExpr:    InstanceofExpr                              = 147 (10);
IntersectExceptExpr:    intersect (InstanceofExpr,
                                   IntersectExceptExpr)             = 148 (10);
IntersectExceptExpr:    except (InstanceofExpr,
                                IntersectExceptExpr)                = 149 (10);

InstanceofExpr:         TreatExpr                                   = 150 (10);
InstanceofExpr:         instof (TreatExpr, SequenceType)            = 151 (10);

TreatExpr:              CastableExpr                                = 152 (10);
TreatExpr:              treat (CastableExpr, SequenceType)          = 153 (10);

CastableExpr:           CastExpr                                    = 154 (10);
CastableExpr:           castable (CastExpr, SingleType)             = 155 (10);

CastExpr:               UnaryExpr                                   = 156 (10);
CastExpr:               cast (UnaryExpr, SingleType)                = 157 (10);

UnaryExpr:              ValueExpr                                   = 158 (10);
UnaryExpr:              uminus (ValueExpr)                          = 159 (10);
UnaryExpr:              uplus (ValueExpr)                           = 160 (10);

ValueExpr:              ValidateExpr                                = 161 (10);
ValueExpr:              PathExpr                                    = 162 (10);

ValidateExpr:           validate (OptExpr)                          = 163 (10);

PathExpr:               root_                                       = 164 (10);
PathExpr:               RelativePathExpr                            = 165 (10);

RelativePathExpr:       StepExpr                                    = 166 (10);
RelativePathExpr:       step (NodeTest)                             = 167 (1);
RelativePathExpr:       locpath (StepExpr, RelativePathExpr)        = 168 (10);

StepExpr:               Step_                                       = 169 (10);
StepExpr:               FilterExpr                                  = 170 (10);

FilterExpr:             PrimaryExpr                                 = 171 (10);
FilterExpr:             pred (RelativePathExpr, OptExpr)            = 172 (10);

Step_:                  step (NodeTest)                             = 173 (10);

PrimaryExpr:            Literal                                     = 174 (10);
PrimaryExpr:            varref                                      = 175 (10);
PrimaryExpr:            ParenthesizedExpr                           = 176 (10);
PrimaryExpr:            ContextItemExpr                             = 177 (10);
PrimaryExpr:            FunctionCall                                = 178 (10);
PrimaryExpr:            Constructor                                 = 179 (10);
PrimaryExpr:            OrderedExpr                                 = 180 (10);
PrimaryExpr:            UnorderedExpr                               = 181 (10);

Literal:                NumericLiteral                              = 182 (10);
Literal:                StringLiteral                               = 183 (10);

NumericLiteral:         IntegerLiteral                              = 184 (10);
NumericLiteral:         DecimalLiteral                              = 185 (10);
NumericLiteral:         DoubleLiteral                               = 186 (10);

IntegerLiteral:         lit_int                                     = 187 (10);
DecimalLiteral:         lit_dec                                     = 188 (10);
DoubleLiteral:          lit_dbl                                     = 189 (10);

StringLiteral:          lit_str                                     = 190 (10);

ParenthesizedExpr:      OptExpr                                     = 191 (10);

ContextItemExpr:        dot                                         = 192 (10);

FunctionCall:           fun_ref (OptFuncArgList_)                   = 193 (10);

OptFuncArgList_:        nil                                         = 194 (10);
OptFuncArgList_:        FuncArgList_                                = 195 (10);

FuncArgList_:           args (OptExpr, nil)                         = 196 (10);
FuncArgList_:           args (OptExpr, FuncArgList_)                = 197 (10);

OrderedExpr:            ordered (OptExpr)                           = 198 (10);
UnorderedExpr:          unordered (OptExpr)                         = 199 (10);

Constructor:            ElementConstructor                          = 200 (10);
Constructor:            AttributeConstructor                        = 201 (10);
Constructor:            TextConstructor                             = 202 (10);
Constructor:            CommentConstructor                          = 203 (10);
Constructor:            PIConstructor                               = 204 (10);
Constructor:            DocumentConstructor                         = 205 (10);

ElementConstructor:     elem (TagName, OptContentExpr)              = 206 (10);

AttributeConstructor:   attr (TagName, OptContentExpr)              = 207 (10);

TextConstructor:        text (OptContentExpr)                       = 208 (10);

CommentConstructor:     comment (OptContentExpr)                    = 209 (10);

PIConstructor:          pi (OptContentExpr)                         = 210 (10);

DocumentConstructor:    doc (OptContentExpr)                        = 211 (10);

TagName:                tag                                         = 212 (10);
TagName:                OptExpr                                     = 213 (10);

OptContentExpr:         OptExpr                                     = 214 (10);
OptContentExpr:         contseq (OptContentExpr, OptContentExpr)    = 215 (10);
OptContentExpr:         contseq (empty_seq, empty_seq)              = 216 (1);
OptContentExpr:         contseq (contseq (OptContentExpr,
                                          OptContentExpr),
                                 OptContentExpr)                    = 217 (1);

%%

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

static void relabel (PFpnode_t *p,  PFpnode_t **kids);

/* construct a nil node */
#define nil(loc) leaf (p_nil, (loc))

#define leaf(t,loc)       p_leaf ((t), (loc))
#define wire1(t,loc,a)    p_wire1 ((t), (loc), (a))
#define wire2(t,loc,a,b)  p_wire2 ((t), (loc), (a), (b))

static PFpnode_t * varref (PFqname_t q, PFloc_t loc);
static PFqname_t new_varname (char *prefix, unsigned int* varcount);

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFpnode_t * p, int goalnt, unsigned int *varcount)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpnode_t *   kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          rewritten;
    short         old_state_label;
    PFpnode_t *   c;

    do {
        /* determine rule that matches for this non-terminal */
        rule = PFnormalize_rule (STATE_LABEL (p), goalnt);

        /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */

        /* initialize the kids[] vector */
        for (unsigned short i = 0; i < MAX_KIDS; i++)
            kids[i] = NULL;

        /*
         * prepare recursive traversal: get information on leaf nodes of
         * this rule
         */
        nts = PFnormalize_nts[rule];
        PFnormalize_kids (p, rule, kids);

        /*
         * Recursively invoke compilation.  This means bottom-up compilation.
         */
        unsigned short i;
        rewritten = false;
        for (i = 0; nts[i]; i++)
            if ((rewritten = reduce (kids[i], nts[i], varcount)))
                break;  /* abort if a subtree was rewritten */

        if (rewritten) {
            /*
             * If a subtree has been rewritten, we have to
             *  - re-label that part of the tree, and
             *  - possibly propagate the `rewritten' information upwards.
             */

            /* remember our old state_label (so we know if it has changed) */
            old_state_label = STATE_LABEL(p);

            /*
             * Re-label current tree pattern.
             * (at most down to the pattern leaves, as they should already be
             * correctly labeled by the above reduce() call)
             */
            relabel (p, kids);

            /* If our own state_label has changed, notify our caller. */
            if (old_state_label != STATE_LABEL(p))
                return true;
        }
    } while (rewritten);

    rewritten = false;

    switch (rule) {
        /* DeclsImports: decl_imps (nil, DeclsImports) */
        case 8:
            *p = *R(p);
            rewritten = true;
            break;

        /* Expr: exprseq (empty_seq, ExprSingle) */
        case 53:
            *p = *(R(p));
            rewritten = true;
            break;

        /* Expr: exprseq (exprseq (Expr, OptExpr), OptExpr) */
        case 54:
            c = wire2 (p_exprseq, p->loc,
                       LL(p),
                       wire2 (p_exprseq, p->loc, LR(p), R(p)));
            *p = *c;
            relabel (p, kids);
            rewritten = true;
            break;

        /* QuantifiedExpr: some (binds (VarBinding, VarBindings),
                                 OptExpr) */
        case 85:
            /* fall through (treat some and every equivalently) */

        /* QuantifiedExpr: every (binds (VarBinding, VarBindings),
                                  OptExpr) */
        case 87:
            /*
             * Current parse tree situation: multi-bind some/every
             * (may bind any number n >= 2 variables):
             *
             * some/every $a as t1 in e1, $b as t2 in e2
             *   satisfies e0
             *
             *                         some/every
             *                         /       \
             *                   binds          e0
             *                  /    \
             *              bind    binds
             *            /    \    /   \
             *          vars   e1  bind  ...
             *         /   \       /  \
             *  var_type   nil   vars  e2
             *  /     \         /    \
             * $a     t1    var_type  nil
             *              /     \
             *             $b     t2
             *
             * Rewrite this into n nested single-bind some/every:
             *
             * some $a as t1 in e1 satisfies
             *   some $b as t2 in e2 satisfies e0
             *
             *
             *                 some/every
             *                 /        \
             *             binds         some/every
             *             /   \           /      \
             *           bind  nil      binds     e0
             *           /   \          /   \  
             *         vars  e1       bind  nil
             *        /    \          /   \
             *    var_type  nil     vars  e2
             *     /     \         /    \
             *    $a     t1    var_type  nil
             *                  /     \
             *                 $b     t2
             */
            c = wire2 (p->kind, p->loc,
                       L(p),
                       wire2 (p->kind, p->loc,
                              LR(p),
                              R(p)));
            LR(c) = nil (p->loc);
            *p = *c;
            relabel (p, kids);
            rewritten = true;
            break;

        /* TypeswitchExpr: typeswitch (OptExpr,
                                       cases (CaseClause,
                                              CaseClauses_)) */
        case 89:
        {
            /*
             * Unnest typeswitch expressions.
             *
             * Rewrite
             *
             *   typeswitch e1
             *     case $a as type1    return ret1
             *     case $b as type2    return ret2
             *     case $c as type3    return ret3
             *     ...
             *     default $d          return def
             *
             * to
             *
             *   typeswitch e1
             *     case $a as type1              return ret1
             *     default $v1 return
             *       typeswitch $v1
             *         case $b as type2          return ret2
             *         default $v2 return
             *           typeswitch $v2
             *             case $c as type3      return ret3
             *             default $v3 return
             *               typeswitch
             *                 ...
             *                   default $d      return def
             *
             * That is:
             *
             *              typeswitch
             *             /          \
             *           e1           cases
             *                       /     \
             *                   case       cases
             *                  /   \      /     \
             *           var_type  ret1   case    ...
             *          /     \          /    \      \   
             *         $a    type1   var_type  ret2   cases
             *                        /   \           /     \
             *                       $b  type2   default    nil
             *                                   /    \
             *                                 $d     def
             *
             * becomes
             *
             *          typeswitch
             *         /          \
             *       e1           cases
             *                   /     \
             *               case       cases
             *              /   \      /     \
             *        var_type  ret1 default  nil
             *        /     \        /     \
             *       $a    type1    $v1    typeswitch
             *                            /        \
             *                          $v1       cases
             *                                   /     \
             *                             var_type     ...
             *                            /      \         \
             *                           $b     type2      cases
             *                                            /    \
             *                                      default    nil
             *                                      /    \
             *                                     $d    def
             */
            PFqname_t v1 = new_varname ("tsw", varcount);

            c = wire2 (p_typeswitch, p->loc,
                       L(p),
                       wire2 (p_cases, R(p)->loc,
                              RL(p),
                              wire2 (p_cases, RR(p)->loc,
                                     wire2 (p_default, RR(p)->loc,
                                            varref (v1, RR(p)->loc),
                                            wire2 (p_typeswitch, RR(p)->loc,
                                                   varref (v1, RR(p)->loc),
                                                   RR(p))),
                                     nil (RR(p)->loc))));
            *p = *c;
            relabel (p, kids);
            rewritten = true;
        } break;

        /* RelativePathExpr: step (NodeTest) */
        case 167:
            /*
             * Make sure any relative path expression starts from
             * the context node `.'
             */
            c = wire2 (p_locpath, p->loc,
                       wire1 (p_step, p->loc, L(p)),
                       leaf (p_dot, p->loc));
            c->child[0]->sem.axis = p->sem.axis;
            *p = *c;
            relabel (p, kids);
            rewritten = true;
            break;

        /* OptContentExpr: contseq (empty_seq, empty_seq) */
        case 216:
            *p = *R(p);
            rewritten = true;
            break;

        /* OptContentExpr: contseq (contseq (OptContentExpr,
                                             OptContentExpr),
                                    OptContentExpr)              */
        case 217:
            c = wire2 (p_contseq, p->loc,
                       LL(p),
                       wire2 (p_contseq, p->loc, LR(p), R(p)));
            *p = *c;
            relabel (p, kids);
            rewritten = true;
            break;

        default:
            break;
    }

    return rewritten;
}

/*
 * Re-label a match pattern.
 *
 * Start with node @a p and relabel the subtree below. However, stop
 * if @a p is one of the pattern leaves, passed as the argument @a kids.
 */
static void 
relabel (PFpnode_t *p,  PFpnode_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    /* Relabel p's children. */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFnormalize_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        relabel (L(p), kids);
        STATE_LABEL(p) = PFnormalize_state (OP_LABEL(p),
                                            STATE_LABEL(L(p)),
                                            0);
    }
    else if (!L(p) && R(p)) {
        relabel (R(p), kids);
        STATE_LABEL(p) = PFnormalize_state (OP_LABEL(p),
                                            STATE_LABEL(R(p)),
                                            0);
    }
    else {
        relabel (L(p), kids);
        relabel (R(p), kids);
        STATE_LABEL(p) = PFnormalize_state (OP_LABEL(p),
                                            STATE_LABEL(L(p)),
                                            STATE_LABEL(R(p)));
    }

}

/**
 * Generate a parse tree node for a variable reference
 * @param q   QName for the variable
 * @param loc location information as #PFloc_t struct
 * @return    a parse tree node representing the variable
 */
static PFpnode_t *
varref (PFqname_t q, PFloc_t loc)
{
    PFpnode_t * n = p_leaf (p_varref, loc);
    
    n->sem.qname = q;
    
    return n;
}

/**
 * Generate a new (unique) variable name. This unique name is created
 * by incrementing a number that is appended to the variable name.
 * A prefix may be given that may not be longer than 3 characters
 * (the length of 'dot'). If no prefix is given (by passing NULL),
 * the default 'v' is used. The namespace for the newly created
 * variable is the internal Pathfinder namespace `pf:...' (PFns_pf).
 *
 * @param prefix The prefix to use. The variable name will be
 *   "[prefix]_[num]", where [prefix] is the prefix and [num] is
 *   a three digit, zero-padded integer number
 * @return A QName describing the new variable name
 */

static PFqname_t
new_varname (char *prefix, unsigned int* varcount)
{
    char                varname[sizeof("dot_000")];
    PFqname_t           qn;
    
    /* construct new variable name */
    if (prefix)
        snprintf (varname, sizeof ("dot_000"), "%3s_%03u", prefix, (*varcount)++);
    else
        snprintf (varname, sizeof ("dot_000"), "v_%03u", (*varcount)++);
    
    /* assign internal Pathfinder namespace `pf:...' */
    qn.ns  = PFns_pf;
    qn.loc = PFstrdup (varname);
    
    return qn;
}


/**
 * Normalize abstract syntax tree.
 *
 * Remove ambiguities in abstract syntax tree and bring it into
 * normal form.
 * 
 * @param r root of the abstract syntax tree (note that this
 *   might change during normalization)
 * @return the normalized abstract syntax tree
 */
PFpnode_t *
PFnormalize_abssyn (PFpnode_t *r)
{
    unsigned int varcount = 0; 
    assert (r);

    /* initiliaze global */
    varcount = 0;

    /* label the parse tree bottom up */
    PFnormalize_label (r);

    /* invoke rewriting */
    while (reduce (r, 1, &varcount))
        /* rewrite as long as there is something to do. */;

    return r;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
