%{

/**
 * @file
 *
 * Compile Core tree into relational algebra.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Initial Developer of the Original Code is the Database &
 * Information Systems Group at the University of Konstanz, Germany.
 * Portions created by the University of Konstanz are Copyright (C)
 * 2000-2005 University of Konstanz.  All Rights Reserved.
 *
 *
 * $Id$
 */ 


#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "oops.h"
#include "core.h"
#include "subtyping.h"
#include "qname.h"
/* #include "mem.h" */

/* PFvar_t */
#include "variable.h"

#include "algebra.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFcnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/core.h!
 */
%term var                =  1 /**< variable */
%term lit_str            =  2 /**< string literal */
%term lit_int            =  3 /**< integer literal */
%term lit_dec            =  4 /**< decimal literal */
%term lit_dbl            =  5 /**< double literal */
%term nil                =  6 /**< end-of-sequence marker */

%term seq                =  7 /**< sequence construction */
%term ordered            =  8
%term unordered          =  9

%term let                = 10 /**< let expression */
%term letbind            = 11 /**< binding part of a let expression */
%term for_               = 12 /**< for expression */
%term forbind            = 13 /**< binding part of a for expression */
%term forvars            = 14 /**< variable pair (var + pos. var) of a for */

%term orderby            = 15 /**< orderby clause */
%term orderspecs         = 16 /**< list of order specs */

%term apply              = 17 /**< function application */
%term arg                = 18 /**< function argument (list) */

%term typesw             = 19 /**< typeswitch clause */
%term cases              = 20 /**< case concatenation for typeswitch */
%term case_              = 21 /**< single case for typeswitch */
%term default_           = 22 /**< default branch in typeswitch */
%term seqtype            = 23 /**< a SequenceType */
%term seqcast            = 24 /**< cast along <: */
/* %term proof           = 25      typechecker only: prove <: relationship */
/* %term subty           = 26      subtype condition for proof() */
/* %term stattype        = 27      static type of expression. Required for
                                   fs:convert-operand. Will be removed during
                                   typechecking and replaced by seqtype, as
                                   soon as types are known. */

%term if_                = 28 /**< if-then-else conditional */
%term then_else          = 29 /**< then- and else-branches of an
                                   if-then-else conditional */

%term locsteps           = 30 /**< path of location steps only */
%term ancestor           = 31 /**< the parent, the parent's parent,... */
%term ancestor_or_self   = 32 /**< the parent, the parent's parent,... + self */
%term attribute          = 33 /**< attributes of the context node */
%term child              = 34 /**< children of the context node */
%term descendant         = 35 /**< children, children's children,... + self */
%term descendant_or_self = 36 /**< children, children's children,... */
%term following          = 37 /**< nodes after current node (document order) */
%term following_sibling  = 38 /**< all following nodes with same parent */
%term parent             = 39 /**< parent node (exactly one or none) */
%term preceding          = 40 /**< nodes before context node (document order) */
%term preceding_sibling  = 41 /**< all preceding nodes with same parent */
%term self               = 42 /**< the context node itself */

%term elem               = 43 /**< the element constructor */
%term attr               = 44 /**< the attribute constructor */
%term text               = 45 /**< the text constructor */
%term doc                = 46 /**< the document constructor */
%term comment            = 47 /**< the comment constructor */
%term pi                 = 48 /**< the processing-instruction constructor */
%term tag                = 49 /**< the tagname for elem. and attr. constr. */

%term true_              = 50 /**< built-in function `fn:true ()' */
%term false_             = 51 /**< built-in function `fn:false ()' */
%term empty              = 52 /**< built-in function `empty' */
%term main               = 53 /**< tree root
                                   Separates function declarations from
                                   the query body. */
%term fun_decls          = 54 /**< list of function declarations */
%term fun_decl           = 55 /**< function declaration */
%term params             = 56 /**< function declaration parameter list */
%term param              = 57 /**< function declaration parameter */
%term cast               = 58 /**< XQuery `cast as' operation */

%%

Query:              main (FunctionDecls, CoreExpr)              =   1 (10);
Query:              CoreExpr                                    =   2 (10);

CoreExpr:           Atom                                        =   3 (10);
CoreExpr:           SequenceTypeCast                            =   4 (10);

CoreExpr:           for_ (forbind (forvars (var, OptVar),
                                   Atom),
                          CoreExpr)                             =   5 (10);

OptVar:             var                                         =   6 (10);
OptVar:             nil                                         =   7 (10);

CoreExpr:           let (letbind (var, CoreExpr), CoreExpr)     =   8 (10);

CoreExpr:           if_ (Atom, then_else (CoreExpr, CoreExpr))  =   9 (10);

CoreExpr:           seq (Atom, Atom)                            =   10 (10);

CoreExpr:           typesw (Atom,
                            cases (case_ (seqtype,
                                          CoreExpr),
                                   default_ (CoreExpr)))        =  11 (10);

SequenceTypeCast:   seqcast (seqtype, CoreExpr)                 =  12 (10);

/* `proof' nodes should no longer be in the Core tree.
 * They are resolved by the type checker.
CoreExpr:           proof (subty (CoreExpr, seqtype),
                           CoreExpr)                            =  13 (10);
 */

/* type checker only
SequenceType:       stattype (Atom)                             =  13 (10);
 */

CoreExpr:           locsteps (LocationStep, CoreExpr)           =  14 (10);

/* Hmm... What does this mean, actually?
CoreExpr:           LocationStep                                =  15 (10);
 */

LocationStep:       ancestor (seqtype)                          =  15 (10);
LocationStep:       ancestor_or_self (seqtype)                  =  16 (10);
LocationStep:       attribute (seqtype)                         =  17 (10);
LocationStep:       child (seqtype)                             =  18 (10);
LocationStep:       descendant (seqtype)                        =  19 (10);
LocationStep:       descendant_or_self (seqtype)                =  20 (10);
LocationStep:       following (seqtype)                         =  21 (10);
LocationStep:       following_sibling (seqtype)                 =  22 (10);
LocationStep:       parent (seqtype)                            =  23 (10);
LocationStep:       preceding (seqtype)                         =  24 (10);
LocationStep:       preceding_sibling (seqtype)                 =  25 (10);
LocationStep:       self (seqtype)                              =  26 (10);

CoreExpr:           apply (FunctionArgs)                        =  29 (10);

FunctionArgs:       nil                                         =  30 (10);
FunctionArgs:       arg (FunctionArg, FunctionArgs)             =  31 (10);

FunctionArg:        Atom                                        =  32 (10);

CoreExpr:           elem (TagName, CoreExpr)                    =  33 (10);

CoreExpr:           attr (TagName, CoreExpr)                    =  34 (10);

TagName:            tag                                         =  35 (10);
TagName:            CoreExpr                                    =  36 (10);

CoreExpr:           text (CoreExpr)                             =  37 (10);
CoreExpr:           doc (CoreExpr)                              =  38 (10);
CoreExpr:           comment (CoreExpr)                          =  39 (10);
CoreExpr:           pi (CoreExpr)                               =  40 (10);

CoreExpr:           ordered (CoreExpr)                          =  41 (10);
CoreExpr:           unordered (CoreExpr)                        =  42 (10);

CoreExpr:           orderby (OrderSpecs, CoreExpr)              =  43 (10);

OrderSpecs:         orderspecs (CoreExpr, nil)                  =  44 (10);
OrderSpecs:         orderspecs (CoreExpr, OrderSpecs)           =  45 (10);

CoreExpr:           cast (seqtype, CoreExpr)                    =  46 (10);

Atom:               var                                         =  47 (10);
Atom:               LiteralValue                                =  48 (10);

LiteralValue:       lit_str                                     =  49 (10);
LiteralValue:       lit_int                                     =  50 (10);
LiteralValue:       lit_dec                                     =  51 (10);
LiteralValue:       lit_dbl                                     =  52 (10);
LiteralValue:       true_                                       =  53 (10);
LiteralValue:       false_                                      =  54 (10);
LiteralValue:       empty                                       =  55 (10);

FunctionDecls:      nil                                         =  62 (10);
FunctionDecls:      fun_decls (FunctionDecl, FunctionDecls)     =  63 (10);

FunctionDecl:       fun_decl (ParamList, FunctionBody)          =  64 (10);

ParamList:          nil                                         =  65 (10);
ParamList:          params (FunParam, ParamList)                =  66 (10);

FunctionBody:       CoreExpr                                    =  67 (10);

FunParam:           param (seqtype, var)                        =  68 (10);

%%

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))
#define LLR(p) R(L(L(p)))
#define RRR(p) R(R(R(p)))
#define LLL(p) L(L(L(p)))
#define LLLL(p) L(L(L(L(p))))
#define LLLLL(p) L(L(L(L(L(p)))))
#define LLLLR(p) R(L(L(L(L(p)))))
#define LLLR(p) R(L(L(L(p))))
#define RLL(p) L(L(R(p)))
#define RLLR(p) R(L(L(R(p))))
#define RLLL(p) L(L(L(R(p))))
#define RLR(p) R(L(R(p)))
#define RRLL(p) L(L(R(R(p))))
#define RRLR(p) R(L(R(R(p))))

/** Algebra equivalent of a Core tree node */
#define A(p) ((p)->alg)

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

/** mnemonic algebra constructors */
#include "logical_mnemonic.h"

/**
 * Variable environment (Gamma in our papers)
 */
static PFarray_t  *env = NULL;

/**
 * Current loop relation
 */
static PFla_op_t *loop = NULL;

/* Constructor for environment entry */
static PFla_env_t enventry (PFvar_t *var, PFla_op_t *result, PFarray_t *doc);

/* worker to implement type tests */
static PFla_op_t *type_test (PFty_t ty, PFla_pair_t e, PFla_op_t *loop);

static PFla_op_t *locstep_dummy (PFalg_axis_t axis, PFty_t seqty);

/**
 * Function parameter variable names (from PFfun_t).
 * Required to translate function calls.
 */
static PFarray_t *fun_args = NULL;

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFcnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFcnode_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */

    /* determine rule that matches for this non-terminal */
    rule = PFcore2alg_rule (STATE_LABEL (p), goalnt);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFcore2alg_nts[rule];
    PFcore2alg_kids (p, rule, kids);

    /*
     * Few translation rules require top-down processing. We figure
     * them out here and skip the recursive compilation. The respective
     * rules will explicitly trigger the compilation of their kids.
     */
    switch (rule) {
        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:

        /* CoreExpr:           for_ (forbind (forvars (var, nil),
                                              Atom),
                                     CoreExpr) */
        case 5:

        /* CoreExpr:           let (letbind (var, CoreExpr), CoreExpr) */
        case 8:

        /* CoreExpr:           typesw (Atom,
                                       cases (case_ (seqtype,
                                                     CoreExpr),
                                              default_ (CoreExpr))) */
        case 11:

        /* CoreExpr:           apply (FunctionArgs) */
        case 29:
        /* FunctionArgs:       arg (FunctionArg, FunctionArgs) */
        case 31:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     */
    if (!topdown)
        for (unsigned short i = 0; nts[i]; i++)
            reduce (kids[i], nts[i]);

    switch (rule) {

        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:
            /* TOPDOWN */

            /*
             * Only the real XQuery expression is of interest, not the
             * function declaration part. Apply serialize() to the
             * XQuery Core result.
             */
            reduce (kids[1], nts[1]);
            A(p) = (PFla_pair_t) {
                     .rel = serialize (PFla_set_to_la (A(R(p)).frag),
                                       A(R(p)).rel),
                     .frag = NULL };
            break;

        /* Query:              CoreExpr */
        case 2:
            /*
             * Defining CoreExpr also as a top-level non-terminal
             * allows us to recursively invoke matching for function
             * calls.
             */
            break;

        /* CoreExpr:           Atom */
        case 3:
            break;
            
        /* CoreExpr:           SequenceTypeCast */
        case 4:
            break;

        /* CoreExpr:           for_ (forbind (forvars (var, nil),
                                              Atom),
                                     CoreExpr) */
        case 5:
        {   /* TOPDOWN */

            /*
             * for $v in e1 return e2                    OR
             * for $v at $p in e1 return e2
             *
             * Given the current environment (which may or may not contain
             * bindings), the current loop relation and delta with e1
             * already compiled:
             * - declare variable $v by loop lifting the result of q1,
             *(- declare variable $p if present)
             * - create a new loop relation and
             * - a new map relation,
             * - as the for expression opens up a scope, update all existing
             *   bindings to the new scope and add the binding of $v
             * Given the updated environment and the new loop relation
             * compile e2. Return the (possibly intermediate) result.
             *
             * env,loop: e1 => q1,delta1
             *
             *        pos
             * q(v) = --- X proj_iter:inner,item(row_inner:<iter,pos> q1)
             *         1
             *
             * loop(v) = proj_iter(q(v))
             *
             * map = proj_outer:iter,inner(row_inner:<iter,pos> q1)
             *
             * updated_env,(v->q(v)) e updated_env,loop(v): e2 => (q2,delta2)
             * -----------------------------------------------------------------
             * env,loop: for &v in e1 return e2 =>
             * (proj_iter:outer, pos:pos1,item
             *   (row_pos1:<iter,pos>/outer (q2 |X| (iter = inner)map)), delta2)
             */
            PFla_op_t   *var;
            PFla_op_t   *opt_var;
            PFla_op_t   *old_loop; 
            PFla_op_t   *map;
            PFarray_t    *old_env;
            unsigned int  i;
            PFla_env_t   e;
            PFla_op_t   *new_bind;

            /* initiate translation of e1 */
            reduce (kids[1], nts[1]);

            /* translate $v */
            var = cross (lit_tbl (attlist (att_pos),
                                  tuple (lit_nat (1))),
                         project (rownum (A(LR(p)).rel,
                                          att_inner,
                                          sortby (att_iter, att_pos),
                                          aat_NULL),
                                  proj (att_iter, att_inner),
                                  proj (att_item, att_item)));

            /* save old environment */
            old_env = env;
            env = PFarray (sizeof (PFla_env_t));

            /* insert $v and "its document" into NEW environment */
            *((PFla_env_t *) PFarray_add (env))
                = enventry (LLL(p)->sem.var, var, A(LR(p)).frag);

            /* save old loop operator */
            old_loop = loop;

            /* create new loop operator */
            loop = project (var, proj (att_iter, att_iter));

            /* create map relation. */
            map = project (rownum(A(LR(p)).rel,
                                  att_inner,
                                  sortby (att_iter, att_pos),
                                  aat_NULL),
                     proj (att_outer, att_iter),
                     proj (att_inner, att_inner));

            /*
             * handle optional variable ($p); we need map operator
             * for this purpose
             * note that the rownum () routine is used to create
             * the 'item' column of $p's operator; since this
             * column must be of type integer instead of nat, we
             * cast it accordingly
             */
            if (LLR(p)->kind == c_var) {
                assert (LLR(p)->sem.var);
                opt_var = cross (lit_tbl (attlist (att_pos),
                                          tuple (lit_nat (1))),
                                 cast (project (rownum (map, att_item,
                                                        sortby (att_inner),
                                                        att_outer),
                                                proj (att_iter, att_inner),
                                                proj (att_item, att_item)),
                                       att_item, aat_int));

                /* insert $p into NEW environment */
                *((PFla_env_t *) PFarray_add (env)) =
                    enventry (LLR(p)->sem.var, opt_var, PFla_empty_set ());
            }

            /* update all variable bindings in old environment and put
             * them into new environment */
            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));
                new_bind = project (eqjoin (e.rel, map, att_iter, att_outer),
                                   proj (att_iter, att_inner),
                                   proj (att_pos, att_pos),
                                   proj (att_item, att_item));
                *((PFla_env_t *) PFarray_add (env)) =
                    enventry (e.var, new_bind, e.frag);
            }

            /* translate e2 under the specified conditions (updated
             * environment, loop(v))
             */
            reduce (kids[2], nts[2]);

            /* restore old loop */
            loop = old_loop;

            /* restore old environment */
            env = old_env;

            /* compute result using old env and old loop. */
            A(p) = (struct PFla_pair_t) {
                     .rel = project (rownum (eqjoin(A(R(p)).rel,
                                                    map, att_iter, att_inner),
                                             att_pos1,
                                             sortby (att_iter, att_pos),
                                             att_outer),
                                     proj (att_iter, att_outer),
                                     proj (att_pos, att_pos1),
                                     proj (att_item, att_item)),
                     .frag = A(R(p)).frag };
        } break;

        /* OptVar:             var */
        case 6:
            /* (will never be called anyway, Rule 4 is top-down) */
            break;

        /* OptVar:             nil */
        case 7:
            /* (will never be called anyway, Rule 4 is top-down) */
            break;

        /* CoreExpr:           let (letbind (var, CoreExpr), CoreExpr) */
        case 8:
        {   /* TOPDOWN */

            /*
             * let $v := e1 return e2
             *
             * Translate e1 in the current environment, translate the
             * variable $v and add the resulting binding to the environment.
             * Compile e2 in the enriched environment.
             *
             * env,loop: e1 => (q1,delta1)
             *
             * env + (v -> q(v)),loop: e2 => (q2,delta2)
             * ------------------------------------------------------------------
             * env,loop: let $v := e1 return e2 => (q2,delta2)
             *
             * NB: Translation of variable is:
             *
             *         /pos                                                   \
             * q(v) = | --- X proj_iter:inner,item(row_inner:<iter,pos>(q(e1)))|
             *         \ 1                                                    /
             *
             */

            /* initiate translation of e1 */
            reduce (kids[0], nts[0]);

            /* assign result of e1 to $v, i.e. add resulting binding to
             * environment together with the currently live nodes
             */
            *((PFla_env_t *) PFarray_add (env))
                = enventry (LL(p)->sem.var, A(LR(p)).rel, A(LR(p)).frag);

            /* now translate e2 in the new context */
            reduce (kids[1], nts[1]);

            /* FIXME: Restore old variable environment? */

            A(p) = A(R(p));
        } break;

        /* CoreExpr:           if_ (Atom, then_else (CoreExpr, CoreExpr)) */
        case 9:
        {   /* TOPDOWN */

            /*
             * if e1 then e2 else e3
             *
             * NB: SEL: select those rows where column value != 0
             *     
             *
             * {..., $v -> q(v), ...},loop: e1 => q1,delta1
             * loop2 = proj_iter (SEL item q1)
             * loop3 = proj_iter (SEL res (NOT res item q1))
             * {..., $v -> 
             *  proj_iter,pos,item (q(v)|X|(iter=iter1)(proj_iter1:iter loop2)),
             *                      ...},loop2: e2 => (q2,delta2) 
             * {..., $v ->
             *  proj_iter,pos,item (q(v)|X|(iter=iter1)(proj_iter1:iter loop3)),
             *                      ...},loop3: e3 => (q3,delta3) 
             * -----------------------------------------------------------------
             * {..., $v -> q(v), ...},loop,delta: if e1 then e2 else e3 =>
             *                        (q2 U q3, delta2 U delta3)
             */
            PFla_op_t *old_loop;
            PFarray_t  *old_env;
            unsigned int i;
            PFla_env_t e;
            PFla_op_t *new_bind;

            /* initiate translation of e1 */
            reduce (kids[0], nts[0]);

            /* save old loop operator */
            old_loop = loop;

            /* create loop2 relation */
            loop = project (select_ (A(L(p)).rel, att_item),
                            proj (att_iter, att_iter));

            /* save old environment */
            old_env = env;

            /* update the environment for translation of e2 */
            env = PFarray (sizeof (PFla_env_t));

            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));
                new_bind = project (eqjoin (e.rel,
                                            project (loop,
                                                     proj (att_iter1, att_iter)),
                                            att_iter,
                                            att_iter1),
                                    proj (att_iter, att_iter),
                                    proj (att_pos, att_pos),
                                    proj (att_item, att_item));
                *((PFla_env_t *) PFarray_add (env))
                    = enventry (e.var, new_bind, e.frag);
            }

            /* translate e2 */
            reduce (kids[1], nts[1]);

            /* create loop3 relation */
            loop = project (select_ (not (A(L(p)).rel,
                                         att_res,
                                         att_item),
                                    att_res),
                            proj (att_iter, att_iter));

            /* update the environment for translation of e3 */
            env = PFarray (sizeof (PFla_env_t));

            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));
                new_bind = project (eqjoin (e.rel,
                                            project (loop,
                                                     proj (att_iter1, att_iter)),
                                            att_iter,
                                            att_iter1),
                                    proj (att_iter, att_iter),
                                    proj (att_pos, att_pos),
                                    proj (att_item, att_item));
                *((PFla_env_t *) PFarray_add (env)) =
                    enventry (e.var, new_bind, e.frag);
            }

            /* translate e3 */
            reduce (kids[2], nts[2]);

            /* reset loop relation and environment */
            loop = old_loop;
            env = old_env;

            A(p) = (struct  PFla_pair_t) {
                     .rel  = disjunion (A(RL(p)).rel, A(RR(p)).rel),
                     .frag = PFla_set_union (A(RL(p)).frag, A(RR(p)).frag) };

        } break;

        /* CoreExpr:           seq (Atom, Atom) */
        case 10:
        {
            /*
             *     env,loop: e1 => q1,delta1      env,loop: e2 => q2,delta2
             * -----------------------------------------------------------------
             *                        env,loop: (e1, e2) =>
             *
             *                      proj_iter,pos:pos1,item
             *  /                          / ord       \     / ord       \ \
             * |  row_pos1:<ord,pos>/iter | ----- X q1  | U | ----- X q2  | |
             *  \                          \  1        /     \  2        / /
             *
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = project (rownum (
                             disjunion (cross (lit_tbl (attlist (att_ord),
                                                        tuple (lit_nat (1))),
                                               A(L(p)).rel),
                                        cross (lit_tbl (attlist (att_ord),
                                                        tuple (lit_nat (2))),
                                               A(R(p)).rel)),
                             att_pos1, sortby (att_ord, att_pos), att_iter),
                         proj (att_iter, att_iter),
                         proj (att_pos, att_pos1),
                         proj (att_item, att_item)),
                     .frag = PFla_set_union (A(L(p)).frag, A(R(p)).frag) };
        } break;

        /* CoreExpr:           typesw (Atom,
                                       cases (case_ (seqtype,
                                                     CoreExpr),
                                              default_ (CoreExpr))) */
        case 11:
        {   /* TOPDOWN */

            /*
             * CoreExpr1 is the expression to be switched. CoreExpr2 
             * compiles one (the current) case branch. CoreExpr3 is
             * either another typeswitch representing the next case
             * branch or the default branch of the overall typeswitch.
             *
             * A lot of work for this translation is captured in the
             * function type_test(). Given an algebra expression and
             * an XQuery sequence type, it will return a relation
             * with columns `iter' and `subty', with `subty' set to
             * true or false, depending on whether for this iteration
             * the sequence type test succeeds or not.
             *
             * env,loop: e1 => q1,delta1
             * tested_q1 = type_test (ty, q1, loop)
             * 
             * -- translate stuff in the `case' branch
             *  loop2 = proj_iter (select_subty (tested_q1))
             *  {..., $v -> proj_iter,pos,item (
             *    qv |X| (iter = iter1) (proj_iter1:iter loop2))},
             *   loop2: e2 => q2,delta2
             * 
             * -- and in the `default' branch
             *  loop3 = proj_iter (select_notsub (not_notsub:subty (tested_q1)))
             *  {..., $v -> proj_iter,pos,item (
             *    qv |X| (iter = iter1) (proj_iter1:iter loop3))},
             *   loop3: e3 => q3,delta3
             * 
             * ---------------------------------------------------------------
             *  env,loop:
             *  typeswitch (e1) case ty return e2 default return e3 =>
             *    (q2 U q3, delta2 U delta3)
             *
             * NB: the TYPE operator creates a new column of type boolean;
             * it examines whether the specified column is of given type "ty";
             * if this is the case, it sets the new column to true, otherwise
             * to false.
             */

            PFla_op_t   *tested_q1;  /* true/false if iterat. satisfies test */
            PFarray_t   *old_env;    /* backup of surrounding environment */
            PFla_op_t   *old_loop;   /* backup of surrounding loop relation */
            PFla_env_t   e;          /* helper variable */
            PFla_op_t   *new_bind;   /* helper variable */
            unsigned int  i;

            /* translate CoreExpr1 */
            reduce (kids[0], nts[0]);

            tested_q1 = type_test (RLL(p)->sem.type, A(L(p)), loop);

            /* translate stuff in the `case' branch */

            /* map `loop' relation */
            old_loop = loop;
            loop = project (select_ (tested_q1, att_subty),
                            proj (att_iter, att_iter));

            /* map variable environment */
            old_env = env;
            env = PFarray (sizeof (PFla_env_t));

            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));
                new_bind =
                    project (eqjoin (e.rel,
                                     project (loop, proj (att_iter1, att_iter)),
                                     att_iter, att_iter1),
                             proj (att_iter, att_iter),
                             proj (att_pos, att_pos),
                             proj (att_item, att_item));
                *((PFla_env_t *) PFarray_add (env))
                    = enventry (e.var, new_bind, e.frag);
            }

            /* translate CoreExpr2 */
            reduce (kids[1], nts[1]);

            /* translate stuff in the `default' branch (equivalently) */

            /* map `loop' relation */
            loop = project (select_ (not (tested_q1, att_notsub, att_subty),
                                     att_notsub),
                            proj (att_iter, att_iter));

            env = PFarray (sizeof (PFla_env_t));

            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));
                new_bind =
                    project (eqjoin (e.rel,
                                     project (loop, proj (att_iter1, att_iter)),
                                     att_iter, att_iter1),
                             proj (att_iter, att_iter),
                             proj (att_pos, att_pos),
                             proj (att_item, att_item));
                *((PFla_env_t *) PFarray_add (env))
                    = enventry (e.var, new_bind, e.frag);
            }

            /* translate CoreExpr3 */
            reduce (kids[2], nts[2]);

            /* reset loop relation and environment */
            loop = old_loop;
            env = old_env;

            A(p) = (struct PFla_pair_t) {
                .rel  = disjunion (A(RLR(p)).rel, A(RRL(p)).rel),
                .frag = PFla_set_union (A(RLR(p)).frag, A(RRL(p)).frag)
            };

        } break;

        /* SequenceTypeCast:   seqcast (seqtype, CoreExpr) */
        case 12:
            /*
             * `seqcast' nodes are only introduced for static typing.
             * They are not meant to be executed.
             */
            A(p) = A(R(p));
            break;

        /* CoreExpr:           locsteps (LocationStep, CoreExpr) */
        case 14:
            /*
             *                  env, loop: e => (q(e), delta)
             * ------------------------------------------------------------
             *                       env, loop: e/a::n =>
             * (row_pos<item>/iter (SCJ (proj_iter,item (q(e)), delta)), delta)
             *
             * A(L(p)).rel contains a dummy node with information on the
             * location step. Will be read out in PFla_scjoin().
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = rownum (scjoin (PFla_set_to_la (A(R(p)).frag),
                                            project (A(R(p)).rel,
                                                     proj (att_iter, att_iter),
                                                     proj (att_item, att_item)),
                                            A(L(p)).rel),
                                    att_pos, sortby (att_item), att_iter),
                     .frag = A(R(p)).frag };

            break;

        /* LocationStep:       ancestor (seqtype) */
        case 15:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_anc, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       ancestor_or_self (seqtype) */
        case 16:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_anc_s, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       attribute (seqtype) */
        case 17:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_attr, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       child (seqtype) */
        case 18:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_chld, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       descendant (seqtype) */
        case 19:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_desc, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       descendant_or_self (seqtype) */
        case 20:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_desc_s, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       following (seqtype) */
        case 21:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_fol, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       following_sibling (seqtype) */
        case 22:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_fol_s, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       parent (seqtype) */
        case 23:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_par, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       preceding (seqtype) */
        case 24:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_prec, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       preceding_sibling (seqtype) */
        case 25:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_prec_s, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* LocationStep:       self (seqtype) */
        case 26:
            /* Set up dummy node to be used in rule 14 */
            A(p) = (PFla_pair_t)
                     { .rel  = locstep_dummy (alg_self, L(p)->sem.type),
                       .frag = NULL };
            break;

        /* CoreExpr:           apply (FunctionArgs) */
        case 29:
        {   /* TOPDOWN*/

            /*
             * Function application (user-defined functions):
             *
             * (1) Save current variable environment.
             * (2) Enter bindings for all variables in the function
             *     signature to the variable environment.
             * (3) Invoke compilation for the function body (accessible
             *     via the PFfun_t struct).
             * (4) Restore variable environment.
             */

            PFarray_t  *old_env;
            PFarray_t  *old_fun_args;

            /* (1) Save current variable environment and create a new one. */
            old_env = env;

            env = PFarray (sizeof (PFla_env_t));

            for (unsigned int i = 0; i < PFarray_last (old_env); i++)
                *((PFla_env_t *) PFarray_add (env))
                    = *((PFla_env_t *) PFarray_at (old_env, i));

            /* (2) Enter bindings for function parameters.
             *     We do this by reducing our child nodes in a
             *     top-down fashion.
             */

            old_fun_args = fun_args;

            /* We will collect the argument values here */
            fun_args = PFarray (sizeof (struct PFla_pair_t));

            /* Top-down processing puts all argument values into this array */
            reduce (kids[0], nts[0]);

            /* All function arguments are now in the array `fun_args'. */

            if (p->sem.fun->builtin) {
                /*
                 * For built-in functions use this array to call the
                 * algebraic representation of the function (builtins.c)
                 */
                if (!p->sem.fun->alg)
                    PFoops (OOPS_FATAL,
                            "Algebra implementation for function `%s' unknown.",
                            PFqname_str (p->sem.fun->qname));

                A(p) = p->sem.fun->alg (loop, fun_args->base);

            }
            else {
                /*
                 * Otherwise bind parameter variables to the argument
                 * values and invoke compilation for function body.
                 */
                for (unsigned int i = 0; i < p->sem.fun->arity; i++) {

                    PFla_pair_t curr_arg
                        = *(PFla_pair_t *) PFarray_at (fun_args, i);

                    *((PFla_env_t *) PFarray_add (env))
                        = enventry (p->sem.fun->params[i],
                                    curr_arg.rel, curr_arg.frag);
                }
                                
                fun_args = old_fun_args;

                /* (3) Invoke compilation of the function body. */
                reduce (p->sem.fun->core, 1);

                A(p) = A(p->sem.fun->core);
            }

            /* (4) Restore variable environment. */
            env = old_env;

        } break;

        /* FunctionArgs:       nil */
        case 30:
            break;

        /* FunctionArgs:       arg (FunctionArg, FunctionArgs) */
        case 31:
        {   /* TOPDOWN */

            /* translate the argument itself */
            reduce (kids[0], nts[0]);

            /* Append the new argument to function argument list */
            *((PFla_pair_t *) PFarray_add (fun_args)) = A(L(p));

            /* go on to next arguments */
            reduce (kids[1], nts[1]);

        } break;

        /* FunctionArg:        Atom */
        case 32:
            break;

        /* CoreExpr:           elem (TagName, CoreExpr) */
        case 33:
        {
            /*
             * CoreExpr (q2) evaluates to a sequence of nodes. TagName (q1)
             * is the name of a new node which becomes the common root of
             * the constructed nodes.
             *
             * env, loop: e1 => q1, doc (q1)
             * env, loop: e2 => q2, doc (q2)
             *
             * n = element (doc (q2), q1, q2)
             * -----------------------------------------------------------------
             * env, loop: element e1 {e2} =>
             *                                               pos
             * result:    (proj_iter,item:pre (roots (n))) x -----
             *                                                1
             *                                                          zero
             *    where roots (n) = sel (res)(= res:(level, zero) (n x ------))
             *                                                            0
             *
             * frag:       proj_pre,size,level,kind,prop,frag (n)
             */
            PFla_op_t *elem = element (PFla_set_to_la (A(R(p)).frag),
                                        A(L(p)).rel, A(R(p)).rel);

            A(p) = (struct  PFla_pair_t) {
                     .rel = roots (elem),
                     .frag = PFla_set (fragment (elem))};
        } break;

        /* CoreExpr:           attr (TagName, CoreExpr) */
        case 34:
        {
            /*
             * CoreExpr (q2) evaluates to a sequence of attributes. TagName
             * (q1) is the name of a new node which becomes the common root
             * of the constructed attributes.
             *
             * env, loop: e1 => q1, doc (q1)
             * env, loop: e2 => q2, doc (q2)
             *
             * n = attribute (doc (q2), q1, q2)
             * ----------------------------------------------------------------
             * env, loop: attribute e1 {e2} =>
             *                                               pos
             * result:    (proj_iter,item:pre (roots (n))) x -----
             *                                                1
             *                                                          zero
             *    where roots (n) = sel (res)(= res:(level, zero) (n x ------))
             *                                                            0
             *
             * frag:       proj_pre,size,level,kind,prop,frag (n)
             */
            PFla_op_t *attr = attribute (A(L(p)).rel, A(R(p)).rel);

            A(p) = (struct  PFla_pair_t) {
                     .rel = roots (attr),
                     .frag = PFla_set (fragment (attr))};
        }

        /* TagName:            tag */
        case 35:
            A(p) = (struct PFla_pair_t) {
                .rel = cross (loop,
                              lit_tbl (attlist (att_pos, att_item),
                                       tuple (lit_nat (1),
                                              lit_qname (p->sem.qname)))),
                .frag = PFla_empty_set () };
            break;

        /* TagName:            CoreExpr */
        case 36:
            break;

        /* CoreExpr:           text (CoreExpr) */
        case 37:
        {
            /*
             * env, loop: e => q, doc (q)
             *
             * n = textnode (doc (q), q)
             * ----------------------------------------------------------------
             * env, loop: textnode e =>
             *                                               pos
             * result:    (proj_iter,item:pre (roots (n))) x -----
             *                                                1
             *                                                          zero
             *    where roots (n) = sel (res)(= res:(level, zero) (n x ------))
             *                                                            0
             *
             * frag:       proj_pre,size,level,kind,prop,frag (n)
             */
            PFla_op_t *textnode = textnode (A(L(p)).rel);

            A(p) = (struct  PFla_pair_t) {
                     .rel = roots (textnode),
                     .frag = PFla_set (fragment (textnode))};
        } break;

        /* CoreExpr:           doc (CoreExpr) */
        case 38:
        {
            /*
             * env, loop: e => q, doc (q)
             *
             * n = docnode (doc (q), q)
             * ----------------------------------------------------------------
             * env, loop: docnode e =>
             *                                               pos
             * result:    (proj_iter,item:pre (roots (n))) x -----
             *                                                1
             *                                                          zero
             *    where roots (n) = sel (res)(= res:(level, zero) (n x ------))
             *                                                            0
             *
             * frag:       proj_pre,size,level,kind,prop,frag (n)
             */
            PFla_op_t *docnode = docnode (PFla_set_to_la (A(L(p)).frag),
                                           A(L(p)).rel);

            A(p) = (struct  PFla_pair_t) {
                     .rel = roots (docnode),
                     .frag = PFla_set (fragment (docnode))};
        } break;

        /* CoreExpr:           comment (CoreExpr) */
        case 39:
            /* FIXME: to do */
            PFoops (OOPS_FATAL, "not implemented");
            break;

        /* CoreExpr:           pi (CoreExpr) */
        case 40:
            /* FIXME: to do */
            PFoops (OOPS_FATAL, "not implemented");
            break;

        /* CoreExpr:           ordered (CoreExpr) */
        case 41:
            /* FIXME: Actually use `ordered' information */
            A(p) = A(L(p));
            break;

        /* CoreExpr:           unordered (CoreExpr) */
        case 42:
            /* FIXME: Actually use `ordered' information */
            A(p) = A(L(p));
            break;

        /* CoreExpr:           cast (seqtype, CoreExpr) */
        case 46:
        {
            PFty_t              t;
            PFalg_simple_type_t algty;

            t = PFty_prime (PFty_defn (L(p)->sem.type));

            /*
             * Unfortunately, we only know how to cast atomic types
             * into (exactly) one of our builtin atomic types. We
             * cannot sensibly cast, e.g., into subtypes thereof.
             */
            if (PFty_equality (t, PFty_xs_string ()))
                algty = aat_str;
            else if (PFty_equality (t, PFty_xs_integer ()))
                algty = aat_int;
            else if (PFty_equality (t, PFty_xs_decimal ()))
                algty = aat_dec;
            else if (PFty_equality (t, PFty_xs_double ()))
                algty = aat_dbl;
            else if (PFty_equality (t, PFty_xs_boolean ()))
                algty = aat_bln;
            else
                PFoops (OOPS_FATAL,
                        "don't know the algebra equivalent of type %s",
                        PFty_str (L(p)->sem.type));

            A(p) = (struct PFla_pair_t) {
                .rel  = cast (A(R(p)).rel, att_item, algty),
                .frag = A(R(p)).frag };

        } break;

        /* Atom:               var */
        case 47:
        {
            /*
             * Reference to variable, so look it up in the environment. It
             * was inserted into the environment by a let or for expression.
             *
             * ---------------------------------------------------------------
             * env, (v -> q(v)) e env, loop: v => (q(v), 0)
             */
            unsigned int i;
        
            /* 
             * look up the variable in the environment;
             * since it has already been ensured beforehand, that
             * each variable was declared before being used, we are
             * guarenteed to find the required binding in the
             * environment
             */
            for (i = 0; i < PFarray_last (env); i++) {
                PFla_env_t e = *((PFla_env_t *) PFarray_at (env, i));
            
                if (p->sem.var == e.var) {
                    A(p) = (struct  PFla_pair_t) {
                             .rel = e.rel,
                             .frag = e.frag };
                    break;
                }
            }

            assert (A(p).rel); assert (A(p).frag);

        } break;

        /* Atom:               LiteralValue */
        case 48:
            break;

        /* LiteralValue:       lit_str */
        case 49:
        {
            /* 
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = cross (loop,
                                   lit_tbl( attlist (att_pos, att_item),
                                            tuple (lit_nat (1),
                                                   lit_str (p->sem.str)))),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       lit_int */
        case 50:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = cross (loop,
                                   lit_tbl( attlist (att_pos, att_item),
                                            tuple (lit_nat (1),
                                                   lit_int (p->sem.num)))),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       lit_dec */
        case 51:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = cross (loop,
                                   lit_tbl( attlist (att_pos, att_item),
                                            tuple (lit_nat (1),
                                                   lit_dec (p->sem.dec)))),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       lit_dbl */
        case 52:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = cross (loop,
                                   lit_tbl( attlist (att_pos, att_item),
                                            tuple (lit_nat (1),
                                                   lit_dbl (p->sem.dbl)))),
                     .frag = PFla_empty_set () };
        } break;


        /* LiteralValue:       true_ */
        case 53:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = cross (loop,
                                   lit_tbl( attlist (att_pos, att_item),
                                            tuple (lit_nat (1),
                                                   lit_bln (true)))),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       false_ */
        case 54:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = cross (loop,
                                   lit_tbl( attlist (att_pos, att_item),
                                            tuple (lit_nat (1),
                                                   lit_bln (false)))),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       empty */
        case 55:
        {
            /*
             *  -------------------------------------------------------------
             *                       iter | pos | item
             *  env, loop: empty => ------+-----+------ , 0
             * 
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = PFla_empty_tbl (attlist (att_iter, att_pos, att_item)),
                     .frag = PFla_empty_set () };
        } break;

        default:
            PFoops (OOPS_FATAL, "untranslated expression");
            break;
    }
}

/**
 * Construct a new entry to be inserted into the variable environment.
 * Called whenever a new variable is declared.
 */
static PFla_env_t
enventry (PFvar_t *var, PFla_op_t *result, PFarray_t *doc)
{
    return (PFla_env_t) { .var = var, .rel = result, .frag = doc };
}

/**
 * Given an XQuery type @a ty, an algebra expression @a e, and the
 * loop relation @a loop, return an algebra expression that returns
 * the relation with schema (iter, subty), so that for each iter value
 * in @a loop there exists one tuple, with the subty attribute set to
 * true, if @a e has a subtype of @a ty, and false otherwise.
 */
static PFla_op_t *
type_test (PFty_t ty, PFla_pair_t e, PFla_op_t *loop)
{
    PFla_op_t *itemty;

    /*
     * Collect algebra expression with schema (iter,pos,itemty)
     * so that itemty is true for any item that is a subtype of
     * ty, and false otherwise.
     *
     * The surface language only allows QNames for predefined
     * types, or node kind tests. Fortunately, only few atomic
     * types are predefined: xs:integer, xs:decimal, xs:double,
     * xs:boolean, xs:string. For all of them we have an algebra
     * correspondance.
     * 
     * We first consider the case that ty is the empty sequence.
     * (This cannot be entered on the surface language. But it
     * may be introduced during core generation/optimization.
     * And we want to avoid nasty bugs here, when that case would
     * be caught in the following cases.)
     *
     *        /                        subty \
     *       | dist (proj_iter (e)) X ------- |       (non-empty iters)
     *        \                        false /
     *                           U
     *    /                                 subty \
     *   | (loop \ dist (proj_iter (e))) X ------- |  (empty iters)
     *    \                                 false /
     *
     */
    if (PFty_subtype (ty, PFty_empty ()))
        return
            disjunion (
                cross (
                    distinct (project (e.rel, proj (att_iter, att_iter))),
                    lit_tbl (attlist (att_subty), tuple (lit_bln (false)))),
                cross (
                    difference (
                        loop,
                        distinct (project (e.rel, proj (att_iter, att_iter)))),
                    lit_tbl (attlist (att_subty), tuple (lit_bln (true)))));
    /*
     * To test, e.g., for integer values, use
     *
     *   proj_iter,pos,itemty (type_itemty:item/int (e))
     *
     */
    else if (PFty_subtype (ty, PFty_star (PFty_xs_integer ())))
        itemty = project (type (e.rel, att_itemty, att_item, aat_int),
                          proj (att_iter, att_iter),
                          proj (att_pos, att_pos),
                          proj (att_itemty, att_itemty));
    else if (PFty_subtype (ty, PFty_star (PFty_xs_decimal ())))
        /* xs:integer is a subtype of xs:decimal.
         * Test for both types. The `type' operator merely adds a boolean
         * column. We OR them after testing for for both types.
         */
        itemty =
            project (
                or (type (type (e.rel, att_isint, att_item, aat_int),
                          att_isdec, att_item, aat_dec),
                    att_itemty, att_isint, att_isdec),
                proj (att_iter, att_iter),
                proj (att_pos, att_pos),
                proj (att_itemty, att_itemty));
    else if (PFty_subtype (ty, PFty_star (PFty_xs_double ())))
        itemty = project (type (e.rel, att_itemty, att_item, aat_dbl),
                          proj (att_iter, att_iter),
                          proj (att_pos, att_pos),
                          proj (att_itemty, att_itemty));
    else if (PFty_subtype (ty, PFty_star (PFty_xs_boolean ())))
        itemty = project (type (e.rel, att_itemty, att_item, aat_bln),
                          proj (att_iter, att_iter),
                          proj (att_pos, att_pos),
                          proj (att_itemty, att_itemty));
    else if (PFty_subtype (ty, PFty_star (PFty_xs_string ())))
        itemty = project (type (e.rel, att_itemty, att_item, aat_str),
                          proj (att_iter, att_iter),
                          proj (att_pos, att_pos),
                          proj (att_itemty, att_itemty));
    else
        PFoops (OOPS_FATAL,
                "Sorry, I cannot translate the test for type `%s'",
                PFty_str (ty));


    /*
     * Second part is the test for the occurence indicator.
     */

    /*
     * Ocurrence indicator `1' (exactly one item).
     *
     * seqty1_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty\
     * | (loop \ proj_iter (itemty)) X ----- |
     *  \                              false/
     *
     * (First part considers all iterations with length of at
     * least one: The itemty expression contains true/false values
     * as determined above. The seqty1 operator sets true for all
     * those `iter' groups, where there is exactly one tuple with
     * value `true', and false otherwise. The second part of the
     * union considers all the empty sequences. They do not match
     * the occurrence indicator and are thus set to false.)
     */
    if (PFty_subtype (ty, PFty_item ()))
        return
            disjunion (
                seqty1 (project (itemty,
                                 proj (att_iter, att_iter),
                                 proj (att_item, att_itemty)),
                        att_subty, att_item, att_iter),
                cross (
                    difference (
                        loop,
                        project (itemty, proj (att_iter, att_iter))),
                    lit_tbl (attlist (att_subty), tuple (lit_bln (false)))));

    /*
     * Ocurrence indicator `?' (zero or one item).
     *
     * seqty1_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty\
     * | (loop \ proj_iter (itemty)) X ----- |
     *  \                              true /
     *
     * In contrast to `1', we return true for all empty sequences.
     */
    if (PFty_subtype (ty, PFty_opt (PFty_item ())))
        return
            disjunion (
                seqty1 (project (itemty,
                                 proj (att_iter, att_iter),
                                 proj (att_item, att_itemty)),
                        att_subty, att_item, att_iter),
                cross (
                    difference (
                        loop,
                        project (itemty, proj (att_iter, att_iter))),
                    lit_tbl (attlist (att_subty), tuple (lit_bln (true)))));

    /*
     * Ocurrence indicator `+' (one or more items).
     *
     * all_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty \
     * | (loop \ proj_iter (itemty)) X -----  |
     *  \                              false /
     *
     * Groupwise test if all tuples in itemty carry a `true'.
     * This makes all iterations true that contain only items
     * that satisfy the type test, and false all those that
     * contain at least one item that does not satisfy the
     * type test. We are left with considering the empty sequences
     * that do not qualify for the name test. We return false for
     * them.
     */
    if (PFty_subtype (ty, PFty_plus (PFty_item ())))
        return
            disjunion (
                all (project (itemty,
                              proj (att_iter, att_iter), proj (att_item, att_itemty)),
                     att_subty, att_item, att_iter),
                cross (
                    difference (
                        loop,
                        project (itemty, proj (att_iter, att_iter))),
                    lit_tbl (attlist (att_subty), tuple (lit_bln (false)))));

    /*
     * Ocurrence indicator `*' (zero or more items).
     *
     * all_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty\
     * | (loop \ proj_iter (itemty)) X ----  |
     *  \                              true /
     *
     * Almost the same as `+', but return true for empty sequences.
     */
    if (PFty_subtype (ty, PFty_star (PFty_item ())))
        return
            disjunion (
                all (project (itemty,
                              proj (att_iter, att_iter), proj (att_item, att_itemty)),
                     att_subty, att_item, att_iter),
                cross (
                    difference (
                        loop,
                        project (itemty, proj (att_iter, att_iter))),
                    lit_tbl (attlist (att_subty), tuple (lit_bln (true)))));

    /*
     * We should never reach this point.
     */
    PFoops (OOPS_FATAL, "Error in type_test().");
    assert(0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * Set up a dummy node that contains parameters for staircase join
 * invocations. Simplifies translation of location steps (see rule 14).
 */
static PFla_op_t *
locstep_dummy (PFalg_axis_t axis, PFty_t seqty)
{
    PFla_op_t *ret = dummy ();

    ret->sem.scjoin.axis = axis;
    ret->sem.scjoin.ty   = seqty;

    return ret;
}


/**
 * Compile XQuery Core tree into relational algebra tree.
 *
 * @param r root of the Core tree.
 * @return the algebra equivalent of @a r
 */
PFla_op_t *
PFcore2alg (PFcnode_t *r)
{
    assert (r);

    /* yet empty environment */
    env = PFarray (sizeof (PFla_env_t));

    /* loop is initially a table with just one tuple */
    loop = lit_tbl (attlist (att_iter), tuple (lit_nat (1)));

    /* Pointer to array of function parameter values */
    fun_args = NULL;

    /* label the core tree bottom up */
    PFcore2alg_label (r);

    /* invoke compilation */
    reduce (r, 1);

    return A(r).rel;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
