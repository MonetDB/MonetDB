%{

/**
 * @file
 *
 * Optimize relational algebra expression DAG
 * based on general patterns.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2007 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 * $Id$
 */

/* always include pathfinder.h first! */
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "algopt.h"
#include "properties.h"
#include "alg_dag.h"
#include "oops.h"         /* PFoops() */
#include "mem.h"          /* PFmalloc() */
#include "subtyping.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFla_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p) ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* the state of the children determined during 
   bottom-up labeling is backed up here */
#define CHILD_STATE_LABEL(p,i) ((p)->child_state_label[i])

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/logical.h!
 */
%term  serialize      =   1
%term  lit_tbl        =   2
%term  empty_tbl      =   3
%term  attach         =   4
%term  cross          =   5
%term  eqjoin         =   6
%term  semijoin       =   7
%term  project        =   8
%term  select_        =   9
%term  disjunion      =  10
%term  intersect      =  11
%term  difference     =  12
%term  distinct       =  13
%term  num_add        =  20
%term  num_subtract   =  21
%term  num_multiply   =  22
%term  num_divide     =  23
%term  num_modulo     =  24
%term  num_eq         =  25
%term  num_gt         =  26
%term  num_neg        =  27
%term  bool_and       =  28
%term  bool_or        =  29
%term  bool_not       =  30
%term  avg            =  31
%term  max_           =  32
%term  min_           =  33
%term  sum            =  34
%term  count          =  35
%term  rownum         =  36
%term  number         =  37
%term  type           =  40
%term  type_assert    =  41
%term  cast           =  42
%term  seqty1         =  43
%term  all            =  44
%term  scjoin         =  50
%term  dup_scjoin     =  51
%term  doc_tbl        =  52
%term  doc_access     =  53
%term  element        =  60
%term  element_tag    =  61
%term  attribute      =  62
%term  textnode       =  63
%term  docnode        =  64
%term  comment        =  65
%term  processi       =  66
%term  merge_adjacent =  67
%term  roots_         =  70
%term  fragment       =  71
%term  frag_union     =  72
%term  empty_frag     =  73
%term  cond_err       =  80
%term  rec_fix        =  81
%term  rec_param      =  82
%term  rec_nil        =  83
%term  rec_arg        =  84
%term  rec_base       =  85
%term  concat         = 100
%term  contains       = 101
%term  string_join    = 102
%term  dummy          = 120

%%

Query:  serialize (Frag, Rel)                     =   1 (10);

Rel:    lit_tbl                                   =   2 (10);
Rel:    attach (Rel)                              =   3 (10);
Rel:    cross (Rel, Rel)                          =   4 (10);
Rel:    cross (Rel, lit_tbl)                      =   5 (10);
Rel:    cross (lit_tbl, Rel)                      =   6 (10);
Rel:    eqjoin (Rel, Rel)                         =   8 (10);
Rel:    semijoin (Rel, Rel)                       =   9 (10);
Rel:    project (Rel)                             =  10 (10);
Rel:    project (attach (Rel))                    =  11 (10);
Rel:    project (project (Rel))                   =  13  (1);
Rel:    select_ (Rel)                             =  19 (10);
Rel:    disjunion (Rel, Rel)                      =  20 (10);
Rel:    disjunion (EmptyRel, Rel)                 =  21  (5);
Rel:    disjunion (Rel, EmptyRel)                 =  22  (5);
Rel:    intersect (Rel, Rel)                      =  23 (10);
Rel:    difference (Rel, Rel)                     =  24 (10);
Rel:    difference (Rel, EmptyRel)                =  25  (5);
Rel:    distinct (Rel)                            =  26 (10);
Rel:    distinct (scjoin (Frag, Rel))             =  27 (5);
Rel:    num_add (Rel)                             =  30 (10);
Rel:    num_subtract (Rel)                        =  31 (10);
Rel:    num_multiply (Rel)                        =  32 (10);
Rel:    num_divide (Rel)                          =  33 (10);
Rel:    num_modulo (Rel)                          =  34 (10);
Rel:    num_neg (Rel)                             =  35 (10);
Rel:    num_gt (Rel)                              =  36 (10);
Rel:    num_eq (Rel)                              =  37 (10);
Rel:    bool_and (Rel)                            =  38 (10);
Rel:    bool_or (Rel)                             =  39 (10);
Rel:    bool_not (Rel)                            =  40 (10);
Rel:    avg (Rel)                                 =  41 (10);
Rel:    max_ (Rel)                                =  42 (10);
Rel:    min_ (Rel)                                =  43 (10);
Rel:    sum (Rel)                                 =  44 (10);
Rel:    count (Rel)                               =  45 (10);
Rel:    rownum (Rel)                              =  50 (10);
Rel:    number (Rel)                              =  51 (10);
Rel:    number (number (Rel))                     =  52 (10);
Rel:    number (project (number (Rel)))           =  53 (10);
Rel:    type (Rel)                                =  54 (10);
Rel:    type_assert (Rel)                         =  55 (10);
Rel:    cast (cast (Rel))                         =  56 (10);
Rel:    cast (project (cast (Rel)))               =  57 (10);
Rel:    cast (Rel)                                =  58 (10);
Rel:    seqty1 (Rel)                              =  59 (10);
Rel:    all (Rel)                                 =  60 (10);
Rel:    ScjRel                                    =  61 (10);
ScjRel: scjoin (Frag, Rel)                        =  62 (10);
ScjRel: scjoin (Frag, ScjRel)                     =  63 (10);
ScjRel: scjoin (Frag, distinct (Rel))             =  64 (10);
Rel:    dup_scjoin (Frag, Rel)                    =  65 (10);
Rel:    doc_access (Frag, Rel)                    =  66 (10);

Rel:    roots_ (doc_tbl (Rel))                    =  70 (10);
Rel:    roots_ (element (Frag,                       
                         element_tag (Rel, Rel))) =  71 (10);
Rel:    roots_ (attribute (Rel))                  =  72 (10);
Rel:    roots_ (textnode (Rel))                   =  73 (10);
Rel:    roots_ (docnode (Frag, Rel))              =  74 (10);
Rel:    roots_ (comment (Rel))                    =  75 (10);
Rel:    roots_ (processi (Rel))                   =  76 (10);
Rel:    roots_ (merge_adjacent (Frag, Rel))       =  77 (10);

Rel:    cond_err (Rel, Rel)                       =  80 (10);

Rel:    rec_fix (Rec, Rel)                        =  81 (10);
Rel:    rec_base                                  =  82 (10);
Rec:    rec_param (Arg, Rec)                      =  83 (10);
Rec:    rec_nil                                   =  84 (10);
Arg:    rec_arg (Rel, Rel)                        =  85 (10);

Rel:    concat (Rel)                              =  86 (10);
Rel:    contains (Rel)                            =  87 (10);
Rel:    string_join (Rel, Rel)                    =  88 (10);
Rel:    dummy (Rel)                               =  89 (10);

Rel:    EmptyRel                                  =  90  (0);


Frag:    fragment (doc_tbl (Rel))                 = 100 (10);
Frag:    fragment (element (Frag, 
                            element_tag (Rel,
                                         Rel)))   = 101 (10);
Frag:    fragment (attribute (Rel))               = 102 (10);
Frag:    fragment (textnode (Rel))                = 103 (10);
Frag:    fragment (docnode (Frag, Rel))           = 104 (10);
Frag:    fragment (comment (Rel))                 = 105 (10);
Frag:    fragment (processi (Rel))                = 106 (10);
Frag:    fragment (merge_adjacent (Frag, Rel))    = 107 (10);

Frag:    frag_union (Frag, Frag)                  = 111 (10);
Frag:    empty_frag                               = 112 (10);


EmptyRel:    empty_tbl                            = 120  (0);

EmptyRel:    attach (EmptyRel)                    = 121  (0);
EmptyRel:    cross (EmptyRel, Rel)                = 122  (0);
EmptyRel:    cross (Rel, EmptyRel)                = 123  (0);
EmptyRel:    eqjoin (EmptyRel, Rel)               = 124  (0);
EmptyRel:    eqjoin (Rel, EmptyRel)               = 125  (0);
EmptyRel:    semijoin (EmptyRel, Rel)             = 126  (0);
EmptyRel:    semijoin (Rel, EmptyRel)             = 127  (0);
EmptyRel:    project (EmptyRel)                   = 128  (0);
EmptyRel:    select_ (EmptyRel)                   = 129  (0);
EmptyRel:    disjunion (EmptyRel, EmptyRel)       = 130  (0);
EmptyRel:    intersect (EmptyRel, Rel)            = 131  (0);
EmptyRel:    intersect (Rel, EmptyRel)            = 132  (0);
EmptyRel:    difference (EmptyRel, Rel)           = 133  (0);
EmptyRel:    distinct (EmptyRel)                  = 134  (0);
EmptyRel:    num_add (EmptyRel)                   = 140  (0);
EmptyRel:    num_subtract (EmptyRel)              = 141  (0);
EmptyRel:    num_multiply (EmptyRel)              = 142  (0);
EmptyRel:    num_divide (EmptyRel)                = 143  (0);
EmptyRel:    num_modulo (EmptyRel)                = 144  (0);
EmptyRel:    num_neg (EmptyRel)                   = 145  (0);
EmptyRel:    num_gt (EmptyRel)                    = 146  (0);
EmptyRel:    num_eq (EmptyRel)                    = 147  (0);
EmptyRel:    bool_and (EmptyRel)                  = 148  (0);
EmptyRel:    bool_or (EmptyRel)                   = 149  (0);
EmptyRel:    bool_not (EmptyRel)                  = 150  (0);
EmptyRel:    avg (EmptyRel)                       = 151  (0);
EmptyRel:    max_ (EmptyRel)                      = 152  (0);
EmptyRel:    min_ (EmptyRel)                      = 153  (0);
EmptyRel:    sum (EmptyRel)                       = 154  (0);
EmptyRel:    count (EmptyRel)                     = 155  (0);
EmptyRel:    rownum (EmptyRel)                    = 160  (0);
EmptyRel:    number (EmptyRel)                    = 161  (0);
EmptyRel:    type (EmptyRel)                      = 162  (0);
EmptyRel:    type_assert (EmptyRel)               = 163  (0);
EmptyRel:    cast (EmptyRel)                      = 164  (0);
EmptyRel:    seqty1 (EmptyRel)                    = 165  (0);
EmptyRel:    all (EmptyRel)                       = 166  (0);
EmptyRel:    scjoin (Frag, EmptyRel)              = 170  (0);
EmptyRel:    doc_access (Frag, EmptyRel)          = 171  (0);

EmptyRel:    roots_ (doc_tbl (EmptyRel))          = 180  (0);
EmptyRel:    roots_ (element (Frag, 
                              element_tag (EmptyRel,
                                          Rel)))  = 181  (0);
EmptyRel:    roots_ (attribute (EmptyRel))        = 182  (0);
EmptyRel:    roots_ (textnode (EmptyRel))         = 183  (0);
EmptyRel:    roots_ (comment (EmptyRel))          = 185  (0);
EmptyRel:    roots_ (processi (EmptyRel))         = 186  (0);
EmptyRel:    roots_ (merge_adjacent (Frag,                   
                                     EmptyRel))   = 187  (0);
EmptyRel:    cond_err (EmptyRel, Rel)             = 190  (0);
EmptyRel:    concat (EmptyRel)                    = 200  (0);
EmptyRel:    string_join (EmptyRel, Rel)          = 201  (0);
EmptyRel:    dummy (EmptyRel)                     = 202  (0);

%%

#include "algebra_mnemonic.h"

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/** and so on... */
#define RL(p) (L(R(p)))
#define LLL(p) (LL(L(p)))
#define RLL(p) (LL(R(p)))

#define MAX_KIDS 10

#define SEEN(p) ((p)->bit_dag)

/* mark all nodes in the pattern of node p as seen 
   if it is not contained in kids. */
static void mark_pattern_SEEN (PFla_op_t *p,  PFla_op_t **kids);

/* Check consistency of the state label in the pattern rooted in p */
static bool changed_label (PFla_op_t *p,  PFla_op_t **kids);

/* Relabel node p if it is not contained in kids. */
static void relabel (PFla_op_t *p,  PFla_op_t **kids);

static void
label (PFla_op_t *p);
/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFla_op_t *p, int goalnt)
{
    int              rule;       /* rule number that matches for this node */
    short           *nts;        /* target non-terminals for the leaf nodes of
                                    the current rule */
    PFla_op_t       *kids[MAX_KIDS];   /* leaf nodes of this rule */
    bool             rewritten = false;

    short            old_state_label;
    unsigned short   i;

    do {
        assert (STATE_LABEL (p));

        /* determine rule that matches for this non-terminal */
        rule = PFopt_general_rule (STATE_LABEL (p), goalnt);

        assert (rule);

        /* initialize the kids[] vector */
        for (unsigned short i = 0; i < MAX_KIDS; i++)
            kids[i] = NULL;

        /*
         * prepare recursive traversal: get information on leaf nodes of
         * this rule
         */
        nts = PFopt_general_nts[rule];
        PFopt_general_kids (p, rule, kids);

        /* check consistency of pattern labels */
        rewritten = changed_label (p, kids);

        /*
         * prune already optimized branch of the tree
         * (we try to treat the tree plan as DAG)
         */
        if (!SEEN(p) && !rewritten)
            /* recursively translate all leaf expressions */
            for (i = 0; nts[i]; i++)
                if ((rewritten = reduce (kids[i], nts[i])))
                    break;  /* abort if a subtree was rewritten */

        if (rewritten) {

            /*
             * If a subtree has been rewritten, we have to
             *  - re-label that part of the tree, and
             *  - possibly propagate the `rewritten' information upwards.
             */

            /* remember our old state_label (so we know if it has changed) */
            old_state_label = STATE_LABEL(p);

            /*
             * Re-label current tree pattern.
             * (at most down to the pattern leaves, as they should already be
             * correctly labeled by the above reduce() call)
             */
            relabel (p, kids);

            /* If our own state_label has changed, notify our caller. */
            if (old_state_label != STATE_LABEL(p)) {
                SEEN(p)= false;
                return true;
            }
        }
    } while (rewritten);

    /* save old_state_label to detect structural changes introduced
       by the following action code */
    old_state_label = STATE_LABEL(p);

    /* mark all nodes in the current pattern as visited 
       to avoid tree traversals */
    mark_pattern_SEEN (p, kids);

    /* action code */
    switch (rule) {

        /* Rel:    cross (Rel, lit_tbl) */
        case 5:
            /* replace cross product with a literal table that contains
               only one row by a number of attach operators (one for each
               tuple). */
            if (R(p)->sem.lit_tbl.count == 1) {
                PFla_op_t *ret = L(p);
                for (unsigned int i = 0; i < R(p)->schema.count; i++)
                    ret = PFla_attach (ret, R(p)->schema.items[i].name,
                                       R(p)->sem.lit_tbl.tuples[0].atoms[i]);
                *p = *(ret);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
            break;

        /* Rel:    cross (lit_tbl, Rel) */
        case 6:
            /* replace cross product with a literal table that contains
               only one row by a number of attach operators (one for each
               tuple). */
            if (L(p)->sem.lit_tbl.count == 1) {
                PFla_op_t *ret = R(p);
                for (unsigned int i = 0; i < L(p)->schema.count; i++)
                    ret = PFla_attach (ret, L(p)->schema.items[i].name,
                                       L(p)->sem.lit_tbl.tuples[0].atoms[i]);
                *p = *(ret);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            } 
            break;

        /* Rel:    project (Rel) */
        case 10:
        {   /**
             * we can skip every project operator that is not needed.
             * Therefore it has to fulfill two conditions:
             * 1. no column is renamed
             * 2. the number of columns does not change
             * (The first condition also ensures that no
             *  column is referenced twice thus allowing us to 
             *  avoid a 1:1 column check.)
             */
            bool renamed = false;
            
            for (unsigned int i = 0; i < p->schema.count; i++)
                renamed = renamed ||
                          (p->sem.proj.items[i].new !=
                           p->sem.proj.items[i].old);

            if (!renamed && L(p)->schema.count == p->schema.count) {
                *p = *PFla_dummy (L(p));
                SEEN(p) = false;
                /* relabeling will be expensive 
                   if there is no real dummy node */
                relabel (p, kids);
                break;
            }
        }   break;

        /* Rel:    project (attach (Rel)) */
        case 11:
            /* only rewrite if there are more than one columns */
            if (p->schema.count > 1) {
                bool found = false, rewrite = true;
                for (unsigned int i = 0; i < p->schema.count; i++)
                    if (p->sem.proj.items[i].old == L(p)->sem.attach.attname) {
                        found = true;
                        rewrite = rewrite &&
                                  (p->sem.proj.items[i].old 
                                   == p->sem.proj.items[i].new);
                    }
                    
                /* if the projection neither discards nor renames
                   the attach result we can switch both operands  */
                if (found && rewrite) {
                    PFalg_proj_t *proj = PFmalloc ((p->schema.count - 1) *
                                                   sizeof (PFalg_proj_t));
                    unsigned int count = 0;
                    
                    for (unsigned int j = 0; j < p->schema.count; j++)
                        if (L(p)->sem.attach.attname
                            != p->sem.proj.items[j].old)
                            proj[count++] = p->sem.proj.items[j];

                    *p = *PFla_attach (PFla_project_ (LL(p), count, proj),
                                       L(p)->sem.attach.attname,
                                       L(p)->sem.attach.value);
                    SEEN(L(p)) = false;
                    SEEN(p) = false;
                    relabel (p, kids);
                    break;
                }
            }
            break;
            
        /* Rel:    project (project (Rel)) */
        case 13:
        {   /* combine two projections */            
            PFalg_proj_t *proj = PFmalloc (p->schema.count *
	                                       sizeof (PFalg_proj_t));

            unsigned int i, j, count = 0;
            for (i = 0; i < p->schema.count; i++)
                for (j = 0; j < L(p)->schema.count; j++)
                    if (p->sem.proj.items[i].old ==
                        L(p)->sem.proj.items[j].new) {
                        proj[count++] = PFalg_proj (
                                            p->sem.proj.items[i].new,
                                            L(p)->sem.proj.items[j].old);
                        break;
                    }

            /* ensure that at least one column remains! */
            if (!count)
                for (j = 0; j < L(p)->schema.count; j++)
                    if (p->sem.proj.items[0].old ==
                        L(p)->sem.proj.items[j].new) {
                        proj[count++] = PFalg_proj (
                                            p->sem.proj.items[0].new,
                                            L(p)->sem.proj.items[j].old);
                        break;
                    }

            *p = *PFla_project_ (L(L(p)), count, proj);

            SEEN(p) = false;
            relabel (p, kids);
        } break;

        /* Rel:    select_ (Rel) */
        case 19:
        {
            /**
             *  introduce thetajoin based on 
             *  one of the following patterns:
             *    
             *    sel (res)    sel (res)   sel (res)   sel (res)
             *     |            |           |           |
             *   eq,gt       project      eq,gt      project
             *     |            |           |           |
             *     X          eq,gt      project      eq,gt 
             *    / \           |           |           |
               rel1 rel2     project        X           X
             *                  |          / \         / \   
             *                  X       rel1 rel2   rel1 rel2
             *                 / \
             *              rel1 rel2
             *    
             * The result will be either:
             *    
             *     @ (res, true)
             *     |
             *    |X| (eq|gt, rel.att1, rel.att2)
             *    / \
             * rel1 rel2
             *    
             * or:
             *    
             *     @ (res, true)
             *     |
             *  project
             *     |
             *    |X| (eq|gt, rel.att1, rel.att2)
             *    / \
             * rel1 rel2
             *   
             */
            PFla_op_t *node;
            PFla_op_t *left = NULL;
            PFla_op_t *right = NULL;
            PFla_op_t *proj = NULL;
            PFla_op_t *proj2 = NULL;

            PFalg_att_t sel = p->sem.select.att;
            PFalg_att_t item1, item2;
            unsigned int i;

            node = L(p);

            if (node->kind == la_project) {
                proj = node;
                /* update the name of the selection */
                for (i = 0; i < node->sem.proj.count; i++)
                    if (sel == node->sem.proj.items[i].new) {
                        sel = node->sem.proj.items[i].old;
                        break;
                    }
                node = L(node);
            }
            
            /* the selection column has to match the
               result column of the comparison operator */
            if (node->kind != la_num_eq ||
                node->sem.binary.res != sel)
                break;

            item1 = node->sem.binary.att1;
            item2 = node->sem.binary.att2;
            node = L(node);

            if (node->kind == la_project) {
                proj2 = node;
                /* update the names of the comparison input */
                for (i = 0; i < node->sem.proj.count; i++) {
                    if (item1 == node->sem.proj.items[i].new)
                        item1 = node->sem.proj.items[i].old;
                    if (item2 == node->sem.proj.items[i].new)
                        item2 = node->sem.proj.items[i].old;
                }
                node = L(node);
            }

            /* match the pattern */
            if (node->kind != la_cross)
                break;

            /* lookup the corresponding subtrees for the
               comparison inputs */
            for (i = 0; i < L(node)->schema.count; i++)
                if (L(node)->schema.items[i].name == item1)
                    left = L(node);
                else if (L(node)->schema.items[i].name == item2)
                    right = L(node);

            for (i = 0; i < R(node)->schema.count; i++)
                if (R(node)->schema.items[i].name == item1)
                    left = R(node);
                else if (R(node)->schema.items[i].name == item2)
                    right = R(node);

            /* the two comparison inputs are from the same relation
               -- multi-value dependency analysis will thus move the
               cross product up */
            if (!left || !right || left == right)
                break;

            /* Now all constraints are checked and the pattern 
               can be replaced by an theta-join and an attach operator
               that adds the missing res column */
            if (!proj && !proj2) {
                *p = *PFla_attach (
                          PFla_eqjoin (left, right, item1, item2),
                          p->sem.select.att, PFalg_lit_bln (true));
                SEEN(p) = false;
                SEEN(L(p)) = false;
                /* relabel does not know that left and right are already
                   labeled correctly and thus would relabel the *complete*
                   subTREE! To avoid this make sure that kids contains the
                   references to left and right */
                kids[0] = left;
                kids[1] = right;
                relabel (p, kids);
                break;
            } else {
                /* if at least one projection was in between we
                   have to apply the projection between theta-join
                   and attach operator */
                PFalg_proj_t *proj_list;
                unsigned int j, count = 0;
                
                /* create projection list */
                proj_list = PFmalloc ((p->schema.count - 1)*
                                      sizeof (*(proj_list)));
                
                for (i = 0; i < p->schema.count; i++) {
                    /* use current schema as starting point
                       (discarding the result column of the comparison) */
                    if (p->schema.items[i].name != p->sem.select.att)
                        proj_list[count] = PFalg_proj (
                                               p->schema.items[i].name,
                                               p->schema.items[i].name);

                    /* apply the renaming of the first projection */
                    if (proj)
                        for (j = 0; j < proj->sem.proj.count; j++)
                            if (proj->sem.proj.items[j].new ==
                                proj_list[count].old)
                                proj_list[count].old
                                    = proj->sem.proj.items[j].old;

                    /* apply the renaming of the second projection */
                    if (proj2)
                        for (j = 0; j < proj2->sem.proj.count; j++)
                            if (proj2->sem.proj.items[j].new ==
                                proj_list[count].old)
                                proj_list[count].old
                                    = proj2->sem.proj.items[j].old;
                    
                    /* increase the counter analogously */
                    if (p->schema.items[i].name != p->sem.select.att)
                        count++;
                }
                                                   
                *p = *PFla_attach (
                          PFla_project_ (
                              PFla_eqjoin (left, right, item1, item2),
                              p->schema.count - 1, proj_list),
                          p->sem.select.att, PFalg_lit_bln (true));
                SEEN(p) = false;
                SEEN(L(p)) = false;
                SEEN(LL(p)) = false;
                /* relabel does not know that left and right are already
                   labeled correctly and thus would relabel the *complete*
                   subTREE! To avoid this make sure that kids contains the
                   references to left and right */
                kids[0] = left;
                kids[1] = right;
                relabel (p, kids);
                break;
            }
        }   break;

        /* Rel:    disjunion (EmptyRel, Rel) */
        case 21:
            /* return right child */
            *p = *PFla_dummy (R(p));
            SEEN(p) = false;
            /* relabeling will be expensive 
               if there is no real dummy node */
            relabel (p, kids);
            break;

        /* Rel:    disjunion (Rel, EmptyRel) */
        case 22:
        /* Rel:    difference (Rel, EmptyRel) */
        case 25:
            /* return left child */
            *p = *PFla_dummy (L(p));
            SEEN(p) = false;
            /* relabeling will be expensive 
               if there is no real dummy node */
            relabel (p, kids);
            break;

        /* Rel:    distinct (scjoin (Frag, Rel)) */
        case 27:
            /* return left child */
            *p = *PFla_dummy (L(p));
            SEEN(p) = false;
            /* relabeling will be expensive 
               if there is no real dummy node */
            relabel (p, kids);
            break;

        /* Rel:    rownum (Rel) */
        case 50:
#if 0 
/* this is only allowed if the numbers do not matter */

            /* replace rownum by projection if it only contains one
               sort (and no partioning) criterion that is of type nat */ 
            if (!p->sem.rownum.part &&
                p->sem.rownum.sortby.count == 1)
                for (unsigned int i = 0; i < p->schema.count; i++) {
                    PFalg_att_t cur_col = p->schema.items[i].name;
                    
                    if (cur_col == p->sem.rownum.sortby.atts[0] &&
                        p->schema.items[i].type == aat_nat) {
                        PFalg_proj_t *proj = PFmalloc (
                                                 p->schema.count
                                                 * sizeof (PFalg_proj_t));
                        /* copy property list */
                        for (i = 0; i < p->schema.count; i++)
                            if (p->sem.rownum.attname ==
                                p->schema.items[i].name)
                                /* as rownum column we use the single
                                   sort criterion */
                                proj[i] = PFalg_proj (p->sem.number.attname,
                                                      cur_col);
                            else
                                proj[i] = PFalg_proj (p->schema.items[i].name,
                                                      p->schema.items[i].name);
                                                      
                        *p = *PFla_project_ (L(p), p->schema.count, proj);
                        SEEN(p) = false;
                        relabel (p, kids);
                        break;
                    }
                }
#endif
            break;

        /* Rel:    number (number (Rel)) */
        case 52:
            if (! p->sem.number.part && 
                ! L(p)->sem.number.part) {
                PFalg_proj_t *proj = PFmalloc (
                                         p->schema.count
                                         * sizeof (PFalg_proj_t));
                /* copy property list */
                for (unsigned int i = 0; i < p->schema.count; i++)
                    if (p->sem.number.attname == p->schema.items[i].name)
                        proj[i] = PFalg_proj (p->sem.number.attname,
                                              L(p)->sem.number.attname);
                    else
                        proj[i] = PFalg_proj (p->schema.items[i].name,
                                              p->schema.items[i].name);
                                              
                *p = *PFla_project_ (L(p), p->schema.count, proj);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
            break;

        /* Rel:    number (project (number (Rel))) */
        case 53:
            if (! p->sem.number.part && 
                ! LL(p)->sem.number.part) {
                unsigned int count = L(p)->sem.proj.count;
                PFalg_proj_t *proj = PFmalloc (
                                         (count + 1)
                                         * sizeof (PFalg_proj_t));
                /* copy property list */
                for (unsigned int i = 0; i < count; i++)
                    proj[i] = L(p)->sem.proj.items[i];

                proj[count] = PFalg_proj (p->sem.number.attname,
                                          LL(p)->sem.number.attname);

                *p = *PFla_project_ (LL(p), count + 1, proj);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
            break;

        /* Rel:    type_assert (Rel) */
        case 55:
            /* throw out type_assert if it is not needed anymore */
            for (unsigned int i = 0; i < L(p)->schema.count; i++)
                if (p->sem.type.att == L(p)->schema.items[i].name) {
                    if (p->sem.type.ty == L(p)->schema.items[i].type) {
                        *p = *PFla_dummy (L(p));
                        SEEN(p) = false;
                        /* relabeling will be expensive 
                           if there is no real dummy node */
                        relabel (p, kids);
                    }
                    break;
                }
            break;
            
        /* Rel:    cast (cast (Rel)) */
        case 56:
        /* Rel:    cast (project (cast (Rel))) */
        case 57:
            /* Discard the casts if the cast maps from string
               to untypedAtomic and back to string. */
        {
            PFla_op_t *cast;
            bool proj = false, found = false;
            unsigned int i;
            PFalg_att_t att = p->sem.type.att;
            
            /* check for a projection in between and update
               the name of the outer cast input */
            if (L(p)->kind == la_project) {
                proj = true;
                for (i = 0; i < L(p)->sem.proj.count; i++)
                    if (att == L(p)->sem.proj.items[i].new) {
                        att = L(p)->sem.proj.items[i].old;
                        break;
                    }
                cast = LL(p);
            }
            else
                cast = L(p);

            /* make sure the input of the first cast 
               is of type string */
            for (i = 0; i < cast->schema.count; i++)
                if (cast->schema.items[i].name == cast->sem.type.att &&
                    cast->schema.items[i].type == aat_str) {
                    found = true;
                    break;
                }
            
            /* enforce the constraints: child node is a cast,
               the output of the nested cast and the input of
               the outer cast match, the inner cast applies a
               cast to untypedAtomic, and the outer to string */
            if (found &&
                att == cast->sem.type.res &&
                cast->sem.type.ty == aat_uA &&
                p->sem.type.ty == aat_str) {
            
                PFalg_proj_t *proj_list;
                /* create projection list */
                proj_list = PFmalloc (p->schema.count *
                                      sizeof (*(proj_list)));
                                      
                if (proj) {
                    /* if there was already a projection keep that
                       one and extend it with the result column of the
                       outer cast that refers to the orginal input column */
                    for (i = 0; i < L(p)->sem.proj.count; i++)
                        proj_list[i] = L(p)->sem.proj.items[i];
                        
                    proj_list[i] = PFalg_proj (p->sem.type.res,
                                               cast->sem.type.att);
                }
                else
                    /* keep all column and link the result column of the
                       outer cast to the input column of the nested cast */
                    for (i = 0; i < p->schema.count; i++)
                        if (p->schema.items[i].name == p->sem.type.res)
                            proj_list[i] = PFalg_proj (p->sem.type.res,
                                                       cast->sem.type.att);
                        else
                            proj_list[i] = PFalg_proj (p->schema.items[i].name,
                                                       p->schema.items[i].name);
                                                       
                /* Replace the outer cast (and the project) by a new project
                   that avoids the unnecessary casts. (The second cast will
                   be removed by an icols optimization phase.) */
                *p = *PFla_project_ (cast, p->schema.count, proj_list);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
        } /* fall trough otherwise */
                
        /* Rel:    cast (Rel) */
        case 58:
        {
            /*
             * If an algebra expression already has the requested
             * type, replace it by a projection.
             */
            bool cast_req = true;
            for (unsigned int i = 0; i < p->schema.count; i++)
                if (p->sem.type.att == p->schema.items[i].name &&
                    p->sem.type.ty == p->schema.items[i].type) {
                    cast_req = false;
                    break;
                }

            if (!cast_req) { 
                PFalg_proj_t *proj = PFmalloc (p->schema.count
                                               * sizeof (PFalg_proj_t));

                for (unsigned int j = 0; j < p->schema.count; j++)
                    if (p->schema.items[j].name != p->sem.type.res) {
                        proj[j] = PFalg_proj (p->schema.items[j].name,
                                              p->schema.items[j].name);
                    } else {
                        proj[j] = PFalg_proj (p->sem.type.res,
                                              p->sem.type.att);
                    }

                *p = *PFla_project_ (L(p), p->schema.count, proj);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
        } break;

        /* ScjRel: scjoin (Frag, ScjRel) */
        case 63:
            /* combine scjoins if they are of the form:
               ``/descandent-or-self::node()/child::element()'' */
            if (R(p)->sem.scjoin.axis == alg_desc_s &&
                PFty_equality (R(p)->sem.scjoin.ty, PFty_xs_anyNode ()) &&
                p->sem.scjoin.axis == alg_chld) {
                /* rewrite child into descendant
                   and discard descendant-or-self step */
                *p = *PFla_scjoin (L(p), RR(p), alg_desc, p->sem.scjoin.ty,
                                   p->sem.scjoin.iter, R(p)->sem.scjoin.item,
                                   p->sem.scjoin.item_res);
                SEEN(p) = false;
                /* relabel does not know that the left and the right children
                   are already labeled correctly and thus would relabel 
                   the *complete* subTREE! To avoid this make sure that kids
                   contains the correct references */
                kids[0] = L(p);
                kids[1] = R(p);
                relabel (p, kids);
                break;
            }
            break;

        /* ScjRel: scjoin (Frag, distinct (Rel)) */
        case 64:
            R(p) = L(R(p));
            SEEN(p) = false;
            relabel (p, kids);
            break;

        /* Rel:    EmptyRel */
        case 90:
        {
            /*
             * Replace any sub-tree that we determined empty with these
             * rules by the literal empty table.
             */
            *p = *PFla_empty_tbl_ (p->schema);
            SEEN(p) = true;
            relabel (p, kids);
        } break;

        /* every occurrence of EmptyRel already copes with
           the empty relation - we therefore do not rewrite
           any of the below rules (they are pruned anyway) */

        /* EmptyRel:    empty_tbl */
        case 120:
        /* EmptyRel:    attach (EmptyRel) */
        case 121:
        /* EmptyRel:    cross (EmptyRel, Rel) */
        case 122:
        /* EmptyRel:    cross (Rel, EmptyRel) */
        case 123:
        /* EmptyRel:    eqjoin (EmptyRel, Rel) */
        case 124:
        /* EmptyRel:    eqjoin (Rel, EmptyRel) */
        case 125:
        /* EmptyRel:    semijoin (EmptyRel, Rel) */
        case 126:
        /* EmptyRel:    semijoin (Rel, EmptyRel) */
        case 127:
        /* EmptyRel:    project (EmptyRel) */
        case 128:
        /* EmptyRel:    select_ (EmptyRel) */
        case 129:
        /* EmptyRel:    disjunion (EmptyRel, EmptyRel) */
        case 130:
        /* EmptyRel:    intersect (EmptyRel, Rel) */
        case 131:
        /* EmptyRel:    intersect (Rel, EmptyRel) */
        case 132:
        /* EmptyRel:    difference (EmptyRel, Rel) */
        case 133:
        /* EmptyRel:    distinct (EmptyRel) */
        case 134:
        /* EmptyRel:    num_add (EmptyRel) */
        case 140:
        /* EmptyRel:    num_subtract (EmptyRel) */
        case 141:
        /* EmptyRel:    num_multiply (EmptyRel) */
        case 142:
        /* EmptyRel:    num_divide (EmptyRel) */
        case 143:
        /* EmptyRel:    num_modulo (EmptyRel) */
        case 144:
        /* EmptyRel:    num_neg (EmptyRel) */
        case 145:
        /* EmptyRel:    num_gt (EmptyRel) */
        case 146:
        /* EmptyRel:    num_eq (EmptyRel) */
        case 147:
        /* EmptyRel:    bool_and (EmptyRel) */
        case 148:
        /* EmptyRel:    bool_or (EmptyRel) */
        case 149:
        /* EmptyRel:    bool_not (EmptyRel) */
        case 150:
        /* EmptyRel:    avg (EmptyRel) */
        case 151:
        /* EmptyRel:    max_ (EmptyRel) */
        case 152:
        /* EmptyRel:    min_ (EmptyRel) */
        case 153:
        /* EmptyRel:    sum (EmptyRel) */
        case 154:
        /* EmptyRel:    count (EmptyRel) */
        case 155:
        /* EmptyRel:    rownum (EmptyRel) */
        case 160:
        /* EmptyRel:    number (EmptyRel) */
        case 161:
        /* EmptyRel:    type (EmptyRel) */
        case 162:
        /* EmptyRel:    type_assert (EmptyRel) */
        case 163:
        /* EmptyRel:    cast (EmptyRel) */
        case 164:
        /* EmptyRel:    seqty1 (EmptyRel) */
        case 165:
        /* EmptyRel:    all (EmptyRel) */
        case 166:
        /* EmptyRel:    scjoin (Frag, EmptyRel) */
        case 170:
        /* EmptyRel:    doc_access (Frag, EmptyRel) */
        case 171:
        /* EmptyRel:    roots_ (doc_tbl (EmptyRel)) */
        case 180:
        /* EmptyRel:    roots_ (element (Frag, element_tag (EmptyRel, Rel))) */
        case 181:
        /* EmptyRel:    roots_ (attribute (EmptyRel)) */
        case 182:
        /* EmptyRel:    roots_ (textnode (EmptyRel)) */
        case 183:
        /* EmptyRel:    roots_ (comment (EmptyRel)) */
        case 185:
        /* EmptyRel:    roots_ (processi (EmptyRel)) */
        case 186:
        /* EmptyRel:    roots_ (merge_adjacent (Frag, EmptyRel)) */
        case 187:
        /* EmptyRel:    cond_err (EmptyRel, Rel) */
        case 190:
        /* EmptyRel:    concat (EmptyRel) */
        case 200:
        /* EmptyRel:    string_join (EmptyRel, Rel) */
        case 201:
        /* EmptyRel:    dummy (EmptyRel) */
        case 202:
            break;

        default:
            break;
    }

    /* if we introduced a structural change the state labels
       will differ (before != after). Therefore the caller will
       start matching once more */
    return old_state_label != STATE_LABEL(p);
}

/* mark all nodes in the pattern of node p as seen 
   if it is not contained in kids. */
static void
mark_pattern_SEEN (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    for (i = 0; i < PFLA_OP_MAXCHILD; i++)
        if (p->child[i])
            mark_pattern_SEEN (p->child[i], kids);
 
    SEEN (p) = true;
}

/**
 * Check label of pattern rooted in p. 
 * (Every change in the state labels is reported)
 */
static bool
changed_label (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int i;
    bool res = false;

    for (i = 0; i < MAX_KIDS; i++)
        if (kids[i] && p == kids[i])
            return false;

    for (i = 0; i < PFLA_OP_MAXCHILD; i++)
        if (p->child[i])
            res = res ||
                  CHILD_STATE_LABEL(p, i) != STATE_LABEL(p->child[i]) ||
                  changed_label (p->child[i], kids);
    return res;
}

/* Relabel node p if it is not contained in kids. */
static unsigned int
relabel_worker (PFla_op_t *p,  PFla_op_t **kids, unsigned int counter)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i] && STATE_LABEL(p))
            return counter;
    }

    /* Relabel p's children. */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        counter = relabel_worker (L(p), kids, counter);
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
    }
    else if (!L(p) && R(p)) {
        counter = relabel_worker (R(p), kids, counter);
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    else {
        counter = relabel_worker (L(p), kids, counter);
        counter = relabel_worker (R(p), kids, counter);
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }

    assert (STATE_LABEL (p));

    assert (counter <= 50 && 
            "tree relabeling in general optimization phase " &&
            "might escape pattern boundaries");

    return counter + 1;
}

static void
relabel (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int counter = 0;

    counter = relabel_worker (p, kids, counter);

    /* relabel might relabel the complete DAG (looking at it as
       a tree) if it does not stop at the kids. Here we assume
       that no rewritten pattern has more than 50 nodes. If this
       warning occurs make sure that every relabel call finds the
       boundaries stored in kids. */
    if (counter > 50)
        PFinfo (OOPS_WARNING,
                "tree relabeling in general optimization phase "
                "might escape pattern boundaries");
}

/* Attach node labels in a DAG walk bottom-up */
static void
label (PFla_op_t *p)
{
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        if (!SEEN(L(p))) label (L(p));
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
    }
    else if (!L(p) && R(p)) {
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    else {
        if (!SEEN(L(p))) label (L(p));
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    SEEN(p) = true;

    assert (STATE_LABEL (p));
}

/**
 * Invoke algebra optimization.
 */
PFla_op_t *
PFalgopt_general (PFla_op_t *root)
{
    /* Attach node labels in a DAG walk bottom-up */
    label (root);
    PFla_dag_reset (root);

    /* Optimize algebra tree */
    while (reduce (root, 1));
    PFla_dag_reset (root);

    return root;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
