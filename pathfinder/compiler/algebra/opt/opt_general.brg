%{

/**
 * @file
 *
 * Optimize relational algebra expression DAG
 * based on general patterns.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * the Database Group at the Technische Universitaet Muenchen, Germany.
 * It is now maintained by the Database Systems Group at the Eberhard
 * Karls Universitaet Tuebingen, Germany.  Portions created by the
 * University of Konstanz, the Technische Universitaet Muenchen, and the
 * Universitaet Tuebingen are Copyright (C) 2000-2005 University of
 * Konstanz, (C) 2005-2008 Technische Universitaet Muenchen, and (C)
 * 2008-2010 Eberhard Karls Universitaet Tuebingen, respectively.  All
 * Rights Reserved.
 *
 * $Id$
 */

/* always include pf_config.h first! */
#include "pf_config.h"
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "algopt.h"
#include "properties.h"
#include "alg_dag.h"
#include "oops.h"         /* PFoops() */
#include "mem.h"          /* PFmalloc() */

/* mnemonic column list accessors */
#include "alg_cl_mnemonic.h"

/* Easily access subtree-parts */
#include "child_mnemonic.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFla_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p) ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* the state of the children determined during
   bottom-up labeling is backed up here */
#define CHILD_STATE_LABEL(p,i) ((p)->child_state_label[i])

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/logical.h!
 */
%term  serialize_seq   =   1
%term  serialize_rel   =   2
%term  side_effects    =   3
%term  lit_tbl         =   4
%term  empty_tbl       =   5
%term  ref_tbl         =   6
%term  attach          =   7
%term  cross           =   8
%term  eqjoin          =   9
%term  semijoin        =  10
%term  thetajoin       =  11
%term  project         =  12
%term  select_         =  13
%term  pos_select      =  14
%term  disjunion       =  16
%term  intersect       =  17
%term  difference      =  18
%term  distinct        =  19
%term  fun_1to1        =  20
%term  num_eq          =  25
%term  num_gt          =  26
%term  bool_and        =  28
%term  bool_or         =  29
%term  bool_not        =  30
%term  to              =  31
%term  aggr            =  32
%term  rownum          =  37
%term  rowrank         =  38
%term  rank            =  39
%term  rowid           =  40
%term  type            =  41
%term  type_assert     =  42
%term  cast            =  43
%term  step            =  50
%term  step_join       =  51
%term  guide_step      =  52
%term  guide_step_join =  53
%term  doc_index_join  =  54
%term  doc_tbl         =  55
%term  doc_access      =  56
%term  twig            =  60
%term  fcns            =  61
%term  docnode         =  62
%term  element         =  63
%term  attribute       =  64
%term  textnode        =  65
%term  comment         =  66
%term  processi        =  67
%term  content         =  68
%term  merge_adjacent  =  69
%term  roots_          =  70
%term  fragment        =  71
%term  frag_extract    =  72
%term  frag_union      =  73
%term  empty_frag      =  74
%term  error           =  78
%term  nil             =  79
%term  cache           =  80
%term  trace           =  81
%term  trace_items     =  82
%term  trace_msg       =  83
%term  trace_map       =  84
%term  rec_fix         =  85
%term  rec_param       =  86
%term  rec_arg         =  87
%term  rec_base        =  88
%term  fun_call        =  90
%term  fun_param       =  91
%term  fun_frag_param  =  92
%term  string_join     = 102
%term  dummy           = 120

%%

Query:  serialize_seq (
            side_effects (Side, Frag),
            Rel)                                  =   1 (10);
Query:  serialize_rel (Side, Rel)                 =   2 (10);
Rel:    lit_tbl                                   =   3 (10);
Rel:    ref_tbl                                   =   4 (10);
Rel:    attach (Rel)                              =   5 (10);
Rel:    attach (lit_tbl)                          =   6 (10);
Rel:    cross (Rel, Rel)                          =   7 (10);
Rel:    cross (lit_tbl, lit_tbl)                  =   8 (10);
Rel:    cross (Rel, lit_tbl)                      =   9 (10);
Rel:    cross (lit_tbl, Rel)                      =  10 (10);
Rel:    eqjoin (Rel, Rel)                         =  11 (10);
Rel:    eqjoin (lit_tbl, lit_tbl)                 =  12 (10);
Rel:    semijoin (Rel, Rel)                       =  13 (10);
Rel:    semijoin (distinct (Rel), Rel)            =  14 (10);
Rel:    thetajoin (Rel, Rel)                      =  15 (10);
Rel:    project (Rel)                             =  16 (10);
Rel:    project (attach (Rel))                    =  17 (10);
Rel:    project (project (Rel))                   =  18  (1);
Rel:    project (lit_tbl)                         =  19 (10);
Rel:    select_ (Rel)                             =  20 (10);
Rel:    pos_select (Rel)                          =  23 (10);
Rel:    disjunion (Rel, Rel)                      =  24 (10);
Rel:    disjunion (lit_tbl, lit_tbl)              =  25 (10);
Rel:    disjunion (EmptyRel, Rel)                 =  26  (5);
Rel:    disjunion (Rel, EmptyRel)                 =  27  (5);
Rel:    intersect (Rel, Rel)                      =  28 (10);
Rel:    difference (Rel, Rel)                     =  29 (10);
Rel:    difference (Rel, EmptyRel)                =  30  (5);
Rel:    distinct (Rel)                            =  32 (10);
Rel:    distinct (step (Frag, Rel))               =  33  (5);
Rel:    fun_1to1 (Rel)                            =  34 (10);
Rel:    num_gt (Rel)                              =  35 (10);
Rel:    num_eq (Rel)                              =  36 (10);
Rel:    bool_and (Rel)                            =  37 (10);
Rel:    bool_or (Rel)                             =  38 (10);
Rel:    bool_not (Rel)                            =  39 (10);
Rel:    to (Rel)                                  =  40 (10);
Rel:    aggr (Rel)                                =  45 (10);
Rel:    rownum (Rel)                              =  47 (10);
Rel:    rownum (lit_tbl)                          =  48 (10);
Rel:    rowrank (Rel)                             =  49 (10);
Rel:    rank (Rel)                                =  50 (10);
Rel:    rowid (Rel)                               =  51 (10);
Rel:    rowid (rowid (Rel))                       =  52 (10);
Rel:    rowid (project (rowid (Rel)))             =  53 (10);
Rel:    type (Rel)                                =  54 (10);
Rel:    type_assert (Rel)                         =  55 (10);
Rel:    cast (cast (Rel))                         =  56 (10);
Rel:    cast (project (cast (Rel)))               =  57 (10);
Rel:    cast (lit_tbl)                            =  58 (10);
Rel:    cast (Rel)                                =  59 (10);
Rel:    ScjRel                                    =  62 (10);
ScjRel: step (Frag, Rel)                          =  63 (10);
ScjRel: step (Frag, ScjRel)                       =  64 (10);
ScjRel: step (Frag, distinct (Rel))               =  65 (10);
Rel:    step_join (Frag, Rel)                     =  66 (10);
Rel:    guide_step (Frag, Rel)                    =  67 (10);
Rel:    guide_step_join (Frag, Rel)               =  68 (10);
Rel:    doc_index_join (Frag, Rel)                =  69 (10);
Rel:    doc_access (Frag, Rel)                    =  70 (10);

Rel:    roots_ (doc_tbl (Rel))                    =  74 (10);
Rel:    roots_ (twig (Twig))                      =  75 (10);
Rel:    roots_ (merge_adjacent (Frag, Rel))       =  76 (10);

Twig:   docnode (Rel, Fcns)                       =  77 (10);
Twig:   docnode (Rel,
                 fcns (content (Frag, EmptyRel),
                       nil))                      =  78 (10);
Twig:   element (Rel, Fcns)                       =  79 (10);
Twig:   element (Rel,
                 fcns (content (Frag, EmptyRel),
                       nil))                      =  80 (10);
Twig:   attribute (Rel)                           =  81 (10);
Twig:   textnode (Rel)                            =  82 (10);
Twig:   comment (Rel)                             =  83 (10);
Twig:   processi (Rel)                            =  84 (10);
Twig:   content (Frag, Rel)                       =  85 (10);
Twig:   nil                                       =  86 (10);

Fcns:   fcns (Twig, Fcns)                         =  87 (10);
Fcns:   fcns (content (Frag, EmptyRel), Fcns)     =  88 (10);
Fcns:   fcns (nil, nil)                           =  89 (10);
Fcns:   nil                                       =  90 (10);

Side:   error (Side, Rel)                         =  91 (10);
Side:   nil                                       =  92 (10);
Side:   cache (Side, Rel)                         =  93 (10);
Side:   trace (Side, Trc)                         =  94 (10);
Trc:    trace_items (Rel, Msg)                    =  95 (10);
Msg:    trace_msg (Rel, Map)                      =  96 (10);
Map:    trace_map (Rel, Map)                      =  97 (10);
Map:    nil                                       =  98 (10);

Rel:    rec_fix (side_effects (Side, Rec), Rel)   =  99 (10);
Rel:    rec_base                                  = 100 (10);
Rec:    rec_param (Arg, Rec)                      = 101 (10);
Rec:    nil                                       = 102 (10);
Arg:    rec_arg (Rel, Rel)                        = 103 (10);

Rel:    fun_call (Rel, Param)                     = 105 (10);
Param:  fun_param (Rel, Param)                    = 106 (10);
Param:  fun_frag_param (Frag, Param)              = 107 (10);
Param:  nil                                       = 108 (10);

Rel:    string_join (Rel, Rel)                    = 110 (10);
Rel:    dummy (Rel)                               = 111 (10);

Rel:    EmptyRel                                  = 112  (0);


Frag:    fragment (doc_tbl (Rel))                 = 114 (10);
Frag:    fragment (twig (Twig))                   = 115 (10);
Frag:    fragment (merge_adjacent (Frag, Rel))    = 116 (10);

Frag:    frag_extract (Rel)                       = 117 (10);
Frag:    frag_union (Frag, Frag)                  = 118 (10);
Frag:    empty_frag                               = 119 (10);

EmptyRel:    empty_tbl                            = 120  (0);

EmptyRel:    attach (EmptyRel)                    = 121  (0);
EmptyRel:    cross (EmptyRel, Rel)                = 122  (0);
EmptyRel:    cross (Rel, EmptyRel)                = 123  (0);
EmptyRel:    eqjoin (EmptyRel, Rel)               = 124  (0);
EmptyRel:    eqjoin (Rel, EmptyRel)               = 125  (0);
EmptyRel:    semijoin (EmptyRel, Rel)             = 126  (0);
EmptyRel:    semijoin (Rel, EmptyRel)             = 127  (0);
EmptyRel:    thetajoin (EmptyRel, Rel)            = 129  (0);
EmptyRel:    thetajoin (Rel, EmptyRel)            = 130  (0);
EmptyRel:    project (EmptyRel)                   = 131  (0);
EmptyRel:    select_ (EmptyRel)                   = 132  (0);
EmptyRel:    disjunion (EmptyRel, EmptyRel)       = 133  (0);
EmptyRel:    intersect (EmptyRel, Rel)            = 134  (0);
EmptyRel:    intersect (Rel, EmptyRel)            = 135  (0);
EmptyRel:    difference (EmptyRel, Rel)           = 136  (0);
EmptyRel:    distinct (EmptyRel)                  = 137  (0);
EmptyRel:    fun_1to1 (EmptyRel)                  = 140  (0);
EmptyRel:    num_gt (EmptyRel)                    = 145  (0);
EmptyRel:    num_eq (EmptyRel)                    = 146  (0);
EmptyRel:    bool_and (EmptyRel)                  = 147  (0);
EmptyRel:    bool_or (EmptyRel)                   = 148  (0);
EmptyRel:    bool_not (EmptyRel)                  = 149  (0);
EmptyRel:    to (EmptyRel)                        = 150  (0);
EmptyRel:    aggr (EmptyRel)                      = 155  (0);
EmptyRel:    rownum (EmptyRel)                    = 158  (0);
EmptyRel:    rowrank (EmptyRel)                   = 159  (0);
EmptyRel:    rank (EmptyRel)                      = 160  (0);
EmptyRel:    rowid (EmptyRel)                     = 161  (0);
EmptyRel:    type (EmptyRel)                      = 162  (0);
EmptyRel:    type_assert (EmptyRel)               = 163  (0);
EmptyRel:    cast (EmptyRel)                      = 164  (0);
EmptyRel:    step (Frag, EmptyRel)                = 170  (0);
EmptyRel:    step_join (Frag, EmptyRel)           = 171  (0);
EmptyRel:    guide_step (Frag, EmptyRel)          = 172  (0);
EmptyRel:    guide_step_join (Frag, EmptyRel)     = 173  (0);
EmptyRel:    doc_index_join (Frag, EmptyRel)      = 174  (0);
EmptyRel:    doc_access (Frag, EmptyRel)          = 176  (0);

EmptyRel:    roots_ (doc_tbl (EmptyRel))          = 180  (0);
EmptyRel:    roots_ (twig (docnode (EmptyRel,
                                    Fcns)))       = 181  (0);
EmptyRel:    roots_ (twig (element (EmptyRel,
                                    Fcns)))       = 182  (0);
EmptyRel:    roots_ (twig (attribute (EmptyRel))) = 183  (0);
EmptyRel:    roots_ (twig (textnode (EmptyRel)))  = 184  (0);
EmptyRel:    roots_ (twig (comment (EmptyRel)))   = 185  (0);
EmptyRel:    roots_ (twig (processi (EmptyRel)))  = 186  (0);
EmptyRel:    roots_ (twig (content (Frag,
                                    EmptyRel)))   = 187  (0);
EmptyRel:    roots_ (twig (nil))                  = 188  (0);
EmptyRel:    roots_ (merge_adjacent (Frag,
                                     EmptyRel))   = 189  (0);
EmptyRel:    fun_call (EmptyRel, Param)           = 190  (0);
EmptyRel:    string_join (EmptyRel, Rel)          = 191  (0);
EmptyRel:    dummy (EmptyRel)                     = 192  (0);

/* get rid of non-effective errors */
Query:  serialize_seq (
            side_effects (error (Side, EmptyRel),
                          Frag),
            Rel)                                  = 193  (0);
Query:  serialize_rel (error (Side, EmptyRel),
                       Rel)                       = 194  (0);
Side:   error (error (Side, EmptyRel), Rel)       = 195  (0);
Side:   trace (error (Side, EmptyRel), Trc)       = 196  (0);
Rel:    rec_fix (side_effects (
                    error (Side, EmptyRel),
                    Rec),
                Rel)                              = 197  (0);

%%

#include "algebra_mnemonic.h"

#define MAX_KIDS 10

#define SEEN(p) ((p)->bit_dag)

/* mark all nodes in the pattern of node p as seen
   if it is not contained in kids. */
static void mark_pattern_SEEN (PFla_op_t *p,  PFla_op_t **kids);

/* Check consistency of the state label in the pattern rooted in p */
static bool changed_label (PFla_op_t *p,  PFla_op_t **kids);

/* Relabel node p if it is not contained in kids. */
static void relabel (PFla_op_t *p,  PFla_op_t **kids);

static void
label (PFla_op_t *p);
/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFla_op_t *p, int goalnt)
{
    int              rule;       /* rule number that matches for this node */
    short           *nts;        /* target non-terminals for the leaf nodes of
                                    the current rule */
    PFla_op_t       *kids[MAX_KIDS];   /* leaf nodes of this rule */
    bool             rewritten = false;

    short            old_state_label;
    unsigned short   i;

    /* guard against too dep recursion */
    PFrecursion_fence();

    do {
        assert (STATE_LABEL (p));

        /* determine rule that matches for this non-terminal */
        rule = PFopt_general_rule (STATE_LABEL (p), goalnt);

        assert (rule);

        /* initialize the kids[] vector */
        for (unsigned short i = 0; i < MAX_KIDS; i++)
            kids[i] = NULL;

        /*
         * prepare recursive traversal: get information on leaf nodes of
         * this rule
         */
        nts = PFopt_general_nts[rule];
        PFopt_general_kids (p, rule, kids);

        /* check consistency of pattern labels */
        rewritten = changed_label (p, kids);

        /*
         * prune already optimized branch of the tree
         * (we try to treat the tree plan as DAG)
         */
        if (!SEEN(p) && !rewritten)
            /* recursively translate all leaf expressions */
            for (i = 0; nts[i]; i++)
                if ((rewritten = reduce (kids[i], nts[i])))
                    break;  /* abort if a subtree was rewritten */

        if (rewritten) {

            /*
             * If a subtree has been rewritten, we have to
             *  - re-label that part of the tree, and
             *  - possibly propagate the `rewritten' information upwards.
             */

            /* remember our old state_label (so we know if it has changed) */
            old_state_label = STATE_LABEL(p);

            /*
             * Re-label current tree pattern.
             * (at most down to the pattern leaves, as they should already be
             * correctly labeled by the above reduce() call)
             */
            relabel (p, kids);

            /* If our own state_label has changed, notify our caller. */
            if (old_state_label != STATE_LABEL(p)) {
                SEEN(p)= false;
                return true;
            }
        }
    } while (rewritten);

    /* save old_state_label to detect structural changes introduced
       by the following action code */
    old_state_label = STATE_LABEL(p);

    /* mark all nodes in the current pattern as visited
       to avoid tree traversals */
    mark_pattern_SEEN (p, kids);

    /* action code */
    switch (rule) {
        /* Rel:    lit_tbl */
        case 3:
            if (p->sem.lit_tbl.count == 0) {
                *p = *PFla_empty_tbl_ (p->schema);
                SEEN(p) = false;
                label (p);
            }
            break;

        /* Rel:    attach (lit_tbl) */
        case 6:
        {
            unsigned int     i, j,
                             acount  = p->schema.count,
                             tcount  = L(p)->sem.lit_tbl.count;
            PFalg_collist_t *collist = PFalg_collist (acount);
            PFalg_tuple_t   *tuples  = PFmalloc (tcount * sizeof (PFalg_tuple_t));
            PFalg_tuple_t    tuple;
            PFalg_atom_t     value   = p->sem.attach.value;

            /* copy the tuples and attach the value
               of the new column to every tuple */
            for (i = 0; i < tcount; i++) {
                tuple = L(p)->sem.lit_tbl.tuples[i];
                tuples[i].count = acount;
                tuples[i].atoms = PFmalloc (acount * sizeof (PFalg_atom_t));
                for (j = 0; j < acount - 1; j++)
                    tuples[i].atoms[j] = tuple.atoms[j];
                tuples[i].atoms[j] = value;
            }
            /* copy the aligned column names */
            for (j = 0; j < acount - 1; j++)
                cladd (collist) = L(p)->schema.items[j].name;
            cladd (collist) = p->sem.attach.res;

            *p = *PFla_lit_tbl_ (collist, tcount, tuples);
            SEEN(p) = false;
            label (p);
        }   break;

        /* Rel:    cross (lit_tbl, lit_tbl) */
        case 8:

        /* Rel:    cross (Rel, lit_tbl) */
        case 9:
            /* replace cross product with a literal table that contains
               only one row by a number of attach operators (one for each
               tuple). */
            if (R(p)->sem.lit_tbl.count == 1) {
                PFla_op_t *ret = L(p);
                SEEN(ret) = false;
                for (unsigned int i = 0; i < R(p)->schema.count; i++)
                    ret = PFla_attach (ret, R(p)->schema.items[i].name,
                                       R(p)->sem.lit_tbl.tuples[0].atoms[i]);
                *p = *(ret);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
            /* continue for rule 8 */
            if (rule != 8)
                break;
        /* Rel:    cross (lit_tbl, lit_tbl) */

        /* Rel:    cross (lit_tbl, Rel) */
        case 10:
            /* replace cross product with a literal table that contains
               only one row by a number of attach operators (one for each
               tuple). */
            if (L(p)->sem.lit_tbl.count == 1) {
                PFla_op_t *ret = R(p);
                SEEN(ret) = false;
                for (unsigned int i = 0; i < L(p)->schema.count; i++)
                    ret = PFla_attach (ret, L(p)->schema.items[i].name,
                                       L(p)->sem.lit_tbl.tuples[0].atoms[i]);
                *p = *(ret);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
            break;

        /* Rel:    eqjoin (lit_tbl, lit_tbl) */
        case 12:
            if (PFprop_type_of (p, p->sem.eqjoin.col1) == aat_nat &&
                L(p)->sem.lit_tbl.count == R(p)->sem.lit_tbl.count) {
                unsigned int     i, j,
                                 count   = p->schema.count,
                                 lcount  = L(p)->schema.count,
                                 rcount  = R(p)->schema.count,
                                 tcount  = L(p)->sem.lit_tbl.count,
                                 lidx,
                                 ridx;
                PFalg_collist_t *collist = PFalg_collist (count);
                PFalg_tuple_t   *tuples  = PFmalloc (tcount * sizeof (PFalg_tuple_t));
                PFalg_tuple_t    ltuple,
                                 rtuple;

                /* lookup the column index where the join columns reside */
                lidx = lcount+1;
                ridx = rcount+1;
                for (i = 0; i < lcount; i++)
                    if (L(p)->schema.items[i].name == p->sem.eqjoin.col1) {
                        lidx = i;
                        break;
                    }
                assert (lidx != lcount+1);
                for (i = 0; i < rcount; i++)
                    if (R(p)->schema.items[i].name == p->sem.eqjoin.col2) {
                        ridx = i;
                        break;
                    }
                assert (ridx != rcount+1);

                /* copy the tuples and apply a merge the columns */
                for (i = 0; i < tcount; i++) {
                    ltuple = L(p)->sem.lit_tbl.tuples[i];
                    rtuple = R(p)->sem.lit_tbl.tuples[i];

                    /* check if the value in this line has the correct value */
                    if (ltuple.atoms[lidx].val.nat_ != i+1 &&
                        rtuple.atoms[ridx].val.nat_ != i+1)
                        break;

                    tuples[i].count = count;
                    tuples[i].atoms = PFmalloc (count * sizeof (PFalg_atom_t));

                    for (j = 0; j < lcount; j++)
                        tuples[i].atoms[j] = ltuple.atoms[j];
                    for (j = 0; j < rcount; j++)
                        tuples[i].atoms[j+lcount] = rtuple.atoms[j];
                }
                /* abort if the values were not already dense and sorted */
                if (i < tcount)
                    break;

                /* copy the aligned column names */
                for (j = 0; j < lcount; j++)
                    cladd (collist) = L(p)->schema.items[j].name;
                for (j = 0; j < rcount; j++)
                    cladd (collist) = R(p)->schema.items[j].name;

                *p = *PFla_lit_tbl_ (collist, tcount, tuples);
                SEEN(p) = false;
                label (p);
            }
            break;

        /* Rel:    semijoin (distinct (Rel), Rel) */
        case 14:
            /* push down semijoin operator
               underneath the distinct operator as
               the semijoin hopefully is more selective
               than the distinct operator */
            *p = *PFla_distinct (
                      PFla_semijoin (
                          LL(p), R(p),
                          p->sem.eqjoin.col1,
                          p->sem.eqjoin.col2));
            SEEN(L(p)) = false;
            SEEN(p) = false;
            /* relabeling will be expensive
               if there is no real dummy node */
            relabel (p, kids);
            break;

        /* Rel:    project (Rel) */
        case 16:
        {   /**
             * we can skip every project operator that is not needed.
             * Therefore it has to fulfill two conditions:
             * 1. no column is renamed
             * 2. the number of columns does not change
             * (The first condition also ensures that no
             *  column is referenced twice thus allowing us to
             *  avoid a 1:1 column check.)
             */
            bool renamed = false;

            for (unsigned int i = 0; i < p->schema.count; i++)
                renamed = renamed ||
                          (p->sem.proj.items[i].new !=
                           p->sem.proj.items[i].old);

            if (!renamed && L(p)->schema.count == p->schema.count) {
                *p = *PFla_dummy (L(p));
                SEEN(p) = false;
                /* relabeling will be expensive
                   if there is no real dummy node */
                relabel (p, kids);
                break;
            }
        }   break;

        /* Rel:    project (attach (Rel)) */
        case 17:
            /* only rewrite if there are more than one columns */
            if (p->schema.count > 1) {
                bool found = false, rewrite = true;
                for (unsigned int i = 0; i < p->schema.count; i++)
                    if (p->sem.proj.items[i].old == L(p)->sem.attach.res) {
                        found = true;
                        rewrite = rewrite &&
                                  (p->sem.proj.items[i].old
                                   == p->sem.proj.items[i].new);
                    }

                /* if the projection neither discards nor renames
                   the attach result we can switch both operands  */
                if (found && rewrite) {
                    PFalg_proj_t *proj = PFmalloc ((p->schema.count - 1) *
                                                   sizeof (PFalg_proj_t));
                    unsigned int count = 0;

                    for (unsigned int j = 0; j < p->schema.count; j++)
                        if (L(p)->sem.attach.res
                            != p->sem.proj.items[j].old)
                            proj[count++] = p->sem.proj.items[j];

                    *p = *PFla_attach (PFla_project_ (LL(p), count, proj),
                                       L(p)->sem.attach.res,
                                       L(p)->sem.attach.value);
                    SEEN(L(p)) = false;
                    SEEN(p) = false;
                    relabel (p, kids);
                    break;
                }
            }
            break;

        /* Rel:    project (project (Rel)) */
        case 18:
            /* combine two projections */
            *p = *PFla_project_ (LL(p),
                                 p->schema.count,
                                 PFalg_proj_merge (
                                     p->sem.proj.items,
                                     p->sem.proj.count,
                                     L(p)->sem.proj.items,
                                     L(p)->sem.proj.count));

            SEEN(p) = false;
            relabel (p, kids);
            break;

        /* Rel:    project (lit_tbl) */
        case 19:
        {
            unsigned int     i, j, index,
                             acount  = p->schema.count,
                             tcount  = L(p)->sem.lit_tbl.count;
            PFalg_collist_t *collist = PFalg_collist (acount);
            PFalg_tuple_t   *tuples  = PFmalloc (tcount * sizeof (PFalg_tuple_t)),
                            *ltuples = L(p)->sem.lit_tbl.tuples;

            /* allocate memory for the tuples */
            for (j = 0; j < tcount; j++) {
                tuples[j].count = acount;
                tuples[j].atoms = PFmalloc (acount * sizeof (PFalg_atom_t));
            }

            /* iterate over all columns */
            for (i = 0; i < acount; i++) {
                /* copy the column names */
                cladd (collist) = p->sem.proj.items[i].new;

                /* find the corresponding column index in the table */
                for (j = 0; j < L(p)->schema.count; j++)
                    if (p->sem.proj.items[i].old == L(p)->schema.items[j].name)
                        break;
                assert (j < L(p)->schema.count);
                index = j;

                /* copy all values from the table */
                for (j = 0; j < tcount; j++)
                    tuples[j].atoms[i] = ltuples[j].atoms[index];
            }

            *p = *PFla_lit_tbl_ (collist, tcount, tuples);
            SEEN(p) = false;
            label (p);
        }   break;

        /* Rel:    select_ (Rel) */
        case 20:
        {
            /**
             *  introduce thetajoin based on
             *  one of the following patterns:
             *
             *    sel (res)    sel (res)   sel (res)   sel (res)
             *     |            |           |           |
             *   eq,gt       project      eq,gt      project
             *     |            |           |           |
             *     X          eq,gt      project      eq,gt
             *    / \           |           |           |
               rel1 rel2     project        X           X
             *                  |          / \         / \
             *                  X       rel1 rel2   rel1 rel2
             *                 / \
             *              rel1 rel2
             *
             * The result will be either:
             *
             *     @ (res, true)
             *     |
             *    |X| (eq|gt, rel.col1, rel.col2)
             *    / \
             * rel1 rel2
             *
             * or:
             *
             *     @ (res, true)
             *     |
             *  project
             *     |
             *    |X| (eq|gt, rel.col1, rel.col2)
             *    / \
             * rel1 rel2
             *
             */
            PFla_op_t *node;
            PFla_op_t *left = NULL;
            PFla_op_t *right = NULL;
            PFla_op_t *proj = NULL;
            PFla_op_t *proj2 = NULL;

            PFalg_col_t sel = p->sem.select.col;
            PFalg_col_t item1, item2;
            PFalg_comp_t comp;
            unsigned int i;

            node = L(p);

            if (node->kind == la_project) {
                proj = node;
                /* update the name of the selection */
                for (i = 0; i < node->sem.proj.count; i++)
                    if (sel == node->sem.proj.items[i].new) {
                        sel = node->sem.proj.items[i].old;
                        break;
                    }
                node = L(node);
            }

            /* the selection column has to match the
               result column of the comparison operator */
            if ((node->kind != la_num_eq && node->kind != la_num_gt) ||
                node->sem.binary.res != sel)
                break;

            if (node->kind == la_num_eq)
                comp = alg_comp_eq;
            else
                comp = alg_comp_gt;
            item1 = node->sem.binary.col1;
            item2 = node->sem.binary.col2;
            node = L(node);

            if (node->kind == la_project) {
                proj2 = node;
                /* update the names of the comparison input */
                for (i = 0; i < node->sem.proj.count; i++) {
                    if (item1 == node->sem.proj.items[i].new)
                        item1 = node->sem.proj.items[i].old;
                    if (item2 == node->sem.proj.items[i].new)
                        item2 = node->sem.proj.items[i].old;
                }
                node = L(node);
            }

            /* match the pattern */
            if (node->kind != la_cross)
                break;

            /* lookup the corresponding subtrees for the
               comparison inputs */
            for (i = 0; i < L(node)->schema.count; i++)
                if (L(node)->schema.items[i].name == item1)
                    left = L(node);
                else if (L(node)->schema.items[i].name == item2)
                    right = L(node);

            for (i = 0; i < R(node)->schema.count; i++)
                if (R(node)->schema.items[i].name == item1)
                    left = R(node);
                else if (R(node)->schema.items[i].name == item2)
                    right = R(node);

            /* the two comparison inputs are from the same relation
               -- multi-value dependency analysis will thus move the
               cross product up */
            if (!left || !right || left == right)
                break;

            /* Now all constraints are checked and the pattern
               can be replaced by an theta-join and an attach operator
               that adds the missing res column */
            if (!proj && !proj2) {
                PFalg_sel_t *pred = PFmalloc (sizeof (PFalg_sel_t));
                pred[0] = PFalg_sel (comp, item1, item2);
                *p = *PFla_attach (
                          PFla_thetajoin (left, right, 1, pred),
                          p->sem.select.col, PFalg_lit_bln (true));
                SEEN(p) = false;
                SEEN(L(p)) = false;
                /* relabel does not know that left and right are already
                   labeled correctly and thus would relabel the *complete*
                   subTREE! To avoid this make sure that kids contains the
                   references to left and right */
                kids[0] = left;
                kids[1] = right;
                relabel (p, kids);
                break;
            } else {
                PFla_op_t *res;
                PFalg_sel_t *pred = PFmalloc (sizeof (PFalg_sel_t));
                pred[0] = PFalg_sel (comp, item1, item2);

                res = PFla_thetajoin (left, right, 1, pred);
                if (proj2)
                    res = PFla_project_ (res,
                                         proj2->sem.proj.count,
                                         proj2->sem.proj.items);

                res = PFla_attach (res, sel, PFalg_lit_bln (true));

                if (proj)
                    res = PFla_project_ (res,
                                         proj->sem.proj.count,
                                         proj->sem.proj.items);

                *p = *res;

                SEEN(p) = false;
                SEEN(L(p)) = false;
                SEEN(LL(p)) = false;
                /* relabel does not know that left and right are already
                   labeled correctly and thus would relabel the *complete*
                   subTREE! To avoid this make sure that kids contains the
                   references to left and right */
                kids[0] = left;
                kids[1] = right;
                relabel (p, kids);
                break;
            }
        }   break;

        /* Rel:    disjunion (lit_tbl, lit_tbl) */
        case 25:
        {
            unsigned int     i, j, index,
                             acount  = p->schema.count,
                             lcount  = L(p)->sem.lit_tbl.count,
                             rcount  = R(p)->sem.lit_tbl.count,
                             tcount  = lcount + rcount;
            PFalg_collist_t *collist = PFalg_collist (acount);
            PFalg_tuple_t   *tuples  = PFmalloc (tcount * sizeof (PFalg_tuple_t)),
                            *ltuples = L(p)->sem.lit_tbl.tuples,
                            *rtuples = R(p)->sem.lit_tbl.tuples;

            /* allocate memory for the tuples */
            for (j = 0; j < tcount; j++) {
                tuples[j].count = acount;
                tuples[j].atoms = PFmalloc (acount * sizeof (PFalg_atom_t));
            }

            /* iterate over all columns */
            for (i = 0; i < acount; i++) {
                /* copy the column names */
                cladd (collist) = p->schema.items[i].name;

                /* find the corresponding column index in the left table */
                for (j = 0; j < acount; j++)
                    if (clat (collist, i) == L(p)->schema.items[j].name)
                        break;
                assert (j < acount);
                index = j;

                /* copy all values from the left table */
                for (j = 0; j < lcount; j++)
                    tuples[j].atoms[i] = ltuples[j].atoms[index];

                /* find the corresponding column index in the right table */
                for (j = 0; j < acount; j++)
                    if (clat (collist, i) == R(p)->schema.items[j].name)
                        break;
                assert (j < acount);
                index = j;

                /* copy all values from the right table */
                for (j = 0; j < rcount; j++)
                    tuples[j+lcount].atoms[i] = rtuples[j].atoms[index];
            }

            *p = *PFla_lit_tbl_ (collist, tcount, tuples);
            SEEN(p) = false;
            label (p);
        }   break;

        /* Rel:    disjunion (EmptyRel, Rel) */
        case 26:
            /* return right child */
            *p = *PFla_dummy (R(p));
            SEEN(p) = false;
            /* relabeling will be expensive
               if there is no real dummy node */
            relabel (p, kids);
            break;

        /* Rel:    disjunion (Rel, EmptyRel) */
        case 27:
        /* Rel:    difference (Rel, EmptyRel) */
        case 30:
            /* return left child */
            *p = *PFla_dummy (L(p));
            SEEN(p) = false;
            /* relabeling will be expensive
               if there is no real dummy node */
            relabel (p, kids);
            break;

        /* Rel:    intersect (Rel, Rel) */
        case 28:
            for (unsigned int i = 0; i < p->schema.count; i++)
                if (!p->schema.items[i].type) {
                    *p = *PFla_empty_tbl_ (p->schema);
                    SEEN(p) = false;
                    label (p);
                    break;
                }
            break;

        /* Rel:    difference (Rel, Rel) */
        case 29:
            for (unsigned int i = 0; i < p->schema.count; i++)
                /* return lhs argument in case of
                   a complete column type mismatch */
                if (!(PFprop_type_of (L(p), p->schema.items[i].name) &
                      PFprop_type_of (R(p), p->schema.items[i].name))) {
                    /* return left child */
                    *p = *PFla_dummy (L(p));
                    SEEN(p) = false;
                    /* relabeling will be expensive
                       if there is no real dummy node */
                    relabel (p, kids);
                    break;
                }
            break;

        /* Rel:    distinct (step (Frag, Rel)) */
        case 33:
            /* return left child */
            *p = *PFla_dummy (L(p));
            SEEN(p) = false;
            /* relabeling will be expensive
               if there is no real dummy node */
            relabel (p, kids);
            break;

        /* Rel:    num_eq (Rel) */
        case 36:
            /* merge back operators that were splitted
               due to a join push down */
            if (L(p)->kind == la_num_eq &&
                p->sem.binary.col1 == L(p)->sem.binary.col1 &&
                p->sem.binary.col2 == L(p)->sem.binary.col2) {
                PFalg_proj_t *proj;
                /* replace upper equality operator by a projection */
                proj = PFmalloc (p->schema.count * sizeof (PFalg_proj_t));
                for (unsigned int i = 0; i < p->schema.count; i++)
                    if (p->sem.binary.res == p->schema.items[i].name)
                        proj[i] = PFalg_proj (p->sem.binary.res,
                                              L(p)->sem.binary.res);
                    else
                        proj[i] = PFalg_proj (p->schema.items[i].name,
                                              p->schema.items[i].name);

                *p = *PFla_project_ (L(p), p->schema.count, proj);
                SEEN(p) = false;
                relabel (p, kids);
            }
            break;

        /* Rel:    aggr (Rel) */
        case 45:
        {
            unsigned int  i,
                          count;
            bool          rewrite = false;
            PFalg_proj_t *proj;

            for (i = 0; i < p->sem.aggr.count; i++)
                if (p->sem.aggr.aggr[i].kind != alg_aggr_dist)
                    break;

            /* Turn an aggregate into a simple distinct operator
               if all aggregates are 'distinct' operations. */
            if (p->sem.aggr.part &&
                i == p->sem.aggr.count) {
                PFalg_proj_t *proj;
                proj = PFmalloc (p->schema.count * sizeof (PFalg_proj_t));
                for (i = 0; i < p->sem.aggr.count; i++)
                    proj[i] = PFalg_proj (p->sem.aggr.aggr[i].res,
                                          p->sem.aggr.aggr[i].col);
                proj[i] = PFalg_proj (p->sem.aggr.part, p->sem.aggr.part);

                *p = *PFla_distinct (
                          PFla_project_ (L(p), p->schema.count, proj));
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }

            /* Get rid of superfluos aggregates that operate on the grouping
               column. Add the missing columns by a projection on top of the
               aggregate. */
            proj  = PFmalloc (p->schema.count * sizeof (PFalg_proj_t));
            count = 0;
            i     = 0;
            
            /* get rid of superfluous aggregates */
            while (i < p->sem.aggr.count) {
                if ((p->sem.aggr.aggr[i].kind == alg_aggr_dist ||
                     p->sem.aggr.aggr[i].kind == alg_aggr_min ||
                     p->sem.aggr.aggr[i].kind == alg_aggr_max) &&
                    p->sem.aggr.aggr[i].col == p->sem.aggr.part) {
                    proj[count++] = PFalg_proj (p->sem.aggr.aggr[i].res,
                                                p->sem.aggr.part);
                    p->sem.aggr.count--;
                    p->sem.aggr.aggr[i] = p->sem.aggr.aggr[p->sem.aggr.count];
                    rewrite = true;
                }
                else {
                    proj[count++] = PFalg_proj (p->sem.aggr.aggr[i].res,
                                                p->sem.aggr.aggr[i].res);
                    i++;
                }
            }
            /* complete projection list by adding grouping column */
            proj[count++] = PFalg_proj (p->sem.aggr.part, p->sem.aggr.part);

            if (rewrite) {
                *p = *PFla_project_ (
                          p->sem.aggr.count
                          ? PFla_aggr (
                                L(p),
                                p->sem.aggr.part,
                                p->sem.aggr.count,
                                p->sem.aggr.aggr)
                          /* skip aggregate if only the grouping
                             column is needed */
                          : PFla_distinct (
                                PFla_project (
                                    L(p), 
                                    PFalg_proj (p->sem.aggr.part,
                                                p->sem.aggr.part))),
                          count,
                          proj);
                SEEN(p) = false;
                relabel (p, kids);
            }

        }   break;

        /* Rel:    rownum (Rel) */
        case 47:
        {
            /**
             * row#_a<b>/   Throw away a key-generating rownum operator
             *   |          that numbers its output based on a single
             *  pi*         order criterion stemming from a key-generating
             *   |          rownum operator below the superfluous rownum.
             * row#_b<...>/
             */
            PFalg_col_t   col;
            PFla_op_t    *op;
            PFalg_proj_t *proj;

            /* check for key-generation, single order criterion, and
               ascending order */
            if (p->sem.sort.part ||
                PFord_count (p->sem.sort.sortby) != 1 ||
                PFord_order_dir_at (p->sem.sort.sortby, 0) != DIR_ASC)
                break;

            op = L(p);
            col = PFord_order_col_at (p->sem.sort.sortby, 0);

            /* ignore intermediate project operators */
            while (op->kind == la_project) {
                for (unsigned int i = 0; i < op->schema.count; i++)
                    if (op->sem.proj.items[i].new == col) {
                        col = op->sem.proj.items[i].old;
                        op = L(op);
                        break;
                    }
            }

            /* check for rownum operator that generates key values
               and provides the sort criterion for the upper rownum */
            if (op->kind != la_rownum ||
                op->sem.sort.part ||
                col != op->sem.sort.res)
                break;

            /* replace rownum operator by a projection */
            proj = PFmalloc (p->schema.count * sizeof (PFalg_proj_t));
            for (unsigned int i = 0; i < p->schema.count; i++)
                if (p->sem.sort.res == p->schema.items[i].name)
                    proj[i] = PFalg_proj (p->sem.sort.res,
                                          PFord_order_col_at (
                                              p->sem.sort.sortby,
                                              0));
                else
                    proj[i] = PFalg_proj (p->schema.items[i].name,
                                          p->schema.items[i].name);

            *p = *PFla_project_ (L(p), p->schema.count, proj);
            SEEN(p) = false;
            relabel (p, kids);
        }   break;

        /* Rel:    rownum (lit_tbl) */
        case 48:
            /* for a rownum operator with a single order column of type
               nat we check whether the order column is already identical
               to the result (under the assumption that the table is
               ordered). */
            if (!p->sem.sort.part &&
                L(p)->sem.lit_tbl.count &&
                PFord_count (p->sem.sort.sortby) == 1 &&
                PFord_order_dir_at (p->sem.sort.sortby, 0) == DIR_ASC &&
                PFprop_type_of (p, PFord_order_col_at (p->sem.sort.sortby, 0))
                    == aat_nat) {
                PFalg_col_t      sort_col;
                unsigned int     i,
                                 tcount  = L(p)->sem.lit_tbl.count,
                                 idx;
                PFalg_proj_t *proj = PFmalloc (
                                         p->schema.count
                                         * sizeof (PFalg_proj_t));

                /* lookup the column index where the sort column resides */
                sort_col = PFord_order_col_at (p->sem.sort.sortby, 0);
                idx = p->schema.count;
                for (i = 0; i < L(p)->schema.count; i++)
                    if (L(p)->schema.items[i].name == sort_col) {
                        idx = i;
                        break;
                    }
                assert (idx != p->schema.count);

                /* check for the correct values in the order column */
                for (i = 0; i < tcount; i++)
                    /* check if the value in this line has the correct value */
                    if (L(p)->sem.lit_tbl.tuples[i].atoms[idx].val.nat_ != i+1)
                        break;
                /* abort if the values were not already sorted */
                if (i < tcount)
                    break;

                /* copy projection list */
                for (unsigned int i = 0; i < p->schema.count; i++)
                    if (p->sem.sort.res == p->schema.items[i].name)
                        proj[i] = PFalg_proj (p->sem.sort.res,
                                              sort_col);
                    else
                        proj[i] = PFalg_proj (p->schema.items[i].name,
                                              p->schema.items[i].name);

                *p = *PFla_project_ (L(p), p->schema.count, proj);
                SEEN(p) = false;
                relabel (p, kids);
            }
            break;

        /* Rel:    rowrank (Rel) */
        case 49:
        /* Rel:    rank (Rel) */
        case 50:
            if (L(p)->kind == la_rank || L(p)->kind == la_rowrank) {
                PFalg_proj_t    *proj;
                PFord_ordering_t upper = p->sem.sort.sortby,
                                 lower = L(p)->sem.sort.sortby;
                unsigned int     i;

                /* check for identical orderings */                
                if (PFord_count (upper) != PFord_count (lower))
                    break;

                for (i = 0; i < PFord_count (upper); i++)
                    if (PFord_order_col_at (upper, i) !=
                        PFord_order_col_at (lower, i) ||
                        PFord_order_dir_at (upper, i) !=
                        PFord_order_dir_at (lower, i))
                        break;
                if (i < PFord_count (upper))
                    break;

                /* we found an identical ordering
                   and can combine both operators */
                proj = PFmalloc (p->schema.count * sizeof (PFalg_proj_t));
                for (i = 0; i < L(p)->schema.count; i++)
                    proj[i] = PFalg_proj (L(p)->schema.items[i].name,
                                          L(p)->schema.items[i].name);
                proj[L(p)->schema.count] = PFalg_proj (p->sem.sort.res,
                                                       L(p)->sem.sort.res);

                *p = *PFla_project_ (
                          PFla_rowrank (LL(p), L(p)->sem.sort.res, lower),
                          p->schema.count, proj);
                /* if both inputs are rank operators they will eventually
                   become rank operators again */

                SEEN(p) = false;
                /* relabel does not know that the left and the right children
                   are already labeled correctly and thus would relabel
                   the *complete* subTREE! To avoid this make sure that kids
                   contains the correct references */
                kids[0] = LL(p);
                relabel (p, kids);
            }
            break;

        /* Rel:    rowid (rowid (Rel)) */
        case 52:
        {
            PFalg_proj_t *proj = PFmalloc (
                                     p->schema.count
                                     * sizeof (PFalg_proj_t));
            /* copy property list */
            for (unsigned int i = 0; i < p->schema.count; i++)
                if (p->sem.rowid.res == p->schema.items[i].name)
                    proj[i] = PFalg_proj (p->sem.rowid.res,
                                          L(p)->sem.rowid.res);
                else
                    proj[i] = PFalg_proj (p->schema.items[i].name,
                                          p->schema.items[i].name);

            *p = *PFla_project_ (L(p), p->schema.count, proj);
            SEEN(p) = false;
            relabel (p, kids);
        }   break;

        /* Rel:    rowid (project (rowid (Rel))) */
        case 53:
        {
            unsigned int count = L(p)->sem.proj.count;
            PFalg_proj_t *proj = PFmalloc (
                                     (count + 1)
                                     * sizeof (PFalg_proj_t));
            /* copy property list */
            for (unsigned int i = 0; i < count; i++)
                proj[i] = L(p)->sem.proj.items[i];

            proj[count] = PFalg_proj (p->sem.rowid.res,
                                      LL(p)->sem.rowid.res);

            *p = *PFla_project_ (LL(p), count + 1, proj);
            SEEN(p) = false;
            relabel (p, kids);
        }   break;

        /* Rel:    type_assert (Rel) */
        case 55:
            /* if we statically know that the type assertion would yield
               an empty type we can replace it by an empty table */
            if (!(PFprop_type_of (L(p), p->sem.type.col) & p->sem.type.ty)) {
                *p = *PFla_empty_tbl_ (p->schema);
                SEEN(p) = false;
                label (p);
                break;
            }
            /* throw out type_assert if it is not needed anymore */
            for (unsigned int i = 0; i < L(p)->schema.count; i++)
                if (p->sem.type.col == L(p)->schema.items[i].name) {
                    if (p->sem.type.ty == L(p)->schema.items[i].type) {
                        *p = *PFla_dummy (L(p));
                        SEEN(p) = false;
                        /* relabeling will be expensive
                           if there is no real dummy node */
                        relabel (p, kids);
                    }
                    break;
                }
            break;

        /* Rel:    cast (cast (Rel)) */
        case 56:
        /* Rel:    cast (project (cast (Rel))) */
        case 57:
            /* Discard the casts if the cast maps from string
               to untypedAtomic and back to string. */
        {
            PFla_op_t *cast;
            bool proj = false, found = false;
            unsigned int i;
            PFalg_col_t col = p->sem.type.col;

            /* check for a projection in between and update
               the name of the outer cast input */
            if (L(p)->kind == la_project) {
                proj = true;
                for (i = 0; i < L(p)->sem.proj.count; i++)
                    if (col == L(p)->sem.proj.items[i].new) {
                        col = L(p)->sem.proj.items[i].old;
                        break;
                    }
                cast = LL(p);
            }
            else
                cast = L(p);

            /* make sure the input of the first cast
               is of type string */
            for (i = 0; i < cast->schema.count; i++)
                if (cast->schema.items[i].name == cast->sem.type.col &&
                    cast->schema.items[i].type == aat_str) {
                    found = true;
                    break;
                }

            /* enforce the constraints: child node is a cast,
               the output of the nested cast and the input of
               the outer cast match, the inner cast applies a
               cast to untypedAtomic, and the outer to string */
            if (found &&
                col == cast->sem.type.res &&
                cast->sem.type.ty == aat_uA &&
                p->sem.type.ty == aat_str) {

                PFalg_proj_t *proj_list;
                /* create projection list */
                proj_list = PFmalloc (p->schema.count *
                                      sizeof (*(proj_list)));

                if (proj) {
                    /* if there was already a projection keep that
                       one and extend it with the result column of the
                       outer cast that refers to the orginal input column */
                    for (i = 0; i < L(p)->sem.proj.count; i++)
                        proj_list[i] = L(p)->sem.proj.items[i];

                    proj_list[i] = PFalg_proj (p->sem.type.res,
                                               cast->sem.type.col);
                }
                else
                    /* keep all column and link the result column of the
                       outer cast to the input column of the nested cast */
                    for (i = 0; i < p->schema.count; i++)
                        if (p->schema.items[i].name == p->sem.type.res)
                            proj_list[i] = PFalg_proj (p->sem.type.res,
                                                       cast->sem.type.col);
                        else
                            proj_list[i] = PFalg_proj (p->schema.items[i].name,
                                                       p->schema.items[i].name);

                /* Replace the outer cast (and the project) by a new project
                   that avoids the unnecessary casts. (The second cast will
                   be removed by an icols optimization phase.) */
                *p = *PFla_project_ (cast, p->schema.count, proj_list);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
        } /* fall trough otherwise */

        /* Rel:    cast (lit_tbl) */
        case 58:
            /* apply the cast in the literal table */
            if (L(p)->kind == la_lit_tbl &&
                p->sem.type.ty == aat_int &&
                PFprop_type_of (p, p->sem.type.col) == aat_nat) {
                unsigned int     i, j,
                                 count  = p->schema.count,
                                 tcount  = L(p)->sem.lit_tbl.count,
                                 idx;
                PFalg_collist_t *collist = PFalg_collist (count);
                PFalg_tuple_t   *tuples  = PFmalloc (tcount * sizeof (PFalg_tuple_t));
                PFalg_tuple_t    tuple;

                idx = p->schema.count;
                for (i = 0; i < L(p)->schema.count; i++)
                    if (L(p)->schema.items[i].name == p->sem.type.col) {
                        idx = i;
                        break;
                    }
                assert (idx != p->schema.count);

                /* copy the tuples and cast the value
                   of the input column in every tuple */
                for (i = 0; i < tcount; i++) {
                    tuple = L(p)->sem.lit_tbl.tuples[i];
                    tuples[i].count = count;
                    tuples[i].atoms = PFmalloc (count * sizeof (PFalg_atom_t));
                    for (j = 0; j < count - 1; j++)
                        tuples[i].atoms[j] = tuple.atoms[j];
                    /* cast the value to integer */
                    tuples[i].atoms[j]
                        = PFalg_lit_int (tuple.atoms[idx].val.nat_);
                }
                /* copy the aligned column names */
                for (j = 0; j < count - 1; j++)
                    cladd (collist) = L(p)->schema.items[j].name;
                cladd (collist) = p->sem.type.res;

                *p = *PFla_lit_tbl_ (collist, tcount, tuples);
                SEEN(p) = false;
                label (p);
            }
            /* fall trough otherwise */

        /* Rel:    cast (Rel) */
        case 59:
        {
            /*
             * If an algebra expression already has the requested
             * type, replace it by a projection.
             */
            bool cast_req = true;
            for (unsigned int i = 0; i < p->schema.count; i++)
                if (p->sem.type.col == p->schema.items[i].name &&
                    p->sem.type.ty == p->schema.items[i].type) {
                    cast_req = false;
                    break;
                }

            if (!cast_req) {
                PFalg_proj_t *proj = PFmalloc (p->schema.count
                                               * sizeof (PFalg_proj_t));

                for (unsigned int j = 0; j < p->schema.count; j++)
                    if (p->schema.items[j].name != p->sem.type.res) {
                        proj[j] = PFalg_proj (p->schema.items[j].name,
                                              p->schema.items[j].name);
                    } else {
                        proj[j] = PFalg_proj (p->sem.type.res,
                                              p->sem.type.col);
                    }

                *p = *PFla_project_ (L(p), p->schema.count, proj);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
        }   break;

        /* ScjRel: step (Frag, ScjRel) */
        case 64:
            /* combine steps if they are of the form:
               ``/descandent-or-self::node()/child::element()'' */
            if (R(p)->sem.step.spec.axis == alg_desc_s &&
                R(p)->sem.step.spec.kind == node_kind_node &&
                p->sem.step.spec.axis == alg_chld) {
                PFalg_step_spec_t spec = p->sem.step.spec;
                spec.axis = alg_desc,
                /* rewrite child into descendant
                   and discard descendant-or-self step */
                *p = *PFla_step_simple (
                          L(p), RR(p), spec,
                          p->sem.step.iter, R(p)->sem.step.item,
                          p->sem.step.item_res);
                SEEN(p) = false;
                /* relabel does not know that the left and the right children
                   are already labeled correctly and thus would relabel
                   the *complete* subTREE! To avoid this make sure that kids
                   contains the correct references */
                kids[0] = L(p);
                kids[1] = R(p);
                relabel (p, kids);
                break;
            }
            break;

        /* ScjRel: step (Frag, distinct (Rel)) */
        case 65:
            R(p) = L(R(p));
            SEEN(p) = false;
            relabel (p, kids);
            break;

        /* Twig:   docnode (Rel,
                            fcns (content (Frag, EmptyRel),
                                  nil)) */
        case 78:
        /* Twig:   element (Rel,
                            fcns (content (Frag, EmptyRel),
                                  nil)) */
        case 80:
            RL(p) = PFla_nil();
            SEEN(p) = false;
            relabel (p, kids);
            break;

        /* Fcns:   fcns (content (Frag, EmptyRel), Fcns) */
        case 88:
        /* Fcns:   fcns (nil, nil) */
        case 89:
            /* This rewrite splits up the R(p) operator... */
            *p = *R(p);
            /* ... and we at least have to create a new property to avoid
               inconsistencies (see also definition for PFla_dummy()). */
            p->prop = PFprop ();

            SEEN(p) = false;
            /* relabel won't work because we have a copy of R(p) now */
            label (p);
            break;

        /* Rel:    EmptyRel */
        case 112:
        {
            /*
             * Replace any sub-tree that we determined empty with these
             * rules by the literal empty table.
             */
            *p = *PFla_empty_tbl_ (p->schema);
            SEEN(p) = true;
            label (p);
        } break;

        /* Query:  serialize_seq (
                       side_effects (error (Side, EmptyRel), Frag),
                       Rel) */
        case 193:
        /* Rel:    rec_fix (side_effects (error (Side, EmptyRel), Rec), Rel) */
        case 197:
            LL(p) = LLL(p);
            SEEN(p) = false;
            relabel (p, kids);
            break;

        /* Query:  serialize_rel (error (Side, EmptyRel), Rel) */
        case 194:
        /* Side:   error (error (Side, EmptyRel), Rel) */
        case 195:
        /* Side:   trace (error (Side, EmptyRel), Trc) */
        case 196:
            L(p) = LL(p);
            SEEN(p) = false;
            relabel (p, kids);
            break;
        case 199:
	    /* INCOMPLETE, GENERATE A CONSTANT '1' HERE */
	    /* fall through */

        default:
            /* every occurrence of EmptyRel already copes with
               the empty relation - we therefore need no special
               translation and use the default branch (the rules
               are pruned anyway) */
            break;
    }

    /* if we introduced a structural change the state labels
       will differ (before != after). Therefore the caller will
       start matching once more */
    return old_state_label != STATE_LABEL(p);
}

/* mark all nodes in the pattern of node p as seen
   if it is not contained in kids. */
static void
mark_pattern_SEEN (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    for (i = 0; i < PFLA_OP_MAXCHILD; i++)
        if (p->child[i])
            mark_pattern_SEEN (p->child[i], kids);

    SEEN (p) = true;
}

/**
 * Check label of pattern rooted in p.
 * (Every change in the state labels is reported)
 */
static bool
changed_label (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int i;
    bool res = false;

    for (i = 0; i < MAX_KIDS; i++)
        if (kids[i] && p == kids[i])
            return false;

    for (i = 0; i < PFLA_OP_MAXCHILD; i++)
        if (p->child[i])
            res = res ||
                  CHILD_STATE_LABEL(p, i) != STATE_LABEL(p->child[i]) ||
                  changed_label (p->child[i], kids);
    return res;
}

/* Relabel node p if it is not contained in kids. */
static unsigned int
relabel_worker (PFla_op_t *p,  PFla_op_t **kids, unsigned int counter)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i] && STATE_LABEL(p))
            return counter;
    }

    /* Relabel p's children. */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        counter = relabel_worker (L(p), kids, counter);
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
    }
    else if (!L(p) && R(p)) {
        counter = relabel_worker (R(p), kids, counter);
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    else {
        counter = relabel_worker (L(p), kids, counter);
        counter = relabel_worker (R(p), kids, counter);
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }

    assert (STATE_LABEL (p));
    assert (0 <= STATE_LABEL (p) && STATE_LABEL (p) <= PFopt_general_Max_state);

    assert (counter <= 50 &&
            "tree relabeling in general optimization phase " &&
            "might escape pattern boundaries");

    return counter + 1;
}

static void
relabel (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int counter = 0;

    counter = relabel_worker (p, kids, counter);

    /* relabel might relabel the complete DAG (looking at it as
       a tree) if it does not stop at the kids. Here we assume
       that no rewritten pattern has more than 50 nodes. If this
       warning occurs make sure that every relabel call finds the
       boundaries stored in kids. */
    if (counter > 50)
        PFinfo (OOPS_WARNING,
                "tree relabeling in general optimization phase "
                "might escape pattern boundaries");
}

/* Attach node labels in a DAG walk bottom-up */
static void
label (PFla_op_t *p)
{
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        if (!SEEN(L(p))) label (L(p));
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
    }
    else if (!L(p) && R(p)) {
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    else {
        if (!SEEN(L(p))) label (L(p));
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    SEEN(p) = true;

    assert (STATE_LABEL (p));
    assert (0 <= STATE_LABEL (p) && STATE_LABEL (p) <= PFopt_general_Max_state);
}

/**
 * Invoke algebra optimization.
 */
PFla_op_t *
PFalgopt_general (PFla_op_t *root)
{
    /* Attach node labels in a DAG walk bottom-up */
    label (root);
    PFla_dag_reset (root);

    /* Optimize algebra tree */
    while (reduce (root, 1));
    PFla_dag_reset (root);

    return root;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
