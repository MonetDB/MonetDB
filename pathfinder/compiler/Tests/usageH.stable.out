stdout of test 'usageH` in directory 'compiler` itself:


# 15:43:45 >  
# 15:43:45 >  ./usageH usageH 
# 15:43:45 >  


# 15:43:45 >  
# 15:43:45 >  Mtimeout -timeout 60 pf -H
# 15:43:45 >  

Pathfinder XQuery Compiler ($Revision$, $Date$)
(c) Database Systems Group, Eberhard Karls Universitaet Tuebingen

Usage: pf [OPTION] [FILE]

  Reads from standard input if FILE is omitted.

= -A, --mil: generate MIL code (default)
= -M, --mil_2004: generate MIL code (directly from XQuery Core)
= -S, --sql: generate SQL code

= -I, --xml-import: import logical-algebra-plan from xml file

= -D, --dot: print internal tree structure in AT&T dot notation
= -P, --text: print internal tree structure in human-readable notation
              (can be used in combination with options -a or -c)
= -X, --xml: print internal algebraic plan in XML notation
             (if options -A, -M, and -S are not used this option
              implicitly extends options with -S, -l, and -s18)

= -a, --abstract-syntax-tree: enable generation of abstract syntax tree
= -c, --core-tree: enable generation of internal Core language
= -t, --typing: enable generation of static types in internal Core language
                using {...} (can be used in combination with option -c)
= -l, --logical-algebra-plan: enable generation of logical algebra plan
= -p, --physical-algebra-plan: enable generation of physical algebra plan
= -f<format>, --format=<format>: enable generation of algebra properties
         +  print all available properties (logical/physical algebra)
         <optoptions> selectively choose optimization options that are based
                      on a single property (e.g., 'O') to print the respective
                      property
         c  print cost value (physical algebra)
         o  print orderings (physical algebra)

= -s<phase>, --stop-after=<phase>: stop processing after certain phase:
         1  right after input parsing
         2  after loading XQuery modules
         3  after parse/abstract syntax tree has been normalized
         4  after namespaces have been checked and resolved
         5  after option declarations have been extracted from the parse tree
         6  after guide tree has been build
         7  after variable scoping has been checked
         8  after XQuery built-in functions have been loaded
         9  after XML Schema predefined types have been loaded
        10  after valid function usage has been checked
        11  after XML Schema document has been imported (if any)
        12  after the abstract syntax tree has been mapped to Core
        13  after the Core tree has been simplified/normalized
        14  after type inference and checking
        15  after XQuery Core optimization
        16  after the Core tree has been translated to the logical algebra
        17  after the logical algebra tree has been rewritten/optimized
        18  after the CSE on the logical algebra tree
        19  after compiling logical algebra into the physical algebra (or SQL)
        20  after introducing boundary operators
        21  after compiling the physical algebra into MIL code
        22  after the MIL program has been serialized

= -o<optoptions>, --optimize-algebra=<optoptions>: optimize algebra according to optimization options:
         E  merge common subexpressions (CSE)
         G  apply general optimization (without properties)
         O  apply optimization based on constant property
         I  apply optimization based on icols property
         K  apply optimization based on key property
         N  apply optimization based on required node values property
         V  apply optimization based on required values property
         S  apply optimization based on set property
         U  apply optimization based on XML Guide information
            (only works for the SQL code generation)
         C  apply optimization using multiple properties (complex)
            (and icols based optimization will be applied afterwards)
         J  push down equi-joins
         M  push up cross products (based on multi-value dependencies
         T  push up theta-joins (based on multi-value dependencies
         R  push up rank operators
         }  introduce proxy operators that representoperator groups
         {  remove proxy operators
         D  apply optimizations tailored for MonetDB/XQuery
         Q  apply optimizations tailored for the SQL code generation
         [  assign a new set of unique column names
         ]  assign bit-encoded column names (deprecated optimization option)
         P  infer all properties
         _  does nothing (used for structuring the optimization options)
            (default for option -A is: '-o OIKCG_VG_JIS_I_GECSVR_OIK_N}MT{JISAI_GYECSVR_}MT{JISAI_OIK_GYECSVR_DC_GP')
            (default for option -S is: '-o OIKCG_VG_JIS_I_GECSVR_OIK_NQU_}MT{JISAI_GYECSVR_QU_}MT{JISAI_OIK_GYECSVR_QU_CGP')

= -e[0|1], --mil-dead-code-elimination=[0|1]: dead code elimination (on the MIL level):
         0  disable dead code elimination
         1  enable dead code elimination (default)
= -O[0-3], --optimize: select optimization level (default=1)
                       (only works in combination with option -M)
= -b, --enable-standoff: enable StandOff axis steps
= -q, --quiet: do not print informational messages to log file

= -T, --timing: print elapsed times for compiler phases

= -h, --help: print short help message
= -H, --fullhelp: print this help message for advanced options

Enjoy.

# 15:43:46 >  
# 15:43:46 >  Done.
# 15:43:46 >  

