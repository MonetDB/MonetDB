%{

/*
 * Compile physical algebra tree into a MIL program.
 *
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Initial Developer of the Original Code is the Database &
 * Information Systems Group at the University of Konstanz, Germany.
 * Portions created by the University of Konstanz are Copyright (C)
 * 2000-2005 University of Konstanz.  All Rights Reserved.
 *
 *
 * $Id$
 */


#include "pathfinder.h"

#include <assert.h>

#include "oops.h"
#include "mem.h"
#include "physical.h"
#include "mil.h"

#include "subtyping.h"

#include <stdio.h>

/*
 * Accessors for the burg matcher
 */
typedef struct PFpa_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/physical.h!
 */
%term lit_tbl        =   1
%term empty_tbl      =   2
%term append_union   =   3
%term merge_union    =   4
%term intersect      =   5
%term difference     =   6
%term cross          =   7
%term attach         =   8
%term project        =   9
%term nljoin         =  10
%term merge_join     =  11
%term sort_distinct  =  12
%term std_sort       =  13
%term refine_sort    =  14
%term merge_rownum   =  15
%term hash_rownum    =  16
%term num_add        =  17
%term num_add_atom   =  18
%term num_sub        =  19
%term num_sub_atom   =  20
%term num_mult       =  21
%term num_mult_atom  =  22
%term num_div        =  23
%term num_div_atom   =  24
%term num_mod        =  25
%term num_mod_atom   =  26
%term eq             =  27
%term eq_atom        =  28
%term gt             =  29
%term gt_atom        =  30
%term num_neg        =  31
%term bool_not       =  32
%term bool_and       =  33
%term bool_or        =  34
%term cast           =  35
%term select         =  36
%term hash_count     =  37
%term llscj_anc      = 100
%term llscj_anc_self = 101
%term llscj_attr     = 102
%term llscj_child    = 103
%term llscj_desc     = 104
%term llscj_desc_self= 105
%term llscj_foll     = 106
%term llscj_foll_sibl= 107
%term llscj_parent   = 108
%term llscj_prec     = 109
%term llscj_prec_sibl= 110
%term doc_tbl        = 111
%term doc_access     = 112
%term string_join    = 113
%term serialize      = 114
%term roots          = 115
%term fragment       = 116
%term frag_union     = 117
%term empty_frag     = 118

%%

Query:    serialize (FragList, Rel)                                =   1 (10);

Rel:      lit_tbl                                                  =   2 (10);
Rel:      attach (Rel)                                             =   3 (10);
Rel:      append_union (Rel, Rel)                                  =   4 (10);
Rel:      merge_union (Rel, Rel)                                   =   5 (10);
Rel:      project (Rel)                                            =   6 (10);
Rel:      merge_rownum (Rel)                                       =   7 (10);
Rel:      roots (FragRel)                                          =   8 (10);
Rel:      sort_distinct (Rel)                                      =   9 (10);
Rel:      llscj_anc (FragList, Rel)                                =  10 (10);
Rel:      llscj_anc_self (FragList, Rel)                           =  11 (10);
Rel:      llscj_attr (FragList, Rel)                               =  12 (10);
Rel:      llscj_child (FragList, Rel)                              =  13 (10);
Rel:      llscj_desc (FragList, Rel)                               =  14 (10);
Rel:      llscj_desc_self (FragList, Rel)                          =  15 (10);
Rel:      llscj_foll (FragList, Rel)                               =  16 (10);
Rel:      llscj_foll_sibl (FragList, Rel)                          =  17 (10);
Rel:      llscj_parent (FragList, Rel)                             =  18 (10);
Rel:      llscj_prec (FragList, Rel)                               =  19 (10);
Rel:      llscj_prec_sibl (FragList, Rel)                          =  20 (10);
Rel:      nljoin (Rel, Rel)                                        =  21 (10);
Rel:      merge_join (Rel, Rel)                                    =  22 (10);
Rel:      refine_sort (Rel)                                        =  23 (10);
Rel:      num_add (Rel)                                            =  24 (10);
Rel:      num_sub (Rel)                                            =  25 (10);
Rel:      num_mult (Rel)                                           =  26 (10);
Rel:      num_div (Rel)                                            =  27 (10);
Rel:      num_mod (Rel)                                            =  28 (10);
Rel:      num_add_atom (Rel)                                       =  29 (10);
Rel:      num_sub_atom (Rel)                                       =  30 (10);
Rel:      num_mult_atom (Rel)                                      =  31 (10);
Rel:      num_div_atom (Rel)                                       =  32 (10);
Rel:      num_mod_atom (Rel)                                       =  33 (10);
Rel:      eq (Rel)                                                 =  34 (10);
Rel:      eq_atom (Rel)                                            =  35 (10);
Rel:      gt (Rel)                                                 =  36 (10);
Rel:      gt_atom (Rel)                                            =  37 (10);
Rel:      num_neg (Rel)                                            =  38 (10);
Rel:      bool_not (Rel)                                           =  39 (10);
Rel:      bool_and (Rel)                                           =  40 (10);
Rel:      bool_or (Rel)                                            =  41 (10);
Rel:      cast (Rel)                                               =  42 (10);
Rel:      select (Rel)                                             =  43 (10);
Rel:      difference (Rel, Rel)                                    =  44 (10);
Rel:      std_sort (Rel)                                           =  45 (10);
Rel:      hash_count (Rel)                                         =  46 (10);

Rel:      doc_access (FragList, Rel)                               =  60 (10);
Rel:      string_join (Rel, Rel)                                   =  61 (10);

FragRel:  doc_tbl (Rel)                                            = 100 (10);

FragList: empty_frag                                               = 200 (10);
FragList: frag_union (FragList, Frag)                              = 201 (10);

Frag:     fragment (FragRel)                                       = 205 (10);

%%

#include "mil_mnemonic.h"

/**
 * We collect the MIL program during compilation here.
 */
static PFmil_t *milprog = NULL;

/**
 * Processing is done bottom-up. This is just the order in
 * which we want to print our code. So we keep the whole
 * MIL program in the variable #milprog, and append commands
 * as we go. Think of it as ``executing'' the commands
 * right away.
 */
#define execute(...) milprog = seq (milprog, __VA_ARGS__)

/**
 * Represents a MIL variable.
 *
 * The variable has a name (that is automatically generated).
 * The @a pins field keeps track of the number of references
 * to this variable.  A variable may not be destroyed before
 * @a pins drops to zero.
 */
struct mvar_t {
    PFmil_ident_t   name;
    unsigned int    pins;
};

/** short-hand for struct mvar_t */
typedef struct mvar_t mvar_t;

/**
 * Remember @em all variables that we deal with during the compiler
 * run in here.  We want to re-use variables as much as possible to
 * reduce the number of active variables in the MIL program.  This
 * should help MonetDB with its memory management.
 *
 * Each time we need a new variable, we try to re-use an old one
 * from here.  We thus search for a variable with pin count zero.
 * If we cannot find any, we create a new variable and append it to
 * the list.
 */
PFarray_t *mvars = NULL;

/**
 * Return a ``new'' valid variable.  Will try to re-use an old,
 * no longer needed, variable, if possible.  For this, the
 * function searches #mvars for a variable with @a pins = 0. If
 * no such variable can be found, a new one will be created and
 * appended to the list.  
 *
 * The new variable will be initialized with the pin count given
 * in @a pins.
 */
static mvar_t *
new_var (unsigned int pins)
{
    static unsigned int   varno = 0;
    mvar_t               *var   = NULL;

    assert (mvars);
    assert (varno < 10000);

    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        if ((var = (mvar_t *) PFarray_at (mvars, i))->pins == 0) {
            var->pins = pins;
            return var;
        }

    /* If we were not successful, create a new entry */
    var = (mvar_t *) PFarray_add (mvars);

    var->name = PFmalloc (sizeof ("a0000"));
    sprintf ((char *) var->name, "a%04u", varno++);

    var->pins = pins;

    return var;
}

/**
 * Pin a variable (i.e., increment its pin count by @a count).
 */
static void
pin (mvar_t *v, unsigned int count)
{
    v->pins += count;
}

/**
 * Unpin a variable (i.e., decrement its pin count by @a count).
 * If the pin count reaches zero, automatically generates a MIL
 * statement that assigns @c unused to the variable, marking it
 * a candidate for MonetDB's garbage collection.
 */
static void
unpin (mvar_t *v, unsigned int count)
{
    if (v->pins < count) {
        PFinfo (OOPS_WARNING, "pin count below zero");
        v->pins = 0;
    } else
        v->pins -= count;

    if (!v->pins)
        execute (assgn (var (v->name), unused ()));
}


/**
 * Environment entry.  In each physical algebra tree node, we keep
 * an environment that maps an attribute/type combination to the
 * #mvar_t struct that holds the corresponding MIL variable.
 */
struct env_t {
    PFalg_att_t          att;
    PFalg_simple_type_t  ty;
    mvar_t              *mvar;
};
typedef struct env_t env_t;

/**
 * Create a new (empty) environment for #env_t entries.
 *
 * With each node in the physical algebra DAG, we keep such an
 * environment that maps an attribute/type combination onto the
 * #mvar_t item that implements it. (Think of this as the mapping
 * from attribute/type to the BAT that represents that combination.
 */
static PFarray_t *
new_env (void)
{
    return PFarray (sizeof (env_t));
}

/**
 * Add an item to environment.
 */
void
env_add (PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty, mvar_t *v)
{
    assert (ty == aat_nat || ty == aat_int || ty == aat_str || ty == aat_dec
            || ty == aat_dbl || ty == aat_bln
            || ty == aat_pre || ty == aat_attr
            || ty == aat_pfrag || ty == aat_afrag);

    *(env_t *) PFarray_add (env)
        = (env_t) { .att = att, .ty = ty, .mvar = v };
}

/**
 * Return environment size.
 */
unsigned int
env_count (const PFarray_t *env)
{
    return PFarray_last (env);
}

/**
 * Return environment item at index @a i.
 */
env_t
env_at (const PFarray_t *env, unsigned int i)
{
    assert (i < PFarray_last (env));

    return *(env_t *) PFarray_at ((PFarray_t *) env, i);
}

/**
 * Look up an entry in the environment @a env, given a combination
 * of attribute (@a att) and type (@a ty) as the search key.
 */
mvar_t *
env_mvar (const PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    for (unsigned int i = 0; i < PFarray_last (env); i++) {

        env_t entry = *(env_t *) PFarray_at ((PFarray_t *) env, i);

        if (entry.att == att && entry.ty == ty)
            return entry.mvar;
    }

    /* FIXME: DEBUGGING ONLY */
    fprintf (stderr, "looking for att: %s, ty: %u", PFatt_print (att), ty);
    fprintf (stderr, "environment looks like:\n");
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        env_t entry = *(env_t *) PFarray_at ((PFarray_t *) env, i);

        fprintf (stderr, "  att: %s, type: %u, mvar->name: %s\n",
                         PFatt_print (entry.att), entry.ty, entry.mvar->name);
    }
    /* */

    /* Entry was not found. In many cases this indicates a problem
     * at the caller's side. In some cases, however, it may be okay,
     * and we don't bailout with PFoops() right away.
     */
    return NULL;
}

PFmil_t *
VAR (PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    assert (env_mvar (env, att, ty));

    return var (env_mvar (env, att, ty)->name);
}

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))

#define MAX_KIDS 10

enum axis_t {
      ax_anc
    , ax_anc_self
    , ax_child
    , ax_desc
    , ax_desc_self
    , ax_foll
    , ax_foll_sibl
    , ax_parent
    , ax_prec
    , ax_prec_sibl
};

static PFalg_simple_type_t type_of (PFpa_op_t *n, PFalg_att_t att);
static PFmil_t * literal (PFalg_atom_t atom);

/* helper to handle loop-lifted staircase join operator */
static void llscj (enum axis_t axis, const PFpa_op_t *p);
/* translate arithmetic operators where both arguments are a BAT */
static void bin_arith (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                       PFpa_op_t *p);
/* translate arithmetic operators where one argument is an atom */
static void bin_arith_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                            PFpa_op_t *p);
/* translate binary coparison operator (eq/gt) */
static void bin_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                      PFpa_op_t *p);
static void bin_comp_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                           PFpa_op_t *p);
/* translate binary Boolean operator (and/or) */
static void bin_bool (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                      PFpa_op_t *p);
/* translate unary operators (numeric negation, Boolean not) */
static void unary_op (PFmil_t * (*op) (const PFmil_t *), PFpa_op_t *p);

/** MIL implementation types for algebra types */
static PFmil_type_t impl_types[] = {
      [aat_nat]   = m_oid
    , [aat_int]   = m_int
    , [aat_str]   = m_str
    , [aat_dec]   = m_dbl
    , [aat_dbl]   = m_dbl
    , [aat_bln]   = m_bit
    , [aat_pre]   = m_oid
    , [aat_attr]  = m_oid
    , [aat_pfrag] = m_oid
    , [aat_afrag] = m_oid
};

/** implementation type for a given algebra type, as a MIL node */
#ifndef NDEBUG
#define implty(n) type (impl_types[n] \
                        ? impl_types[n] \
                        : (PFoops (OOPS_FATAL, "illegal type in implty()"), 0))
#else
#define implty(n) type (impl_types[n])
#endif

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFpa_op_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */

    if (p->env)
        return;

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
assert(rule);
    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);

    /* PFinfo (OOPS_NOTICE, "in rule %u", rule); */

    switch (rule) {
        /* Query:    serialize (FragList, Rel) */
        case 1:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     */
    if (!topdown)
        for (unsigned short i = 0; nts[i]; i++)
            reduce (kids[i], nts[i]);

    if (p->env)
        return;

    p->env = new_env ();

    switch (rule) {

        /* Query:   serialize (FragList, Rel) */
        case 1:
        {
            mvar_t *intVAL, *dblVAL, *decVAL, *strVAL;
            mvar_t *item, *kind;
            PFalg_simple_type_t ty;
            bool sorted = false;

            /*
            PFmil_t *args = NULL;
            */

            execute (
                assgn (unused (), nil ()),
                assgn (var ("ws"), new_ws ()));
            reduce (kids[0], nts[0]);
            reduce (kids[1], nts[1]);

            /* Set up all the value containers for print_result().
             * (It is actually too much overhead to introduce the value
             * containers just for printing. But this way we can re-use
             * Jan F's print_result() and stay compatible with the
             * ``summer branch''.
             */

            intVAL = new_var (1);
            dblVAL = new_var (1);
            decVAL = new_var (1);
            strVAL = new_var (1);
            item = new_var (1);
            kind = new_var (1);

            execute (
                assgn (var (intVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_int), type (m_void)), true)),
                           lit_oid (0))),
                assgn (var (dblVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_dbl), type (m_void)), true)),
                           lit_oid (0))),
                assgn (var (decVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_dbl), type (m_void)), true)),
                           lit_oid (0))),
                assgn (var (strVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_str), type (m_void)), true)),
                           lit_oid (0))),
                assgn (var (item->name),
                       seqbase (new (type (m_void), type (m_oid)), lit_oid(0))),
                assgn (var (kind->name),
                       seqbase (new (type (m_void), type (m_int)), lit_oid(0)))
                );

            ty = type_of (R(p), att_item);

            /* consider attribute results */
            if (ty & aat_anode) {
                if (ty == aat_anode) {
                    execute (
                        assgn (var (item->name),
                               VAR (R(p)->env, att_item, aat_attr)),
                        assgn (var (kind->name),
                               set_kind (VAR (R(p)->env, att_item, aat_afrag),
                                         var ("ATTR")))
                        );
                    sorted = true;
                }
                else {
                    assert (ty & aat_attr && ty & aat_afrag);
                    execute (
                        binsert (var (item->name),
                                 select2 (
                                     VAR (R(p)->env, att_item, aat_attr),
                                     nil (),
                                     nil ())),
                        binsert (var (kind->name),
                                 select2 (
                                     set_kind (VAR (R(p)->env, 
                                                    att_item,
                                                    aat_afrag),
                                               var ("ATTR")),
                                     cast (type (m_int), nil ()),
                                     cast (type (m_int), nil ())))
                        );
                }
            }

            /* consider node results */
            if (ty & aat_pnode) {
                if (ty == aat_pnode) {
                    execute (
                        assgn (var (item->name),
                               VAR (R(p)->env, att_item, aat_pre)),
                        assgn (var (kind->name),
                               set_kind (VAR (R(p)->env, att_item, aat_pfrag),
                                         var ("ELEM")))
                        );
                    sorted = true;
                }
                else {
                    assert (ty & aat_pre && ty & aat_pfrag);
                    execute (
                        binsert (var (item->name),
                                 select2 (
                                     VAR (R(p)->env, att_item, aat_pre),
                                     nil (),
                                     nil ())),
                        binsert (var (kind->name),
                                 select2 (
                                     set_kind (VAR (R(p)->env, 
                                                    att_item,
                                                    aat_pfrag),
                                               var ("ELEM")),
                                     cast (type (m_int), nil ()),
                                     cast (type (m_int), nil ())))
                        );
                }
            }

            /* consider str results */
            if (ty & aat_str) {
                execute (
                    bappend (var (strVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       att_item,
                                                       aat_str),
                                                  cast (type (m_str), nil ()),
                                                  cast (type (m_str), nil ()))
                                         )))));
                if (ty == aat_str) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, att_item, aat_str),
                                      reverse (var (strVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, att_item, aat_str),
                                     var ("STR")))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, att_item, aat_str),
                                  reverse (var (strVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, att_item, aat_str),
                                              cast (type (m_str), nil ()),
                                              cast (type (m_str), nil ())),
                                     var ("STR")))
                    );
                }
            }

            /* consider int results */
            if (ty & aat_int) {
                execute (
                    bappend (var (intVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       att_item,
                                                       aat_int),
                                                  cast (type (m_int), nil ()),
                                                  cast (type (m_int), nil ()))
                                         )))));
                if (ty == aat_int) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, att_item, aat_int),
                                      reverse (var (intVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, att_item, aat_int),
                                     var ("INT")))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, att_item, aat_int),
                                  reverse (var (intVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, att_item, aat_int),
                                              cast (type (m_int), nil ()),
                                              cast (type (m_int), nil ())),
                                     var ("INT")))
                    );
                }
            }

            /* consider dbl results */
            if (ty & aat_dbl) {
                execute (
                    bappend (var (dblVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       att_item,
                                                       aat_dbl),
                                                  cast (type (m_dbl), nil ()),
                                                  cast (type (m_dbl), nil ()))
                                         )))));
                if (ty == aat_dbl) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, att_item, aat_dbl),
                                      reverse (var (dblVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, att_item, aat_dbl),
                                     var ("DBL")))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, att_item, aat_dbl),
                                  reverse (var (dblVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, att_item, aat_dbl),
                                              cast (type (m_dbl), nil ()),
                                              cast (type (m_dbl), nil ())),
                                     var ("DBL")))
                    );
                }
            }

            /* consider dec results */
            if (ty & aat_dec) {
                execute (
                    bappend (var (decVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       att_item,
                                                       aat_dec),
                                                  cast (type (m_dbl), nil ()),
                                                  cast (type (m_dbl), nil ()))
                                         )))));
                if (ty == aat_dec) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, att_item, aat_dec),
                                      reverse (var (decVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, att_item, aat_dec),
                                     var ("DEC")))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, att_item, aat_dec),
                                  reverse (var (decVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, att_item, aat_dec),
                                              cast (type (m_dbl), nil ()),
                                              cast (type (m_dbl), nil ())),
                                     var ("DEC")))
                    );
                }
            }

            /* consider bit results */
            if (ty & aat_bln) {
                if (ty == aat_int) {
                    execute (
                        assgn (
                            var (item->name),
                            mcast (type (m_oid),
                                   VAR (R(p)->env, att_item, aat_bln))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, att_item, aat_bln),
                                     var ("BOOL")))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            mcast (type (m_oid),
                                   VAR (R(p)->env, att_item, aat_bln))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, att_item, aat_bln),
                                              cast (type (m_bit), nil ()),
                                              cast (type (m_bit), nil ())),
                                     var ("BOOL")))
                    );
                }
            }

            if (!sorted)
                execute (
                    assgn (var (item->name),
                           reverse (sort (reverse (var (item->name))))),
                    assgn (var (kind->name),
                           leftjoin (mirror (var (item->name)),
                                     var (kind->name))));

            execute (
                assgn (var (item->name),
                       reverse (mark (reverse (var (item->name)),lit_oid (0)))),
                assgn (var (kind->name),
                       reverse (mark (reverse (var (kind->name)),lit_oid (0)))),

                serialize (
                    arg (lit_str ("xml"),
                        arg (var ("ws"),
                            arg (var (item->name),
                                arg (var (kind->name),
                                    arg (var (intVAL->name),
                                        arg (var (dblVAL->name),
                                            arg (var (decVAL->name),
                                                 var (strVAL->name))))))))));

            /*
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                if (i)
                    args = arg (args,
                                var (env_at (R(p)->env, i).mvar->name));
                else
                    args = var (env_at (R(p)->env, i).mvar->name);
            }

            execute (print (args));
            */

        } break;

        /* Rel:      lit_tbl */
        case 2:

            /* iterate over table columns */
            for (unsigned int col = 0; col < p->schema.count; col++)

                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & p->schema.items[col].type) {

                        mvar_t *v = new_var (p->refctr);
                        env_add (p->env, p->schema.items[col].name, t, v);

                        execute (
                            assgn (
                                var (v->name),
                                seqbase (
                                    new (type (m_void), implty (t)),
                                    lit_oid (0))));

                        for (unsigned int row = 0;
                                row < p->sem.lit_tbl.count; row++)
                            execute (
                                insert (
                                    var (v->name),
                                    nil (),
                                    t == p->sem.lit_tbl.tuples[row]
                                                              .atoms[col].type
                                    ? literal (p->sem.lit_tbl.tuples[row]
                                                              .atoms[col])
                                    : cast (implty (t), nil ())));

                        execute (access (var (v->name), BAT_READ));
                    }

            break;

        /* Rel:      attach (Rel) */
        case 3:
        {
            /* copy all the existing variables */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }

            /* now create the new column */
            mvar_t *v = new_var (p->refctr);
            env_add (p->env, p->sem.attach.attname,
                     p->sem.attach.value.type, v);

            execute (
                assgn (var (v->name),
                       project (var (env_at (p->env, 0).mvar->name),
                                literal (p->sem.attach.value))));

        } break;

        /* Rel:      append_union (Rel, Rel) */
        case 4:

            for (unsigned int i = 0; i < p->schema.count; i++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & p->schema.items[i].type) {

                        mvar_t *v = new_var (p->refctr);

                        /*
                         * Type t is in the result relation. See if it
                         * is also in the left operand.
                         */
                        if (t & type_of (L(p), p->schema.items[i].name))
                            /* v := l.copy */
                            execute (
                                assgn (
                                    var (v->name),
                                    access (
                                        copy (VAR (L(p)->env,
                                                   p->schema.items[i].name,
                                                   t)),
                                        BAT_APPEND)));
                        else
                            /* v := <some BAT of L>.project(nil); */
                            execute (
                                assgn (
                                    var (v->name),
                                    access (
                                        project (
                                            var (env_at (L(p)->env, 0).mvar
                                                                       ->name),
                                            cast (implty (t), nil ())),
                                        BAT_APPEND)));

                        /*
                         * Is t also in the right operand?
                         */
                        if (t & type_of (R(p), p->schema.items[i].name))
                            /* v.append(R); */
                            execute (
                                access (
                                    bappend (
                                        var (v->name),
                                        VAR (R(p)->env,
                                             p->schema.items[i].name,
                                             t)),
                                    BAT_READ));
                        else
                            /* v.append(<some BAT of L>.project(nil)); */
                            execute (
                                access (
                                    bappend (
                                        var (v->name),
                                        project (
                                            var (env_at (R(p)->env, 0).mvar
                                                                       ->name),
                                            cast (implty (t), nil ()))),
                                    BAT_APPEND));

                        env_add (p->env, p->schema.items[i].name, t, v);
                    }

            break;

        /* Rel:      merge_union (Rel, Rel) */
        case 5:
        {
            PFmil_t *grouping[2];
            PFmil_t *args;
            bool     single_column_grouping = true;
            mvar_t  *v = NULL;

            /*
             * If the grouping parameter for MergeUnion is just a
             * single column, we can use the corresponding BAT right
             * away.  Otherwise, we need to use MonetDB's CT...()
             * functions to generate a BAT that describes just that
             * grouping.
             */
            grouping[0]
                = VAR (L(p)->env,
                       PFord_order_at (p->sem.merge_union.ord, 0),
                       type_of (L(p),
                                PFord_order_at (p->sem.merge_union.ord, 0)));
            grouping[1]
                = VAR (R(p)->env,
                       PFord_order_at (p->sem.merge_union.ord, 0),
                       type_of (R(p),
                                PFord_order_at (p->sem.merge_union.ord, 0)));

            /*
             * We know (from the ordering properties we derived) that
             * our input is appropriately ordered. The grouping
             * function CTderive(), however, also provides grouping
             * from un-ordered groups (using a hash-based implementation).
             * This way, the resulting grouping BATs will not be marked
             * as tail-ordered (although they always will be, as we
             * know from our own ordering properties). We thus need to
             * check orderings explicitly (using chk_order()).
             *
             * An alternative to CTderive() could help us in two ways:
             *
             *  (1) There's actually no need to use a hash-based
             *      implementation, if we know that our input has the
             *      correct ordering.
             *  (2) An order-aware implementation could set ordering
             *      properties correctly right away.
             */
            for (unsigned int i = 1;
                    i < PFord_count (p->sem.merge_union.ord); i++) {

                single_column_grouping = false;

                grouping[0]
                    = ctderive (
                        grouping[0],
                        VAR (L(p)->env,
                             PFord_order_at (p->sem.merge_union.ord, i),
                             type_of (
                                 L(p),
                                 PFord_order_at (p->sem.merge_union.ord, i))));
                grouping[1]
                    = ctderive (
                        grouping[1],
                        VAR (R(p)->env,
                             PFord_order_at (p->sem.merge_union.ord, i),
                             type_of (
                                 R(p),
                                 PFord_order_at (p->sem.merge_union.ord, i))));
            }

            /*
             * If we had to CTderive(), turn the grp result into an
             * actual BAT using CTmap().
             */
            if (PFord_count (p->sem.merge_union.ord) > 1)
                for (unsigned int i = 0; i < 2; i++)
                    grouping[i] = ctmap (grouping[i]);


            /* first two arguments of merged_union() are the grouping atts */
            args = arg (chk_order (grouping[0]), chk_order (grouping[1]));

            for (unsigned int i = 0; i < p->schema.count; i++) {

                /*
                 * If we group by a single column, then we don't need
                 * to list the grouping attribute a second time.
                 */
                if (!single_column_grouping
                    || p->schema.items[i].name !=
                       PFord_order_at (p->sem.merge_union.ord, 0)) {

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & p->schema.items[i].type) {

                            for (unsigned short j = 0; j <= 1; j++)
                                /*
                                 * If t is among the operand's types, use the
                                 * corresponding BAT, otherwise substitute a
                                 * BAT with `nil' tail.
                                 */
                                if (t & type_of (p->child[j],
                                                 p->schema.items[i].name))
                                    args = arg (args,
                                                VAR (p->child[j]->env,
                                                     p->schema.items[i].name,
                                                     t));
                                else
                                    args = arg (args,
                                                project (grouping[j],
                                                         cast (implty(t),
                                                               nil ())));
                        }
                }
            }

            v = new_var (1);

            /* execute merged_union() and assign it to v */
            execute (assgn (var (v->name), merged_union (args)));

            unsigned int j = 1;

            /* now extract all the result BATs */
            for (unsigned int i = 0; i < p->schema.count; i++) {

                /*
                 * If we group by a single column, then the grouping
                 * attribute is to be found as the first result BAT.
                 */
                if (!single_column_grouping
                    || p->schema.items[i].name !=
                       PFord_order_at (p->sem.merge_union.ord, 0)) {

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & p->schema.items[i].type) {

                            mvar_t *w = new_var (p->refctr);

                            execute (
                                assgn (var (w->name),
                                       fetch (var (v->name), lit_int (j))));
                            env_add (p->env, p->schema.items[i].name, t, w);
                            j++;

                        }
                }
                else {
                    PFalg_simple_type_t t
                        = type_of (p, p->schema.items[i].name);
                    mvar_t *w = new_var (p->refctr);

                    env_add (p->env, p->schema.items[i].name, t, w);
                    execute (
                            assgn (var (w->name),
                                fetch (var (v->name), lit_int (0))));
                }
            }

            /* release our temporary variable v */
            unpin (v, 1);

        } break;

        /* Rel:      project (Rel) */
        case 6:
            /*
             * Algebra projection is a no-op. We only fill the
             * environment in node p appropriately.
             */
            for (unsigned int i = 0; i < p->sem.proj.count; i++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & type_of (L(p), p->sem.proj.items[i].old)) {

                        mvar_t *v = env_mvar (L(p)->env,
                                              p->sem.proj.items[i].old,
                                              t);
                        assert (v);

                        env_add (p->env, p->sem.proj.items[i].new, t, v);
                        pin (v, p->refctr);

                    }

            break;

        /* Rel:      rownum (Rel) */
        case 7:
        {
            mvar_t *v = new_var (p->refctr);

            /* copy all the attributes from our argument */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {

                pin (env_at (L(p)->env, i).mvar, p->refctr);

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }

            /* and add the newly numbered one */
            if (p->sem.rownum.part != aat_NULL)
                execute (
                    assgn (var (v->name),
                           mark_grp (
                               VAR (p->env,
                                    p->sem.rownum.part,
                                    type_of (p, p->sem.rownum.part)),
                               project (
                                   kunique (
                                       reverse (
                                           VAR (p->env,
                                                p->sem.rownum.part,
                                                type_of (p, p->sem.rownum.part))
                                           )),
                                   lit_oid (1)))));
            else
                execute (
                    assgn (var (v->name),
                           mark (var (env_at (L(p)->env, 0).mvar->name),
                                 lit_oid (1))));

            env_add (p->env, p->sem.rownum.attname, aat_nat, v);

        } break;

        /* Rel:      roots (FragRel) */
        case 8:
            /* copy all the attributes from our argument */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {

                pin (env_at (L(p)->env, i).mvar, p->refctr);

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Rel:      sort_distinct (Rel) */
        case 9:
        {
            /*
             * Derive a single BAT from the multi-column grouping
             * (using functions from the xtables module).
             */
            mvar_t  *v = new_var (1);
            bool     initialized = false;

            for (unsigned int i = 0;
                    i < PFord_count (p->sem.sort_distinct.ord); i++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if (t & type_of (L(p),
                                     PFord_order_at (p->sem.sort_distinct.ord,
                                                     i))) {
                        if (!initialized) {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctgroup (VAR (L(p)->env,
                                             PFord_order_at (p->sem
                                                               .sort_distinct
                                                               .ord, i),
                                             t))));
                            initialized = true;
                        }
                        else {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctderive (
                                        ctmap (var (v->name)),
                                        VAR (L(p)->env,
                                             PFord_order_at (p->sem
                                                               .sort_distinct
                                                               .ord, i),
                                             t))));
                        }
                    }
                }
            }

            /*
             * Variable v is now of MIL type grp and contains the
             * grouping we need.
             *
             * We get the duplicate-free equivalent of our input by
             * joining the extend of v with each input BAT (and
             * generating a new key with mark().
             *
             * v := v.CTextend ().mark (0@0).reverse ();
             */
            execute (
                assgn (var (v->name),
                       reverse (mark (ctextend (var (v->name)),
                                      lit_oid (0)))));

            /*
             * The join with each input relation:
             *
             * out := v.join (in);
             */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {

                mvar_t *out = new_var (p->refctr);

                execute (
                    assgn (var (out->name),
                           leftjoin (var (v->name),
                                     var (env_at (L(p)->env, i).mvar->name))));

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         out);
            }

            /* release our temporary variable */
            unpin (v, 1);

        } break;

        /* Rel:      llscj_anc (FragList, Rel) */
        case 10:
            llscj (ax_anc, p);
            break;

        /* Rel:      llscj_anc_self (FragList, Rel) */
        case 11:
            llscj (ax_anc_self, p);
            break;

        /* Rel:      llscj_attr (FragList, Rel) */
        case 12:
        {
            /* abbreviations for input expressions */
            PFty_t           ty  = p->sem.scjoin.ty;

            /* MIL equivalents of input expression */
            PFmil_t *iter;
            PFmil_t *pre;
            PFmil_t *frag;

            mvar_t  *tmp;         /* helper variable */
            mvar_t  *ret_iter;    /* variable to which we assign the `iter' result */
            mvar_t  *ret_attr;     /* variable to which we assign the `pre' result */
            mvar_t  *ret_frag;    /* variable to which we assign the `kind' result */
            
            /*
             * Determine generic input arguments.
             */
            assert (p); assert (R(p)); assert (R(p)->env);
            iter = VAR (R(p)->env, att_iter, aat_nat); assert (iter);
            pre = VAR (R(p)->env, att_item, aat_pre); assert (pre);
            frag = VAR (R(p)->env, att_item, aat_pfrag); assert (frag);

            tmp      = new_var (1);
            ret_iter = new_var (p->refctr);
            ret_attr  = new_var (p->refctr);
            ret_frag = new_var (p->refctr);

            /* first get all attribute nodes... */
            execute (
                assgn (var (tmp->name), 
                       mvaljoin (pre, frag, fetch (var("ws"),
                                                    var("ATTR_OWN")))),
                assgn (var (ret_attr->name),
                       reverse (mark (reverse (var (tmp->name)), lit_oid (0)))),
                assgn (var (ret_frag->name),
                       leftjoin (reverse (mark (var (tmp->name), lit_oid (0))),
                                 frag)),
                assgn (var (ret_iter->name),
                       leftjoin (reverse (mark (var (tmp->name), lit_oid (0))),
                                 iter)));

            /* ... then filter out all nodes, whose name test does not match */
            if (PFty_subtype (ty, PFty_xs_anyAttribute ())) {

                /* Is it just a generic attribute kind test? (e.g. .../attribute()) */
                if (PFty_subtype (PFty_xs_anyAttribute (), ty))
                    ;

                /* Is it a test on attribute kind and local name only? */
                else if (PFty_subtype (
                            PFty_attr (PFqname (PFns_wild,
                                                PFty_qname (PFty_defn (ty)).loc),
                                       PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_QN"))),
                                         mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_FRAG"))),
                                         fetch (var("ws"), var("QN_LOC")))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_loc (
                                                PFty_qname (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name), var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name), var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name), var (ret_iter->name))));

                /* Or maybe a test on attribute kind and namespace only? */
                else if (PFty_subtype (
                            PFty_attr (PFqname (PFty_qname (PFty_defn (ty)).ns,
                                                NULL),
                                       PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_QN"))),
                                         mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_FRAG"))),
                                         fetch (var("ws"), var("QN_URI")))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_uri (
                                                PFty_qname (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name), var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name), var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name), var (ret_iter->name))));

                /* A test on attribute kind and full QName? */
                else if (PFty_subtype (
                            PFty_attr (PFty_qname (PFty_defn (ty)),
                                       PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_QN"))),
                                         mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_FRAG"))),
                                         fetch (var("ws"), var("QN_LOC")))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_loc (
                                                PFty_qname (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name), var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name), var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name), var (ret_iter->name))),
                        assgn (var (tmp->name),
                               mposjoin (mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_QN"))),
                                         mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_FRAG"))),
                                         fetch (var("ws"), var("QN_URI")))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_uri (
                                                PFty_qname (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name), var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name), var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name), var (ret_iter->name))));

                /*
                 * If we couldn't figure out what attribute test we got, give up.
                 *
                 * NOTE: The surface language actually allows such tests. We
                 *       just cannot implement them (yet):
                 *
                 *        doc("foo")/attribute::attribute(shoeSize, xs:integer)
                 */
                else
                    PFoops (OOPS_FATAL,
                            "Problem with an XPath step: cannot evaluate "
                            "node test `%s'", PFty_str (ty));
            }
            else
                PFoops (OOPS_FATAL,
                        "Problem with an XPath step: cannot evaluate "
                        "node test `%s'", PFty_str (ty));

            env_add (p->env, att_iter, aat_nat, ret_iter);
            env_add (p->env, att_item, aat_attr, ret_attr);
            env_add (p->env, att_item, aat_afrag, ret_frag);

            unpin (tmp, 1);
        }
            break;

        /* Rel:      llscj_child (FragList, Rel) */
        case 13:
            llscj (ax_child, p);
            break;

        /* Rel:      llscj_desc (FragList, Rel) */
        case 14:
            llscj (ax_desc, p);
            break;

        /* Rel:      llscj_desc_self (FragList, Rel) */
        case 15:
            llscj (ax_desc_self, p);
            break;

        /* Rel:      llscj_foll (FragList, Rel) */
        case 16:
            llscj (ax_foll, p);
            break;

        /* Rel:      llscj_foll_sibl (FragList, Rel) */
        case 17:
            llscj (ax_foll_sibl, p);
            break;

        /* Rel:      llscj_parent (FragList, Rel) */
        case 18:
            llscj (ax_parent, p);
            break;

        /* Rel:      llscj_prec (FragList, Rel) */
        case 19:
            llscj (ax_prec, p);
            break;

        /* Rel:      llscj_prec_sibl (FragList, Rel) */
        case 20:
            llscj (ax_prec_sibl, p);
            break;

        /* Rel:      nljoin (Rel, Rel) */
        case 21:
            /*
             * We don't really have sensible MIL equivalents for
             * NestedLoop or Merge joins.
             *
             * We just fall through and treat them both equally.
             */

        /* Rel:      merge_join (Rel, Rel) */
        case 22:
        {
            /*
             * We actually cannot guarantee that MonetDB applies a
             * MergeJoin (tactical optimization may choose other
             * implementations). By using leftjoin(), however, we
             * can guarantee the result to be correctly ordered.
             */
            PFalg_simple_type_t lty = type_of (L(p), p->sem.eqjoin.att1);
            PFalg_simple_type_t rty = type_of (R(p), p->sem.eqjoin.att2);
            mvar_t *l = NULL;
            mvar_t *r = NULL;
            mvar_t *tmp1 = new_var (1);
            mvar_t *tmp[2] = { [0] = new_var (1), [1] = new_var (2) };

            assert (lty == rty);

            for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                if (t == lty && t == rty) {
                    l = env_mvar (L(p)->env, p->sem.eqjoin.att1, t);
                    r = env_mvar (R(p)->env, p->sem.eqjoin.att2, t);
                    break;
                }
            }

            if (!l || !r)
                PFoops (OOPS_FATAL, "incompatible types in MergeJoin");

            execute (
                assgn (var (tmp1->name),
                       leftjoin (var (l->name), reverse (var (r->name)))),
                assgn (var (tmp[0]->name),
                       reverse (mark (var (tmp1->name), lit_oid (0)))),
                assgn (var (tmp[1]->name),
                       reverse (
                           mark (reverse (var (tmp1->name)), lit_oid (0)))));

            unpin (tmp1, 1);

            for (unsigned short c = 0; c < 2; c++)
                for (unsigned int i = 0; i < env_count (p->child[c]->env); i++){

                    mvar_t *v = new_var (p->refctr);

                    execute (
                        assgn (var (v->name),
                            leftjoin (
                                var (tmp[c]->name),
                                var (env_at (p->child[c]->env, i).mvar->name)))
                        );

                    env_add (p->env,
                             env_at (p->child[c]->env, i).att,
                             env_at (p->child[c]->env, i).ty,
                             v);
                }

            unpin (tmp[0], 1);
            unpin (tmp[1], 1);

        } break;

        /* Rel:      refine_sort (Rel) */
        case 23:
        {
            mvar_t  *v = new_var (1);
            bool     initialized = false;

            /*
             * Create a MonetDB grp object according to the already
             * existing order.
             */
            for (unsigned int i = 0;
                    i < PFord_count (p->sem.sortby.existing); i++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if (t & type_of (L(p),
                                     PFord_order_at (p->sem.sortby.existing,
                                                     i))) {
                        if (!initialized) {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctgroup (VAR (L(p)->env,
                                             PFord_order_at (p->sem
                                                               .sortby
                                                               .existing, i),
                                             t))));
                            initialized = true;
                        }
                        else {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctderive (
                                        ctmap (var (v->name)),
                                        VAR (L(p)->env,
                                             PFord_order_at (p->sem
                                                               .sortby
                                                               .existing, i),
                                             t))));
                        }
                    }
                }
            }

            /*
             * v now describes the grouping of our input relation.
             * Turn it into a BAT.
             */
            execute (assgn (var (v->name), ctmap (var (v->name))));

            /*
             * Now do the remaining sorting
             */
            for (unsigned int i = PFord_count (p->sem.sortby.existing);
                    i < PFord_count (p->sem.sortby.required); i++) {
                /*
                 * Be careful to implement document order on
                 * nodes correctly:
                 *
                 *  - sort by fragment first, then by pre/attr
                 *    (the aat_pfrag/aat_afrag bit is lower
                 *     than the aat_pre/aat_attr bit)
                 *  - document order of attributes and other nodes
                 *    requires extra effort
                 */
                assert(!(aat_anode & 
                         type_of (L(p),
                                  PFord_order_at (p->sem.sortby.required,
                                                  i)))
                       ||
                       !(aat_pnode &
                         type_of (L(p),
                                  PFord_order_at (p->sem.sortby.required,
                                                  i))));

                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & type_of (L(p),
                                     PFord_order_at (p->sem.sortby.required,
                                                     i))) {
                         execute (
                             assgn (var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (L(p)->env,
                                             PFord_order_at (p->sem
                                                               .sortby
                                                               .required,
                                                             i),
                                             t))));
                    }
            }

            execute (
                assgn (var (v->name),
                       reverse (mark (var (v->name), lit_oid (0)))));

            for (unsigned int i = 0; i < env_count (L(p)->env); i++){

                mvar_t *a = new_var (p->refctr);

                execute (
                    assgn (var (a->name),
                        leftjoin (
                            var (v->name),
                            var (env_at (L(p)->env, i).mvar->name)))
                    );

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         a);
            }

            unpin (v, 1);

        } break;

        /* Rel:      num_add (Rel) */
        case 24:
            bin_arith (PFmil_madd, p);
            break;

        /* Rel:      num_sub (Rel) */
        case 25:
            bin_arith (PFmil_msub, p);
            break;

        /* Rel:      num_mult (Rel) */
        case 26:
            bin_arith (PFmil_mmult, p);
            break;

        /* Rel:      num_div (Rel) */
        case 27:
            bin_arith (PFmil_mdiv, p);
            break;

        /* Rel:      num_mod (Rel) */
        case 28:
            bin_arith (PFmil_mmod, p);
            break;

        /* Rel:      num_add_atom (Rel) */
        case 29:
            bin_arith_atom (PFmil_madd, p);
            break;

        /* Rel:      num_sub_atom (Rel) */
        case 30:
            bin_arith_atom (PFmil_msub, p);
            break;

        /* Rel:      num_mult_atom (Rel) */
        case 31:
            bin_arith_atom (PFmil_mmult, p);
            break;

        /* Rel:      num_div_atom (Rel) */
        case 32:
            bin_arith_atom (PFmil_mdiv, p);
            break;

        /* Rel:      num_mod_atom (Rel) */
        case 33:
            bin_arith_atom (PFmil_mmod, p);
            break;

        /* Rel:      eq (Rel, Rel) */
        case 34:
            bin_comp (PFmil_meq, p);
            break;

        /* Rel:      eq_atom (Rel, Rel) */
        case 35:
            bin_comp_atom (PFmil_meq, p);
            break;

        /* Rel:      gt (Rel, Rel) */
        case 36:
            bin_comp (PFmil_mgt, p);
            break;

        /* Rel:      gt_atom (Rel, Rel) */
        case 37:
            bin_comp_atom (PFmil_mgt, p);
            break;

        /* Rel:      num_neg (Rel) */
        case 38:
            return unary_op (PFmil_mneg, p);
            break;

        /* Rel:      bool_not (Rel) */
        case 39:
            return unary_op (PFmil_mnot, p);
            break;

        /* Rel:      bool_and (Rel, Rel) */
        case 40:
            bin_bool (PFmil_mand, p);
            break;

        /* Rel:      bool_or (Rel, Rel) */
        case 41:
            bin_bool (PFmil_mor, p);
            break;

        /* Rel:      cast (Rel) */
        case 42:
            for (unsigned int i = 0; i < L(p)->schema.count; i++)
                if (L(p)->schema.items[i].name == p->sem.cast.att) {

                    mvar_t        *v = new_var (p->refctr);
                    unsigned int   parts = 0;

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            PFmil_t *casted = NULL;

                            if (t == p->sem.cast.ty)
                                casted = VAR (L(p)->env, p->sem.cast.att, t);
                            else
                                casted
                                    = mcast (
                                        implty (p->sem.cast.ty),
                                        VAR (L(p)->env, p->sem.cast.att, t));

                            if (parts)
                                execute (assgn (var (v->name),
                                                mifthenelse (
                                                    misnil (var (v->name)),
                                                    casted,
                                                    var (v->name))));
                            else
                                execute (assgn (var (v->name), casted));

                            parts++;

                        }

                    env_add (p->env, p->sem.cast.att, p->sem.cast.ty, v);
                }
                else {
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            mvar_t *v = env_mvar (L(p)->env,
                                                  L(p)->schema.items[i].name,
                                                  t);

                            env_add (p->env, L(p)->schema.items[i].name, t, v);
                            pin (v, p->refctr);
                        }
                }
            break;

        /* Rel:      select (Rel) */
        case 43:
        {
            mvar_t *v = new_var (1);

            /*
             * For the predicate column c do
             *
             *  v := c.select (true).mark (0@0).reverse ();
             */
            execute (
                assgn (
                    var (v->name),
                    reverse (
                        mark (
                            select_(VAR (L(p)->env, p->sem.select.att,aat_bln),
                                    lit_bit (true)),
                            lit_oid (0)))));

            /*
             * Then join any BAT in L(p)'s environment with v
             */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {

                mvar_t *w = new_var (p->refctr);

                execute (
                    assgn (var (w->name),
                           leftjoin (var (v->name),
                                     var (env_at (L(p)->env, i).mvar->name))));

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         w);
            }

            /* release v */
            unpin (v, 1);

        } break;

        /* Rel:      difference (Rel, Rel) */
        case 44:
            
            if (env_count (L(p)->env) == 1) {

                mvar_t *v = new_var (p->refctr);

                execute (
                    assgn (
                        var (v->name),
                        reverse (
                            mark (
                                kdiff (
                                    reverse (
                                        var (env_at (L(p)->env, 0).mvar->name)),
                                    reverse (VAR (R(p)->env,
                                                  env_at (L(p)->env, 0).att,
                                                  env_at (L(p)->env, 0).ty))),
                                lit_oid (0)))));

                env_add (p->env,
                         env_at (L(p)->env, 0).att,
                         env_at (L(p)->env, 0).ty,
                         v);
            }
            else
                PFoops (OOPS_FATAL,
                        "don't know how to handle physical Difference operator "
                        "with more than one attribute.");

            break;

        /* Rel:      std_sort (Rel) */
        case 45:
            {
                unsigned int  count = 0;
                mvar_t       *v     = new_var (1);

                for (unsigned int i = 0;
                        i < PFord_count (p->sem.sortby.required); i++) {
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & type_of (L(p),
                                         PFord_order_at (p->sem.sortby.required,
                                                         i))) {
                            if (count) {
                                execute (
                                    assgn (
                                        var (v->name),
                                        ctrefine (
                                            var (v->name),
                                            VAR (L(p)->env,
                                                 PFord_order_at (
                                                     p->sem.sortby.required,
                                                     i),
                                                 t))));
                            }
                            else {
                                execute (
                                    assgn (
                                        var (v->name),
                                        reverse (sort (reverse (
                                            VAR (L(p)->env,
                                                 PFord_order_at (
                                                     p->sem.sortby.required,
                                                     i),
                                                 t))))));
                            }
                            count++;
                        }
                }

                execute (assgn (var (v->name),
                                reverse (mark (var (v->name), lit_oid (0)))));

                for (unsigned int i = 0; i < env_count (L(p)->env); i++) {

                    mvar_t *a = new_var (p->refctr);

                    execute (
                        assgn (var (a->name),
                               leftjoin (
                                   var (v->name),
                                   var (env_at (L(p)->env, i).mvar->name))));

                    env_add (p->env,
                             env_at (L(p)->env, i).att,
                             env_at (L(p)->env, i).ty,
                             a);
                }

                unpin (v, 1);
            }
            break;

        /* Rel:      hash_count (Rel) */
        case 46:
            if (p->sem.count.part != aat_NULL) {
                for (unsigned int i = 0; i < L(p)->schema.count; i++)
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            if (t != L(p)->schema.items[i].type)
                                PFoops (OOPS_FATAL,
                                        "HashCount not implemented for "
                                        "polymorphic groups");

                            mvar_t *v    = new_var (1);
                            mvar_t *res  = new_var (p->refctr);
                            mvar_t *part = new_var (p->refctr);

                            execute (
                                /* v := {count}(p_in.reverse ()) */
                                assgn (
                                    var (v->name),
                                    gcount (
                                        reverse (VAR (L(p)->env,
                                                      p->sem.count.part, t)))),
                                /* res := v.reverse ().mark (0@0).reverse (); */
                                assgn (
                                    var (res->name),
                                    reverse (
                                        mark (
                                            reverse (var (v->name)),
                                            lit_oid (0)))),
                                /* part := v.mark (0@0).reverse (); */
                                assgn (
                                    var (part->name),
                                    reverse (
                                        mark (var (v->name), lit_oid (0)))));

                            env_add (p->env, p->sem.count.res, aat_int, res);
                            env_add (p->env, p->sem.count.part, t, part);

                            unpin (v, 1);
                        }
            }
            else {

                mvar_t *v = new_var (p->refctr);
                execute (
                    assgn (var (v->name),
                           count (var (env_at (L(p)->env, 0).mvar->name))));
                env_add (p->env, p->sem.count.res, aat_int, v);
            }
            break;

        /* Rel:      doc_access (FragList, Rel) */
        case 60:
        {
            mvar_t *str   = new_var (p->refctr);

            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                pin (env_at (R(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (R(p)->env, i).att,
                         env_at (R(p)->env, i).ty,
                         env_at (R(p)->env, i).mvar);
            }

            switch (p->sem.doc_access.doc_col)
            {
                case (doc_atext):
                    {
                        PFmil_t *attr  = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_attr);
                        PFmil_t *afrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_afrag);

                        execute (
                            assgn (var (str->name),
                                   mposjoin (mposjoin (attr,
                                                       afrag,
                                                       fetch (var("ws"),
                                                              var("ATTR_PROP"))),
                                             mposjoin (attr,
                                                       afrag,
                                                       fetch (var("ws"),
                                                              var("ATTR_FRAG"))),
                                             fetch (var("ws"), var("PROP_VAL")))));
                    }
                    break;
                case (doc_text):
                    {
                        PFmil_t *pre  = VAR (R(p)->env,
                                             p->sem.doc_access.att,
                                             aat_pre);
                        PFmil_t *pfrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_pfrag);
                        execute (
                            assgn (var (str->name),
                                   mposjoin (mposjoin (pre,
                                                       pfrag,
                                                       fetch (var("ws"),
                                                              var("PRE_PROP"))),
                                             mposjoin (pre,
                                                       pfrag,
                                                       fetch (var("ws"),
                                                              var("PRE_FRAG"))),
                                             fetch (var("ws"), var("PROP_TEXT")))));
                    }
                    break;
                default:
                    PFoops (OOPS_FATAL, 
                            "unexpected document column in doc_access (%i)",
                            p->sem.doc_access.doc_col);
            }

            env_add (p->env, att_res, aat_str, str);
        }
            break;

        /* Rel:      string_join (Rel, Rel) */
        case 61:
        {
            mvar_t *str  = new_var (p->refctr);
            mvar_t *iter = new_var (p->refctr);
            mvar_t *item = new_var (p->refctr);

            execute (
                assgn (var (str->name),
                       string_join (
                           leftjoin (
                               reverse (VAR(L(p)->env, att_iter, aat_nat)),
                               VAR(L(p)->env, att_item, aat_str)),
                           leftjoin (
                               reverse (VAR(R(p)->env, att_iter, aat_nat)),
                               VAR(R(p)->env, att_item, aat_str)))),
                assgn (var (iter->name), 
                       reverse (mark (var (str->name), lit_oid (0)))),
                assgn (var (item->name), 
                       reverse (
                           mark (reverse (var (str->name)), lit_oid (0)))));

            env_add (p->env, att_iter, aat_nat, iter);
            env_add (p->env, att_item, aat_str, item);
        }
            break;

        /* FragRel:  doc_tbl (Rel) */
        case 100:
        {
            /* temporary variable */
            mvar_t *v = new_var (1);
            /* result BATs */
            mvar_t *pre  = new_var (p->refctr);
            mvar_t *frag = new_var (p->refctr);
            mvar_t *iter = env_mvar (L(p)->env, att_iter, aat_nat);

            env_add (p->env, att_item, aat_pre, pre);
            env_add (p->env, att_item, aat_pfrag, frag);

            execute (
                assgn (var (v->name),
                       doc_tbl (var ("ws"),
                                VAR (L(p)->env, att_item, aat_str))),
                assgn (var ("ws"), fetch (var (v->name), lit_int (0))),
                assgn (var (pre->name), fetch (var (v->name), lit_int (1))),
                assgn (var (frag->name), fetch (var (v->name), lit_int (2)))
                );

            /* copy the iter BAT */
            env_add (p->env, att_iter, aat_nat, iter);
            pin (iter, p->refctr);

            /* release our temporary variable v */
            unpin (v, 1);
        } break;


        /* FragList: empty_frag */
        case 200:
            break;

        /* FragList: frag_union (FragList, Frag) */
        case 201:
            break;

        /* Frag:     fragment (FragRel) */
        case 205:
            break;

        default:
            PFoops (OOPS_FATAL, "unknown rule %u", rule);
            break;
    }

    for (unsigned int c = 0; c < PFPA_OP_MAXCHILD && p->child[c]; c++)
        for (unsigned int i = 0; i < PFarray_last (p->child[c]->env); i++)
            unpin (((env_t *) PFarray_at (p->child[c]->env, i))->mvar,
                   p->refctr);

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_print (env_at (p->env, i).att))));

#endif

}

static PFalg_simple_type_t
type_of (PFpa_op_t *n, PFalg_att_t att)
{
    assert (n);

    for (unsigned int i = 0; i < n->schema.count; i++)
        if (n->schema.items[i].name == att)
            return n->schema.items[i].type;

    PFoops (OOPS_FATAL,
            "cannot determine implementation type of algebra expression");

    assert (0); /* never reached due to "exit" in "PFoops" */
    return aat_nat; /* pacify picky compilers */
}


/**
 * Compile a physical algebra literal value into its MIL equivalent.
 */
static PFmil_t *
literal (PFalg_atom_t atom)
{
    switch (atom.type) {

        case aat_nat:  return lit_oid (atom.val.nat);
        case aat_int:  return lit_int (atom.val.int_);
        case aat_str:  return lit_str (atom.val.str);
        case aat_dec:  return lit_dbl (atom.val.dec);
        case aat_dbl:  return lit_dbl (atom.val.dbl);
        case aat_bln:  return lit_bit (atom.val.bln);

        default:
                       PFoops (OOPS_FATAL,
                               "A relational algebra type has not yet "
                               "been implemented.");
                       break;
    }

    assert (0); /* never reached due to "exit" in "PFoops" */
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `node()' */
static PFmil_t *
llscj_node (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_node()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `element()' */
static PFmil_t *
llscj_elem (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_elem (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_elem (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_elem (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_elem (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_elem (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_elem (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_elem (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_elem()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `text()' */
static PFmil_t *
llscj_text (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_text (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_text (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_text (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_text (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_text (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_text (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_text (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_text (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_text (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_text (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_text()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `comment()' */
static PFmil_t *
llscj_comm (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_comm (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_comm (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_comm (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_comm (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_comm (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_comm (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_comm (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_comm (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_comm (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_comm (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_comm()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `processing-instr()' */
static PFmil_t *
llscj_pi (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_pi (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_pi (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_pi (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_pi (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_pi (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_pi (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_pi (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_pi (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_pi (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_pi (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_pi()");
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test for some local name, but a wildcard namespace
 */
static PFmil_t *
llscj_elem_loc (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                const PFmil_t *loc)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_anc_self:
            return llscj_anc_self_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_child:
            return llscj_child_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_desc:
            return llscj_desc_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_desc_self:
            return llscj_desc_self_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_foll:
            return llscj_foll_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_parent:
            return llscj_parent_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_prec:
            return llscj_prec_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_loc (iter, item, frag, ws, ord, loc);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test for some namespace, but a wildcard local name
 */
static PFmil_t *
llscj_elem_ns (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
               const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
               const PFmil_t *ns)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_anc_self:
            return llscj_anc_self_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_child:
            return llscj_child_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_desc:
            return llscj_desc_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_desc_self:
            return llscj_desc_self_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_foll:
            return llscj_foll_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_parent:
            return llscj_parent_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_prec:
            return llscj_prec_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_ns (iter, item, frag, ws, ord, ns);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test with a fully qualified QName
 */
static PFmil_t *
llscj_elem_nsloc (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                  const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                  const PFmil_t *ns, const PFmil_t *loc)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_anc_self:
            return llscj_anc_self_elem_nsloc (iter, item, frag, ws, ord, ns,
                                              loc);
        case ax_child:
            return llscj_child_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_desc:
            return llscj_desc_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_desc_self:
            return llscj_desc_self_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
        case ax_foll:
            return llscj_foll_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
        case ax_parent:
            return llscj_parent_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_prec:
            return llscj_prec_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is a
 * processing-instruction test with a given target
 */
static PFmil_t *
llscj_pi_targ (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                  const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                  const PFmil_t *target)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_pi_targ (iter, item, frag, ws, ord, target);
        case ax_anc_self:
            return llscj_anc_self_pi_targ (iter, item, frag, ws, ord, target);
        case ax_child:
            return llscj_child_pi_targ (iter, item, frag, ws, ord, target);
        case ax_desc:
            return llscj_desc_pi_targ (iter, item, frag, ws, ord, target);
        case ax_desc_self:
            return llscj_desc_self_pi_targ (iter, item, frag, ws, ord, target);
        case ax_foll:
            return llscj_foll_pi_targ (iter, item, frag, ws, ord, target);
        case ax_foll_sibl:
            return llscj_foll_sibl_pi_targ (iter, item, frag, ws, ord, target);
        case ax_parent:
            return llscj_parent_pi_targ (iter, item, frag, ws, ord, target);
        case ax_prec:
            return llscj_prec_pi_targ (iter, item, frag, ws, ord, target);
        case ax_prec_sibl:
            return llscj_prec_sibl_pi_targ (iter, item, frag, ws, ord, target);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * Translate loop-lifted staircase joins.
 */
static void
llscj (enum axis_t axis, const PFpa_op_t *p)
{
    /* abbreviations for input expressions */
    PFty_t           ty  = p->sem.scjoin.ty;
    PFord_ordering_t in  = p->sem.scjoin.in;
    PFord_ordering_t out = p->sem.scjoin.out;

    /* MIL equivalents of input expression */
    PFmil_t *iter;
    PFmil_t *item;
    PFmil_t *frag;

    int      o;           /* helper to compute order specifier */
    PFmil_t *order;       /* order specifier for llscj MIL functions */
    PFmil_t *scj = NULL;  /* MIL expression that evaluates llscj */

    mvar_t  *tmp;         /* helper variable */
    mvar_t  *ret_iter;    /* variable to which we assign the `iter' result */
    mvar_t  *ret_pre;     /* variable to which we assign the `pre' result */
    mvar_t  *ret_frag;    /* variable to which we assign the `kind' result */
    
    /*
     * Determine generic input arguments.
     */
    assert (p); assert (R(p)); assert (R(p)->env);
    iter = VAR (R(p)->env, att_iter, aat_nat); assert (iter);
    item = VAR (R(p)->env, att_item, aat_pre); assert (item);
    frag = VAR (R(p)->env, att_item, aat_pfrag); assert (frag);

    /*
     * Determine in- and output orderings.
     * MIL functions expect this information encoded in an integer
     * value that we build up here.
     */
    if (PFord_implies (in, PFord_refine (PFord_refine (PFordering (), att_iter),
                                         att_item)))
        o = 0;
    else if (PFord_implies (in, PFord_refine (PFord_refine (PFordering (),
                                                            att_item),
                                              att_iter)))
        o = 1;
    else
        PFoops (OOPS_FATAL, "illegal argument for input ordering");

    if (PFord_implies (out, PFord_refine (PFord_refine (PFordering (), att_iter),
                                          att_item)))
        o |= 0;
    else if (PFord_implies (out, PFord_refine (PFord_refine (PFordering (),
                                                             att_item),
                                               att_iter)))
        o |= 2;
    else
        PFoops (OOPS_FATAL, "illegal argument for output ordering");

    order = lit_int (o);

    if (PFty_subtype (ty, PFty_xs_anyElement ())) {

        /* This is a test for element nodes */

        /* Is it just a generic element kind test? (e.g. .../element()) */
        if (PFty_subtype (PFty_xs_anyElement (), ty))

            scj = llscj_elem (axis, iter, item, frag, var ("ws"), order);

        /* Is it a test on element kind and local name only? */
        else if (PFty_subtype (
                    PFty_elem (PFqname (PFns_wild,
                                        PFty_qname (PFty_defn (ty)).loc),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_loc (axis, iter, item, frag, var ("ws"), order,
                                  lit_str (PFqname_loc (
                                               PFty_qname (PFty_defn (ty)))));

        /* Or maybe a test on element kind and namespace only? */
        else if (PFty_subtype (
                    PFty_elem (PFqname (PFty_qname (PFty_defn (ty)).ns,
                                        NULL),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_ns (axis, iter, item, frag, var ("ws"), order,
                                 lit_str (PFqname_uri (
                                              PFty_qname (PFty_defn (ty)))));

        /* A test on element kind and full QName? */
        else if (PFty_subtype (
                    PFty_elem (PFty_qname (PFty_defn (ty)),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_nsloc (
                    axis, iter, item, frag, var ("ws"), order,
                    lit_str (PFqname_uri (PFty_qname (PFty_defn (ty)))),
                    lit_str (PFqname_loc (PFty_qname (PFty_defn (ty)))));
        /*
         * If we couldn't figure out what element test we got, give up.
         *
         * NOTE: The surface language actually allows such tests. We
         *       just cannot implement them (yet):
         *
         *        doc("foo")/child::element(shoeSize, xs:integer)
         */
        else
            PFoops (OOPS_FATAL,
                    "Problem with an XPath step: cannot evaluate "
                    "node test `%s'", PFty_str (ty));
    }
    /* If the node test wasn't some element test, maybe it is a text() test? */
    else if (PFty_subtype (ty, PFty_text ())) {
        scj = llscj_text (axis, iter, item, frag, var ("ws"), order);
    }
    /* or a comment() test? */
    else if (PFty_subtype (ty, PFty_comm ())) {
        scj = llscj_comm (axis, iter, item, frag, var ("ws"), order);
    }
    /* some test for processing-instructions? */
    else if (PFty_subtype (ty, PFty_pi (NULL))) {
        /* maybe we look for _any_ pi, regardless of its target? */
        if (PFty_subtype (PFty_pi (NULL), ty))
            scj = llscj_pi (axis, iter, item, frag, var ("ws"), order);
        /* or was there a target specified? */
        else
            scj = llscj_pi_targ (
                    axis, iter, item, frag, var ("ws"), order,
                    lit_str (PFqname_loc (PFty_qname (PFty_defn (ty)))));
    }
    /* If all these cases did not apply, it is probably a node() test. */
    else if (PFty_subtype (PFty_xs_anyNode (), ty)) {
        scj = llscj_node (axis, iter, item, frag, var ("ws"), order);
    }
    /* If we still couldn't find out, we probably need to give up. */
    else
        PFoops (OOPS_FATAL,
                "Problem with an XPath step: cannot evaluate "
                "node test `%s'", PFty_str (ty));

    assert (scj);

    /*
     * tmp  := scj (...);            # constructed just before
     * iter := tmp.fetch (0);
     * pre  := tmp.fetch (1);
     * kind := tmp.fetch (2);
     */
    tmp      = new_var (1);
    ret_iter = new_var (p->refctr);
    ret_pre  = new_var (p->refctr);
    ret_frag = new_var (p->refctr);

    execute (
        assgn (var (tmp->name), scj),
        assgn (var (ret_iter->name), fetch (var (tmp->name), lit_int (0))),
        assgn (var (ret_pre->name), fetch (var (tmp->name), lit_int (1))),
        assgn (var (ret_frag->name), fetch (var (tmp->name), lit_int (2))));

    /*
     * FIXME: fake_project is completely undocumented!
     *
     * Should we actually do fake_projecting at runtime? In most cases
     * we should be able to see at compile time if columns are guaranteed
     * to be constant. We could then avoid carrying around the column at
     * all.
     *
     * Problem is: We do consider a `constant' property in our algebra
     * (not fully, yet, but the ideas are there). This property, however
     * only looks at ``real'' algebra columns. Here, fake_project operates
     * on only part of a ``real'' column. The ``real'' column `item' is
     * implemented as `pre|kind' for nodes. And while kind may be constant,
     * pre probably won't.
     */
    execute (
        if_ (
            is_fake_project (var (ret_frag->name)),
            assgn (var (ret_frag->name),
                   project (var (ret_iter->name),
                            fetch (var (ret_frag->name), lit_int (0)))),
            nop ()));

    env_add (p->env, att_iter, aat_nat, ret_iter);
    env_add (p->env, att_item, aat_pre, ret_pre);
    env_add (p->env, att_item, aat_pfrag, ret_frag);

    unpin (tmp, 1);

}

/**
 * Generic handling of binary operators, where both operands
 * are a BAT (in contrast to when one operand is known to be constant
 * and thus needs not be materialized as a BAT).
 *
 * @param op A MIL multiplex operation that implements the binary
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
bin_op (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
        PFpa_op_t *p, PFalg_simple_type_t arg_ty, PFalg_simple_type_t ret_ty)
{
    mvar_t              *res = new_var (p->refctr);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.binary.att1, arg_ty),
                   VAR (L(p)->env, p->sem.binary.att2, arg_ty))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.binary.res, ret_ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

/**
 * Generic binary arithmetic operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_arith (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));
    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl);

    return bin_op (op, p, ty, ty);
}

/**
 * Generic binary comparison operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));
    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl || ty == aat_str);

    return bin_op (op, p, ty, aat_bln);
}

/**
 * Generic binary Boolean operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_bool (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));
    assert (ty == aat_bln);

    return bin_op (op, p, ty, aat_bln);
}

/**
 * Generic handling of arithmetic operators, where one operand is
 * known to be constant. (We don't need to materialize that attribute
 * as a BAT, but pass it as a const argument to MonetDB's [+].
 *
 * @param op A MIL multiplex operation that implements the arithmetic
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
bin_op_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
             PFpa_op_t *p,
             PFalg_simple_type_t arg_ty, PFalg_simple_type_t ret_ty)
{
    mvar_t              *res = new_var (p->refctr);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.bin_atom.att1, arg_ty),
                   literal (p->sem.bin_atom.att2))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.bin_atom.res, ret_ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

static void
bin_arith_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl);
    assert (ty == p->sem.bin_atom.att2.type);

    return bin_op_atom (op, p, ty, ty);
}

static void
bin_comp_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl || ty == aat_str);
    assert (ty == p->sem.bin_atom.att2.type);

    return bin_op_atom (op, p, ty, aat_bln);
}

/**
 * Generic handling of unary operators (numeric and Boolean negation).
 *
 * @param op A MIL multiplex operation that implements the operation
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
unary_op (PFmil_t * (*op) (const PFmil_t *), PFpa_op_t *p)
{
    mvar_t              *res = new_var (p->refctr);
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.unary.att);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.unary.att, ty))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.unary.res, ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

static void
clear_ctr (PFpa_op_t *n)
{
    assert (n);

    n->refctr = n->usectr = 0;

    for (unsigned int i = 0; i < PFPA_OP_MAXCHILD && n->child[i]; i++)
        clear_ctr (n->child[i]);
}

static void
inc_refctr (PFpa_op_t *n)
{
    assert (n);

    n->refctr++;

    for (unsigned int i = 0; i < PFPA_OP_MAXCHILD && n->child[i]; i++)
        inc_refctr (n->child[i]);
}


/**
 * Translate MIL algebra tree in a MIL program.
 */
PFmil_t *
PFmilgen (PFpa_op_t *n)
{
    assert (n);

    /* set counters in algebra tree nodes */
    clear_ctr (n);
    inc_refctr (n);

    /* initialize list of variables we use */
    mvars = PFarray (sizeof (mvar_t));

    /* enrich algebra tree with state labels for subsequent reduce() call */
    PFmilgen_label (n);

    /* we start with an empty MIL program */
    milprog = declare (unused ());

    execute (declare (var ("ws")));

    /* start compilation */
    reduce (n, 1);

    /* prepend variable declarations before the actual program */
    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        milprog = seq (declare (var (((mvar_t *) PFarray_at (mvars, i))->name)),
                       milprog);

    return milprog;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
