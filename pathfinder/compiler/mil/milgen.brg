/* -*- c-basic-offset:4; c-indentation-style:"k&r"; indent-tabs-mode:nil -*- */
%{

/*
 * Compile physical algebra tree into a MIL program.
 *
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2006 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 *
 * $Id$
 */


#include "pathfinder.h"

#include <assert.h>

#include "oops.h"
#include "mem.h"
#include "physical.h"
#include "alg_dag.h"
#include "properties.h"
#include "mil.h"

#include "subtyping.h"

#include <stdio.h>

/*
 * Accessors for the burg matcher
 */
typedef struct PFpa_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/physical.h!
 */
%term serialize      =   1
%term lit_tbl        =   2
%term empty_tbl      =   3
%term attach         =   4
%term cross          =  10
%term leftjoin       =  11
%term eqjoin         =  14
%term project        =  15
%term select         =  16
%term append_union   =  20
%term merge_union    =  21
%term intersect      =  22
%term difference     =  23
%term sort_distinct  =  24
%term std_sort       =  25
%term refine_sort    =  26
%term num_add        =  30
%term num_add_atom   =  31
%term num_sub        =  32
%term num_sub_atom   =  33
%term num_mult       =  34
%term num_mult_atom  =  35
%term num_div        =  36
%term num_div_atom   =  37
%term num_mod        =  38
%term num_mod_atom   =  39
%term eq             =  40
%term eq_atom        =  41
%term gt             =  42
%term gt_atom        =  43
%term num_neg        =  44
%term bool_not       =  45
%term bool_and       =  46
%term bool_or        =  47
%term bool_and_atom  =  48
%term bool_or_atom   =  49
%term hash_count     =  55
%term avg            =  56
%term max_           =  57
%term min_           =  58
%term sum            =  59
%term merge_rownum   =  60
%term hash_rownum    =  61
%term number         =  62
%term type           =  63
%term type_assert    =  64
%term cast           =  65
%term llscj_anc      = 100
%term llscj_anc_self = 101
%term llscj_attr     = 102
%term llscj_child    = 103
%term llscj_desc     = 104
%term llscj_desc_self= 105
%term llscj_foll     = 106
%term llscj_foll_sibl= 107
%term llscj_parent   = 108
%term llscj_prec     = 109
%term llscj_prec_sibl= 110
%term doc_tbl        = 120
%term doc_access     = 121
%term element        = 122
%term element_tag    = 123
%term attribute      = 124
%term textnode       = 125
%term docnode        = 126
%term comment        = 127
%term processi       = 128
%term merge_adjacent = 129
%term roots          = 130
%term fragment       = 131
%term frag_union     = 132
%term empty_frag     = 133
%term cond_err       = 140
%term rec_fix        = 141
%term rec_param      = 142
%term rec_nil        = 143
%term rec_arg        = 144
%term rec_base       = 145
%term rec_border     = 146
%term concat         = 150
%term contains       = 151
%term string_join    = 152

%%

Query:    serialize (FragList, Rel)                                =   1 (10);
Query:    serialize (FragList, empty_tbl)                          =   2 (10);

Rel:      lit_tbl                                                  =  10 (10);
Rel:      empty_tbl                                                =  11 (10);
Rel:      attach (Rel)                                             =  12 (10);
Rel:      cross (Rel, Rel)                                         =  13 (10);
Rel:      leftjoin (Rel, Rel)                                      =  14 (10);
Rel:      eqjoin (Rel, Rel)                                        =  15 (10);
Rel:      project (Rel)                                            =  20 (10);
Rel:      select (Rel)                                             =  21 (10);
Rel:      append_union (Rel, Rel)                                  =  22 (10);
Rel:      append_union (hash_count (Rel),
                        attach (difference 
                                    (Rel, 
                                     project (hash_count (Rel))))) =  23 (40);
Rel:      merge_union (Rel, Rel)                                   =  24 (10);
Rel:      intersect (Rel, Rel)                                     =  25 (10);
Rel:      difference (Rel, Rel)                                    =  26 (10);
Rel:      sort_distinct (Rel)                                      =  30 (10);
Rel:      sort_distinct (std_sort (Rel))                           =  31 (10);
Rel:      sort_distinct (refine_sort (Rel))                        =  32 (10);
Rel:      std_sort (Rel)                                           =  33 (10);
Rel:      refine_sort (Rel)                                        =  34 (10);
Rel:      num_add (Rel)                                            =  40 (10);
Rel:      num_sub (Rel)                                            =  41 (10);
Rel:      num_mult (Rel)                                           =  42 (10);
Rel:      num_div (Rel)                                            =  43 (10);
Rel:      num_mod (Rel)                                            =  44 (10);
Rel:      num_add_atom (Rel)                                       =  45 (10);
Rel:      num_sub_atom (Rel)                                       =  46 (10);
Rel:      num_mult_atom (Rel)                                      =  47 (10);
Rel:      num_div_atom (Rel)                                       =  48 (10);
Rel:      num_mod_atom (Rel)                                       =  49 (10);
Rel:      eq (Rel)                                                 =  50 (10);
Rel:      eq_atom (Rel)                                            =  51 (10);
Rel:      gt (Rel)                                                 =  52 (10);
Rel:      gt_atom (Rel)                                            =  53 (10);
Rel:      num_neg (Rel)                                            =  60 (10);
Rel:      bool_not (Rel)                                           =  61 (10);
Rel:      bool_and (Rel)                                           =  62 (10);
Rel:      bool_or (Rel)                                            =  63 (10);
Rel:      bool_and_atom (Rel)                                      =  64 (10);
Rel:      bool_or_atom (Rel)                                       =  65 (10);
Rel:      hash_count (Rel)                                         =  66 (10);
Rel:      avg (Rel)                                                =  67 (10);
Rel:      max_ (Rel)                                               =  68 (10);
Rel:      min_ (Rel)                                               =  69 (10);
Rel:      sum (Rel)                                                =  70 (10);
Rel:      merge_rownum (Rel)                                       =  71 (10);
Rel:      hash_rownum (Rel)                                        =  72 (10);
Rel:      number (Rel)                                             =  73 (10);
Rel:      type (Rel)                                               =  74 (10);
Rel:      type_assert (Rel)                                        =  75 (10);
Rel:      cast (Rel)                                               =  76 (10);

Rel:      llscj_anc (FragList, Rel)                                =  80 (10);
Rel:      llscj_anc_self (FragList, Rel)                           =  81 (10);
Rel:      llscj_attr (FragList, Rel)                               =  82 (10);
Rel:      llscj_child (FragList, Rel)                              =  83 (10);
Rel:      llscj_desc (FragList, Rel)                               =  84 (10);
Rel:      llscj_desc_self (FragList, Rel)                          =  85 (10);
Rel:      llscj_foll (FragList, Rel)                               =  86 (10);
Rel:      llscj_foll_sibl (FragList, Rel)                          =  87 (10);
Rel:      llscj_parent (FragList, Rel)                             =  88 (10);
Rel:      llscj_prec (FragList, Rel)                               =  89 (10);
Rel:      llscj_prec_sibl (FragList, Rel)                          =  90 (10);

FragRel:  doc_tbl (Rel)                                            = 100 (10);
Rel:      doc_access (FragList, Rel)                               = 101 (10);
FragRel:  element (FragList, element_tag (Rel, empty_tbl))         = 102 (10);
FragRel:  element (FragList, 
                   element_tag (Rel, rec_border (empty_tbl)))      = 103 (10);
FragRel:  element (FragList, element_tag (Rel, Rel))               = 104 (10);
FragRel:  attribute (Rel)                                          = 105 (10);
FragRel:  textnode (Rel)                                           = 106 (10);
FragRel:  docnode (FragList, Rel)                                  = 107 (10);
FragRel:  comment (Rel)                                            = 108 (10);
FragRel:  processi (Rel)                                           = 109 (10);
FragRel:  merge_adjacent (FragList, Rel)                           = 110 (10);

Rel:      roots (FragRel)                                          = 120 (10);
Frag:     fragment (FragRel)                                       = 121 (10);
FragList: frag_union (FragList, Frag)                              = 122 (10);
FragList: empty_frag                                               = 123 (10);

Rel:      cond_err (Rel, Rel)                                      = 130 (10);

Rel:      rec_fix (Rec, Rel)                                       = 131 (10);
Rec:      rec_param (rec_arg (Rel, Rel), Rec)                      = 132 (10);
Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec)                = 133 (10);
Rec:      rec_nil                                                  = 134 (10);
Rel:      rec_base                                                 = 135 (10);
Rel:      rec_border (Rel)                                         = 136 (10);

Rel:      concat (Rel)                                             = 140 (10);
Rel:      contains (Rel)                                           = 141 (10);
Rel:      string_join (Rel, Rel)                                   = 142 (10);

%%

#include "mil_mnemonic.h"

/**
 * We collect the MIL program during compilation here.
 */
static PFmil_t *milprog = NULL;

/**
 * Processing is done bottom-up. This is just the order in
 * which we want to print our code. So we keep the whole
 * MIL program in the variable #milprog, and append commands
 * as we go. Think of it as ``executing'' the commands
 * right away.
 */
#define execute(...) milprog = seq (milprog, __VA_ARGS__)

/**
 * Represents a MIL variable.
 *
 * The variable has a name (that is automatically generated).
 * The @a pins field keeps track of the number of references
 * to this variable.  A variable may not be destroyed before
 * @a pins drops to zero.
 */
struct mvar_t {
    PFmil_ident_t   name;
    unsigned int    pins;
};

/** short-hand for struct mvar_t */
typedef struct mvar_t mvar_t;

/**
 * Remember @em all variables that we deal with during the compiler
 * run in here.  We want to re-use variables as much as possible to
 * reduce the number of active variables in the MIL program.  This
 * should help MonetDB with its memory management.
 *
 * Each time we need a new variable, we try to re-use an old one
 * from here.  We thus search for a variable with pin count zero.
 * If we cannot find any, we create a new variable and append it to
 * the list.
 */
PFarray_t *mvars = NULL;

/**
 * Return a ``new'' valid variable.  Will try to re-use an old,
 * no longer needed, variable, if possible.  For this, the
 * function searches #mvars for a variable with @a pins = 0. If
 * no such variable can be found, a new one will be created and
 * appended to the list.  
 *
 * The new variable will be initialized with the pin count given
 * in @a pins.
 */
static mvar_t *
new_var (unsigned int pins)
{
    static unsigned int   varno = PF_MIL_RES_VAR_COUNT;
    mvar_t               *var   = NULL;

    assert (mvars);
    assert (varno < 10000);

    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        if ((var = (mvar_t *) PFarray_at (mvars, i))->pins == 0) {
            var->pins = pins;
            return var;
        }

    /* If we were not successful, create a new entry */
    var = (mvar_t *) PFarray_add (mvars);

    var->name = varno++;
    var->pins = pins;

    return var;
}

/**
 * Pin a variable (i.e., increment its pin count by @a count).
 */
static void
pin (mvar_t *v, unsigned int count)
{
    v->pins += count;
}

/**
 * Unpin a variable (i.e., decrement its pin count by @a count).
 * If the pin count reaches zero, automatically generates a MIL
 * statement that assigns @c unused to the variable, marking it
 * a candidate for MonetDB's garbage collection.
 */
static void
unpin (mvar_t *v, unsigned int count)
{
    if (v->pins < count) {
        PFinfo (OOPS_WARNING, "pin count below zero");
        v->pins = 0;
    } else
        v->pins -= count;
    if (!v->pins)
        execute (assgn (var (v->name), unused ()));
}


/**
 * Environment entry.  In each physical algebra tree node, we keep
 * an environment that maps an attribute/type combination to the
 * #mvar_t struct that holds the corresponding MIL variable.
 */
struct env_t {
    PFalg_att_t          att;
    PFalg_simple_type_t  ty;
    mvar_t              *mvar;
};
typedef struct env_t env_t;

/**
 * Create a new (empty) environment for #env_t entries.
 *
 * With each node in the physical algebra DAG, we keep such an
 * environment that maps an attribute/type combination onto the
 * #mvar_t item that implements it. (Think of this as the mapping
 * from attribute/type to the BAT that represents that combination.
 */
static PFarray_t *
new_env (void)
{
    return PFarray (sizeof (env_t));
}

/**
 * Add an item to environment.
 */
void
env_add (PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty, mvar_t *v)
{
    assert (ty == aat_nat || ty == aat_int || ty == aat_str || ty == aat_dec
            || ty == aat_dbl || ty == aat_bln || ty == aat_qname 
            || ty == aat_uA || ty == aat_pre || ty == aat_attr
            || ty == aat_pfrag || ty == aat_afrag);

    *(env_t *) PFarray_add (env)
        = (env_t) { .att = att, .ty = ty, .mvar = v };
#ifndef NDEBUG
    execute ( comment ("    %s: %s(%s)", 
                       PFmil_var_str (v->name), 
                       PFatt_str (att), 
                       PFsimple_type_str (ty)));
#endif
}

/**
 * Return environment size.
 */
unsigned int
env_count (const PFarray_t *env)
{
    return PFarray_last (env);
}

/**
 * Return environment item at index @a i.
 */
env_t
env_at (const PFarray_t *env, unsigned int i)
{
    assert (i < PFarray_last (env));

    return *(env_t *) PFarray_at ((PFarray_t *) env, i);
}

/**
 * Worker for env_mvar ().  Yields NULL if the MIL variable could not be
 * found in the enviroment @a env (in specific cases, this is not an error).
 */ 
static mvar_t *
env_mvar_unsafe (const PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    for (unsigned int i = 0; i < PFarray_last (env); i++) {

        env_t entry = *(env_t *) PFarray_at ((PFarray_t *) env, i);

        if (entry.att == att && entry.ty == ty)
            return entry.mvar;
    }
    return NULL;
}

/**
 * Look up an entry in the environment @a env, given a combination
 * of attribute (@a att) and type (@a ty) as the search key.
 */
mvar_t *
env_mvar (const PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    mvar_t *mvar = env_mvar_unsafe (env, att, ty);
    if (mvar)
        return mvar;

#ifndef NDEBUG
    fprintf (stderr, "looking for att: %s, ty: 0x%X\n", PFatt_str (att), ty);
    fprintf (stderr, "environment looks like:\n");
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        env_t entry = *(env_t *) PFarray_at ((PFarray_t *) env, i);

        fprintf (stderr, "  att: %s, type: 0x%X, mvar->name: %s\n",
                 PFatt_str (entry.att), entry.ty, 
                 PFmil_var_str (entry.mvar->name));
    }
#endif

    PFoops (OOPS_FATAL,
            "attribute '%s' with type '0x%X' not found in environment",
            PFatt_str (att), ty);
    /* we don't ever get here */
    return NULL;
}

PFmil_t *
VAR (PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    return var (env_mvar (env, att, ty)->name);
}

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RLL(p) L(L(R(p)))
#define RLR(p) R(L(R(p)))
#define RLRL(p) L(R(L(R(p))))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))

#define MAX_KIDS 10

#define SEEN(p) ((p)->bit_dag)

enum axis_t {
      ax_anc
    , ax_anc_self
    , ax_child
    , ax_desc
    , ax_desc_self
    , ax_foll
    , ax_foll_sibl
    , ax_parent
    , ax_prec
    , ax_prec_sibl
};

static PFalg_simple_type_t type_of (PFpa_op_t *n, PFalg_att_t att);
static PFmil_t * literal (PFalg_atom_t atom);

/* helper to handle loop-lifted staircase join operator */
static void llscj (enum axis_t axis, const PFpa_op_t *p);
/* translate arithmetic operators where both arguments are a BAT */
static void bin_arith (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                       PFpa_op_t *p);
/* translate arithmetic operators where one argument is an atom */
static void bin_arith_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                            PFpa_op_t *p);
/* translate binary coparison operator (eq/gt) */
static void bin_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                      PFpa_op_t *p);
static void bin_comp_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                           PFpa_op_t *p);
/* translate binary Boolean operator (and/or) */
static void bin_bool (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                      PFpa_op_t *p);
static void bin_bool_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                           PFpa_op_t *p);
/* translate unary operators (numeric negation, Boolean not) */
static void unary_op (PFmil_t * (*op) (const PFmil_t *), PFpa_op_t *p);

/* Generic handling of aggregation functions (avg, max, min and sum). */
static void aggr_function (PFmil_t * (*op) (const PFmil_t *),
                           PFmil_t * (*gop) (const PFmil_t *),
                           PFpa_op_t *p);

/** MIL implementation types for algebra types */
static PFmil_type_t impl_types[] = {
      [aat_nat]   = m_oid
    , [aat_int]   = m_lng
    , [aat_str]   = m_str
    , [aat_uA]    = m_str
    , [aat_dec]   = m_dbl
    , [aat_dbl]   = m_dbl
    , [aat_bln]   = m_bit
    , [aat_qname] = m_oid
    , [aat_pre]   = m_oid
    , [aat_attr]  = m_oid
    , [aat_pfrag] = m_oid
    , [aat_afrag] = m_oid
};

/** implementation type for a given algebra type, as a MIL node */
#ifndef NDEBUG
#define implty(n) type (impl_types[n] \
                        ? impl_types[n] \
                        : (PFoops (OOPS_FATAL, "illegal type in implty()"), (PFmil_type_t)0))
#else
#define implty(n) type (impl_types[n])
#endif

/* forward declaration */
static void reduce (PFpa_op_t * p, int goalnt);

/**
 * Alternative reducer function. Introduces code that is invariant
 * to the recursion before the recursion body is translated.
 */
static void
reduce_border (PFpa_op_t * p, int goalnt, PFarray_t *border_vars)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */

    assert (p);

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);
    
    switch (rule) {
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 132:
            /* only follow the seeds */
            reduce (kids[0], nts[0]);
            /* and the rest of the parameter list */
            reduce_border (kids[2], nts[2], border_vars);
            break;

        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 133:
            /* follow the rest of the parameter list */
            reduce_border (kids[1], nts[1], border_vars);
            break;

        /* Rec:      rec_nil */
        case 134:
            /* nothing to be done */
            break;
            
        /* Rel:      rec_border (Rel) */
        case 136:
            if (!p->env) {
                /* translate sub-DAG starting at the border */
                reduce (p, goalnt);
                assert (p->env);
                /* increase the pin count by one to avoid releasing the
                   variables before the end of the while loop and remember 
                   which variables to unpin afterwards */
                for (unsigned int i = 0; i < env_count (p->env); i++) {
                    pin (env_at (p->env, i).mvar, 1);
                    *(mvar_t **) PFarray_add (border_vars) 
                        = env_at (p->env, i).mvar;
                }
            }
            break;
            
        default:
            for (unsigned short i = 0; nts[i]; i++)
                reduce_border (kids[i], nts[i], border_vars);
    }
}

/**
 * Alternative reducer function. Copes with patterns that are
 * larger than the burg patterns (e.g., variable parameter lists
 * required for the recursion operator). It contains the
 * respective action code for some of the above burg patterns.
 */
static void
reduce1 (PFpa_op_t * p, int goalnt, PFarray_t *border_vars)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */

    assert (p);
    /* reduce1 should be called only once for each pattern */
    if (p->env)
        return;

    p->env = new_env ();
    
    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);
    
#ifndef NDEBUG
    execute (comment ("Begin rule (reduce1): \"%s\"", PFmilgen_string[rule]));
#endif

    switch (rule) {
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 132:
            /* only generate MIL code for the seed */
            reduce (kids[0], nts[0]);
            
            /* relink the enviroment of arg to its base */
            L(p)->sem.rec_arg.base->env = p->env;
            
            /* Copy the result of the the seed into a new variable.
               This variable is pinned for each call of the base
               (base and paramter both refer to the same environment)
               and additionally for each parameter to avoid that the
               variable is overwritten during generation of the recursion. */
            for (unsigned int i = 0; i < env_count (LL(p)->env); i++) {
                mvar_t *tmp  = new_var (p->refctr + 
                                        L(p)->sem.rec_arg.base->refctr);

                /* copy variable */
                execute (
                    assgn (var (tmp->name),
                           var (env_at (LL(p)->env, i).mvar->name)));
                
                /* add the variable to the current environment
                   (and thus also to the base environment) */
                env_add (p->env,
                         env_at (LL(p)->env, i).att,
                         env_at (LL(p)->env, i).ty,
                         tmp);
                
                /* unpin the seed once -- the recursion now does not
                   reference it anymore */
                unpin (((env_t *) PFarray_at (kids[0]->env, i))->mvar, 1);
            }

            /* translate all the remaining seeds */
            reduce1 (kids[2], nts[2], border_vars);

            /* translate all expressions that are invariant to
               the recursion body */
            reduce_border (kids[1], nts[1], border_vars);
            break;

        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 133:
            /* relink the enviroment of arg to its base */
            L(p)->sem.rec_arg.base->env = p->env;

            /* For each column and type in the empty table generate
               a new bat and assign it to the variables used by the
               recursion. */
            for (unsigned int col = 0; col < LL(p)->schema.count; col++) {
                if (!LL(p)->schema.items[col].type)
                    PFoops (OOPS_FATAL,
                            "empty sequence should never occur in MIL generation.");

                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & LL(p)->schema.items[col].type) {
                        mvar_t *tmp  = new_var (p->refctr + 
                                                L(p)->sem.rec_arg.base->refctr);

                        /* assign an empty BAT to the new variable */
                        execute (
                            assgn (var (tmp->name),
                                   seqbase (new (type (m_void), implty (t)),
                                            lit_oid (0))));
                        
                        /* add the variable to the current environment
                           (and thus also to the base environment) */
                        env_add (p->env,
                                 LL(p)->schema.items[col].name,
                                 t,
                                 tmp);
                    }
            }

            /* translate all the remaining seeds */
            reduce1 (kids[1], nts[1], border_vars);

            /* translate all expressions that are invariant to
               the recursion body */
            reduce_border (kids[0], nts[0], border_vars);
            break;

        /* Rec:      rec_nil */
        case 134:
            /* no MIL code needed */
            break;
            
        default:
            PFoops (OOPS_FATAL,
                    "cannot cope with rule %d in "
                    "alternative reduce function",
                    rule);
    }

#ifndef NDEBUG
    execute (comment ("End rule (reduce1): \"%s\"", PFmilgen_string[rule]));
    for (unsigned int i = 0; i < PFarray_last (p->env); i++)
        assert (((env_t *) PFarray_at (p->env, i))->mvar->pins);
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

}

/**
 * Alternative reducer function. Copes with patterns that are
 * larger than the burg patterns (e.g., variable parameter lists
 * required for the recursion operator). It contains the
 * respective action code for some of the above burg patterns.
 */
static void
reduce2 (PFpa_op_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    int           pos_body;       /* position of the recursion body in the
                                     list of kids */

    /* reduce2 should be only called after reduce1 */
    if (!p->env)
        PFoops (OOPS_FATAL,
                "cannot cope with function reduce2 "
                "as long as reduce1 was not called.");

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);
    
#ifndef NDEBUG
    execute (comment ("Begin rule (reduce2): \"%s\"", PFmilgen_string[rule]));
#endif

    pos_body = 0;
    
    switch (rule) {
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 132:
            pos_body = 1; /* discard the seed */
        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 133:
            /* only generate MIL code for the seed */
            reduce (kids[pos_body], nts[pos_body]);
            /* translate all the remaining parts of the body */
            reduce2 (kids[pos_body + 1], nts[pos_body + 1]);
            
            /* ensure that we have a 1:1 mapping of the environments */
            assert (PFarray_last (p->env) == PFarray_last (LR(p)->env));
            
            /* Reassign the variables. Thus the initial seed relations
               are overwritten by the result of the recursion */
            for (unsigned int i = 0; i < PFarray_last (p->env); i++) {
                env_t entry = env_at (p->env, i);

                /* find the corresponding variable in res for the variable in p */
                mvar_t *tmp = env_mvar (LR(p)->env, entry.att, entry.ty);

                execute (
                    assgn (var (entry.mvar->name),
                           var (tmp->name)));
                   
                /* unpin the recursion once -- the recursion now does not
                   reference it anymore */
                unpin (tmp, 1);
            }
            break;

        /* Rec:      rec_nil */
        case 134:
            /* no MIL code needed */
            break;
            
        default:
            PFoops (OOPS_FATAL,
                    "cannot cope with rule %d in "
                    "alternative reduce function",
                    rule);
    }

#ifndef NDEBUG
    execute (comment ("End rule (reduce2): \"%s\"", PFmilgen_string[rule]));
    for (unsigned int i = 0; i < PFarray_last (p->env); i++)
        assert (((env_t *) PFarray_at (p->env, i))->mvar->pins);
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

}

/**
 * Alternative reducer function. Copes with patterns that are
 * larger than the burg patterns (e.g., variable parameter lists
 * required for the recursion operator). It contains the
 * respective action code for some of the above burg patterns.
 */
static void
reduce3 (PFpa_op_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    int           pos_list;       /* position of the param list in the
                                     list of kids */

    /* reduce3 should be only called after reduce1 */
    if (!p->env)
        PFoops (OOPS_FATAL,
                "cannot cope with function reduce3 "
                "as long as reduce1 was not called.");

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);
    
#ifndef NDEBUG
    execute (comment ("Begin rule (reduce3): \"%s\"", PFmilgen_string[rule]));
#endif

    pos_list = 1;
    
    switch (rule) {
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 132:
            pos_list = 2; /* discard the seed */
        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 133:
            /* translate all the remaining parts of the list */
            reduce3 (kids[pos_list], nts[pos_list]);
            
            /* release the remaining pins that ensured that the
               recursion input arguments were not overwritten
               during the recursion. */
            for (unsigned int i = 0; i < PFarray_last (p->env); i++) {
                unpin (env_at (p->env, i).mvar, p->refctr);
            }
            break;

        /* Rec:      rec_nil */
        case 134:
            /* no MIL code needed */
            break;
            
        default:
            PFoops (OOPS_FATAL,
                    "cannot cope with rule %d in "
                    "alternative reduce function",
                    rule);
    }

#ifndef NDEBUG
    execute (comment ("End rule (reduce3): \"%s\"", PFmilgen_string[rule]));
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

}

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFpa_op_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */

    if (p->env)
        return;

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);

    /* PFinfo (OOPS_NOTICE, "in rule %u", rule); */

    switch (rule) {
        /* Query:    serialize (FragList, Rel) */
        case 1:
        /* Query:    serialize (FragList, empty_tbl) */
        case 2:
        /* Rel:      rec_fix (Rec, Rel) */
        case 131:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     * (ensure that the fragment information is translated after 
     *  the value part)
     */
    if (!topdown)
        for (unsigned short i = MAX_KIDS; i > 0; i--)
            if (kids[i - 1])
                reduce (kids[i - 1], nts[i - 1]);

    if (p->env)
        return;

    p->env = new_env ();

#ifndef NDEBUG
    execute (comment ("Begin rule: \"%s\"", PFmilgen_string[rule]));
#endif

    switch (rule) {

        /* Query:   serialize (FragList, Rel) */
        case 1:
        {
            mvar_t *intVAL, *dblVAL, *decVAL, *strVAL;
            mvar_t *item, *kind, *err, *time;
            PFalg_simple_type_t ty;
            bool sorted = false;
            PFalg_att_t pa_item = p->sem.serialize.item;
            PFmil_t *oldmilprog, *bodymilprog;

            /* save the current mil program */
            oldmilprog = milprog;
           
            /* create a new empty milprog */
            milprog = nop ();
           
            /*
            PFmil_t *args = NULL;
            */

            execute (
                assgn (var (PF_MIL_VAR_WS), new_ws ()));
            reduce (kids[1], nts[1]);
            reduce (kids[0], nts[0]);

            /* add timing information */
            time = new_var (1);
            execute (assgn (var (time->name), usec ()));
            
            /* Set up all the value containers for print_result().
             * (It is actually too much overhead to introduce the value
             * containers just for printing. But this way we can re-use
             * Jan F's print_result() and stay compatible with the
             * ``summer branch''.
             */

            intVAL = new_var (1);
            dblVAL = new_var (1);
            /*decVAL = new_var (1); as we currently have no
                                    decimal support we use doubles */
            decVAL = dblVAL;
            strVAL = new_var (1);
            item = new_var (1);
            kind = new_var (1);

            execute (
                assgn (var (intVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_lng), type (m_void)), true)),
                           lit_oid (0))),
                assgn (var (dblVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_dbl), type (m_void)), true)),
                           lit_oid (0))),
                /*
                assgn (var (decVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_dbl), type (m_void)), true)),
                           lit_oid (0))),
                */
                assgn (var (strVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_str), type (m_void)), true)),
                           lit_oid (0))),
                assgn (var (item->name),
                       seqbase (new (type (m_void), type (m_oid)), lit_oid(0))),
                assgn (var (kind->name),
                       seqbase (new (type (m_void), type (m_int)), lit_oid(0)))
                );

            ty = type_of (R(p), pa_item);

            /* consider attribute results */
            if (ty & aat_anode) {
                if (ty == aat_anode) {
                    execute (
                        assgn (var (item->name),
                               VAR (R(p)->env, pa_item, aat_attr)),
                        assgn (var (kind->name),
                               set_kind (VAR (R(p)->env, pa_item, aat_afrag),
                                         var (PF_MIL_VAR_ATTR)))
                        );
                    sorted = true;
                }
                else {
                    assert (ty & aat_attr && ty & aat_afrag);
                    execute (
                        binsert (var (item->name),
                                 select2 (
                                     VAR (R(p)->env, pa_item, aat_attr),
                                     cast (type (m_oid), nil ()),
                                     cast (type (m_oid), nil ()))),
                        binsert (var (kind->name),
                                 select2 (
                                     set_kind (VAR (R(p)->env, 
                                                    pa_item,
                                                    aat_afrag),
                                               var (PF_MIL_VAR_ATTR)),
                                     cast (type (m_int), nil ()),
                                     cast (type (m_int), nil ())))
                        );
                }
            }

            /* consider node results */
            if (ty & aat_pnode) {
                if (ty == aat_pnode) {
                    execute (
                        assgn (var (item->name),
                               VAR (R(p)->env, pa_item, aat_pre)),
                        assgn (var (kind->name),
                               set_kind (VAR (R(p)->env, pa_item, aat_pfrag),
                                         var (PF_MIL_VAR_ELEM)))
                        );
                    sorted = true;
                }
                else {
                    assert (ty & aat_pre && ty & aat_pfrag);
                    execute (
                        binsert (var (item->name),
                                 select2 (
                                     VAR (R(p)->env, pa_item, aat_pre),
                                     cast (type (m_oid), nil ()),
                                     cast (type (m_oid), nil ()))),
                        binsert (var (kind->name),
                                 select2 (
                                     set_kind (VAR (R(p)->env, 
                                                    pa_item,
                                                    aat_pfrag),
                                               var (PF_MIL_VAR_ELEM)),
                                     cast (type (m_int), nil ()),
                                     cast (type (m_int), nil ())))
                        );
                }
            }

            /* consider str results */
            if (ty & aat_str) {
                execute (
                    bappend (var (strVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       pa_item,
                                                       aat_str),
                                                  cast (type (m_str), nil ()),
                                                  cast (type (m_str), nil ()))
                                         )))));
                if (ty == aat_str) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, pa_item, aat_str),
                                      reverse (var (strVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_str),
                                     var (PF_MIL_VAR_STR)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, pa_item, aat_str),
                                  reverse (var (strVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_str),
                                              cast (type (m_str), nil ()),
                                              cast (type (m_str), nil ())),
                                     var (PF_MIL_VAR_STR)))
                    );
                }
            }

            /* consider untyped results */
            if (ty & aat_uA) {
                execute (
                    bappend (var (strVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       pa_item,
                                                       aat_uA),
                                                  cast (type (m_str), nil ()),
                                                  cast (type (m_str), nil ()))
                                         )))));
                if (ty == aat_uA) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, pa_item, aat_uA),
                                      reverse (var (strVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_uA),
                                     var (PF_MIL_VAR_STR)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, pa_item, aat_uA),
                                  reverse (var (strVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_uA),
                                              cast (type (m_str), nil ()),
                                              cast (type (m_str), nil ())),
                                     var (PF_MIL_VAR_STR)))
                    );
                }
            }

            /* consider int results */
            if (ty & aat_int) {
                execute (
                    bappend (var (intVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       pa_item,
                                                       aat_int),
                                                  cast (type (m_lng), nil ()),
                                                  cast (type (m_lng), nil ()))
                                         )))));
                if (ty == aat_int) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, pa_item, aat_int),
                                      reverse (var (intVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_int),
                                     var (PF_MIL_VAR_INT)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, pa_item, aat_int),
                                  reverse (var (intVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_int),
                                              cast (type (m_lng), nil ()),
                                              cast (type (m_lng), nil ())),
                                     var (PF_MIL_VAR_INT)))
                    );
                }
            }

            /* consider dbl results */
            if (ty & aat_dbl) {
                execute (
                    bappend (var (dblVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       pa_item,
                                                       aat_dbl),
                                                  cast (type (m_dbl), nil ()),
                                                  cast (type (m_dbl), nil ()))
                                         )))));
                if (ty == aat_dbl) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, pa_item, aat_dbl),
                                      reverse (var (dblVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_dbl),
                                     var (PF_MIL_VAR_DBL)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, pa_item, aat_dbl),
                                  reverse (var (dblVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_dbl),
                                              cast (type (m_dbl), nil ()),
                                              cast (type (m_dbl), nil ())),
                                     var (PF_MIL_VAR_DBL)))
                    );
                }
            }

            /* consider dec results */
            if (ty & aat_dec) {
                execute (
                    bappend (var (decVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       pa_item,
                                                       aat_dec),
                                                  cast (type (m_dbl), nil ()),
                                                  cast (type (m_dbl), nil ()))
                                         )))));
                if (ty == aat_dec) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, pa_item, aat_dec),
                                      reverse (var (decVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_dec),
                                     var (PF_MIL_VAR_DEC)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, pa_item, aat_dec),
                                  reverse (var (decVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_dec),
                                              cast (type (m_dbl), nil ()),
                                              cast (type (m_dbl), nil ())),
                                     var (PF_MIL_VAR_DEC)))
                    );
                }
            }

            /* consider bit results */
            if (ty & aat_bln) {
                if (ty == aat_int) {
                    execute (
                        assgn (
                            var (item->name),
                            mcast (type (m_oid),
                                   VAR (R(p)->env, pa_item, aat_bln))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_bln),
                                     var (PF_MIL_VAR_BOOL)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            mcast (type (m_oid),
                                   VAR (R(p)->env, pa_item, aat_bln))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_bln),
                                              cast (type (m_bit), nil ()),
                                              cast (type (m_bit), nil ())),
                                     var (PF_MIL_VAR_BOOL)))
                    );
                }
            }

            if (!sorted)
                execute (
                    assgn (var (item->name),
                           sort (var (item->name))),
                    assgn (var (kind->name),
                           leftjoin (mirror (var (item->name)),
                                     var (kind->name))));

            execute (
                assgn (var (item->name),
                       reverse (mark (reverse (var (item->name)),lit_oid (0)))),
                assgn (var (kind->name),
                       reverse (mark (reverse (var (kind->name)),lit_oid (0)))),

                serialize (
                    arg (lit_str ("xml"),
                        arg (var (PF_MIL_VAR_WS),
                            arg (var (item->name),
                                arg (var (kind->name),
                                    arg (var (intVAL->name),
                                        arg (var (dblVAL->name),
                                            arg (var (decVAL->name),
                                                 var (strVAL->name))))))))));

            /*
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                if (i)
                    args = arg (args,
                                var (env_at (R(p)->env, i).mvar->name));
                else
                    args = var (env_at (R(p)->env, i).mvar->name);
            }

            execute (print (args));
            */

            unpin (intVAL, 1);
            unpin (dblVAL, 1);
            /* unpin (decVAL, 1); as we currently have no
                                           decimal support we use doubles */
            unpin (strVAL, 1);
            unpin (item, 1);
            unpin (kind, 1);

            /* add timing information */
            execute (
                assgn (var (PF_MIL_VAR_TIME_PRINT),
                       sub (usec (),
                            var (time->name))));
            unpin (time, 1);

            /* make the old mil program the active one */
            bodymilprog = milprog;
            milprog = oldmilprog;
           
            err = new_var (1);

            execute (
                catch_ (var (err->name), bodymilprog),
                if_ (not (isnil (var (PF_MIL_VAR_WS))),
                     destroy_ws (var (PF_MIL_VAR_WS)),
                     nop ()),
                if_ (not (isnil (var (err->name))),
                     error (var (err->name)),
                     nop ()));
            
            unpin (err, 1);
        } break;

        /* Query:   serialize (FragList, empty_tbl) */
        case 2:
        {
            mvar_t *intVAL, *dblVAL, *decVAL, *strVAL;
            mvar_t *item, *kind, *err, *time;
            PFmil_t *oldmilprog, *bodymilprog;

            /* save the current mil program */
            oldmilprog = milprog;
           
            /* create a new empty milprog */
            milprog = nop ();
           
            reduce (kids[0], nts[0]);

            /* add timing information */
            time = new_var (1);
            execute (assgn (var (time->name), usec ()));
            
            /* Set up all the value containers for print_result().
             * (It is actually too much overhead to introduce the value
             * containers just for printing. But this way we can re-use
             * Jan F's print_result() and stay compatible with the
             * ``summer branch''.
             */

            intVAL = new_var (1);
            dblVAL = new_var (1);
            decVAL = new_var (1);
            strVAL = new_var (1);
            item = new_var (1);
            kind = new_var (1);

            execute (
                assgn (var (PF_MIL_VAR_WS), new_ws ()),
                assgn (
                    var (intVAL->name),
                    seqbase (new (type (m_void), type (m_lng)), lit_oid (0))),
                assgn (
                    var (dblVAL->name),                
                    seqbase (new (type (m_void), type (m_dbl)), lit_oid (0))),
                assgn (
                    var (decVAL->name),                
                    seqbase (new (type (m_void), type (m_dbl)), lit_oid (0))),
                assgn (
                    var (strVAL->name),                
                    seqbase (new (type (m_void), type (m_str)), lit_oid (0))),
                assgn (
                    var (item->name),
                    seqbase (new (type (m_void), type (m_oid)), lit_oid (0))),
                assgn (
                    var (kind->name),
                    seqbase (new (type (m_void), type (m_int)), lit_oid (0))),
                serialize (
                    arg (lit_str ("xml"),
                        arg (var (PF_MIL_VAR_WS),
                            arg (var (item->name),
                                arg (var (kind->name),
                                    arg (var (intVAL->name),
                                        arg (var (dblVAL->name),
                                            arg (var (decVAL->name),
                                                 var (strVAL->name))))))))));
            
            unpin (intVAL, 1);
            unpin (dblVAL, 1);
            unpin (decVAL, 1);
            unpin (strVAL, 1);
            unpin (item, 1);
            unpin (kind, 1);

            /* add timing information */
            execute (
                assgn (var (PF_MIL_VAR_TIME_PRINT),
                       sub (usec (),
                            var (time->name))));
            unpin (time, 1);

            /* make the old mil program the active one */
            bodymilprog = milprog;
            milprog = oldmilprog;
           
            err = new_var (1);

            execute (
                catch_ (var (err->name), bodymilprog),
                if_ (not (isnil (var (PF_MIL_VAR_WS))),
                     destroy_ws (var (PF_MIL_VAR_WS)),
                     nop ()),
                if_ (not (isnil (var (err->name))),
                     error (var (err->name)),
                     nop ()));

            unpin (err, 1);
        } break;

        /* Rel:      lit_tbl */
        case 10:

            /* iterate over table columns */
            for (unsigned int col = 0; col < p->schema.count; col++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & p->schema.items[col].type) {
                        /* special support for QNames */
                        if (t == aat_qname)
                        {
                            /* insert qnames into working set
                               and insert corresponding offsets
                               into result */
                            mvar_t *v = new_var (p->refctr);

                            env_add (p->env, p->schema.items[col].name, t, v);

                            execute (
                                assgn (
                                    var (v->name),
                                    seqbase (
                                        new (type (m_void), implty (t)),
                                        lit_oid (0))));

                            for (unsigned int row = 0;
                                    row < p->sem.lit_tbl.count; row++)
                                execute (
                                    append (
                                        var (v->name),
                                   /* add_qname changes the working set 
                                      in 'var (PF_MIL_VAR_WS)' as side effect */
                                        add_qname (lit_str (
                                                       PFqname_ns (
                                                           p->sem.lit_tbl
                                                                 .tuples[row]
                                                                 .atoms[col]
                                                                 .val.qname)),
                                                   lit_str (
                                                       PFqname_uri (
                                                           p->sem.lit_tbl
                                                                 .tuples[row]
                                                                 .atoms[col]
                                                                 .val.qname)),
                                                   lit_str (
                                                       PFqname_loc (
                                                           p->sem.lit_tbl
                                                                 .tuples[row]
                                                                 .atoms[col]
                                                                 .val.qname)),
                                                   var (PF_MIL_VAR_WS))));

                            execute (access (var (v->name), BAT_READ));
                        } else {
                            mvar_t *v = new_var (p->refctr);
                            env_add (p->env, p->schema.items[col].name, t, v);

                            execute (
                                assgn (
                                    var (v->name),
                                    seqbase (
                                        new (type (m_void), implty (t)),
                                        lit_oid (0))));

                            for (unsigned int row = 0;
                                    row < p->sem.lit_tbl.count; row++)
                                execute (
                                    append (
                                        var (v->name),
                                        t == p->sem.lit_tbl.tuples[row]
                                                            .atoms[col].type
                                        ? literal (p->sem.lit_tbl.tuples[row]
                                                                  .atoms[col])
                                        : cast (implty (t), nil ())));

                            execute (access (var (v->name), BAT_READ));
                        }
                    }

            break;

        /* Rel:     empty_tbl */
        case 11:
            PFoops (OOPS_FATAL,
                    "empty sequence should never occur in MIL generation."
                    " (optimizations disabled?)");
            break;

        /* Rel:      attach (Rel) */
        case 12:
        {
            /* copy all the existing variables */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }

            /* now create the new column */
            mvar_t *v = new_var (p->refctr);
            env_add (p->env, p->sem.attach.attname,
                     p->sem.attach.value.type, v);

            execute (
                assgn (var (v->name),
                       project (var (env_at (p->env, 0).mvar->name),
                                literal (p->sem.attach.value))));

        } break;

        /* Rel:      cross (Rel, Rel) */
        case 13:
        {
            mvar_t *v  = new_var (1);
            mvar_t *v1 = new_var (1);
            mvar_t *v2 = new_var (1);

            if (!env_count (L(p)->env) || !env_count (R(p)->env))
                PFoops (OOPS_FATAL, "Cross does not cope with empty schemas");

            execute (
                assgn (var (v->name),
                       cross (
                           project (var (env_at (L(p)->env, 0).mvar->name),
                                    nil ()),
                           reverse (
                               project (var (env_at (R(p)->env, 0).mvar->name),
                                        nil ())))),
                assgn (var (v1->name),
                       reverse (mark (var (v->name), lit_oid (0)))),
                assgn (var (v2->name),
                       reverse (mark (reverse (var (v->name)), lit_oid (0)))));

            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                mvar_t *tmp  = new_var (p->refctr);
                /* expand variables */
                execute (
                    assgn (var (tmp->name),
                           leftjoin (var (v1->name),
                                     var (env_at (L(p)->env, i).mvar->name))),
                    /* because leftjoin does not know that we have 
                       exactly one match for each tuple in v,
                       we need to make the heads void ourselves */
                    assgn (var (tmp->name),
                           reverse (mark (reverse (var (tmp->name)),
                                          lit_oid (0)))));
                
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         tmp);
            }
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                mvar_t *tmp  = new_var (p->refctr);
                /* expand variables */
                execute (
                    assgn (var (tmp->name),
                           leftjoin (var (v2->name),
                                     var (env_at (R(p)->env, i).mvar->name))),
                    /* because leftjoin does not know that we have 
                       exactly one match for each tuple in v,
                       we need to make the heads void ourselves */
                    assgn (var (tmp->name),
                           reverse (mark (reverse (var (tmp->name)),
                                          lit_oid (0)))));
                
                env_add (p->env,
                         env_at (R(p)->env, i).att,
                         env_at (R(p)->env, i).ty,
                         tmp);
            }

            unpin (v, 1);
            unpin (v1, 1);
            unpin (v2, 1);
        }
            break;

        /* Rel:      leftjoin (Rel, Rel) */
        case 14:
        /* Rel:      eqjoin (Rel, Rel) */
        case 15:
        {
            /*
             * We actually cannot guarantee that MonetDB applies a
             * MergeJoin (tactical optimization may choose other
             * implementations). By using leftjoin(), however, we
             * can guarantee the result to be correctly ordered.
             */
            PFalg_simple_type_t lty = type_of (L(p), p->sem.eqjoin.att1);
            PFalg_simple_type_t rty = type_of (R(p), p->sem.eqjoin.att2);
            mvar_t *l = NULL;
            mvar_t *r = NULL;
            mvar_t *tmp1 = new_var (1);
            mvar_t *tmp[2] = { [0] = new_var (1), [1] = new_var (1) };

            assert (lty == rty);

            for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                if (t == lty && t == rty) {
                    l = env_mvar_unsafe (L(p)->env, p->sem.eqjoin.att1, t);
                    r = env_mvar_unsafe (R(p)->env, p->sem.eqjoin.att2, t);
                    break;
                }
            }

            if (!l || !r)
                PFoops (OOPS_FATAL, "incompatible types in Join");

            execute (
                assgn (var (tmp1->name),
                       leftjoin (var (l->name), reverse (var (r->name)))),
                assgn (var (tmp[0]->name),
                       reverse (mark (var (tmp1->name), lit_oid (0)))),
                assgn (var (tmp[1]->name),
                       reverse (
                           mark (reverse (var (tmp1->name)), lit_oid (0)))));

            unpin (tmp1, 1);

            for (unsigned short c = 0; c < 2; c++) {
                for (unsigned int i = 0; i < env_count (p->child[c]->env); i++)
                {

                     mvar_t *v = new_var (p->refctr);

                     execute (
                          assgn (var (v->name),
                                 leftjoin (
                                      var (tmp[c]->name),
                                      var (env_at (p->child[c]->env,
                                                   i).mvar->name))),
                          /* because leftjoin does not know that we have 
                             exactly one match for each tuple in v,
                             we need to make the heads void ourselves */
                          assgn (var (v->name),
                                 reverse (mark (reverse (var (v->name)),
                                                lit_oid (0))))
                          );

                     env_add (p->env,
                              env_at (p->child[c]->env, i).att,
                              env_at (p->child[c]->env, i).ty,
                              v);
                }
            }

            unpin (tmp[0], 1);
            unpin (tmp[1], 1);

        } break;

        /* Rel:      project (Rel) */
        case 20:
            /*
             * Algebra projection is a no-op. We only fill the
             * environment in node p appropriately.
             */
            for (unsigned int i = 0; i < p->sem.proj.count; i++)
                 for (PFalg_simple_type_t t = 1; t; t <<= 1)
                      if (t & type_of (L(p), p->sem.proj.items[i].old)) {

                           mvar_t *v = env_mvar (L(p)->env,
                                                 p->sem.proj.items[i].old,
                                                 t);

                           env_add (p->env, p->sem.proj.items[i].new, t, v);
                           pin (v, p->refctr);

                      }

            break;

        /* Rel:      select (Rel) */
        case 21:
        {
            mvar_t *v = new_var (1);

            /*
             * For the predicate column c do
             *
             *  v := c.select (true).mark (0@0).reverse ();
             */
            execute (
                assgn (
                    var (v->name),
                    reverse (
                        mark (
                            select_(VAR (L(p)->env, p->sem.select.att,aat_bln),
                                    lit_bit (true)),
                            lit_oid (0)))));

            /*
             * Then join any BAT in L(p)'s environment with v
             */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                mvar_t *w = new_var (p->refctr);

                execute (
                    assgn (var (w->name),
                           leftjoin (var (v->name),
                                     var (env_at (L(p)->env, i).mvar->name))),
                    /* because leftjoin does not know that we have 
                       exactly one match for each tuple in v,
                       we need to make the heads void ourselves */
                    assgn (var (w->name),
                           reverse (mark (reverse (var (w->name)),
                                          lit_oid (0)))));

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         w);
            }

            /* release v */
            unpin (v, 1);

        } break;

        /* Rel:      append_union (Rel, Rel) */
        case 22:

            for (unsigned int i = 0; i < p->schema.count; i++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & p->schema.items[i].type) {

                        mvar_t *v = new_var (p->refctr);

                        /*
                         * Type t is in the result relation. See if it
                         * is also in the left operand.
                         */
                        if (t & type_of (L(p), p->schema.items[i].name))
                            /* v := l.copy */
                            execute (
                                assgn (
                                    var (v->name),
                                    access (
                                        copy (VAR (L(p)->env,
                                                   p->schema.items[i].name,
                                                   t)),
                                        BAT_APPEND)));
                        else
                            /* v := <some BAT of L>.project(nil); */
                            execute (
                                assgn (
                                    var (v->name),
                                    access (
                                        project (
                                            var (env_at (L(p)->env, 0).mvar
                                                                       ->name),
                                            cast (implty (t), nil ())),
                                        BAT_APPEND)));

                        /*
                         * Is t also in the right operand?
                         */
                        if (t & type_of (R(p), p->schema.items[i].name))
                            /* v.append(R); */
                            execute (
                                access (
                                    bappend (
                                        var (v->name),
                                        VAR (R(p)->env,
                                             p->schema.items[i].name,
                                             t)),
                                    BAT_READ));
                        else
                            /* v.append(<some BAT of L>.project(nil)); */
                            execute (
                                access (
                                    bappend (
                                        var (v->name),
                                        project (
                                            var (env_at (R(p)->env, 0).mvar
                                                                       ->name),
                                            cast (implty (t), nil ()))),
                                    BAT_APPEND));

                        env_add (p->env, p->schema.items[i].name, t, v);
                    }

            break;

        /* Rel:      append_union (hash_count (Rel),
                                   attach (
                                       diff (Rel, 
                                             project (hash_count (Rel))))) */
        case 23:
        {
            if (L(p) == RLRL(p) && 
                R(p)->sem.attach.attname == L(p)->sem.count.res &&
                R(p)->sem.attach.value.type == aat_int &&
                R(p)->sem.attach.value.val.int_ == 0 &&
                RLL(p)->schema.count == 1 &&
                RLR(p)->schema.count == 1 &&
                L(p)->sem.count.part != att_NULL) {

                for (unsigned int i = 0; i < LL(p)->schema.count; i++)
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & LL(p)->schema.items[i].type) {

                            if (t != LL(p)->schema.items[i].type)
                                PFoops (OOPS_FATAL,
                                        "HashCount not implemented for "
                                        "polymorphic groups");

                            mvar_t *v    = new_var (1);
                            mvar_t *res  = new_var (p->refctr);
                            mvar_t *part = new_var (p->refctr);

                            execute (
                                /* v := {count}(p_in.reverse ()) */
                                assgn (
                                    var (v->name),
                                    egcount (
                                        reverse (VAR (LL(p)->env,
                                                      L(p)->sem.count.part, t)),
                                        reverse (
                                            VAR (RLL(p)->env,
                                                 RLL(p)->schema.items[0].name,
                                                 t)))),
                                /* align with integer representation (lng) */
                                assgn (var (v->name),
                                       mcast (type (m_lng), var (v->name))),
                                /* res := v.reverse ().mark (0@0).reverse (); */
                                assgn (
                                    var (res->name),
                                    reverse (
                                        mark (
                                            reverse (var (v->name)),
                                            lit_oid (0)))),
                                /* part := v.mark (0@0).reverse (); */
                                assgn (
                                    var (part->name),
                                    reverse (
                                        mark (var (v->name), lit_oid (0)))));

                            env_add (p->env, L(p)->sem.count.res, aat_int, res);
                            env_add (p->env, L(p)->sem.count.part, t, part);

                            unpin (v, 1);
                        }

                /* the relation in hash_count is used twice in this pattern
                   - the DAG however counts only one reference - thus we 
                   increase the pin count of the affected variables */
                for (unsigned int i = 0; i < PFarray_last (LL(p)->env); i++)
                    pin (env_at (LL(p)->env, i).mvar, 1);
            }
            else
                PFoops (OOPS_FATAL, 
                        "translation in milgen.brg is incorrect "
                        "- please remove");
        } break;

        /* Rel:      merge_union (Rel, Rel) */
        case 24:
        {
            PFmil_t *grouping[2];
            PFmil_t *args;
            bool     single_column_grouping = true;
            mvar_t  *v = NULL;

            /*
             * If the grouping parameter for MergeUnion is just a
             * single column, we can use the corresponding BAT right
             * away.  Otherwise, we need to use MonetDB's CT...()
             * functions to generate a BAT that describes just that
             * grouping.
             */
            grouping[0]
                = VAR (L(p)->env,
                       PFord_order_at (p->sem.merge_union.ord, 0),
                       type_of (L(p),
                                PFord_order_at (p->sem.merge_union.ord, 0)));
            grouping[1]
                = VAR (R(p)->env,
                       PFord_order_at (p->sem.merge_union.ord, 0),
                       type_of (R(p),
                                PFord_order_at (p->sem.merge_union.ord, 0)));

            /*
             * We know (from the ordering properties we derived) that
             * our input is appropriately ordered. The grouping
             * function CTderive(), however, also provides grouping
             * from un-ordered groups (using a hash-based implementation).
             * This way, the resulting grouping BATs will not be marked
             * as tail-ordered (although they always will be, as we
             * know from our own ordering properties). We thus need to
             * check orderings explicitly (using chk_order()).
             *
             * An alternative to CTderive() could help us in two ways:
             *
             *  (1) There's actually no need to use a hash-based
             *      implementation, if we know that our input has the
             *      correct ordering.
             *  (2) An order-aware implementation could set ordering
             *      properties correctly right away.
             */
            for (unsigned int i = 1;
                    i < PFord_count (p->sem.merge_union.ord); i++) {

                single_column_grouping = false;

                grouping[0]
                    = ctderive (
                        grouping[0],
                        VAR (L(p)->env,
                             PFord_order_at (p->sem.merge_union.ord, i),
                             type_of (
                                 L(p),
                                 PFord_order_at (p->sem.merge_union.ord, i))));
                grouping[1]
                    = ctderive (
                        grouping[1],
                        VAR (R(p)->env,
                             PFord_order_at (p->sem.merge_union.ord, i),
                             type_of (
                                 R(p),
                                 PFord_order_at (p->sem.merge_union.ord, i))));
            }

            /*
             * If we had to CTderive(), turn the grp result into an
             * actual BAT using CTmap().
             *
             * Use chk_order() to ensure that order properties are
             * correctly derived on the back-end.
             *
             * NOTE:
             *   We only want to use chk_order() on computed BATs,
             *   *not* if grouping[i] are just the variable names of
             *   the input relations.  Otherwise, chk_order() would
             *   have a side-effect on our input, with unpredictable
             *   effects...
             */
            if (PFord_count (p->sem.merge_union.ord) > 1)
                for (unsigned int i = 0; i < 2; i++)
                    grouping[i] = chk_order (ctmap (grouping[i]));


            /* first two arguments of merged_union() are the grouping atts */
            args = arg (grouping[0], grouping[1]);

            for (unsigned int i = 0; i < p->schema.count; i++) {

                /*
                 * If we group by a single column, then we don't need
                 * to list the grouping attribute a second time.
                 */
                if (!single_column_grouping
                    || p->schema.items[i].name !=
                       PFord_order_at (p->sem.merge_union.ord, 0)) {

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & p->schema.items[i].type) {

                            for (unsigned short j = 0; j <= 1; j++)
                                /*
                                 * If t is among the operand's types, use the
                                 * corresponding BAT, otherwise substitute a
                                 * BAT with `nil' tail.
                                 */
                                if (t & type_of (p->child[j],
                                                 p->schema.items[i].name))
                                    args = arg (args,
                                                VAR (p->child[j]->env,
                                                     p->schema.items[i].name,
                                                     t));
                                else
                                    args = arg (args,
                                                project (grouping[j],
                                                         cast (implty(t),
                                                               nil ())));
                        }
                }
            }

            v = new_var (1);

            /* execute merged_union() and assign it to v */
            execute (assgn (var (v->name), merged_union (args)));

            unsigned int j = 1;

            /* now extract all the result BATs */
            for (unsigned int i = 0; i < p->schema.count; i++) {

                /*
                 * If we group by a single column, then the grouping
                 * attribute is to be found as the first result BAT.
                 */
                if (!single_column_grouping
                    || p->schema.items[i].name !=
                       PFord_order_at (p->sem.merge_union.ord, 0)) {

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & p->schema.items[i].type) {

                            mvar_t *w = new_var (p->refctr);

                            execute (
                                assgn (var (w->name),
                                       fetch (var (v->name), lit_int (j))));
                            env_add (p->env, p->schema.items[i].name, t, w);
                            j++;

                        }
                }
                else {
                    PFalg_simple_type_t t
                        = type_of (p, p->schema.items[i].name);
                    mvar_t *w = new_var (p->refctr);

                    env_add (p->env, p->schema.items[i].name, t, w);
                    execute (
                            assgn (var (w->name),
                                fetch (var (v->name), lit_int (0))));
                }
            }

            /* release our temporary variable v */
            unpin (v, 1);

        } break;

        /* Rel:      intersect (Rel, Rel) */
        case 25:
        {
	    mvar_t **res, **r;
	    mvar_t *is;
	    unsigned int shared_cols;
	    PFmil_t *intersection;

	    /* prepare as many result variables and temporary variables as 
	       there will be result columns */
	    res = (mvar_t **) PFmalloc (sizeof (mvar_t *) * 
					env_count(L(p)->env));
	    r   = (mvar_t **) PFmalloc (sizeof (mvar_t *) * 
					env_count(L(p)->env));

	    shared_cols = 0;
	    for (unsigned int col = 0; col < env_count (L(p)->env); col++) {
	      /* in the rhs argument, try to find the column that coresponds 
		 (name, type) with the column in the lhs */ 
	      r[shared_cols] = env_mvar_unsafe (R(p)->env,
						env_at (L(p)->env, col).att,
						env_at (L(p)->env, col).ty);
	      if (r[shared_cols]) {
		res[shared_cols] = new_var (p->refctr);
		execute (assgn (var (res[shared_cols]->name), 
				join (var (env_at (L(p)->env, col).mvar->name),
				      reverse (var (r[shared_cols]->name)))));

		env_add (p->env, 
			 env_at (L(p)->env, col).att, 
			 env_at (L(p)->env, col).ty,
			 res[shared_cols]);

		shared_cols++;
	      }
	    }

	    if (!shared_cols)
	      PFoops (OOPS_FATAL, "Arguments to Intersect do not share "
		                  "any column with common name and type");

	    /* compute intersection (column-by-column) */ 	
	    intersection = var (res[0]->name);
	    for (unsigned int col = 1; col < shared_cols; col++)
	        intersection = sintersect (intersection, var (res[col]->name));

	    is = new_var (1);
	    execute (
                assgn (var (is->name), 
		       reverse (mark (tunique (intersection), lit_oid (0)))));
	    
	    for (unsigned int col = 0; col < shared_cols; col++)
	        execute (
	  	    assgn (var (res[col]->name),
			   leftjoin (var (is->name), var (r[col]->name))));

	    /* release temporary variable is */
	    unpin (is, 1);
	    
	} break;

	/* Rel:      difference (Rel, Rel) */
        case 26:
	{
   	    mvar_t **res, **l, *r;
	    unsigned int shared_cols;
	    mvar_t *is;
	    PFmil_t *intersection;

  	    /* prepare as many result variables and temporary variables as 
	       there will be result columns */
  	    res = (mvar_t **) PFmalloc (sizeof (mvar_t *) * 
					env_count(L(p)->env));
	    l   = (mvar_t **) PFmalloc (sizeof (mvar_t *) * 
					env_count(L(p)->env));
	    
	    shared_cols = 0;
	    for (unsigned int col = 0; col < env_count (L(p)->env); col++) {
	      /* in the rhs argument, try to find the column that coresponds 
		 (name, type) with the column in the lhs */ 
	      r = env_mvar_unsafe (R(p)->env, env_at (L(p)->env, col).att,
				              env_at (L(p)->env, col).ty);
	      if (r) {
		res[shared_cols] = new_var (p->refctr);
		l[shared_cols]   = env_at (L(p)->env, col).mvar;
		execute (assgn (var (res[shared_cols]->name), 
				join (var (l[col]->name), 
				      reverse (var (r->name)))));

		env_add (p->env, 
			 env_at (L(p)->env, col).att, 
			 env_at (L(p)->env, col).ty,
			 res[shared_cols]);

		shared_cols++;
	      }
	    }

	    if (!shared_cols)
	      PFoops (OOPS_FATAL, "Arguments to Difference do not share "
		                  "any column with common name and type");

	    /* compute intersection (column-by-column) */ 	
	    intersection = var (res[0]->name);
	    for (unsigned int col = 1; col < shared_cols; col++)
	        intersection = sintersect (intersection, var (res[col]->name));
	    
	    is = new_var (1);
	    execute (assgn (var (is->name), intersection));

	    for (unsigned int col = 0; col < shared_cols; col++)
	      execute (
	          assgn (var (res[col]->name),
			 reverse (
			     mark (reverse (kdiff (var (l[col]->name), 
						   var (is->name))),
				   lit_oid (0)))));
	    
	    /* release temporary variable is */
	    unpin (is, 1);

	} break;

        /* Rel:      sort_distinct (Rel) */
        case 30:
        /* Rel:      sort_distinct (std_sort (Rel)) */
        case 31: 
        /* Rel:      sort_distinct (refine_sort (Rel)) */
        case 32: 
            /* as we have to sort anyway we can also skip the sort operator */
        {
            /*
             * Derive a single BAT from the multi-column grouping
             * (using functions from the xtables module).
             */
            mvar_t    *v = new_var (1);
            mvar_t    *first_sort_var = NULL;
            bool       initialized = false;
            PFpa_op_t *rel;

            if (L(p)->kind == pa_std_sort || L(p)->kind == pa_refine_sort)
                rel = LL(p);
            else
                rel = L(p);

            /* cope with completely constant relations */
            if (!PFord_count (p->sem.sort_distinct.ord))
                execute (assgn (var (v->name),
                                var (env_at (rel->env, 0).mvar->name)));

            for (unsigned int i = 0;
                    i < PFord_count (p->sem.sort_distinct.ord); i++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if (t & type_of (rel,
                                     PFord_order_at (p->sem.sort_distinct.ord,
                                                     i))) {
                        if (!initialized) {
                            first_sort_var = env_mvar (rel->env,
                                                       PFord_order_at (
                                                           p->sem.sort_distinct.ord, i),
                                                       t);
                            execute (
                                assgn (
                                    var (v->name),
                                    reverse (
                                        sort (
                                            reverse (
                                                var (first_sort_var->name))
                                            ))));

                            initialized = true;
                        }
                        else {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (rel->env,
                                             PFord_order_at (p->sem
                                                               .sort_distinct
                                                               .ord, i),
                                             t))));
                        }
                    }
                }
            }

            /*
             * Variable v is now of MIL type grp and contains the
             * grouping we need.
             *
             * We get the duplicate-free equivalent of our input by
             * joining the extend of v with each input BAT (and
             * generating a new key with mark().
             *
             * v := v.CTextend ().mark (0@0).reverse ();
             */
            execute (
                assgn (var (v->name),
                       reverse (mark (reverse (
                                          kunique( reverse (var (v->name)))),
                                      lit_oid (0)))));

            /*
             * The join with each input relation:
             *
             * out := v.join (in);
             */
            for (unsigned int i = 0; i < env_count (rel->env); i++) {
                 mvar_t *out = new_var (p->refctr);

                 execute (
                      assgn (var (out->name),
                             leftjoin (var (v->name),
                                       var (env_at (rel->env,
                                                    i).mvar->name))));

                 /* we know that the first sort criterion certainly 
                    is sorted */
                 if (first_sort_var == env_at (rel->env,i).mvar)
                     execute (
                          assgn (var (out->name),
                                 assert_order (var (out->name))));

                 /* because leftjoin does not know that we have 
                    exactly one match for each tuple in v,
                    we need to make the heads void ourselves */
                 execute (
                     assgn (var (out->name),
                            reverse (mark (reverse (var (out->name)),
                                           lit_oid (0)))));

                 env_add (p->env,
                          env_at (rel->env, i).att,
                          env_at (rel->env, i).ty,
                          out);
            }

            /* release our temporary variable */
            unpin (v, 1);

        } break;

        /* Rel:      std_sort (Rel) */
        case 33:
        {
            unsigned int count          = 0;
            mvar_t      *v              = new_var (1);
            mvar_t      *first_sort_var = NULL;

            for (unsigned int i = 0;
                    i < PFord_count (p->sem.sortby.required); i++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & type_of (L(p),
                                     PFord_order_at (p->sem.sortby.required,
                                                     i))) {
                        if (count) {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (L(p)->env,
                                             PFord_order_at (
                                                 p->sem.sortby.required,
                                                 i),
                                             t))));
                        }
                        else {
                            first_sort_var = env_mvar (
                                                 L(p)->env,
                                                 PFord_order_at (
                                                     p->sem.sortby.required,
                                                     i),
                                                 t);
                            
                            execute (
                                assgn (
                                    var (v->name),
                                    reverse (
                                        sort (
                                            reverse (
                                                var (first_sort_var->name))
                                            ))));
                        }
                        count++;
                    }

            /* handle the case that a sort does nothing */
            if (!PFord_count (p->sem.sortby.required))
                execute (assgn (var (v->name),
                                mirror (var (env_at (L(p)->env,
                                                     0).mvar->name))));

            execute (assgn (var (v->name),
                            reverse (mark (var (v->name), lit_oid (0)))));

            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                 mvar_t *a = new_var (p->refctr);

                 execute (
                      assgn (var (a->name),
                             leftjoin (
                                  var (v->name),
                                  var (env_at (L(p)->env, i).mvar->name))));
                      
                 /* we know that the first sort criterion certainly 
                    is sorted */
                 if (first_sort_var == env_at (L(p)->env,i).mvar)
                     execute (
                          assgn (var (a->name),
                                 assert_order (var (a->name))));

                  /* because leftjoin does not know that we have 
                     exactly one match for each tuple in v,
                     we need to make the heads void ourselves */
                 execute (
                     assgn (var (a->name),
                            reverse (mark (reverse (var (a->name)),
                                           lit_oid (0)))));

                 env_add (p->env,
                          env_at (L(p)->env, i).att,
                          env_at (L(p)->env, i).ty,
                          a);
            }

            unpin (v, 1);
        }
        break;

        /* Rel:      refine_sort (Rel) */
        case 34:
        {
            mvar_t  *v = new_var (1);
            bool     initialized = false;

            /*
             * Create a MonetDB grp object according to the already
             * existing order.
             */
            for (unsigned int i = 0;
                    i < PFord_count (p->sem.sortby.existing); i++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if (t & type_of (L(p),
                                     PFord_order_at (p->sem.sortby.existing,
                                                     i))) {
                        if (!initialized) {
                            execute (
                                assgn (
                                    var (v->name),
                                    VAR (L(p)->env,
                                    PFord_order_at (p->sem
                                                      .sortby
                                                      .existing, i),
                                    t)));
                            initialized = true;
                        }
                        else {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (L(p)->env,
                                             PFord_order_at (p->sem
                                                               .sortby
                                                               .existing, i),
                                             t))));
                        }
                    }
                }
            }

            /*
             * Now do the remaining sorting
             */
            for (unsigned int i = PFord_count (p->sem.sortby.existing);
                    i < PFord_count (p->sem.sortby.required); i++) {
                /*
                 * Be careful to implement document order on
                 * nodes correctly:
                 *
                 *  - sort by fragment first, then by pre/attr
                 *    (the aat_pfrag/aat_afrag bit is lower
                 *     than the aat_pre/aat_attr bit)
                 *  - document order of attributes and other nodes
                 *    requires extra effort
                 */
                assert(!((aat_anode & 
                          type_of (L(p),
                                   PFord_order_at (p->sem.sortby.required,
                                                   i))) &&
                         (aat_pnode &
                          type_of (L(p),
                                  PFord_order_at (p->sem.sortby.required,
                                                  i)))));

                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & type_of (L(p),
                                     PFord_order_at (p->sem.sortby.required,
                                                     i))) {
                         execute (
                             assgn (var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (L(p)->env,
                                             PFord_order_at (p->sem
                                                               .sortby
                                                               .required,
                                                             i),
                                             t))));
                    }
            }

            execute (
                assgn (var (v->name),
                       reverse (mark (var (v->name), lit_oid (0)))));

            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                 mvar_t *a = new_var (p->refctr);

                 execute (
                      assgn (var (a->name),
                             leftjoin (
                                  var (v->name),
                                  var (env_at (L(p)->env, i).mvar->name))),
                      /* because leftjoin does not know that we have 
                         exactly one match for each tuple in v,
                         we need to make the heads void ourselves */
                      assgn (var (a->name),
                             reverse (mark (reverse (var (a->name)),
                                            lit_oid (0))))
                      );

                 env_add (p->env,
                          env_at (L(p)->env, i).att,
                          env_at (L(p)->env, i).ty,
                          a);
            }

            unpin (v, 1);

        } break;

        /* Rel:      num_add (Rel) */
        case 40:
            bin_arith (PFmil_madd, p);
            break;

        /* Rel:      num_sub (Rel) */
        case 41:
            bin_arith (PFmil_msub, p);
            break;

        /* Rel:      num_mult (Rel) */
        case 42:
            bin_arith (PFmil_mmult, p);
            break;

        /* Rel:      num_div (Rel) */
        case 43:
            bin_arith (PFmil_mdiv, p);
            break;

        /* Rel:      num_mod (Rel) */
        case 44:
            bin_arith (PFmil_mmod, p);
            break;

        /* Rel:      num_add_atom (Rel) */
        case 45:
            bin_arith_atom (PFmil_madd, p);
            break;

        /* Rel:      num_sub_atom (Rel) */
        case 46:
            bin_arith_atom (PFmil_msub, p);
            break;

        /* Rel:      num_mult_atom (Rel) */
        case 47:
            bin_arith_atom (PFmil_mmult, p);
            break;

        /* Rel:      num_div_atom (Rel) */
        case 48:
            bin_arith_atom (PFmil_mdiv, p);
            break;

        /* Rel:      num_mod_atom (Rel) */
        case 49:
            bin_arith_atom (PFmil_mmod, p);
            break;

        /* Rel:      eq (Rel) */
        case 50:
            bin_comp (PFmil_meq, p);
            break;

        /* Rel:      eq_atom (Rel) */
        case 51:
            bin_comp_atom (PFmil_meq, p);
            break;

        /* Rel:      gt (Rel) */
        case 52:
            bin_comp (PFmil_mgt, p);
            break;

        /* Rel:      gt_atom (Rel) */
        case 53:
            bin_comp_atom (PFmil_mgt, p);
            break;

        /* Rel:      num_neg (Rel) */
        case 60:
            unary_op (PFmil_mneg, p);
            break;

        /* Rel:      bool_not (Rel) */
        case 61:
            unary_op (PFmil_mnot, p);
            break;

        /* Rel:      bool_and (Rel) */
        case 62:
            bin_bool (PFmil_mand, p);
            break;

        /* Rel:      bool_or (Rel) */
        case 63:
            bin_bool (PFmil_mor, p);
            break;

        /* Rel:      bool_and_atom (Rel) */
        case 64:
            bin_bool_atom (PFmil_mand, p);
            break;

        /* Rel:      bool_or_atom (Rel) */
        case 65:
            bin_bool_atom (PFmil_mor, p);
            break;

        /* Rel:      hash_count (Rel) */
        case 66:
            if (p->sem.count.part != att_NULL) {
                for (unsigned int i = 0; i < L(p)->schema.count; i++)
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            if (t != L(p)->schema.items[i].type)
                                PFoops (OOPS_FATAL,
                                        "HashCount not implemented for "
                                        "polymorphic groups");

                            mvar_t *v    = new_var (1);
                            mvar_t *res  = new_var (p->refctr);
                            mvar_t *part = new_var (p->refctr);

                            execute (
                                /* v := {count}(p_in.reverse ()) */
                                assgn (
                                    var (v->name),
                                    gcount (
                                        reverse (VAR (L(p)->env,
                                                      p->sem.count.part, t)))),
                                /* align with integer representation (lng) */
                                assgn (var (v->name),
                                       mcast (type (m_lng), var (v->name))),
                                /* res := v.reverse ().mark (0@0).reverse (); */
                                assgn (
                                    var (res->name),
                                    reverse (
                                        mark (
                                            reverse (var (v->name)),
                                            lit_oid (0)))),
                                /* part := v.mark (0@0).reverse (); */
                                assgn (
                                    var (part->name),
                                    reverse (
                                        mark (var (v->name), lit_oid (0)))));

                            env_add (p->env, p->sem.count.res, aat_int, res);
                            env_add (p->env, p->sem.count.part, t, part);

                            unpin (v, 1);
                        }
            }
            else {

                mvar_t *v = new_var (p->refctr);
                execute (
                    assgn (var (v->name),
                           count (var (env_at (L(p)->env, 0).mvar->name))),
                    /* align with integer representation (lng) */
                    assgn (var (v->name),
                           cast (type (m_lng), var (v->name))),
                    assgn (var (v->name),
                           append (
                               seqbase (
                                   new (type (m_void), type (m_lng)),
                                   lit_oid (0)),
                               var (v->name))));
                env_add (p->env, p->sem.count.res, aat_int, v);
            }
            break;

        /* Rel:      avg (Rel) */
        case 67:
             aggr_function(PFmil_avg, PFmil_gavg, p);
             break;

        /* Rel:      max_ (Rel) */
        case 68:
             aggr_function(PFmil_max, PFmil_gmax, p);
             break;

        /* Rel:      min_ (Rel) */
        case 69:
             aggr_function(PFmil_min, PFmil_gmin, p);
             break;

        /* Rel:      sum (Rel) */
        case 70:
             aggr_function(PFmil_sum, PFmil_gsum, p);
             break;

        /* Rel:      merge_rownum (Rel) */
        case 71:
        {
            mvar_t *v = new_var (p->refctr);

            /* copy all the attributes from our argument */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {

                pin (env_at (L(p)->env, i).mvar, p->refctr);

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }

            /* and add the newly numbered one */
            if (p->sem.rownum.part != att_NULL)
                execute (
                    assgn (var (v->name),
                           mark_grp (
                               VAR (p->env,
                                    p->sem.rownum.part,
                                    type_of (p, p->sem.rownum.part)),
                               project (
                                   kunique (
                                       reverse (
                                           VAR (p->env,
                                                p->sem.rownum.part,
                                                type_of (p, p->sem.rownum.part))
                                           )),
                                   lit_oid (1)))));
            else
                execute (
                    assgn (var (v->name),
                           mark (var (env_at (L(p)->env, 0).mvar->name),
                                 lit_oid (1))));

            env_add (p->env, p->sem.rownum.attname, aat_nat, v);

        } break;

        /* Rel:      hash_rownum (Rel) */
        case 72:
            PFoops (OOPS_FATAL,
                    "hash_rownum not implemented yet.");
            break;

        /* Rel:      number (Rel) */
        case 73:
        {
            mvar_t *res = new_var (p->refctr);

            assert (env_count (L(p)->env));

            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }

            /* and add the newly numbered one */
            if (p->sem.number.part != att_NULL)
                execute (
                    assgn (var (res->name),
                           mark_grp (
                               VAR (p->env,
                                    p->sem.number.part,
                                    type_of (p, p->sem.number.part)),
                               project (
                                   kunique (
                                       reverse (
                                           VAR (p->env,
                                                p->sem.number.part,
                                                type_of (p, p->sem.number.part))
                                           )),
                                   lit_oid (1)))));
            else
                execute (
                    assgn (var (res->name),
                           mark (var (env_at (L(p)->env, 0).mvar->name),
                                 lit_oid (1))));

            /* put the result into p's environment */
            env_add (p->env, p->sem.number.attname, aat_nat, res);
        } break;

        /* Rel:      type (Rel) */
        case 74:
        {
            mvar_t              *res = new_var (p->refctr);

            /* and put the result into p's environment */
            env_add (p->env, p->sem.type.res, aat_bln, res);

            /* everything from p's child */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }
            /* we have one simple type */
            if (p->sem.type.ty == aat_node)
                execute (
                    assgn (var (res->name),
                           mor (
                               mnot (misnil (VAR (L(p)->env,
                                             p->sem.type.att,
                                             aat_pre))),
                               mnot (misnil (VAR (L(p)->env,
                                             p->sem.type.att,
                                             aat_attr))))));
            else if (p->sem.type.ty == aat_pnode)
                execute (
                    assgn (var (res->name),
                           mnot (misnil (VAR (L(p)->env,
                                         p->sem.type.att,
                                         aat_pre)))));
            else if (p->sem.type.ty == aat_anode)
                execute (
                    assgn (var (res->name),
                           mnot (misnil (VAR (L(p)->env,
                                         p->sem.type.att,
                                         aat_attr)))));
            else
                execute (
                    assgn (var (res->name),
                           mnot (misnil (VAR (L(p)->env,
                                         p->sem.type.att,
                                         p->sem.type.ty)))));

        }
            break;

        /* Rel:      type_assert (Rel) */
        case 75:
            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Rel:      cast (Rel) */
        case 76:
            for (unsigned int i = 0; i < L(p)->schema.count; i++)
            {
                bool att_needed = true;
                mvar_t *v = NULL;
               
                /* cast as qname requires additional document access */
                if (L(p)->schema.items[i].name == p->sem.cast.att &&
                    p->sem.cast.ty == aat_qname) {

                    v = new_var (p->refctr);

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if ((t & L(p)->schema.items[i].type) &&
                            (t != aat_str && t != aat_uA && t != aat_qname))
                            PFoops (OOPS_FATAL,
                                    "cast to type QName is only possible "
                                    "for type QName and type string.%i", t);

                    bool   qn = false;

                    /* nothing to do - just assign it to a new variable */
                    if (L(p)->schema.items[i].type & aat_qname)
                    {
                        execute (assgn (var (v->name), 
                                        VAR (L(p)->env, p->sem.cast.att,
                                             L(p)->schema.items[i].type)));
                        qn = true;
                    }

                    if (L(p)->schema.items[i].type & aat_str
                         || L(p)->schema.items[i].type & aat_uA)
                    {
                        PFmil_t *str = NULL;
                        mvar_t  *offset  = new_var (1);
                        mvar_t  *prefix  = new_var (1);
                        mvar_t  *local   = new_var (1);
                        mvar_t  *err_str = new_var (1);
                        PFmil_t *v_cast  = 
                                     VAR (L(p)->env, p->sem.cast.att,
                                          L(p)->schema.items[i].type);

                        /* split up strings using ``:'' as delimiter */
                        /* FIXME: currently we we don't retrieve the URI */
                        execute (
                            assgn (var (err_str->name),
                                   check_qnames (v_cast)),
                            if_ (not (isnil (var (err_str->name))),
                                 error (arg (lit_str ("err:FORG0001. "
                                                      "illegal QName '%s'."),
                                             var (err_str->name))),
                                 nop ()),
                            assgn (var (offset->name),
                                   msearch (v_cast, lit_str (":"))),
                            assgn (var (prefix->name),
                                   mstring2 (v_cast,
                                             lit_int (0),
                                             var (offset->name))),
                            assgn (var (local->name),
                                   mstring (v_cast,
                                            madd (lit_int (1),
                                                  var (offset->name)))));

                        /* add_qnames changes the working set 
                           in 'var (PF_MIL_VAR_WS)' as side effect */
                        str = add_qnames (
                                  var (prefix->name),
                                  project (var (prefix->name),
                                           lit_str ("")),
                                  var (local->name),
                                  var (PF_MIL_VAR_WS));

                        if (qn) /* combine both qname tables */
                            execute (assgn (var (v->name),
                                            mifthenelse (
                                                misnil (var (v->name)),
                                                str,
                                                var (v->name))));
                        else
                            execute (assgn (var (v->name), str));

                        unpin (offset, 1);
                        unpin (prefix, 1);
                        unpin (local, 1);
                        unpin (err_str, 1);
                    }
                }
                else if (L(p)->schema.items[i].name == p->sem.cast.att) {

                    unsigned int   parts = 0;
                    mvar_t        *bln_tmp = NULL;
                    v = new_var (p->refctr);

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            PFmil_t *casted = NULL;

                            if (t == p->sem.cast.ty)
                                casted = VAR (L(p)->env, p->sem.cast.att, t);
                            
                            else if ((t == aat_str || t == aat_uA) &&
                                     p->sem.cast.ty == aat_bln) {
                                /* The cast from string or untypedAtomic
                                   to boolean is only allowed for a few
                                   values. Here the values are checked and
                                   the respective result is returned. */
                                mvar_t *true_values;
                                mvar_t *false_values = new_var (1);

                                bln_tmp = new_var (1);
                                true_values = bln_tmp;

                                /* collect all strings that map to 'true' */
                                execute (assgn (var (true_values->name),
                                                meq (VAR (L(p)->env, 
                                                          p->sem.cast.att,
                                                          t),
                                                     lit_str("true"))),
                                         assgn (var (true_values->name),
                                                mor (var (true_values->name),
                                                     meq (VAR (L(p)->env, 
                                                               p->sem.cast.att,
                                                               t),
                                                          lit_str("1")))),
                                /* collect all strings that map to 'false' */
                                         assgn (var (false_values->name),
                                                meq (VAR (L(p)->env, 
                                                          p->sem.cast.att,
                                                          t),
                                                     lit_str("false"))),
                                         assgn (var (false_values->name),
                                                mor (var (false_values->name),
                                                     meq (VAR (L(p)->env, 
                                                               p->sem.cast.att,
                                                               t),
                                                          lit_str("0")))),
                                /* generate an error message for all other 
                                   strings */
                                         if_ (
                                             exist (
                                                 reverse (
                                                     mor (
                                                         var (
                                                             true_values->name),
                                                         var (
                                                             false_values->name)
                                                         )),
                                                 lit_bit (false)),
                                             
                                             error (
                                                 t == aat_uA
                                                 ? lit_str ("err:FORG0001. "
                                                            "casting from "
                                                            "untypedAtomic "
                                                            "to boolean "
                                                            "failed.")
                                                 : lit_str ("err:FORG0001. "
                                                            "casting from "
                                                            "string to "
                                                            "boolean failed.")
                                                 ),
                                             nop ()));
                                
                                casted = var (true_values->name);
                                /* note: casted == bln_tmp */
                                unpin (false_values, 1);
                            }
                            else
                                casted
                                    = mcast (
                                        implty (p->sem.cast.ty),
                                        VAR (L(p)->env, p->sem.cast.att, t));

                            if (parts)
                                execute (assgn (var (v->name),
                                                mifthenelse (
                                                    misnil (var (v->name)),
                                                    casted,
                                                    var (v->name))));
                            else
                                execute (assgn (var (v->name), casted));

                            parts++;

                            /* Unpin the temporary variable 
                               bln_tmp if it has been pinned. */
                            if (bln_tmp)
                                unpin (bln_tmp, 1);
                        }
                    execute (
                        if_ (exist (reverse (var (v->name)),
                                    cast (implty (p->sem.cast.ty), nil ())),
                             error (lit_str ("err:FORG0001.")),
                             nop ()));
                }

                if (L(p)->schema.items[i].name == p->sem.cast.att &&
                    p->sem.cast.att != p->sem.cast.res)
                    env_add (p->env, p->sem.cast.res, p->sem.cast.ty, v);
                else if (L(p)->schema.items[i].name == p->sem.cast.att)
                {
                    att_needed = false;
                    env_add (p->env, p->sem.cast.att, p->sem.cast.ty, v);
                }

                if (att_needed) {
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            mvar_t *v = env_mvar (L(p)->env,
                                                  L(p)->schema.items[i].name,
                                                  t);

                            env_add (p->env, L(p)->schema.items[i].name, t, v);
                            pin (v, p->refctr);
                        }
                }
            } break;

        /* Rel:      llscj_anc (FragList, Rel) */
        case 80:
            llscj (ax_anc, p);
            break;

        /* Rel:      llscj_anc_self (FragList, Rel) */
        case 81:
            llscj (ax_anc_self, p);
            break;

        /* Rel:      llscj_attr (FragList, Rel) */
        case 82:
        {
            /* abbreviations for input expressions */
            PFty_t           ty  = p->sem.scjoin.ty;

            /* MIL equivalents of input expression */
            PFmil_t *iter;
            PFmil_t *pre;
            PFmil_t *frag;

            mvar_t  *tmp;      /* helper variable */
            mvar_t  *ret_iter; /* var to which we assign the `iter' result */
            mvar_t  *ret_attr; /* var to which we assign the `pre' result */
            mvar_t  *ret_frag; /* var to which we assign the `kind' result */
            
            /*
             * Determine generic input arguments.
             */
            assert (p); assert (R(p)); assert (R(p)->env);
            iter = VAR (R(p)->env, p->sem.scjoin.iter, aat_nat);
            pre = VAR (R(p)->env, p->sem.scjoin.item, aat_pre);
            frag = VAR (R(p)->env, p->sem.scjoin.item, aat_pfrag);
            assert (iter); assert (pre); assert (frag);

            tmp      = new_var (1);
            ret_iter = new_var (p->refctr);
            ret_attr  = new_var (p->refctr);
            ret_frag = new_var (p->refctr);

            /* first get all attribute nodes... */
            execute (
                assgn (var (tmp->name), 
                       mvaljoin (pre, frag, fetch (var (PF_MIL_VAR_WS),
                                                   var (PF_MIL_VAR_ATTR_OWN)))),
                assgn (var (ret_attr->name),
                       reverse (mark (reverse (var (tmp->name)), lit_oid (0)))),
                assgn (var (ret_frag->name),
                       leftjoin (reverse (mark (var (tmp->name), lit_oid (0))),
                                 frag)),
                assgn (var (ret_iter->name),
                       leftjoin (reverse (mark (var (tmp->name), lit_oid (0))),
                                 iter)));

            /* ... then filter out all nodes, whose name test does not match */
            if (PFty_subtype (ty, PFty_xs_anyAttribute ())) {

                /* Is it just a generic attribute kind test?
                   (e.g. .../attribute()) */
                if (PFty_subtype (PFty_xs_anyAttribute (), ty))
                    ;

                /* Is it a test on attribute kind and local name only? */
                else if (PFty_subtype (
                            PFty_attr (
                                PFqname (PFns_wild,
                                         PFty_name (PFty_defn (ty)).loc),
                                PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (
                                   mposjoin (
                                       var (ret_attr->name),
                                       var (ret_frag->name),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_ATTR_QN))),
                                   mposjoin (
                                       var (ret_attr->name),
                                       var (ret_frag->name),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_ATTR_CONT))),
                               fetch (var (PF_MIL_VAR_WS),
                                      var (PF_MIL_VAR_QN_LOC)))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_loc (
                                                PFty_name (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name),
                                         var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name),
                                         var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name),
                                         var (ret_iter->name))));

                /* Or maybe a test on attribute kind and namespace only? */
                else if (PFty_subtype (
                            PFty_attr (PFqname (PFty_name (PFty_defn (ty)).ns,
                                                NULL),
                                       PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (
                                   mposjoin (var (ret_attr->name),
                                             var (ret_frag->name),
                                             fetch (var (PF_MIL_VAR_WS),
                                                    var (PF_MIL_VAR_ATTR_QN))),
                                   mposjoin (
                                       var (ret_attr->name),
                                       var (ret_frag->name),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_ATTR_CONT))),
                                   fetch (var (PF_MIL_VAR_WS), 
                                          var (PF_MIL_VAR_QN_URI)))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_uri (
                                                PFty_name (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name),
                                         var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name),
                                         var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name),
                                         var (ret_iter->name))));

                /* A test on attribute kind and full QName? */
                else if (PFty_subtype (
                            PFty_attr (PFty_name (PFty_defn (ty)),
                                       PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (
                                  mposjoin (var (ret_attr->name),
                                            var (ret_frag->name),
                                            fetch (var (PF_MIL_VAR_WS),
                                                   var (PF_MIL_VAR_ATTR_QN))),
                                  mposjoin (var (ret_attr->name),
                                            var (ret_frag->name),
                                            fetch (var (PF_MIL_VAR_WS),
                                                   var (PF_MIL_VAR_ATTR_CONT))),
                                  fetch (var (PF_MIL_VAR_WS),
                                         var (PF_MIL_VAR_QN_LOC)))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_loc (
                                                PFty_name (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name), 
                                         var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name),
                                         var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name),
                                         var (ret_iter->name))),
                        assgn (var (tmp->name),
                               mposjoin (
                                   mposjoin (var (ret_attr->name),
                                             var (ret_frag->name),
                                             fetch (var (PF_MIL_VAR_WS),
                                                    var (PF_MIL_VAR_ATTR_QN))),
                                   mposjoin (
                                       var (ret_attr->name),
                                       var (ret_frag->name),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_ATTR_CONT))),
                                   fetch (var (PF_MIL_VAR_WS),
                                          var (PF_MIL_VAR_QN_URI)))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_uri (
                                                PFty_name (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name), 
                                         var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name),
                                         var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name),
                                         var (ret_iter->name))));

                /*
                 * If we couldn't figure out what attribute test we got,
                 * give up.
                 *
                 * NOTE: The surface language actually allows such tests. We
                 *       just cannot implement them (yet):
                 *
                 *        doc("foo")/attribute::attribute(shoeSize, xs:integer)
                 */
                else
                    PFoops (OOPS_FATAL,
                            "Problem with an XPath step: cannot evaluate "
                            "node test `%s'", PFty_str (ty));
            }
            else
                PFoops (OOPS_FATAL,
                        "Problem with an XPath step: cannot evaluate "
                        "node test `%s'", PFty_str (ty));

            /* because leftjoin does not know that we have 
               exactly one match for each tuple in v,
               we need to make the heads void ourselves */
            execute (
                assgn (var (ret_attr->name),
                       reverse (mark (reverse (var (ret_attr->name)),
                                      lit_oid (0)))),
                assgn (var (ret_frag->name),
                       reverse (mark (reverse (var (ret_frag->name)),
                                      lit_oid (0)))),
                assgn (var (ret_iter->name),
                       reverse (mark (reverse (var (ret_iter->name)),
                                      lit_oid (0)))));


            env_add (p->env, p->sem.scjoin.iter, aat_nat, ret_iter);

            env_add (p->env, p->sem.scjoin.item, aat_attr, ret_attr);
            env_add (p->env, p->sem.scjoin.item, aat_afrag, ret_frag);

            unpin (tmp, 1);
        }
            break;

        /* Rel:      llscj_child (FragList, Rel) */
        case 83:
            llscj (ax_child, p);
            break;

        /* Rel:      llscj_desc (FragList, Rel) */
        case 84:
            llscj (ax_desc, p);
            break;

        /* Rel:      llscj_desc_self (FragList, Rel) */
        case 85:
            llscj (ax_desc_self, p);
            break;

        /* Rel:      llscj_foll (FragList, Rel) */
        case 86:
            llscj (ax_foll, p);
            break;

        /* Rel:      llscj_foll_sibl (FragList, Rel) */
        case 87:
            llscj (ax_foll_sibl, p);
            break;

        /* Rel:      llscj_parent (FragList, Rel) */
        case 88:
            llscj (ax_parent, p);
            break;

        /* Rel:      llscj_prec (FragList, Rel) */
        case 89:
            llscj (ax_prec, p);
            break;

        /* Rel:      llscj_prec_sibl (FragList, Rel) */
        case 90:
            llscj (ax_prec_sibl, p);
            break;

        /* FragRel:  doc_tbl (Rel) */
        case 100:
        {
            mvar_t *time;
            
            /* copy the iter BAT */
            mvar_t *iter = env_mvar (L(p)->env, p->sem.ii.iter, aat_nat);

            env_add (p->env, p->sem.ii.iter, aat_nat, iter);
            pin (iter, p->refctr);

            /* add timing information */
            time = new_var (1);
            execute (assgn (var (time->name), usec ()));
            
            /* temporary variable */
            mvar_t *v = new_var (1);
            /* result BATs */
            mvar_t *frag = new_var (p->refctr);
            mvar_t *pre  = new_var (p->refctr);

            env_add (p->env, p->sem.ii.item, aat_pre, pre);
            env_add (p->env, p->sem.ii.item, aat_pfrag, frag);

            execute (
                 assgn (var (v->name),
                        doc_tbl (var (PF_MIL_VAR_WS),
                                 VAR (L(p)->env, p->sem.ii.item, aat_str))),
                 assgn (var (PF_MIL_VAR_WS), 
                        fetch (var (v->name), lit_int (0))),
                 assgn (var (pre->name), fetch (var (v->name), lit_int (1))),
                 assgn (var (frag->name), fetch (var (v->name), lit_int (2)))
                 );

            unpin (v, 1);
            
            /* add timing information */
            execute (
                assgn (var (PF_MIL_VAR_TIME_LOAD),
                       add (var (PF_MIL_VAR_TIME_LOAD),
                            sub (usec (),
                                 var (time->name)))));
            unpin (time, 1);

        } break;

        /* Rel:      doc_access (FragList, Rel) */
        case 101:
        {
            mvar_t *str   = new_var (p->refctr);

            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                pin (env_at (R(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (R(p)->env, i).att,
                         env_at (R(p)->env, i).ty,
                         env_at (R(p)->env, i).mvar);
            }

            /* lookup the values in the documents using mposjoin */
            switch (p->sem.doc_access.doc_col)
            {
                case (doc_atext):
                    {
                        PFmil_t *attr  = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_attr);
                        PFmil_t *afrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_afrag);

                        execute (
                            assgn (var (str->name),
                                   mposjoin (
                                       mposjoin (
                                           attr,
                                           afrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_ATTR_PROP))),
                                       mposjoin (
                                           attr,
                                           afrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_ATTR_CONT))),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_PROP_VAL)))));
                    }
                    break;
                case (doc_text):
                    {
                        PFmil_t *pre  = VAR (R(p)->env,
                                             p->sem.doc_access.att,
                                             aat_pre);
                        PFmil_t *pfrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_pfrag);
                        execute (
                            assgn (var (str->name),
                                   mposjoin (
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_PROP))),
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_CONT))),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_PROP_TEXT)))));
                    }
                    break;
                case (doc_comm):
                    {
                        PFmil_t *pre  = VAR (R(p)->env,
                                             p->sem.doc_access.att,
                                             aat_pre);
                        PFmil_t *pfrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_pfrag);
                        execute (
                            assgn (var (str->name),
                                   mposjoin (
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_PROP))),
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_CONT))),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_PROP_COM)))));
                    }
                    break;
                case (doc_pi_text):
                    {
                        PFmil_t *pre  = VAR (R(p)->env,
                                             p->sem.doc_access.att,
                                             aat_pre);
                        PFmil_t *pfrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_pfrag);
                        execute (
                            assgn (var (str->name),
                                   mposjoin (
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_PROP))),
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_CONT))),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_PROP_INS)))));
                    }
                    break;
                default:
                    PFoops (OOPS_FATAL, 
                            "unexpected document column in doc_access (%i)",
                            p->sem.doc_access.doc_col);
            }

            env_add (p->env, p->sem.doc_access.res, aat_str, str);
        }
            break;

        /* FragRel: element (FragList, element_tag (Rel, empty_lit_tbl)) */
        case 102:
        /* FragRel: element (FragList, 
                             element_tag (Rel, rec_border (empty_tbl))) */
        case 103:
        {
            /* copy the iter BAT */

             mvar_t *iter = env_mvar (L(R(p))->env, p->sem.ii.iter, aat_nat);
             env_add (p->env, p->sem.ii.iter, aat_nat, iter);
             pin (iter, p->refctr);


             /* temporary variable */
             mvar_t *v = new_var (1);
             /* result BATs */
             mvar_t *pre  = new_var (p->refctr);
             mvar_t *frag = new_var (p->refctr);
             env_add (p->env, p->sem.ii.item, aat_pre, pre);
             env_add (p->env, p->sem.ii.item, aat_pfrag, frag);

             execute (
                  assgn (var (v->name),
                         empty_element (VAR (L(R(p))->env, 
                                             p->sem.ii.item, aat_qname),
                                        var (PF_MIL_VAR_WS))),
                  assgn (var (PF_MIL_VAR_WS),
                         fetch (var (v->name), lit_int (0))),
                  assgn (var (pre->name), fetch (var (v->name), 
                                                 lit_int (1))),
                  assgn (var (frag->name), fetch (var (v->name),
                                                  lit_int (2)))
                  );

            unpin (v, 1);
        } break;

        /* FragRel: element (FragList, element_tag (Rel, Rel)) */
        case 104:
        {
            /* copy the iter BAT */
            mvar_t *iter = env_mvar (L(R(p))->env, p->sem.ii.iter, aat_nat);
            env_add (p->env, p->sem.ii.iter, aat_nat, iter);
            pin (iter, p->refctr);
            PFmil_t *pre, *pfrag, *attr, *afrag;
            mvar_t *tmp;

            /* temporary variable */
            mvar_t *v = new_var (1);
            /* result BATs */
            mvar_t *res_pre = new_var (p->refctr);
            mvar_t *res_frag = new_var (p->refctr);

            env_add (p->env, p->sem.ii.item, aat_pre, res_pre);
            env_add (p->env, p->sem.ii.item, aat_pfrag, res_frag);

            /* check occurrence of attributes and other nodes
               and react accordingly */ 
            if ((tmp = env_mvar_unsafe (R(R(p))->env,
                                        p->sem.ii.item,
                                        aat_pre)))
            {
                 pre = var (tmp->name);
                 pfrag = VAR (R(R(p))->env, p->sem.ii.item, aat_pfrag);
            } else {
                 pre = seqbase (new (type (m_void), type (m_oid)),
                                lit_oid (0));
                 pfrag = pre;
            }
               
            if ((tmp = env_mvar_unsafe (R(R(p))->env,
                                        p->sem.ii.item,
                                        aat_attr)))
            {
                 attr = var (tmp->name);
                 afrag = VAR (R(R(p))->env, p->sem.ii.item, aat_afrag);
            } else {
                 attr = seqbase (new (type (m_void), type (m_oid)),
                                 lit_oid (0));
                 afrag = attr;
            }

            execute (
                 assgn (var (v->name),
                        element (VAR (L(R(p))->env, p->sem.ii.iter, aat_nat),
                                 VAR (L(R(p))->env, p->sem.ii.item, aat_qname),
                                 VAR (R(R(p))->env, p->sem.ii.iter, aat_nat),
                                 pre, pfrag, attr, afrag,
                                 var (PF_MIL_VAR_WS))),
                 assgn (var (PF_MIL_VAR_WS),
                        fetch (var (v->name), lit_int (0))),
                 assgn (var (res_pre->name), 
                        fetch (var (v->name), lit_int (1))),
                 assgn (var (res_frag->name),
                        fetch (var (v->name), lit_int (2)))
                 );

            unpin (v, 1);
        } break;

        /* FragRel: attribute (Rel) */
        case 105:
        {
            /* temporary variable */
            mvar_t *v = new_var (1);
            /* result BATs */
            mvar_t *attr  = new_var (p->refctr);
            mvar_t *frag = new_var (p->refctr);

            env_add (p->env, p->sem.attr.res, aat_attr, attr);
            env_add (p->env, p->sem.attr.res, aat_afrag, frag);

            execute (
                assgn (var (v->name),
                       attribute (VAR (L(p)->env, p->sem.attr.qn, aat_qname),
                                  VAR (L(p)->env, p->sem.attr.val, aat_str),
                                  var (PF_MIL_VAR_WS))),
                assgn (var (PF_MIL_VAR_WS), fetch (var (v->name), lit_int (0))),
                assgn (var (attr->name), fetch (var (v->name), lit_int (1))),
                assgn (var (frag->name), fetch (var (v->name), lit_int (2)))
                );

            unpin (v, 1);

            /* copy all the existing variables of the qname relation */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }
        } break;

        /* FragRel: textnode (Rel) */
        case 106:
        {
            /* temporary variable */
            mvar_t *v = new_var (1);
            /* result BATs */
            mvar_t *pre  = new_var (p->refctr);
            mvar_t *frag = new_var (p->refctr);

            env_add (p->env, p->sem.textnode.res, aat_pre, pre);
            env_add (p->env, p->sem.textnode.res, aat_pfrag, frag);

            execute (
                assgn (var (v->name),
                       textnode (VAR (L(p)->env, p->sem.textnode.item, aat_str),
                                 var (PF_MIL_VAR_WS))),
                assgn (var (PF_MIL_VAR_WS), fetch (var (v->name), lit_int (0))),
                assgn (var (pre->name), fetch (var (v->name), lit_int (1))),
                assgn (var (frag->name), fetch (var (v->name), lit_int (2)))
                );
            unpin (v, 1);

            /* copy all the existing variables */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }
        } break;

        /* Rel:      docnode (FragList, Rel) */
        case 107:
            PFoops (OOPS_FATAL,
                    "docnode not implemented yet.");
            break;

        /* Rel:      comment (Rel) */
        case 108:
            PFoops (OOPS_FATAL,
                    "comment not implemented yet.");
            break;

        /* Rel:      processi (Rel) */
        case 109:
            PFoops (OOPS_FATAL,
                    "processing-instruction not implemented yet.");
            break;

        /* Rel:      merge_adjacent (FragList, Rel) */
        case 110:
        {
            PFmil_t *iter = NULL, *pre = NULL, *pfrag = NULL;

            /* copy all the existing variables */
            for (unsigned int i = 0; i < PFarray_last (R(p)->env); i++) {
                env_t entry = env_at (R(p)->env, i);

                if (entry.att == p->sem.ii.iter && entry.ty == aat_nat) {
                    iter = var (entry.mvar->name);
                    env_add (p->env, entry.att, entry.ty, entry.mvar);
                    pin (entry.mvar, p->refctr);
                }
                else if (entry.att == p->sem.ii.item && entry.ty == aat_pre)
                    pre = var (entry.mvar->name);
                else if (entry.att == p->sem.ii.item &&
                         entry.ty == aat_pfrag)
                    pfrag = var (entry.mvar->name);
                else {
                    env_add (p->env, entry.att, entry.ty, entry.mvar);
                    pin (entry.mvar, p->refctr);
                }
            }
            assert (iter && pre && pfrag);

            mvar_t *v  = new_var (1);
            mvar_t *res_pre = new_var (p->refctr);
            mvar_t *res_frag = new_var (p->refctr);

            execute (
                assgn (var (v->name),
                       merge_adjacent (iter, pre, pfrag, var (PF_MIL_VAR_WS))),
                assgn (var (PF_MIL_VAR_WS), 
                       fetch (var (v->name), lit_oid (0))),
                assgn (var (res_pre->name), 
                       fetch (var (v->name), lit_oid (1))),
                assgn (var (res_frag->name), 
                       fetch (var (v->name), lit_oid (2))));

            unpin (v, 1);
            env_add (p->env, p->sem.ii.item, aat_pre, res_pre);
            env_add (p->env, p->sem.ii.item, aat_pfrag, res_frag);

        } break;

        /* Rel:      roots (FragRel) */
        case 120:
            /* copy all the attributes from our argument */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {

                pin (env_at (L(p)->env, i).mvar, p->refctr);

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Frag:     fragment (FragRel) */
        case 121:
            break;

        /* FragList: frag_union (FragList, Frag) */
        case 122:
            break;

        /* FragList: empty_frag */
        case 123:
            break;

        /* Rel:      cond_err (Rel, Rel) */
        case 130:
            execute (
                if_ (exist (reverse (VAR (R(p)->env, p->sem.err.att, aat_bln)),
                            lit_bit (false)),
                     error (lit_str (p->sem.err.str)),
                     nop ()));
                       
            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Rel:      rec_fix (Rec, Rel) */
        case 131:
        {
            PFmil_t *oldmilprog, *bodymilprog;
            PFarray_t *res_env;
            mvar_t *old_count, *new_count;
            PFarray_t *border_vars = PFarray (sizeof (mvar_t *));
            
            /* Generate code for the seeds and bind them to the new variables.
               In addition generate code for all expressions that are 
               invariant to the recursion body (all expressions underneath
               a rec_border operator) and pin the variables holding the 
               results once more such they are not released in the recursion
               body (references stored in border_vars). */
            reduce1(kids[0], nts[0], border_vars);
           
            old_count = new_var (1);
            new_count = new_var (1);

            /* initialize the result counters */
            execute (
                assgn (var (old_count->name), 
                       lit_int (-1)),
                assgn (var (new_count->name), 
                       lit_int (0)));
                       
            /* save the current mil program */
            oldmilprog = milprog;
           
            /* create a new empty milprog */
            milprog = nop ();
           
            /* translate the recursion body and 
               reassign the recursion variables */
            reduce2(kids[0], nts[0]);
           
            /* get the result environment */
            reduce(kids[1], nts[1]);
            res_env = R(p)->env;

            /* update the result counters */
            execute (
                assgn (var (old_count->name), 
                       var (new_count->name)),
                assgn (var (new_count->name),
                       count (var (env_at (res_env, 0).mvar->name))));

            /* make the old mil program the active one */
            bodymilprog = milprog;
            milprog = oldmilprog;
           
            /* apply the while statement */
            execute (
                while_ (
                  gt (var (new_count->name),
                      var (old_count->name)),
                  bodymilprog));

            /* the condition variables are not needed anymore */
            unpin (new_count, 1);
            unpin (old_count, 1);
            
            /* copy all the result attributes */
            for (unsigned int i = 0; i < env_count (res_env); i++) {
                pin (env_at (res_env, i).mvar,
                     p->refctr);
                
                env_add (p->env,
                         env_at (res_env, i).att,
                         env_at (res_env, i).ty,
                         env_at (res_env, i).mvar);
            }
            
            /* release the additional pins of the variables
               representing the recursion invariant expressions */
            for (unsigned int i = 0; i < PFarray_last (border_vars); i++)
                unpin (*(mvar_t **) PFarray_at (border_vars, i), 1);
            
            /* release all the pins of the while loop arguments */
            reduce3(kids[0], nts[0]);

            /* ensure that the child of p (the first argument) still
               has one pin left to release (see bottom of function reduce) */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++)
                pin (env_at (L(p)->env, i).mvar, 1);
        } break;

        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 132:
        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 133:
        /* Rec:      rec_nil */
        case 134:
            /* the rules are called via reduce1, reduce2, and reduce3 */
            break;

        /* Rel:      rec_base */
        case 135:
            /* no MIL code needed */

            /* The environment already contains the bindings.
               See rules:
                  rec_param (rec_arg (Rel, Rel), Rec)
                and
                  rec_param (rec_arg (empty_tbl, Rel), Rec))
                in function reduce1 */
            break;

        /* Rel:      rec_border (Rel) */
        case 136:
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Rel:      concat (Rel) */
        case 140:
            bin_arith (PFmil_madd, p);
            break;

        /* Rel:      contains (Rel) */
        case 141:
        {
            mvar_t              *res = new_var (p->refctr);

            /* do the containment checks:
               [search](strings,search_strs).[!=](-1).[oid]() */
            execute (
                assgn (var (res->name),
                              mnot (meq (msearch (
                                             VAR (L(p)->env,
                                                  p->sem.binary.att1,
                                                  aat_str),
                                             VAR (L(p)->env,
                                                  p->sem.binary.att2,
                                                  aat_str)),
                                         lit_int (-1)))));

            /* and put the result into p's environment */
            env_add (p->env, p->sem.binary.res, aat_bln, res);

            /* everything from p's child */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }
        } break;

        /* Rel:      string_join (Rel, Rel) */
        case 142:
        {
            mvar_t *str  = new_var (1);
            mvar_t *iter = new_var (p->refctr);
            mvar_t *item = new_var (p->refctr);

            execute (
                assgn (var (str->name),
                       string_join (
                           leftjoin (
                               reverse (VAR(L(p)->env,
                                            p->sem.ii.iter,
                                            aat_nat)),
                               VAR(L(p)->env, p->sem.ii.item, aat_str)),
                           leftjoin (
                               reverse (VAR(R(p)->env,
                                            p->sem.ii.iter,
                                            aat_nat)),
                               VAR(R(p)->env, p->sem.ii.item, aat_str)))),
                assgn (var (iter->name), 
                       reverse (mark (var (str->name), lit_oid (0)))),
                assgn (var (item->name), 
                       reverse (
                           mark (reverse (var (str->name)), lit_oid (0)))));

            unpin (str, 1);
            env_add (p->env, p->sem.ii.iter, aat_nat, iter);
            env_add (p->env, p->sem.ii.item, aat_str, item);
        }
            break;

        default:
            PFoops (OOPS_FATAL, "unknown rule %u", rule);
            break;
    }

    for (unsigned short c = 0; nts[c]; c++)
        for (unsigned int i = 0; i < PFarray_last (kids[c]->env); i++)
            unpin (((env_t *) PFarray_at (kids[c]->env, i))->mvar, 1);

#ifndef NDEBUG
    execute (comment ("End rule: \"%s\"", PFmilgen_string[rule]));

    for (unsigned int i = 0; i < PFarray_last (p->env); i++)
        assert (((env_t *) PFarray_at (p->env, i))->mvar->pins);
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

}

static PFalg_simple_type_t
type_of (PFpa_op_t *n, PFalg_att_t att)
{
    assert (n);

    for (unsigned int i = 0; i < n->schema.count; i++)
        if (n->schema.items[i].name == att)
            return n->schema.items[i].type;

    PFoops (OOPS_FATAL,
            "cannot determine implementation type of algebra expression");

    assert (0); /* never reached due to "exit" in "PFoops" */
    return aat_nat; /* pacify picky compilers */
}


/**
 * Compile a physical algebra literal value into its MIL equivalent.
 */
static PFmil_t *
literal (PFalg_atom_t atom)
{
    if (atom.special == amm_min)
        switch (atom.type) {
            case aat_int:  return lit_min (m_lng);
            case aat_uA:
            case aat_str:  return lit_min (m_str);
            case aat_dec:  return lit_min (m_dbl);
            case aat_dbl:  return lit_min (m_dbl);
            case aat_bln:  return lit_min (m_bit);
            default:
                break;
        }
    else if (atom.special == amm_max)
        switch (atom.type) {
            case aat_int:  return lit_max (m_lng);
            case aat_uA:
            case aat_str:  return lit_max (m_str);
            case aat_dec:  return lit_max (m_dbl);
            case aat_dbl:  return lit_max (m_dbl);
            case aat_bln:  return lit_max (m_bit);
            default:
                break;
        }
    else
        switch (atom.type) {

            case aat_nat:  return lit_oid (atom.val.nat_);
            case aat_int:  return lit_lng (atom.val.int_);
            case aat_uA:
            case aat_str:  return lit_str (atom.val.str);
            case aat_dec:  return lit_dbl (atom.val.dec_);
            case aat_dbl:  return lit_dbl (atom.val.dbl);
            case aat_bln:  return lit_bit (atom.val.bln);
            case aat_qname:  
                return add_qname (lit_str (PFqname_ns (atom.val.qname)),
                                  lit_str (PFqname_uri (atom.val.qname)),
                                  lit_str (PFqname_loc (atom.val.qname)),
                                  var (PF_MIL_VAR_WS));
            default:
                break;
        }

    PFoops (OOPS_FATAL,
            "A relational algebra type (%u) has not yet "
            "been implemented.", atom.type);

    assert (0); /* never reached due to "exit" in "PFoops" */
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `node()' */
static PFmil_t *
llscj_node (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_node()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `element()' */
static PFmil_t *
llscj_elem (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_elem (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_elem (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_elem (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_elem (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_elem (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_elem (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_elem (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_elem()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `text()' */
static PFmil_t *
llscj_text (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_text (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_text (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_text (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_text (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_text (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_text (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_text (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_text (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_text (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_text (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_text()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `comment()' */
static PFmil_t *
llscj_comm (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_comm (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_comm (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_comm (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_comm (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_comm (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_comm (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_comm (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_comm (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_comm (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_comm (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_comm()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `processing-instr()' */
static PFmil_t *
llscj_pi (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_pi (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_pi (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_pi (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_pi (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_pi (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_pi (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_pi (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_pi (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_pi (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_pi (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_pi()");
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test for some local name, but a wildcard namespace
 */
static PFmil_t *
llscj_elem_loc (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                const PFmil_t *loc)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_anc_self:
            return llscj_anc_self_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_child:
            return llscj_child_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_desc:
            return llscj_desc_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_desc_self:
            return llscj_desc_self_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_foll:
            return llscj_foll_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_parent:
            return llscj_parent_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_prec:
            return llscj_prec_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_loc (iter, item, frag, ws, ord, loc);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test for some namespace, but a wildcard local name
 */
static PFmil_t *
llscj_elem_ns (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
               const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
               const PFmil_t *ns)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_anc_self:
            return llscj_anc_self_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_child:
            return llscj_child_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_desc:
            return llscj_desc_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_desc_self:
            return llscj_desc_self_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_foll:
            return llscj_foll_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_parent:
            return llscj_parent_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_prec:
            return llscj_prec_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_ns (iter, item, frag, ws, ord, ns);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test with a fully qualified QName
 */
static PFmil_t *
llscj_elem_nsloc (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                  const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                  const PFmil_t *ns, const PFmil_t *loc)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_anc_self:
            return llscj_anc_self_elem_nsloc (iter, item, frag, ws, ord, ns,
                                              loc);
        case ax_child:
            return llscj_child_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_desc:
            return llscj_desc_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_desc_self:
            return llscj_desc_self_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
        case ax_foll:
            return llscj_foll_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
        case ax_parent:
            return llscj_parent_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_prec:
            return llscj_prec_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is a
 * processing-instruction test with a given target
 */
static PFmil_t *
llscj_pi_targ (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                  const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                  const PFmil_t *target)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_pi_targ (iter, item, frag, ws, ord, target);
        case ax_anc_self:
            return llscj_anc_self_pi_targ (iter, item, frag, ws, ord, target);
        case ax_child:
            return llscj_child_pi_targ (iter, item, frag, ws, ord, target);
        case ax_desc:
            return llscj_desc_pi_targ (iter, item, frag, ws, ord, target);
        case ax_desc_self:
            return llscj_desc_self_pi_targ (iter, item, frag, ws, ord, target);
        case ax_foll:
            return llscj_foll_pi_targ (iter, item, frag, ws, ord, target);
        case ax_foll_sibl:
            return llscj_foll_sibl_pi_targ (iter, item, frag, ws, ord, target);
        case ax_parent:
            return llscj_parent_pi_targ (iter, item, frag, ws, ord, target);
        case ax_prec:
            return llscj_prec_pi_targ (iter, item, frag, ws, ord, target);
        case ax_prec_sibl:
            return llscj_prec_sibl_pi_targ (iter, item, frag, ws, ord, target);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * Translate loop-lifted staircase joins.
 */
static void
llscj (enum axis_t axis, const PFpa_op_t *p)
{
    /* abbreviations for input expressions */
    PFty_t           ty  = p->sem.scjoin.ty;
    PFord_ordering_t in  = p->sem.scjoin.in;
    PFord_ordering_t out = p->sem.scjoin.out;

    /* MIL equivalents of input expression */
    PFmil_t *iter;
    PFmil_t *item;
    PFmil_t *frag;

    int      o;           /* helper to compute order specifier */
    PFmil_t *order;       /* order specifier for llscj MIL functions */
    PFmil_t *scj = NULL;  /* MIL expression that evaluates llscj */

    mvar_t  *tmp;         /* helper variable */
    mvar_t  *ret_iter;    /* variable to which we assign the `iter' result */
    mvar_t  *ret_pre;     /* variable to which we assign the `pre' result */
    mvar_t  *ret_frag;    /* variable to which we assign the `kind' result */
    
    PFalg_att_t pa_iter = p->sem.scjoin.iter; 
    PFalg_att_t pa_item = p->sem.scjoin.item; 
    
    /*
     * Determine generic input arguments.
     */
    assert (p); assert (R(p)); assert (R(p)->env);
    iter = VAR (R(p)->env, pa_iter, aat_nat); assert (iter);
    item = VAR (R(p)->env, pa_item, aat_pre); assert (item);
    frag = VAR (R(p)->env, pa_item, aat_pfrag); assert (frag);

    /*
     * Determine in- and output orderings.
     * MIL functions expect this information encoded in an integer
     * value that we build up here.
     */
    if (PFord_implies (in, PFord_refine (PFord_refine (PFordering (), pa_iter),
                                         pa_item)))
        o = 0;
    else if (PFord_implies (in, PFord_refine (PFord_refine (PFordering (),
                                                            pa_item),
                                              pa_iter)))
        o = 1;
    else
        PFoops (OOPS_FATAL, "illegal argument for input ordering");

    if (PFord_implies (out, PFord_refine (PFord_refine (PFordering (), pa_iter),
                                          pa_item)))
        o |= 0;
    else if (PFord_implies (out, PFord_refine (PFord_refine (PFordering (),
                                                             pa_item),
                                               pa_iter)))
        o |= 2;
    else
        PFoops (OOPS_FATAL, "illegal argument for output ordering");

    order = lit_int (o);

    if (PFty_subtype (ty, PFty_xs_anyElement ())) {

        /* This is a test for element nodes */

        /* Is it just a generic element kind test? (e.g. .../element()) */
        if (PFty_subtype (PFty_xs_anyElement (), ty))

            scj = llscj_elem (axis, iter, item, frag,
                              var (PF_MIL_VAR_WS), order);

        /* Is it a test on element kind and local name only? */
        else if (PFty_subtype (
                    PFty_elem (PFqname (PFns_wild,
                                        PFty_name (PFty_defn (ty)).loc),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_loc (axis, iter, item, frag,
                                  var (PF_MIL_VAR_WS), order,
                                  lit_str (PFqname_loc (
                                               PFty_name (PFty_defn (ty)))));

        /* Or maybe a test on element kind and namespace only? */
        else if (PFty_subtype (
                    PFty_elem (PFqname (PFty_name (PFty_defn (ty)).ns,
                                        NULL),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_ns (axis, iter, item, frag,
                                 var (PF_MIL_VAR_WS), order,
                                 lit_str (PFqname_uri (
                                              PFty_name (PFty_defn (ty)))));

        /* A test on element kind and full QName? */
        else if (PFty_subtype (
                    PFty_elem (PFty_name (PFty_defn (ty)),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_nsloc (
                    axis, iter, item, frag, var (PF_MIL_VAR_WS), order,
                    lit_str (PFqname_uri (PFty_name (PFty_defn (ty)))),
                    lit_str (PFqname_loc (PFty_name (PFty_defn (ty)))));
        /*
         * If we couldn't figure out what element test we got, give up.
         *
         * NOTE: The surface language actually allows such tests. We
         *       just cannot implement them (yet):
         *
         *        doc("foo")/child::element(shoeSize, xs:integer)
         */
        else
            PFoops (OOPS_FATAL,
                    "Problem with an XPath step: cannot evaluate "
                    "node test `%s'", PFty_str (ty));
    }
    /* If the node test wasn't some element test, maybe it is a text() test? */
    else if (PFty_subtype (ty, PFty_text ())) {
        scj = llscj_text (axis, iter, item, frag, var (PF_MIL_VAR_WS), order);
    }
    /* or a comment() test? */
    else if (PFty_subtype (ty, PFty_comm ())) {
        scj = llscj_comm (axis, iter, item, frag, var (PF_MIL_VAR_WS), order);
    }
    /* some test for processing-instructions? */
    else if (PFty_subtype (ty, PFty_pi (NULL))) {
        /* maybe we look for _any_ pi, regardless of its target? */
        if (PFty_subtype (PFty_pi (NULL), ty))
            scj = llscj_pi (axis, iter, item, frag, var (PF_MIL_VAR_WS), order);
        /* or was there a target specified? */
        else
            scj = llscj_pi_targ (
                    axis, iter, item, frag, var (PF_MIL_VAR_WS), order,
                    lit_str (PFqname_loc (PFty_name (PFty_defn (ty)))));
    }
    /* If all these cases did not apply, it is probably a node() test. */
    else if (PFty_subtype (PFty_xs_anyNode (), ty)) {
        scj = llscj_node (axis, iter, item, frag, var (PF_MIL_VAR_WS), order);
    }
    /* If we still couldn't find out, we probably need to give up. */
    else
        PFoops (OOPS_FATAL,
                "Problem with an XPath step: cannot evaluate "
                "node test `%s'", PFty_str (ty));

    assert (scj);

    /*
     * tmp  := scj (...);            # constructed just before
     * iter := tmp.fetch (0);
     * pre  := tmp.fetch (1);
     * kind := tmp.fetch (2);
     */
    tmp      = new_var (1);

    /*
     * Should we actually do materialize at runtime? In most cases
     * we should be able to see at compile time if columns are guaranteed
     * to be constant. We could then avoid carrying around the column at
     * all.
     *
     * Problem is: We do consider a `constant' property in our algebra
     * (not fully, yet, but the ideas are there). This property, however
     * only looks at ``real'' algebra columns. Here, materialize operates
     * on only part of a ``real'' column. The ``real'' column `item' is
     * implemented as `pre|kind' for nodes. And while kind may be constant,
     * pre probably won't.
     */
    execute (assgn (var (tmp->name), scj));

    ret_pre  = new_var (p->refctr);
    ret_frag = new_var (p->refctr);
    execute (
         assgn (var (ret_pre->name), fetch (var (tmp->name), lit_int (1))),
         assgn (var (ret_frag->name), 
                materialize (fetch (var (tmp->name), lit_int (2)),
                             var (ret_pre->name))));
    env_add (p->env, pa_item, aat_pre, ret_pre);
    env_add (p->env, pa_item, aat_pfrag, ret_frag);

    ret_iter = new_var (p->refctr);
    execute (
         assgn (var (ret_iter->name), 
                materialize (fetch (var (tmp->name), lit_int (0)),
                             fetch (var (tmp->name), lit_int (1)))));
    env_add (p->env, pa_iter, aat_nat, ret_iter);

    unpin (tmp, 1);

}

/**
 * Generic handling of binary operators, where both operands
 * are a BAT (in contrast to when one operand is known to be constant
 * and thus needs not be materialized as a BAT).
 *
 * @param op A MIL multiplex operation that implements the binary
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
bin_op (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
        PFpa_op_t *p, PFalg_simple_type_t arg_ty, PFalg_simple_type_t ret_ty)
{
    mvar_t              *res = new_var (p->refctr);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.binary.att1, arg_ty),
                   VAR (L(p)->env, p->sem.binary.att2, arg_ty))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.binary.res, ret_ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

/**
 * Generic binary arithmetic operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_arith (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));
    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl ||
            ty == aat_str);

    bin_op (op, p, ty, ty);
}

/**
 * node comparison operator, where both operands are a BAT
 * (in contrast to when one operand is known to be constant
 * and thus needs not be materialized as a BAT).
 *
 * @param op A MIL multiplex operation that implements the binary
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
node_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    mvar_t              *res = new_var (p->refctr);

    if (op == PFmil_mgt) {
        /* do the comparison: 
           frag1 > frag2 || (frag1 = frag2 && pre1 > pre2) */
        execute (
            assgn (
                var (res->name),
                PFmil_mor (
                    op (VAR (L(p)->env, p->sem.binary.att1, aat_pfrag),
                        VAR (L(p)->env, p->sem.binary.att2, aat_pfrag)),
                    PFmil_mand (
                        PFmil_meq (
                            VAR (L(p)->env, p->sem.binary.att1, aat_pfrag),
                            VAR (L(p)->env, p->sem.binary.att2, aat_pfrag)),
                        op (VAR (L(p)->env, p->sem.binary.att1, aat_pre),
                            VAR (L(p)->env, p->sem.binary.att2, aat_pre))))));
    } else if (op == PFmil_meq) {
        /* do the comparison: 
           frag1 = frag2 && pre1 = pre2 */
        execute (
            assgn (var (res->name),
                   PFmil_mand (
                       op (VAR (L(p)->env, p->sem.binary.att1, aat_pfrag),
                           VAR (L(p)->env, p->sem.binary.att2, aat_pfrag)),
                       op (VAR (L(p)->env, p->sem.binary.att1, aat_pre),
                           VAR (L(p)->env, p->sem.binary.att2, aat_pre)))));
    } else PFoops (OOPS_FATAL, "Unknown comparison for nodes.");

    /* and put the result into p's environment */
    env_add (p->env, p->sem.binary.res, aat_bln, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

/**
 * Generic binary comparison operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));

    if (ty & ~aat_node) {
        assert (ty == aat_int || ty == aat_dec ||
                ty == aat_dbl || ty == aat_str ||
                ty == aat_bln);
        bin_op (op, p, ty, aat_bln);
    } else if (ty == aat_pnode) {
        node_comp (op, p);
    } else
        PFoops (OOPS_FATAL,
                "Mil implementation of binary comparison for type %i unknown",
                ty);
}

/**
 * Generic binary Boolean operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_bool (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));
    assert (ty == aat_bln);

    bin_op (op, p, ty, aat_bln);
}

/**
 * Generic handling of arithmetic operators, where one operand is
 * known to be constant. (We don't need to materialize that attribute
 * as a BAT, but pass it as a const argument to MonetDB's [+].
 *
 * @param op A MIL multiplex operation that implements the arithmetic
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
bin_op_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
             PFpa_op_t *p,
             PFalg_simple_type_t arg_ty, PFalg_simple_type_t ret_ty)
{
    mvar_t              *res = new_var (p->refctr);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.bin_atom.att1, arg_ty),
                   literal (p->sem.bin_atom.att2))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.bin_atom.res, ret_ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

static void
bin_arith_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl);
    assert (ty == p->sem.bin_atom.att2.type);

    bin_op_atom (op, p, ty, ty);
}

static void
bin_comp_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl ||
            ty == aat_str || ty == aat_nat || ty == aat_bln);
    assert (ty == p->sem.bin_atom.att2.type);

    bin_op_atom (op, p, ty, aat_bln);
}

static void
bin_bool_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_bln);
    assert (ty == p->sem.bin_atom.att2.type);

    bin_op_atom (op, p, ty, aat_bln);
}

/**
 * Generic handling of unary operators (numeric and Boolean negation).
 *
 * @param op A MIL multiplex operation that implements the
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
unary_op (PFmil_t * (*op) (const PFmil_t *), PFpa_op_t *p)
{
    mvar_t              *res = new_var (p->refctr);
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.unary.att);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.unary.att, ty))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.unary.res, ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

/**
 * Generic handling of aggregation functions (avg, max, min and sum).
 *
 * @param op  A MIL operation that implements the function
 *            of interest (as a function pointer to the
 *            constructor function).
 * @param gop A MIL operation that implements the function
 *            of interest (as a function pointer to the
 *            constructor function), grouped version.
 * @param p   The physical algebra tree node that we are to translate.
 *            This function will actually fill @a p's environment
 *            <code>p->env</code>.
 */
static void 
aggr_function (PFmil_t * (*op) (const PFmil_t *),
               PFmil_t * (*gop) (const PFmil_t *),
               PFpa_op_t *p) 
{
     PFalg_att_t part = p->sem.aggr.part;
     PFalg_att_t att = p->sem.aggr.att;
     PFalg_att_t res = p->sem.aggr.res;
     bool has_part = part != att_NULL;
     PFalg_type_t poly_att_type = 0;
     PFalg_type_t poly_part_type = 0;
     PFalg_type_t poly_res_type = 0;
     /* determine res type */
     for (unsigned int i = 0; i < p->schema.count; i++) {
          if (p->schema.items[i].name == res) {
               poly_res_type = p->schema.items[i].type;
               break;
          }
     }
     /* determine att and part type */
     for (unsigned int i = 0; i < L(p)->schema.count; i++) {
          if (L(p)->schema.items[i].name == part)
               poly_part_type = L(p)->schema.items[i].type;
          else if (L(p)->schema.items[i].name == att)
               poly_att_type = L(p)->schema.items[i].type;
     }
     /* sanity checks */
     if (poly_att_type == 0) 
          PFoops (OOPS_FATAL,
                  "attribute `%s' referenced in aggregation function "
                  "not found", 
                  PFatt_str (att));
     if (has_part && poly_part_type == 0)
          PFoops (OOPS_FATAL,
                  "attribute `%s' referenced in aggregation function "
                  "not found", 
                  PFatt_str (part));
     if (poly_res_type == 0) 
          PFoops (OOPS_FATAL,
                  "attribute `%s' referenced in aggregation function "
                  "not found", 
                  PFatt_str (res));
     if (!monomorphic(poly_att_type) || !monomorphic(poly_res_type)
         || (has_part && !monomorphic(poly_part_type)))
          PFoops (OOPS_FATAL,
                  "Aggregation function not implemented for "
                  "polymorphic groups");
     PFalg_simple_type_t att_type = (PFalg_simple_type_t)poly_att_type;
     PFalg_simple_type_t res_type = (PFalg_simple_type_t)poly_res_type;
     if (has_part) {
          PFalg_simple_type_t part_type 
               = (PFalg_simple_type_t)poly_part_type;
          mvar_t *v    = new_var (1);
          mvar_t *res_var  = new_var (p->refctr);
          mvar_t *part_var = new_var (p->refctr);
          
          execute (
               /* v := 
                  {gop}(att.reverse().join(part).reverse()) */
               assgn (
                    var (v->name),
                    gop (
                         reverse (
                              join (
                                   reverse (VAR (L(p)->env, 
                                                 att, 
                                                 att_type)),
                                   VAR (L(p)->env, 
                                        part, 
                                        part_type))))),
               /* res := v.reverse ().mark (0@0).reverse (); */
               assgn (
                    var (res_var->name),
                    reverse (
                         mark (
                              reverse (var (v->name)),
                              lit_oid (0)))),
               /* part := v.mark (0@0).reverse (); */
               assgn (
                    var (part_var->name),
                    reverse (
                         mark (var (v->name), lit_oid (0)))));
          
          env_add (p->env, res, res_type, res_var);
          env_add (p->env, part, part_type, part_var);
          
          unpin (v, 1);
     }
     else {
          mvar_t *v = new_var (p->refctr);
          execute (
               assgn (var (v->name),
                      op (VAR (L(p)->env, att, att_type))),
               assgn (var (v->name),
                      append (
                           seqbase (
                                new (type (m_void), implty (res_type)),
                                lit_oid (0)),
                           var (v->name))));
          env_add (p->env, res, res_type, v);
     }
}

static void
inc_refctr (PFpa_op_t *n)
{
    assert (n);

    /* count number of incoming edges */
    n->refctr++;

    /* only descend once */
    if (SEEN(n))
        return;
    else
        SEEN(n) = true;
    
    for (unsigned int i = 0; i < PFPA_OP_MAXCHILD && n->child[i]; i++)
        inc_refctr (n->child[i]);
}

static void
label (PFpa_op_t *p)
{
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        if (!SEEN(L(p))) label (L(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
    }
    else if (!L(p) && R(p)) {
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
    }
    else {
        if (!SEEN(L(p))) label (L(p));
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
    }
    SEEN(p) = true;
}

/**
 * Translate MIL algebra tree in a MIL program.
 */
PFmil_t *
PFmilgen (PFpa_op_t *n)
{
    PFmil_t *bodymilprog;

    assert (n);

    /* set counters in algebra tree nodes */
    inc_refctr (n);
    PFpa_dag_reset (n);

    /* initialize list of variables we use */
    mvars = PFarray (sizeof (mvar_t));

    /* enrich algebra tree with state labels for subsequent reduce() call */
    label (n);
    PFpa_dag_reset (n);

    /* we start with an empty MIL program */
    milprog = declare (unused ());

    execute (declare (var (PF_MIL_VAR_WS)),
             assgn (unused (), nil ()));

    /* start compilation */
    reduce (n, 1);

#ifndef NDEBUG
    mvar_t *var = NULL;
    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        if ((var = (mvar_t *) PFarray_at (mvars, i))->pins) {
            if (var->pins == 1)
                PFinfo (OOPS_WARNING, 
                        "variable %s stilled pinned once.",
                        PFmil_var_str (var->name));
            else
                PFinfo (OOPS_WARNING, 
                        "variable %s stilled pinned %i times.",
                        PFmil_var_str (var->name), var->pins);
        }
#endif

    bodymilprog = milprog;
    
    milprog = seq (module (lit_str ("pathfinder")),
                   /* add timing information */
                   declare (var (PF_MIL_VAR_TIME_LOAD)),
                   declare (var (PF_MIL_VAR_TIME_QUERY)),
                   declare (var (PF_MIL_VAR_TIME_PRINT)),
                   assgn (var (PF_MIL_VAR_TIME_LOAD), lit_int (0)),
                   assgn (var (PF_MIL_VAR_TIME_PRINT), lit_int (0)),
                   assgn (var (PF_MIL_VAR_TIME_QUERY), usec ()));
    
    /* prepend variable declarations before the actual program */
    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        milprog = seq (milprog, 
                       declare (
                           var (((mvar_t *) PFarray_at (mvars, i))->name)));

    milprog = seq (milprog,
                   bodymilprog,
                   /* add timing information */
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          sub (usec (),
                               var (PF_MIL_VAR_TIME_QUERY))),
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          sub (var (PF_MIL_VAR_TIME_QUERY),
                               var (PF_MIL_VAR_TIME_LOAD))),
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          sub (var (PF_MIL_VAR_TIME_QUERY),
                               var (PF_MIL_VAR_TIME_PRINT))),
                   assgn (var (PF_MIL_VAR_TIME_LOAD),
                          div (
                              cast (type (m_dbl),
                                    var (PF_MIL_VAR_TIME_LOAD)),
                              lit_dbl (1000.0))),
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          div (
                              cast (type (m_dbl),
                                    var (PF_MIL_VAR_TIME_QUERY)),
                              lit_dbl (1000.0))),
                   assgn (var (PF_MIL_VAR_TIME_PRINT),
                          div (
                              cast (type (m_dbl),
                                    var (PF_MIL_VAR_TIME_PRINT)),
                              lit_dbl (1000.0))));

    return milprog;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
