/* -*- c-basic-offset:4; c-indentation-style:"k&r"; indent-tabs-mode:nil -*- */
/**
 * @file
 *
 * @brief Compile physical algebra tree into a MIL program
 *        (see also the @ref milgenDetail page).
 *
 * @page milgenDetail MIL Code generation
 *
 * @section phys2mil Physical algebra to MIL Code compilation
 *
 * The compilation from physical algebra is controlled by the function
 * #PFmilgen() and a Burg pattern matcher. It registers a global variable
 * #milprog which stores a MIL tree that is build during a bottom-up
 * traversal of the physical algebra DAG. The preferred way to extend
 * the MIL program is to use the macro #execute() which appends the new
 * commands to the MIL program. (More high-level information can be found
 * in the @ref milgenOverview Section in algebra.c.)
 *
 * MIL variables are used to provide for each operator, logical column,
 * and type the correct ``named'' BAT representations. We extend at compile
 * time every physical operator with a variable environment (#env_t) that maps
 * (column name, type) pairs to MIL variable names.
 *
 * The compilation procedure thus has to provide for each operator
 * -# the action code (by extending the MIL program) and
 *    .
 * -# has to fill the variable environment <code>p->env</code>
 *    (with the MIL variables used in the action code to store
 *     the result).
 *
 * If the environments are filled correctly every consuming parent operator
 * can refer to the result of its child by accessing the MIL variables in
 * the environment of its children. The bottom-up traversal ensures that
 * at runtime the respective MIL variables are already evaluated and visible.
 *
 * @subsection pin Pinning and Unpinning MIL variables
 *
 * We try to make use of variables as often as possible. We therefore keep
 * track which variables are already generated and how often they are going
 * to be used (pinned). As soon as a variable is not pinned anymore it will
 * be reused.
 *
 * If an operator needs local variables it can get a new free one from the
 * variable pool using the function #new_var() and an arbitrary pin count.
 * This pinned variable can be released at the end of the operator code again
 * by issuing #unpin() with the same count.
 *
 * Variables that are used to represent the result of an operator have
 * to pinned with <code>p->refctr</code> (the number of consuming parents).
 * For these variables is done automatically after the consumption.
 *
 * @if COPYRIGHT
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2008 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 * $Id$
 *
 * @endif
 */
%{

#include "pathfinder.h"

#include <assert.h>
#include <string.h>

#include "oops.h"
#include "mem.h"

#include "physical.h"
#include "alg_dag.h"
#include "properties.h"
#include "mil.h"
/* XRPC function call context */
#include "core.h"

/* abbreviate MIL constructor calls */
#include "mil_mnemonic.h"

/* Easily access subtree-parts */
#include "child_mnemonic.h"

/* fold( define burg accessors */
/** @cond BRG */ /* make doxygen ignore brg specific code */

/* Accessors for the burg matcher */
typedef struct PFpa_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

/** @endcond BRG */ /* make doxygen ignore brg specific code */
/* fold) */

%}

/* start non-terminal */
%start Query

/* fold( node identifiers */
/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/physical.h!
 */
%term serialize      =   1
%term lit_tbl        =   2
%term empty_tbl      =   3
%term attach         =   4
%term cross          =  10
%term leftjoin       =  11
%term eqjoin         =  14
%term semijoin       =  15
%term thetajoin      =  16
%term unq2_thetajoin =  17
%term unq1_thetajoin =  18
%term project        =  19
%term select         =  20
%term val_select     =  21
%term append_union   =  23
%term merge_union    =  24
%term intersect      =  25
%term difference     =  26
%term sort_distinct  =  27
%term std_sort       =  28
%term refine_sort    =  29
%term fun_1to1       =  30
%term eq             =  40
%term gt             =  42
%term bool_not       =  45
%term bool_and       =  46
%term bool_or        =  47
%term to             =  50
%term count_ext      =  54
%term count          =  55
%term avg            =  56
%term max_           =  57
%term min_           =  58
%term sum            =  59
%term mark           =  60
%term rank           =  61
%term mark_grp       =  62
%term type           =  63
%term type_assert    =  64
%term cast           =  65
%term llscjoin       = 100
%term doc_tbl        = 120
%term doc_access     = 121
%term twig           = 122
%term fcns           = 123
%term docnode        = 124
%term element        = 125
%term attribute      = 126
%term textnode       = 127
%term comment        = 128
%term processi       = 129
%term content        = 130
%term slim_content   = 131
%term merge_adjacent = 132
%term error          = 139
%term cond_err       = 140
%term nil            = 141
%term trace          = 142
%term trace_msg      = 143
%term trace_map      = 144
%term rec_fix        = 145
%term rec_param      = 146
%term rec_arg        = 147
%term rec_base       = 148
%term rec_border     = 149
%term fun_call       = 150
%term fun_param      = 151
%term string_join    = 160
/* fold)  */

/** @cond GRAMMAR */ /* make doxygen ignore the grammar */
%%

/* fold( grammar */
Query:    serialize (Rel)                                          =   1 (10);
Query:    serialize (empty_tbl)                                    =   2 (10);

Rel:      lit_tbl                                                  =  10 (10);
Rel:      empty_tbl                                                =  11 (10);
Rel:      attach (Rel)                                             =  12 (10);
Rel:      cross (Rel, Rel)                                         =  13 (10);
Rel:      leftjoin (Rel, Rel)                                      =  14 (10);
Rel:      eqjoin (Rel, Rel)                                        =  15 (10);
Rel:      semijoin (Rel, Rel)                                      =  16 (10);
Rel:      thetajoin (Rel, Rel)                                     =  17 (10);
Rel:      unq2_thetajoin (Rel, Rel)                                =  18 (10);
Rel:      unq1_thetajoin (Rel, Rel)                                =  19 (10);
Rel:      project (Rel)                                            =  20 (10);
Rel:      select (Rel)                                             =  21 (10);
Rel:      val_select (Rel)                                         =  22 (10);
Rel:      append_union (Rel, Rel)                                  =  23 (10);
Rel:      merge_union (Rel, Rel)                                   =  25 (10);
Rel:      intersect (Rel, Rel)                                     =  26 (10);
Rel:      difference (Rel, Rel)                                    =  27 (10);
Rel:      sort_distinct (Rel)                                      =  30 (10);
Rel:      sort_distinct (std_sort (Rel))                           =  31 (10);
Rel:      sort_distinct (refine_sort (Rel))                        =  32 (10);
Rel:      std_sort (Rel)                                           =  33 (10);
Rel:      refine_sort (Rel)                                        =  34 (10);
Rel:      fun_1to1 (Rel)                                           =  40 (10);
Rel:      eq (Rel)                                                 =  50 (10);
Rel:      gt (Rel)                                                 =  52 (10);
Rel:      bool_not (Rel)                                           =  60 (10);
Rel:      bool_and (Rel)                                           =  61 (10);
Rel:      bool_or (Rel)                                            =  62 (10);
Rel:      to (Rel)                                                 =  64 (10);
Rel:      count_ext (Rel, Rel)                                     =  65 (10);
Rel:      count (Rel)                                              =  66 (10);
Rel:      avg (Rel)                                                =  67 (10);
Rel:      max_ (Rel)                                               =  68 (10);
Rel:      min_ (Rel)                                               =  69 (10);
Rel:      sum (Rel)                                                =  70 (10);
Rel:      mark (Rel)                                               =  71 (10);
Rel:      rank (Rel)                                               =  72 (10);
Rel:      rank (std_sort (Rel))                                    =  73 (10);
Rel:      rank (refine_sort (Rel))                                 =  74 (10);
Rel:      mark_grp (Rel)                                           =  75 (10);
Rel:      type (Rel)                                               =  76 (10);
Rel:      type_assert (Rel)                                        =  77 (10);
Rel:      cast (Rel)                                               =  78 (10);

Rel:      llscjoin (Rel)                                           =  80 (10);
Rel:      doc_tbl (Rel)                                            = 100 (10);
Rel:      doc_access (Rel)                                         = 101 (10);
Rel:      twig (Twig)                                              = 102 (10);
Rel:      twig (attribute (Rel))                                   = 103 (10);
Rel:      twig (textnode (Rel))                                    = 104 (10);
Fcns:     fcns (Twig, Fcns)                                        = 105 (10);
Fcns:     fcns (Twig, nil)                                         = 106 (10);
Twig:     docnode (Rel, fcns (nil, nil))                           = 107 (10);
Twig:     docnode (Rel, Fcns)                                      = 108 (10);
Twig:     element (Rel, fcns (nil, nil))                           = 109 (10);
Twig:     element (Rel, Fcns)                                      = 110 (10);
Twig:     attribute (Rel)                                          = 111 (10);
Twig:     textnode (Rel)                                           = 112 (10);
Twig:     comment (Rel)                                            = 113 (10);
Twig:     processi (Rel)                                           = 114 (10);
Twig:     content (Rel)                                            = 115 (10);
Twig:     slim_content (Rel)                                       = 116 (10);
Rel:      merge_adjacent (Rel)                                     = 117 (10);

Rel:      error(Rel)                                               = 129 (10);
Rel:      cond_err (Rel, Rel)                                      = 130 (10);
Rel:      cond_err (Rel, empty_tbl)                                = 131 (10);
Rel:      trace (Rel, trace_msg (Rel, Map))                        = 135 (10);
Rel:      trace (Rel, trace_msg (Rel, nil))                        = 136 (10);
Map:      trace_map (Rel, Map)                                     = 137 (10);
Map:      trace_map (Rel, nil)                                     = 138 (10);

Rel:      rec_fix (Rec, Rel)                                       = 140 (10);
Rec:      rec_param (rec_arg (Rel, Rel), Rec)                      = 141 (10);
Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec)                = 142 (10);
Rec:      nil                                                      = 143 (10);
Rel:      rec_base                                                 = 144 (10);
Rel:      rec_border (Rel)                                         = 145 (10);

Rel:      FunRel                                                   = 150 (10);
FunRel:   fun_call (Rel, Param)                                    = 151 (10);
Param:    fun_param (Rel, Param)                                   = 152 (10);
Param:    nil                                                      = 154 (10);

Rel:      string_join (Rel, Rel)                                   = 160 (10);
/* fold) */

%%
/** @endcond */

/* fold( execute() / global milprog definition */
/**
 * @brief Global variable to collect the MIL program during compilation
 */
static PFmil_t *milprog;

/**
 * @brief Collect the MIL program in variable #milprog
 *
 * Processing of the physical plan is done bottom-up.
 * This is just the order in which we want to print our code.
 * So we keep the whole MIL program in the variable #milprog,
 * and append commands as we go. Think of it as @em executing
 * the commands right away.
 */
#define execute(...) milprog = seq (milprog, __VA_ARGS__)
/* fold) */

/* fold( mvar_t / global mvars / new_var() / pin() / unpin() definition */
/**
 * @brief Represents a MIL variable.
 *
 * The variable has a name (that is automatically generated).
 * The @a pins field keeps track of the number of references
 * to this variable.  A variable may not be destroyed before
 * @a pins drops to zero.
 */
struct mvar_t {
    PFmil_ident_t   name; /**< name of the variable */
    unsigned int    pins; /**< pin count of the variable */
};

/** short-hand for struct mvar_t */
typedef struct mvar_t mvar_t;

/**
 * @brief Global variable to reference all created variables
 *
 * Remember @em all variables that we deal with during the compiler
 * run in here.  We want to re-use variables as much as possible to
 * reduce the number of active variables in the MIL program.  This
 * should help MonetDB with its memory management.
 *
 * Each time we need a new variable, we try to re-use an old one
 * from here.  We thus search for a variable with pin count zero.
 * If we cannot find any, we create a new variable and append it to
 * the list.
 */
static PFarray_t *mvars;

/**
 * @brief running variable number.
 */
static unsigned int varno;

/**
 * @brief Create a ``new'' valid variable
 *
 * Will try to re-use an old, no longer needed, variable, if possible.
 * For this, the function searches #mvars for a variable with
 * @a pins = 0. If no such variable can be found, a new one will
 * be created and appended to the list.
 *
 * The new variable will be initialized with the pin count given
 * in @a pins.
 *
 * @param pins the initial pin count
 * @return The ``new'' valid variable
 */
static mvar_t *
new_var (unsigned int pins)
{
    mvar_t *var = NULL;

    assert (mvars);
    assert (varno < 10000);

    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        if ((var = *(mvar_t **) PFarray_at (mvars, i))->pins == 0) {
            var->pins = pins;
            return var;
        }

    /* If we were not successful, create a new entry */
    var = PFmalloc (sizeof (mvar_t));
    var->name = varno++;
    var->pins = pins;
    
    *(mvar_t **) PFarray_add (mvars) = var;

    return var;
}

/**
 * @brief Pin a variable (i.e., increment its pin count by @a count).
 *
 * @param v the variable whose pin count is increased
 * @param count the pin increment
 */
static void
pin (mvar_t *v, unsigned int count)
{
    v->pins += count;
}

/**
 * @brief Unpin a variable (i.e., decrement its pin count by @a count).
 *
 * If the pin count reaches zero, automatically generates a MIL
 * statement that assigns @c unused to the variable, marking it
 * a candidate for MonetDB's garbage collection.
 *
 * @param v the variable whose pin count is decreased
 * @param count the pin decrement
 */
static void
unpin (mvar_t *v, unsigned int count)
{
    if (v->pins < count) {
        PFinfo (OOPS_WARNING, "pin count below zero");
        v->pins = 0;
    } else
        v->pins -= count;
    if (!v->pins)
        execute (assgn (var (v->name), unused ()));
}


/* fold) */

/* fold( TYPE_MASK() / type_bit_check() / impl_types() / implty() definition */

/** @brief ``mask out'' the flags identifying non-attribute nodes */
#define TYPE_MASK(t)  ((t) & ~(aat_nkind | aat_nkind1))

/**
 * @brief Check if the algebra type represents only a single type bit
 *
 * @param ty the type representation that is going to be checked
 * @return the bool indicating if the input type consists of a single type bit
 */
static bool
type_bit_check (PFalg_simple_type_t ty)
{
    int count = 0;
    for (PFalg_simple_type_t t = 1; t; t <<= 1)
        if (t & ty) count++;

    return count == 1 && !(ty & aat_nkind);
}

/**
 * @brief MIL implementation types for algebra types
 */
static PFmil_type_t
impl_types (PFalg_simple_type_t ty)
{
    switch (ty) {
        case aat_nat:
        case aat_qname_id:
        case aat_qname_cont:
        case aat_pre:
        case aat_attr:
        case aat_frag:
        case aat_pre1:
        case aat_attr1:
        case aat_frag1:
            return mty_oid;

        case aat_int:
        case aat_update:
        case aat_docmgmt:
            return mty_lng;

        case aat_path:
        case aat_colnm:
        case aat_docnm:
        case aat_str:
        case aat_uA:
            return mty_str;

        case aat_dec:
        case aat_dbl:
            return mty_dbl;

        case aat_bln:
            return mty_bit;

        default:
            PFoops (OOPS_FATAL, "illegal type in impl_types");
            return mty_oid;
    }
}

#ifndef NDEBUG
/** @brief implementation type for a given algebra type, as a MIL node */
#define implty(n) type (type_bit_check ((n))                     \
                        ? impl_types ((n))                       \
                        : (assert (!"illegal type in implty()"), \
                           (PFmil_type_t) 0))
#else
/** @brief implementation type for a given algebra type, as a MIL node */
#define implty(n) type (impl_types ((n)))
#endif
/* fold) */

/* fold( env_t / new_env() / env_*() / VAR() / ANY_VAR() definition */
/**
 * @brief Environment entry.
 *
 * In each physical algebra tree node, we keep an environment
 * that maps an attribute/type combination to the #mvar_t struct
 * that holds the corresponding MIL variable.
 */
struct env_t {
    PFalg_att_t          att;
    PFalg_simple_type_t  ty;
    mvar_t              *mvar;
};
/** short-hand for struct env_t */
typedef struct env_t env_t;

/**
 * @brief Create a new (empty) environment for #env_t entries.
 *
 * With each node in the physical algebra DAG, we keep such an
 * environment that maps an attribute/type combination onto the
 * #mvar_t item that implements it. (Think of this as the mapping
 * from attribute/type to the BAT that represents that combination.
 */
static PFarray_t *
new_env (void)
{
    return PFarray (sizeof (env_t), 10);
}

/** @brief Add an item to environment for #env_t entries. */
static void
env_add_ (PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty, mvar_t *v)
{
    *(env_t *) PFarray_add (env)
        = (env_t) { .att = att, .ty = ty, .mvar = v };
#ifndef NDEBUG
    execute ( comment ("    %s: %s(%s)",
                       PFmil_var_str (v->name),
                       PFatt_str (att),
                       PFalg_simple_type_str (ty)));
#endif
}
/** @brief Add an item to environment for #env_t entries. */
#define env_add(e,a,t,v) (type_bit_check ((t))           \
                          ? env_add_ ((e), (a), (t), (v)) \
                          : (assert (!"illegal type in env_add()")))

/** @brief Return #env_t environment size. */
static unsigned int
env_count (const PFarray_t *env)
{
    return PFarray_last (env);
}

/** @brief Return environment item at index @a i. */
static env_t
env_at (const PFarray_t *env, unsigned int i)
{
    assert (i < PFarray_last (env));

    return *(env_t *) PFarray_at ((PFarray_t *) env, i);
}

/**
 * @brief Worker for #env_mvar().
 *
 * Yields NULL if the MIL variable could not be found in the enviroment
 * @a env (in specific cases, this is not an error).
 */
static mvar_t *
env_mvar_unsafe (const PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    for (unsigned int i = 0; i < PFarray_last (env); i++) {

        env_t entry = *(env_t *) PFarray_at ((PFarray_t *) env, i);

        if (entry.att == att && entry.ty == ty)
            return entry.mvar;
    }
    return NULL;
}

/**
 * @brief Look up an entry in the environment @a env, given a combination
 *        of attribute (@a att) and type (@a ty) as the search key.
 */
static mvar_t *
#ifndef NDEBUG
#define env_mvar(e,a,t) (env_mvar_ ((e), (a), (t), __func__, __LINE__))
env_mvar_ (const PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty,
           const char *func, const int line)
#else
env_mvar (const PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
#endif
{
    mvar_t *mvar = env_mvar_unsafe (env, att, ty);

    if (mvar)
        return mvar;

#ifndef NDEBUG
    fprintf (stderr,
             "looking for att: %s, ty: 0x%X in function %s (line %i)\n",
             PFatt_str (att), ty, func, line);
    fprintf (stderr, "environment looks like:\n");
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        env_t entry = *(env_t *) PFarray_at ((PFarray_t *) env, i);

        fprintf (stderr, "  att: %s, type: 0x%X, mvar->name: %s\n",
                 PFatt_str (entry.att), entry.ty,
                 PFmil_var_str (entry.mvar->name));
    }
#endif

    PFoops (OOPS_FATAL,
            "attribute '%s' with type '0x%X' not found in environment",
            PFatt_str (att), ty);
    /* we don't ever get here */
    return NULL;
}

/**
 * @brief Look up a MIL variable in the environment @a env
 *        and return it as MIL code.
 */
#define VAR(e,a,t) (var (env_mvar ((e), (a), (t))->name))

/**
 * @brief Look up an @e arbitrary MIL variable in the environment
 *        @a env and return it as MIL code.
 */
#define ANY_VAR(e) (var (env_at ((e), 0).mvar->name))

/**
 * @brief Copy the complete environment.
 */
static void
env_copy (PFpa_op_t *p, PFarray_t *in_env)
{
    assert (p);
    assert (in_env);

    /* copy all the existing variables */
    for (unsigned int i = 0; i < env_count (in_env); i++) {
        env_t entry = env_at (in_env, i);
        env_add (p->env, entry.att, entry.ty, entry.mvar);
        pin (entry.mvar, p->refctr);
    }
}

/**
 * @brief env_map copies the the complete environment and
 *        aligns the columns with a given map relation (in @a v).
 */
static void
env_map (PFpa_op_t *p, PFarray_t *in_env, mvar_t *v)
{
    assert (p);
    assert (in_env);
    assert (v);

    for (unsigned int i = 0; i < env_count (in_env); i++) {
        mvar_t *tmp  = new_var (p->refctr);
        /* expand variables */
        execute (
            assgn (var (tmp->name),
                   leftjoin (var (v->name),
                             var (env_at (in_env, i).mvar->name))),
            /* because leftjoin does not know that we have
               exactly one match for each tuple in v,
               we need to make the heads void ourselves */
            assgn (var (tmp->name),
                   reverse (mark (reverse (var (tmp->name)),
                                  lit_oid (0)))));

        env_add (p->env,
                 env_at (in_env, i).att,
                 env_at (in_env, i).ty,
                 tmp);
    }
}
/* fold) */

/* fold( twig_state_t / global twig_state definition */
/**
 * @brief The state information necessary to build a twig
 *        of multiple node constructors in one go.
 */
struct twig_state_t {
    unsigned int pre;          /**< pre id in the twig tree */
    unsigned int parent;       /**< pre id of the parent in the twig tree */
    unsigned int size;         /**< static size value of a node */
    unsigned int level;        /**< static level of a twig node */
    PFarray_t   *elem_vars;    /**< ordered list of node constructor
                                    representations */
    PFarray_t   *attr_vars;    /**< ordered list of attribute constructor
                                    representations */
    PFmil_t     *loop;         /**< loop relation */
    bool         elem_content; /**< information if a content operator
                                    with element nodes appears in the twig */
};

/** @brief short-hand for struct twig_state_t */
typedef struct twig_state_t twig_state_t;

/** @brief current twig state */
static twig_state_t *twig_state;
/* fold) */

/* fold( new_trace_id() / global global_trace_id definition */

/** @brief global ID for tracing */
static unsigned int global_trace_id;

/**
 * @brief Return a ``new'' trace id. This id is used
 *        to refer to a certain trace relation.
 */
static unsigned int
new_trace_id (void)
{
    /* the trace_id corresponds to the oids
       in the trace containers */
    return global_trace_id++;
}
/* fold) */

/** @brief Function call parameter list. */
static PFarray_t *fun_params = NULL;

/** @brief The maximum number of non-terminals in the brg grammar rules */
#define MAX_KIDS 10
/** @brief A flag indicating whether the operators has been seen already */
#define SEEN(p) ((p)->bit_dag)

/** @brief mnemonic for a sort specification list */
#define sortby(...)     PFord_order_intro (__VA_ARGS__)

/* forward declaration */
static void reduce (PFpa_op_t * p, int goalnt);

/***********************************/
/* fold( reduce() helper functions */
/***********************************/
/** @brief Lookup the type of the @a att column in the schema of node @a n. */
static PFalg_simple_type_t
type_of (const PFpa_op_t *n, PFalg_att_t att)
{ /* fold( */
    assert (n);

    for (unsigned int i = 0; i < n->schema.count; i++)
        if (n->schema.items[i].name == att)
            return n->schema.items[i].type;

    PFoops (OOPS_FATAL,
            "cannot determine implementation type of algebra expression");

    assert (0); /* never reached due to "exit" in "PFoops" */
    return aat_nat; /* pacify picky compilers */
} /* fold) */

/** @brief Compile a physical algebra literal value into its MIL equivalent. */
static PFmil_t *
literal_ (PFalg_atom_t atom, PFalg_simple_type_t type)
{ /* fold( */
    switch (type) {

        case aat_nat:  return lit_oid (atom.val.nat_);
        case aat_int:  return lit_lng (atom.val.int_);
        case aat_uA:
        case aat_str:  return lit_str (atom.val.str);
        case aat_dec:  return lit_dbl (atom.val.dec_);
        case aat_dbl:  return lit_dbl (atom.val.dbl);
        case aat_bln:  return lit_bit (atom.val.bln);
        case aat_qname_id:
            return add_qname (lit_str (PFqname_prefix (atom.val.qname)),
                              lit_str (PFqname_uri (atom.val.qname)),
                              lit_str (PFqname_loc (atom.val.qname)),
                              var (PF_MIL_VAR_WS));
        case aat_qname_cont:
            return var (PF_MIL_VAR_WS_CONT);

        default:
            break;
    }

    PFoops (OOPS_FATAL,
            "A relational algebra type (%u) has not yet "
            "been implemented.", atom.type);

    assert (0); /* never reached due to "exit" in "PFoops" */
    return NULL; /* pacify picky compilers */
} /* fold) */
/** @brief Compile a physical algebra literal value into its MIL equivalent. */
#define literal(a) (literal_ ((a), (a).type))

/**
 * @brief Generate MIL code for an intersection.
 *
 * @param p the intersection operator
 * @param left the schema of the arguments from the left input
 * @param right the schema of the arguments from the right input
 * @param[out] res the MIL variable the result is assigned to.
 */
static void
intersect (PFpa_op_t *p,
           PFalg_schema_t left, PFalg_schema_t right,
           mvar_t *res)
{ /* fold( */
    PFarray_t          *helper_vars = PFarray (sizeof (mvar_t *), 10);
    PFalg_att_t         latt,
                        ratt;
    PFalg_simple_type_t lty  = 0,
                        rty  = 0;
    PFmil_t            *args = NULL;
    mvar_t             *l = NULL,
                       *r = NULL;

    assert (left.count == right.count);

    /* collect all arguments/columns for the intersection ... */
    for (unsigned int i = 0; i < left.count; i++) { /* fold( */
        latt = left.items[i].name;
        ratt = right.items[i].name;
        lty  = left.items[i].type;
        rty  = right.items[i].type;

        /* cope with simple types */
        if (type_bit_check (lty) && lty == rty) {
            l = env_mvar (L(p)->env, latt, lty);
            r = env_mvar (R(p)->env, ratt, rty);
        }
        /* cope with nodes */
        else if (!(~aat_node & lty) && !(~aat_node & rty)) {
            /* cope with conflicting nodes (attr vs. node) */
            if ((lty == aat_pnode && rty == aat_anode) ||
                (lty == aat_anode && rty == aat_pnode)) {
                args = arg (seqbase (new (type (mty_void),
                                          type (mty_oid)),
                                     lit_oid (0)),
                            seqbase (new (type (mty_void),
                                          type (mty_oid)),
                                     lit_oid (0)));
                break;
            }
            /* cope with normal nodes only */
            else if (lty == aat_pnode && rty == aat_pnode) {
                l = env_mvar (L(p)->env, latt, aat_pre);
                r = env_mvar (R(p)->env, ratt, aat_pre);
            }
            /* cope with attribute nodes only */
            else if (lty == aat_anode && rty == aat_anode) {
                l = env_mvar (L(p)->env, latt, aat_attr);
                r = env_mvar (R(p)->env, ratt, aat_attr);
            }
            /* cope with a mix of all possible nodes */
            else if (lty == aat_node && rty == aat_node) {
                mvar_t *lpre  = new_var (1),
                       *rpre  = new_var (1),
                       *lattr = new_var (1),
                       *rattr = new_var (1);

                *(mvar_t **) PFarray_add (helper_vars) = lpre;
                *(mvar_t **) PFarray_add (helper_vars) = rpre;
                *(mvar_t **) PFarray_add (helper_vars) = lattr;
                *(mvar_t **) PFarray_add (helper_vars) = rattr;

                /* We have to ensure that tuples with nil values
                   are not ignored. We therefore shift all pre
                   and attr id by one and replace nil by 0. This
                   way attributes only match attributes and
                   other nodes only match non-attribute nodes. */
                l = env_mvar (L(p)->env, latt, aat_pre);
                r = env_mvar (R(p)->env, ratt, aat_pre);

                execute (
                    assgn (var (lpre->name),
                           mifthenelse (
                               misnil (var (l->name)),
                               project (var (l->name),
                                        lit_int (0)),
                               madd (mcast (type (mty_lng),
                                            var (l->name)),
                                     lit_int (1)))),
                    assgn (var (rpre->name),
                           mifthenelse (
                               misnil (var (r->name)),
                               project (var (r->name),
                                        lit_int (0)),
                               madd (mcast (type (mty_lng),
                                            var (r->name)),
                                     lit_int (1)))));

                /* add the pre column */
                if (!args)
                    args = arg (var (lpre->name), var (rpre->name));
                else
                    args = arg (args, arg (var (lpre->name),
                                           var (rpre->name)));

                l = env_mvar (L(p)->env, latt, aat_attr);
                r = env_mvar (R(p)->env, ratt, aat_attr);

                execute (
                    assgn (var (lattr->name),
                           mifthenelse (
                               misnil (var (l->name)),
                               project (var (l->name),
                                        lit_int (0)),
                               madd (mcast (type (mty_lng),
                                            var (l->name)),
                                     lit_int (1)))),
                    assgn (var (rattr->name),
                           mifthenelse (
                               misnil (var (r->name)),
                               project (var (r->name),
                                        lit_int (0)),
                               madd (mcast (type (mty_lng),
                                            var (r->name)),
                                     lit_int (1)))));

                /* add the attr column */
                args = arg (args, arg (var (lattr->name), var (rattr->name)));

                l = env_mvar (L(p)->env, latt, aat_frag);
                r = env_mvar (R(p)->env, ratt, aat_frag);

                args = arg (args, arg (var (l->name), var (r->name)));

                /* jump over the shared code as we already added
                   everything to the argument by hand. */
                continue;
            }
#ifndef NDEBUG
            else
                assert (!"thinking error in intersect translation");
#endif

            /* add the attr/pre column */
            if (!args)
                args = arg (var (l->name), var (r->name));
            else
                args = arg (args, arg (var (l->name),
                                       var (r->name)));
            l = env_mvar (L(p)->env, latt, aat_frag);
            r = env_mvar (R(p)->env, ratt, aat_frag);
        }
        /* cope with QNames */
        else if (aat_qname == lty && aat_qname == rty) {
            mvar_t *luri_loc = new_var (1),
                   *ruri_loc = new_var (1);

            *(mvar_t **) PFarray_add (helper_vars) = luri_loc;
            *(mvar_t **) PFarray_add (helper_vars) = ruri_loc;

            execute (
                assgn (var (luri_loc->name),
                       mposjoin (VAR (L(p)->env, latt, aat_qname_id),
                                 VAR (L(p)->env, latt, aat_qname_cont),
                                 var (PF_MIL_VAR_QN_URI_LOC))),
                assgn (var (ruri_loc->name),
                       mposjoin (VAR (R(p)->env, ratt, aat_qname_id),
                                 VAR (R(p)->env, ratt, aat_qname_cont),
                                 var (PF_MIL_VAR_QN_URI_LOC))));

            if (!args)
                args = arg (var (luri_loc->name), var (ruri_loc->name));
            else
                args = arg (args, arg (var (luri_loc->name),
                                       var (ruri_loc->name)));

            /* jump over the shared code as we already added
               everything to the argument by hand. */
            continue;
        }
        else
            PFoops (OOPS_FATAL,
                    "cannot handle polymorphic join columns "
                    " in the intersect translation for MIL");

        if (!args)
            args = arg (var (l->name), var (r->name));
        else
            args = arg (args, arg (var (l->name), var (r->name)));
    } /* fold) */

    /* apply the multi-column equi-join */
    execute (assgn (var (res->name),
                    mc_intersect (args)));

    for (unsigned int i = 0; i < PFarray_last (helper_vars); i++)
        unpin (*(mvar_t **) PFarray_at (helper_vars, i), 1);
} /* fold) */

/**
 * @brief Generate MIL code that prepares the input
 *        for an (in)equality comparison.
 *
 * @param l the left input relation
 * @param r the right input relation
 * @param latt the comparison column of the left input
 * @param ratt the comparison column of the right input
 * @param[out] lres the MIL variable which the result
 *                  of the preparation for the left input
 *                  is assigned to
 * @param[out] rres the MIL variable which the result
 *                  of the preparation for the right input
 *                  is assigned to
 */
static void
prepare_comp (PFpa_op_t *l, PFpa_op_t *r,
              PFalg_att_t latt, PFalg_att_t ratt,
              mvar_t *lres, mvar_t *rres)
{ /* fold( */
    PFalg_simple_type_t lty = type_of (l, latt),
                        rty = type_of (r, ratt);

    /* cope with simple types */
    if (type_bit_check (lty) && lty == rty) {
        execute (
            assgn (var (lres->name),
                   VAR (l->env, latt, lty)),
            assgn (var (rres->name),
                   VAR (r->env, ratt, rty)));
    }
    /* cope with nodes */
    else if (!(~aat_node & lty) && !(~aat_node & rty)) {
        mvar_t *tmp_res = new_var (1),
               *lf      = env_mvar (l->env, latt, aat_frag),
               *rf      = env_mvar (r->env, ratt, aat_frag);

        /* cope with normal nodes only */
        if (lty == aat_pnode && rty == aat_pnode) {
            mvar_t *lp = env_mvar (l->env, latt, aat_pre);
            mvar_t *rp = env_mvar (r->env, ratt, aat_pre);
            execute (assgn (var (tmp_res->name),
                            zip_nodes (
                                var (lf->name),
                                var (lp->name),
                                nil (),
                                var (rf->name),
                                var (rp->name),
                                nil ())));
        }
        /* cope with attribute nodes only */
        else if (lty == aat_anode && rty == aat_anode) {
            mvar_t *la = env_mvar (l->env, latt, aat_attr);
            mvar_t *ra = env_mvar (r->env, ratt, aat_attr);
            execute (assgn (var (tmp_res->name),
                            zip_nodes (
                                var (lf->name),
                                var (la->name),
                                nil (),
                                var (rf->name),
                                var (ra->name),
                                nil ())));
        }
        /* cope with a mix of all possible nodes */
        else if ((lty == aat_node && rty == aat_node) ||
                 (lty == aat_pnode && rty == aat_anode) ||
                 (lty == aat_anode && rty == aat_pnode)) {
            /* We have to ensure that tuples with nil values
               are not ignored. We therefore shift all pre
               and attr id by one and replace nil by 0. This
               way attributes only match attributes and
               other nodes only match non-attribute nodes. */
            mvar_t *lp = new_var (1);
            mvar_t *rp = new_var (1);
            mvar_t *la = new_var (1);
            mvar_t *ra = new_var (1);

            if (lty & aat_pre)
                execute (
                    assgn (var (lp->name), VAR (l->env, latt, aat_pre)),
                    assgn (var (lp->name),
                           mifthenelse (
                               misnil (var (lp->name)),
                               project (var (lp->name),
                                        lit_int (0)),
                               madd (mcast (type (mty_lng),
                                            var (lp->name)),
                                     lit_int (1)))));
            else
                execute (
                    assgn (var (lp->name),
                           project (var (lf->name), lit_int (0))));

            if (rty & aat_pre)
                execute (
                    assgn (var (rp->name), VAR (r->env, ratt, aat_pre)),
                    assgn (var (rp->name),
                           mifthenelse (
                               misnil (var (rp->name)),
                               project (var (rp->name),
                                        lit_int (0)),
                               madd (mcast (type (mty_lng),
                                            var (rp->name)),
                                     lit_int (1)))));
            else
                execute (
                    assgn (var (rp->name),
                           project (var (rf->name), lit_int (0))));

            if (lty & aat_attr)
                execute (
                    assgn (var (la->name), VAR (l->env, latt, aat_attr)),
                    assgn (var (la->name),
                           mifthenelse (
                               misnil (var (la->name)),
                               project (var (la->name),
                                        lit_int (0)),
                               madd (mcast (type (mty_lng),
                                            var (la->name)),
                                     lit_int (1)))));
            else
                execute (
                    assgn (var (la->name),
                           project (var (lf->name), lit_int (0))));

            if (rty & aat_attr)
                execute (
                    assgn (var (ra->name), VAR (r->env, ratt, aat_attr)),
                    assgn (var (ra->name),
                           mifthenelse (
                               misnil (var (ra->name)),
                               project (var (ra->name),
                                        lit_int (0)),
                               madd (mcast (type (mty_lng),
                                            var (ra->name)),
                                     lit_int (1)))));
            else
                execute (
                    assgn (var (ra->name),
                           project (var (rf->name), lit_int (0))));

            execute (
                assgn (var (tmp_res->name),
                       zip_nodes (
                           var (lf->name),
                           var (lp->name),
                           var (la->name),
                           var (rf->name),
                           var (rp->name),
                           var (ra->name))));
            unpin (lp, 1);
            unpin (rp, 1);
            unpin (la, 1);
            unpin (ra, 1);
        }
#ifndef NDEBUG
        else
            assert (!"thinking error in comparison");
#endif
        execute (assgn (var (lres->name),
                        fetch (var (tmp_res->name),
                               lit_int (0))),
                 assgn (var (rres->name),
                        fetch (var (tmp_res->name),
                               lit_int (1))));
        unpin (tmp_res, 1);
    }
    /* cope with QNames */
    else if (aat_qname == lty && aat_qname == rty) {
        execute (
            assgn (var (lres->name),
                   mposjoin (VAR (l->env, latt, aat_qname_id),
                             VAR (l->env, latt, aat_qname_cont),
                             var (PF_MIL_VAR_QN_URI_LOC))),
            assgn (var (rres->name),
                   mposjoin (VAR (r->env, ratt, aat_qname_id),
                             VAR (r->env, ratt, aat_qname_cont),
                             var (PF_MIL_VAR_QN_URI_LOC))));
    }
    else
        PFoops (OOPS_FATAL,
                "cannot handle polymorphic join columns "
                " in the thetajoin translation for MIL"
                " (got 0x%X and 0x%X)", lty, rty);
} /* fold) */

/**
 * @brief Generate MIL code that produces an order extend
 *        based on the order given in @a ord.
 *
 * @param p the order (extend) operator
 * @param ord the list of orderings that have to be applied
 * @param[out] res the MIL variable the extend is assigned to
 */
static void
order_extend (PFpa_op_t *p, PFord_ordering_t ord, mvar_t *res)
{ /* fold( */
    /*
     * Derive a single BAT from the multi-column grouping
     * (using functions from the xtables module).
     */
    PFalg_att_t att;
    bool        dir,
                initialized = false;

    for (unsigned int i = 0; i < PFord_count (ord); i++) {
        att = PFord_order_col_at (ord, i);
        dir = PFord_order_dir_at (ord, i);

        /* special case QNames -- here we need to look up the
           values */
        if (type_of (p, att) & aat_qname) {
            mvar_t *qn = new_var (1);
            execute (
                assgn (var (qn->name),
                       mposjoin (VAR (p->env, att, aat_qname_id),
                                 VAR (p->env, att, aat_qname_cont),
                                 var (PF_MIL_VAR_QN_URI_LOC))));
            if (!initialized) {
                execute (
                    assgn (var (res->name),
                           reverse (
                               sort (reverse (var (qn->name)), dir))));
                initialized = true;
            }
            else
                execute (
                    assgn (var (res->name),
                           ctrefine (var (res->name), var (qn->name),
                                     dir)));
            unpin (qn, 1);
        }
        else
            /* cope with all non-QName types */
            for (PFalg_simple_type_t t = 1; t; t <<= 1)
                if (t & TYPE_MASK(type_of (p, att)) &&
                    !(t & aat_qname)) {
                    if (!initialized) {
                        execute (
                            assgn (var (res->name),
                                   reverse (
                                       sort (
                                           reverse (
                                               VAR (p->env, att, t)),
                                           dir))));
                        initialized = true;
                    }
                    else
                        execute (
                            assgn (var (res->name),
                                   ctrefine (var (res->name),
                                             VAR (p->env, att, t),
                                             dir)));
                }
    }
} /* fold) */

/**
 * @brief Generate MIL code that extracts the QName references
 *        from a node column @a att in a given operator @a p.
 *
 * @param p the operator whose column values are used
 * @param att the column that holds the node references
 * @param[out] id the MIL variable the references to the QName
 *                entries are assigned to
 * @param[out] cont the MIL variable the containers to the respective
 *                  QName references are assigned to
 */
static void
fn_node_name (PFpa_op_t *p, PFalg_att_t att, mvar_t *id, mvar_t *cont)
{ /* fold( */
    PFalg_simple_type_t ty = type_of (p, att);

    if (ty == aat_pnode) {
        /* find all element nodes and extract their QName references */
        mvar_t  *kind      = new_var (1),
                *elem      = new_var (1),
                *elem_cont = new_var (1),
                *map       = new_var (1);
        PFmil_t *pre       = VAR (p->env, att, aat_pre),
                *pre_cont  = VAR (p->env, att, aat_frag);

        execute (
            assgn (var (kind->name),
                   mposjoin (
                       pre,
                       pre_cont,
                       fetch (var (PF_MIL_VAR_WS),
                              var (PF_MIL_VAR_PRE_KIND)))),
            assgn (var (map->name),
                   hmark (select_ (var (kind->name),
                                   var (PF_MIL_VAR_KIND_ELEM)),
                          lit_oid (0))),
            assgn (var (elem->name),
                   leftfetchjoin (var (map->name), pre)),
            assgn (var (elem_cont->name),
                   leftfetchjoin (var (map->name), pre_cont)),
            assgn (var (id->name),
                   leftfetchjoin (
                       reverse (var (map->name)),
                       mposjoin (var (elem->name),
                                 var (elem_cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_PROP))))),
            assgn (var (cont->name),
                   leftfetchjoin (
                       reverse (var (map->name)),
                       mposjoin (var (elem->name),
                                 var (elem_cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_CONT))))));

        unpin (kind, 1);
        unpin (elem, 1);
        unpin (elem_cont, 1);
        unpin (map, 1);
    }
    else if (ty == aat_anode) {
        /* extract all QName references from the attributes */
        PFmil_t *attr      = VAR (p->env, att, aat_attr),
                *attr_cont = VAR (p->env, att, aat_frag);

        execute (
            assgn (var (id->name),
                   mposjoin (attr,
                             attr_cont,
                             fetch (var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_ATTR_QN)))),
            assgn (var (cont->name),
                   mposjoin (attr,
                             attr_cont,
                             fetch (var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_ATTR_CONT)))));
    }
    else {
        assert (ty == aat_node);

        /* split up nodes and attributes,
           find all element nodes and extract their QName references */
        mvar_t  *elem      = new_var (1),
                *elem_cont = new_var (1),
                *pre_sel   = new_var (1),
                *attr_sel  = new_var (1),

                *pid       = new_var (1),
                *pcont     = new_var (1),
                *aid       = new_var (1),
                *acont     = new_var (1),
                *res       = new_var (1),

                *attr_col  = env_mvar (p->env, att, aat_attr);
        PFmil_t *pre       = VAR (p->env, att, aat_pre),
                *pre_cont  = VAR (p->env, att, aat_frag),
                *attr      = VAR (p->env, att, aat_attr);

        execute (
            /* get all attributes */
            assgn (var (attr_sel->name),
                   hmark (
                       select2 (var (attr_col->name),
                                cast (type (mty_oid), nil ()),
                                cast (type (mty_oid), nil ())),
                       lit_oid (0))),
            /* get all attribute QNames */
            assgn (var (aid->name),
                   mposjoin (leftfetchjoin (var (attr_sel->name), attr),
                             leftfetchjoin (var (attr_sel->name), pre_cont),
                             fetch (var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_ATTR_QN)))),
            assgn (var (acont->name),
                   mposjoin (leftfetchjoin (var (attr_sel->name), attr),
                             leftfetchjoin (var (attr_sel->name), pre_cont),
                             fetch (var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_ATTR_CONT)))),
            /* get all other nodes */
            assgn (var (pre_sel->name),
                   hmark (
                       select_ (
                           misnil (var (attr_col->name)),
                           lit_bit (true)),
                       lit_oid (0))),
            /* get all element nodes */
            assgn (var (elem->name),
                   leftfetchjoin (var (pre_sel->name), pre)),
            assgn (var (elem_cont->name),
                   leftfetchjoin (var (pre_sel->name), pre_cont)),
            assgn (var (pre_sel->name),
                   leftfetchjoin (
                       reverse (var (pre_sel->name)),
                       mposjoin (var (elem->name),
                                 var (elem_cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_KIND))))),
            assgn (var (pre_sel->name),
                   hmark (select_ (var (pre_sel->name),
                                   var (PF_MIL_VAR_KIND_ELEM)),
                          lit_oid (0))),
            assgn (var (elem->name),
                   leftfetchjoin (var (pre_sel->name), pre)),
            assgn (var (elem_cont->name),
                   leftfetchjoin (var (pre_sel->name), pre_cont)),
            /* get all element QNames */
            assgn (var (pid->name),
                   mposjoin (var (elem->name),
                             var (elem_cont->name),
                             fetch (var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PRE_PROP)))),
            assgn (var (pcont->name),
                   mposjoin (var (elem->name),
                             var (elem_cont->name),
                             fetch (var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PRE_CONT)))),
            /* combine the results */
            assgn (var (res->name),
                   merged_union (
                       arg (var (attr_sel->name),
                            arg (var (pre_sel->name),
                                 arg (var (aid->name),
                                      arg (var (pid->name),
                                           arg (var (acont->name),
                                                var (pcont->name)))))))),
            assgn (var (id->name),
                   leftfetchjoin (
                       reverse (fetch (var (res->name), lit_int (0))),
                       fetch (var (res->name), lit_int (1)))),
            assgn (var (cont->name),
                   leftfetchjoin (
                       reverse (fetch (var (res->name), lit_int (0))),
                       fetch (var (res->name), lit_int (2)))));

        unpin (elem, 1);
        unpin (elem_cont, 1);
        unpin (pre_sel, 1);
        unpin (attr_sel, 1);
        unpin (aid, 1);
        unpin (pid, 1);
        unpin (acont, 1);
        unpin (pcont, 1);
        unpin (res, 1);
    }
} /* fold) */

/**
 * @brief Generate MIL code that transforms strings into QNames.
 *
 * @param[in] in the MIL variable that refers to the BAT of input strings
 * @param[out] out the MIl variable the references to the QName
 *                 entries are assigned to
 */
static void
transform_QName (mvar_t *in, mvar_t *out)
{ /* fold( */
    mvar_t  *offset  = new_var (1);
    mvar_t  *prefix  = new_var (1);
    mvar_t  *local   = new_var (1);
    mvar_t  *err_str = new_var (1);

    /* split up strings using ``:'' as delimiter */
    /* FIXME: currently we we don't retrieve the URI */
    execute (
        assgn (var (err_str->name),
               check_qnames (var (in->name))),
        if_ (not (isnil (var (err_str->name))),
             error (arg (lit_str ("err:FORG0001. "
                                  "illegal QName '%s'."),
                         var (err_str->name))),
             nop ()),
        assgn (var (offset->name),
               msearch (var (in->name), lit_str (":"))),
        assgn (var (prefix->name),
               mstring2 (var (in->name),
                         lit_int (0),
                         var (offset->name))),
        assgn (var (local->name),
               mstring (var (in->name),
                        madd (lit_int (1),
                              var (offset->name)))),
        /* add_qnames changes the working set
           in 'var (PF_MIL_VAR_WS)' as side effect */
        assgn (var (out->name),
               add_qnames (
                   var (prefix->name),
                   project (var (prefix->name),
                            lit_str ("")),
                   var (local->name),
                   var (PF_MIL_VAR_WS))));

    unpin (offset, 1);
    unpin (prefix, 1);
    unpin (local, 1);
    unpin (err_str, 1);
} /* fold) */

/**
 * @brief Generate MIL code that copies QNames from arbitrary containers
 *        to the WS container.
 *
 * @param[in] in_qn_id the MIL variable the QName reference are bound to
 * @param[in] in_qn_cont the MIL variable the QName reference containers
 *                       are bound to
 * @param[out] qn_id the MIL variable the references to the QName
 *                   entries in the WS container are assigned to
 */
static void
copy_QName (mvar_t *in_qn_id, mvar_t *in_qn_cont, mvar_t *qn_id)
{ /* fold( */
    mvar_t  *qn_cont  = new_var (1),
            *qn_id_ws = new_var (1),
            *qn_bool  = new_var (1),
            *qn_map   = new_var (1),
            *prefix   = new_var (1),
            *uri      = new_var (1),
            *local    = new_var (1),
            *mu_res   = new_var (1);
    PFmil_t *bodymilprog,
            *oldmilprog;

    /* check if all QNames reside in the transient container
       - if not we need to copy them */
    oldmilprog = milprog;
    /* start new milprog for the nesting:
       'if (...) {...} else {}' */
    milprog = nop ();

    execute (
        assgn (var (qn_bool->name),
               meq (var (in_qn_cont->name), var (PF_MIL_VAR_WS_CONT))),
        assgn (var (qn_map->name),
               mirror (select_ (var (qn_bool->name),
                                lit_bit (false)))),
        assgn (var (qn_id->name),
               leftfetchjoin (
                   var (qn_map->name),
                   var (in_qn_id->name))),
        assgn (var (qn_cont->name),
               leftfetchjoin (
                   var (qn_map->name),
                   var (in_qn_cont->name))),
        assgn (var (prefix->name),
               mposjoin (var (qn_id->name),
                         var (qn_cont->name),
                         fetch (var (PF_MIL_VAR_WS),
                                var (PF_MIL_VAR_QN_PREFIX)))),
        assgn (var (uri->name),
               mposjoin (var (qn_id->name),
                         var (qn_cont->name),
                         fetch (var (PF_MIL_VAR_WS),
                                var (PF_MIL_VAR_QN_URI)))),
        assgn (var (local->name),
               mposjoin (var (qn_id->name),
                         var (qn_cont->name),
                         fetch (var (PF_MIL_VAR_WS),
                                var (PF_MIL_VAR_QN_LOC)))),
        assgn (var (qn_id->name),
               add_qnames (
                   var (prefix->name),
                   var (uri->name),
                   var (local->name),
                   var (PF_MIL_VAR_WS))),
        assgn (var (qn_id_ws->name),
               leftfetchjoin (
                   mirror (select_ (var (qn_bool->name),
                                    lit_bit (true))),
                   var (in_qn_id->name))),
        assgn (var (mu_res->name),
               merged_union (
                   arg (hmark (var (qn_id->name), lit_oid (0)),
                        arg (hmark (var (qn_id_ws->name), lit_oid (0)),
                             arg (tmark (var (qn_id->name), lit_oid (0)),
                                  tmark (var (qn_id_ws->name), lit_oid (0))
                                  ))))),
        assgn (var (qn_id->name),
               leftfetchjoin (
                   reverse (fetch (var (mu_res->name), lit_int (0))),
                   fetch (var (mu_res->name), lit_int (1)))));

    /* store nested MIL code */
    bodymilprog = milprog;
    /* activate old mil program */
    milprog = oldmilprog;

    /* fill in the MIL code for the QName transfer:
       if (count unchanged) { do nothing } else { transform ... } */
    execute (
        if_ (eq (count (select_ (var (in_qn_cont->name),
                                 var (PF_MIL_VAR_WS_CONT))),
                 count (var (in_qn_cont->name))),
        /* then */ assgn (var (qn_id->name), var (in_qn_id->name)),
        /* else */ bodymilprog));

    unpin (qn_cont, 1);
    unpin (qn_id_ws, 1);
    unpin (qn_bool, 1);
    unpin (qn_map, 1);
    unpin (prefix, 1);
    unpin (uri, 1);
    unpin (local, 1);
    unpin (mu_res, 1);
} /* fold) */

/**
 * @brief Generic handling of aggregation functions (avg, max, min and sum).
 *
 * @param op  A MIL operation that implements the function
 *            of interest (as a function pointer to the
 *            constructor function).
 * @param gop A MIL operation that implements the function
 *            of interest (as a function pointer to the
 *            constructor function), grouped version.
 * @param p   The physical algebra tree node that we are to translate.
 *            This function will actually fill @a p's environment
 *            <code>p->env</code>.
 */
static void
aggr_function (PFmil_t * (*op) (const PFmil_t *),
               PFmil_t * (*gop) (const PFmil_t *),
               PFpa_op_t *p)
{ /* fold( */
     PFalg_att_t         part    = p->sem.aggr.part,
                         att     = p->sem.aggr.att,
                         res     = p->sem.aggr.res;
     PFalg_simple_type_t part_ty,
                         att_ty  = type_of (L(p), att),
                         res_ty  = type_of (p, res);

     assert (att_ty == res_ty);

     if (part != att_NULL) {
         mvar_t *v    = new_var (1);
         mvar_t *res_var  = new_var (p->refctr);
         mvar_t *part_var = new_var (p->refctr);

         part_ty = type_of (L(p), part);

         execute (
              /* v :=
                 {gop}(att.reverse().join(part).reverse()) */
              assgn (var (v->name),
                     gop (reverse (
                              join (reverse (VAR (L(p)->env, att, att_ty)),
                                    VAR (L(p)->env, part, part_ty))))),
              /* res := v.reverse ().mark (0@0).reverse (); */
              assgn (var (res_var->name),
                     reverse (mark (reverse (var (v->name)), lit_oid (0)))),
              /* part := v.mark (0@0).reverse (); */
              assgn (var (part_var->name),
                     reverse (mark (var (v->name), lit_oid (0)))));

         env_add (p->env, res, res_ty, res_var);
         env_add (p->env, part, part_ty, part_var);

         unpin (v, 1);
     }
     else {
          mvar_t *v = new_var (p->refctr);
          execute (
               assgn (var (v->name),
                      op (VAR (L(p)->env, att, att_ty))),
               assgn (var (v->name),
                      append (
                           seqbase (
                                new (type (mty_void), implty (res_ty)),
                                lit_oid (0)),
                           var (v->name))));
          env_add (p->env, res, res_ty, v);
     }
} /* fold) */

/**
 * Translate loop-lifted staircase joins.
 */
static void
llscj (const PFpa_op_t *p)
{ /* fold( */
    /* abbreviations for input expressions */
    PFord_ordering_t in  = p->sem.scjoin.in;
    PFord_ordering_t out = p->sem.scjoin.out;

    char *qn_uri = PFqname_uri (p->sem.scjoin.spec.qname),
         *qn_loc = PFqname_loc (p->sem.scjoin.spec.qname);

    PFmil_t *axis,    /* axis specifier */
            *code,    /* code indicating which additional tests
                         have to be applied (name or kind) */
            *order,   /* order specifier */
            *kind,    /* kind specifier */
            *uri,     /* namespace specifier */
            *loc,     /* local name specifier */
            *tgt;     /* target name specifier */
    int      o;       /* helper to compute order specifier */
    mvar_t  *step     = new_var (1),         /* the step result variable */
            *map      = new_var (1),         /* mapping helper variable */
            *ret_iter = new_var (p->refctr), /* the `iter' result variable */
            *ret_frag = new_var (p->refctr), /* the `frag' result variable */
            *ret_pre  = new_var (p->refctr); /* the `pre' result variable */

    PFalg_att_t pa_iter = p->sem.scjoin.iter;
    PFalg_att_t pa_item = p->sem.scjoin.item;

    PFalg_simple_type_t iter_ty     = type_of (L(p), pa_iter),
                        item_ty     = type_of (L(p), pa_item),
                        item_res_ty = type_of (p, pa_item);

    assert (iter_ty == aat_nat);
    assert (p); assert (L(p)); assert (L(p)->env);

    /* collect all information to check *//* fold( */
    /* translate axis information */
    axis = NULL;
    switch (p->sem.scjoin.spec.axis) {
        case alg_anc:    axis = var (PF_MIL_VAR_AXIS_ANC);    break;
        case alg_anc_s:  axis = var (PF_MIL_VAR_AXIS_ANC_S);  break;
        case alg_chld:   axis = var (PF_MIL_VAR_AXIS_CHLD);   break;
        case alg_desc:   axis = var (PF_MIL_VAR_AXIS_DESC);   break;
        case alg_desc_s: axis = var (PF_MIL_VAR_AXIS_DESC_S); break;
        case alg_fol:    axis = var (PF_MIL_VAR_AXIS_FOL);    break;
        case alg_fol_s:  axis = var (PF_MIL_VAR_AXIS_FOL_S);  break;
        case alg_par:    axis = var (PF_MIL_VAR_AXIS_PAR);    break;
        case alg_prec:   axis = var (PF_MIL_VAR_AXIS_PREC);   break;
        case alg_prec_s: axis = var (PF_MIL_VAR_AXIS_PREC_S); break;
        case alg_self:   axis = var (PF_MIL_VAR_AXIS_SELF);   break;
        case alg_attr:   axis = var (PF_MIL_VAR_AXIS_ATTR);   break;
    }

    /*
     * Determine in- and output orderings.
     * MIL functions expect this information encoded in an integer
     * value that we build up here.
     */
    if (PFord_implies (in, sortby (pa_iter, pa_item)))
        o = 0;
    else if (PFord_implies (in, sortby (pa_item, pa_iter)))
        o = 1;
    else
        PFoops (OOPS_FATAL, "illegal argument for input ordering");

    if (PFord_implies (out, sortby (pa_iter, pa_item)))
        o |= 0;
    else if (PFord_implies (out, sortby (pa_item, pa_iter)))
        o |= 2;
    else
        PFoops (OOPS_FATAL, "illegal argument for output ordering");

    order = lit_int (o);

    /* initialize the code */
    code = var (PF_MIL_VAR_CODE_KIND);
    /* translate kind information */
    kind = NULL;
    switch (p->sem.scjoin.spec.kind) {
        case node_kind_elem: kind = var (PF_MIL_VAR_KIND_ELEM);    break;
        case node_kind_attr: kind = cast (type (mty_chr), nil ()); break;
        case node_kind_text: kind = var (PF_MIL_VAR_KIND_TEXT);    break;
        case node_kind_pi:   kind = var (PF_MIL_VAR_KIND_PI);      break;
        case node_kind_comm: kind = var (PF_MIL_VAR_KIND_COM);     break;
        case node_kind_doc:  kind = var (PF_MIL_VAR_KIND_DOC);     break;
        case node_kind_node: kind = cast (type (mty_chr), nil ());
        /* overwrite code */ code = var (PF_MIL_VAR_CODE_NONE);
    }

    /* translate name information and extend testing code */
    if (p->sem.scjoin.spec.kind == node_kind_pi && qn_loc) {
        code = var (PF_MIL_VAR_CODE_TARGET);
        uri  = cast (type (mty_str), nil ());
        loc  = cast (type (mty_str), nil ());
        tgt  = lit_str (qn_loc);
    }
    else if (qn_uri && qn_loc) {
        code = var (PF_MIL_VAR_CODE_NSLOC);
        uri  = lit_str (qn_uri);
        loc  = lit_str (qn_loc);
        tgt  = cast (type (mty_str), nil ());
    }
    else if (qn_uri) {
        code = var (PF_MIL_VAR_CODE_NS);
        uri  = lit_str (qn_uri);
        loc  = cast (type (mty_str), nil ());
        tgt  = cast (type (mty_str), nil ());
    }
    else if (qn_loc) {
        code = var (PF_MIL_VAR_CODE_LOC);
        uri  = cast (type (mty_str), nil ());
        loc  = lit_str (qn_loc);
        tgt  = cast (type (mty_str), nil ());
    }
    else {
        uri  = cast (type (mty_str), nil ());
        loc  = cast (type (mty_str), nil ());
        tgt  = cast (type (mty_str), nil ());
    }
    /* end of collect all information to check *//* fold) */

    /*
     * step := step (...);
     * iter := step.fetch (0);
     * frag := step.fetch (1);
     * pre  := step.fetch (2);
     */
    execute (
         assgn (var (step->name),
                step (axis, code,
                      VAR (L(p)->env, pa_iter, iter_ty),
                      VAR (L(p)->env, pa_item, aat_frag),
                      VAR (L(p)->env, pa_item, aat_pre),
                      item_ty & aat_attr
                      ? VAR (L(p)->env, pa_item, aat_attr)
                      : nil (),
                      var (PF_MIL_VAR_WS),
                      order, kind,
                      uri, loc, tgt)),
         assgn (var (ret_pre->name), fetch (var (step->name), lit_int (2))),
         /*
          * Should we actually do materialize at runtime? In most cases
          * we should be able to see at compile time if columns are guaranteed
          * to be constant. We could then avoid carrying around the column at
          * all.
          *
          * Problem is: We do consider a `constant' property in our algebra
          * (not fully, yet, but the ideas are there). This property, however
          * only looks at ``real'' algebra columns. Here, materialize operates
          * on only part of a ``real'' column. The ``real'' column `item' is
          * implemented as `pre|kind' for nodes. And while kind may be constant,
          * pre probably won't.
          */
         assgn (var (ret_frag->name),
                materialize (fetch (var (step->name), lit_int (1)),
                             var (ret_pre->name))),
         assgn (var (ret_iter->name),
                materialize (fetch (var (step->name), lit_int (0)),
                             var (ret_pre->name))));

    /* add the result variables to the environment */
    env_add (p->env, pa_iter, aat_nat, ret_iter);
    env_add (p->env, pa_item, aat_pre, ret_pre);
    env_add (p->env, pa_item, aat_frag, ret_frag);

    if (item_res_ty & aat_attr) {
        mvar_t *ret_attr = new_var (p->refctr);

        execute (
             assgn (var (ret_attr->name),
                    fetch (var (step->name), lit_int (3))));

        env_add (p->env, pa_item, aat_attr, ret_attr);
    }

    unpin (step, 1);
    unpin (map, 1);

} /* fold) */

#ifdef HAVE_PFTIJAH

/* PFTIJAH helper functions */

static mvar_t
*pft_create_pfop(PFpa_op_t *p, PFalg_simple_type_t t)
{
	mvar_t *res;
	if ( p ) {
	    res  = new_var (1);
	    mvar_t *p_iter = env_mvar (p->env, att_iter, aat_nat);
	    mvar_t *p_item = env_mvar (p->env, att_item, t);
	    mvar_t *p_frag;
	    if ( t == aat_pre ) {
	        p_frag = env_mvar (p->env, att_item, aat_frag);
	    } else {
	        p_frag = new_var (1);
		execute(
                    assgn (var (p_frag->name), lit_int(0))
		);
	    }
	    mvar_t *p_pos  = env_mvar (p->env, att_pos , aat_nat);

	    if ( !(p_iter && p_item && p_frag && p_pos) )
		PFoops(OOPS_FATAL,"pft_create_pfop: missing [iter|item|frag|pos] child");
	    execute (
                assgn (var (res->name), 
                          tj_pfop(var (p_iter->name),var(p_item->name),var(p_frag->name),var(p_pos->name)))
	    );
	    if ( t != aat_pre )
	        unpin(p_frag,1);
	} else {
	    res  = new_var (1);
	    execute (
                assgn (var (res->name), 
                          seqbase (new (type (mty_void), type(mty_bat) ),
                                            lit_oid (0)))
	    );
	}
	return res;
}

static void
pft_unpack_pfop(PFpa_op_t* dest, mvar_t *pack,
		     PFalg_att_t a_iter,
		     PFalg_att_t a_item, PFalg_simple_type_t t_item,
		     PFalg_att_t a_frag,
		     PFalg_att_t a_pos
		    )
{
	mvar_t *v_iter  = new_var (dest->refctr);
	execute (
	    assgn (var (v_iter->name),
		fetch (var (pack->name), lit_int (0))));
	env_add (dest->env, a_iter, aat_nat, v_iter);

	mvar_t *v_item  = new_var (dest->refctr);
	execute (
	    assgn (var (v_item->name),
		fetch (var (pack->name), lit_int (1))));
	env_add (dest->env, a_item, t_item, v_item);

	if ( a_frag ) {
	    mvar_t *v_frag  = new_var (dest->refctr);
	    execute (
	        assgn (var (v_frag->name),
		    fetch (var (pack->name), lit_int (2))));
	    env_add (dest->env, a_frag, aat_frag, v_frag);
	}

	mvar_t *v_pos  = new_var (dest->refctr);
	execute (
	    assgn (var (v_pos->name),
		fetch (var (pack->name), lit_int (3))));
	env_add (dest->env, a_pos, aat_nat, v_pos);
}

#endif

/***********************************/
/* fold) end reduce helper functions */
/***********************************/

/* fold( reduce*() functions implementing the rec_* operators */
/*
 * Alternative reducer function. Introduces code that is invariant
 * to the recursion before the recursion body is translated.
 */
static void
reduce_border (PFpa_op_t * p, int goalnt, PFarray_t *border_vars)
{ /* fold( */
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */

    assert (p);

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* guard against too dep recursion */
    PFrecursion_fence();

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);

    switch (rule) {
        /* Rel:      rec_fix (Rec, Rel) */
        case 140:
            /* only follow the parameters */
            reduce_border (kids[0], nts[0], border_vars);
            break;

        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 141:
            /* only follow the seeds */
            reduce_border (kids[0], nts[0], border_vars);
            /* and the rest of the parameter list */
            reduce_border (kids[2], nts[2], border_vars);
            break;

        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 142:
            /* follow the rest of the parameter list */
            reduce_border (kids[1], nts[1], border_vars);
            break;

        /* Rec:      nil */
        case 143:
            /* nothing to be done */
            break;

        /* Rel:      rec_border (Rel) */
        case 145:
            if (!p->env) {
                /* translate sub-DAG starting at the border */
                reduce (p, goalnt);
                assert (p->env);
                /* increase the pin count by one to avoid releasing the
                   variables before the end of the while loop and remember
                   which variables to unpin afterwards */
                for (unsigned int i = 0; i < env_count (p->env); i++) {
                    pin (env_at (p->env, i).mvar, 1);
                    *(mvar_t **) PFarray_add (border_vars)
                        = env_at (p->env, i).mvar;
                }
            }
            break;

        default:
            for (unsigned short i = 0; nts[i]; i++)
                reduce_border (kids[i], nts[i], border_vars);
    }
} /* fold) */

/*
 * Alternative reducer function. Copes with patterns that are
 * larger than the burg patterns (e.g., variable parameter lists
 * required for the recursion operator). It contains the
 * respective action code for some of the above burg patterns.
 */
static void
reduce1 (PFpa_op_t * p, int goalnt, PFarray_t *border_vars)
{ /* fold( */
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */

    assert (p);
    /* reduce1 should be called only once for each pattern */
    if (p->env)
        return;

    /* guard against too dep recursion */
    PFrecursion_fence();

    p->env = new_env ();

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);

#ifndef NDEBUG
    execute (comment ("Begin rule (reduce1): \"%s\"", PFmilgen_string[rule]));
#endif

    switch (rule) {
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 141:
            /* only generate MIL code for the seed */
            reduce (kids[0], nts[0]);

            /* relink the enviroment of arg to its base */
            L(p)->sem.rec_arg.base->env = p->env;

            /* Copy the result of the the seed into a new variable.
               This variable is pinned for each call of the base
               (base and paramter both refer to the same environment)
               and additionally for each parameter to avoid that the
               variable is overwritten during generation of the recursion. */
            for (unsigned int i = 0; i < env_count (LL(p)->env); i++) {
                mvar_t *tmp  = new_var (p->refctr +
                                        L(p)->sem.rec_arg.base->refctr);

                /* copy variable */
                execute (
                    assgn (var (tmp->name),
                           var (env_at (LL(p)->env, i).mvar->name)));

                /* add the variable to the current environment
                   (and thus also to the base environment) */
                env_add (p->env,
                         env_at (LL(p)->env, i).att,
                         env_at (LL(p)->env, i).ty,
                         tmp);

                /* unpin the seed once -- the recursion now does not
                   reference it anymore */
                unpin (((env_t *) PFarray_at (kids[0]->env, i))->mvar, 1);
            }

            /* translate all the remaining seeds */
            reduce1 (kids[2], nts[2], border_vars);

            /* translate all expressions that are invariant to
               the recursion body */
            reduce_border (kids[1], nts[1], border_vars);
            break;

        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 142:
            /* relink the enviroment of arg to its base */
            L(p)->sem.rec_arg.base->env = p->env;

            /* For each column and type in the empty table generate
               a new bat and assign it to the variables used by the
               recursion. */
            for (unsigned int col = 0; col < LL(p)->schema.count; col++) {
                if (!LL(p)->schema.items[col].type)
                    PFoops (OOPS_FATAL,
                            "empty sequence should never "
                            "occur in MIL generation.");

                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & TYPE_MASK(LL(p)->schema.items[col].type)) {
                        mvar_t *tmp  = new_var (p->refctr +
                                                L(p)->sem.rec_arg.base->refctr);

                        /* assign an empty BAT to the new variable */
                        execute (
                            assgn (var (tmp->name),
                                   seqbase (new (type (mty_void), implty (t)),
                                            lit_oid (0))));

                        /* add the variable to the current environment
                           (and thus also to the base environment) */
                        env_add (p->env,
                                 LL(p)->schema.items[col].name,
                                 t,
                                 tmp);
                    }
            }

            /* translate all the remaining seeds */
            reduce1 (kids[1], nts[1], border_vars);

            /* translate all expressions that are invariant to
               the recursion body */
            reduce_border (kids[0], nts[0], border_vars);
            break;

        /* Rec:      nil */
        case 143:
            /* no MIL code needed */
            break;

        default:
            PFoops (OOPS_FATAL,
                    "cannot cope with rule %d in "
                    "alternative reduce function",
                    rule);
    }

#ifndef NDEBUG
    execute (comment ("End rule (reduce1): \"%s\"", PFmilgen_string[rule]));
    for (unsigned int i = 0; i < PFarray_last (p->env); i++)
        assert (((env_t *) PFarray_at (p->env, i))->mvar->pins);
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

} /* fold) */

/*
 * Alternative reducer function. Copes with patterns that are
 * larger than the burg patterns (e.g., variable parameter lists
 * required for the recursion operator). It contains the
 * respective action code for some of the above burg patterns.
 */
static void
reduce2 (PFpa_op_t * p, int goalnt)
{ /* fold( */
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    int           pos_body;       /* position of the recursion body in the
                                     list of kids */

    /* reduce2 should be only called after reduce1 */
    if (!p->env)
        PFoops (OOPS_FATAL,
                "cannot cope with function reduce2 "
                "as long as reduce1 was not called.");

    /* guard against too dep recursion */
    PFrecursion_fence();

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);

#ifndef NDEBUG
    execute (comment ("Begin rule (reduce2): \"%s\"", PFmilgen_string[rule]));
#endif

    pos_body = 0;

    switch (rule) {
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 141:
            pos_body = 1; /* discard the seed */
        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 142:
            /* only generate MIL code for the body */
            reduce (kids[pos_body], nts[pos_body]);
            /* translate all the remaining parts of the body */
            reduce2 (kids[pos_body + 1], nts[pos_body + 1]);

            /* ensure that we have a 1:1 mapping of the environments */
            assert (PFarray_last (p->env) == PFarray_last (LR(p)->env));

            /* Reassign the variables. Thus the initial seed relations
               are overwritten by the result of the recursion */
            for (unsigned int i = 0; i < PFarray_last (p->env); i++) {
                env_t entry = env_at (p->env, i);

                /* find the corresponding variable in res for
                   the variable in p */
                mvar_t *tmp = env_mvar (LR(p)->env, entry.att, entry.ty);

                execute (
                    assgn (var (entry.mvar->name),
                           var (tmp->name)));

                /* unpin the recursion once -- the recursion now does not
                   reference it anymore */
                unpin (tmp, 1);
            }
            break;

        /* Rec:      nil */
        case 143:
            /* no MIL code needed */
            break;

        default:
            PFoops (OOPS_FATAL,
                    "cannot cope with rule %d in "
                    "alternative reduce function",
                    rule);
    }

#ifndef NDEBUG
    execute (comment ("End rule (reduce2): \"%s\"", PFmilgen_string[rule]));
    for (unsigned int i = 0; i < PFarray_last (p->env); i++)
        assert (((env_t *) PFarray_at (p->env, i))->mvar->pins);
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

} /* fold) */

/*
 * Alternative reducer function. Copes with patterns that are
 * larger than the burg patterns (e.g., variable parameter lists
 * required for the recursion operator). It contains the
 * respective action code for some of the above burg patterns.
 */
static void
reduce3 (PFpa_op_t * p, int goalnt)
{ /* fold( */
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    int           pos_list;       /* position of the param list in the
                                     list of kids */

    /* reduce3 should be only called after reduce1 */
    if (!p->env)
        PFoops (OOPS_FATAL,
                "cannot cope with function reduce3 "
                "as long as reduce1 was not called.");

    /* guard against too dep recursion */
    PFrecursion_fence();

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);

#ifndef NDEBUG
    execute (comment ("Begin rule (reduce3): \"%s\"", PFmilgen_string[rule]));
#endif

    pos_list = 1;

    switch (rule) {
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 141:
            pos_list = 2; /* discard the seed */
        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 142:
            /* translate all the remaining parts of the list */
            reduce3 (kids[pos_list], nts[pos_list]);

            /* release the remaining pins that ensured that the
               recursion input arguments were not overwritten
               during the recursion. */
            for (unsigned int i = 0; i < PFarray_last (p->env); i++) {
                unpin (env_at (p->env, i).mvar, p->refctr);
            }
            break;

        /* Rec:      nil */
        case 143:
            /* no MIL code needed */
            break;

        default:
            PFoops (OOPS_FATAL,
                    "cannot cope with rule %d in "
                    "alternative reduce function",
                    rule);
    }

#ifndef NDEBUG
    execute (comment ("End rule (reduce3): \"%s\"", PFmilgen_string[rule]));
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

} /* fold) */
/* fold) */

/**
 * @brief Reducer function.
 *
 * This is the heart of this source file. It contains all the action code
 * for the above burg patterns.
 */
static void
reduce (PFpa_op_t * p, int goalnt)
{ /* fold( */
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */

    if (p->env)
        return;

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* guard against too deep recursion */
    PFrecursion_fence();

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);

    /* PFinfo (OOPS_NOTICE, "in rule %u", rule); */

    switch (rule) {
        /* Query:    serialize (Rel) */
        case 1:
        /* Query:    serialize (empty_tbl) */
        case 2:
        /* Rel:      twig (Twig) */
        case 102:
        /* Fcns:     fcns (Twig, Fcns) */
        case 105:
        /* Twig:     docnode (Rel, Fcns) */
        case 108:
        /* Twig:     element (Rel, Fcns) */
        case 110:
        /* Rel:      rec_fix (Rec, Rel) */
        case 140:
        /* FunRel:   fun_call (Rel, Param) */
        case 151:
        /* Param:    fun_param (Rel, Param) */
        case 152:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     * (ensure that the fragment information is translated after
     *  the value part)
     */
    if (!topdown)
        for (unsigned short i = MAX_KIDS; i > 0; i--)
            if (kids[i - 1])
                reduce (kids[i - 1], nts[i - 1]);

    /* translate every operator only once */
    if (p->env)
        return;

    p->env = new_env ();

#ifndef NDEBUG
    execute (comment ("Begin rule: \"%s\"", PFmilgen_string[rule]));
#endif

    switch (rule) {
        /* Query:   serialize (Rel) */
        case 1: /* fold( */
        {
            PFalg_simple_type_t ty;
            mvar_t *err, *time;
            PFalg_att_t pa_item = p->sem.serialize.item;
            PFmil_t *oldmilprog, *bodymilprog;

            /* save the current mil program */
            oldmilprog = milprog;

            /* create a new empty milprog */
            milprog = nop ();

            execute (
                comment ("variable controlling the output format"),
                assgn (var (PF_MIL_VAR_GENTYPE), lit_str ("xml")),
                comment ("volatile variable environment"),
                assgn (var (PF_MIL_VAR_WS), new_ws ()));
            reduce (kids[0], nts[0]);

            /* add timing information */
            time = new_var (1);
            execute (assgn (var (time->name), usec ()));

            /* check if the type of the root node is aat_update
               and if yes play the update tape */
            if (aat_update & type_of (L(p), pa_item)) { /* fold( */
                /* Set up all the value containers for update_tape(). */

                /* UpdateTape (
                       BAT[void,bat] ws,
                       BAT[void,int] kind,
                       BAT[void,oid] pre_tgt,
                       BAT[void,oid] pre_cont_tgt,
                       BAT[void,oid] attr_tgt,
                       BAT[void,oid] attr_cont_tgt,
                       BAT[void,str] replace_strings,
                       BAT[void,str] replace_qn_uristrings,
                       BAT[void,str] replace_qn_loc_strings,
                       BAT[void,oid] pre_ins,
                       BAT[void,oid] pre_cont_ins,
                       BAT[void,oid] attr_ins,
                       BAT[void,oid] attr_cont_ins): void
                */
                mvar_t *upd_kind               = new_var (1),
                       *pre_tgt                = new_var (1),
                       *pre_cont_tgt           = new_var (1),
                       *attr_tgt               = new_var (1),
                       *attr_cont_tgt          = new_var (1),
                       *replace_strings        = new_var (1),
                       *replace_qn_uristrings  = new_var (1),
                       *replace_qn_loc_strings = new_var (1),
                       *pre_ins                = new_var (1),
                       *pre_cont_ins           = new_var (1),
                       *attr_ins               = new_var (1),
                       *attr_cont_ins          = new_var (1);

                ty = type_of (L(p), pa_item);

                /* consider update kind */
                execute (
                    assgn (var (upd_kind->name),
                           VAR (L(p)->env, pa_item, aat_update)),
                );

                /* consider node tgt */
                if (ty & aat_pnode1 && !(ty & aat_attr1)) {
                    /* all nodes but not attributes */
                    execute (
                        assgn (var (pre_tgt->name),
                               VAR (L(p)->env, pa_item, aat_pre1)),
                        assgn (var (pre_cont_tgt->name),
                               VAR (L(p)->env, pa_item, aat_frag1)));
                }
                else if (ty & aat_nkind1 && ty & aat_attr1) {
                    /* We have a mixed set of result nodes here
                       and need to use the attr column to find
                       all non-attribute nodes.  */
                    mvar_t *v = new_var (1);
                    execute (
                        assgn (var (v->name),
                               select2 (
                                   VAR (L(p)->env, pa_item, aat_pre1),
                                   cast (type (mty_oid), nil ()),
                                   cast (type (mty_oid), nil ()))),
                        assgn (var (v->name),
                               mirror (
                                   select_ (
                                       misnil (
                                           leftjoin (
                                               mirror (var (v->name)),
                                               VAR (L(p)->env,
                                                    pa_item,
                                                    aat_attr1))),
                                       lit_bit (true)))),
                        assgn (var (pre_tgt->name),
                               leftjoin (
                                   var (v->name),
                                   VAR (L(p)->env, pa_item, aat_pre1))),
                        assgn (var (pre_cont_tgt->name),
                               leftjoin (
                                   var (v->name),
                                   VAR (L(p)->env, pa_item, aat_frag1))));
                    unpin (v, 1);
                }
                else {
                    execute (
                        assgn (var (pre_tgt->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_oid), nil()))),
                        assgn (var (pre_cont_tgt->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_oid), nil()))));
                }

                /* consider attribute tgt */
                if (ty & aat_anode1 && !(ty & aat_nkind1)) {
                    /* only attr and no nkinds */
                    execute (
                        assgn (var (attr_tgt->name),
                               VAR (L(p)->env, pa_item, aat_attr1)),
                        assgn (var (attr_cont_tgt->name),
                               VAR (L(p)->env, pa_item, aat_frag1)));
                }
                else if (ty & aat_attr1) {
                    /* Because frag is shared for all nodes
                       we need the attr column to distinct
                       between attributes and non-attributes. */
                    mvar_t *v = new_var (1);
                    execute (
                        assgn (var (v->name),
                               select2 (
                                   VAR (L(p)->env, pa_item, aat_attr1),
                                   cast (type (mty_oid), nil ()),
                                   cast (type (mty_oid), nil ()))),
                        assgn (var (attr_tgt->name),
                               var (v->name)),
                        assgn (var (attr_cont_tgt->name),
                               leftjoin (
                                   mirror (var (v->name)),
                                   VAR (L(p)->env, pa_item, aat_frag1))));
                    unpin (v, 1);
                }
                else {
                    /* no attributes */
                    execute (
                        assgn (var (attr_tgt->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_oid), nil()))),
                        assgn (var (attr_cont_tgt->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_oid), nil()))));
                }


                /* consider strings  (which are arriving as aat_uA...) */
                if (ty & aat_uA)
                    execute (
                        assgn (var (replace_strings->name),
                               VAR (L(p)->env, pa_item, aat_uA)));
                else
                    execute (
                        assgn (var (replace_strings->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_str), nil()))));

                /* consider qnames */ 
                if (ty & aat_qname)
                    execute (
                        assgn (var (replace_qn_uristrings->name),
                            mposjoin (VAR (L(p)->env, pa_item, aat_qname_id),
                                      VAR (L(p)->env, pa_item, aat_qname_cont),
                                      fetch (var (PF_MIL_VAR_WS),
                                             var (PF_MIL_VAR_QN_URI)))),
                        assgn (var (replace_qn_loc_strings->name),
                            mposjoin (VAR (L(p)->env, pa_item, aat_qname_id),
                                      VAR (L(p)->env, pa_item, aat_qname_cont),
                                      fetch (var (PF_MIL_VAR_WS),
                                             var (PF_MIL_VAR_QN_LOC)))));
                else
                    execute (
                        assgn (var (replace_qn_uristrings->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_str), nil()))),
                        assgn (var (replace_qn_loc_strings->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_str), nil()))));

                /* consider node ins */
                if (ty & aat_pnode && !(ty & aat_attr)) {
                    /* all nodes but not attributes */
                    execute (
                        assgn (var (pre_ins->name),
                               VAR (L(p)->env, pa_item, aat_pre)),
                        assgn (var (pre_cont_ins->name),
                               VAR (L(p)->env, pa_item, aat_frag)));
                }
                else if (ty & aat_nkind && ty & aat_attr) {
                    /* We have a mixed set of result nodes here
                       and need to use the attr column to find
                       all non-attribute nodes.  */
                    mvar_t *v = new_var (1);
                    execute (
                        assgn (var (v->name),
                               select2 (
                                   VAR (L(p)->env, pa_item, aat_pre),
                                   cast (type (mty_oid), nil ()),
                                   cast (type (mty_oid), nil ()))),
                        assgn (var (v->name),
                               mirror (
                                   select_ (
                                       misnil (
                                           leftjoin (
                                               mirror (var (v->name)),
                                               VAR (L(p)->env,
                                                    pa_item,
                                                    aat_attr))),
                                       lit_bit (true)))),
                        assgn (var (pre_ins->name),
                               leftjoin (
                                   var (v->name),
                                   VAR (L(p)->env, pa_item, aat_pre))),
                        assgn (var (pre_cont_ins->name),
                               leftjoin (
                                   var (v->name),
                                   VAR (L(p)->env, pa_item, aat_frag))));
                    unpin (v, 1);
                }
                else {
                    execute (
                        assgn (var (pre_ins->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_oid), nil()))),
                        assgn (var (pre_cont_ins->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_oid), nil()))));
                }

                /* consider attribute ins */
                if (ty & aat_anode && !(ty & aat_nkind)) {
                    /* only attr and no nkinds */
                    execute (
                        assgn (var (attr_ins->name),
                               VAR (L(p)->env, pa_item, aat_attr)),
                        assgn (var (attr_cont_ins->name),
                               VAR (L(p)->env, pa_item, aat_frag)));
                }
                else if (ty & aat_attr) {
                    /* Because frag is shared for all nodes
                       we need the attr column to distinct
                       between attributes and non-attributes. */
                    mvar_t *v = new_var (1);
                    execute (
                        assgn (var (v->name),
                               select2 (
                                   VAR (L(p)->env, pa_item, aat_attr),
                                   cast (type (mty_oid), nil ()),
                                   cast (type (mty_oid), nil ()))),
                        assgn (var (attr_ins->name),
                               var (v->name)),
                        assgn (var (attr_cont_ins->name),
                               leftjoin (
                                   mirror (var (v->name)),
                                   VAR (L(p)->env, pa_item, aat_frag))));
                    unpin (v, 1);
                }
                else {
                    /* no attributes */
                    execute (
                        assgn (var (attr_ins->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_oid), nil()))),
                        assgn (var (attr_cont_ins->name),
                               project (var (upd_kind->name),
                                        cast (type (mty_oid), nil()))));
                }

                /* execute update_tape */
                execute (
                    update_tape (
                        arg (var (PF_MIL_VAR_WS),
                            arg (var (upd_kind->name),
                                arg (var (pre_tgt->name),
                                    arg (var (pre_cont_tgt->name),
                                        arg (var (attr_tgt->name),
                                            arg (var (attr_cont_tgt->name),
                        arg (var (replace_strings->name),
                            arg (var (replace_qn_uristrings->name),
                                arg (var (replace_qn_loc_strings->name),
                                    arg (var (pre_ins->name),
                                        arg (var (pre_cont_ins->name),
                                            arg (var (attr_ins->name),
                                                 var (attr_cont_ins->name)
                        ))))))))))))));  /* end of play update tape      */

                unpin (upd_kind, 1);
                unpin (pre_tgt, 1);
                unpin (pre_cont_tgt, 1);
                unpin (attr_tgt, 1);
                unpin (attr_cont_tgt, 1);
                unpin (replace_strings, 1);
                unpin (replace_qn_uristrings, 1);
                unpin (replace_qn_loc_strings, 1);
                unpin (pre_ins, 1);
                unpin (pre_cont_ins, 1);
                unpin (attr_ins, 1);
                unpin (attr_cont_ins, 1);

            } /* fold) */
            /* docmgmt query */
            else if (aat_docmgmt & type_of (L(p), pa_item)) { /* fold( */

                mvar_t *docmgmt  = new_var (1),
                       *docname  = new_var (1),
                       *colname  = new_var (1),
                       *filepath = new_var (1);

                ty = type_of (L(p), pa_item);

                /* consider docmgmt kind / percentage */
                execute (
                    assgn (var (docmgmt->name),
                           VAR (L(p)->env, pa_item, aat_docmgmt))
                );

                /* consider file path */
                if (ty & aat_path)
                    execute (
                        assgn (var (filepath->name),
                               VAR (L(p)->env, pa_item, aat_path)));
                else
                    execute (
                        assgn (var (filepath->name),
                               project (var (docmgmt->name),
                                        cast (type (mty_str), nil ()))));

                /* consider document names */
                execute (
                    assgn (var (docname->name),
                           VAR (L(p)->env, pa_item, aat_docnm)));

                /* consider colection names */
                if (ty & aat_colnm)
                    execute (
                        assgn (var (colname->name),
                               VAR (L(p)->env, pa_item, aat_colnm)));
                else
                    execute (
                        assgn (var (colname->name),
                               project (var (docmgmt->name),
                                        cast (type (mty_str), nil ()))));

                execute (
                    docmgmt_tape (
                        arg (var (PF_MIL_VAR_WS),
                            arg (var (filepath->name),
                                arg (var (docname->name),
                                    arg (var (colname->name),
                                         var (docmgmt->name)))))));

#ifdef HAVE_PFTIJAH
		/* INCOMPLETE, when the print is removed it is optimized out */
                execute (
		   if_(
		   	tj_docmgmt_tape (
			    var(PF_MIL_TIJAH_FTI_TAPE),
                            var (PF_MIL_VAR_WS),
                            var (filepath->name),
                            var (docname->name),
                            var (colname->name),
                            var (docmgmt->name)),
			 nil(),print(lit_str("INCOMPLETE fooled MIL optimizer")))
		);
#endif
                unpin (docmgmt, 1);
                unpin (docname, 1);
                unpin (colname, 1);
                unpin (filepath, 1);

            } /* fold) */
            /* it is a normal query (neither update nor document management) */
            else { /* fold( */
                mvar_t *intVAL, *dblVAL, *decVAL, *strVAL;
                mvar_t *item, *kind;
                bool sorted = false;

                /* Set up all the value containers for print_result().
                 * (It is actually too much overhead to introduce the value
                 * containers just for printing. But this way we can re-use
                 * Jan F's print_result() and stay compatible with the
                 * ``summer branch''.
                 */

                intVAL = new_var (1);
                dblVAL = new_var (1);
                decVAL = dblVAL;
                strVAL = new_var (1);
                item   = new_var (1);
                kind   = new_var (1);

                execute (
                    assgn (var (intVAL->name),
                           seqbase (
                               reverse (
                                   key (new (type (mty_lng), type (mty_void)),
                                        true)),
                               lit_oid (0))),
                    assgn (var (dblVAL->name),
                           seqbase (
                               reverse (
                                   key (new (type (mty_dbl), type (mty_void)),
                                        true)),
                               lit_oid (0))),
                    /*
                    assgn (var (decVAL->name),
                           seqbase (
                               reverse (
                                   key (new (type (mty_dbl), type (mty_void)),
                                    true)),
                               lit_oid (0))),
                    */
                    assgn (var (strVAL->name),
                           seqbase (
                               reverse (
                                   key (new (type (mty_str), type (mty_void)),
                                        true)),
                               lit_oid (0))),
                    assgn (var (item->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid(0))),
                    assgn (var (kind->name),
                           seqbase (new (type (mty_void), type (mty_int)),
                                    lit_oid(0)))
                    );

                ty = type_of (L(p), pa_item);

                /* consider attribute results */
                if (ty == aat_anode) {
                    execute (
                        assgn (var (item->name),
                               VAR (L(p)->env, pa_item, aat_attr)),
                        assgn (var (kind->name),
                               set_kind (VAR (L(p)->env,
                                              pa_item,
                                              aat_frag),
                                         var (PF_MIL_VAR_ATTR))));
                    sorted = true;
                }
                else if (ty & aat_attr) {
                    /* Because frag is shared for all nodes
                       we need the attr column to distinct
                       between attributes and non-attributes. */
                    mvar_t *v = new_var (1);
                    execute (
                        assgn (var (v->name),
                               select2 (
                                   VAR (L(p)->env, pa_item, aat_attr),
                                   cast (type (mty_oid), nil ()),
                                   cast (type (mty_oid), nil ()))),
                        binsert (var (item->name),
                                 var (v->name)),
                        binsert (var (kind->name),
                                 leftjoin (
                                     mirror (var (v->name)),
                                     set_kind (
                                         VAR (L(p)->env, pa_item, aat_frag),
                                         var (PF_MIL_VAR_ATTR)))));
                    unpin (v, 1);
                }

                /* consider node results */
                if (ty == aat_pnode) {
                    execute (
                        assgn (var (item->name),
                               VAR (L(p)->env, pa_item, aat_pre)),
                        assgn (var (kind->name),
                               set_kind (VAR (L(p)->env,
                                              pa_item,
                                              aat_frag),
                                         var (PF_MIL_VAR_ELEM))));
                    sorted = true;
                }
                else if (ty & aat_nkind && ty & aat_attr) {
                    /* We have a mixed set of result nodes here
                       and need to use the attr column to find
                       all non-attribute nodes.  */
                    mvar_t *v = new_var (1);
                    execute (
                        assgn (var (v->name),
                               select2 (
                                   VAR (L(p)->env, pa_item, aat_pre),
                                   cast (type (mty_oid), nil ()),
                                   cast (type (mty_oid), nil ()))),
                        assgn (var (v->name),
                               mirror (
                                   select_ (
                                       misnil (
                                           leftjoin (
                                               mirror (var (v->name)),
                                               VAR (L(p)->env,
                                                    pa_item,
                                                    aat_attr))),
                                       lit_bit (true)))),
                        binsert (var (item->name),
                                 leftjoin (var (v->name),
                                           VAR (L(p)->env, pa_item, aat_pre))),
                        binsert (var (kind->name),
                                 leftjoin (
                                     var (v->name),
                                     set_kind (
                                         VAR (L(p)->env, pa_item, aat_frag),
                                         var (PF_MIL_VAR_ELEM)))));
                    unpin (v, 1);
                }
                else if (ty & aat_nkind)
                    execute (
                        binsert (var (item->name),
                                 select2 (
                                     VAR (L(p)->env, pa_item, aat_pre),
                                     cast (type (mty_oid), nil ()),
                                     cast (type (mty_oid), nil ()))),
                        binsert (var (kind->name),
                                 select2 (
                                     set_kind (VAR (L(p)->env,
                                                    pa_item,
                                                    aat_frag),
                                               var (PF_MIL_VAR_ELEM)),
                                     cast (type (mty_int), nil ()),
                                     cast (type (mty_int), nil ()))));

                /* consider str results */
                if (ty & aat_str) {
                    execute (
                        bappend (var (strVAL->name),
                                 reverse (
                                     kunique (
                                         reverse (
                                             select2 (VAR (L(p)->env,
                                                           pa_item,
                                                           aat_str),
                                                      cast (type (mty_str),
                                                            nil ()),
                                                      cast (type (mty_str),
                                                            nil ()))
                                             )))));
                    if (ty == aat_str) {
                        execute (
                            assgn (
                                var (item->name),
                                leftjoin (VAR (L(p)->env, pa_item, aat_str),
                                          reverse (var (strVAL->name)))),
                            assgn (
                                var (kind->name),
                                project (VAR (L(p)->env, pa_item, aat_str),
                                         var (PF_MIL_VAR_STR)))
                            );
                        sorted = true;
                    }
                    else {
                        execute (
                            binsert (
                                var (item->name),
                                join (VAR (L(p)->env, pa_item, aat_str),
                                      reverse (var (strVAL->name)))),
                            binsert (
                                var (kind->name),
                                project (select2 (VAR (L(p)->env,
                                                       pa_item,
                                                       aat_str),
                                                  cast (type (mty_str),
                                                        nil ()),
                                                  cast (type (mty_str),
                                                        nil ())),
                                         var (PF_MIL_VAR_STR)))
                        );
                    }
                }

                /* consider untyped results */
                if (ty & aat_uA) {
                    execute (
                        bappend (var (strVAL->name),
                                 reverse (
                                     kunique (
                                         reverse (
                                             select2 (VAR (L(p)->env,
                                                           pa_item,
                                                           aat_uA),
                                                      cast (type (mty_str),
                                                            nil ()),
                                                      cast (type (mty_str),
                                                            nil ()))
                                             )))));
                    if (ty == aat_uA) {
                        execute (
                            assgn (
                                var (item->name),
                                leftjoin (VAR (L(p)->env, pa_item, aat_uA),
                                          reverse (var (strVAL->name)))),
                            assgn (
                                var (kind->name),
                                project (VAR (L(p)->env, pa_item, aat_uA),
                                         var (PF_MIL_VAR_STR)))
                            );
                        sorted = true;
                    }
                    else {
                        execute (
                            binsert (
                                var (item->name),
                                join (VAR (L(p)->env, pa_item, aat_uA),
                                      reverse (var (strVAL->name)))),
                            binsert (
                                var (kind->name),
                                project (select2 (VAR (L(p)->env,
                                                       pa_item,
                                                       aat_uA),
                                                  cast (type (mty_str),
                                                        nil ()),
                                                  cast (type (mty_str),
                                                        nil ())),
                                         var (PF_MIL_VAR_STR)))
                        );
                    }
                }

                /* consider int results */
                if (ty & aat_int) {
                    execute (
                        bappend (var (intVAL->name),
                                 reverse (
                                     kunique (
                                         reverse (
                                             select2 (VAR (L(p)->env,
                                                           pa_item,
                                                           aat_int),
                                                      cast (type (mty_lng),
                                                            nil ()),
                                                      cast (type (mty_lng),
                                                            nil ()))
                                             )))));
                    if (ty == aat_int) {
                        execute (
                            assgn (
                                var (item->name),
                                leftjoin (VAR (L(p)->env, pa_item, aat_int),
                                          reverse (var (intVAL->name)))),
                            assgn (
                                var (kind->name),
                                project (VAR (L(p)->env, pa_item, aat_int),
                                         var (PF_MIL_VAR_INT)))
                            );
                        sorted = true;
                    }
                    else {
                        execute (
                            binsert (
                                var (item->name),
                                join (VAR (L(p)->env, pa_item, aat_int),
                                      reverse (var (intVAL->name)))),
                            binsert (
                                var (kind->name),
                                project (select2 (VAR (L(p)->env,
                                                       pa_item,
                                                       aat_int),
                                                  cast (type (mty_lng),
                                                        nil ()),
                                                  cast (type (mty_lng),
                                                        nil ())),
                                         var (PF_MIL_VAR_INT)))
                        );
                    }
                }

                /* consider dbl results */
                if (ty & aat_dbl) {
                    execute (
                        bappend (var (dblVAL->name),
                                 reverse (
                                     kunique (
                                         reverse (
                                             select2 (VAR (L(p)->env,
                                                           pa_item,
                                                           aat_dbl),
                                                      cast (type (mty_dbl),
                                                            nil ()),
                                                      cast (type (mty_dbl),
                                                            nil ()))
                                             )))));
                    if (ty == aat_dbl) {
                        execute (
                            assgn (
                                var (item->name),
                                leftjoin (VAR (L(p)->env, pa_item, aat_dbl),
                                          reverse (var (dblVAL->name)))),
                            assgn (
                                var (kind->name),
                                project (VAR (L(p)->env, pa_item, aat_dbl),
                                         var (PF_MIL_VAR_DBL)))
                            );
                        sorted = true;
                    }
                    else {
                        execute (
                            binsert (
                                var (item->name),
                                join (VAR (L(p)->env, pa_item, aat_dbl),
                                      reverse (var (dblVAL->name)))),
                            binsert (
                                var (kind->name),
                                project (select2 (VAR (L(p)->env,
                                                       pa_item,
                                                       aat_dbl),
                                                  cast (type (mty_dbl),
                                                        nil ()),
                                                  cast (type (mty_dbl),
                                                        nil ())),
                                         var (PF_MIL_VAR_DBL)))
                        );
                    }
                }

                /* consider dec results */
                if (ty & aat_dec) {
                    execute (
                        bappend (var (decVAL->name),
                                 reverse (
                                     kunique (
                                         reverse (
                                             select2 (VAR (L(p)->env,
                                                           pa_item,
                                                           aat_dec),
                                                      cast (type (mty_dbl),
                                                            nil ()),
                                                      cast (type (mty_dbl),
                                                            nil ()))
                                             )))));
                    if (ty == aat_dec) {
                        execute (
                            assgn (
                                var (item->name),
                                leftjoin (VAR (L(p)->env, pa_item, aat_dec),
                                          reverse (var (decVAL->name)))),
                            assgn (
                                var (kind->name),
                                project (VAR (L(p)->env, pa_item, aat_dec),
                                         var (PF_MIL_VAR_DEC)))
                            );
                        sorted = true;
                    }
                    else {
                        execute (
                            binsert (
                                var (item->name),
                                join (VAR (L(p)->env, pa_item, aat_dec),
                                      reverse (var (decVAL->name)))),
                            binsert (
                                var (kind->name),
                                project (select2 (VAR (L(p)->env,
                                                       pa_item,
                                                       aat_dec),
                                                  cast (type (mty_dbl),
                                                        nil ()),
                                                  cast (type (mty_dbl),
                                                        nil ())),
                                         var (PF_MIL_VAR_DEC)))
                        );
                    }
                }

                /* consider bit results */
                if (ty & aat_bln) {
                    if (ty == aat_bln) {
                        execute (
                            assgn (
                                var (item->name),
                                mcast (type (mty_oid),
                                       VAR (L(p)->env, pa_item, aat_bln))),
                            assgn (
                                var (kind->name),
                                project (VAR (L(p)->env, pa_item, aat_bln),
                                         var (PF_MIL_VAR_BOOL)))
                            );
                        sorted = true;
                    }
                    else {
                        execute (
                            binsert (
                                var (item->name),
                                mcast (type (mty_oid),
                                       VAR (L(p)->env, pa_item, aat_bln))),
                            binsert (
                                var (kind->name),
                                project (select2 (VAR (L(p)->env,
                                                       pa_item,
                                                       aat_bln),
                                                  cast (type (mty_bit),
                                                        nil ()),
                                                  cast (type (mty_bit),
                                                        nil ())),
                                         var (PF_MIL_VAR_BOOL)))
                        );
                    }
                }

                if (!sorted)
                    execute (
                        assgn (var (item->name),
                               sort (var (item->name), DIR_ASC)),
                        assgn (var (kind->name),
                               leftjoin (mirror (var (item->name)),
                                         var (kind->name))));

                execute (
                    assgn (var (item->name),
                           reverse (mark (reverse (var (item->name)),
                                          lit_oid (0)))),
                    assgn (var (kind->name),
                           reverse (mark (reverse (var (kind->name)),
                                          lit_oid (0)))),

                    serialize (
                        arg (var (PF_MIL_VAR_GENTYPE),
                            arg (var (PF_MIL_VAR_WS),
                                arg (var (item->name),
                                    arg (var (kind->name),
                                        arg (var (intVAL->name),
                                            arg (var (dblVAL->name),
                                                arg (var (decVAL->name),
                                                     var (strVAL->name)))))))))
                        );

                unpin (intVAL, 1);
                unpin (dblVAL, 1);
                unpin (strVAL, 1);
                unpin (item, 1);
                unpin (kind, 1);

            } /* end of printing results */ /* fold) */

            /* add timing information */
            execute (
                assgn (var (PF_MIL_VAR_TIME_PRINT),
                       sub (usec (),
                            var (time->name))));
            unpin (time, 1);

            /* output trace information if available */
            if (global_trace_id != 1)
                execute (
                    trace (
                        arg (var (PF_MIL_VAR_WS),
                        arg (var (PF_MIL_VAR_TRACE_OUTER),
                        arg (var (PF_MIL_VAR_TRACE_INNER),
                        arg (var (PF_MIL_VAR_TRACE_ITER),
                        arg (var (PF_MIL_VAR_TRACE_MSG),
                        arg (var (PF_MIL_VAR_TRACE_ITEM),
                        arg (var (PF_MIL_VAR_TRACE_TYPE),
                             var (PF_MIL_VAR_TRACE_REL))))))))));

            /* make the old mil program the active one */
            bodymilprog = milprog;
            milprog = oldmilprog;

            err = new_var (1);

            execute (
                catch_ (var (err->name), bodymilprog),
                if_ (not (isnil (var (PF_MIL_VAR_WS))),
                     destroy_ws (var (PF_MIL_VAR_WS)),
                     nop ()),
                if_ (not (isnil (var (err->name))),
                     error (var (err->name)),
                     nop ()));

            unpin (err, 1);
        }   break; /* fold) */

        /* Query:   serialize (empty_tbl) */
        case 2: /* fold( */
        {
            mvar_t *intVAL, *dblVAL, *decVAL, *strVAL;
            mvar_t *item, *kind, *err, *time;
            PFmil_t *oldmilprog, *bodymilprog;

            /* save the current mil program */
            oldmilprog = milprog;

            /* create a new empty milprog */
            milprog = nop ();

            /* add timing information */
            time = new_var (1);
            execute (assgn (var (time->name), usec ()));

            /* Set up all the value containers for print_result().
             * (It is actually too much overhead to introduce the value
             * containers just for printing. But this way we can re-use
             * Jan F's print_result() and stay compatible with the
             * ``summer branch''.
             */

            intVAL = new_var (1);
            dblVAL = new_var (1);
            decVAL = new_var (1);
            strVAL = new_var (1);
            item = new_var (1);
            kind = new_var (1);

            execute (
                assgn (var (PF_MIL_VAR_WS), new_ws ()),
                assgn (
                    var (intVAL->name),
                    seqbase (new (type (mty_void), type (mty_lng)),
                             lit_oid (0))),
                assgn (
                    var (dblVAL->name),
                    seqbase (new (type (mty_void), type (mty_dbl)),
                             lit_oid (0))),
                assgn (
                    var (decVAL->name),
                    seqbase (new (type (mty_void), type (mty_dbl)),
                             lit_oid (0))),
                assgn (
                    var (strVAL->name),
                    seqbase (new (type (mty_void), type (mty_str)),
                             lit_oid (0))),
                assgn (
                    var (item->name),
                    seqbase (new (type (mty_void), type (mty_oid)),
                             lit_oid (0))),
                assgn (
                    var (kind->name),
                    seqbase (new (type (mty_void), type (mty_int)),
                             lit_oid (0))),
                serialize (
                    arg (lit_str ("xml"),
                        arg (var (PF_MIL_VAR_WS),
                            arg (var (item->name),
                                arg (var (kind->name),
                                    arg (var (intVAL->name),
                                        arg (var (dblVAL->name),
                                            arg (var (decVAL->name),
                                                 var (strVAL->name))))))))));

            unpin (intVAL, 1);
            unpin (dblVAL, 1);
            unpin (decVAL, 1);
            unpin (strVAL, 1);
            unpin (item, 1);
            unpin (kind, 1);

            /* add timing information */
            execute (
                assgn (var (PF_MIL_VAR_TIME_PRINT),
                       sub (usec (),
                            var (time->name))));
            unpin (time, 1);

            /* make the old mil program the active one */
            bodymilprog = milprog;
            milprog = oldmilprog;

            err = new_var (1);

            execute (
                catch_ (var (err->name), bodymilprog),
                if_ (not (isnil (var (PF_MIL_VAR_WS))),
                     destroy_ws (var (PF_MIL_VAR_WS)),
                     nop ()),
                if_ (not (isnil (var (err->name))),
                     error (var (err->name)),
                     nop ()));

            unpin (err, 1);
        } break; /* fold) */

        /* Rel:      lit_tbl */
        case 10: /* fold( */
            /* iterate over table columns */
            for (unsigned int col = 0; col < p->schema.count; col++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & TYPE_MASK(p->schema.items[col].type)) {
                        mvar_t *v = new_var (p->refctr);
                        env_add (p->env, p->schema.items[col].name, t, v);

                        execute (
                            assgn (
                                var (v->name),
                                seqbase (
                                    new (type (mty_void), implty (t)),
                                    lit_oid (0))));

                        for (unsigned int row = 0;
                                row < p->sem.lit_tbl.count; row++)
                            execute (
                                append (
                                    var (v->name),
                                    t & p->sem.lit_tbl.tuples[row]
                                                      .atoms[col].type
                                    ? literal_ (p->sem.lit_tbl.tuples[row]
                                                              .atoms[col], t)
                                    : cast (implty (t), nil ())));

                        execute (access (var (v->name), BAT_READ));
                    }
            break; /* fold) */

        /* Rel:     empty_tbl */
        case 11: /* fold( */
            PFoops (OOPS_FATAL,
                    "empty sequence should never occur in MIL generation."
                    " (optimizations disabled?)");
            break; /* fold) */

        /* Rel:      attach (Rel) */
        case 12: /* fold( */
            /* copy all the existing variables */
            env_copy (p, L(p)->env);

            /* Cope with literal QNames differently
               (as QNames are represented by a id/cont pair). */
            if (p->sem.attach.value.type == aat_qname) {
                mvar_t *id   = new_var (p->refctr);
                mvar_t *cont = new_var (p->refctr);
                env_add (p->env, p->sem.attach.attname, aat_qname_id, id);
                env_add (p->env, p->sem.attach.attname, aat_qname_cont, cont);

                execute (
                    assgn (var (id->name),
                           project (ANY_VAR(p->env),
                                    literal_ (p->sem.attach.value,
                                              aat_qname_id))),
                    assgn (var (cont->name),
                           project (ANY_VAR(p->env),
                                    literal_ (p->sem.attach.value,
                                              aat_qname_cont))));
            }
            else {
                /* now create the new column */
                mvar_t *v = new_var (p->refctr);
                env_add (p->env, p->sem.attach.attname,
                         p->sem.attach.value.type, v);

                execute (
                    assgn (var (v->name),
                           project (ANY_VAR(p->env),
                                    literal (p->sem.attach.value))));
            }
            break; /* fold) */

        /* Rel:      cross (Rel, Rel) */
        case 13: /* fold( */
        {
            mvar_t *v  = new_var (1);
            mvar_t *v1 = new_var (1);
            mvar_t *v2 = new_var (1);

            if (!env_count (L(p)->env) || !env_count (R(p)->env))
                PFoops (OOPS_FATAL, "Cross does not cope with empty schemas");

            /* The cross product of two relations with cardinality 1
               requires no MIL code. */
            if (PFprop_card (L(p)->prop) == 1 &&
                PFprop_card (R(p)->prop) == 1) {
                env_copy (p, L(p)->env);
                env_copy (p, R(p)->env);
            }
            else {
                /* evaluate the cross product and create two map relations */
                execute (
                    assgn (var (v->name),
                           cross (
                               project (ANY_VAR(L(p)->env), nil ()),
                               reverse (project (ANY_VAR(R(p)->env), nil ())))),
                    assgn (var (v1->name),
                           reverse (mark (var (v->name), lit_oid (0)))),
                    assgn (var (v2->name),
                           reverse (mark (reverse (var (v->name)),
                                          lit_oid (0)))));

                /* map all columns from the left and the right argument */
                env_map (p, L(p)->env, v1);
                env_map (p, R(p)->env, v2);
            }

            unpin (v, 1);
            unpin (v1, 1);
            unpin (v2, 1);
        }   break; /* fold) */

        /* Rel:      leftjoin (Rel, Rel) */
        case 14:
        /* Rel:      eqjoin (Rel, Rel) */
        case 15:
        /* Rel:      semijoin (Rel, Rel) */
        case 16: /* fold( */
        {
            /*
             * We actually cannot guarantee that MonetDB applies a
             * MergeJoin (tactical optimization may choose other
             * implementations). By using leftjoin(), however, we
             * can guarantee the result to be correctly ordered.
             */
            PFalg_simple_type_t lty = type_of (L(p), p->sem.eqjoin.att1);
            PFalg_simple_type_t rty = type_of (R(p), p->sem.eqjoin.att2);
            mvar_t *l  = NULL;
            mvar_t *r  = NULL;
            mvar_t *v  = new_var (1);
            mvar_t *v1 = new_var (1);
            mvar_t *v2 = new_var (1);


            if (type_bit_check (lty)) {
                if (lty != rty)
                    PFoops (OOPS_FATAL, "incompatible types in Join");

                l = env_mvar (L(p)->env, p->sem.eqjoin.att1, lty);
                r = env_mvar (R(p)->env, p->sem.eqjoin.att2, rty);
            }
            else {
                /* If this case is ever triggered this means we have
                   either an erroneous predicate or a join on nodes.
                   In the latter case this join should be replaced
                   by a thetajoin. */
                PFoops (OOPS_FATAL,
                        "multi-predicate joins are not supported yet");
            }

            if (p->kind == pa_semijoin) {
                /* evaluate the semijoin and create the map relation */
                execute (
                    assgn (var (v->name),
                           kintersect (reverse (var (l->name)),
                                       reverse (var (r->name)))),
                    assgn (var (v1->name),
                           tmark (var (v->name), lit_oid (0))));

                /* map all columns from the left argument */
                env_map (p, L(p)->env, v1);
            }
            else {
                /* evaluate the join and create two map relations */
                execute (
                    assgn (var (v->name),
                           leftjoin (var (l->name), reverse (var (r->name)))),
                    assgn (var (v1->name),
                           reverse (mark (var (v->name), lit_oid (0)))),
                    assgn (var (v2->name),
                           reverse (
                               mark (reverse (var (v->name)), lit_oid (0)))));

                /* map all columns from the left and the right argument */
                env_map (p, L(p)->env, v1);
                env_map (p, R(p)->env, v2);
            }

            unpin (v, 1);
            unpin (v1, 1);
            unpin (v2, 1);
        }   break; /* fold) */

        /* Rel:      thetajoin (Rel, Rel) */
        case 17: /* fold( */
        {
            bool                initialized = false;
            PFalg_att_t         latt,
                                ratt;
            PFalg_simple_type_t lty  = 0,
                                rty  = 0;
            PFmil_t            *(*op) (const PFmil_t *, const PFmil_t *);
            PFmil_t            *comp;
            mvar_t             *l    = new_var (1),
                               *r    = new_var (1),
                               *res  = new_var (1),
                               *lmap = new_var (1),
                               *rmap = new_var (1);
            PFalg_schema_t      left,
                                right;

            /* initialize schemas for equi-join predicates */
            left.count  = 0;
            right.count = 0;
            left.items  = PFmalloc (p->schema.count * sizeof (*(left.items)));
            right.items = PFmalloc (p->schema.count * sizeof (*(right.items)));

            /* first collect all equi-join predicates */
            for (unsigned int i = 0; i < p->sem.thetajoin.count; i++)
                if (p->sem.thetajoin.pred[i].comp == alg_comp_eq) { /* fold( */
                    initialized = true;

                    latt = p->sem.thetajoin.pred[i].left;
                    ratt = p->sem.thetajoin.pred[i].right;
                    lty  = type_of (L(p), latt);
                    rty  = type_of (R(p), ratt);

                    left.items[left.count++] =
                        (struct PFalg_schm_item_t)
                            { .name = latt, .type = lty };
                    right.items[right.count++] =
                        (struct PFalg_schm_item_t)
                            { .name = ratt, .type = rty };

                } /* fold) */

            /* apply the multi-column equi-join */
            if (initialized) {
                /* apply the intersection on all equality predicates */
                intersect (p, left, right, res);

                execute (assgn (var (lmap->name),
                                reverse (mark (var (res->name), lit_oid (0)))),
                         assgn (var (rmap->name),
                                reverse (mark (reverse (var (res->name)),
                                               lit_oid (0)))));
            }

            /* If there was no equality predicate apply a normal inequality
               thetajoin to the first predicate.
               For all remaining predicates (also the ones that appear in
               combination with equi-join predicates we apply a selection
               (post) filter. */
            for (unsigned int i = 0; i < p->sem.thetajoin.count; i++)
                if (p->sem.thetajoin.pred[i].comp != alg_comp_eq) { /* fold( */
                    op   = NULL;
                    comp = NULL;
                    /* find the correct comparison */
                    switch (p->sem.thetajoin.pred[i].comp) {
                        case alg_comp_eq:
                            op   = PFmil_meq;
                            comp = var (PF_MIL_VAR_EQ); break;
                        case alg_comp_gt:
                            op   = PFmil_mgt;
                            comp = var (PF_MIL_VAR_GT); break;
                        case alg_comp_ge:
                            op   = PFmil_mge;
                            comp = var (PF_MIL_VAR_GE); break;
                        case alg_comp_lt:
                            op   = PFmil_mlt;
                            comp = var (PF_MIL_VAR_LT); break;
                        case alg_comp_le:
                            op   = PFmil_mle;
                            comp = var (PF_MIL_VAR_LE); break;
                        case alg_comp_ne:
                            op   = PFmil_mne;
                            break;
                        default:
                            PFoops (OOPS_FATAL, "incorrect comparison");
                    }

                    /* prepare the join columns for an inequality
                       predicate (map multiple columns into a single
                       BAT) */
                    prepare_comp (L(p), R(p),
                                  p->sem.thetajoin.pred[i].left,
                                  p->sem.thetajoin.pred[i].right,
                                  l, r);

                    if (!initialized) {
                        /* As there was no equi-join condition and
                           this is the first inequality predicate
                           we evaluate a thetajoin */
                        execute (assgn (var (res->name),
                                        tjoin (
                                            var (l->name),
                                            reverse (var (r->name)),
                                            comp,
                                            PFmil_mmult (
                                                count (var (r->name)),
                                                lit_lng (64)))),
                                 assgn (var (lmap->name),
                                        reverse (mark (var (res->name),
                                                       lit_oid (0)))),
                                 assgn (var (rmap->name),
                                        reverse (
                                            mark (reverse (var (res->name)),
                                                  lit_oid (0)))));
                    } else {
                        /* apply a (post) filter and update
                           the mapping relations lmap and rmap */
                        execute (
                            assgn (
                                var (res->name),
                                op (leftjoin (var (lmap->name), var (l->name)),
                                    leftjoin (var (rmap->name), var (r->name)))),
                            assgn (
                                var (res->name),
                                reverse (
                                    mark (select_ (var (res->name),
                                                   lit_bit (true)),
                                          lit_oid (0)))),
                            assgn (
                                var (lmap->name),
                                leftjoin (var (res->name), var (lmap->name))),
                            assgn (
                                var (rmap->name),
                                leftjoin (var (res->name), var (rmap->name))));
                    }

                    initialized = true;
                } /* fold) */

            /* map all columns from the left and the right argument */
            env_map (p, L(p)->env, lmap);
            env_map (p, R(p)->env, rmap);

            /* release temporary variables */
            unpin (l, 1);
            unpin (r, 1);
            unpin (res, 1);
            unpin (lmap, 1);
            unpin (rmap, 1);
        }   break; /* fold) */

        /* Rel:      unq2_thetajoin (Rel, Rel) */
        case 18:
        /* Rel:      unq1_thetajoin (Rel, Rel) */
        case 19: /* fold( */
        {
            PFalg_att_t latt, ratt, ldist_att, rdist_att;
            PFalg_simple_type_t lty, rty, ldist_ty, rdist_ty;
            PFmil_t *comp;
            mvar_t *l     = NULL,
                   *r     = NULL,
                   *ldist = NULL,
                   *rdist = NULL,
                   *v     = new_var (1),
                   *v1,
                   *v2;

            latt      = p->sem.unq_thetajoin.left;
            ratt      = p->sem.unq_thetajoin.right;
            ldist_att = p->sem.unq_thetajoin.ldist;
            rdist_att = p->sem.unq_thetajoin.rdist;

            lty      = type_of (L(p), latt);
            rty      = type_of (R(p), ratt);
            ldist_ty = type_of (L(p), ldist_att);
            rdist_ty = type_of (R(p), rdist_att);

            if (type_bit_check (lty) && type_bit_check (ldist_ty)) {
                if (lty != rty || ldist_ty != rdist_ty)
                    PFoops (OOPS_FATAL, "incompatible types in Theta-Join");

                l     = env_mvar (L(p)->env, latt, lty);
                r     = env_mvar (R(p)->env, ratt, rty);
                ldist = env_mvar (L(p)->env, ldist_att, ldist_ty);
                rdist = env_mvar (R(p)->env, rdist_att, rdist_ty);
            }
            else {
                /* If this case is ever triggered this means we have
                   either an erroneous predicate or a join on nodes.
                   In the latter case this join should be replaced
                   by a thetajoin. */
                PFoops (OOPS_FATAL,
                        "multi-predicate theta-joins are not supported yet");
            }

            /* find the correct comparison */
            switch (p->sem.unq_thetajoin.comp) {
                case alg_comp_eq: comp = var (PF_MIL_VAR_EQ); break;
                case alg_comp_gt: comp = var (PF_MIL_VAR_GT); break;
                case alg_comp_ge: comp = var (PF_MIL_VAR_GE); break;
                case alg_comp_lt: comp = var (PF_MIL_VAR_LT); break;
                case alg_comp_le: comp = var (PF_MIL_VAR_LE); break;
                default:
                    PFoops (OOPS_FATAL, "incorrect comparison");
            }

            if (p->kind == pa_unq2_thetajoin) {
                v1 = new_var (p->refctr);
                v2 = new_var (p->refctr);

                /* apply the duplicate removing thetajoin */
                execute (
                    assgn (var (v->name),
                           unq2_tjoin (leftjoin (reverse (var (ldist->name)),
                                                 var (l->name)),
                                       leftjoin (reverse (var (rdist->name)),
                                                 var (r->name)),
                                       comp)),
                    assgn (var (v1->name),
                           reverse (mark (var (v->name), lit_oid (0)))),
                    assgn (var (v1->name),
                           assert_order (var (v1->name))),
                    assgn (var (v2->name),
                           reverse (mark (reverse (var (v->name)),
                                          lit_oid (0)))));

                /* add the two result columns to the environment */
                env_add (p->env, ldist_att, ldist_ty, v1);
                env_add (p->env, rdist_att, rdist_ty, v2);
            }
            else if (p->kind == pa_unq1_thetajoin) {
                v1 = new_var (p->refctr);

                /* apply the duplicate removing thetajoin */
                execute (
                    assgn (var (v->name),
                           unq1_tjoin (
                               leftjoin (reverse (var (ldist->name)),
                                         var (l->name)),
                               leftjoin (reverse (var (rdist->name)),
                                         var (r->name)),
                               var (ldist->name),
                               var (rdist->name),
                               comp)),
                    assgn (var (v1->name),
                           reverse( mark (var (v->name), lit_oid (0)))));

                /* add the result column to the environment */
                env_add (p->env, ldist_att, ldist_ty, v1);
            }
            else
                PFoops (OOPS_FATAL,
                        "incompatible operator in theta-join translation");

            unpin (v, 1);
        }   break; /* fold) */

        /* Rel:      project (Rel) */
        case 20: /* fold( */
            /*
             * Algebra projection is a no-op. We only fill the
             * environment in node p appropriately.
             */
            for (unsigned int i = 0; i < p->sem.proj.count; i++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & TYPE_MASK(type_of (L(p),
                                               p->sem.proj.items[i].old))) {
                        mvar_t *v = env_mvar (L(p)->env,
                                              p->sem.proj.items[i].old,
                                              t);
                        env_add (p->env, p->sem.proj.items[i].new, t, v);
                        pin (v, p->refctr);
                    }
            break; /* fold) */

        /* Rel:      select (Rel) */
        case 21: /* fold( */
        {
            mvar_t *v = new_var (1);

            /*
             * For the predicate column c do
             *
             *  v := c.uselect (true).mark (0@0).reverse ();
             */
            execute (
                assgn (
                    var (v->name),
                    reverse (
                        mark (
                            select_(VAR (L(p)->env, p->sem.select.att,aat_bln),
                                    lit_bit (true)),
                            lit_oid (0)))));

            /* map all columns from the argument */
            env_map (p, L(p)->env, v);

            /* release v */
            unpin (v, 1);
        }   break; /* fold) */

        /* Rel:      val_select (Rel) */
        case 22: /* fold( */
        {
            mvar_t *v = new_var (1);

            assert (type_of (p, p->sem.attach.attname) ==
                    p->sem.attach.value.type);

            if (!type_bit_check (p->sem.attach.value.type))
                /* If this case is ever triggered this means we have
                   either an erroneous predicate or a selection on
                   nodes or qnames. */
                PFoops (OOPS_FATAL,
                        "multi-predicate selections are not supported yet");

            /*
             * For the predicate column c do
             *
             *  v := c.uselect (atom).mark (0@0).reverse ();
             */
            execute (
                assgn (
                    var (v->name),
                    reverse (
                        mark (
                            uselect (VAR (L(p)->env,
                                          p->sem.attach.attname,
                                          type_of (p, p->sem.attach.attname)),
                                     literal (p->sem.attach.value)),
                            lit_oid (0)))));

            /* map all columns from the argument */
            env_map (p, L(p)->env, v);

            /* release v */
            unpin (v, 1);
        }   break; /* fold) */

        /* Rel:      append_union (Rel, Rel) */
        case 23: /* fold( */
        {
            PFalg_att_t         att;
            PFalg_simple_type_t lty, rty;
            for (unsigned int i = 0; i < p->schema.count; i++) {
                att = p->schema.items[i].name;
                lty = type_of (L(p), att);
                rty = type_of (R(p), att);
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & TYPE_MASK(p->schema.items[i].type)) {

                        mvar_t *v = new_var (p->refctr);

                        /*
                         * Type t is in the result relation. See if it
                         * is also in the left operand.
                         */
                        if (t & lty)
                            /* v := l.copy */
                            execute (
                                assgn (
                                    var (v->name),
                                    access (
                                        copy (VAR (L(p)->env, att, t)),
                                        BAT_APPEND)));
                        else
                            /* v := <some BAT of L>.project(nil); */
                            execute (
                                assgn (
                                    var (v->name),
                                    access (
                                        project (
                                            ANY_VAR(L(p)->env),
                                            cast (implty (t), nil ())),
                                        BAT_APPEND)));

                        /*
                         * Is t also in the right operand?
                         */
                        if (t & rty)
                            /* v.append(R); */
                            execute (
                                access (
                                    bappend (
                                        var (v->name),
                                        VAR (R(p)->env, att, t)),
                                    BAT_READ));
                        else
                            /* v.append(<some BAT of L>.project(nil)); */
                            execute (
                                access (
                                    bappend (
                                        var (v->name),
                                        project (
                                            ANY_VAR(R(p)->env),
                                            cast (implty (t), nil ()))),
                                    BAT_READ));

                        env_add (p->env, att, t, v);
                    }
            }
        }   break; /* fold) */

        /* Rel:      merge_union (Rel, Rel) */
        case 25: /* fold( */
        {
            PFalg_att_t         grp_att;
            PFalg_simple_type_t grp_ty;
            PFmil_t            *args;
            mvar_t             *v = new_var (1);

            if (PFord_count (p->sem.merge_union.ord) != 1 ||
                PFord_order_dir_at (p->sem.merge_union.ord, 0) != DIR_ASC)
                PFoops (OOPS_FATAL,
                        "MergeUnion for more complex orderings "
                        "is not implemented (got %s)",
                        PFord_str (p->sem.merge_union.ord));

            grp_att = PFord_order_col_at (p->sem.merge_union.ord, 0);
            grp_ty  = type_of (p, grp_att);

            if (!type_bit_check (grp_ty) ||
                type_of (L(p), grp_att) != grp_ty ||
                type_of (R(p), grp_att) != grp_ty)
                PFoops (OOPS_FATAL,
                        "cannot handle polymorphic grouping columns "
                        " in the merge-union translation for MIL");

            /* first two arguments of merged_union() are the grouping atts */
            args = arg (VAR (L(p)->env, grp_att, grp_ty),
                        VAR (R(p)->env, grp_att, grp_ty));

            for (unsigned int i = 0; i < p->schema.count; i++)
                if (p->schema.items[i].name != grp_att)
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & TYPE_MASK(p->schema.items[i].type))
                            for (unsigned short j = 0; j <= 1; j++) {
                                /*
                                 * If t is among the operand's types, use the
                                 * corresponding BAT, otherwise substitute a
                                 * BAT with `nil' tail.
                                 */
                                if (t & type_of (p->child[j],
                                                 p->schema.items[i].name))
                                    args = arg (args,
                                                VAR (p->child[j]->env,
                                                     p->schema.items[i].name,
                                                     t));
                                else
                                    args = arg (args,
                                                project (
                                                    ANY_VAR (p->child[j]->env),
                                                    cast (implty(t), nil ())));
                            }

            /* execute merged_union() and assign it to v */
            execute (assgn (var (v->name), merged_union (args)));

            /* All BATs are returned in the order they were fed into
               the merged_union operator. This means the grouping
               column comes first and then all columns in the order
               of the above for loops follow. We therefore use the
               same loops to align the column names and types
               with the result columns. */
            unsigned int j = 1;

            /* now extract all the result BATs */
            for (unsigned int i = 0; i < p->schema.count; i++) {
                /* The grouping attribute is to be found
                   as the first result BAT. */
                if (p->schema.items[i].name == grp_att) {
                    mvar_t *w = new_var (p->refctr);
                    env_add (p->env, p->schema.items[i].name, grp_ty, w);
                    execute (assgn (var (w->name),
                             fetch (var (v->name), lit_int (0))));
                }
                else {
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & TYPE_MASK(p->schema.items[i].type)) {
                            mvar_t *w = new_var (p->refctr);

                            execute (assgn (var (w->name),
                                     fetch (var (v->name), lit_int (j))));
                            env_add (p->env, p->schema.items[i].name, t, w);
                            j++;
                        }
                }
            }

            /* release our temporary variable v */
            unpin (v, 1);
        }   break; /* fold) */

        /* Rel:      intersect (Rel, Rel) */
        case 26: /* fold( */
        {
            PFalg_att_t         att;
            PFalg_simple_type_t lty,
                                rty;
            PFalg_schema_t      left,
                                right;
            mvar_t             *res = new_var (1);

            /* initialize schemas for equi-join predicates */
            left.count  = 0;
            right.count = 0;
            left.items  = PFmalloc (p->schema.count * sizeof (*(left.items)));
            right.items = PFmalloc (p->schema.count * sizeof (*(right.items)));

            /* collect the aligned list of columns (in preparation for
               the intersect worker) */
            for (unsigned int i = 0; i < p->schema.count; i++) {
                    att = p->schema.items[i].name;
                    lty = type_of (L(p), att);
                    rty = type_of (R(p), att);
                    left.items[left.count++] =
                        (struct PFalg_schm_item_t) { .name = att, .type = lty };
                    right.items[right.count++] =
                        (struct PFalg_schm_item_t) { .name = att, .type = rty };
            }

            /* apply the intersection */
            intersect (p, left, right, res);

            execute (assgn (var (res->name),
                            reverse (
                                mark (tunique (reverse (var (res->name))),
                                      lit_oid (0)))));

            /* map all columns from the argument */
            env_map (p, L(p)->env, res);

            unpin (res, 1);
        }   break; /* fold) */

        /* Rel:      difference (Rel, Rel) */
        case 27: /* fold( */
            /* in most cases we only have a single column (difference based
               on iter) where we can choose a more efficient variant. */
            if (env_count (L(p)->env) == 1 &&
                env_count (R(p)->env) == 1 &&
                L(p)->schema.items[0].type == R(p)->schema.items[0].type) {
                mvar_t *res = new_var (p->refctr);

                execute (
                    assgn (var (res->name),
                           reverse (
                               mark (
                                   kdiff (
                                       reverse (
                                           var (env_at (L(p)->env,
                                                        0).mvar->name)),
                                       reverse (
                                           var (env_at (R(p)->env,
                                                        0).mvar->name))),
                                   lit_oid (0)))));

                env_add (p->env,
                         env_at (L(p)->env, 0).att,
                         env_at (L(p)->env, 0).ty,
                         res);
            }
            else {
                /* First apply the intersection like the intersect operator
                   and then build the difference of the left side and the
                   result of the intersection. */
                PFalg_att_t         att;
                PFalg_simple_type_t lty,
                                    rty;
                PFalg_schema_t      left,
                                    right;
                mvar_t             *res = new_var (1);

                /* initialize schemas for equi-join predicates */
                left.count  = 0;
                right.count = 0;
                left.items  = PFmalloc (p->schema.count *
                                        sizeof (*(left.items)));
                right.items = PFmalloc (p->schema.count *
                                        sizeof (*(right.items)));

                /* collect the aligned list of columns (in preparation for
                   the intersect worker) */
                for (unsigned int i = 0; i < p->schema.count; i++) {
                        att = p->schema.items[i].name;
                        lty = type_of (L(p), att);
                        rty = type_of (R(p), att);
                        left.items[left.count++] =
                            (struct PFalg_schm_item_t)
                                { .name = att, .type = lty };
                        right.items[right.count++] =
                            (struct PFalg_schm_item_t)
                                { .name = att, .type = rty };
                }

                /* apply the intersection */
                intersect (p, left, right, res);

                /* build the difference */
                execute (
                    assgn (var (res->name),
                           reverse (
                               mark (
                                   kdiff (ANY_VAR(L(p)->env),
                                          var (res->name)),
                                   lit_oid (0)))));

                /* map all columns from the argument */
                env_map (p, L(p)->env, res);

                unpin (res, 1);
            }
            break; /* fold) */

        /* Rel:      sort_distinct (Rel) */
        case 30:
        /* Rel:      sort_distinct (std_sort (Rel)) */
        case 31:
        /* Rel:      sort_distinct (refine_sort (Rel)) */
        case 32: /* fold( */
        /* as we have to sort anyway we can also skip the sort operator */
        {
            /*
             * Derive a single BAT from the multi-column grouping
             * (using functions from the xtables module).
             */
            PFord_ordering_t    ord = p->sem.sort_distinct.ord;
            PFpa_op_t          *rel;
            mvar_t             *v = new_var (1);

            if (L(p)->kind == pa_std_sort || L(p)->kind == pa_refine_sort)
                rel = LL(p);
            else
                rel = L(p);

            if (!PFord_count (ord))
                /* cope with completely constant relations */
                execute (assgn (var (v->name), ANY_VAR(rel->env)));
            else
                /* create the MIL code that stores
                   the ordered extend in variable v */
                order_extend (rel, ord, v);

            /* apply the duplicate elimination */
            execute (
                assgn (var (v->name),
                       tmark (kunique (reverse (var (v->name))),
                              lit_oid (0))));

            /* map all columns from the argument */
            env_map (p, rel->env, v);

             /* we know that the first sort criterion certainly is sorted
                -- assert_order however only copes with ascending order */
            if (PFord_count (ord) &&
                PFord_order_dir_at (ord, 0) == DIR_ASC) {
                PFalg_att_t att = PFord_order_col_at (ord, 0);
                PFalg_simple_type_t ty = type_of (rel, att);
                if (type_bit_check(ty))
                    execute (
                        assgn (VAR(p->env, att, ty),
                               assert_order (VAR(p->env, att, ty))));
            }

            /* release our temporary variable */
            unpin (v, 1);
        }   break; /* fold) */

        /* Rel:      std_sort (Rel) */
        case 33: /* fold( */
            /* handle the case that a sort does nothing */
            if (!PFord_count (p->sem.sortby.required))
                env_copy (p, L(p)->env);
            else {
                PFord_ordering_t ord = p->sem.sortby.required;
                mvar_t          *v   = new_var (1);

                /* create the MIL code that stores
                   the ordered extend in variable v */
                order_extend (L(p), ord, v);

                /* prepare the map relation */
                execute (
                    assgn (var (v->name),
                           reverse (mark (var (v->name), lit_oid (0)))));

                /* map all columns from the argument */
                env_map (p, L(p)->env, v);

                 /* we know that the first sort criterion certainly is sorted
                    -- assert_order however only copes with ascending order */
                if (PFord_count (ord) &&
                    PFord_order_dir_at (ord, 0) == DIR_ASC) {
                    PFalg_att_t att = PFord_order_col_at (ord, 0);
                    PFalg_simple_type_t ty = type_of (L(p), att);
                    if (type_bit_check(ty))
                        execute (
                            assgn (VAR(p->env, att, ty),
                                   assert_order (VAR(p->env, att, ty))));
                }

                /* release our temporary variable */
                unpin (v, 1);
            }
            break; /* fold) */

        /* Rel:      refine_sort (Rel) */
        case 34: /* fold( */
        {
            PFord_ordering_t ord = p->sem.sortby.required;
            mvar_t          *v   = new_var (1);
            unsigned int     i,
                             j;

            /* create the MIL code that stores
               the ordered extend in variable v */
            order_extend (L(p), ord, v);

            /* prepare the map relation */
            execute (
                assgn (var (v->name),
                       reverse (mark (var (v->name), lit_oid (0)))));

            /* map all columns from the argument */
            for (i = 0; i < env_count (L(p)->env); i++) {
                /* all columns that ensure the already existing order
                   stay unchanged. */
                for (j = 0; j < PFord_count (p->sem.sortby.existing); j++)
                    if (PFord_order_col_at (p->sem.sortby.existing, j) ==
                        env_at (L(p)->env, i).att) {
                        env_t entry = env_at (L(p)->env, i);
                        env_add (p->env, entry.att, entry.ty, entry.mvar);
                        pin (entry.mvar, p->refctr);
                        break;
                    }

                /* adjust the ordering for all other columns */
                if (j == PFord_count (p->sem.sortby.existing)) {
                    mvar_t *tmp  = new_var (p->refctr);
                    /* expand variables */
                    execute (
                        assgn (var (tmp->name),
                               leftjoin (var (v->name),
                                         var (env_at (L(p)->env,
                                                      i).mvar->name))),
                        /* because leftjoin does not know that we have
                           exactly one match for each tuple in v,
                           we need to make the heads void ourselves */
                        assgn (var (tmp->name),
                               reverse (mark (reverse (var (tmp->name)),
                                              lit_oid (0)))));

                    env_add (p->env,
                             env_at (L(p)->env, i).att,
                             env_at (L(p)->env, i).ty,
                             tmp);
                }
            }

            /* release our temporary variable */
            unpin (v, 1);
        }   break; /* fold) */

        /* Rel:      fun_1to1 (Rel) */
        case 40: /* fold( */
        {
            /* result variable */
            mvar_t             *res = new_var (p->refctr);
            PFalg_simple_type_t res_type = 0;

            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            switch (p->sem.fun_1to1.kind) {
                case alg_fun_num_add:
                case alg_fun_num_subtract:
                case alg_fun_num_multiply:
                case alg_fun_num_divide:
                case alg_fun_num_modulo:
                case alg_fun_fn_concat: /* fold( */
                {
                    PFmil_t * (*op) (const PFmil_t *, const PFmil_t *) = NULL;
                    PFalg_att_t att1, att2;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = type_of (L(p), att1);

                    assert (res_type == type_of (L(p), att2));
                    assert (res_type == aat_int || res_type == aat_dec ||
                            res_type == aat_dbl || res_type == aat_str);

                    switch (p->sem.fun_1to1.kind) {
                        case alg_fun_fn_concat:
                        case alg_fun_num_add:
                            op = PFmil_madd; break;
                        case alg_fun_num_subtract:
                            op = PFmil_msub; break;
                        case alg_fun_num_multiply:
                            op = PFmil_mmult; break;
                        case alg_fun_num_divide:
                            op = PFmil_mdiv; break;
                        case alg_fun_num_modulo:
                            op = PFmil_mmod; break;
                        default:
                            break;
                    }

                    /* do the arithmetics */
                    execute (
                        assgn (var (res->name),
                               op (VAR (L(p)->env, att1, res_type),
                                   VAR (L(p)->env, att2, res_type))));
                }   break; /* fold) */
                case alg_fun_fn_abs:
                case alg_fun_fn_ceiling:
                case alg_fun_fn_floor:
                case alg_fun_fn_round: /* fold( */
                {
                    PFmil_t * (*op) (const PFmil_t *) = NULL;
                    PFalg_att_t att;

                    att = p->sem.fun_1to1.refs.atts[0];
                    res_type = type_of (L(p), att);

                    assert (res_type == aat_int ||
                            res_type == aat_dec ||
                            res_type == aat_dbl);

                    switch (p->sem.fun_1to1.kind) {
                        case alg_fun_fn_abs:
                            op = PFmil_mabs; break;
                        case alg_fun_fn_ceiling:
                            op = PFmil_mceil; break;
                        case alg_fun_fn_floor:
                            op = PFmil_mfloor; break;
                        case alg_fun_fn_round:
                            op = PFmil_mround_up; break;
                        default:
                            break;
                    }

                    /* because functions are only allowed for dbl
                       we need to cast before and afterwards:
                       res := `input'.[dbl]().[`op']().[`res_type'](); */
                    if (impl_types (res_type) == mty_dbl)
                        execute (
                            assgn (var (res->name),
                                   op (VAR (L(p)->env, att, res_type))));
                    else
                        execute (
                            assgn (var (res->name),
                                   mcast (implty (res_type),
                                          op (mcast (type (mty_dbl),
                                                     VAR (L(p)->env,
                                                          att,
                                                          res_type))))));
                }   break; /* fold) */
                case alg_fun_fn_substring: /* fold( */
                {
                    PFalg_att_t att1, att2;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = aat_str;

                    execute (
                        assgn (var (res->name),
                               mstring (
                                   VAR (L(p)->env, att1, aat_str),
                                   mmax( msub( mcast (type (mty_int),
                                                      mround_up( VAR (L(p)->env,
                                                                 att2,
                                                                 aat_dbl))),
                                              lit_int(1)),
                                         lit_int(0)))));
                }   break; /* fold) */
                case alg_fun_fn_substring_dbl: /* fold( */
                {
                    PFalg_att_t att1, att2, att3;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    att3 = p->sem.fun_1to1.refs.atts[2];
                    res_type = aat_str;

                    execute (
                        assgn (var (res->name),
                               mstring2 (
                                   VAR (L(p)->env, att1, aat_str),
                                   mmax( msub( mcast (type (mty_int),
                                                      mround_up( VAR (L(p)->env,
                                                                 att2,
                                                                 aat_dbl))),
                                              lit_int(1)),
                                         lit_int(0)),
                                   mcast (type (mty_int),
                                          mround_up( VAR (L(p)->env,
                                                     att3,
                                                     aat_dbl))))));
                }   break; /* fold) */

                case alg_fun_fn_string_length: /* fold( */
                {
                    PFalg_att_t att;

                    att = p->sem.fun_1to1.refs.atts[0];
                    res_type = aat_int;

                    execute (
                        assgn (var (res->name),
                               mcast (implty (res_type),
                                      mlength (
                                          VAR (L(p)->env, att, aat_str)))));
                }   break; /* fold) */
                case alg_fun_fn_normalize_space:
                case alg_fun_fn_upper_case:
                case alg_fun_fn_lower_case: /* fold( */
                {
                    PFmil_t * (*op) (const PFmil_t *) = NULL;
                    PFalg_att_t att;

                    att = p->sem.fun_1to1.refs.atts[0];
                    res_type = aat_str;

                    switch (p->sem.fun_1to1.kind) {
                        case alg_fun_fn_upper_case:
                            op = PFmil_mtoUpper; break;
                        case alg_fun_fn_lower_case:
                            op = PFmil_mtoLower; break;
                        case alg_fun_fn_normalize_space:
                            op = PFmil_mnorm_space; break;
                        default: break;
                    }

                    execute (
                        assgn (var (res->name),
                               op (VAR (L(p)->env, att, aat_str))));

                }   break; /* fold) */
                case alg_fun_fn_translate: /* fold( */
                {
                    PFalg_att_t att1, att2, att3;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    att3 = p->sem.fun_1to1.refs.atts[2];
                    res_type = aat_str;

                    execute (
                        assgn (var (res->name),
                               mtranslate (
                                   VAR (L(p)->env, att1, aat_str),
                                   VAR (L(p)->env, att2, aat_str),
                                   VAR (L(p)->env, att3, aat_str))));
                }   break; /* fold) */
                case alg_fun_fn_contains: /* fold( */
                {
                    PFalg_att_t att1, att2;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = aat_bln;

                    /* do the containment checks:
                       [search](strings,search_strs).[!=](-1).[oid]() */
                    execute (
                        assgn (var (res->name),
                               mnot (meq (msearch (
                                              VAR (L(p)->env, att1, aat_str),
                                              VAR (L(p)->env, att2, aat_str)),
                                          lit_int (-1)))));
                }   break; /* fold) */
                case alg_fun_fn_starts_with:
                case alg_fun_fn_ends_with:
                case alg_fun_fn_matches: /* fold( */
                {
                    PFmil_t * (*op) (const PFmil_t *, const PFmil_t *) = NULL;
                    PFalg_att_t att1, att2;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = aat_bln;

                    switch (p->sem.fun_1to1.kind) {
                        case alg_fun_fn_starts_with:
                            op = PFmil_mstarts_with; break;
                        case alg_fun_fn_ends_with:
                            op = PFmil_mends_with; break;
                        case alg_fun_fn_matches:
                            op = PFmil_mpcre_match; break;
                        default: break;
                    }

                    execute (
                        assgn (var (res->name),
                               op (VAR (L(p)->env, att1, aat_str),
                                   VAR (L(p)->env, att2, aat_str))));
                }   break; /* fold) */
                case alg_fun_fn_substring_before: /* fold( */
                {
                    PFalg_att_t att1, att2;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = aat_str;

                    execute (
                        assgn (var (res->name),
                               mstring2 (VAR (L(p)->env, att1, aat_str),
                                         lit_int (0),
                                         msearch (
                                             VAR (L(p)->env, att1, aat_str),
                                             VAR (L(p)->env, att2, aat_str)))));

                }   break; /* fold) */
                case alg_fun_fn_substring_after: /* fold( */
                {
                    PFalg_att_t att1, att2;
                    mvar_t     *search_res;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = aat_str;
                    search_res = new_var(1);

                    execute (
                        assgn (var (search_res->name),
                               msearch (VAR (L(p)->env, att1, aat_str),
                                        VAR (L(p)->env, att2, aat_str))),
                        assgn (var (res->name),
                               mifthenelse (meq (var (search_res->name),
                                                 lit_int(-1)),
                                            lit_str(""),
                                            mstring (
                                                VAR (L(p)->env, att1, aat_str),
                                                madd (var (search_res->name),
                                                      mlength (VAR (L(p)->env,
                                                                   att2,
                                                                   aat_str))
                                                      )))));
                    unpin(search_res, 1);
                }   break; /* fold) */
                case alg_fun_fn_matches_flag: /* fold( */
                {
                    PFalg_att_t att1, att2, att3;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    att3 = p->sem.fun_1to1.refs.atts[2];
                    res_type = aat_bln;

                    execute (
                        assgn (var (res->name),
                               mpcre_match_flag (
                                   VAR (L(p)->env, att1, aat_str),
                                   VAR (L(p)->env, att2, aat_str),
                                   VAR (L(p)->env, att3, aat_str))));
                }   break; /* fold) */
                case alg_fun_fn_replace: /* fold( */
                {
                    PFalg_att_t att1, att2, att3;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    att3 = p->sem.fun_1to1.refs.atts[2];
                    res_type = aat_str;

                    execute (
                        assgn (var (res->name),
                               mpcre_replace (
                                   VAR (L(p)->env, att1, aat_str),
                                   VAR (L(p)->env, att2, aat_str),
                                   VAR (L(p)->env, att3, aat_str),
                                   lit_str(""))));
                }   break; /* fold) */
                case alg_fun_fn_replace_flag: /* fold( */
                {
                    PFalg_att_t att1, att2, att3, att4;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    att3 = p->sem.fun_1to1.refs.atts[2];
                    att4 = p->sem.fun_1to1.refs.atts[3];
                    res_type = aat_str;

                    execute (
                        assgn (var (res->name),
                               mpcre_replace (
                                   VAR (L(p)->env, att1, aat_str),
                                   VAR (L(p)->env, att2, aat_str),
                                   VAR (L(p)->env, att3, aat_str),
                                   VAR (L(p)->env, att4, aat_str))));
                }   break; /* fold) */
                case alg_fun_fn_name: /* fold( */
                {
                    PFalg_att_t att         = p->sem.fun_1to1.refs.atts[0];
                    mvar_t     *id          = new_var (1),
                               *cont        = new_var (1),
                               *empty_str   = new_var (1),
                               *mu          = new_var (1),
                               *prefix      = new_var (1),
                               *name        = new_var (1),
                               *prefix_bool = new_var (1),
                               *true_oid    = new_var (1),
                               *false_oid   = new_var (1);

                    /* look up the correct QName references */
                    fn_node_name (L(p), att, id, cont);

                    /* get all prefixes */
                    execute (
                        assgn (var (prefix->name),
                               mposjoin (tmark (var (id->name), lit_oid (0)),
                                         tmark (var (cont->name), lit_oid (0)),
                                         fetch (var (PF_MIL_VAR_WS),
                                                var (PF_MIL_VAR_QN_PREFIX)))),
                        /* add ":" only to prefix that are not "" */
                        assgn (var (prefix_bool->name),
                               meq (var (prefix->name), lit_str(""))),
                        assgn (var (true_oid->name),
                               hmark (uselect (var (prefix_bool->name),
                                               lit_bit(true)),
                                      lit_oid(0))),
                        assgn (var (false_oid->name),
                               hmark (uselect (var (prefix_bool->name),
                                               lit_bit(false)),
                                      lit_oid(0))),
                        assgn (var (prefix->name),
                               madd (leftfetchjoin (var (false_oid->name),
                                                    var (prefix->name)),
                                     lit_str(":"))),
                        assgn (var (mu->name),
                               merged_union (
                                   arg (var (true_oid->name),
                                        arg (var (false_oid->name),
                                             arg (lit_str(""),
                                                  var (prefix->name)))))),
                        /* we know that prefix now contains all rows
                           (and thus treat a tmark for a leftjoin) */
                        assgn (var (prefix->name),
                               tmark (
                                   fetch (var (mu->name), lit_int (1)),
                                   lit_oid (0))),
                        assgn (var (name->name),
                               madd (var (prefix->name),
                                     mposjoin (tmark (var (id->name),
                                                      lit_oid (0)),
                                               tmark (var (cont->name),
                                                      lit_oid (0)),
                                               fetch (
                                                   var (PF_MIL_VAR_WS),
                                                   var (PF_MIL_VAR_QN_LOC))))),
                        /* empty names for nodes that have no QName */
                        assgn (var (empty_str->name),
                               project (kdiff (ANY_VAR(L(p)->env),
                                               var (id->name)),
                                        lit_str (""))),
                        assgn (var (mu->name),
                               merged_union (
                                   arg (hmark (var (id->name), lit_oid (0)),
                                        arg (hmark (var (empty_str->name),
                                                    lit_oid (0)),
                                             arg (var (name->name),
                                                  tmark (var (empty_str->name),
                                                         lit_oid (0))))))),
                        assgn (var (res->name),
                               tmark (fetch (var (mu->name), lit_int (1)),
                                      lit_oid (0))));

                    unpin (id, 1);
                    unpin (cont, 1);
                    unpin (empty_str, 1);
                    unpin (mu, 1);
                    unpin (prefix, 1);
                    unpin (name, 1);
                    unpin (prefix_bool, 1);
                    unpin (true_oid, 1);
                    unpin (false_oid, 1);

                    res_type = aat_str;
                }   break; /* fold) */
                case alg_fun_fn_local_name:
                case alg_fun_fn_namespace_uri: /* fold( */
                {
                    PFalg_att_t   att         = p->sem.fun_1to1.refs.atts[0];
                    mvar_t       *id          = new_var (1),
                                 *cont        = new_var (1),
                                 *name        = new_var (1),
                                 *empty_str   = new_var (1),
                                 *mu          = new_var (1);
                    PFmil_ident_t uri_loc     = PF_MIL_VAR_UNUSED;

                    switch (p->sem.fun_1to1.kind) {
                        case alg_fun_fn_local_name:
                            uri_loc = PF_MIL_VAR_QN_LOC; break;
                        case alg_fun_fn_namespace_uri:
                            uri_loc = PF_MIL_VAR_QN_URI; break;
                        default:
                            assert(!"should never reach here"); break;
                    }

                    /* look up the correct QName references */
                    fn_node_name (L(p), att, id, cont);

                    /* get all prefixes */
                    execute (
                        assgn (var (name->name),
                               mposjoin (tmark (var (id->name), lit_oid (0)),
                                         tmark (var (cont->name), lit_oid (0)),
                                         fetch (var (PF_MIL_VAR_WS),
                                                var (uri_loc)))),
                        /* empty names for nodes that have no QName */
                        assgn (var (empty_str->name),
                               project (kdiff (ANY_VAR(L(p)->env),
                                               var (id->name)),
                                        lit_str (""))),
                        assgn (var (mu->name),
                               merged_union (
                                   arg (hmark (var (id->name), lit_oid (0)),
                                        arg (hmark (var (empty_str->name),
                                                    lit_oid (0)),
                                             arg (var (name->name),
                                                  tmark (var (empty_str->name),
                                                         lit_oid (0))))))),
                        assgn (var (res->name),
                               tmark (fetch (var (mu->name), lit_int (1)),
                                      lit_oid (0))));

                    unpin (id, 1);
                    unpin (cont, 1);
                    unpin (name, 1);
                    unpin (empty_str, 1);
                    unpin (mu, 1);

                    res_type = aat_str;
                }   break; /* fold) */
                case alg_fun_fn_number:
                case alg_fun_fn_number_lax: /* fold( */
                {
                    PFalg_att_t         att   = p->sem.fun_1to1.refs.atts[0];
                    PFalg_simple_type_t ty    = type_of (L(p), att);
                    bool                first = true;

                    res_type = aat_dbl;

                    if (ty & aat_qname)
                        PFoops (OOPS_FATAL,
                                "We do not support the value NaN.");

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & TYPE_MASK(ty)) {

                            PFmil_t *casted = NULL;

                            if (t == res_type)
                                casted = VAR (L(p)->env, att, t);
                            else
                                casted
                                    = mcast (
                                        implty (res_type),
                                        VAR (L(p)->env, att, t));

                            if (first) {
                                execute (assgn (var (res->name), casted));
                                first = false;
                            }
                            else
                                execute (assgn (var (res->name),
                                                mifthenelse (
                                                    misnil (var (res->name)),
                                                    casted,
                                                    var (res->name))));
                        }

                    if (p->sem.fun_1to1.kind == alg_fun_fn_number)
                        /* As we do not support the value NaN we need to generate
                           an error for all tuples that cannot be casted (instead
                           of generating NaN). */
                        execute (
                            if_ (exist (reverse (var (res->name)),
                                        cast (implty (res_type), nil ())),
                                 error (
                                     lit_str ("We do not support the value NaN.")),
                                 nop ()));
                }   break; /* fold) */
                case alg_fun_fn_qname: /* fold( */
                {
                    PFalg_att_t uri     = p->sem.fun_1to1.refs.atts[0],
                                pfx_loc = p->sem.fun_1to1.refs.atts[1];
                    mvar_t     *cont    = new_var (p->refctr),
                               *offset  = new_var (1),
                               *prefix  = new_var (1),
                               *local   = new_var (1),
                               *err_str = new_var (1),
                               *err_chk = new_var (1);
                    PFmil_t    *v_cast  = VAR (L(p)->env, pfx_loc, aat_str),
                               *v_uri   = VAR (L(p)->env, uri, aat_str);
                    PFmil_t    *str     = NULL;

                    /* split up strings using ``:'' as delimiter */
                    execute (
                        assgn (var (err_str->name),
                               check_qnames (v_cast)),
                        if_ (not (isnil (var (err_str->name))),
                             error (arg (lit_str ("err:FORG0001. "
                                                  "illegal QName '%s'."),
                                         var (err_str->name))),
                             nop ()),
                        assgn (var (offset->name),
                               msearch (v_cast, lit_str (":"))),
                        assgn (var (prefix->name),
                               mstring2 (v_cast,
                                         lit_int (0),
                                         var (offset->name))),
                        assgn (var (local->name),
                               mstring (v_cast,
                                        madd (lit_int (1),
                                              var (offset->name)))));

                    /* Report an error if there is a prefix
                       but no namespace (encoded by the string "|"). */
                    execute (
                        assgn (var (err_chk->name),
                               select_ (
                                   meq (
                                       msearch (
                                           leftfetchjoin (
                                               mirror (
                                                   select_ (
                                                       meq (
                                                           var (prefix->name),
                                                           lit_str ("")),
                                                       lit_bit (false))),
                                               v_uri),
                                           lit_str ("|")),
                                       lit_int (-1)),
                                   lit_bit (false))),
                        if_ (gt (count (var (err_chk->name)), lit_int (0)),
                             error (
                                 lit_str ("err:FOCA0002, "
                                          "Invalid lexical value.")),
                             nop ()));

                    /* add_qnames changes the working set
                       in 'var (PF_MIL_VAR_WS)' as side effect */
                    str = add_qnames (
                              var (prefix->name),
                              v_uri,
                              var (local->name),
                              var (PF_MIL_VAR_WS));

                    execute (assgn (var (res->name), str),
                             assgn (var (cont->name),
                                    project (var (res->name),
                                             var (PF_MIL_VAR_WS))));

                    unpin (offset, 1);
                    unpin (prefix, 1);
                    unpin (local, 1);
                    unpin (err_str, 1);

                    /* and put the result into p's environment */
                    env_add (p->env, p->sem.fun_1to1.res, aat_qname_cont, cont);

                    res_type = aat_qname_id;
                }   break; /* fold) */
                case alg_fun_pf_fragment: /* fold( */
                {
                    res_type = aat_frag;
                    res = env_mvar (L(p)->env,
                                    p->sem.fun_1to1.refs.atts[0],
                                    aat_frag);
                }   break; /* fold) */
                case alg_fun_pf_supernode: /* fold( */
                    /* FIXME: not implemented yet. */
                    assert (!"no implementation here");
                    break; /* fold) */
                case alg_fun_pf_add_doc_str: /* fold( */
                {
                    PFalg_att_t filepath   = p->sem.fun_1to1.refs.atts[0],
                                docname    = p->sem.fun_1to1.refs.atts[1],
                                collection = p->sem.fun_1to1.refs.atts[2];

                    assert (env_count (L(p)->env));

                    /* relink all filepath strings to the result BATs */
                    for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                        if (env_at (L(p)->env, i).att == filepath) {
                            pin (env_at (L(p)->env, i).mvar, p->refctr);
                            env_add (p->env,
                                     p->sem.fun_1to1.res,
                                     aat_path,
                                     env_at (L(p)->env, i).mvar);
                        }

                    /* relink all document name strings to the result BATs */
                    for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                        if (env_at (L(p)->env, i).att == docname) {
                            pin (env_at (L(p)->env, i).mvar, p->refctr);
                            env_add (p->env,
                                     p->sem.fun_1to1.res,
                                     aat_docnm,
                                     env_at (L(p)->env, i).mvar);
                        }

                    /* relink all colection name strings to the result BATs */
                    for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                        if (env_at (L(p)->env, i).att == collection) {
                            pin (env_at (L(p)->env, i).mvar, p->refctr);
                            env_add (p->env,
                                     p->sem.fun_1to1.res,
                                     aat_colnm,
                                     env_at (L(p)->env, i).mvar);
                        }

                    /* update percentage is the result BAT */
                    res_type = aat_docmgmt;
                    execute (
                        assgn ( var (res->name),
                                project (VAR (L(p)->env, docname, aat_str),
                                         lit_lng(0))));

                }   break; /* fold) */
                case alg_fun_pf_add_doc_str_int: /* fold( */
                {
                    PFalg_att_t filepath   = p->sem.fun_1to1.refs.atts[0],
                                docname    = p->sem.fun_1to1.refs.atts[1],
                                collection = p->sem.fun_1to1.refs.atts[2],
                                percentage = p->sem.fun_1to1.refs.atts[3];

                    assert (env_count (L(p)->env));

                    /* relink all filepath strings to the result BATs */
                    for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                        if (env_at (L(p)->env, i).att == filepath) {
                            pin (env_at (L(p)->env, i).mvar, p->refctr);
                            env_add (p->env,
                                     p->sem.fun_1to1.res,
                                     aat_path,
                                     env_at (L(p)->env, i).mvar);
                        }

                    /* relink all document name strings to the result BATs */
                    for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                        if (env_at (L(p)->env, i).att == docname) {
                            pin (env_at (L(p)->env, i).mvar, p->refctr);
                            env_add (p->env,
                                     p->sem.fun_1to1.res,
                                     aat_docnm,
                                     env_at (L(p)->env, i).mvar);
                        }

                    /* relink all colection name strings to the result BATs */
                    for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                        if (env_at (L(p)->env, i).att == collection) {
                            pin (env_at (L(p)->env, i).mvar, p->refctr);
                            env_add (p->env,
                                     p->sem.fun_1to1.res,
                                     aat_colnm,
                                     env_at (L(p)->env, i).mvar);
                        }

                    /* update percentage is the result BAT */
                    res_type = aat_docmgmt;
                    execute (
                        assgn ( var (res->name),
                                VAR (L(p)->env, percentage, aat_int)));

                }   break; /* fold) */
                case alg_fun_pf_del_doc: /* fold( */
                {
                    PFalg_att_t docname   = p->sem.fun_1to1.refs.atts[0];

                    assert (env_count (L(p)->env));

                    /* relink all document name strings to the result BATs */
                    for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                        if (env_at (L(p)->env, i).att == docname) {
                            pin (env_at (L(p)->env, i).mvar, p->refctr);
                            env_add (p->env,
                                     p->sem.fun_1to1.res,
                                     aat_docnm,
                                     env_at (L(p)->env, i).mvar);
                        }

                    /* update percentage is the result BAT */
                    res_type = aat_docmgmt;
                    execute (
                        assgn ( var (res->name),
                                project (VAR (L(p)->env, docname, aat_str),
                                         lit_lng(-1))));

                }   break; /* fold) */
                case alg_fun_upd_delete: /* fold( */
                {
                    PFalg_att_t tgt = p->sem.fun_1to1.refs.atts[0];
                    mvar_t *loop = NULL;

                    assert (env_count (L(p)->env));

                    /* relink all target nodes to the result BATs */
                    for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                        if (env_at (L(p)->env, i).att == tgt) {
                            pin (env_at (L(p)->env, i).mvar, p->refctr);
                            env_add (p->env,
                                     p->sem.fun_1to1.res,
                                     env_at (L(p)->env, i).ty << 4,
                                     env_at (L(p)->env, i).mvar);
                            loop = env_at (L(p)->env, i).mvar;
                        }

                    res_type = aat_update;

                    /* assign the correct update type to every row */
                    execute (
                        assgn (var (res->name),
                               project (
                                   var (loop->name),
                                   lit_lng(UPDATE_DELETE))));
                }   break; /* fold) */
                case alg_fun_upd_rename:
                case alg_fun_upd_insert_into_as_first:
                case alg_fun_upd_insert_into_as_last:
                case alg_fun_upd_insert_before:
                case alg_fun_upd_insert_after:
                case alg_fun_upd_replace_value_att:
                case alg_fun_upd_replace_value:
                case alg_fun_upd_replace_element:
                case alg_fun_upd_replace_node: /* fold( */
                {
                    PFalg_att_t tgt     = p->sem.fun_1to1.refs.atts[0],
                                changes = p->sem.fun_1to1.refs.atts[1];
                    mvar_t *loop = NULL;
                    
                    int update_str;

                    assert (env_count (L(p)->env));

                    /* relink all target nodes to the result BATs */
                    for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                        if (env_at (L(p)->env, i).att == tgt) {
                            pin (env_at (L(p)->env, i).mvar, p->refctr);
                            env_add (p->env,
                                     p->sem.fun_1to1.res,
                                     env_at (L(p)->env, i).ty << 4,
                                     env_at (L(p)->env, i).mvar);
                            loop = env_at (L(p)->env, i).mvar;
                        }

                    /* relink all changes to the result BATs */
                    for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                        if (env_at (L(p)->env, i).att == changes) {
                            pin (env_at (L(p)->env, i).mvar, p->refctr);
                            env_add (p->env,
                                     p->sem.fun_1to1.res,
                                     env_at (L(p)->env, i).ty,
                                     env_at (L(p)->env, i).mvar);
                        }

                    res_type = aat_update;

                    /* assign the correct update type to every row */
                    switch (p->sem.fun_1to1.kind) {
                        case alg_fun_upd_rename:
                             update_str = UPDATE_RENAME;
                             break;
                        case alg_fun_upd_insert_into_as_first:
                             update_str = UPDATE_INSERT_FIRST;
                             break;
                        case alg_fun_upd_insert_into_as_last:
                             update_str = UPDATE_INSERT_LAST;
                             break;
                        case alg_fun_upd_insert_before:
                             update_str = UPDATE_INSERT_BEFORE;
                             break;
                        case alg_fun_upd_insert_after:
                             update_str = UPDATE_INSERT_AFTER;
                             break;
                        case alg_fun_upd_replace_value_att:
                        case alg_fun_upd_replace_value:
                             update_str = UPDATE_REPLACE;
                             break;
                        case alg_fun_upd_replace_element:
                             update_str = UPDATE_REPLACECONTENT;
                             break;
                        case alg_fun_upd_replace_node:
                             update_str = UPDATE_REPLACENODE;
                             break;
                        default:
                             update_str = 0; /* should never reach here */
                             break;     /* this is just to fool the compiler */
                    }
                    execute (
                        assgn (var (res->name),
                               project (
                                   var (loop->name),
                                   lit_lng(update_str))));

                }   break; /* fold) */
            }

            /* and put the result into p's environment */
            env_add (p->env, p->sem.fun_1to1.res, res_type, res);
        }   break; /* fold) */

        /* Rel:      eq (Rel) */
        case 50:
        /* Rel:      gt (Rel) */
        case 52: /* fold( */
        {
            PFmil_t * (*op) (const PFmil_t *, const PFmil_t *) = NULL;
            mvar_t *l   = new_var (1),
                   *r   = new_var (1),
                   *res = new_var (p->refctr);

            /* choose the correct operator */
            if (p->kind == pa_eq)      op = PFmil_meq;
            else if (p->kind == pa_gt) op = PFmil_mgt;
#ifndef NDEBUG
            else assert (!"unexpected operator in comparison");
#endif
            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            /* transform (possibly) multiple input columns
               into two single BATs (stored in l and r) */
            prepare_comp (
                L(p), L(p), p->sem.binary.att1, p->sem.binary.att2, l, r);

            /* do the comparison */
            execute (
                assgn (var (res->name), op (var (l->name), var (r->name))));

            /* and put the result into p's environment */
            env_add (p->env, p->sem.binary.res, aat_bln, res);

            unpin (l, 1);
            unpin (r, 1);
        }   break; /* fold) */

        /* Rel:      bool_not (Rel) */
        case 60: /* fold( */
        {
            mvar_t *res = new_var (p->refctr);

            assert (aat_bln == type_of (L(p), p->sem.unary.att));

            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            /* do the comparison */
            execute (
                assgn (var (res->name),
                       mnot (VAR (L(p)->env, p->sem.unary.att, aat_bln))));

            /* and put the result into p's environment */
            env_add (p->env, p->sem.unary.res, aat_bln, res);
        }   break; /* fold) */

        /* Rel:      bool_and (Rel) */
        case 61:
        /* Rel:      bool_or (Rel) */
        case 62: /* fold( */
        {
            PFmil_t * (*op) (const PFmil_t *, const PFmil_t *) = NULL;
            mvar_t *res = new_var (p->refctr);

            assert (aat_bln == type_of (L(p), p->sem.binary.att1));
            assert (aat_bln == type_of (L(p), p->sem.binary.att2));

            /* choose the correct operator */
            if (p->kind == pa_bool_and)     op = PFmil_mand;
            else if (p->kind == pa_bool_or) op = PFmil_mor;
#ifndef NDEBUG
            else assert (!"unexpected operator in boolean operator");
#endif
            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            /* do the comparison */
            execute (
                assgn (var (res->name),
                       op (VAR (L(p)->env, p->sem.binary.att1, aat_bln),
                           VAR (L(p)->env, p->sem.binary.att2, aat_bln))));

            /* and put the result into p's environment */
            env_add (p->env, p->sem.binary.res, aat_bln, res);
        }   break; /* fold) */

        /* Rel:      to (Rel) */
        case 64: /* fold( */
        {
            mvar_t *v   = new_var (1);
            mvar_t *res = new_var (p->refctr);

            execute (
                /* v := in2.[-](in1).[+](1LL).[max](0LL);
                   v := enumerate(in1, v);
                   res := v.reverse().mark(0@0).reverse();
                   v := v.mark(0@0).reverse();

                   out_n := v.leftjoin(in_n);
                   out_n := out_n.tmark(0@0); */
                assgn (
                    var (v->name),
                    mmax (lit_lng (0),
                          madd (lit_lng (1),
                                msub (VAR (L(p)->env,
                                           p->sem.binary.att2,
                                           aat_int),
                                      VAR (L(p)->env,
                                           p->sem.binary.att1,
                                           aat_int))))),
                assgn (
                    var (v->name),
                    enumerate (VAR (L(p)->env, p->sem.binary.att1, aat_int),
                               var (v->name))),
                assgn (
                    var (res->name),
                    tmark (var (v->name), lit_oid (0))),
                assgn (
                    var (v->name),
                    reverse (mark (var (v->name), lit_oid (0)))));

            env_add (p->env, p->sem.binary.res, aat_int, res);

            /* map all columns from the argument */
            env_map (p, L(p)->env, v);

            unpin (v, 1);
        }   break; /* fold) */

        /* Rel:      count_ext (Rel, Rel) */
        case 65: /* fold( */
        {
            mvar_t *v    = new_var (1);
            mvar_t *res  = new_var (p->refctr);
            mvar_t *part = new_var (p->refctr);
            PFalg_simple_type_t ty = type_of (p, p->sem.count.part);

            if (!type_bit_check (ty))
                PFoops (OOPS_FATAL,
                        "Count not implemented for polymorphic groups");

            execute (
                /* v := {count}(p_in.reverse ()) */
                assgn (
                    var (v->name),
                    egcount (
                        reverse (VAR (L(p)->env, p->sem.count.part, ty)),
                        reverse (VAR (R(p)->env, p->sem.count.loop, ty)))),
                /* align with integer representation (lng) */
                assgn (var (v->name),
                       mcast (type (mty_lng), var (v->name))),
                /* res := v.reverse ().mark (0@0).reverse (); */
                assgn (
                    var (res->name),
                    reverse (
                        mark (
                            reverse (var (v->name)),
                            lit_oid (0)))),
                /* part := v.mark (0@0).reverse (); */
                assgn (
                    var (part->name),
                    reverse (
                        mark (var (v->name), lit_oid (0)))));

            env_add (p->env, p->sem.count.res, aat_int, res);
            env_add (p->env, p->sem.count.part, ty, part);

            unpin (v, 1);
        }   break; /* fold) */

        /* Rel:      count (Rel) */
        case 66: /* fold( */
            if (p->sem.count.part != att_NULL) {
                mvar_t *v              = new_var (1);
                mvar_t *res            = new_var (p->refctr);
                mvar_t *part           = new_var (p->refctr);
                PFalg_simple_type_t ty = type_of (L(p), p->sem.count.part);

                if (!type_bit_check (ty))
                    PFoops (OOPS_FATAL,
                            "HashCount not implemented for polymorphic groups");

                execute (
                    /* v := {count}(p_in.reverse ()) */
                    assgn (
                        var (v->name),
                        gcount (
                            reverse (VAR (L(p)->env,
                                          p->sem.count.part, ty)))),
                    /* align with integer representation (lng) */
                    assgn (var (v->name),
                           mcast (type (mty_lng), var (v->name))),
                    /* res := v.reverse ().mark (0@0).reverse (); */
                    assgn (
                        var (res->name),
                        reverse (
                            mark (
                                reverse (var (v->name)),
                                lit_oid (0)))),
                    /* part := v.mark (0@0).reverse (); */
                    assgn (
                        var (part->name),
                        reverse (
                            mark (var (v->name), lit_oid (0)))));

                env_add (p->env, p->sem.count.res, aat_int, res);
                env_add (p->env, p->sem.count.part, ty, part);

                unpin (v, 1);
            }
            else {
                mvar_t *v = new_var (p->refctr);
                execute (
                    assgn (var (v->name),
                           count (var (env_at (L(p)->env, 0).mvar->name))),
                    /* align with integer representation (lng) */
                    assgn (var (v->name),
                           cast (type (mty_lng), var (v->name))),
                    assgn (var (v->name),
                           append (
                               seqbase (
                                   new (type (mty_void), type (mty_lng)),
                                   lit_oid (0)),
                               var (v->name))));
                env_add (p->env, p->sem.count.res, aat_int, v);
            }
            break; /* fold) */

        /* Rel:      avg (Rel) */
        case 67:
             aggr_function (PFmil_avg, PFmil_gavg, p);
             break;

        /* Rel:      max_ (Rel) */
        case 68:
             aggr_function (PFmil_max, PFmil_gmax, p);
             break;

        /* Rel:      min_ (Rel) */
        case 69:
             aggr_function (PFmil_min, PFmil_gmin, p);
             break;

        /* Rel:      sum (Rel) */
        case 70:
             aggr_function (PFmil_sum, PFmil_gsum, p);
             break;

        /* Rel:      mark (Rel) */
        case 71: /* fold( */
        {
            mvar_t *res = new_var (p->refctr);

            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            if (env_at (L(p)->env, 0).ty == aat_frag)
                /* As in many cases two adjacent path steps are separated
                   by a mark operator and the fragment is constant we
                   try to avoid an additional dependency on the fragment
                   to ease 'materialize' operator removal. */
                execute (
                    assgn (var (res->name),
                           mark (VAR (L(p)->env,
                                      env_at (L(p)->env, 0).att,
                                      aat_pre),
                                 lit_oid (1))));
            else
                execute (assgn (var (res->name),
                                mark (ANY_VAR (L(p)->env), lit_oid (1))));

            /* put the result into p's environment */
            env_add (p->env, p->sem.mark.res, aat_nat, res);
        } break; /* fold) */

        /* Rel:      rank (Rel) */
        case 72:
        /* Rel:      rank (std_sort (Rel)) */
        case 73:
        /* Rel:      rank (refine_sort (Rel)) */
        case 74: /* fold( */
            /* as we have to sort anyway we can also skip the sort operator */
        {
            /*
             * Derive a single BAT from the multi-column grouping
             * (using functions from the xtables module).
             */
            PFord_ordering_t    ord = p->sem.rank.ord;
            PFpa_op_t          *rel;
            mvar_t             *v   = new_var (1),
                               *res = new_var (p->refctr);

            if (L(p)->kind == pa_std_sort || L(p)->kind == pa_refine_sort)
                rel = LL(p);
            else
                rel = L(p);

            assert (PFord_count (ord));

            /* create the MIL code that stores
               the ordered extend in variable v */
            order_extend (rel, ord, v);

            execute (
                /* Extend the sorting with a dummy sort criterion to
                   ensure that the result column @a res consists of oids. */
                assgn (var (res->name),
                       reverse (mark (reverse (
                                          ctrefine (var (v->name),
                                                    project (var (v->name),
                                                             lit_oid (1)),
                                                    false)),
                                      lit_oid (0)))),
                 /* We know that the extent certainly is sorted. */
                assgn (var (res->name),
                       assert_order (var (res->name))),
                /* Create a new mapping relation. */
                assgn (var (v->name),
                       reverse (mark (var (v->name), lit_oid (0)))));

            /* put the result into p's environment */
            env_add (p->env, p->sem.rank.res, aat_nat, res);

            /* map all columns from the argument */
            env_map (p, rel->env, v);

             /* we know that the first sort criterion certainly is sorted
                -- assert_order however only copes with ascending order */
            if (PFord_count (ord) &&
                PFord_order_dir_at (ord, 0) == DIR_ASC) {
                PFalg_att_t att = PFord_order_col_at (ord, 0);
                PFalg_simple_type_t ty = type_of (rel, att);
                if (type_bit_check (ty))
                    execute (
                        assgn (VAR(p->env, att, ty),
                               assert_order (VAR(p->env, att, ty))));
            }

            /* release our temporary variable */
            unpin (v, 1);
        }   break; /* fold) */

        /* Rel:      mark_grp (Rel) */
        case 75: /* fold( */
        {
            mvar_t *res = new_var (p->refctr);

            assert (env_count (L(p)->env));
            assert (p->sem.mark.part);

            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            execute (
                assgn (var (res->name),
                       mark_grp (
                           VAR (p->env,
                                p->sem.mark.part,
                                type_of (p, p->sem.mark.part)),
                           project (
                               kunique (
                                   reverse (
                                       VAR (p->env,
                                            p->sem.mark.part,
                                            type_of (p, p->sem.mark.part)))),
                               lit_oid (1)))));

            /* put the result into p's environment */
            env_add (p->env, p->sem.mark.res, aat_nat, res);
        } break; /* fold) */

        /* Rel:      type (Rel) */
        case 76: /* fold( */
        {
            mvar_t             *res      = new_var (p->refctr);
            PFalg_att_t         att      = p->sem.type.att;
            PFalg_simple_type_t input_ty = type_of (L(p), att),
                                req_ty   = p->sem.type.ty;
            PFmil_t            *type     = NULL;

            /* and put the result into p's environment */
            env_add (p->env, p->sem.type.res, aat_bln, res);

            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            if (!(req_ty & input_ty))
                /* cope with the case that our schema does not provide
                   the type represented by req_ty */
                type = project (ANY_VAR (L(p)->env), lit_bit (false));
            else if (req_ty == aat_node)
                /* both pre values and attributes are available and allowed */
                type = mnot (misnil (VAR (L(p)->env, att, aat_frag)));
            else if (req_ty == aat_pnode && input_ty & aat_attr)
                /* attr values are available and not allowed */
                type = mand (mnot (misnil (VAR (L(p)->env, att, aat_frag))),
                             misnil (VAR (L(p)->env, att, aat_attr)));
            else if (req_ty == aat_pnode)
                /* pre values are available and allowed */
               type = mnot (misnil (VAR (L(p)->env, att, aat_pre)));
            else if (req_ty == aat_anode)
                /* attributes are available and allowed */
                type = mnot (misnil (VAR (L(p)->env, att, aat_attr)));
            else if (req_ty == aat_qname)
                /* attributes are available and allowed */
                type = mnot (misnil (VAR (L(p)->env, att, aat_qname_id)));
            else
                /* we have one simple type */
                type = not (misnil (VAR (L(p)->env, att, req_ty)));

            execute (assgn (var (res->name), type));
        }   break; /* fold) */

        /* Rel:      type_assert (Rel) */
        case 77: /* fold( */
            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);
            break; /* fold) */

        /* Rel:      cast (Rel) */
        case 78: /* fold( */
        {
            PFalg_att_t         att      = p->sem.cast.att;
            PFalg_simple_type_t input_ty = type_of (L(p), att),
                                req_ty   = p->sem.cast.ty;

            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            /* cast as qname requires additional document access */
            if (req_ty == aat_qname) {
                if (input_ty & ~(aat_str | aat_uA | aat_qname))
                    PFoops (OOPS_FATAL,
                            "cast to type QName is only possible "
                            "for values of type QName or string.");

                if (input_ty == aat_qname) {
                    env_add (p->env, p->sem.cast.res, aat_qname_id,
                             env_mvar (L(p)->env, att, aat_qname_id));
                    env_add (p->env, p->sem.cast.res, aat_qname_cont,
                             env_mvar (L(p)->env, att, aat_qname_cont));
                }
                else if (input_ty == aat_str || input_ty == aat_uA) {
                    mvar_t *res_id   = new_var (p->refctr),
                           *res_cont = new_var (p->refctr),
                           *in       = env_mvar (L(p)->env, att, input_ty);

                    transform_QName (in, res_id);
                    execute (
                        assgn (var (res_cont->name),
                               project (var (res_id->name),
                                        var (PF_MIL_VAR_WS_CONT))));

                    /* and put the result into p's environment */
                    env_add (p->env, p->sem.cast.res, aat_qname_id, res_id);
                    env_add (p->env, p->sem.cast.res, aat_qname_cont, res_cont);
                }
                else {
                    PFalg_simple_type_t ty[2]    = { aat_str, aat_uA };
                    mvar_t             *res_id   = new_var (p->refctr),
                                       *res_cont = new_var (p->refctr);

                    if (input_ty & aat_qname)
                        execute (
                            assgn (var (res_id->name),
                                   VAR (L(p)->env, att, aat_qname_id)),
                            assgn (var (res_cont->name),
                                   VAR (L(p)->env, att, aat_qname_cont)));
                    else
                        execute (
                            assgn (var (res_id->name),
                                   project (ANY_VAR (L(p)->env),
                                            mcast (type (mty_oid), nil ()))),
                            assgn (var (res_cont->name),
                                   project (ANY_VAR (L(p)->env),
                                            mcast (type (mty_oid), nil ()))));

                    for (unsigned short i = 0; i < 2; i++)
                        if (input_ty & ty[i]) {
                            mvar_t *str_id   = new_var (1),
                                   *str_cont = new_var (1),
                                   *in       = env_mvar (L(p)->env, att, ty[i]);

                            transform_QName (in, str_id);
                            execute (
                                assgn (var (str_cont->name),
                                       project (var (res_id->name),
                                                var (PF_MIL_VAR_WS_CONT))),
                                assgn (var (res_id->name),
                                       mifthenelse (
                                           misnil (var (res_id->name)),
                                           var (str_id->name),
                                           var (res_id->name))),
                                assgn (var (res_cont->name),
                                       mifthenelse (
                                           misnil (var (res_cont->name)),
                                           var (str_cont->name),
                                           var (res_cont->name))));

                            unpin (str_id, 1);
                            unpin (str_cont, 1);
                        }

                    /* and put the result into p's environment */
                    env_add (p->env, p->sem.cast.res, aat_qname_id, res_id);
                    env_add (p->env, p->sem.cast.res, aat_qname_cont, res_cont);
                }
            }
            else if (type_bit_check (req_ty)) {
                unsigned int parts = 0;
                mvar_t      *res   = new_var (p->refctr),
                            *tmp   = new_var (1);

                /* and put the result into p's environment */
                env_add (p->env, p->sem.cast.res, req_ty, res);

                if (input_ty & aat_qname) {
                    if (req_ty == aat_str || req_ty == aat_uA) {
                        mvar_t *id,
                               *cont,
                               *mu          = new_var (1),
                               *prefix      = new_var (1),
                               *prefix_bool = new_var (1),
                               *true_oid    = new_var (1),
                               *false_oid   = new_var (1);

                        id   = env_mvar (L(p)->env, att, aat_qname_id);
                        cont = env_mvar (L(p)->env, att, aat_qname_cont);

                        execute (
                            assgn (var (prefix->name),
                                   mposjoin (
                                       var (id->name),
                                       var (cont->name),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_QN_PREFIX)))),
                            /* add ":" only to prefix that are not "" */
                            assgn (var (prefix_bool->name),
                                   meq (var (prefix->name), lit_str(""))),
                            assgn (var (true_oid->name),
                                   hmark (uselect (var (prefix_bool->name),
                                                   lit_bit(true)),
                                          lit_oid(0))),
                            assgn (var (false_oid->name),
                                   hmark (uselect (var (prefix_bool->name),
                                                   lit_bit(false)),
                                          lit_oid(0))),
                            assgn (var (prefix->name),
                                   madd (leftfetchjoin (var (false_oid->name),
                                                        var (prefix->name)),
                                         lit_str(":"))),
                            assgn (var (mu->name),
                                   merged_union (
                                       arg (var (true_oid->name),
                                            arg (var (false_oid->name),
                                                 arg (lit_str(""),
                                                      var (prefix->name)))))),
                            assgn (var (prefix->name),
                                   leftfetchjoin (
                                       reverse (
                                           fetch (var (mu->name), lit_int (0))),
                                       fetch (var (mu->name), lit_int (1)))),
                            assgn (var (res->name),
                                   madd (var (prefix->name),
                                         mposjoin (
                                             var (id->name),
                                             var (cont->name),
                                             fetch (
                                                 var (PF_MIL_VAR_WS),
                                                 var (PF_MIL_VAR_QN_LOC))))));
                        unpin (mu, 1);
                        unpin (prefix, 1);
                        unpin (prefix_bool, 1);
                        unpin (true_oid, 1);
                        unpin (false_oid, 1);
                    }
                    else
                        PFoops (OOPS_FATAL,
                                "err:XPTY0004: cannot cast QName to %s",
                                PFalg_simple_type_str (req_ty));

                    /* remove QNames */
                    input_ty = input_ty & ~aat_qname;
                    parts++;
                }
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & TYPE_MASK(input_ty)) {
                        PFmil_t *casted = NULL;

                        if (t == p->sem.cast.ty)
                            casted = VAR (L(p)->env, p->sem.cast.att, t);
                        else if ((t == aat_str || t == aat_uA) &&
                                 req_ty == aat_bln) {
                            /* The cast from string or untypedAtomic
                               to boolean is only allowed for a few
                               values. Here the values are checked and
                               the respective result is returned. */
                            mvar_t *false_values = new_var (1),
                                   *true_values  = tmp;

                            /* collect all strings that map to 'true' */
                            execute (assgn (var (true_values->name),
                                            meq (VAR (L(p)->env,
                                                      p->sem.cast.att,
                                                      t),
                                                 lit_str("true"))),
                                     assgn (var (true_values->name),
                                            mor (var (true_values->name),
                                                 meq (VAR (L(p)->env,
                                                           p->sem.cast.att,
                                                           t),
                                                      lit_str("1")))),
                            /* collect all strings that map to 'false' */
                                     assgn (var (false_values->name),
                                            meq (VAR (L(p)->env,
                                                      p->sem.cast.att,
                                                      t),
                                                 lit_str("false"))),
                                     assgn (var (false_values->name),
                                            mor (var (false_values->name),
                                                 meq (VAR (L(p)->env,
                                                           p->sem.cast.att,
                                                           t),
                                                      lit_str("0")))),
                            /* generate an error message for all other
                               strings */
                                     if_ (
                                         exist (
                                             reverse (
                                                 mor (
                                                     var (
                                                         true_values->name),
                                                     var (
                                                         false_values->name)
                                                     )),
                                             lit_bit (false)),

                                         error (
                                             t == aat_uA
                                             ? lit_str ("err:FORG0001. "
                                                        "casting from "
                                                        "untypedAtomic "
                                                        "to boolean "
                                                        "failed.")
                                             : lit_str ("err:FORG0001. "
                                                        "casting from "
                                                        "string to "
                                                        "boolean failed.")
                                             ),
                                         nop ()));

                            casted = var (true_values->name);
                            /* note: casted == tmp */
                            unpin (false_values, 1);
                        }
                        else
                            casted
                                = mcast (
                                    implty (p->sem.cast.ty),
                                    VAR (L(p)->env, p->sem.cast.att, t));

                        if (parts)
                            execute (assgn (var (res->name),
                                            mifthenelse (
                                                misnil (var (res->name)),
                                                casted,
                                                var (res->name))));
                        else
                            execute (assgn (var (res->name), casted));

                        parts++;
                    }
                execute (
                    if_ (exist (reverse (var (res->name)),
                                cast (implty (p->sem.cast.ty), nil ())),
                         error (lit_str ("err:FORG0001.")),
                         nop ()));
                unpin (tmp, 1);
            }
            else
                PFoops (OOPS_FATAL,
                        "cast to polymorphic type not allowed.");
        }   break; /* fold) */

        /* Rel:      llscjoin (Rel) */
        case 80: /* fold( */
            llscj (p);
            break; /* fold) */

        /* Rel:      doc_tbl (Rel) */
        case 100: /* fold( */
        {
            /* temporary variables */
            mvar_t *time = new_var (1),
                   *v    = new_var (1),
                    /* result BATs */
                   *frag = new_var (p->refctr),
                   *pre  = new_var (p->refctr);

            env_add (p->env, p->sem.unary.res, aat_pre, pre);
            env_add (p->env, p->sem.unary.res, aat_frag, frag);

            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            /* add timing information */
            execute (assgn (var (time->name), usec ()));

            execute (
                 assgn (var (v->name),
                        doc_tbl (var (PF_MIL_VAR_WS),
                                 VAR (L(p)->env, p->sem.unary.att, aat_str))),
                 assgn (var (pre->name), fetch (var (v->name), lit_int (1))),
                 assgn (var (frag->name), fetch (var (v->name), lit_int (2))),
                 assgn (var (PF_MIL_VAR_WS), fetch (var (v->name), lit_int (0)))
                 );

            unpin (v, 1);

            /* add timing information */
            execute (
                assgn (var (PF_MIL_VAR_TIME_LOAD),
                       add (var (PF_MIL_VAR_TIME_LOAD),
                            sub (usec (),
                                 var (time->name)))));
            unpin (time, 1);
        }   break; /* fold) */

        /* Rel:      doc_access (Rel) */
        case 101: /* fold( */
        {
            PFalg_att_t         att = p->sem.doc_access.att;
#ifndef NDEBUG
            /* only used in assertions */
            PFalg_simple_type_t ty  = type_of (L(p), p->sem.doc_access.att);
#endif
            mvar_t             *str = new_var (p->refctr);

            PFmil_t *frag = VAR (L(p)->env, att, aat_frag),
                    *pre  = VAR (L(p)->env, att, aat_pre),
                    *attr,
                    *prop = mposjoin (
                                pre, frag, fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_PROP))),
                    *cont = mposjoin (
                                pre, frag, fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_CONT)));

            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            env_add (p->env, p->sem.doc_access.res, aat_str, str);

            /* lookup the values in the documents using mposjoin */
            switch (p->sem.doc_access.doc_col) {
                case (doc_atext):
                    assert (ty == aat_anode);
                    attr = VAR (L(p)->env, att, aat_attr);

                    execute (
                        assgn (var (str->name),
                               mposjoin (
                                   mposjoin (
                                       attr,
                                       frag,
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_ATTR_PROP))),
                                   mposjoin (
                                       attr,
                                       frag,
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_ATTR_CONT))),
                                   fetch (var (PF_MIL_VAR_WS),
                                          var (PF_MIL_VAR_PROP_VAL)))));
                    break;
                case (doc_text):
                    assert (ty == aat_pnode);
                    execute (
                        assgn (var (str->name),
                               mposjoin (
                                   prop,
                                   cont,
                                   fetch (var (PF_MIL_VAR_WS),
                                          var (PF_MIL_VAR_PROP_TEXT)))));
                    break;
                case (doc_comm):
                    assert (ty == aat_pnode);
                    execute (
                        assgn (var (str->name),
                               mposjoin (
                                   prop,
                                   cont,
                                   fetch (var (PF_MIL_VAR_WS),
                                          var (PF_MIL_VAR_PROP_COM)))));
                    break;
                case (doc_pi_text):
                    assert (ty == aat_pnode);
                    execute (
                        assgn (var (str->name),
                               mposjoin (
                                   prop,
                                   cont,
                                   fetch (var (PF_MIL_VAR_WS),
                                          var (PF_MIL_VAR_PROP_INS)))));
                    break;
                default:
                    PFoops (OOPS_FATAL,
                            "unexpected document column in doc_access (%i)",
                            p->sem.doc_access.doc_col);
            }
        }   break; /* fold) */

        /* Rel:      twig (Twig) */
        case 102: /* fold( */
        { /* top-down */
            unsigned int i;
            mvar_t *root_pre, *root_frag, *root_iter,
                   *mmu_res, *seqb, *newPre, *tmp;

            /* backup old twig state before traversing the children... */
            twig_state_t *old_twig_state = twig_state;

            /* ... and create a new one */
            twig_state = PFmalloc (sizeof (twig_state_t));
            twig_state->pre          = 0;
            twig_state->parent       = 0;
            twig_state->size         = 0;
            twig_state->level        = 0;
            twig_state->elem_vars    = PFarray (sizeof (mvar_t *), 10);
            twig_state->attr_vars    = PFarray (sizeof (mvar_t *), 10);
            twig_state->loop         = NULL;
            twig_state->elem_content = false;

            /* translate the child operators */
            reduce(kids[0], nts[0]);

            root_iter = new_var (p->refctr);
            root_pre  = new_var (p->refctr);
            root_frag = new_var (p->refctr);
            mmu_res   = new_var (1);
            seqb      = new_var (1);
            newPre    = new_var (1);

            /* the result of the twig construction will be stored
               in the variables root_iter, root_pre, and root_frag */
            env_add (p->env, p->sem.ii.iter, aat_nat, root_iter);
            env_add (p->env, p->sem.ii.item, aat_pre, root_pre);
            env_add (p->env, p->sem.ii.item, aat_frag, root_frag);

            /* FIXME: We cannot cope with a single content operator
               that provides only attribute nodes */

            /* merge all input node constructors
               (in the correct order -- the one stored
                in twig_state->elem_vars) */
            if (PFarray_last (twig_state->elem_vars) > 1) {
                mvar_t *mmu_input = new_var (1);

                /* create relation to hold all the input relations
                   for the merged_union operation */
                execute (
                    assgn (var (mmu_input->name),
                           seqbase (new (type (mty_void), type (mty_bat)),
                                    lit_oid (0))));

                /* fill in all input relations (in the correct order) */
                for (i = 0; i < PFarray_last (twig_state->elem_vars); i++) {
                    tmp = *(mvar_t **) PFarray_at (twig_state->elem_vars, i);
                    execute (bappend (var (mmu_input->name), var (tmp->name)));
                    unpin (tmp, 1);
                }

                /* apply merged union operation over multiple inputs */
                execute (
                    assgn (var (mmu_res->name),
                           multi_merged_union (var (mmu_input->name))));
                unpin (mmu_input, 1);

            } else {
                /* no merged_union needed in case we only have a single
                   constructor (with possibly multiple attributes) */
                assert (PFarray_last (twig_state->elem_vars) == 1);
                tmp = *(mvar_t **) PFarray_at (twig_state->elem_vars, 0);

                execute (assgn (var (mmu_res->name), var (tmp->name)));
                unpin (tmp, 1);
            }

            /* Generate the MIL code necessary for document, element,
               textnodes, comments, and processing-instructions */
            execute (

                /* get the offset for the first free node id:
                   seqb := oid (ws.fetch(PRE_SIZE).fetch(WS).count() +
                                ws.fetch(PRE_SIZE).fetch(WS).seqbase().int());
                */
                assgn (var (seqb->name),
                       cast (
                           type (mty_oid),
                           add (
                               count (
                                   fetch (
                                       fetch (
                                           var (PF_MIL_VAR_WS),
                                           var (PF_MIL_VAR_PRE_SIZE)),
                                       var (PF_MIL_VAR_WS_CONT))),
                               cast (
                                   type (mty_int),
                                   seqbase_lookup (
                                       fetch (
                                           fetch (
                                               var (PF_MIL_VAR_WS),
                                               var (PF_MIL_VAR_PRE_SIZE)),
                                           var (PF_MIL_VAR_WS_CONT))))))),
                /* create a column with the new pre numbers:
                   newPre := mmu_res.fetch(0).mark(seqb); */
                assgn (var (newPre->name),
                       mark (
                           fetch (var (mmu_res->name), lit_int (0)),
                           var (seqb->name))),


                /* fill the constructed nodes into the ws */

                /* size:
                   ws.fetch(PRE_SIZE).fetch(WS).append (mmu_res.fetch(2)); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_SIZE)),
                             var (PF_MIL_VAR_WS_CONT)),
                         fetch (var (mmu_res->name), lit_int (2))),
                /* level:
                   ws.fetch(PRE_LEVEL).fetch(WS).append (mmu_res.fetch(3)); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_LEVEL)),
                             var (PF_MIL_VAR_WS_CONT)),
                         fetch (var (mmu_res->name), lit_int (3))),
                /* kind:
                   ws.fetch(PRE_KIND).fetch(WS).append (mmu_res.fetch(4)); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_KIND)),
                             var (PF_MIL_VAR_WS_CONT)),
                         fetch (var (mmu_res->name), lit_int (4))),
                /* prop:
                   ws.fetch(PRE_PROP).fetch(WS).append (mmu_res.fetch(5)); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_PROP)),
                             var (PF_MIL_VAR_WS_CONT)),
                         fetch (var (mmu_res->name), lit_int (5))),
                /* cont:
                   ws.fetch(PRE_CONT).fetch(WS).append (mmu_res.fetch(6)); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_CONT)),
                             var (PF_MIL_VAR_WS_CONT)),
                         fetch (var (mmu_res->name), lit_int (6))),
                /* pre_nid:
                   ws.fetch(PRE_NID).fetch(WS).append (newPre); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_NID)),
                             var (PF_MIL_VAR_WS_CONT)),
                         var (newPre->name)),
                /* nid_rid:
                   ws.fetch(NID_RID).fetch(WS).append (newPre); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_NID_RID)),
                             var (PF_MIL_VAR_WS_CONT)),
                         var (newPre->name)),

                /* select roots and fill environment */

                /* collect new pre values of the root nodes:
                   root_pre := mmu_res.fetch(1).reverse().mark(seqb).reverse()
                                      .ord_uselect(0@0).mark(0@0).reverse(); */
                assgn (var (root_pre->name),
                       reverse (
                           mark (
                               uselect (
                                   reverse (
                                       mark (
                                           reverse (
                                               fetch (
                                                   var (mmu_res->name),
                                                   lit_int (1))),
                                           var (seqb->name))),
                                   lit_oid (0)),
                               lit_oid (0)))),

                /* prepare new iter column:
                   root_iter := root_pre.leftjoin (mmu_res.fetch(0)
                                                          .reverse.mark(seqb)
                                                          .reverse()); */
                assgn (var (root_iter->name),
                       leftjoin (
                           var (root_pre->name),
                           reverse (
                               mark (
                                   reverse (
                                       fetch (
                                           var (mmu_res->name),
                                           lit_int (0))),
                                   var (seqb->name))))),
                /* prepare the new fragment column:
                   root_frag := root_pre.leftjoin (mmu_res.fetch(6)
                                                          .reverse.mark(seqb)
                                                          .reverse()); */
                assgn (var (root_frag->name),
                       leftjoin (
                           var (root_pre->name),
                           reverse (
                               mark (
                                   reverse (
                                       fetch (
                                           var (mmu_res->name),
                                           lit_int (6))),
                                   var (seqb->name))))),

                /* make the fragment boundaries known:
                   ws.fetch(FRAG_ROOT)
                     .fetch(WS)
                     .insert(root_pre.reverse().project(oid_nil).reverse()); */
                binsert (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_FRAG_ROOT)),
                             var (PF_MIL_VAR_WS_CONT)),
                         reverse (
                             project (
                                 reverse (var (root_pre->name)),
                                 lit_oid (0)))) );

            unpin (seqb, 1);

            /* map root attributes (dslink (iter, pre))
               and add them to the ws */
            if (PFarray_last (twig_state->attr_vars)) {
                PFmil_t *bodymilprog, *oldmilprog;
                mvar_t  *a_iter  = new_var (1);
                mvar_t  *a_pre   = new_var (1);
                mvar_t  *a_qn    = new_var (1);
                mvar_t  *a_val   = new_var (1);
                mvar_t  *a_cont  = new_var (1);
                mvar_t  *count   = new_var (1);
                mvar_t  *mapping = new_var (1);
                mvar_t  *sorting = new_var (1);

                /* first collect the overall size */
                execute (assgn (var (count->name), lit_int (0)));
                for (i = 0; i < PFarray_last (twig_state->attr_vars); i++) {
                    tmp = *(mvar_t **) PFarray_at (twig_state->attr_vars, i);
                    execute (assgn (var (count->name),
                                    add (var (count->name),
                                         count (var (tmp->name)))));
                }

                oldmilprog = milprog;
                /* start new milprog for the nesting:
                   'if (...) {...} else {}' */
                milprog = nop ();

                /* create relation to hold all the input relations
                   for the append operation */
                execute (
                    assgn (var (a_iter->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid (0))),
                    assgn (var (a_pre->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid (0))),
                    assgn (var (a_qn->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid (0))),
                    assgn (var (a_val->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid (0))),
                    assgn (var (a_cont->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid (0))));

                /* add all possible root attributes
                   (references stored in twig_state->attr_vars) */
                for (i = 0; i < PFarray_last (twig_state->attr_vars); i++) {
                    tmp = *(mvar_t **) PFarray_at (twig_state->attr_vars, i);
                    execute (
                        bappend (var (a_iter->name),
                                 fetch (var (tmp->name), lit_int (0))),
                        bappend (var (a_pre->name),
                                 fetch (var (tmp->name), lit_int (1))),
                        bappend (var (a_qn->name),
                                 fetch (var (tmp->name), lit_int (2))),
                        bappend (var (a_val->name),
                                 fetch (var (tmp->name), lit_int (3))),
                        bappend (var (a_cont->name),
                                 fetch (var (tmp->name), lit_int (4))));
                    unpin (tmp, 1);
                }

                execute (
                    /* collect the references to the parent element nodes:
                       mapping := ds_link (a_iter, mmu_res.fetch(0),
                                           a_pre, mmu_res.fetch(1)); */
                    assgn (var (mapping->name),
                           mc_intersect (
                               arg (
                                   arg (
                                       var (a_iter->name),
                                       fetch (var (mmu_res->name),
                                              lit_int (0))),
                                   arg (
                                       var (a_pre->name),
                                       fetch (var (mmu_res->name),
                                              lit_int (1)))))),

                    /* get the pre values and align them
                       with the attribute values:
                       mapping := a_iter.mirror()
                                        .leftjoin(mapping.join(newPre)); */
                    assgn (var (mapping->name),
                           leftjoin (mirror (var (a_iter->name)),
                                     join (var (mapping->name),
                                           var (newPre->name)))),

                    /* fill the constructed attributes into the ws */

                    /* own:
                       ws.fetch(ATTR_OWN).fetch(WS).append(mapping); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_OWN)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             var (mapping->name)),
                    /* qn:
                       ws.fetch(ATTR_QN).fetch(WS).append(a_qn); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_QN)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             var (a_qn->name)),
                    /* prop:
                       ws.fetch(ATTR_PROP).fetch(WS).append(a_val); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_PROP)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             var (a_val->name)),
                    /* cont:
                       ws.fetch(ATTR_CONT).fetch(WS).append(a_cont); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_CONT)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             var (a_cont->name)));
                unpin (mapping, 1);

                /* check for duplicate attributes and generate
                   a runtime error if duplicates have been found. */
                execute (
                    /* sorting := a_iter.reverse().sort().reverse(); */
                    assgn (
                        var (sorting->name),
                        reverse (sort (reverse (var (a_iter->name)), DIR_ASC))),
                    /* sorting := sorting.CTrefine (a_pre); */
                    assgn (
                        var (sorting->name),
                        ctrefine (
                            var (sorting->name),
                            var (a_pre->name),
                            DIR_ASC)),
                    /* sorting := sorting.CTrefine (
                                              mposjoin (a_qn,
                                                        a_cont,
                                                        ws.fetch(QN_URI))); */
                    assgn (
                        var (sorting->name),
                        ctrefine (
                            var (sorting->name),
                            mposjoin (
                                var (a_qn->name),
                                var (a_cont->name),
                                fetch (
                                    var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_QN_URI))),
                            DIR_ASC)),
                    /* sorting := sorting.CTrefine (
                                              mposjoin (a_qn,
                                                        a_cont,
                                                        ws.fetch(QN_LOC))); */
                    assgn (
                        var (sorting->name),
                        ctrefine (
                            var (sorting->name),
                            mposjoin (
                                var (a_qn->name),
                                var (a_cont->name),
                                fetch (
                                    var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_QN_LOC))),
                            DIR_ASC)),
                    /* if (sorting.count() != sorting.tunique().count())
                       { ERROR ("..."); } else {} */
                    if_ (not (eq (count (var (sorting->name)),
                              count (tunique (var (sorting->name))))),
                         error (lit_str ("err:XQDY0025: attribute names are not"
                                         " unique in constructed element.")),
                         nop ()));
                unpin (sorting, 1);

                unpin (a_iter, 1);
                unpin (a_pre, 1);
                unpin (a_qn, 1);
                unpin (a_val, 1);
                unpin (a_cont, 1);

                /* store nested MIL code */
                bodymilprog = milprog;
                /* activate old mil program */
                milprog = oldmilprog;

                /* fill in the MIL code for root attributes:
                   if (count > 0) { ... } else { } */
                execute (
                    if_ (gt (var (count->name), lit_int (0)),
                    /* then */ bodymilprog,
                    /* else */ nop ()));

                unpin (count, 1);
            }

            /* collect and update content attributes (mvaljoin) */
            if (twig_state->elem_content) {
                mvar_t *attr = new_var (1);
                mvar_t *item = new_var (1);
                mvar_t *cont = new_var (1);

                execute (
                    /* lookup attribute ids for all subtree nodes:
                       attr := mvaljoin (mmu_res.fetch(7),
                                         mmu_res.fetch(8),
                                         ws.fetch(ATTR_OWN)); */
                    assgn (
                        var (attr->name),
                        mvaljoin (
                            fetch (var (mmu_res->name), lit_int (7)),
                            fetch (var (mmu_res->name), lit_int (8)),
                            fetch (
                                var (PF_MIL_VAR_WS),
                                var (PF_MIL_VAR_ATTR_OWN)))),

                    /* align the resulting attribute ids and the fragment
                       information:
                       item := attr.reverse().mark(0@0).reverse();
                       cont := attr.mark(0@0).reverse()
                                   .leftjoin(mmu_res.fetch(8)); */
                    assgn (var (item->name),
                           reverse (
                               mark (
                                   reverse (
                                       var (attr->name)),
                                   lit_oid (0)))),
                    assgn (var (cont->name),
                           leftjoin (
                               reverse (
                                   mark (
                                       var (attr->name),
                                       lit_oid (0))),
                               fetch (var (mmu_res->name), lit_int (8)))),

                    /* fill the constructed attributes into the ws */

                    /* own:
                       ws.fetch(ATTR_OWN).fetch(WS)
                         .append(attr.mark(0@0).reverse().leftjoin(newPre)); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_OWN)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             leftjoin (
                                 reverse (
                                     mark (
                                         var (attr->name),
                                         lit_oid (0))),
                                 var (newPre->name))),
                    /* qn:
                       ws.fetch(ATTR_QN).fetch(WS)
                         .append(mposjoin(item,cont,ws.fetch(ATTR_QN))); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_QN)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_QN)))),
                    /* prop:
                       ws.fetch(ATTR_PROP).fetch(WS)
                         .append(mposjoin(item,cont,ws.fetch(ATTR_PROP))); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_PROP)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_PROP)))),
                    /* cont:
                       ws.fetch(ATTR_CONT).fetch(WS)
                         .append(mposjoin(item,cont,ws.fetch(ATTR_CONT))); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_CONT)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_CONT)))),
                    );
                unpin (attr, 1);
                unpin (item, 1);
                unpin (cont, 1);
            }

            unpin (mmu_res, 1);
            unpin (newPre, 1);

            /* reset old twig state */
            twig_state = old_twig_state;
        }
            break; /* fold) */

        /* Rel:      twig (attribute (Rel)) */
        case 103: /* fold( */
            assert (type_of (LL(p), L(p)->sem.iter_item1_item2.iter)
                    == aat_nat);
            assert (type_of (LL(p), L(p)->sem.iter_item1_item2.item1)
                    == aat_qname);
            assert (type_of (LL(p), L(p)->sem.iter_item1_item2.item2)
                    == aat_str);
        {
            PFalg_att_t iter_att  = L(p)->sem.iter_item1_item2.iter,
                        qn_att    = L(p)->sem.iter_item1_item2.item1,
                        val_att   = L(p)->sem.iter_item1_item2.item2;
            mvar_t     *seqb      = new_var (1),
                       *qn_id     = new_var (1),
                       *root_pre  = new_var (p->refctr),
                       *root_attr = new_var (p->refctr),
                       *root_frag = new_var (p->refctr),
                       *iter      = env_mvar (LL(p)->env, iter_att, aat_nat);
            /* Lookup the input value column ... */
            PFmil_t    *val       = VAR (LL(p)->env, val_att, aat_str);

            /* and the QName columns. (Furthermore ensure that the QNames
               are stored in the WS container and copy them if they reside
               in a different container.) */
            copy_QName (
                env_mvar (LL(p)->env, qn_att, aat_qname_id),
                env_mvar (LL(p)->env, qn_att, aat_qname_cont),
                qn_id);

            execute (
                /* get first free pre value */
                assgn (var (seqb->name),
                       cast (
                           type (mty_oid),
                           add (
                               count (
                                   fetch (
                                       fetch (
                                           var (PF_MIL_VAR_WS),
                                           var (PF_MIL_VAR_ATTR_OWN)),
                                       var (PF_MIL_VAR_WS_CONT))),
                               cast (
                                   type (mty_int),
                                   seqbase_lookup (
                                       fetch (
                                           fetch (
                                               var (PF_MIL_VAR_WS),
                                               var (PF_MIL_VAR_ATTR_OWN)),
                                           var (PF_MIL_VAR_WS_CONT))))))),
                /* own */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_ATTR_OWN)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (val, cast (type (mty_oid), nil ()))),
                /* qn */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_ATTR_QN)),
                             var (PF_MIL_VAR_WS_CONT)),
                         var (qn_id->name)),
                /* prop */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_ATTR_PROP)),
                             var (PF_MIL_VAR_WS_CONT)),
                         add_content (val,
                                      var (PF_MIL_VAR_WS),
                                      var (PF_MIL_VAR_PROP_VAL))),
                /* cont */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_ATTR_CONT)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (val, var (PF_MIL_VAR_WS_CONT))),

                /* new root pre values */
                assgn (var (root_pre->name),
                       project (val, cast (type (mty_oid), nil ()))),
                /* new root attr values */
                assgn (var (root_attr->name),
                       mark (val, var (seqb->name))),
                /* fragment information */
                assgn (var (root_frag->name),
                       project (val, var (PF_MIL_VAR_WS_CONT))));

            unpin (seqb, 1);
            unpin (qn_id, 1);

            pin (iter, p->refctr);
            env_add (p->env, p->sem.ii.iter, aat_nat, iter);
            env_add (p->env, p->sem.ii.item, aat_pre, root_pre);
            env_add (p->env, p->sem.ii.item, aat_attr, root_attr);
            env_add (p->env, p->sem.ii.item, aat_frag, root_frag);
        }
            break; /* fold) */

        /* Rel:      twig (textnode (Rel)) */
        case 104: /* fold( */
            assert (type_of (LL(p), L(p)->sem.ii.iter) == aat_nat);
            assert (type_of (LL(p), L(p)->sem.ii.item) == aat_str);
        {
            mvar_t *seqb = new_var (1);
            mvar_t *root_pre  = new_var (p->refctr);
            mvar_t *root_frag = new_var (p->refctr);
            mvar_t *iter = env_mvar (LL(p)->env, L(p)->sem.ii.iter, aat_nat);
            PFmil_t *item = VAR (LL(p)->env, L(p)->sem.ii.item, aat_str);

            execute (
                /* get first free pre value */
                assgn (var (seqb->name),
                       cast (
                           type (mty_oid),
                           add (
                               count (
                                   fetch (
                                       fetch (
                                           var (PF_MIL_VAR_WS),
                                           var (PF_MIL_VAR_PRE_SIZE)),
                                       var (PF_MIL_VAR_WS_CONT))),
                               cast (
                                   type (mty_int),
                                   seqbase_lookup (
                                       fetch (
                                           fetch (
                                               var (PF_MIL_VAR_WS),
                                               var (PF_MIL_VAR_PRE_SIZE)),
                                           var (PF_MIL_VAR_WS_CONT))))))),
                /* size */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_SIZE)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (item, lit_int (0))),
                /* level */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_LEVEL)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (item, cast (type (mty_chr), lit_int (0)))),
                /* kind */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_KIND)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (item, var (PF_MIL_VAR_KIND_TEXT))),
                /* prop */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_PROP)),
                             var (PF_MIL_VAR_WS_CONT)),
                         add_content (item,
                                      var (PF_MIL_VAR_WS),
                                      var (PF_MIL_VAR_PROP_TEXT))),
                /* cont */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_CONT)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (item, var (PF_MIL_VAR_WS_CONT))),
                /* pre_nid */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_NID)),
                             var (PF_MIL_VAR_WS_CONT)),
                         mark (item, var (seqb->name))),
                /* nid_rid */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_NID_RID)),
                             var (PF_MIL_VAR_WS_CONT)),
                         mark (item, var (seqb->name))),

                /* new root pre values */
                assgn (var (root_pre->name),
                       mark (item, var (seqb->name))),
                /* fragment information */
                assgn (var (root_frag->name),
                       project (item, var (PF_MIL_VAR_WS_CONT))),

                /* make the fragment boundaries known */
                binsert (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_FRAG_ROOT)),
                             var (PF_MIL_VAR_WS_CONT)),
                         reverse (
                             project (
                                 reverse (var (root_pre->name)),
                                 lit_oid (0)))));

            unpin (seqb, 1);
            pin (iter, p->refctr);
            env_add (p->env, p->sem.ii.iter, aat_nat,   iter);
            env_add (p->env, p->sem.ii.item, aat_pre,   root_pre);
            env_add (p->env, p->sem.ii.item, aat_frag, root_frag);
        }
            break; /* fold) */

        /* Fcns:     fcns (Twig, Fcns) */
        case 105: /* fold( */
        { /* top-down */

            /* traverse the DAG in sequence order */
            reduce(kids[0], nts[0]);
            reduce(kids[1], nts[1]);

            /* propagate the size information of the content
               operators underneath */
            if (env_count (L(p)->env) &&
                env_count (R(p)->env)) {
                mvar_t *v = new_var (1);
                mvar_t *l = env_at (L(p)->env, 0).mvar;
                mvar_t *r = env_at (R(p)->env, 0).mvar;

                assert (env_count (L(p)->env) == 1);
                assert (env_count (R(p)->env) == 1);

                execute (
                    assgn (var (v->name),
                           madd (var (l->name), var (r->name))));

                env_add (p->env,
                         env_at (L(p)->env, 0).att,
                         env_at (L(p)->env, 0).ty,
                         v);

            } else if (env_count (L(p)->env)) {

                assert (env_count (L(p)->env) == 1);
                env_add (p->env,
                         env_at (L(p)->env, 0).att,
                         env_at (L(p)->env, 0).ty,
                         env_at (L(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);

            } else if (env_count (R(p)->env)) {

                assert (env_count (R(p)->env) == 1);
                env_add (p->env,
                         env_at (R(p)->env, 0).att,
                         env_at (R(p)->env, 0).ty,
                         env_at (R(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);
            }
        }
            break; /* fold) */

        /* Fcns:     fcns (Twig, nil) */
        case 106: /* fold( */
            /* propagate the size information of the content
               operators underneath */
            if (env_count (L(p)->env)) {
                assert (env_count (L(p)->env) == 1);
                env_add (p->env,
                         env_at (L(p)->env, 0).att,
                         env_at (L(p)->env, 0).ty,
                         env_at (L(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);
            }
            break; /* fold) */

        /* Twig:     docnode (Rel, fcns (nil, nil)) */
        case 107: /* fold( */
            assert (type_of (L(p), p->sem.ii.iter) == aat_nat);
        {
            mvar_t  *v = new_var (1);
            PFmil_t *iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);

            execute (
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (twig_state->pre))),
                /* size */
                bappend (var (v->name),
                         project (iter, lit_int (0))),
                /* level */
                bappend (var (v->name),
                         project (iter,
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_DOC))),
                /* prop */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));

            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
            twig_state->pre++;
            twig_state->size++;
        }
            break; /* fold) */

        /* Twig:     docnode (Rel, Fcns) */
        case 108: /* fold( */
            assert (type_of (L(p), p->sem.ii.iter) == aat_nat);
        { /* top-down */
            unsigned int old_twig_state_pre,
                         old_twig_state_parent,
                         old_twig_state_size;
            mvar_t  *v = new_var (1);
            mvar_t  *size = new_var (1);
            PFmil_t *iter;

            /* translate the qnames */
            reduce(kids[0], nts[0]);

            iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);

            /* add the element representation into the ordered
               twig state list to ensure that the constructed node
               appears before all children */
            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;

            /* store the twig state information
               and prepare for the translation of the children */
            old_twig_state_pre    = twig_state->pre;
            old_twig_state_parent = twig_state->parent;
            old_twig_state_size   = twig_state->size;

            twig_state->parent = twig_state->pre;
            twig_state->pre++;
            twig_state->size = 0;
            twig_state->level++;
            /* Use the iter column of the root twig operator
               as loop relation for the content operator.

               NOTE: We have to use the root twig operator
               (the one the content operator is nested in)
               as otherwise the variable stored in twig_state->loop
               might not be pinned anymore before the content operator
               can use it. */
            if (!twig_state->loop)
                twig_state->loop = iter;

            /* translate the children */
            reduce(kids[1], nts[1]);

            /* reset the level information */
            twig_state->level--;

            /* calculate the sizes */
            if (env_count (R(p)->env) && twig_state->size) {
                mvar_t *content_size = env_at (R(p)->env, 0).mvar;

                assert (env_count (R(p)->env) == 1);

                execute (
                    assgn (var (size->name),
                           madd (var (content_size->name),
                                 lit_int (twig_state->size))));

                env_add (p->env,
                         env_at (R(p)->env, 0).att,
                         env_at (R(p)->env, 0).ty,
                         env_at (R(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);

            } else if (env_count (R(p)->env)) {
                mvar_t *content_size = env_at (R(p)->env, 0).mvar;

                assert (env_count (R(p)->env) == 1);

                execute (
                    assgn (var (size->name),
                           var (content_size->name)));

                env_add (p->env,
                         env_at (R(p)->env, 0).att,
                         env_at (R(p)->env, 0).ty,
                         env_at (R(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);

            } else {
                execute (
                    assgn (var (size->name),
                           project (iter, lit_int (twig_state->size))));
            }

            execute (
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (old_twig_state_pre))),
                /* size */
                bappend (var (v->name), var (size->name)),
                /* level */
                bappend (var (v->name),
                         project (iter,
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_DOC))),
                /* prop */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));

            unpin (size, 1);

            twig_state->size = twig_state->size + old_twig_state_size + 1;
            twig_state->parent = old_twig_state_parent;
        }
            break; /* fold) */

        /* Twig:     element (Rel, fcns (nil, nil)) */
        case 109: /* fold( */
            assert (type_of (L(p), p->sem.ii.iter) == aat_nat);
            assert (type_of (L(p), p->sem.ii.item) == aat_qname);
        {
            mvar_t  *v     = new_var (1),
                    *qn_id = new_var (1);
            PFmil_t *iter  = VAR (L(p)->env, p->sem.ii.iter, aat_nat);

            /* Ensure that the QNames are stored in the WS container
               and copy them if they reside in a different container. */
            copy_QName (
                env_mvar (L(p)->env, p->sem.ii.item, aat_qname_id),
                env_mvar (L(p)->env, p->sem.ii.item, aat_qname_cont),
                qn_id);

            execute (
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (twig_state->pre))),
                /* size */
                bappend (var (v->name),
                         project (iter, lit_int (0))),
                /* level */
                bappend (var (v->name),
                         project (iter,
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_ELEM))),
                /* prop */
                bappend (var (v->name), var (qn_id->name)),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));

            unpin (qn_id, 1);

            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
            twig_state->pre++;
            twig_state->size++;
        }
            break; /* fold) */

        /* Twig:     element (Rel, Fcns) */
        case  110: /* fold( */
            assert (type_of (L(p), p->sem.ii.iter) == aat_nat);
            assert (type_of (L(p), p->sem.ii.item) == aat_qname);
        { /* top-down */
            unsigned int old_twig_state_pre,
                         old_twig_state_parent,
                         old_twig_state_size;
            mvar_t  *v     = new_var (1),
                    *qn_id = new_var (1),
                    *size  = new_var (1);
            PFmil_t *iter;

            /* translate the qnames */
            reduce(kids[0], nts[0]);

            iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);

            /* Ensure that the QNames are stored in the WS container
               and copy them if they reside in a different container. */
            copy_QName (
                env_mvar (L(p)->env, p->sem.ii.item, aat_qname_id),
                env_mvar (L(p)->env, p->sem.ii.item, aat_qname_cont),
                qn_id);

            /* add the element representation into the ordered
               twig state list to ensure that the constructed node
               appears before all children */
            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;

            /* store the twig state information
               and prepare for the translation of the children */
            old_twig_state_pre    = twig_state->pre;
            old_twig_state_parent = twig_state->parent;
            old_twig_state_size   = twig_state->size;

            twig_state->parent = twig_state->pre;
            twig_state->pre++;
            twig_state->size = 0;
            twig_state->level++;
            /* Use the iter column of the root twig operator
               as loop relation for the content operator.

               NOTE: We have to use the root twig operator
               (the one the content operator is nested in)
               as otherwise the variable stored in twig_state->loop
               might not be pinned anymore before the content operator
               can use it. */
            if (!twig_state->loop)
                twig_state->loop = iter;

            /* translate the children */
            reduce(kids[1], nts[1]);

            /* reset the level information */
            twig_state->level--;

            /* calculate the sizes */
            if (env_count (R(p)->env) && twig_state->size) {
                mvar_t *content_size = env_at (R(p)->env, 0).mvar;

                assert (env_count (R(p)->env) == 1);

                execute (
                    assgn (var (size->name),
                           madd (var (content_size->name),
                                 lit_int (twig_state->size))));

                env_add (p->env,
                         env_at (R(p)->env, 0).att,
                         env_at (R(p)->env, 0).ty,
                         env_at (R(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);

            } else if (env_count (R(p)->env)) {
                mvar_t *content_size = env_at (R(p)->env, 0).mvar;

                assert (env_count (R(p)->env) == 1);

                execute (
                    assgn (var (size->name),
                           var (content_size->name)));

                env_add (p->env,
                         env_at (R(p)->env, 0).att,
                         env_at (R(p)->env, 0).ty,
                         env_at (R(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);

            } else {
                execute (
                    assgn (var (size->name),
                           project (iter, lit_int (twig_state->size))));
            }

            execute (
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (old_twig_state_pre))),
                /* size */
                bappend (var (v->name), var (size->name)),
                /* level */
                bappend (var (v->name),
                         project (iter,
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_ELEM))),
                /* prop */
                bappend (var (v->name), var (qn_id->name)),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));

            unpin (qn_id, 1);
            unpin (size, 1);

            twig_state->size = twig_state->size + old_twig_state_size + 1;
            twig_state->parent = old_twig_state_parent;
        }
            break; /* fold) */

        /* Twig:     attribute (Rel) */
        case 111: /* fold( */
            assert (type_of (L(p), p->sem.iter_item1_item2.iter) == aat_nat);
            assert (type_of (L(p), p->sem.iter_item1_item2.item1) == aat_qname);
            assert (type_of (L(p), p->sem.iter_item1_item2.item2) == aat_str);
        {
            mvar_t     *v      = new_var (1),
                       *qn_id  = new_var (1),
                       *prop   = new_var (1);
            PFmil_t    *iter   = VAR (L(p)->env,
                                      p->sem.iter_item1_item2.iter,
                                      aat_nat);
            PFalg_att_t qn_att = p->sem.iter_item1_item2.item1;
            PFmil_t    *val    = VAR (L(p)->env,
                                      p->sem.iter_item1_item2.item2,
                                      aat_str);

            /* Ensure that the QNames are stored in the WS container
               and copy them if they reside in a different container. */
            copy_QName (
                env_mvar (L(p)->env, qn_att, aat_qname_id),
                env_mvar (L(p)->env, qn_att, aat_qname_cont),
                qn_id);

            execute (
                assgn (var (prop->name),
                       add_content (val,
                                    var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PROP_VAL))),
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre (parent) */
                bappend (var (v->name),
                         project (iter, lit_oid (twig_state->parent))),
                /* qname */
                bappend (var (v->name), var (qn_id->name)),
                /* value */
                bappend (var (v->name), var (prop->name)),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))));

            unpin (qn_id, 1);
            unpin (prop, 1);

            *(mvar_t **) PFarray_add (twig_state->attr_vars) = v;
        }
            break; /* fold) */

        /* Twig:     textnode (Rel) */
        case 112: /* fold( */
            assert (type_of (L(p), p->sem.ii.iter) == aat_nat);
            assert (type_of (L(p), p->sem.ii.item) == aat_str);
        {
            mvar_t  *v = new_var (1);
            mvar_t  *prop = new_var (1);
            PFmil_t *iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);
            PFmil_t *item = VAR (L(p)->env, p->sem.ii.item, aat_str);

            execute (
                assgn (var (prop->name),
                       add_content (item,
                                    var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PROP_TEXT))),
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (twig_state->pre))),
                /* size */
                bappend (var (v->name),
                         project (iter, lit_int (0))),
                /* level */
                bappend (var (v->name),
                         project (iter,
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_TEXT))),
                /* prop */
                bappend (var (v->name), var (prop->name)),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));

            unpin (prop, 1);

            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
            twig_state->pre++;
            twig_state->size++;
        }
            break; /* fold) */

        /* Twig:     comment (Rel) */
        case 113: /* fold( */
            assert (type_of (L(p), p->sem.ii.iter) == aat_nat);
            assert (type_of (L(p), p->sem.ii.item) == aat_str);
        {
            mvar_t  *v = new_var (1);
            mvar_t  *prop = new_var (1);
            PFmil_t *iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);
            PFmil_t *item = VAR (L(p)->env, p->sem.ii.item, aat_str);

            execute (
                assgn (var (prop->name),
                       add_content (item,
                                    var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PROP_COM))),
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (twig_state->pre))),
                /* size */
                bappend (var (v->name),
                         project (iter, lit_int (0))),
                /* level */
                bappend (var (v->name),
                         project (iter,
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_COM))),
                /* prop */
                bappend (var (v->name), var (prop->name)),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));

            unpin (prop, 1);

            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
            twig_state->pre++;
            twig_state->size++;
        }
            break; /* fold) */

        /* Twig:     processi (Rel) */
        case 114: /* fold( */
            assert (!"not implemented yet");
            break; /* fold) */

        /* Twig:     content (Rel) */
        case 115:
        /* Twig:     slim_content (Rel) */
        case 116: /* fold( */
            assert (type_of (L(p), p->sem.ii.iter) == aat_nat);
            assert (!(type_of (L(p), p->sem.ii.item) & ~aat_node));
        {
            PFalg_simple_type_t item_ty    = type_of (L(p), p->sem.ii.item);
            mvar_t             *a_iter     = NULL,
                               *a_item     = NULL,
                               *a_cont     = NULL,
                               *p_iter     = NULL,
                               *p_item     = NULL,
                               *p_cont     = NULL;
            bool                treat_attr = false,
                                treat_pre  = false;

            /* based on the item type treat only attributes or other nodes */
            if (item_ty == aat_pnode) {
                treat_pre = true;
                p_iter = env_mvar (L(p)->env, p->sem.ii.iter, aat_nat);
                p_item = env_mvar (L(p)->env, p->sem.ii.item, aat_pre);
                p_cont = env_mvar (L(p)->env, p->sem.ii.item, aat_frag);
            } else if (item_ty == aat_anode) {
                treat_attr = true;
                a_iter = env_mvar (L(p)->env, p->sem.ii.iter, aat_nat);
                a_item = env_mvar (L(p)->env, p->sem.ii.item, aat_attr);
                a_cont = env_mvar (L(p)->env, p->sem.ii.item, aat_frag);
            } else /* mixed content */ {
                mvar_t *attr = new_var (1),
                       *sel  = new_var (1),
                       *iter = env_mvar (L(p)->env, p->sem.ii.iter, aat_nat),
                       *frag = env_mvar (L(p)->env, p->sem.ii.item, aat_frag),
                       *tmp;

                treat_pre  = true;
                treat_attr = true;

                p_iter = new_var (1);
                p_item = new_var (1);
                p_cont = new_var (1);
                a_iter = new_var (1);
                a_item = new_var (1);
                a_cont = new_var (1);

                /* create a boolean BAT that distinct attributes
                   and other nodes */

                /* attr := [isnil](attr); */
                execute (
                    assgn (
                        var (attr->name),
                        misnil (VAR (L(p)->env, p->sem.ii.item, aat_attr))));

                /* split up by nodes... */

                /* sel    := attr.uselect(true).hmark(0@0);
                   p_item := leftfetchjoin (sel, pre);
                   p_iter := leftfetchjoin (sel, iter);
                   p_cont := leftfetchjoin (sel, frag); */
                tmp = env_mvar (L(p)->env, p->sem.ii.item, aat_pre);
                execute (
                    assgn (var (sel->name),
                           hmark (select_ (var (attr->name), lit_bit (true)),
                                  lit_oid (0))),
                    assgn (var (p_item->name),
                           leftfetchjoin (var (sel->name), var (tmp->name))),
                    assgn (var (p_iter->name),
                           leftfetchjoin (var (sel->name), var (iter->name))),
                    assgn (var (p_cont->name),
                           leftfetchjoin (var (sel->name), var (frag->name))));

                /* ... and attributes */

                /* sel    := attr.uselect(false).hmark(0@0);
                   a_item := leftfetchjoin (sel, pre);
                   a_iter := leftfetchjoin (sel, iter);
                   a_cont := leftfetchjoin (sel, frag); */
                tmp = env_mvar (L(p)->env, p->sem.ii.item, aat_attr);
                execute (
                    assgn (var (sel->name),
                           hmark (select_ (var (attr->name), lit_bit (false)),
                                  lit_oid (0))),
                    assgn (var (a_item->name),
                           leftfetchjoin (var (sel->name), var (tmp->name))),
                    assgn (var (a_iter->name),
                           leftfetchjoin (var (sel->name), var (iter->name))),
                    assgn (var (a_cont->name),
                           leftfetchjoin (var (sel->name), var (frag->name))));

                unpin (attr, 1);
                unpin (sel, 1);
            }

            /* first handle root attributes */
            if (treat_attr) {
                mvar_t  *v = new_var (1);

                /* collect attribute names, values, and container... */
                execute (
                    assgn (var (v->name),
                           seqbase (new (type (mty_void), type (mty_bat)),
                                    lit_oid (0))),
                    /* iter */
                    bappend (var (v->name), var (a_iter->name)),
                    /* pre (parent) */
                    bappend (var (v->name),
                             project (var (a_iter->name),
                                      lit_oid (twig_state->parent))),
                    /* qname */
                    bappend (var (v->name),
                             mposjoin (
                                 var (a_item->name),
                                 var (a_cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_ATTR_QN)))),
                    /* value */
                    bappend (var (v->name),
                             mposjoin (
                                 var (a_item->name),
                                 var (a_cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_ATTR_PROP)))),
                    /* cont */
                    bappend (var (v->name),
                             mposjoin (
                                 var (a_item->name),
                                 var (a_cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_ATTR_CONT)))));

                /* ... and add them to list of root attributes */
                *(mvar_t **) PFarray_add (twig_state->attr_vars) = v;
            }

            if (treat_pre && p->kind == pa_content) {
                mvar_t  *unq_iter, *scj_res, *root_level, *content_level;
                mvar_t  *iter = new_var (1);
                mvar_t  *item = new_var (1);
                mvar_t  *cont = new_var (1);
                mvar_t  *v    = new_var (1);

                unq_iter = new_var (1);
                scj_res  = new_var (1);
                /* evaluate descendant-or-self::node() step:
                   unq_iter := p_iter.mirror();
                   scj_res := step (AXIS_descendant_or_self,
                                    TEST_none,
                                    p_iter, p_cont, p_item, nil, ws, 0,
                                    chr(nil), str(nil), str(nil), str(nil));
                   iter := scj_res.fetch(0);
                   item := scj_res.fetch(2);
                   # cont is probably a fake project
                   cont := scj_res.fetch(1);
                   # avoid iter being a fake project
                   iter := materialize(iter, item); */
                execute (
                    assgn (
                        var (unq_iter->name),
                        mirror (var (p_iter->name))),
                    assgn (
                        var (scj_res->name),
                        step (var (PF_MIL_VAR_AXIS_DESC_S),
                              var (PF_MIL_VAR_CODE_NONE),
                              var (unq_iter->name),
                              var (p_cont->name),
                              var (p_item->name),
                              nil (),
                              var (PF_MIL_VAR_WS),
                              lit_int (0),
                              cast (type (mty_chr), nil ()),
                              cast (type (mty_str), nil ()),
                              cast (type (mty_str), nil ()),
                              cast (type (mty_str), nil ()))),
                    assgn (
                        var (iter->name),
                        fetch(var (scj_res->name), lit_int (0))),
                    assgn (
                        var (item->name),
                        fetch(var (scj_res->name), lit_int (2))),
                    assgn (
                        var (cont->name),
                        fetch(var (scj_res->name), lit_int (1))),
                    assgn (
                        var (iter->name),
                        materialize (
                            var (iter->name),
                            var (item->name))));
                unpin (unq_iter, 1);
                unpin (scj_res, 1);

                root_level    = new_var (1);
                content_level = new_var (1);
                /* collect node values and insert them into
                   list of twig constructors:
                   v := new(void, bat).seqbase(0@0);
                   v.append(iter.leftjoin(p_iter).chk_order());
                   v.append(item.project(%twig_state->pre%));
                   v.append(mposjoin(item,cont,ws.fetch(PRE_SIZE)));
                   root_level := mposjoin(p_item,p_cont,ws.fetch(PRE_LEVEL));
                   # map root_level to the correct cardinality
                   root_level := iter.leftjoin(root_level);
                   content_level := mposjoin(item,cont,ws.fetch(PRE_LEVEL));
                   content_level := [-](content_level, root_level);
                   content_level := [+](content_level, %twig_state->level%);
                   v.append(content_level);
                   v.append(mposjoin(item,cont,ws.fetch(PRE_KIND)));
                   v.append(mposjoin(item,cont,ws.fetch(PRE_PROP)));
                   v.append(mposjoin(item,cont,ws.fetch(PRE_CONT)));
                   v.append(item);
                   # avoid cont being a fake project
                   v.append(materialize (cont, item));
                   */
                execute (
                    assgn (var (v->name),
                           seqbase (new (type (mty_void), type (mty_bat)),
                                    lit_oid (0))),
                    /* iter */
                    bappend (var (v->name),
                             chk_order (
                                 leftjoin (
                                     var (iter->name),
                                     var (p_iter->name)))),
                    /* pre */
                    bappend (var (v->name),
                             project (
                                 var (item->name),
                                 lit_oid (twig_state->pre))),
                    /* size */
                    bappend (var (v->name),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_SIZE)))),
                    /* level */
                    assgn (
                        var (root_level->name),
                         mposjoin (
                             var (p_item->name),
                             var (p_cont->name),
                             fetch (var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PRE_LEVEL)))),
                    assgn (
                        var (root_level->name),
                        leftjoin (
                            var (iter->name),
                            var (root_level->name))),
                    assgn (
                        var (content_level->name),
                         mposjoin (
                             var (item->name),
                             var (cont->name),
                             fetch (var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PRE_LEVEL)))),
                    assgn (
                        var (content_level->name),
                        msub (
                            var (content_level->name),
                            var (root_level->name))),
                    assgn (
                        var (content_level->name),
                        madd (
                            var (content_level->name),
                            cast (
                                type (mty_chr),
                                lit_int (twig_state->level)))),
                    bappend (var (v->name),
                             var (content_level->name)),
                    /* kind */
                    bappend (var (v->name),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_KIND)))),
                    /* prop */
                    bappend (var (v->name),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_PROP)))),
                    /* cont */
                    bappend (var (v->name),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_CONT)))),
                    /* old_pre */
                    bappend (var (v->name),
                             var (item->name)),
                    /* old_cont */
                    bappend (var (v->name),
                             materialize (
                                 var (cont->name),
                                 var (item->name))));
                unpin (root_level, 1);
                unpin (content_level, 1);
                unpin (iter, 1);
                unpin (item, 1);
                unpin (cont, 1);

                *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
                twig_state->pre++;
                /* tell the twig constructor to handle
                   subtree attribute copies */
                twig_state->elem_content = true;

                /* add summed sizes to the environment */
                if (twig_state->loop) {
                    mvar_t *sizes = new_var (1);
                    mvar_t *gsize = new_var (1);

                    /* sizes := mposjoin(p_item,p_cont,ws.fetch(PRE_SIZE);
                       # don't forget the node itself
                       sizes := [+](sizes, 1);
                       sizes := p_iter.reverse().leftjoin(sizes);
                       gsize := {sum}(sizes,%twig_state->loop%.reverse());
                       # map back to head values
                       sizes := %twig_state->loop%.leftjoin(gsize); */
                    execute (
                        assgn (
                            var (sizes->name),
                            mposjoin (
                                var (p_item->name),
                                var (p_cont->name),
                                fetch (var (PF_MIL_VAR_WS),
                                       var (PF_MIL_VAR_PRE_SIZE)))),
                        assgn (
                            var (sizes->name),
                            madd (var (sizes->name), lit_int (1))),
                        assgn (
                            var (sizes->name),
                            leftjoin (
                                reverse (var (p_iter->name)),
                                var (sizes->name))),
                        assgn (
                            var (gsize->name),
                            egsum (
                                var (sizes->name),
                                reverse (twig_state->loop))),
                        assgn (
                            var (gsize->name),
                            leftjoin (
                                twig_state->loop,
                                var (gsize->name))));
                    unpin (sizes, 1);
                    /* add the grouped sizes to the variable environment */
                    env_add (p->env, att_NULL, aat_int, gsize);
                }
            }
            else if (treat_pre && p->kind == pa_slim_content) {
                mvar_t  *v    = new_var (1);

                /* add the node references into list of twig constructors
                   (size = 0, kind = REFERENCE, prop = p_prop, cont = p_cont):
                   v := new(void, bat).seqbase(0@0);
                   v.append(p_iter);
                   v.append(p_iter.project(%twig_state->pre%));
                   v.append(p_iter.project(0));
                   v.append(p_iter.project(%twig_state->level%));
                   v.append(p_iter.project(REFERENCE));
                   # store the references to look up the reference
                   # in the PRE_PROP column
                   v.append(p_item);
                   # store the node container to look up the reference
                   # in the PRE_CONT column
                   v.append(p_cont);
                   v.append(p_iter.project(oid(nil)));
                   v.append(p_iter.project(oid(nil)));
                   */
                execute (
                    assgn (var (v->name),
                           seqbase (new (type (mty_void), type (mty_bat)),
                                    lit_oid (0))),
                    /* iter */
                    bappend (var (v->name),
                             var (p_iter->name)),
                    /* pre */
                    bappend (var (v->name),
                             project (
                                 var (p_iter->name),
                                 lit_oid (twig_state->pre))),
                    /* size */
                    bappend (var (v->name),
                             project (
                                 var (p_iter->name),
                                 lit_int (0))),
                    /* level */
                    bappend (var (v->name),
                             project (
                                 var (p_iter->name),
                                 cast (
                                     type (mty_chr),
                                     lit_int (twig_state->level)))),
                    /* kind */
                    bappend (var (v->name),
                             project (
                                 var (p_iter->name),
                                 var (PF_MIL_VAR_KIND_REF))),
                    /* prop */
                    bappend (var (v->name),
                             var (p_item->name)),
                    /* cont */
                    bappend (var (v->name),
                             var (p_cont->name)),
                    /* old_pre */
                    bappend (var (v->name),
                             project (
                                 var (p_iter->name),
                                 cast (type (mty_oid), nil ()))),
                    /* old_cont */
                    bappend (var (v->name),
                             project (
                                 var (p_iter->name),
                                 cast (type (mty_oid), nil ()))));

                *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
                twig_state->pre++;
                /* do not tell the twig constructor to handle
                   subtree attribute copies */
                /* twig_state->elem_content = false; */

                /* add count of the references to the environment */
                if (twig_state->loop) {
                    mvar_t *gsize = new_var (1);

                    /* gsize := {count}(p_iter.reverse(),
                                        %twig_state->loop%.reverse());
                       # map back to head values
                       gsize := %twig_state->loop%.leftjoin(gsize); */
                    execute (
                        assgn (
                            var (gsize->name),
                            egcount (
                                reverse (var (p_iter->name)),
                                reverse (twig_state->loop))),
                        assgn (
                            var (gsize->name),
                            leftjoin (
                                twig_state->loop,
                                var (gsize->name))));

                    /* add the grouped sizes to the variable environment */
                    env_add (p->env, att_NULL, aat_int, gsize);
                }
            }

            if (treat_pre && treat_attr) {
                unpin (p_iter, 1);
                unpin (p_item, 1);
                unpin (p_cont, 1);
                unpin (a_iter, 1);
                unpin (a_item, 1);
                unpin (a_cont, 1);
            }
        }
            break; /* fold) */

        /* Rel:      merge_adjacent (Rel) */
        case 117: /* fold( */
        {
            PFalg_att_t         iter_att   = p->sem.ii.iter,
                                item_att   = p->sem.ii.item;
            PFalg_simple_type_t item_ty    = type_of (L(p), item_att);
            mvar_t             *iter       = new_var (p->refctr),
                               *pre        = new_var (p->refctr),
                               *frag       = new_var (p->refctr),
                               *a_iter     = NULL,
                               *a_pre      = NULL,
                               *a_attr     = NULL,
                               *a_cont     = NULL,
                               *p_iter     = NULL,
                               *p_pre      = NULL,
                               *p_cont     = NULL,
                               *ma;
            bool                treat_attr = false;

            env_add (p->env, iter_att, aat_nat, iter);
            env_add (p->env, item_att, aat_pre, pre);
            env_add (p->env, item_att, aat_frag, frag);

            /* if we have attributes and other nodes we need to
               split them up first */
            if (item_ty & aat_attr) {
                mvar_t *attr    = new_var (1),
                       *sel     = new_var (1),
                       *in_iter = env_mvar (L(p)->env, iter_att, aat_nat),
                       *in_frag = env_mvar (L(p)->env, item_att, aat_frag),
                       *in_pre  = env_mvar (L(p)->env, item_att, aat_pre),
                       *in_attr = env_mvar (L(p)->env, item_att, aat_attr);

                treat_attr = true;

                p_iter = new_var (1);
                p_pre  = new_var (1);
                p_cont = new_var (1);
                a_iter = new_var (1);
                a_pre  = new_var (1);
                a_attr = new_var (1);
                a_cont = new_var (1);

                /* create a boolean BAT that distinct attributes
                   and other nodes */

                /* attr := [isnil](attr); */
                execute (
                    assgn (
                        var (attr->name),
                        misnil (var (in_attr->name))));

                /* split up by nodes... */

                /* sel    := attr.uselect(true).hmark(0@0);
                   p_pre  := leftfetchjoin (sel, pre);
                   p_iter := leftfetchjoin (sel, iter);
                   p_cont := leftfetchjoin (sel, frag); */
                execute (
                    assgn (var (sel->name),
                           hmark (select_ (var (attr->name), lit_bit (false)),
                                  lit_oid (0))),
                    assgn (var (p_pre->name),
                           leftfetchjoin (var (sel->name),
                                          var (in_pre->name))),
                    assgn (var (p_iter->name),
                           leftfetchjoin (var (sel->name),
                                          var (in_iter->name))),
                    assgn (var (p_cont->name),
                           leftfetchjoin (var (sel->name),
                                          var (in_frag->name))));

                /* ... and attributes */

                /* sel    := attr.uselect(false).hmark(0@0);
                   a_pre  := leftfetchjoin (sel, pre);
                   a_attr := leftfetchjoin (sel, attr);
                   a_iter := leftfetchjoin (sel, iter);
                   a_cont := leftfetchjoin (sel, frag); */
                execute (
                    assgn (var (sel->name),
                           hmark (select_ (var (attr->name), lit_bit (true)),
                                  lit_oid (0))),
                    assgn (var (a_pre->name),
                           leftfetchjoin (var (sel->name),
                                          var (in_pre->name))),
                    assgn (var (a_attr->name),
                           leftfetchjoin (var (sel->name),
                                          var (in_attr->name))),
                    assgn (var (a_iter->name),
                           leftfetchjoin (var (sel->name),
                                          var (in_iter->name))),
                    assgn (var (a_cont->name),
                           leftfetchjoin (var (sel->name),
                                          var (in_frag->name))));

                unpin (attr, 1);
                unpin (sel, 1);
            }
            else {
                p_iter = env_mvar (L(p)->env, iter_att, aat_nat);
                p_pre  = env_mvar (L(p)->env, item_att, aat_pre);
                p_cont = env_mvar (L(p)->env, item_att, aat_frag);
            }

            /* apply the merge_adjacent operation */
            ma = new_var (1);

            execute (
                assgn (var (ma->name),
                       merge_adjacent (var (p_iter->name),
                                       var (p_pre->name),
                                       var (p_cont->name),
                                       var (PF_MIL_VAR_WS))),
                assgn (var (iter->name),
                       leftfetchjoin (
                           hmark (fetch (var (ma->name), lit_int (1)),
                                  lit_oid (0)),
                           VAR (L(p)->env, iter_att, aat_nat))),
                assgn (var (pre->name),
                       tmark (fetch (var (ma->name), lit_int (1)),
                              lit_oid (0))),
                assgn (var (frag->name),
                       tmark (fetch (var (ma->name), lit_int (2)),
                              lit_oid (0))),
                assgn (var (PF_MIL_VAR_WS),
                       fetch (var (ma->name), lit_int (0))));

            unpin (ma, 1);

            /* if we have attributes and other nodes we need to
               merge them back again */
            if (treat_attr) {
                mvar_t *mu   = new_var (1),
                       *attr = new_var (p->refctr);

                env_add (p->env, item_att, aat_frag, attr);

                /* Attributes have to appear before the other nodes.
                   Otherwise the node constructors may fail.
                   (In our scenario it however doesn't matteri
                    as we split them up anyway.) */
                execute (
                    assgn (var (mu->name),
                           arg (var (a_iter->name),
                           arg (var (iter->name),
                           arg (var (a_pre->name),
                           arg (var (pre->name),
                           arg (var (a_attr->name),
                           arg (project (var (iter->name),
                                         cast (type (mty_oid), nil ())),
                           arg (var (a_cont->name),
                                var (frag->name))))))))),
                    assgn (var (iter->name),
                           fetch (var (mu->name), lit_int (0))),
                    assgn (var (pre->name),
                           fetch (var (mu->name), lit_int (1))),
                    assgn (var (attr->name),
                           fetch (var (mu->name), lit_int (2))),
                    assgn (var (frag->name),
                           fetch (var (mu->name), lit_int (3))));

                unpin (mu, 1);

                unpin (p_iter, 1);
                unpin (p_pre, 1);
                unpin (p_cont, 1);
                unpin (a_iter, 1);
                unpin (a_pre, 1);
                unpin (a_attr, 1);
                unpin (a_cont, 1);
            }
        }   break; /* fold) */

        /* Rel:      error(Rel) */
        case 129: /* fold( */
            execute (
                if_ (eq (count (VAR (L(p)->env, p->sem.err.att, aat_str)),
                         lit_int (0)),
                     nop(),
                     error (fetch (VAR (L(p)->env, p->sem.err.att, aat_str),
                                   lit_int (0)))));

            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                /* make sure that the implicit type change
                   is correctly implemented */
                if (env_at (L(p)->env, i).att == p->sem.err.att) {
                    PFalg_simple_type_t ty = type_of (p, p->sem.err.att);
                    assert (env_at (L(p)->env, i).ty == aat_str);

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & TYPE_MASK(ty)) {
                            /* create new variable */
                            mvar_t *v  = new_var (p->refctr);
                            /* dummy assignment */
                            execute (
                                assgn (var (v->name),
                                       seqbase (new (type (mty_void),
                                                     implty (t)),
                                                lit_oid (0))));
                            env_add (p->env, p->sem.err.att, t, v);
                        }
                }
                else {
                    pin (env_at (L(p)->env, i).mvar, p->refctr);
                    env_add (p->env,
                             env_at (L(p)->env, i).att,
                             env_at (L(p)->env, i).ty,
                             env_at (L(p)->env, i).mvar);
                }
            }
            break; /* fold) */

        /* Rel:      cond_err (Rel, Rel) */
        case 130: /* fold( */
            execute (
                if_ (exist (reverse (VAR (R(p)->env, p->sem.err.att, aat_bln)),
                            lit_bit (false)),
                     error (lit_str (p->sem.err.str)),
                     nop ()));

            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);
            break; /* fold) */

        /* Rel:      cond_err (Rel, empty_tbl) */
        case 131: /* fold( */
            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);
            break; /* fold) */

        /* Rel:      trace (Rel, trace_msg (Rel, Map)) */
        case 135:
        /* Rel:      trace (Rel, trace_msg (Rel, nil)) */
        case 136: /* fold( */
        {
            unsigned trace_id = new_trace_id ();
            PFmil_t *iter = NULL,
                    *item = NULL;

            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);

                /* as a side effect fill in the trace information */
                if (env_at (L(p)->env, i).att == p->sem.ii.iter) {
                    /* fill in the iter information */
                    execute (
                        insert (var (PF_MIL_VAR_TRACE_ITER),
                                lit_oid (trace_id),
                                var (env_at (L(p)->env, i).mvar->name)));
                }
                else if (env_at (L(p)->env, i).att == p->sem.ii.item) {
                    /* fill in the item information */
                    execute (
                        insert (var (PF_MIL_VAR_TRACE_ITEM),
                                lit_oid (trace_id),
                                var (env_at (L(p)->env, i).mvar->name)),
                        insert (var (PF_MIL_VAR_TRACE_TYPE),
                                lit_oid (trace_id),
                                lit_int (env_at (L(p)->env, i).ty)));
                }
            }

            /* collect the message information */
            iter = VAR (RL(p)->env, R(p)->sem.ii.iter, aat_nat);
            assert (iter);
            item = VAR (RL(p)->env, R(p)->sem.ii.item, aat_str);
            assert (item);

            execute (
                insert (var (PF_MIL_VAR_TRACE_MSG),
                        lit_oid (trace_id),
                        leftjoin (reverse (iter), item)));

            /* fill in the relationship between the trace and the
               last map relation */
            if (RR(p)->kind == pa_nil)
                execute (
                    insert (var (PF_MIL_VAR_TRACE_REL),
                            lit_oid (0),
                            lit_oid (trace_id)));
            else
                execute (
                    insert (var (PF_MIL_VAR_TRACE_REL),
                            lit_oid (RR(p)->sem.trace_map.trace_id),
                            lit_oid (trace_id)));
        }   break; /* fold) */

        /* Map:      trace_map (Rel, Map) */
        case 137:
        /* Map:      trace_map (Rel, nil) */
        case 138: /* fold( */
        {
            unsigned trace_id = new_trace_id ();
            /* store the trace_id */
            p->sem.trace_map.trace_id = trace_id;

            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                if (env_at (L(p)->env, i).att == p->sem.trace_map.outer) {
                    /* fill in the iter information */
                    execute (
                        insert (var (PF_MIL_VAR_TRACE_OUTER),
                                lit_oid (trace_id),
                                var (env_at (L(p)->env, i).mvar->name)));
                }
                else if (env_at (L(p)->env, i).att == p->sem.trace_map.inner) {
                    /* fill in the item information */
                    execute (
                        insert (var (PF_MIL_VAR_TRACE_INNER),
                                lit_oid (trace_id),
                                var (env_at (L(p)->env, i).mvar->name)));
                }
            }

            /* fill in the relationship between the map relations */
            if (R(p)->kind == pa_nil)
                execute (
                    insert (var (PF_MIL_VAR_TRACE_REL),
                            lit_oid (0),
                            lit_oid (trace_id)));
            else
                execute (
                    insert (var (PF_MIL_VAR_TRACE_REL),
                            lit_oid (R(p)->sem.trace_map.trace_id),
                            lit_oid (trace_id)));
        }   break; /* fold) */

        /* Rel:      rec_fix (Rec, Rel) */
        case 140: /* fold( */
        {
            PFmil_t *oldmilprog, *bodymilprog;
            PFarray_t *res_env;
            mvar_t *old_count, *new_count;
            PFarray_t *border_vars = PFarray (sizeof (mvar_t *), 10);

            /* Generate code for the seeds and bind them to the new variables.
               In addition generate code for all expressions that are
               invariant to the recursion body (all expressions underneath
               a rec_border operator) and pin the variables holding the
               results once more such they are not released in the recursion
               body (references stored in border_vars). */
            reduce1(kids[0], nts[0], border_vars);

            old_count = new_var (1);
            new_count = new_var (1);

            /* initialize the result counters */
            execute (
                assgn (var (old_count->name),
                       lit_int (-1)),
                assgn (var (new_count->name),
                       lit_int (0)));

            /* save the current mil program */
            oldmilprog = milprog;

            /* create a new empty milprog */
            milprog = nop ();

            /* translate the recursion body and
               reassign the recursion variables */
            reduce2(kids[0], nts[0]);

            /* get the result environment */
            reduce(kids[1], nts[1]);
            res_env = R(p)->env;

            /* update the result counters */
            execute (
                assgn (var (old_count->name),
                       var (new_count->name)),
                assgn (var (new_count->name),
                       count (var (env_at (res_env, 0).mvar->name))));

            /* make the old mil program the active one */
            bodymilprog = milprog;
            milprog = oldmilprog;

            /* apply the while statement */
            execute (
                while_ (
                  gt (var (new_count->name),
                      var (old_count->name)),
                  bodymilprog));

            /* the condition variables are not needed anymore */
            unpin (new_count, 1);
            unpin (old_count, 1);

            /* copy all the result attributes */
            for (unsigned int i = 0; i < env_count (res_env); i++) {
                pin (env_at (res_env, i).mvar,
                     p->refctr);

                env_add (p->env,
                         env_at (res_env, i).att,
                         env_at (res_env, i).ty,
                         env_at (res_env, i).mvar);
            }

            /* release the additional pins of the variables
               representing the recursion invariant expressions */
            for (unsigned int i = 0; i < PFarray_last (border_vars); i++)
                unpin (*(mvar_t **) PFarray_at (border_vars, i), 1);

            /* release all the pins of the while loop arguments */
            reduce3(kids[0], nts[0]);

            /* ensure that the child of p (the first argument) still
               has one pin left to release (see bottom of function reduce) */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++)
                pin (env_at (L(p)->env, i).mvar, 1);
        }   break; /* fold) */

        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 141:
        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 142:
        /* Rec:      nil */
        case 143:
            /* the rules are called via reduce1, reduce2, and reduce3 */
            break;

        /* Rel:      rec_base */
        case 144:
            /* no MIL code needed */

            /* The environment already contains the bindings.
               See rules:
                  rec_param (rec_arg (Rel, Rel), Rec)
                and
                  rec_param (rec_arg (empty_tbl, Rel), Rec))
                in function reduce1 */
            break;

        /* Rel:      rec_border (Rel) */
        case 145: /* fold( */
            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);
            break; /* fold) */

        /* Rel:      FunRel */
        case 150:
            /* no operator -- nothing to do */
            break;

        /* FunRel:   fun_call (Rel, Param) */
        case 151: /* fold( */
        {   /* TOPDOWN */
            PFarray_t *old_fun_params;
            PFpa_op_t *param;

            /* Collect the destinations */
            reduce (kids[0], nts[0]);

            old_fun_params = fun_params;

            /* We will collect the parameters here */
            fun_params = PFarray (sizeof (PFpa_op_t **), 10);

            /* Top-down processing puts all parameters into this array */
            reduce (kids[1], nts[1]);

            /* All function parameters are now in the array `fun_params'. */

            /***********************************/
            /*                                 */
            /* DO FUNCTION TRANSFORMATION HERE */
            /*                                 */
            /***********************************/

            /* PFalg_att_t funcall_loop = p->sem.fun_call.iter; */

            if (p->sem.fun_call.kind == alg_fun_call_xrpc) {
                PFcnode_t *core_apply = (PFcnode_t *) p->sem.fun_call.ctx;

                /* do XRPC stuff here */
                (void)* core_apply;

                /* dummy stub to fill the environment */

                /* create dummy temp variable */
                mvar_t *v  = new_var (1);
                /* add more references to v */
                pin (v, 1);
                /* release all pins */
                unpin (v, 2);

                /* fill the environment for all attributes and columns */
                for (unsigned int i = 0; i < p->schema.count; i++) {
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & TYPE_MASK(p->schema.items[i].type)) {
                            /* create new variable */
                            mvar_t *v  = new_var (p->refctr);
                            /* dummy assignment */
                            execute (
                                assgn (var (v->name),
                                       nil ()));
                            env_add (p->env, p->schema.items[i].name, t, v);
                        }
                }
            } else if (p->sem.fun_call.kind == alg_fun_call_tijah) {
#ifdef HAVE_PFTIJAH
	    const char* fcname = PFqname_loc(p->sem.fun_call.qname);

	    PFalg_att_t fc_iter_a = p->schema.items[0].name; /* fixed */
	    PFalg_att_t fc_pos_a  = p->schema.items[1].name; /* fixed */
	    PFalg_att_t fc_item_a = p->schema.items[2].name; /* fixed */


	    if ( PFT_FUN(fcname) ) {

	        /* handle pftijah functions here */

	        mvar_t *fc_loop = env_mvar (L(p)->env, p->sem.fun_call.iter , aat_nat);

		if ( PFT_FUN_QUERY(fcname) ) {
		    int fcci = 0;
		    PFalg_simple_type_t restype;
		    int returnNodes = PTF_QUERY_NODES(fcname);

		    mvar_t *retNodes    = new_var (1);
		    if ( returnNodes ) {
		        execute (assgn(var(retNodes->name),lit_bit(false)));
			restype = aat_pre;
		    } else {
		        execute (assgn(var(retNodes->name),lit_bit(true)));
			restype = aat_int;
		    }

		    mvar_t *pfop_sn, *pfop_query, *pfop_opt;

		    if ( PTF_QUERY_STARTNODES(fcname) ) {
		        pfop_sn    = pft_create_pfop(*(PFpa_op_t **)PFarray_at (fun_params,fcci),aat_pre);
			fcci++;
		    } else {
		        pfop_sn    = pft_create_pfop(NULL,aat_pre);
		    }

		    pfop_query = pft_create_pfop(*(PFpa_op_t **)PFarray_at (fun_params,fcci),aat_str);
		    fcci++;

		    if ( PTF_QUERY_OPTIONS(fcname) ) {
		        pfop_opt   = pft_create_pfop(*(PFpa_op_t **)PFarray_at (fun_params,fcci),aat_pre);
		    } else {
		        pfop_opt   = pft_create_pfop(NULL,aat_pre);
		    }

		    mvar_t *tjqres = new_var(1);
		    execute(
		        assgn(var(tjqres->name),
			    tj_query_handler(
			    	var(retNodes->name),
				var(pfop_sn->name),
				var(pfop_query->name),
				var(pfop_opt->name),
				var(fc_loop->name),
				var (PF_MIL_VAR_WS),
				var (PF_MIL_TIJAH_SCORE_DB)
			    )
			)
		    );
		    unpin(retNodes,1);

		    unpin(pfop_sn,1);
		    unpin(pfop_query,1);
		    unpin(pfop_opt,1);

		    pft_unpack_pfop(p,tjqres,fc_iter_a,fc_item_a,restype,fc_item_a,fc_pos_a);

		    unpin(tjqres,1);
		} else if ( PFT_FUN_MANAGE(fcname) ) {
		    int fcci = 0;

		    char* opkind;
		    
		    switch (PFT_FUN_MANAGE_KIND(fcname) ) {
		     case 'c':	opkind = "create";
		     		break;
		     case 'e':	opkind = "extend";
		     		break;
		     case 'r':	opkind = "remove";
		     		break;
		     default:   opkind = "error";
		    }

		    mvar_t *pfop_coll, *pfop_opt;

		    if ( PFT_FUN_MANAGE_COLL(fcname) ) {
		        pfop_coll    = pft_create_pfop(*(PFpa_op_t **)PFarray_at (fun_params,fcci),aat_str);
			fcci++;
		    } else {
		        pfop_coll    = pft_create_pfop(NULL,aat_pre);
		    }
		    if ( PFT_FUN_MANAGE_OPT(fcname) ) {
		        pfop_opt    = pft_create_pfop(*(PFpa_op_t **)PFarray_at (fun_params,fcci),aat_pre);
			fcci++;
		    } else {
		        pfop_opt    = pft_create_pfop(NULL,aat_pre);
		    }

                    execute (
                        assgn (var (PF_MIL_TIJAH_FTI_TAPE),
		 	       tj_add_fti_tape(
			           lit_str(opkind),
				   var(pfop_coll->name),
				   var(pfop_opt->name),
				   var(fc_loop->name),
				   var(PF_MIL_VAR_WS),
			           var(PF_MIL_TIJAH_FTI_TAPE)
			       )));

		    unpin(pfop_coll,1);
		    unpin(pfop_opt,1);

                    mvar_t *p_iter  = new_var (p->refctr);
                    execute (
                       assgn (var (p_iter->name),
                          seqbase (new (type (mty_void), type(mty_oid) ),
                                            lit_oid (0))));
                    env_add (p->env, fc_iter_a, aat_nat, p_iter);

                    mvar_t *p_item1 = new_var (p->refctr);
                    execute (
                       assgn (var (p_item1->name),
                          seqbase (new (type (mty_void), type(mty_lng) ),
                                            lit_oid (0))));
                    env_add (p->env, fc_item_a, aat_docmgmt, p_item1);

                    mvar_t *p_item2 = new_var (p->refctr);
                    execute (
                       assgn (var (p_item2->name),
                          seqbase (new (type (mty_void), type(mty_str) ),
                                            lit_oid (0))));
                    env_add (p->env, fc_item_a, aat_docnm, p_item2);

                    mvar_t *p_pos  = new_var (p->refctr);
                    execute (
                       assgn (var (p_pos->name),
                          seqbase (new (type (mty_void), type(mty_oid) ),
                                            lit_oid (0))));
                    env_add (p->env, fc_pos_a, aat_nat, p_pos);
		} else if (strcmp(fcname,PFT_SCORE) == 0 ) {
		    mvar_t *pfop_id;
		    mvar_t *pfop_nodes;

		    pfop_id = pft_create_pfop(*(PFpa_op_t **)PFarray_at (fun_params,0),aat_int);
		    pfop_nodes = pft_create_pfop(*(PFpa_op_t **)PFarray_at (fun_params,1),aat_pre);

		    mvar_t *tjsres = new_var(1);
		    execute(
		        assgn(var(tjsres->name),
			    tj_query_score(
				var(fc_loop->name),
				var(pfop_id->name),
				var(pfop_nodes->name),
				var (PF_MIL_TIJAH_SCORE_DB)
			    )
			)
		    );
		    unpin(pfop_id,1);
		    unpin(pfop_nodes,1);

		    pft_unpack_pfop(p,tjsres,fc_iter_a,fc_item_a,aat_dbl,0,fc_pos_a);

		    unpin(tjsres,1);
		} else if (strcmp(fcname,PFT_NODES) == 0 ) {
		    mvar_t *pfop_id;

		    pfop_id = pft_create_pfop(*(PFpa_op_t **)PFarray_at (fun_params,0),aat_int);

		    mvar_t *tjnres = new_var(1);
		    execute(
		        assgn(var(tjnres->name),
			    tj_query_nodes(
				var(fc_loop->name),
				var(pfop_id->name),
				var (PF_MIL_TIJAH_SCORE_DB)
			    )
			)
		    );
		    unpin(pfop_id,1);

		    pft_unpack_pfop(p,tjnres,fc_iter_a,fc_item_a,aat_pre,fc_item_a,fc_pos_a);

		    unpin(tjnres,1);
		} else if (strcmp(fcname,PFT_INFO) == 0 ) {
		    PFoops (OOPS_FATAL,"milgen.brg: tijah:ft-index-info () temporary not supported.\n");
		} else if ( (strcmp(fcname,PFT_TOKENIZE) == 0) ||
			    (strcmp(fcname,PFT_RESSIZE) == 0) ) {
		    PFpa_op_t* op1 = *(PFpa_op_t **)PFarray_at(fun_params,0);

		    /* copy the iter bat */
	            mvar_t *p_iter = env_mvar (op1->env, att_iter, aat_nat);
		    pin(p_iter,1);
                    env_add (p->env, fc_iter_a, aat_nat, p_iter);

                    mvar_t *new_item  = new_var (p->refctr);
		    if ( strcmp(fcname,PFT_TOKENIZE) == 0 ) {
	                mvar_t *p_item = env_mvar (op1->env, att_item, aat_str);
                        execute (
                           assgn (var (new_item->name),
		               tj_tokenize( var(p_item->name) ) ) );
                        env_add (p->env, fc_item_a, aat_str, new_item);
		    } else {
		        /* must be RESSIZE */
	                mvar_t *p_item = env_mvar (op1->env, att_item, aat_int);
			/* "var res := item%s.join(tijah_scoreDB.fetch(4@0));\n" */
                        execute (
                           assgn (var (new_item->name),
		               join( var(p_item->name), 
			       	     fetch( var(PF_MIL_TIJAH_SCORE_DB),
				         lit_int(4)) ) ) );
                        env_add (p->env, fc_item_a, aat_int, new_item);
		    }

		    /* copy the pos bat */
	            mvar_t *p_pos  = env_mvar (op1->env, att_iter, aat_nat);
		    pin(p_pos,1);
                    env_add (p->env, fc_pos_a, aat_nat, p_pos);
		} else {
	    	    PFoops (OOPS_FATAL,"milgen.brg: PFTIJAH fun_call() bad function[%s]!!!\n",fcname);
		}
	    } else {
	    	    PFoops (OOPS_FATAL,"milgen.brg: PFTIJAH fun_call() bad function[%s]!!!\n",fcname);
	    }
#endif /* PFTIJAH */

	    } else {
	        /* ERROR? do not know how to handle */
	    }

            /* Unpin all MIL variables that represent the function parameters.
               (They have 1 additional pin (see rule fun_param) to ensure
                their visibility in this operator.) */
            for (unsigned int i = 0; i < PFarray_last (fun_params); i++) {
                param = *((PFpa_op_t **) PFarray_at (fun_params, i));
                for (unsigned int j = 0; j < PFarray_last (param->env); j++)
                    unpin (((env_t *) PFarray_at (param->env, j))->mvar, 1);
            }

            /* restore the function arguments */
            fun_params = old_fun_params;
        }   break; /* fold) */

        /* Param:    fun_param (Rel, Param) */
        case 152: /* fold( */
        {   /* TOPDOWN */

            /* translate the argument itself */
            reduce (kids[0], nts[0]);

            /* copy the complete environment of the argument */
            env_copy (p, L(p)->env);

            /* Add an extra pin to every function argument to ensure
               that they are only free'ed AFTER the fun_call operator. */
            for (unsigned int i = 0; i < PFarray_last (p->env); i++)
                pin (((env_t *) PFarray_at (p->env, i))->mvar, 1);
            
            /* Append the new parameter to function parameter list */
            *((PFpa_op_t **) PFarray_add (fun_params)) = p;

            /* go on to next arguments */
            reduce (kids[1], nts[1]);
        }   break; /* fold) */
        /* Param:    nil */
        case 154:
            /* end of parameter list */
            break;

        /* Rel:      string_join (Rel, Rel) */
        case 160: /* fold( */
        {
            mvar_t *str  = new_var (1);
            mvar_t *iter = new_var (p->refctr);
            mvar_t *item = new_var (p->refctr);

            execute (
                assgn (var (str->name),
                       string_join (
                           leftjoin (
                               reverse (VAR(L(p)->env,
                                            p->sem.ii.iter,
                                            aat_nat)),
                               VAR(L(p)->env, p->sem.ii.item, aat_str)),
                           leftjoin (
                               reverse (VAR(R(p)->env,
                                            p->sem.ii.iter,
                                            aat_nat)),
                               VAR(R(p)->env, p->sem.ii.item, aat_str)))),
                assgn (var (iter->name),
                       reverse (mark (var (str->name), lit_oid (0)))),
                assgn (var (item->name),
                       reverse (
                           mark (reverse (var (str->name)), lit_oid (0)))));

            unpin (str, 1);
            env_add (p->env, p->sem.ii.iter, aat_nat, iter);
            env_add (p->env, p->sem.ii.item, aat_str, item);
        }   break; /* fold) */

        default:
            PFoops (OOPS_FATAL, "unknown rule %u", rule);
            break;
    }

    for (unsigned short c = 0; nts[c]; c++)
        for (unsigned int i = 0; i < PFarray_last (kids[c]->env); i++)
            unpin (((env_t *) PFarray_at (kids[c]->env, i))->mvar, 1);

#ifndef NDEBUG
    execute (comment ("End rule: \"%s\"", PFmilgen_string[rule]));

    for (unsigned int i = 0; i < PFarray_last (p->env); i++)
        assert (((env_t *) PFarray_at (p->env, i))->mvar->pins);
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

} /* fold) */

/**
 * @brief Collect the number of references
 *        for each physical algebra operator @a n.
 */
static void
inc_refctr (PFpa_op_t *n)
{ /* fold( */
    assert (n);

    /* count number of incoming edges */
    n->refctr++;

    /* only descend once */
    if (SEEN(n))
        return;
    else
        SEEN(n) = true;

    for (unsigned int i = 0; i < PFPA_OP_MAXCHILD && n->child[i]; i++)
        inc_refctr (n->child[i]);
} /* fold) */

/** @brief Assign the brg state labels to the physical algebra tree */
static void
label (PFpa_op_t *p)
{ /* fold( */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        if (!SEEN(L(p))) label (L(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
    }
    else if (!L(p) && R(p)) {
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
    }
    else {
        if (!SEEN(L(p))) label (L(p));
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
    }
    SEEN(p) = true;
} /* fold) */

/** @brief Compile physical algebra tree into a MIL program. */
PFmil_t *
PFmilgen (PFpa_op_t *n)
{
    PFmil_t *bodymilprog;

    assert (n);

    /* set counters in algebra tree nodes */
    inc_refctr (n);
    PFpa_dag_reset (n);

    /* enrich algebra tree with state labels for subsequent reduce() call */
    label (n);
    PFpa_dag_reset (n);

    /* we start with an empty MIL program */
    milprog = declare (unused ());

    execute (declare (var (PF_MIL_VAR_WS)),
             declare (var (PF_MIL_VAR_GENTYPE)),
             assgn (unused (), nil ()));

    /* prepare the storage structure for the side
       effect of a trace operator: the trace output */
    execute (comment ("trace structure"),
             declare (var (PF_MIL_VAR_TRACE_OUTER)),
             declare (var (PF_MIL_VAR_TRACE_INNER)),
             declare (var (PF_MIL_VAR_TRACE_ITER )),
             declare (var (PF_MIL_VAR_TRACE_MSG  )),
             declare (var (PF_MIL_VAR_TRACE_ITEM )),
             declare (var (PF_MIL_VAR_TRACE_TYPE )),
             declare (var (PF_MIL_VAR_TRACE_REL  )),
             assgn (var (PF_MIL_VAR_TRACE_OUTER),
                    new (type (mty_oid), type (mty_bat))),
             assgn (var (PF_MIL_VAR_TRACE_INNER),
                    new (type (mty_oid), type (mty_bat))),
             assgn (var (PF_MIL_VAR_TRACE_ITER ),
                    new (type (mty_oid), type (mty_bat))),
             assgn (var (PF_MIL_VAR_TRACE_MSG  ),
                    new (type (mty_oid), type (mty_bat))),
             assgn (var (PF_MIL_VAR_TRACE_ITEM ),
                    new (type (mty_oid), type (mty_bat))),
             assgn (var (PF_MIL_VAR_TRACE_TYPE ),
                    new (type (mty_oid), type (mty_int))),
             assgn (var (PF_MIL_VAR_TRACE_REL  ),
                    new (type (mty_oid), type (mty_oid))));

    /* initialize list of variables we use */
    mvars = PFarray (sizeof (mvar_t *), 100);

    /* initialize the variable name counter
       with the first free variable number */
    varno = PF_MIL_RES_VAR_COUNT;
    
    /* dummy initializations */
    twig_state      = NULL;
    fun_params      = NULL;

    /* initialize tracing counter */
    global_trace_id = 1;

    /* start compilation */
    reduce (n, 1);

#ifndef NDEBUG
    mvar_t *var = NULL;
    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        if ((var = *(mvar_t **) PFarray_at (mvars, i))->pins) {
            if (var->pins == 1)
                PFinfo (OOPS_WARNING,
                        "variable %s stilled pinned once.",
                        PFmil_var_str (var->name));
            else
                PFinfo (OOPS_WARNING,
                        "variable %s stilled pinned %i times.",
                        PFmil_var_str (var->name), var->pins);
        }
#endif

    bodymilprog = milprog;

    milprog = seq (module (lit_str ("pathfinder")),
                   module (lit_str ("mkey")),
#ifdef HAVE_PFTIJAH
		   /* create pftijah score db */
    		   declare (var (PF_MIL_TIJAH_SCORE_DB)),
                   assgn (var (PF_MIL_TIJAH_SCORE_DB), 
                          seqbase (new (type (mty_void), type(mty_bat) ),
                                            lit_oid (0))),
		   append (var (PF_MIL_TIJAH_SCORE_DB),
		          seqbase (new (type (mty_void), type(mty_oid) ),
			           lit_oid (0))),
		   append (var (PF_MIL_TIJAH_SCORE_DB),
		          seqbase (new (type (mty_void), type(mty_oid) ),
			           lit_oid (0))),
		   append (var (PF_MIL_TIJAH_SCORE_DB),
		          seqbase (new (type (mty_void), type(mty_oid) ),
			           lit_oid (0))),
		   append (var (PF_MIL_TIJAH_SCORE_DB),
		          seqbase (new (type (mty_void), type(mty_dbl) ),
			           lit_oid (0))),
		   append (var (PF_MIL_TIJAH_SCORE_DB),
		          new (type (mty_lng), type(mty_lng) ) ),
    		   declare (var (PF_MIL_TIJAH_FTI_TAPE)),
                   assgn (var (PF_MIL_TIJAH_FTI_TAPE), 
                          (new (type (mty_str), type(mty_bat) ))),
#endif
                   /* add timing information */
                   declare (var (PF_MIL_VAR_TIME_LOAD)),
                   declare (var (PF_MIL_VAR_TIME_QUERY)),
                   declare (var (PF_MIL_VAR_TIME_PRINT)),
                   assgn (var (PF_MIL_VAR_TIME_LOAD), lit_int (0)),
                   assgn (var (PF_MIL_VAR_TIME_PRINT), lit_int (0)),
                   assgn (var (PF_MIL_VAR_TIME_QUERY), usec ()));

    /* prepend variable declarations before the actual program */
    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        milprog = seq (milprog,
                       declare (
                           var ((*(mvar_t **) PFarray_at (mvars, i))->name)));

    milprog = seq (milprog,
                   bodymilprog,
                   /* add timing information */
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          sub (usec (),
                               var (PF_MIL_VAR_TIME_QUERY))),
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          sub (var (PF_MIL_VAR_TIME_QUERY),
                               var (PF_MIL_VAR_TIME_LOAD))),
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          sub (var (PF_MIL_VAR_TIME_QUERY),
                               var (PF_MIL_VAR_TIME_PRINT))),
                   assgn (var (PF_MIL_VAR_TIME_LOAD),
                          div_ (
                              cast (type (mty_dbl),
                                    var (PF_MIL_VAR_TIME_LOAD)),
                              lit_dbl (1000.0))),
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          div_ (
                              cast (type (mty_dbl),
                                    var (PF_MIL_VAR_TIME_QUERY)),
                              lit_dbl (1000.0))),
                   assgn (var (PF_MIL_VAR_TIME_PRINT),
                          div_ (
                              cast (type (mty_dbl),
                                    var (PF_MIL_VAR_TIME_PRINT)),
                              lit_dbl (1000.0))));

    return milprog;
}

/* vim:set shiftwidth=4 expandtab filetype=c foldmarker=fold(,fold) foldmethod=marker foldopen-=search: */
