%{

/*
 * Map MIL algebra expressions to MIL code
 *
 *
 * Copyright Notice:
 * -----------------
 *
 *  The contents of this file are subject to the MonetDB Public
 *  License Version 1.0 (the "License"); you may not use this file
 *  except in compliance with the License. You may obtain a copy of
 *  the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
 *
 *  Software distributed under the License is distributed on an "AS
 *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 *  implied. See the License for the specific language governing
 *  rights and limitations under the License.
 *
 *  The Original Code is the ``Pathfinder'' system. The Initial
 *  Developer of the Original Code is the Database & Information
 *  Systems Group at the University of Konstanz, Germany. Portions
 *  created by U Konstanz are Copyright (C) 2000-2005 University
 *  of Konstanz. All Rights Reserved.
 *
 *
 * $Id$
 */

#include "pathfinder.h"
#include "oops.h"         /* PFoops() */
#include "algebra.h"
#include "milalgebra.h"
#include "mem.h"          /* PFstrdup() */

#include <assert.h>
#include <string.h>

/*
 * Accessors for the burg matcher
 */
typedef struct PFalg_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p) ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/algebra.h!
 */
%term lit_tbl        =  1
%term disjunion      =  2
%term intersect      =  3
%term difference     =  4
%term cross          =  5
%term eqjoin         =  6
%term scjoin         =  7
%term select         =  8
%term type           =  9
%term cast           = 10
%term project        = 11
%term rownum         = 12
%term serialize      = 13
%term num_add        = 14
%term num_subtract   = 15
%term num_multiply   = 16
%term num_divide     = 17
%term num_modulo     = 18
%term num_eq         = 19
%term num_gt         = 20
%term num_neg        = 21
%term bool_and       = 22
%term bool_or        = 23
%term bool_not       = 24
%term sum            = 25
%term count          = 26
%term distinct       = 27
%term element        = 28
%term attribute      = 29
%term textnode       = 30
%term docnode        = 31
%term comment        = 32
%term processi       = 33
%term concat         = 34
%term merge_adjacent = 35
%term seqty1         = 36
%term all            = 37
%term roots          = 38
%term fragment       = 39
%term frag_union     = 40
%term empty_frag     = 41
%term doc_tbl        = 42

%%

Query:  serialize (Frag, Rel)                     =  1 (10);

Rel:    disjunion (Rel, Rel)                      =  2 (10);
Rel:    eqjoin (Rel, Rel)                         =  3 (10);
Rel:    cross (LitTbl, Rel)                       =  4 ( 5);
Rel:    cross (Rel, Rel)                          =  5 (10);
Rel:    project (Rel)                             =  6 (10);
Rel:    rownum (Rel)                              =  7 (10);
Rel:    num_add (Rel)                             =  8 (10);
Rel:    num_subtract (Rel)                        =  9 (10);
Rel:    num_multiply (Rel)                        = 10 (10);
Rel:    num_divide (Rel)                          = 11 (10);
Rel:    cast (Rel)                                = 12 (10);
Rel:    num_gt (Rel)                              = 13 (10);
Rel:    num_eq (Rel)                              = 14 (10);
Rel:    bool_not (Rel)                            = 15 (10);
Rel:    select (Rel)                              = 16 (10);
Rel:    LitTbl                                    = 17 (0);

LitTbl:   lit_tbl                                 = 18 (10);

Frag:   empty_frag                                = 50 (10);

%%

#include "milalgebra_mnemonic.h"

/*
 * With each algebra expression node, we keep an environment of
 * MIL algebra expressions that implement the algebra expression.
 * The environment is an array of mapping entries. Each entry
 * contains an attribute name (field @a att), an algebra type
 * (field @a ty; remember that there is a BAT for each algebra
 * type that might occur in this BAT), and the MIL algebra expression
 * tree that implements this attribute/type combination.
 */
struct enventry_t {
    PFalg_att_t           att;  /**< attribute name */
    PFalg_simple_type_t   ty;   /**< algebra type */
    PFma_op_t            *ma;   /**< MIL algebra expression */
};
typedef struct enventry_t enventry_t;

/* Create new environment (with enventry_t entries) */
static PFarray_t *new_env (void);
/* Look up a value in the environment */
static PFma_op_t **lookup (PFarray_t *env, PFalg_att_t att,
                           PFalg_simple_type_t ty);

/**
 * Easily access an entry in an environment.
 *
 * @param node Algebra node. A lookup is performed in the environment
 *             stored along this node.
 * @param att  Attribute name for the lookup.
 * @param type Type for the lookup.
 * @return MIL algebra equivalent for the specified attribute/type
 *         combination in the given algebra node.  The return value
 *         is of type <code>PFma_op_t *</code> and is allowed as a
 *         left or right hand side expression.
 */
#define LOOKUP(node,att,type) *(lookup ((node)->env, (att), (type)))

/* copy all entries of environment src to environment dest */
static void copy_env (PFarray_t *dest, PFarray_t *src);

/* encapsulate literal value translation */
static PFma_op_t *literal (PFalg_atom_t atom);
/* find some monomorphic column in n and return its MIL algebra equivalent */
static PFma_op_t *mono (PFalg_op_t *n);
/* MIL implementation type for a given algebra type */
static PFmil_type_t implty (PFalg_simple_type_t t);
/* type of a given attribute in a given algebra node */
static PFalg_type_t attr_type (PFalg_op_t *n, PFalg_att_t attname);

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static PFma_op_t *
reduce (PFalg_op_t *p, int goalnt)
{
    int         rule;       /* rule number that matches for this node */
    short      *nts;        /* target non-terminals for the leaf nodes of
                               the current rule */
    PFalg_op_t *kids[10];   /* leaf nodes of this rule */
    PFma_op_t  *ret = NULL; /* return value */

    /* stop if we already translated that expression */
    if (p->env)
        return ret;

    /* determine rule that matches for this non-terminal */
    rule = PFma_gen_rule (STATE_LABEL (p), goalnt);

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFma_gen_nts[rule];
    PFma_gen_kids (p, rule, kids);

    /* recursively translate all leaf expressions */
    unsigned short i;

    for (i = 0; nts[i]; i++)
        reduce (kids[i], nts[i]);

    /*
     * Stop if we have now already translated that expression.
     * This may be the case in ``chain rules'' (like `Rel: LitTbl')
     */
    if (p->env)
        return ret;

    /* Set up a new environment for the result */
    p->env = new_env ();

    switch (rule) {

        /* Query:    serialize (Rel, Rel) */
        case 1:
            ret = serialize (
                    LOOKUP (R(p), "pos", aat_nat),
                    LOOKUP (R(p), "item", aat_int)
                        ? LOOKUP (R(p), "item", aat_int)
                        : new (m_void, implty (aat_int)),
                    LOOKUP (R(p), "item", aat_str)
                        ? LOOKUP (R(p), "item", aat_str)
                        : new (m_void, implty (aat_str)),
                    LOOKUP (R(p), "item", aat_dec)
                        ? LOOKUP (R(p), "item", aat_dec)
                        : new (m_void, implty (aat_dec)),
                    LOOKUP (R(p), "item", aat_dbl)
                        ? LOOKUP (R(p), "item", aat_dbl)
                        : new (m_void, implty (aat_dbl)),
                    LOOKUP (R(p), "item", aat_bln)
                        ? LOOKUP (R(p), "item", aat_bln)
                        : new (m_void, implty (aat_bln)),
                    LOOKUP (R(p), "item", aat_node)
                        ? LOOKUP (R(p), "item", aat_node)
                        : new (m_void, implty (aat_node)));
            break;

        /* Rel:  disjunion (Rel, Rel) */
        case 2:
        {
            /*
             * disjoint union  L U R
             */
            PFma_op_t *m = mono (L(p));   /* monomorphic column in L */
            PFma_op_t *shifted;           /* R, with keys shifted */

            /* copy everything we get from L */
            copy_env (p->env, L(p)->env);

            /* Now append everything we get from R */
            unsigned int i;
            PFalg_simple_type_t t;
            for (i = 0; i < (unsigned int) R(p)->schema.count; i++)
                for (t = 1; t; t <<= 1)
                    if (t & R(p)->schema.items[i].type) {
                        if (t == R(p)->schema.items[i].type)
                            /*
                             * If this attribute is monomorphic, shifting
                             * is easy: just move the seqbase.
                             */
                            shifted
                                = seqbase (
                                    LOOKUP (R(p),
                                            R(p)->schema.items[i].name, t),
                                    oid (count (m)));
                        else
                            /*
                             * Otherwise we have to do some nasty arithmetics:
                             *
                             * ([oid]([+]([int](s.reverse), m.count))).reverse
                             */
                            shifted
                                = reverse (
                                    moid (
                                        madd (
                                            mint (
                                                reverse (
                                                    LOOKUP (R(p),
                                                            R(p)->schema
                                                                .items[i].name,
                                                            t))),
                                            count (m))));
                        /*
                         * Let's see if we had some contribution from L for
                         * this attribute/type combination
                         */
                        if (LOOKUP (p, R(p)->schema.items[i].name, t))
                            /* If yes, append R's contribution */
                            LOOKUP (p, R(p)->schema.items[i].name, t)
                                = append (LOOKUP (p,
                                                  R(p)->schema.items[i].name,
                                                  t),
                                          shifted);
                        else
                            /* Otherwise, R's contrib. is already the result */
                            LOOKUP (p, R(p)->schema.items[i].name, t)
                                = shifted;
                    }
        } break;

        /* Rel:  eqjoin (Rel, Rel) */
        case 3:
        {
            /*
             * Equi-join  L |X|_a1=a2 R
             *
             * - Do
             *
             *   tmp := l.cross (r.reverse);
             *   tmp1 := tmp.mark (0@0).reverse;
             *   tmp2 := tmp.reverse.mark (0@0).reverse;
             *
             *   with l and r the join attributes of L/R, respectively.
             *
             * - And for each attribute a/b in R/S
             *
             *   <a_out> := tmp1.leftjoin (a_in);
             *   <b_out> := tmp2.leftjoin (b_in);
             */
            PFma_op_t          *l, *r;
            PFma_op_t          *tmp, *tmp1, *tmp2;
            unsigned int        i;
            PFalg_simple_type_t t;

            l = LOOKUP (L(p),
                        p->sem.eqjoin.att1,
                        attr_type (L(p), p->sem.eqjoin.att1));
            r = LOOKUP (R(p),
                        p->sem.eqjoin.att2,
                        attr_type (R(p), p->sem.eqjoin.att2));

            if (!l || !r)
                PFoops (OOPS_FATAL,
                        "Join attribute not found or not monomorphic: "
                        "`%s' or `%s'", p->sem.eqjoin.att1, p->sem.eqjoin.att2);

            tmp = join (l, reverse (r));
            tmp1 = reverse (mark (tmp, lit_oid (0)));
            tmp2 = reverse (mark (reverse (tmp), lit_oid (0)));

            /* And we set all the result attributes, first from L... */
            for (i = 0; i < (unsigned int) L(p)->schema.count; i++)
                for (t = 1; t; t <<= 1)
                    if (t & L(p)->schema.items[i].type)
                        LOOKUP (p, L(p)->schema.items[i].name, t)
                            = leftjoin (tmp1,
                                        LOOKUP (L(p),
                                                L(p)->schema.items[i].name,
                                                t));

            /* ... then from R */
            for (i = 0; i < (unsigned int) R(p)->schema.count; i++)
                for (t = 1; t; t <<= 1)
                    if (t & R(p)->schema.items[i].type)
                        LOOKUP (p, R(p)->schema.items[i].name, t)
                            = leftjoin (tmp2,
                                        LOOKUP (R(p),
                                                R(p)->schema.items[i].name,
                                                t));
        } break;

        /* Rel:  cross (LitTbl, Rel) */
        case 4:
          /*
           * we don't have a special translation for this (yet).
           * -> just fall through.
           *
           * FIXME: This still has to be implemented.
           */

        /* Rel:  cross (Rel, Rel) */
        case 5:
        {
            /*
             * Cross product  L x R
             *
             * - Grab monomorphic attributes r and s from R and S.
             * - Then do
             *
             *   tmp := l.cross (r.reverse);
             *   tmp1 := tmp.mark (0@0).reverse;
             *   tmp2 := tmp.reverse.mark (0@0).reverse;
             *
             * - And for each attribute a/b in R/S
             *
             *   <a_out> := tmp1.leftjoin (a_in);
             *   <b_out> := tmp2.leftjoin (b_in);
             */
            PFma_op_t          *l, *r;
            PFma_op_t          *tmp, *tmp1, *tmp2;
            unsigned int        i;
            PFalg_simple_type_t t;

            l = mono (L(p));
            r = mono (R(p));

            tmp = cross (l, reverse (r));
            tmp1 = reverse (mark (tmp, lit_oid (0)));
            tmp2 = reverse (mark (reverse (tmp), lit_oid (0)));

            /* And we set all the result attributes, first from L... */
            for (i = 0; i < (unsigned int) L(p)->schema.count; i++)
                for (t = 1; t; t <<= 1)
                    if (t & L(p)->schema.items[i].type)
                        LOOKUP (p, L(p)->schema.items[i].name, t)
                            = leftjoin (tmp1,
                                        LOOKUP (L(p),
                                                L(p)->schema.items[i].name,
                                                t));

            /* ... then from R */
            for (i = 0; i < (unsigned int) R(p)->schema.count; i++)
                for (t = 1; t; t <<= 1)
                    if (t & R(p)->schema.items[i].type)
                        LOOKUP (p, R(p)->schema.items[i].name, t)
                            = leftjoin (tmp2,
                                        LOOKUP (R(p),
                                                R(p)->schema.items[i].name,
                                                t));
        } break;

        /* Rel:  project (Rel) */
        case 6: {
            /* Just copy entries to new environment under new names */
            unsigned int i;
            PFalg_simple_type_t t;
            for (i = 0; i < (unsigned int) p->sem.proj.count; i++)
                for (t = 1; t; t <<= 1)
                    if (t & p->schema.items[i].type)
                        LOOKUP (p, p->sem.proj.items[i].new, t)
                            = LOOKUP (L(p), p->sem.proj.items[i].old, t);
            }
            break;

        /* Rel:  rownum (Rel) */
        case 7:
        {
            PFma_op_t    *tmp, *tmp2;
            unsigned int  i;

            /* copy all attributes from our operand */
            copy_env (p->env, L(p)->env);

            if (p->sem.rownum.sortby.count >= 1) {
                /*
                 * sort by first sort specification:
                 * 
                 * tmp := <sort_crit>.reverse.sort.reverse;
                 */
                tmp = reverse (
                        sort (
                            reverse (
                                LOOKUP (L(p),
                                        p->sem.rownum.sortby.atts[0],
                                        attr_type (
                                            L(p),
                                            p->sem.rownum.sortby.atts[0])))));

                /*
                 * refine sorting by other sort criteria:
                 *
                 * tmp := tmp.CTrefine (<sort_crit>);
                 */
                for (i = 1; i < (unsigned int) p->sem.rownum.sortby.count; i++)
                    tmp = ctrefine (
                            tmp,
                            LOOKUP (L(p),
                                    p->sem.rownum.sortby.atts[i],
                                    attr_type (L(p),
                                               p->sem.rownum.sortby.atts[i])));
            }
            else
                PFoops (OOPS_FATAL,
                        "rownumber without sort specifier not implemented yet");

            if (p->sem.rownum.part) {
                /*
                 * If a partitioning attribute was given:
                 *  - fetch partitioning attribute into tmp's tail
                 *  - set up groups for mark_grp operator
                 *  - use mark_grp to get the result
                 */

                /*
                 * fetch partitioning attribute into tail:
                 *
                 * tmp := tmp.mirror.leftjoin (<part_att>);
                 */
                tmp = leftjoin (mirror (tmp),
                                LOOKUP (L(p),
                                        p->sem.rownum.part,
                                        attr_type (L(p),
                                                   p->sem.rownum.part)));
                /*
                 * define groups for mark_grp operator:
                 *
                 * tmp2 := <part_att>.reverse.kunique.project (1@0);
                 */
                tmp2 = project (
                        kunique (
                            reverse (LOOKUP (L(p),
                                             p->sem.rownum.part,
                                             attr_type (L(p),
                                                        p->sem.rownum.part)))),
                        lit_oid (1));
                /*
                 * now we can apply mark_grp:
                 *
                 * <new_att> := tmp.mark_grp (tmp2);
                 */
                LOOKUP (p, p->sem.rownum.attname, aat_nat)
                    = mark_grp (tmp, tmp2);
            }
            else {
                /*
                 * If not partitioning attribute is given, just use
                 * the mark operator:
                 *
                 * <new_att> := tmp.mark (1@0);
                 */
                LOOKUP (p, p->sem.rownum.attname, aat_nat)
                    = mark (tmp, lit_oid (1));
            }

            /*
             * Now make new attribute aligned with all the other BATs
             * (re-sort it).
             *
             * <new_att> := <new_att>.sort.reverse.mark (0@0).reverse;
             */
            LOOKUP (p, p->sem.rownum.attname, aat_nat)
                = reverse (
                    mark (
                        reverse (
                            sort (LOOKUP (p, p->sem.rownum.attname, aat_nat))),
                        lit_oid (0)));
        } break;

        /* Rel:  num_add (Rel) */
        case 8:
            copy_env (p->env, L(p)->env);

            LOOKUP (p, p->sem.binary.res, attr_type (p, p->sem.binary.res))
                = madd (LOOKUP (L(p),
                                p->sem.binary.att1,
                                attr_type (L(p), p->sem.binary.att1)),
                        LOOKUP (L(p),
                                p->sem.binary.att2,
                                attr_type (L(p), p->sem.binary.att2)));
            break;

        /* Rel:  num_subtract (Rel) */
        case 9:
            copy_env (p->env, L(p)->env);

            LOOKUP (p, p->sem.binary.res, attr_type (p, p->sem.binary.res))
                = msub (LOOKUP (L(p),
                                p->sem.binary.att1,
                                attr_type (L(p), p->sem.binary.att1)),
                        LOOKUP (L(p),
                                p->sem.binary.att2,
                                attr_type (L(p), p->sem.binary.att2)));
            break;

        /* Rel:  num_multiply (Rel) */
        case 10:
            copy_env (p->env, L(p)->env);

            LOOKUP (p, p->sem.binary.res, attr_type (p, p->sem.binary.res))
                = mmult (LOOKUP (L(p),
                                 p->sem.binary.att1,
                                 attr_type (L(p), p->sem.binary.att1)),
                         LOOKUP (L(p),
                                 p->sem.binary.att2,
                                 attr_type (L(p), p->sem.binary.att2)));
            break;

        /* Rel:  num_divide (Rel) */
        case 11:
            copy_env (p->env, L(p)->env);

            LOOKUP (p, p->sem.binary.res, attr_type (p, p->sem.binary.res))
                = mdiv (LOOKUP (L(p),
                                p->sem.binary.att1,
                                attr_type (L(p), p->sem.binary.att1)),
                        LOOKUP (L(p),
                                p->sem.binary.att2,
                                attr_type (L(p), p->sem.binary.att2)));
            break;

        /* Rel:  cast (Rel) */
        case 12:
        {
            unsigned int         i;
            PFalg_simple_type_t  t;

            /* Look at all the attributes we have in the argument */
            for (i = 0; i < (unsigned int) L(p)->schema.count; i++) {

                if (strcmp (L(p)->schema.items[i].name, p->sem.cast.att)) {
                    /*
                     * If this is not the attribute that is to be casted,
                     * just copy it to the result.
                     */
                    for (t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type)
                            LOOKUP (p, L(p)->schema.items[i].name, t)
                                = LOOKUP (L(p), L(p)->schema.items[i].name, t);
                }

                else {
                    PFma_op_t  *tmp = NULL;
                    bool        monomorphic = false;

                    for (t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            /*
                             * Cast the attribute/type combination
                             * and keep it in tmp.
                             */
                            switch (implty (p->sem.cast.ty)) {
                                case m_void:
                                case m_oid:
                                    tmp = moid (LOOKUP (L(p),
                                                        p->sem.cast.att, t));
                                    break;
                                case m_int:
                                    tmp = mint (LOOKUP (L(p),
                                                        p->sem.cast.att, t));
                                    break;
                                case m_str:
                                    tmp = mstr (LOOKUP (L(p),
                                                        p->sem.cast.att, t));
                                    break;
                                case m_dbl:
                                    tmp = mdbl (LOOKUP (L(p),
                                                        p->sem.cast.att, t));
                                    break;
                                case m_bit:
                                    tmp = mbit (LOOKUP (L(p),
                                                        p->sem.cast.att, t));
                                    break;
                            }

                            /*
                             * If the result is empty yet, set the result
                             * to tmp, otherwise append tmp to the result.
                             */
                            if (LOOKUP (p, p->sem.cast.att, p->sem.cast.ty))
                                LOOKUP (p, p->sem.cast.att, p->sem.cast.ty)
                                    = append (LOOKUP (p, p->sem.cast.att, t),
                                              tmp);
                            else 
                                LOOKUP (p, p->sem.cast.att, p->sem.cast.ty)
                                    = tmp;

                            /* keep track of if attribute was monomorphic */
                            monomorphic = (t == L(p)->schema.items[i].type);
                        }

                    /*
                     * Now we have considered all the types that
                     * the attribute (we want to cast) had. If it
                     * was not monomorphic, make sure the result
                     * has a void head.
                     */
                    if (!monomorphic)
                        LOOKUP (p, p->sem.cast.att, p->sem.cast.ty)
                            = reverse (
                                    mark (
                                        reverse (
                                            sort (LOOKUP (p,
                                                          p->sem.cast.att,
                                                          p->sem.cast.ty))),
                                        lit_oid (0)));
                }
            }
        } break;

        /* Rel:  num_gt (Rel) */
        case 13:
            PFinfo (OOPS_NOTICE, "untranslated expression (rule %i)", rule);
            break;

        /* Rel:  num_eq (Rel) */
        case 14:
            PFinfo (OOPS_NOTICE, "untranslated expression (rule %i)", rule);
            break;

        /* Rel:  not (Rel) */
        case 15:
            PFinfo (OOPS_NOTICE, "untranslated expression (rule %i)", rule);
            break;

        /* Rel:  select (Rel) */
        case 16:
            PFinfo (OOPS_NOTICE, "untranslated expression (rule %i)", rule);
            break;

        /* Rel:  LitTbl */
        case 17:
            break;

        /* LitTbl:   lit_tbl */
        case 18:
        {
            /*
             * Literal table construction:
             *  - Create a new BAT for each of the attributes. Use a void
             *    head if applicable, i.e., if the column is monomorphic.
             *  - Then insert() all the tuples.
             */
            unsigned int          col, row;
            PFalg_simple_type_t   t;

            for (col = 0; col < (unsigned int) p->schema.count; col++) {
                /*
                 * For each attribute and each of its types create a BAT
                 */
                for (t = 1; t; t <<= 1)
                    if (t & p->schema.items[col].type) {
                        if (t == p->schema.items[col].type)
                            /* monomorphic type: new (void,<t>).seqbase (0@0) */
                            LOOKUP (p, p->schema.items[col].name, t)
                                = seqbase (new (m_void, implty (t)),
                                           lit_oid (0));
                        else
                            /* polymorphic type: new (oid, <t>) */
                            LOOKUP (p, p->schema.items[col].name, t)
                                = new (m_oid, implty (t));
                    }

                /*
                 * Insert the values.
                 */
                for (row = 0; row < (unsigned int) p->sem.lit_tbl.count; row++)
                    LOOKUP (p,
                            p->schema.items[col].name,
                            p->sem.lit_tbl.tuples[row].atoms[col].type)
                        = insert (
                            LOOKUP (p,
                                    p->schema.items[col].name,
                                    p->sem.lit_tbl.tuples[row].atoms[col].type),
                            lit_oid (row),
                            literal (p->sem.lit_tbl.tuples[row].atoms[col]));
            }

        } break;

        default:
            PFinfo (OOPS_NOTICE, "untranslated expression (rule %i)", rule);
            break;
    }

    return ret;
}

/**
 * Allocate a new environment
 */
static PFarray_t *
new_env (void)
{
    return PFarray (sizeof (enventry_t));
}

/**
 * Lookup MIL algebra expression in the environment @a env, given
 * the attribute/type combination @a att/@a ty.  Creates a new
 * entry, if the combination was not found.  The entry is initialized
 * with NULL, and a pointer to it is returned.
 */
static PFma_op_t **
lookup (PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    enventry_t   *e;
    unsigned int  i;

    assert (env);

    for (i = 0; i < PFarray_last (env); i++) {
        e = (enventry_t *) PFarray_at (env, i);
        if (!strcmp (e->att, att) && e->ty == ty)
            return &(e->ma);
    }

    /* create new entry in environment if we couldn't find one */
    *((enventry_t *) PFarray_add (env)) 
        = (enventry_t) { .att = PFstrdup (att), .ty = ty, .ma = NULL };

    /* return this new entry */
    return &(((enventry_t *) PFarray_at (env, PFarray_last (env) - 1))->ma);
}

/**
 * Copy environment.
 */
static void
copy_env (PFarray_t *dest, PFarray_t *src)
{   
    unsigned int i;

    assert (dest); assert (src);

    for (i = 0; i < PFarray_last (src); i++)
        *((enventry_t *) PFarray_add (dest))
            = *((enventry_t *) PFarray_at (src, i));
}   

/**
 * Pick MIL algebra representation of (some) monomorphic column
 * in algebra expression @a n. Returns @c NULL if there is no
 * monomorphic column.
 */
static PFma_op_t *
mono (PFalg_op_t *n)
{
    unsigned int         i;
    PFalg_simple_type_t  t;

    for (i = 0; i < (unsigned int) n->schema.count; i++)
        for (t = 1; t; t <<= 1)
            if (t == n->schema.items[i].type)
                return LOOKUP (n, n->schema.items[i].name, t);

    return NULL;
}

/**
 * Translate a literal value into a MIL algebra operator.
 */
static PFma_op_t *
literal (PFalg_atom_t atom)
{
    switch (atom.type) {

        case aat_nat:  return lit_oid (atom.val.nat);
        case aat_int:  return lit_int (atom.val.int_);
        case aat_str:  return lit_str (atom.val.str);
        case aat_node: return lit_oid (atom.val.node);
        case aat_dec:  return lit_dbl (atom.val.dec);
        case aat_dbl:  return lit_dbl (atom.val.dbl);
        case aat_bln:  return lit_bit (atom.val.bln);

        default:       PFoops (OOPS_FATAL,
                               "A relational algebra type has not yet "
                               "been implemented.");
                       break;
    }
}

/**
 * MIL implementation type of a given algebra type.
 */
static PFmil_type_t
implty (PFalg_simple_type_t t)
{
    switch (t) {
        case aat_nat:    return m_oid;
        case aat_int:    return m_int;
        case aat_str:    return m_str;
        case aat_node:   return m_oid;
        case aat_dec:    return m_dbl;
        case aat_dbl:    return m_dbl;
        case aat_bln:    return m_bit;
    }

    PFoops (OOPS_FATAL, "Cannot determine implementation type of %x", t);
}

/**
 * Lookup type of attribute @a attname in algebra expression @a n.
 */
static PFalg_type_t
attr_type (PFalg_op_t *n, PFalg_att_t attname)
{
    unsigned int i;

    for (i = 0; i < (unsigned int) n->schema.count; i++)
        if (!strcmp (n->schema.items[i].name, attname))
            return n->schema.items[i].type;

    PFoops (OOPS_FATAL,
            "Unable to determine type of attribute `%s': attribute not found.",
            attname);
}


/**
 * Invoke MIL algebra generation, translate algebra graph
 * (PFalg_op_t *) to a MIL algebra tree (PFma_op_t *).
 */
PFma_op_t *
PFma_gen (PFalg_op_t *n)
{
    /* Attach node labels in a tree walk bottom-up */
    PFma_gen_label (n);
    /* Compile tree into MIL algebra */
    return reduce (n, 1);
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
