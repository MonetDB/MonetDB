%{

/**
 * @file
 *
 * Simplify XQuery Core tree.
 *
 * This step runs right after compilation into XQuery Core. Its
 * job is not only to simplify the Core tree and bring it into
 * some normal form (e.g., unnest let clauses), but also to check
 * the Core tree structure for syntactial errors that might have
 * sneaked in in the Core compilation phase (fs.brg).
 *
 * Note that static type information is not available at this
 * step during query compilation. ``Real optimization'' will only
 * be possible after the type checking phase (typecheck.brg). See
 * coreopt.brg for this purpose.
 *
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * the Database Group at the Technische Universitaet Muenchen, Germany.
 * It is now maintained by the Database Systems Group at the Eberhard
 * Karls Universitaet Tuebingen, Germany.  Portions created by the
 * University of Konstanz, the Technische Universitaet Muenchen, and the
 * Universitaet Tuebingen are Copyright (C) 2000-2005 University of
 * Konstanz, (C) 2005-2008 Technische Universitaet Muenchen, and (C)
 * 2008-2010 Eberhard Karls Universitaet Tuebingen, respectively.  All
 * Rights Reserved.
 *
 *
 * $Id$
 */

/* always include pf_config.h first! */
#include "pf_config.h"
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "oops.h"
#include "core.h"
#include "qname.h"
#include "mem.h"

/* Easily access subtree-parts */
#include "child_mnemonic.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFcnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

/** We hash variable replacement bindings into 8 buckets */
#define HASH_BUCKETS 8
/** hash function for the variable replacement environment */
#define hash(v) ((unsigned int) ((v) - (PFvar_t *) NULL) % HASH_BUCKETS)

/** a binding in the variable replacement environment */
typedef struct {
    PFvar_t    *var;
    PFcnode_t  *atom;
} bind_t;

/**
 * Variable replacement environment.
 *
 * In order to unfold let-bound variables which are bound to some
 * other atom, we proceed as follows:
 *
 * First, we process the binding sequence (the atom).  If it is
 * a variable itself, there may be a replacement for it, so we do
 * that first.  Then, add an entry to the environment var_env
 * (a hash table with HASH_BUCKETS buckets) and process the return
 * part (which will replace every occurrence of the variable).
 * When we're back, we replace the let clause by its return part.
 *
 * Whenever we process the usage of a variable, look into the
 * environment if there is a replacement for it.  In that case,
 * do the replacement.
 *
 * Note that we do *not* remove the binding from the environment
 * when we're back from the return part.  The Core expression
 * tree may contain "global" variables (i.e., ones that were
 * bound in the query prolog).  Such variables may be used in
 * functions as well.  Therefore, we process the query first
 * (the start rule for our grammar is top-down) in order to have
 * globals be added to the environment.  As we leave all the
 * variables in the environment, they will be available when we
 * process the function bodies.  Hence, they will be replaced
 * there as well.
 */
static PFarray_t *var_env[HASH_BUCKETS];

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/core.h!
 */
%term var                =  1 /**< variable */
%term lit_str            =  2 /**< string literal */
%term lit_int            =  3 /**< integer literal */
%term lit_dec            =  4 /**< decimal literal */
%term lit_dbl            =  5 /**< double literal */
%term nil                =  6 /**< end-of-sequence marker */

%term seq                =  7 /**< sequence construction */
%term ordered            =  9
%term unordered          = 10

%term flwr               = 14 /**< flwr expression */
%term let                = 15 /**< let expression */
%term letbind            = 16 /**< binding part of a let expression */
%term for_               = 17 /**< for expression */
%term forbind            = 18 /**< binding part of a for expression */
%term forvars            = 19 /**< variable pair (var + pos. var) of a for */

%term where              = 20 /**< where clause */
%term orderby            = 21 /**< orderby clause */
%term orderspecs         = 22 /**< list of order specs */

%term apply              = 23 /**< function application */
%term arg                = 24 /**< function argument (list) */

%term typesw             = 25 /**< typeswitch clause */
%term cases              = 26 /**< case concatenation for typeswitch */
%term case_              = 27 /**< single case for typeswitch */
%term default_           = 28 /**< default branch in typeswitch */
%term seqtype            = 29 /**< a SequenceType */
%term seqcast            = 30 /**< cast along <: */
%term proof              = 31 /**< typechecker only: prove <: relationship */
%term subty              = 32 /**< subtype condition for proof() */
%term stattype           = 33 /**< static type of expression. Required for
                                fs:convert-operand. Will be removed during
                                typechecking and replaced by seqtype, as
                                soon as types are known. */

%term if_                = 34 /**< if-then-else conditional */
%term then_else          = 35 /**< then- and else-branches of an
                                if-then-else conditional */

%term locsteps           = 40 /**< path of location steps only */

  /* XPath axes */
%term ancestor           = 41 /**< the parent, the parent's parent,... */
%term ancestor_or_self   = 42 /**< the parent, the parent's parent,... + self */
%term attribute          = 43 /**< attributes of the context node */
%term child              = 44 /**< children of the context node */
%term descendant         = 45 /**< children, children's children,... + self */
%term descendant_or_self = 46 /**< children, children's children,... */
%term following          = 47 /**< nodes after current node (document order) */
%term following_sibling  = 48 /**< all following nodes with same parent */
%term parent             = 49 /**< parent node (exactly one or none) */
%term preceding          = 50 /**< nodes before context node (document order) */
%term preceding_sibling  = 51 /**< all preceding nodes with same parent */
%term self               = 52 /**< the context node itself */

/* [STANDOFF] */
%term select_narrow      = 53 /**< regions contained in a context-node */
%term select_wide        = 54 /**< regions overlapping a context-node */
/* [/STANDOFF] */

  /* Constructor Nodes */
%term elem               = 55 /**< the element constructor */
%term attr               = 56 /**< the attribute constructor */
%term text               = 57 /**< the text constructor */
%term doc                = 58 /**< the document constructor */
%term comment            = 59 /**< the comment constructor */
%term pi                 = 60 /**< the processing-instruction constructor */
%term tag                = 61 /**< the tagname for elem. and attr. constr. */

%term true_              = 65 /**< built-in function `fn:true ()' */
%term false_             = 66 /**< built-in function `fn:false ()' */
%term empty              = 67 /**< built-in function `empty' */

%term main               = 68 /**< tree root.
                                   Separates function declarations from
                                   the query body. */
%term fun_decls          = 69 /**< list of function declarations */
%term fun_decl           = 70 /**< function declaration */
%term params             = 71 /**< function declaration parameter list */
%term param              = 72 /**< function declaration parameter */
%term cast               = 73 /**< function declaration parameter */

  /* Pathfinder extension: recursion */
%term recursion          = 74 /**< "with $v seeded by..." expression */
%term seed               = 75

  /* Pathfinder extension: XRPC */
%term xrpc               = 76 /**< XRPC calls: "execute at" */

%%

Query:              main (FunctionDecls, CoreExpr)              =   1 (10);

CoreExpr:           Atom                                        =  30 (10);
CoreExpr:           SequenceTypeCast                            =  31 (10);

CoreExpr:           flwr (OptBindExpr, WhereExpr)               =  32 (10);
CoreExpr:           flwr (OptBindExpr, OrdWhereExpr)            =  33 (10);

OptBindExpr:        for_ (forbind (forvars (var, nil),
                                   LiteralValue),
                          OptBindExpr)                          =   2 (10);
OptBindExpr:        for_ (forbind (forvars (var, var),
                                   LiteralValue),
                          OptBindExpr)                          =   3 (10);
OptBindExpr:        for_ (forbind (forvars (var, OptVar),
                                   CoreExpr),
                          OptBindExpr)                          =  34 (10);

OptVar:             nil                                         =  35 (10);
OptVar:             var                                         =  36 (10);

OptBindExpr:        let (letbind (var, Atom), OptBindExpr)      =   4 (10);
OptBindExpr:        let (letbind (var,
                                  flwr (let (letbind (var,
                                                      CoreExpr),
                                             nil),
                                        WhereExpr)),
                         OptBindExpr)                           =   5 (10);
OptBindExpr:        let (letbind (var,
                                  flwr (let (letbind (var,
                                                      CoreExpr),
                                             OptBindExpr),
                                        WhereExpr)),
                         OptBindExpr)                           =   6 (10);
OptBindExpr:        let (letbind (var,
                                  flwr (let (letbind (var,
                                                      CoreExpr),
                                             OptBindExpr),
                                        OrdWhereExpr)),
                         OptBindExpr)                           =   7 (10);
OptBindExpr:        let (letbind (var, CoreExpr), OptBindExpr)  =  40 (10);

OptBindExpr:        nil                                         =  41 (10);

WhereExpr:          where (true_, WhereExpr)                    =   8 (10);
WhereExpr:          where (CoreExpr, WhereExpr)                 =  42 (10);
WhereExpr:          CoreExpr                                    =  43 (10);

OrdWhereExpr:       where (true_, OrdWhereExpr)                 =   9 (10);
OrdWhereExpr:       where (CoreExpr, OrdWhereExpr)              =  44 (10);
OrdWhereExpr:       orderby (OrderSpecs, CoreExpr)              =  45 (10);

OrderSpecs:         orderspecs (CoreExpr, nil)                  =  46 (10);
OrderSpecs:         orderspecs (CoreExpr, OrderSpecs)           =  47 (10);

CoreExpr:           typesw (CoreExpr,
                            cases (case_ (SequenceType,
                                          CoreExpr),
                                   default_ (CoreExpr)))        =  50 (10);

SequenceType:       seqtype                                     =  51 (10);
SequenceType:       stattype (CoreExpr)                         =  52 (10);

SequenceTypeCast:   seqcast (SequenceType, CoreExpr)            =  53 (10);

CoreExpr:           proof (subty (CoreExpr, SequenceType),
                           CoreExpr)                            =  54 (10);

CoreExpr:           if_ (CoreExpr,
                         then_else (CoreExpr, CoreExpr))        =  55 (10);
CoreExpr:           if_ (true_, then_else (CoreExpr, CoreExpr)) =  11 (1);
CoreExpr:           if_ (false_, then_else (CoreExpr, CoreExpr))=  12 (1);

CoreExpr:           seq (seq (CoreExpr, CoreExpr), CoreExpr)    =  13 (10);
CoreExpr:           seq (CoreExpr, CoreExpr)                    =  56 (10);
CoreExpr:           seq (empty, CoreExpr)                       =  15 (10);
CoreExpr:           seq (CoreExpr, empty)                       =  16 (10);

CoreExpr:           LocationSteps                               =  60 (10);

LocationStep:       ancestor (SequenceType)                     =  61 (10);
LocationStep:       ancestor_or_self (SequenceType)             =  62 (10);
LocationStep:       attribute (SequenceType)                    =  63 (10);
LocationStep:       child (SequenceType)                        =  64 (10);
LocationStep:       descendant (SequenceType)                   =  65 (10);
LocationStep:       descendant_or_self (SequenceType)           =  66 (10);
LocationStep:       following (SequenceType)                    =  67 (10);
LocationStep:       following_sibling (SequenceType)            =  68 (10);
LocationStep:       parent (SequenceType)                       =  69 (10);
LocationStep:       preceding (SequenceType)                    =  70 (10);
LocationStep:       preceding_sibling (SequenceType)            =  71 (10);
LocationStep:       self (SequenceType)                         =  72 (10);
/* [STANDOFF] */
LocationStep:       select_narrow (SequenceType)                =  73 (10);
LocationStep:       select_wide (SequenceType)                  =  74 (10);
/* [/STANDOFF] */

LocationSteps:      locsteps (LocationStep, LocationSteps)      =  75 (10);
LocationSteps:      locsteps (LocationStep, CoreExpr)           =  76 (10);

CoreExpr:           elem (TagName, CoreExpr)                    =  80 (10);
CoreExpr:           attr (TagName, CoreExpr)                    =  81 (10);
CoreExpr:           text (CoreExpr)                             =  82 (10);
CoreExpr:           doc (CoreExpr)                              =  83 (10);
CoreExpr:           comment (CoreExpr)                          =  84 (10);
CoreExpr:           pi (CoreExpr, CoreExpr)                     =  85 (10);

TagName:            tag                                         =  86 (10);
TagName:            CoreExpr                                    =  87 (10);

CoreExpr:           FunExpr                                     =  90 (10);
FunExpr:            apply (FunctionArgs)                        =  91 (10);
FunExpr:            apply (arg (CoreExpr,
                                arg (CoreExpr,
                                     arg (CoreExpr,
                                          FunctionArgs))))      =  18 (10);

FunctionArgs:       arg (CoreExpr, FunctionArgs)                =  92 (10);
FunctionArgs:       arg (SequenceTypeCast, FunctionArgs)        =  93 (10);
FunctionArgs:       nil                                         =  94 (10);

CoreExpr:           ordered (CoreExpr)                          =  95 (10);
CoreExpr:           unordered (CoreExpr)                        =  96 (10);

CoreExpr:           cast (SequenceType, CoreExpr)               =  97 (10);

Atom:               var                                         =  19 (10);
Atom:               empty                                       = 101 (10);
Atom:               LiteralValue                                = 102 (10);

LiteralValue:       lit_str                                     = 104 (10);
LiteralValue:       lit_int                                     = 105 (10);
LiteralValue:       lit_dec                                     = 106 (10);
LiteralValue:       lit_dbl                                     = 107 (10);
LiteralValue:       true_                                       = 108 (10);
LiteralValue:       false_                                      = 109 (10);

FunctionDecls:      nil                                         = 110 (10);
FunctionDecls:      fun_decls (FunctionDecl, FunctionDecls)     = 111 (10);

FunctionDecl:       fun_decl (ParamList, FunctionBody)          =  20 (10);

ParamList:          nil                                         = 113 (10);
ParamList:          params (FunParam, ParamList)                = 114 (10);

FunctionBody:       CoreExpr                                    = 120 (10);

FunParam:           param (SequenceType, CoreExpr)              = 121 (10);

/* Pathfinder extension: recursion */
CoreExpr:           recursion (var, seed (CoreExpr, CoreExpr))  = 123 (10);

/* Pathfinder extension: XRPC */
CoreExpr:           xrpc (CoreExpr, FunExpr)                    = 124 (10);

%%

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

static void relabel (PFcnode_t *p,  PFcnode_t **kids);

#include "core_mnemonic.h"

/* helper function that transforms where list into nested if-then-else(empty) */
static PFcnode_t *
transform_where (PFcnode_t *p)
{
    assert (p);
    switch (p->kind) {
        case c_where:
            /* replace where nodes by if-then-else constructs */
            return if_ (L(p), then_else (transform_where (R(p)), empty ()));
        default:
            return p;
    }
}

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFcnode_t *p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFcnode_t *   kids[MAX_KIDS]; /* leaf nodes of this rule */
    short         old_state_label, old_state_label2;
    bool          manual;
    bool          rewrite_again;

    old_state_label = STATE_LABEL(p);

    /* guard against too dep recursion */
    PFrecursion_fence();

    do {
        rewrite_again = false;
        manual = false;

        /* determine rule that matches for this non-terminal */
        rule = PFsimplify_rule (STATE_LABEL (p), goalnt);

        assert (rule);

        /*
        fprintf (stderr, "rule %i\n", rule);
        */

        /* initialize the kids[] vector */
        for (unsigned short i = 0; i < MAX_KIDS; i++)
            kids[i] = NULL;

        /*
         * prepare recursive traversal: get information on leaf nodes of
         * this rule
         */
        nts = PFsimplify_nts[rule];
        PFsimplify_kids (p, rule, kids);

        switch (rule) {

            /* Query:              main (FunctionDecls, CoreExpr) */
            case 1:
                manual = true;

                /*
                 * Look at query body first, then at function declarations.
                 * This way we make sure that the expansion of let statements
                 * also considers function declarations.
                 */
                reduce (kids[1], nts[1]);
                reduce (kids[0], nts[0]);
                break;

            /* OptBindExpr:        for_ (forbind (forvars (var, nil),
                                                  LiteralValue),
                                         OptBindExpr) */
            case 2:
                *p = *let (letbind (LLL(p), LR(p)), R(p));
                relabel (p, kids);
                rewrite_again = true;
                break;

            /* OptBindExpr:        for_ (forbind (forvars (var, var),
                                                  LiteralValue),
                                         OptBindExpr) */
            case 3:
                *p = *let (letbind (LLL(p), LR(p)),
                           let (letbind (LLR(p), num (1)), R(p)));
                relabel (p, kids);
                rewrite_again = true;
                break;

            /* OptBindExpr:        let (letbind (var, Atom), OptBindExpr) */
            case 4:
                manual = true;

                /*
                 * Unfold atoms (a is an atom)
                 *
                 *     let $v := a return e
                 *  -->
                 *     e[a/$v]
                 *
                 * See the comment in the declaration of var_env to
                 * understand what's going on here.
                 */

                /*
                 * Handle Atom first.  In case it is a variable, this
                 * will make sure that we do transitive cases of variable
                 * replacement correctly.
                 */
                reduce (kids[0], nts[0]);

                /* add mapping for this variable to the environment */
                *((bind_t *) PFarray_add (var_env[hash(LL(p)->sem.var)]))
                    = (bind_t) { .var = LL(p)->sem.var, .atom = LR(p) };

                if (LL(p)->sem.var->global && LR(p)->kind == c_var)
                    LR(p)->sem.var->global = true;

                /*
                 * Reduce the return part.
                 */
                reduce (kids[1], nts[1]);

                /*
                 * Do NOT remove the variable from the environment.
                 */

                /*
                 * We have now replaced every occurrence of the variable
                 * in the return part with its binding atom.  The return
                 * part now becomes the expression itself.
                 */
                *p = *R(p);

                rewrite_again = true;
                break;

            /* OptBindExpr:        let (letbind (var,
                                                 flwr (let (letbind (var,
                                                                     CoreExpr),
                                                            nil),
                                                       WhereExpr)),
                                        OptBindExpr) */
            case 5:
            {   /*
                 * Remove a nested let block:
                 *
                 *     let $v1 := let $v2 := e return e' return e''
                 *  -->
                 *     let $v2 := e return
                 *       let $v1 := e' return
                 *         e''
                 */
                bool label = false;
                /* make sure to transform (necessary) where lists into
                   if-then-else(empty) constructs */
                if (LRR(p)->kind == c_where) {
                    /* throw away unnecessary where list */
                    if (L(LRR(p))->kind == c_true) {
                        assert (kids[1] == LRR(p));
                        LRR(p) = R(LRR(p));
                        kids[1] = LRR(p);
                    }
                    else {
                        LRR(p) = transform_where (LRR(p));
                        label = true;
                    }
                }

                /* Don't remove flwr if there is an order by -- we could prune
                   an type error. After typechecking we know that the order by
                   has correct type and can rewrite the same pattern */
                *p = *let (letbind (LL(LRL(p)),
                                    LR(LRL(p))),   /* let $v2 := e return */
                           let (letbind (LL(p),
                                         LRR(p)),  /*   let $v1 := e' ret */
                                R(p)));            /*     e''             */

                /* in case we rewrote the WhereExpr as well
                   we need to label the complete Core tree */
                if (!label)
                    relabel (p, kids);
                else
                    PFsimplify_label (p);

                rewrite_again = true;
            }   break;

            /* OptBindExpr:        let (letbind (var,
                                                 flwr (let (letbind (var,
                                                                     CoreExpr),
                                                            OptBindExpr)),
                                                       WhereExpr),
                                        OptBindExpr) */
            case 6:
            /* OptBindExpr:        let (letbind (var,
                                                 flwr (let (letbind (var,
                                                                     CoreExpr),
                                                            OptBindExpr),
                                                       OrdWhereExpr)),
                                        OptBindExpr) */
            case 7:
                /*
                 * Remove a nested let block:
                 *
                 *     let $v1 := let $v2 := e return e' return e''
                 *  -->
                 *     let $v2 := e return
                 *       let $v1 := e' return
                 *         e''
                 */
                *p = *let (letbind (LL(LRL(p)),
                                    LR(LRL(p))),       /* let $v2 := e return */
                         let (letbind (LL(p),          /*   let $v1 := e' ret */
                                       flwr (R(LRL(p)),
                                             LRR(p))),
                              R(p)));                  /*     e''             */
                relabel (p, kids);
                rewrite_again = true;
                break;

            /* WhereExpr:          where (true_, WhereExpr) */
            case 8:
            /* OrdWhereExpr:       where (true_, OrdWhereExpr) */
            case 9:
                *p = *(R(p));
                /* don't need to re-label here,
                 * RL(p) should already be labeled */
                rewrite_again = true;
                break;

            /* CoreExpr:          if_ (true_, then_else (CoreExpr, CoreExpr)) */
            case 11:
                *p = *RL(p);
                /* don't need to re-label here,
                 * RL(p) should already be labeled */
                rewrite_again = true;
                break;

            /* CoreExpr:          if_ (false_, then_else (CoreExpr, CoreExpr))*/
            case 12:
                *p = *RR(p);
                /* don't need to re-label here,
                 * RR(p) should already be labeled */
                rewrite_again = true;
                break;

            /* CoreExpr:           seq (seq (CoreExpr, CoreExpr), CoreExpr) */
            case 13:
                *p = *seq (LL(p), seq (LR(p), R(p)));
                relabel (p, kids);
                rewrite_again = true;
                break;

            /* CoreExpr:           seq (empty, CoreExpr) */
            case 15:
                *p = *R(p);
                rewrite_again = true;
                break;

            /* CoreExpr:           seq (CoreExpr, empty) */
            case 16:
                *p = *L(p);
                rewrite_again = true;
                break;


            /* FunExpr:            apply (arg (CoreExpr,
                                               arg (CoreExpr,
                                                    arg (CoreExpr,
                                                         FunctionArgs)))) */
            case 18:
                /*
                 * There's exactly one function defined with an arbitrary
                 * number of arguments: fn:concat(). We normalize it here
                 * to subsequent calls with just two arguments.
                 */
                if (! PFqname_eq (p->sem.fun->qname,
                                  PFqname (PFns_fn, "concat"))) {

                    PFfun_t *fn_concat = function (PFqname (PFns_fn, "concat"));

                    /* The result must refer to the same parent non-terminal
                       FunExpr as otherwise the next reduce() call fails. */
                    *p = *apply (fn_concat,
                                 arg (apply (fn_concat,
                                             arg (LL(p),
                                                  arg (LRL(p),
                                                       nil ()))),
                                      LRR(p)));

                    relabel (p, kids);
                    rewrite_again = true;
                }
                break;



            /* Atom:                var */
            case 19:
                {
                    /*
                     * See the comment in the declaration of var_env and
                     * the rule that processes let-bindings to understand
                     * what's going on here.
                     */
                    unsigned short h = hash (p->sem.var);

                    /*
                     * Look up this variable in the variable replacement
                     * environment.  If we find it there, do the replacement.
                     */
                    for (unsigned int i = 0; i < PFarray_last (var_env[h]); i++)
                        if (((bind_t *) PFarray_at (var_env[h], i))->var
                                == p->sem.var) {
                            *p = *((bind_t *) PFarray_at (var_env[h], i))->atom;
                            rewrite_again = true;
                            break;
                        }
                }
                break;

            /* FunctionDecl:       fun_decl (ParamList, FunctionBody) */
            case 20:
                /* During simplification, the function body root may have
                 * changed. Fix it in the corresponding PFfun_t struct.
                 */
                p->sem.fun->core = R(p);
                break;

            default:
                break;
        }
    } while (rewrite_again);

    old_state_label2 = STATE_LABEL(p);

    if ( ! manual )
        for (unsigned int i = 0; nts[i]; i++) {
            while (reduce (kids[i], nts[i]))
                relabel (p, kids);
        }

    if (old_state_label != STATE_LABEL(p)
        || old_state_label2 != STATE_LABEL(p))
        return true;

    return false;
}


/*
 * Re-label a match pattern.
 *
 * Start with node @a p and relabel the subtree below. However, stop
 * if @a p is one of the pattern leaves, passed as the argument @a kids.
 */
static void
relabel (PFcnode_t *p,  PFcnode_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    /* Relabel p's children. */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFsimplify_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        relabel (L(p), kids);
        STATE_LABEL(p) = PFsimplify_state (OP_LABEL(p),
                                           STATE_LABEL(L(p)),
                                           0);
    }
    else if (!L(p) && R(p)) {
        relabel (R(p), kids);
        STATE_LABEL(p) = PFsimplify_state (OP_LABEL(p),
                                           STATE_LABEL(R(p)),
                                           0);
    }
    else {
        relabel (L(p), kids);
        relabel (R(p), kids);
        STATE_LABEL(p) = PFsimplify_state (OP_LABEL(p),
                                           STATE_LABEL(L(p)),
                                           STATE_LABEL(R(p)));
    }

}

/* initialize global  variables */
static void
PFsimplify_init (void)
{
    /* set up variable replacement environment */
    for (unsigned short i = 0; i < HASH_BUCKETS; i++)
        var_env[i] = PFarray (sizeof (bind_t), 128);
}

/**
 * Simplify XQuery Core tree.
 *
 * @param r root of the XQuery Core tree.
 * @return the simplified Core tree
 */
PFcnode_t *
PFsimplify (PFcnode_t *r)
{
    assert (r);

    /* initialize global  variables */
    PFsimplify_init ();

    /* label the Core tree bottom up */
    PFsimplify_label (r);

    /* invoke rewriting */
    while (reduce (r, 1))
        /* rewrite as long as there is something to do. */;

    return r;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
