PATHFINDER'S EXTENSIONS TO THE W3C XQUERY LANGUAGE
==================================================

The Pathfinder compiler implements a number of extensions and/or
modifications to the XQuery language specification published by
the W3 Consortium.

1. XQuery Update Facility
-------------------------

There is (preliminary) support for the XQuery Update Facility.
Update statements, however, are currently only supported in
Pathfinder's "milprint_summer" back-end.

Due to some problem's with Pathfinder's XQuery parser, note that
"our" syntax for rename expression is

  "do rename" TargetExpr "into" NewNameExpr

while the Update Facility uses "as" instead of "into".  Sorry
for the inconvenience.

(The same issue has been discussed in the W3C XQuery bug
tracking system: http://www.w3.org/Bugs/Public/show_bug.cgi?id=4176.)


2. Transitive Closure Operator
------------------------------

There is some interest in the research community for a dedicated
*transitive closure* operator (contrasted to XQuery's means to
provide for recursion, user-defined functions).  Pathfinder, hence,
provides the syntax extension

  "with" $variable ["as" Type] "seeded by" SeedExpr "recurse" Expr

The semantics of this expression is

 (1) Evaluate SeedExpr.  It serves as a seed to the recursion
     process and is bound to variable $variable in the first
     recursion step.

 (2) For each recursion step, evaluate the expression's body
     Expr.  This body may refer to variable $variable, which is
     bound to the outcome of the previous recursion step (or to
     the seed expression if we are in the first step).

 (3) All evaluations of the body are collected by means of the
     XQuery `union' operator to form the expression result.
     Recursion stops as soon as we reach a fix point.

A few remarks:

 -- An optional type declaration may be used to restrict the type
    of the recursion variable.  If it is omitted, Type defaults to
    `node*'.  In any case, the static types of both expressions,
    SeedExpr and Expr must be subtypes of Type.

 -- XQuery's `union' operator is only defined on nodes.  Hence,
    Type must be a subtype of `node*'.  There are some more
    restrictions on Type to make the entire expression sensible
    (e.g., its quantifier must be greater than 1).

 -- It is possible to write recursive expressions that do not reach
    a fix point.  Evaluation won't terminate in that case.

The transitive closure operator is only supported when using
Pathfinder's algebraic back-end.  On the other hand, the algebraic
back-end does not support any other means of recursion (don't try;
you have been warned).  The "milprint_summer" back-end, in contrast,
provides full support for recursive user-defined functions (though
they may suffer from poor performance).

3. Support for Stand-Off Annotations
------------------------------------

In addition to the 12 XPath axes described by the W3C specifications,
Pathfinder provides four axes that allow for simple and efficient
querying of so-called stand-off annotations, specially crafted XML
attribute nodes that lead to a multi-hierarchy XML structure.

More on this functionality can be found in

 Efficient XQuery Support for Stand-Off Annotation.  Wouter Alink,
 Raoul Bhoedjang, Arjen de Vries, and Peter Boncz.  XIME-P 2006.

This functionality is compiled in by default, but must be enabled
explicitly on the XQuery compiler Pathfinder's command line via
the option `--enable-standoff' (short: `-b').

Stand-Off functionality is currently only available in Pathfinder's
"milprint_summer" back-end.

4. Full Text Retrieval, PF/Tijah
--------------------------------

The database group a U Twente contributed full text retrieval
functionality to the Pathfinder project in terms of their "Tijah"
system.

[ Documentation on this remains to be filled in... ]

This functionality needs to be compiled in explicitly via the
`--enable-pftijah' option of the ./configure command.

Full text functionality is currently only available in Pathfinder's
"milprint_summer" back-end.

5. XQuery RPC
-------------

The MonetDB/XQuery system allows the remote invocation of XQuery
user-defined functions in a peer-to-peer fashion.

[ Documentation on this remains to be filled in... ]

Pathfinder's XRPC functionality can be accessed via a syntax extension
in our compiler.  The statement

  execute at { <<URI>> } { <<FunctionCall>> }

will execute the function call given in the second pair of curly
braces at the URI specified in the first pair of braces.  The URI
expression may be any expression that can sensibly be interpreted
as a string.  A syntactically lighter variant using a literal URI 
is acceptable as well:

  execute at "<<URI>>" { <<FunctionCall>> }

XQuery RPC functionality is currently only available in Pathfinder's
"milprint_summer" back-end.


6. Document Management Interface 
--------------------------------

The XQuery specification provides limited means for querying the
meta-data repository (i.e. fn:doc() and fn:collection()), and no means
to change it (i.e. add and delete documents).

To avoid having to resort to other means than XQuery for data management
tasks, we provide the following functions:

  pf:del-doc(name as xs:string) as docmgmt
  pf:add-doc(location as xs:string, 
             name as xs:string, 
             collection as xs:string, 
             percentage as xs:integer) as docmgmt

An XML document is stored at a 'location' (URI) and can be given a
logical name. A 'collection' is a database object that contains multiple
documents. Especially in cases where we have many small documents, it
may make sense to store them together in a collection (i.e. by using the
same 'collection' name in the pf:add-doc() function).

Parameters: in pf:add-doc(), 'name' and 'collection' may be both
omitted, in which case name=collection=location.  If only 'collection'
is omitted, collection=name.  Percentage may always be omitted, in which
case it is 0.

The percentage is a percentage of free space to leave in the shredded
document to accomodate future updates. Colections with a percentage=0
are taken to be read-only. Updates to such documents produce a runtime
error.

Calls to functions that manipulate the persistent storage may not be
intermixed with update statements or query expressions.  All docuemnt
management functions return the special type `docmgmt' to ensure this.
You can call document management functions from user-defined functions.
But you explicitly have to declare your function as a document
management function using the Pathfinder syntax extension

  declare document management function your-function-name (..args..)
  {
    ..body..
  };

(similar in spirit to the `declare updating function' syntax from the
W3C XQuery Update Facility).

We also provide two information functions:

pf:collections() as xs:string*
pf:documents(collection as xs:string*) as xs:string*

The pf:collections() function provides a full list of all collection
names.  The pf:documents() function provides a full list of all document
names in a collection.


7. Element Node Identifiers
---------------------------

Internally, all nodes get an immutable identifier in the MonetDB
backend.  These identifiers are integer numbers, but represented as a
xs:string.

This identifier can be obtained using the function:

pf:nid(element()*) as xs:string*

With this identifier, elements can be quickly retrieved using the
existing: 

  fn:id(xs:string*) as node()*
  fn:id(xs:string*, node()) as node*

Note that this is an extension of fn:id() because the ID xs:string
values normally cannot start with a digit (this is how we distinguish
between them).

Element node identifiers (and standard ID/IDREF support) are currently
only available in Pathfinder's "milprint_summer" back-end.


8. Missing math functions
-------------------------

The XQuery standard only defines a limited number of mathematical functions
in its functions and operators. The functions below have been added in the
"pf" namespace. They are currently only available in Pathfinder's
"milprint_summer" backend.

Natural logarithm
   pf:log(xs:decimal) as xs:decimal
   pf:log(xs:decimal?) as xs:decimal?
   pf:log(xs:double) as xs:double
   pf:log(xs:double?) as xs:double?
Square root
   pf:sqrt(xs:decimal) as xs:decimal
   pf:sqrt(xs:decimal?) as xs:decimal?
   pf:sqrt(xs:double) as xs:double
   pf:sqrt(xs:double?) as xs:double?
