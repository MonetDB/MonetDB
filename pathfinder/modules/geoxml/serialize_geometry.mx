@/
Copyright Notice:
-----------------

The contents of this file are subject to the PfTijah Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://dbappl.cs.utwente.nl/Legal/PfTijah-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the PfTijah system.

The Initial Developer of the Original Code is the "University of Twente".
Portions created by the "University of Twente" are
Copyright (C) 2006-2007 "University of Twente".
All Rights Reserved.
@

@f serialize_geometry
@a Jan Flokstra
@t serialize_geometry

@h

extern int serialize_geometry_DRIVER(
	BAT**			res;
        BAT*			ws,
        BUN			niters,
        BAT*			loop,
        BAT*			iter,
        BAT*			item, 
        BAT*			kind,
        BAT*			intVAL,
        BAT*			dblVAL,
        BAT*			strVAL);

@c
#include <pf_config.h>
#include <ctype.h>
#include <gdk.h>

/*******************************************
 * serialize_geometry.c : GEOXML options serialization
 *
 */

#include "serialize.h"
/* contains dummy callback functions */
#include "serialize_null.h"

typedef struct GEOENV {
    int  cnt;			/* count the number of tags here */
    BAT* bat;			/* [str,str] result BAT */
    int  stop_filling;
    int  fill_wkb;
    char* wkb_kind;
    int	  wkb_par2;
    unsigned char geobuff[65536];
    unsigned char *p;

    const char* errorMessage;	/* error message buffer */
} GEOENV;

static struct GEOENV* GLOBAL_GEOENV = NULL;

/**
 *
 * Definition of the structure containing the functions
 */
static bool
serialize_geometry_init(XqueryCtx* ctx, char* args, char *restag, char *resprefix) {
    (void) args;
    (void) restag;
    (void) resprefix;

    ctx->driverWs		= GLOBAL_GEOENV;
    GLOBAL_GEOENV->errorMessage	= NULL;
    GLOBAL_GEOENV->fill_wkb 	= 0;
    GLOBAL_GEOENV->geobuff[0] 	= 0;


    GLOBAL_GEOENV->bat = BATnew(TYPE_void, TYPE_str, 32);
    BATseqbase(GLOBAL_GEOENV->bat, 0);
#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: serialize_geometry_init() called.\n");
#endif
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static bool
serialize_geometry_handle_startElement(XqueryCtx* ctx, str ns, str name, oid pre) {
    struct GEOENV* geoenv = (struct GEOENV*)ctx->driverWs;
    (void)ns;
    (void)pre;

    if ( strcmp(name,"LinearRing")==0) {
    	/* geoenv->wkb_kind = "LINEARRING";  */
    	geoenv->wkb_kind = "POLYGON"; 
    	geoenv->wkb_par2 = 1; 
    } else if ( strcmp(name,"Point")==0) {
    	geoenv->wkb_kind = "POINT"; 
    } else if ( strcmp(name,"coordinates")==0) {
    	geoenv->fill_wkb++;
    }
#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: serialize_geometry_handle_startElement(%s) SUCCES.\n",name);
#endif
    return 1;
}

static bool
serialize_geometry_handle_endElement (XqueryCtx* ctx, str prefix, str name) {
    struct GEOENV* geoenv = (struct GEOENV*)ctx->driverWs;
    (void)prefix;

    if ( strcmp(name,"coordinates")==0) {
    	geoenv->fill_wkb--;
	geoenv->stop_filling = 1; /* cannot handle multi yet*/
    }
    return 1;
}

static void start_point(struct GEOENV* geoenv) {
    if ( !geoenv->wkb_kind )
    	geoenv->wkb_kind = "LINESTRING";
    if ( !geoenv->geobuff[0] ) {
    	sprintf(&geoenv->geobuff[0],"%s(",geoenv->wkb_kind);
        geoenv->p = &geoenv->geobuff[strlen(&geoenv->geobuff[0])];
	if (geoenv->wkb_par2 ) {
    	    *geoenv->p++ = '(';
    	    *geoenv->p   = 0;
	}
    } else {
    	*geoenv->p++ = ',';
    	*geoenv->p   = 0;
    }
}

static void 
add_point2buff(struct GEOENV* geoenv, unsigned char* p_start, unsigned char* p_end) {
    size_t sz = (size_t)(p_end - p_start);
    memcpy(geoenv->p,p_start,sz);
    geoenv->p += sz;
    *geoenv->p = 0;
}

static bool scan_for_points(struct GEOENV* geoenv, unsigned char* p) {
    while( *p ) {
        while( isspace(*p) ) p++;
        if ( *p ) {
            unsigned char *lp = p;
    
            // stream_printf(GDKout,"#! SP-1: %s\n",p);
	    start_point(geoenv);
            while (*p && *p!=',') p++;
	    if (*p==',') {
                // stream_printf(GDKout,"#! SP-2: %s\n",p);
	        // emit
	        add_point2buff(geoenv,lp,p);
                *geoenv->p++ = ' ';
	        p++;
                while( isspace(*p) ) p++;
	        lp = p;
	        while( *p && !isspace(*p) ) p++;
	        // emit
	        add_point2buff(geoenv,lp,p);
	    }
        }
        // stream_printf(GDKout,"# %s\n",&geoenv->geobuff[0]);
    }
    return 1;
}

static bool 
serialize_geometry_handle_characters (XqueryCtx* ctx, str chars) {
    struct GEOENV* geoenv = (struct GEOENV*)ctx->driverWs;

    if ( geoenv->fill_wkb && !geoenv->stop_filling ) {
	if ( 0 ) {
	    FILE *f = fopen("/tmp/x","a");
	    fprintf(f,"HC[\"%s\"]\n",chars);
	    fclose(f);
	}
	return scan_for_points(geoenv,(unsigned char*)chars);
    } else
    	return 1;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
static bool
serialize_geometry_handle_attribute(XqueryCtx* ctx, str prefix, str loc, str value) {
    (void)ctx;
    (void)prefix;
    (void)loc;
    (void)value;
#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: serialize_geometry_handle_attribute(%s,%s) SUCCES.\n",loc,value);
#endif
    return 1;
}

// bool null_seqStart (XqueryCtx* ctx, int count);
// bool null_complete_seqStart (XqueryCtx* ctx);
// bool null_seqEnd (XqueryCtx* ctx);
// bool null_seqItemStart (XqueryCtx* ctx, int kind);
// bool null_seqItemEnd (XqueryCtx* ctx, int kind);
// bool null_seqItemSeparator (XqueryCtx* ctx, int kind1, int kind2);

bool serialize_geometry_seqItemStart (XqueryCtx* ctx, int kind) {
    (void)kind;
    struct GEOENV* geoenv = (struct GEOENV*)ctx->driverWs;
    geoenv->wkb_kind   = NULL;
    geoenv->wkb_par2   = 0;
    geoenv->geobuff[0] = 0;
    geoenv->stop_filling = 0;
    geoenv->p          = &geoenv->geobuff[0];
#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: serialize_geometry_seqItemStart() SUCCES.\n");
#endif
    return 1;
}

bool serialize_geometry_seqItemEnd (XqueryCtx* ctx, int kind) {
    (void)kind;
    struct GEOENV* geoenv = (struct GEOENV*)ctx->driverWs;

    if ( geoenv->geobuff[0] ) {
    	*geoenv->p++ = ')';
	if ( geoenv->wkb_par2 )
    	    *geoenv->p++ = ')';
	*geoenv->p   = 0;
	if ( 0 ) {
	    FILE *f = fopen("/tmp/x","a");
	    fprintf(f,"geostr.append(\"%s\");\n",&geoenv->geobuff[0]);
	    fclose(f);
	}
        if ( !BUNappend(geoenv->bat, (str)&geoenv->geobuff[0], FALSE) )
            stream_printf(GDKout,"serialize_geometry: WRITE FAILS\n");
    } else {
    	str xxx = "POINT( 0 0 )";
        if ( !BUNappend(geoenv->bat, xxx, FALSE) )
            stream_printf(GDKout,"serialize_geometry: WRITE FAILS\n");
        // stream_printf(GDKout,"serialize_geometry: missed geobuff!!\n");
    }

#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: serialize_geometry_seqItemEnd() SUCCES.\n");
#endif
    return 1;
}


static struct serializeFunStruct serialize_geometrySerializeFun = {
    "serialize_geometry",
    serialize_geometry_init,
    null_cleanup,

    null_startSerialize,
    null_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    serialize_geometry_handle_startElement,
    serialize_geometry_handle_endElement,
    serialize_geometry_handle_characters,
    null_handle_ignorableWhitespace,
    null_handle_comment,
    null_handle_processingInstruction,

    null_complete_startElement,
    null_complete_startElementEmpty,
    serialize_geometry_handle_attribute,

    null_seqEmitBool,
    null_seqEmitInt,
    null_seqEmitDbl,
    null_seqEmitStr,
    null_handle_attribute,
    null_handle_characters,

    null_seqStart,
    null_complete_seqStart,
    null_seqEnd,
    serialize_geometry_seqItemStart,
    serialize_geometry_seqItemEnd,
    null_seqItemSeparator
};

int serialize_geometry_DRIVER(
	BAT**			res,
        BAT*			ws,
        BUN			niters,
        BAT*			loop,
        BAT*			iter,
        BAT*			item, 
        BAT*			kind,
        BAT*			intVAL,
        BAT*			dblVAL,
        BAT*			strVAL) {

	(void)niters;
	(void)loop;
	(void)iter;
	struct GEOENV ptos;
	if ( GLOBAL_GEOENV ) {
	    /* error locked ?? */
	    return GDK_FAIL;
	}
	GLOBAL_GEOENV = &ptos;
	ptos.cnt = 0;
	ptos.bat = BATnew(TYPE_str, TYPE_str, 32);
#ifdef FULLDEBUG
	stream_printf(GDKout,"******** NITERS = %d\n",niters);
	BATprintf(GDKout,loop);
	BATprintf(GDKout,iter);
	BATprintf(GDKout,item);
	BATprintf(GDKout,kind);
	BATprintf(GDKout,strVAL);
#endif
	int returnVal = xquery_print_result_DRIVER(
            "",
            &serialize_geometrySerializeFun,
            "",
        	ws,
        	1,    /* niters, */
        	item, /* loop, */
        	item, /* iter, */
        	item, 
        	kind,
        	intVAL,
        	dblVAL,
        	strVAL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
#ifdef FULLDEBUG
	stream_printf(GDKout,"CALLED xquery_print_result_DRIVER: res=%d\n",returnVal);
	BATprintf(GDKout,ptos.bat);
#endif
	*res = ptos.bat;
	GLOBAL_GEOENV = NULL;
	return returnVal;
}

/* vim:set shiftwidth=4 expandtab: */
