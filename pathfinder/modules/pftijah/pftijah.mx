@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2006 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'

@f pftijah
@a Jan Flokstra
@a Henning Rode
@t pftijah

@m
.MODULE pftijah;

.USE pathfinder;

.COMMAND run_tijah_command(str s) : bit = CMDtijah_command;
 "INCOMPLETE"

.COMMAND run_tijah_query(BAT[str,str], BAT[void,oid], str q) : BAT[oid,dbl] = CMDtijah_query;
 "INCOMPLETE"

.COMMAND tj_normalizeTerm(str, str) : str = CMDtj_normalizeTerm;
 "INCOMPLETE"

.COMMAND tj_add2collection(BAT[oid,bat],BAT[oid,bat],str,str) : BAT[void,bat] = CMDtj_add2collection;
 "INCOMPLETE"

.COMMAND tj_add2collection_index(BAT[oid,bat],str) : BAT[void,bat] = CMDtj_add2collection_index;
 "INCOMPLETE"
 
.COMMAND tijah_tokenize(str) : str = CMDtijah_tokenize;
 "INCOMPLETE"

.COMMAND serialize_tijah_opt(
                      BAT[void,bat] ws,
                      int	    niters,
                      BAT[void,oid] loop,
                      BAT[void,oid] iter,
                      BAT[void,oid] item,
		      BAT[void,int] kind,
                      BAT[void,lng] int_values,
		      BAT[void,dbl] dbl_values,
		      BAT[void,str] str_values)
		       : BAT[str,str] = serialize_pftijah_options_DRIVER;
 "C interface to pftijah option serialize"

.COMMAND pf2tijah_node(
                      BAT[void,str] doc_name,
                      BAT[void,int] doc_firstpre,
                      BAT[oid,oid] pfpre,
                      BAT[void,oid] item,
		      BAT[void,int] kind,
                      BAT[void,str]  doc_loaded)
		       : BAT[void,oid] = CMDpf2tijah_node;
 "Translate Pathfinder node sequence to tijah node sequence"

.COMMAND offsetindex( BAT[void,oid] offset_tid, int res_size)
		: BAT[void,oid] = CMDoffsetindex;

"PARAMETERS:
BAT[void,oid] - the offset index 
ressize       - the result size, equals number of different tids + 1
DESCRIPTION:
creates an offset index.
"

.COMMAND indexfetchjoin( BAT[any,oid] tid, BAT[void,oid] index, BAT[void, oid] pre)
		: BAT[oid,oid] = CMDindexfetchjoin;
"PARAMETERS:
BAT[any,oid] - bat with tail values which have to be joined (e.g. tid values)
BAT[void,oid] - join index bat with value-offset
BAT[void,oid] - bat with indexed offset and tail values to be returned
DESCRIPTION:
the join algorithm comes down to a repeated slice and insert operation.
"

.PRELUDE = pftijah_prelude;
.EPILOGUE = pftijah_epilogue;

.END pftijah;
@mil
module("pathfinder");
module("monettime");

###
# This file contains implementations of some of the SRA operators 
# to run on the TIJAH Light index.
#
# Based on code by the TIJAH team (Vojkan, Thijs)
#
# Additional retrieval models by Henning Rode 
#
# Authors: Roel van Os <roel.van.os@glacimonto.nl>
#          Henning Rode <h.rode@cs.utwente.nl>
#
###

const DEBUG := false;

# Type of the size used
const SIZE_ENTITY := 1;
const SIZE_TERM := 2;

# Comparisons
const GREATER := 10;
const LESS := 11;
const EQUAL := 12;
const GEQ := 13;
const LEQ := 14;

# Modifiers
const NORMAL := 71;
const PLUS := 72;
const MINUS := 73;
const MUST := 74;
const MUST_NOT := 75;

# Default score (0 or 1)
var scoreBase := 0;

const ENTITY_NUM := 10000;

var collName := "PFX";
var background_collName := "PFX";
var collHeight := 10;
var retNum := 100;

var trace := false;

##
# For retrieval models: 
#   true:  return all elements from the context set
#   false: return only elements from the context set that contain one or more query terms
#
# Setting this variable to false has the advantage of smaller intermediate region sets.
# In theory, true has the advantage of better results, since it is possible that
# elements that don't match any term at the beginning of a query, contain descendants
# that do match terms.
##
var returnAllElements := true;

if (view_bbp_name().reverse().exist("tj_collName")) {
	if (bat("tj_collName").count() > 0) {
		var name := bat("tj_collName").fetch(0);
		tj_setCollName(name);
	}
}

PROC tj_setCollName(str name) : void := 
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(name))) {
		ERROR("collection \"%s\"does not exist",name);
	}
	collName := name;
	background_collName := name;
	collHeight := bat("tj_" + collName + "_param").find("height").int();
	if ( DEBUG ) { 
        	printf("Work collection is set to %s (with height %d)\n", collName, collHeight);
        	fflush(stdout());
        } 
}

PROC tj_setBackgroundCollName(str name) : void := 
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(name))) {
		ERROR("background collection \"%s\"does not exist",name);
	}
	background_collName := name;
	if ( DEBUG ) { 
        	printf("Background collection is set to %s (with height %d)\n", collName, collHeight);
        	fflush(stdout());
        } 
}

PROC tj_setScoreBase(int default) : void :=
{
	scoreBase := default;
}


var equivalences := new(str,str);
PROC tj_initEquivalences() : void := 
{
    equivalences := new(str,str);
}

PROC tj_addEquivalenceClass( bat elements ) : void := 
{
    # Create cross product of class elements
    var class := eqclass.reverse().cross( eqclass );
    # Append to equivalences table
    equivalences := equivalences.insert( class );
}

var tracefile_handle := nil;
PROC tj_trace( str s ) : void := 
{
    if ( not( tracefile = "" ) ) {
        if ( isnil( tracefile_handle ) )
            tracefile_handle := open_wastream(tracefile);
        
        tracefile_handle.stream_write( sprintf( "%d %s\n", int(msec()/1000), s ) );
        tracefile_handle.stream_flush();
    }
}

const virtRoot := 0@0;


##
# Compute ancestor-descendant relation. 
#
# Forwards to anc_desc_llscj: see below.
##
PROC anc_desc( bat[oid,any] anc, bat[oid,any] desc ) : bat[oid,oid] :=
{
   return anc_desc_llscj(anc,desc);
}


##
# Compute ancestor-descendant relation using the loop-lifted staircase join.
#
# The arguments anc and desc must contain preorder indices in their heads. 
# The tail values are discarded.
#
# Returns a bat containing [anc,desc] preorder index pairs
##
PROC anc_desc_llscj( bat[oid,any] anc, bat[oid,any] desc ) : bat[oid,oid] :=
{
    if ( trace ) tj_trace( "BEGIN anc_desc_llscj" );
    
    # Items contains the context nodes for the descendant step: 
    # this is the right side argument to contained_by.
    # The table must be [void,oid], so:
    var items := anc.sort().mark(0@0).reverse();
    
    # Suggestion from Thijs: make iters a [void,void], with the same length as anc
    var iters := anc.hmark(oid(0)).mark(oid(0));
    
    # Candidates contains the right side argument. This must also be [void,oid]:
    var candidates := desc.sort().mark(0@0).reverse();
    
    # Load the pre-size table
    var pre_size := load( "tj_" + collName + "_size1");
    
    # Call the descendant algorithm: it returns [ancestor, descendant] pairs 
    # if we pass items as the iteration argument
    var void_desc := ll_descendant(iters, items, pre_size, candidates, false, false, min(iters), max(iters), false, chr(nil));
    
    # Map back the ancestors
    var anc_desc  := anc.mark(oid(0)).join(void_desc);
    
    candidates := nil;
    items := nil;
    pre_size := nil;
    
    if ( trace ) tj_trace( "END   anc_desc_llscj" );
    return anc_desc;
}


## 
# Compute parent-child relation. 
# 
# Forwards to parent_child_llscj: see below.
##
PROC parent_child( bat[oid,any] parent, bat[oid,any] child ) : bat[oid,oid] :=
{
    return parent_child_llscj( parent, child );
}


## 
# Compute parent-child relation using the loop-lifted staircase join. 
# 
# The arguments parent and child must contain preorder indices in their heads. 
# The tail values are discarded.
#
# Returns a bat containing [parent,child] preorder index pairs
##
PROC parent_child_llscj( bat[oid,any] parent, bat[oid,any] child ) : bat[oid,oid] :=
{
    # Items contains the context nodes for the descendant step: 
    # this is the right side argument to contained_by.
    # The table must be [void,oid], so:
    var items := parent.mark(0@0).reverse();
    
    # Suggestion from Thijs: make iters a [void,void], with the same length as anc
    var iters := parent.hmark(oid(0)).mark(oid(0));
    
    # Candidates: all element nodes
    var candidates := child.sort().mark(0@0).reverse();
    
    # Load the pre-size table
    var pre_size := load( "tj_" + collName + "_size1");
    
    # Check the order of the items:
    items.chk_order();
    
    var void_chld := ll_child(iters, items, pre_size, candidates, collHeight, false, false, min(iters), max(iters), false);
    
    # Map back the ancestors
    var par_desc  := parent.mark(oid(0)).join(void_chld);
    
    candidates := nil;
    items := nil;
    pre_size := nil;
    
    return par_chld;
}


##
# Converts a list of query terms to a list of term id->document position mappings.
#
# Stemming on the query terms is performed using the same stemmer
# that was used for the collection.
#
# Results are sorted on the document position (tail)
##
PROC Qterms_to_tid_pre( bat[void,str] Qterms ): bat[oid,oid] :=
{
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var stemmed := [tj_normalizeTerm]( [toLower](Qterms), stemmer );
    
    var tids    := bat("tj_globalTerms").join( stemmed.reverse() ).sort().hmark(oid(0));
    
    var result := indexfetchjoin( tids,
                                  bat("tj_" + collName + "_TermIndex"),
                                  bat("tj_" + collName + "_Terms") );
    return result.tsort();
}


##
# Converts a list of query terms to a list of term ids
#
# Stemming on the query terms is performed using the same stemmer
# that was used for the collection.
##
PROC Qterms_to_void_tid( bat[void,str] Qterms ): bat[void,oid] :=
{
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var stemmed := [tj_normalizeTerm]( [toLower](Qterms), stemmer );
    
    var tids := bat("tj_globalTerms").join( stemmed.reverse() ).sort().hmark(oid(0));
    return tids;
}


##
# Return only the element nodes from region ctx
##
PROC nodes( bat[oid,any] ctx ) : bat[oid,any] :=
{
    # The pfpre table only stores element nodes, so we can use it as a filter:
    var pfpre  := bat( "tj_" + collName + "_pfpre");
    var result := pfpre.mirror().join( ctx );
    return result;
}


##
# Return only the terms from region ctx
##
PROC terms( bat[oid,any] ctx ) : bat[oid,any] :=
{
    # A term is everything that is not an element node
    var nodes  := nodes( ctx );
    var result := ctx.kdiff( nodes );
    return result;
}


################################################################################
# SELECTION
################################################################################

##
# Select the root node of the collection
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_root() : bat[oid,dbl] :=
{
    if ( not( isnil( startNodes ) ) ) {
        # Start from a set of starting nodes if available. 
        # It is assumed that the startNodes are [any, pre]
        if ( count( startNodes ) > 0 ) {
            var root_reg := startNodes.reverse().sort().project( dbl(scoreBase) );
            return root_reg;
        } else {
            var root_reg := new(oid,dbl,1);
            
            root_reg.insert( virtRoot, dbl(scoreBase) );
            return root_reg;
        }
    } else {
        # Because TIJAH expects all documents in a collection to be contained by one 
        # "virtual root" element, his behaviour should be emulated by the light index. 
        # An element with preorder oid(0) will indicate that it is the collection root.
        var root_reg := new(oid,dbl,1);
        
        root_reg.insert( virtRoot, dbl(scoreBase) );
        return root_reg;
    }
}

PROC select_root_frag() : bat[oid,bat] := 
{
    var res := new(oid,bat);
    
    res.insert(1@0, select_root() );
    return res;
}

##
# Select all element nodes in the collection
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_node() : bat[oid,dbl] := 
{
    # The table pfpre only stores element nodes, so we can use it as a filter:
    var pfpre  := bat( "tj_" + collName + "_pfpre");
    
    return pfpre.project( dbl(scoreBase ) );
}

##
# Select all element nodes in the collection with the given name
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_node(str name) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( sprintf("BEGIN select_node('%s')", name) );

    var tids := bat("tj_globalTags").select(name);
    if (tids.count() = 0) return new(oid,dbl);
    var tid := tids.reverse().fetch(0);
    var result := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TagIndex"),
    				  bat("tj_" + collName + "_Tags") );
    result := result.reverse().sort().project(dbl(scoreBase)); 

    if ( trace ) tj_trace( sprintf("END   select_node('%s')", name) );
    return result;
}


##
# Select all element nodes in the collection with the given name.
#
# Equivalence classes are taken into account. 
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_node(str name, bit e_class) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( sprintf("BEGIN select_node('%s',%d)", name, e_class) );
    
    if ( e_class ) {
        var names := equivalences.uselect( name ).reverse();
        if ( count( names ) = 0 ) {
            # Apparently, there were no equivalent tags (not even the tag itself)
            #names := new(void,str).seqbase(oid(0));
            #names.append(name);
            return select_node(name);
        }
        
        var tids := bat("tj_globalTags").join(names.reverse()).mark(0@0).sort().reverse();
        
        var result := indexfetchjoin( tids,
                        bat("tj_" + collName + "_TagIndex"),
                        bat("tj_" + collName + "_Tags") );
        result := result.reverse().sort().project(dbl(scoreBase)); 
        
        
        if ( trace ) tj_trace( sprintf("END   select_node('%s',%d)", name, e_class) );
        return result;
    } else {
        if ( trace ) tj_trace( sprintf(" END select_node('%s',%d)", name, e_class) );
        return select_node(name);
    }
}

PROC select_node_frag(str name, bit e_class) : bat[oid,bat] := 
{
    var res := new(oid,bat);
    
    res.insert(1@0, select_node(name, e_class) );
    return res;
}


##
# Select all terms with the given value
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_term(str name) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( sprintf("BEGIN select_term('%s')", name) );
    # 
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var term    := tj_normalizeTerm( toLower(name), stemmer );
    
    # Select the term positions from the global term dictionary.
    var tids := bat("tj_globalTerms").select(term).mark(0@0).sort().reverse();
    
    var result := indexfetchjoin( tids,
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
    result := result.reverse().sort().project(dbl(scoreBase)); 
    

    if ( trace ) tj_trace( sprintf("END   select_term('%s')", name) );
    return result;
}


##
# Select all terms with the given value, possibly performing stemming on the argument.
#
# This variant of the select_term function is present for compatibility reasons:
# at the moment, stemming is always performed using the same stemmer that was
# used to index the collection.
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_term(str name, int stemming) : bat[oid,dbl] := 
{
    return select_term( name );
}


##
# Select a number of terms by their term-id.
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_phrase(bat[void,oid] terms) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN select_phrase" );
    # Select the term positions from the global term dictionary. 
   
    var tid := terms.fetch(0);
    var tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
    var res := tmp.reverse();
    var j := terms.count();
    var i := 1; 
    while (i < j)
    {
        tid := terms.fetch(i);
        tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
        res := res.semijoin(tmp.[int]().[-](i).[oid]().reverse());   
	i :+= 1;
    }	
    
    res := res.sort().project(dbl(scoreBase)); 
    
    if ( trace ) tj_trace( "END   select_phrase" );
    return res;
}


################################################################################
# CONTAINMENT
################################################################################


#####################################
# left CONTAINED_BY right:
#
#   +--------------------+
#   |       right        |
#   | +---------------+  |
#   | |      left     |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it is contained a region in right
#
#####################################
PROC contained_by(bat[oid,dbl] left, bat[oid,dbl] right) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN contained_by_2" );
    
    # Check for the virtual root
    if ( not( bat("tj_"+collName+"_size1").exist(0@0) ) ) {
        # Exceptions for root in left or right argument. The case 
        # of region sets containing the root is not handled
        if ( count( left ) = 1 )
            if ( left.reverse().fetch(0) = virtRoot ) 
                return new(oid,dbl);
        
        if ( count( right ) = 1 )
            if ( right.reverse().fetch(0) = virtRoot ) 
                return left;
    }
    
    var anc_desc := anc_desc( right, left );
    
    # Attach the scores to the resulting nodes again:
    var result := anc_desc.reverse().mirror().join(left);
    
    if ( trace ) tj_trace( "END   contained_by_2" );
    return result;
}

PROC contained_by_frag(bat[oid,bat] left, bat[oid,bat] right) : bat[oid,bat] :=
{
    var res        := new(oid,bat);

    left@batloop() {
      if ( right.exist($h) ) {
        res.insert($h, $t.contained_by(right.find($h)) );
      }
    }
    return res;
}

##
# Returns all regions in the collection that are contained by the argument. 
# Equivalent with a descendant step in XPath.
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC contained_by(bat[oid,dbl] region) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN contained_by_1" );
    if ( not( bat("tj_"+collName+"_size1").exist(0@0) ) ) {
        # Exceptions for root in argument. The case 
        # of region sets containing the root is not handled
        if ( count( region ) = 1 ) 
            if ( region.reverse().fetch(0) = virtRoot )
                return select_node();
    }


    var ctx      := region;
    var pre_size := load( "tj_" + collName + "_size1");    
    var desc     := scj_desc( pre_size, ctx, collHeight, count(pre_size) );
    var result   := nodes( desc ).project( dbl(scoreBase) );
    
    if ( trace ) tj_trace( "END  contained_by_1" );
    return result;
}


#####################################
# left CONTAINING right:
#
#   +--------------------+
#   |       left         |
#   | +---------------+  |
#   | |      right    |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it contains a region in right
#
#####################################
PROC containing(bat[oid,dbl] left, bat[oid,dbl] right) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN containing_2" );
    
    # Check for the virtual root
    if ( not( bat("tj_"+collName+"_size1").exist(0@0) ) ) {
        # Exceptions for root in argument. The case 
        # of region sets containing the root is not handled
        if ( count( left ) = 1 )
            if ( left.reverse().fetch(0) = virtRoot )
                return right;
    
        if ( count( right ) = 1 )
            if ( right.reverse().fetch(0) = virtRoot )
                return new(oid,dbl);
    }
        
    var anc_desc := anc_desc( left, right );

    # Attach the scores to the resulting nodes again:
    var result := anc_desc.mirror().kunique().join(left);
    
    if ( trace ) tj_trace( "END   containing_2" );
    return result;
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################


PROC p_containing_q_NLLR_batloop_anc(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_NLLR_batloop_anc" );
     var terms := Qterms_to_void_tid( Qterms );
     if (terms.count() = 0) {return new(oid,dbl);}
     var t1 := time();
     var tind := bat("tj_" + collName + "_TermIndex");
     var pres := bat("tj_" + collName + "_Terms");
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := pres.count();
     _lmbd :*= collFrq; 

     var t2 := time();
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var t5 := time();
	  var oid_min := int(tind.fetch($t));
	  var oid_max := int(tind.fetch(int($t) + 1)) - 1;
	  var tid_pre := pres.slice(oid_min, oid_max);
          var tmp_pre := tid_pre.tsort().tmark(0@0); 
	  tid_pre := nil;
	  var fac := tmp_pre.count();
	  if (fac > 0)
	  {
	       fac := _lmbd / fac;
               
               var elem_termpre := ll_ancestor(tmp_pre, tmp_pre, bat("tj_" + collName + "_size1"), collHeight).reverse(); 
               tmp_pre := nil;
               elem_termpre := elem_termpre.semijoin(left);
               var elem_frq := bat("tj_" + collName + "_size1").semijoin(elem_termpre);
	       
	       var tmp := elem_termpre.reverse().histogram();
               elem_termpre := nil;
	       tmp := [dbl](tmp);
	       tmp := [/](tmp, elem_frq);
	       tmp := [*](tmp, fac);
	       tmp := [+](tmp, 1);
	       tmp := [log](tmp);
	       var t8 := time();
	       doc_prob.insert(tmp);
	       var t9 := time();
         if (DEBUG) {
            printf("inside loop: ll_desc (%d), insert (%d), total (%d)\n", t7 - t6, t9 - t8, t9 - t5);
            fflush(stdout());
         }
	       
          }
     }
     var t3 := time();
     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), left.mark(0@0));
     res := res.[/](terms.count()).[+](left);
     var t4 := time();
     
     if (DEBUG) {
        printf("p_containing_q: loop (%d), total (%d)\n", t3 - t2, t4 - t1);
        fflush(stdout());
     }
     
     if ( trace ) tj_trace( "END  p_containing_q_NLLR_batloop_anc" );
     return res;
}

PROC p_containing_q_NLLR_batloop(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_NLLR_batloop" );
     var terms := Qterms_to_void_tid( Qterms );
     if (terms.count() = 0) {return new(oid,dbl);}
     var t1 := time();
     var tind := bat("tj_" + collName + "_TermIndex");
     var pres := bat("tj_" + collName + "_Terms");
     var elem_frq := bat("tj_" + collName + "_size1").semijoin(left);
     var elems := left.hmark(0@0);
     var iter := elems.mirror();
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := pres.count();
     _lmbd :*= collFrq; 

     var t2 := time();
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var t5 := time();
	  var oid_min := int(tind.fetch($t));
	  var oid_max := int(tind.fetch(int($t) + 1)) - 1;
	  var tid_pre := pres.slice(oid_min, oid_max);
          var cands := tid_pre.reverse().sort().mark(0@0).reverse();
	  var fac := tid_pre.count();
	  if (fac > 0)
	  {
	       fac := _lmbd / fac;
	       var t6 := time();
               if (DEBUG) {
                    printf("ll_desc: #loops/items: %d, #cands: %d, #pre_size: %d\n", elems.count(), cands.count(), bat("tj_" + collName + "_size1").count());
                    fflush(stdout());
               }
	       var elem_termpre := ll_descendant(iter, 
     						 elems, 
						 bat("tj_" + collName + "_size1"), 
						 cands, 
						 false, false, min(iter), max(iter), false, chr(nil));
               var t7 := time();
	       cands := nil;
	       tid_pre := nil;
     	       elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
	       var tmp := elem_termpre.reverse().histogram();
               elem_termpre := nil;
	       tmp := [dbl](tmp);
	       tmp := [/](tmp, elem_frq);
	       tmp := [*](tmp, fac);
	       tmp := [+](tmp, 1);
	       tmp := [log](tmp);
	       var t8 := time();
	       doc_prob.insert(tmp);
	       var t9 := time();
           if (DEBUG) {
               printf("inside loop: ll_desc (%d), insert (%d), total (%d)\n", t7 - t6, t9 - t8, t9 - t5);
               fflush(stdout());
	       }
          }
     }
     var t3 := time();
     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), elems.reverse());
     res := res.[/](terms.count()).[+](left);
     var t4 := time();
     
     if (DEBUG) {
        printf("p_containing_q: loop (%d), total (%d)\n", t3 - t2, t4 - t1);
        fflush(stdout());
     }
     if ( trace ) tj_trace( "END   p_containing_q_NLLR_batloop" );
     return res;
}

PROC _containing_desc(bat[oid,void] left, bat[oid,oid] tid_pre) : bat[oid,oid] :=
{
    if ( trace ) tj_trace( "BEGIN _containing_desc" );    
     var elems := left.hmark(0@0);
     var cands := tid_pre.tmark(0@0);
     var iter := elems.mirror();
     var elem_termpre := ll_descendant(	iter, 
     					elems, 
					bat("tj_" + collName + "_size1"), 
					cands, 
					false, false, min(iter), max(iter), false, chr(nil));
     elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
     var elem_tid := elem_termpre.join(tid_pre.reverse());
     elem_termpre := nil;
     if ( trace ) tj_trace( "END   _containing_desc" );    
     return elem_tid;
}

PROC _containing_desc2(bat[oid,void] left, bat[oid,oid] tid_pre) : bat[oid,oid] :=
{
    if ( trace ) tj_trace( "BEGIN _containing_desc2" );    
     var elems := left.hmark(0@0);
     var cands := tid_pre.tmark(0@0);
     var iter := elems.mirror();
     var elem_termpre := ll_descendant2(iter, 
     					elems, 
					bat("tj_" + collName + "_size1"), 
					cands, 
					false, false, min(iter), max(iter), false, chr(nil));
     var elem_tid := elem_termpre.join(tid_pre.reverse());
     elem_termpre := nil;
     if ( trace ) tj_trace( "END   _containing_desc" );    
     return elem_tid;
}

PROC _containing_anc(bat[oid,void] left, bat[oid,oid] tid_pre) : bat[oid,oid] :=
{
    if ( trace ) tj_trace( "BEGIN _containing_anc" );    
     var tmp_pre := tid_pre.tmark(0@0);
     var elems := ll_ancestor(tmp_pre, 
                              tmp_pre, 
                              bat("tj_" + collName + "_size1"), 
                              collHeight).reverse(); 
     tmp_pre := nil;
     elems := elems.semijoin(left);
     var elem_tid := elems.join(tid_pre.reverse());
     var elems := nil;
     
     print( "END   _containing_anc" );
     return elem_tid;
}

PROC collTermCount(str col, bat[void,oid] terms) : bat[oid,int] :=
{
     var tids := terms.reverse().mirror();
     var offsets1 := tids.leftfetchjoin(bat("tj_" + col + "_TermIndex"));
     tids := tids.[int]().[+](1).[oid]();
     var offsets2 := tids.leftfetchjoin(bat("tj_" + col + "_TermIndex"));
     var res := [-](offsets2.[int](),offsets1.[int]()).select(1,int(nil));
     return res;
}


# NEW fragment code
PROC p_containing_q_NLLR_frag(bat[oid,bat] left, bat[void,str] Qterms, flt lmbd) : bat[oid,bat] :=
{
    var res        := new(oid,bat);

    left@batloop() {
      res.insert($h, $t.p_containing_q_NLLR(Qterms,lmbd) );
    }
    return res;
}

PROC p_containing_q_NLLR(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_NLLR" );
    var t1 := time();
    
     # fetch term occurrences and drop all terms with zero frq in col or background-col
     var terms := Qterms_to_void_tid( Qterms );
     var tid_frq := collTermCount(background_collName, terms);
     terms := terms.reverse().semijoin(tid_frq).hmark(0@0);
     if (terms.count() = 0) {return new(oid,dbl);}
     
     var tid_pre := indexfetchjoin(terms, 
                                   bat("tj_" + collName + "_TermIndex"), 
                                   bat("tj_" + collName + "_Terms") );
     if (tid_pre.count() = 0) {return new(oid,dbl);}
     tid_pre := tid_pre.tsort();
     
     # compute constant factor in score computation
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := bat("tj_" + background_collName + "_Terms").count();
     _lmbd :*= collFrq;

     # compute collection terms frequencies 
     var _tid_frq := [/](_lmbd, tid_frq);
     tid_frq := nil;

     # get evaluate doc/term (anc/desc) relationship
     # including rule-of-thumb optimization
     var elem_tid;
     var t2 := time();
     #if ((tid_pre.count() * 50000) > collFrq)
          elem_tid := _containing_desc(left.mark(0@0), tid_pre);
     #else
     #     elem_tid := _containing_anc(left.mark(0@0), tid_pre);
     var t3 := time();
     tid_pre := nil;
    
     # if matches found in any node, return empty set
     if (elem_tid.count() = 0)
     {
          return new(oid,dbl);
     }
    
     # compute document sizes
     var elem_size := bat("tj_" + collName + "_size1").semijoin(elem_tid);

     # compute scores in batloop over terms
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var tmp := elem_tid.select($t);
	  var fac := _tid_frq.find($t);
	  tmp := tmp.reverse().histogram();
	  tmp := [dbl](tmp);
	  tmp := [/](tmp, elem_size);
	  tmp := [*](tmp, fac);
	  tmp := [+](tmp, 1);
	  tmp := [log](tmp);
	  doc_prob.insert(tmp);
     }
    
    var elements := left.mark(0@0);
    
    if ( not( returnAllElements ) ) 
        elements := elements.semijoin(elem_tid);
     
     # aggregate doc scores
     var res := {sum}(doc_prob.tmark(0@0), doc_prob.hmark(0@0), elements);
     
     res := res.[/](terms.count());
     # Obey scoreBase setting: 
     if ( scoreBase = 0 ) {
        res := [+](left, res);
     } else {
        res := [*](left, res);
     }
     if ( trace ) tj_trace( "END   p_containing_q_NLLR" );
     var t4 := time();
     # printf("total time: %d, containmentjoin: %d, score computation: %d\n", t4 - t1, t3 - t2, t4 - t3);
     return res;
}

PROC p_containing_q_NLLR2(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_NLLR" );
    var t1 := time();
    
     # fetch term occurrences and drop all terms with zero frq in col or background-col
     var terms := Qterms_to_void_tid( Qterms );
     var tid_frq := collTermCount(background_collName, terms);
     terms := terms.reverse().semijoin(tid_frq).hmark(0@0);
     if (terms.count() = 0) {return new(oid,dbl);}
     
     var tid_pre := indexfetchjoin(terms, 
                                   bat("tj_" + collName + "_TermIndex"), 
                                   bat("tj_" + collName + "_Terms") );
     if (tid_pre.count() = 0) {return new(oid,dbl);}
     tid_pre := tid_pre.tsort();
     
     # compute constant factor in score computation
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := bat("tj_" + background_collName + "_Terms").count();
     _lmbd :*= collFrq;

     # compute collection terms frequencies 
     var _tid_frq := [/](_lmbd, tid_frq);
     tid_frq := nil;

     # get evaluate doc/term (anc/desc) relationship
     # including rule-of-thumb optimization
     var elem_tid;
     var t2 := time();
     #if ((tid_pre.count() * 50000) > collFrq)
          elem_tid := _containing_desc2(left.mark(0@0), tid_pre);
     #else
     #     elem_tid := _containing_anc(left.mark(0@0), tid_pre);
     var t3 := time();
     tid_pre := nil;
    
     # if matches found in any node, return empty set
     if (elem_tid.count() = 0)
     {
          return new(oid,dbl);
     }
    
     # compute document sizes
     var elem_size := bat("tj_" + collName + "_size1").semijoin(elem_tid);

     # compute scores in batloop over terms
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var tmp := elem_tid.select($t);
	  var fac := _tid_frq.find($t);
	  tmp := tmp.reverse().histogram();
	  tmp := [dbl](tmp);
	  tmp := [/](tmp, elem_size);
	  tmp := [*](tmp, fac);
	  tmp := [+](tmp, 1);
	  tmp := [log](tmp);
	  doc_prob.insert(tmp);
     }
    
    var elements := left.mark(0@0);
    
    if ( not( returnAllElements ) ) 
        elements := elements.semijoin(elem_tid);
     
     # aggregate doc scores
     var res := {sum}(doc_prob.tmark(0@0), doc_prob.hmark(0@0), elements);
     
     res := res.[/](terms.count());
     # Obey scoreBase setting: 
     if ( scoreBase = 0 ) {
        res := [+](left, res);
     } else {
        res := [*](left, res);
     }
     if ( trace ) tj_trace( "END   p_containing_q_NLLR" );
     var t4 := time();
     printf("total time: %d, containmentjoin: %d, score computation: %d\n", t4 - t1, t3 - t2, t4 - t3);
     return res;
}

##
# Implementation of the Language Modeling retrieval model, with smoothing.
#
# This function is meant for term-at-a-time score computation (ASPECT algebra), e.g.:
#
# var R1 := select_node("article");
# var R2 := select_term("information");
# var R3 := p_containing_t_LMs(R1, R2, 0.5, SIZE_TERM);
#
# R3 now contains all regions in R1, however with scores attached according
# to the occurrence of the term "information" (R2)
#
#
# This function implements the following formula:
#                         tc(tm_i, doc)                  tc(tm_i,col)
#  S(doc|tm_i) = lambda * ------------- + (1 - lambda) * ------------
#                           len(doc)                       len(col)
#
#  tm_i         : query term
#  doc          : document or, in this case, region
#  tc(tm_i, doc): term count of query term tm_i in doc
#  len(doc)     : size of doc (term or element size)
##
PROC p_containing_t_LMs(bat[oid,dbl] left, bat[oid,dbl] right, flt lmbd, int size_type) : bat[oid,dbl] := 
{
    if ( trace ) tj_trace( "BEGIN p_containing_t_LMs_ASPECT" );
    
    var lambda;
    var m_lambda;
    var forgnd_prob := new(oid,dbl,ENTITY_NUM);
    var bckgnd_prob;

    var res_reg := new(oid,dbl,ENTITY_NUM);

    # Compute the foreground probability: how many regions from right does left contain?
    # This count is divided by the region size by reg_freq
    # 
    # This constitutes P(t|D), or tc(tm,doc)/len(doc)
    forgnd_prob := reg_freq(left,right,size_type);

    # Compute the background probability: how often does the query term occur in the collection
    # In this case, we know that count(right) = tc(tm,col)
    #
    # This constitutes P(t|C), or tc(tm,col)/len(col)
    if (size_type = SIZE_ENTITY) {
        # Compute right size / collection entity size
        
        var pre_pfpre := bat("tj_" + collName + "_pfpre");
        bckgnd_prob := dbl(count(right))/dbl(count(pre_pfpre));

        pre_pfpre := nil;
    } else if (size_type = SIZE_TERM) {
        # Compute right size / collection term size
        
        var pre_tid  := bat("tj_" + collName + "_tid1");
        var pre_pfpre := bat("tj_" + collName + "_pfpre");
        var terms := pre_tid.mirror().kdiff( pre_pfpre.mirror() );

        bckgnd_prob := dbl(count(right))/dbl(count(terms));
        
        var pre_tid := nil;
        var pre_pfpre := nil;
        var terms := nil;
    }

    if (bckgnd_prob = dbl(0)) {
        if (DEBUG) printf( "Minimum collection frequency has not been computed yet!\n" );
        # Assign minimum collection frequency
        
        bckgnd_prob := min(col_freq());
    }

    # Precompute lambda values
    lambda := dbl(lmbd);
    m_lambda := dbl(1)-lambda;

    if (scoreBase = 0)
        res_reg := [+](left, [+]([*](lambda,forgnd_prob),*(m_lambda,bckgnd_prob)));
    else if (scoreBase = 1)
        res_reg := [*](left, [+]([*](lambda,forgnd_prob),*(m_lambda,bckgnd_prob)));
    
    
    
    if ( trace ) tj_trace( "END   p_containing_t_LMs_ASPECT" );
    return res_reg;
}

##
# Implementation of the Language Modeling retrieval model.
#
# This function is meant for set-based score computation (COARSE2 algebra), e.g.:
#
# var R1 := select_node("article");
# var terms := new(void,str).seqbase(oid(0));
# var modifiers := new(void,int).seqbase(oid(0));
# terms.append("information");
# terms.append("retrieval");
# var R2 := p_containing_t_LMs(R1, terms, modifiers, 0.5, 1, SIZE_TERM);
#
# R2 now contains all regions in R1, however with scores attached according
# to the occurrence of the terms "information" and "retrieval"
#
#
# The score value for a single term and document is defined as follows:
#                                                  
#  S(doc|tm) = lambda * FG(tm) + (1 - lambda) * BG(tm)
#
# where 
#            tc(tm,doc)
#  FG(tm) = ------------       (foreground statistics)
#             len(doc)
#
#            tc(tm,col)
#  BG(tm) = ------------       (background statistics)
#             len(col)
#
# To compute score values for a set of terms at once, this function implements 
# presence weighting (thanks to Thijs for pointing this out), using the following 
# formula:
#
#            /    ___       lambda * FG(tm_i)         \        ___     
# S(doc|q) = |    | |     ----------------------  + 1 |  *     | |    (1 - lambda) * BG(tm_i)
#            \ tm_i in q  (1 - lambda) * BG(tm_i)     /     tm_i in q  
#
# where:                                                   
#  q            : query: set of query terms
#  tm_i         : query term
#  doc          : search document or, in this case, context region
#  tc(tm_i, doc): term count of query term tm_i in doc
#  len(doc)     : size of doc (term or element size)
##
PROC p_containing_q_LMs(bat[oid,dbl] ctx, bat[void,str] Qterms, bat modifiers, flt lambda, int stemming, int size_type) : bat[oid,dbl]
{   
    if ( trace ) tj_trace( "BEGIN p_containing_t_LMs_COARSE" );
    # To follow the naming in the formula above, context regions are named "documents".
    # For each term we need:
    #  - foreground probability (first term). This depends on the context region
    #  - background probability (second term). This is the same for every context region
    
    # Convert the query terms from [void,str] to [void,tid]
    var terms := Qterms_to_void_tid( Qterms );

    ### Background probability:
    # For each term: collection term frequency tc(tm_i, col):
    #var col_term_frq := tid_pre.reverse().histogram();
    var col_term_frq := collTermCount(background_collName, terms);

    # Collection size len(col): int
    var col_len := bat("tj_" + background_collName + "_Terms").count();

    # Take only the terms that occur in the collection
    terms := terms.reverse().semijoin(col_term_frq).hmark(0@0);

    if (terms.count() = 0) { return new(oid,dbl); }
    
    ###
    
    ### Foreground probability: 
    # Find out the document positions of the terms for foreground probability
    var tid_pre := indexfetchjoin(terms, 
                                   bat("tj_" + collName + "_TermIndex"), 
                                   bat("tj_" + collName + "_Terms") );
    
    if (tid_pre.count() = 0) { return new(oid,dbl); }
    tid_pre := tid_pre.tsort();
    
    # See which document contain the query terms we create a bat of [doc, term-id]:
    var doc_tid := _containing_desc(ctx.mark(0@0), tid_pre);
    
    # len(doc): [doc, size]
    var doc_len := [dbl](bat("tj_" + collName + "_size1").semijoin(doc_tid));
    
    ###
    
    # Now, we need to compute the probability for each document->term pair
    var doc_termscore   := new(oid,dbl);
    var prod_background := dbl(1);
    
    # Iterate over all terms.
    terms@batloop() {
        # Compute the first factor
        # $t contains the term id 
        var occurrences := doc_tid.select($t).sort();
        
        # Count the occurrence of the term in all documents: tc(tm_i, doc), 
        # for all documents at once
        var tc_tm_doc  := [dbl](occurrences.reverse().histogram());
        var foreground := [/](tc_tm_doc, doc_len);

        # Compute the background probability: tc(tm_i,col)/len(col)
        var tc_tm_col  := col_term_frq.find($t); 
        var background := dbl(tc_tm_col) / dbl(col_len);
        
        # Compute the first factor. This generates a [doc, term score] table for
        # each combination of doc and term
        var total := [+]( [/]( [*](lambda, foreground), (1.0 - lambda) * background), dbl(1) );
        doc_termscore.insert( [dbl](total) );
        
        # Compute the second factor: product of background statistics over all terms
        prod_background := prod_background * background;
    }
    
    # We now have a table that lists [doc, term score] pairs. These need to be aggregated
    # into [doc, score] pairs: (this is the first aggregate product in the formula)
    #var res := {prod}(doc_termscore, ctx.mark(oid(0)));
    
    var elements := ctx.mark(0@0);
    
    if ( not( returnAllElements ) ) 
        elements := elements.semijoin(doc_tid);
        
    var res := {prod}(doc_termscore.tmark(0@0), doc_termscore.hmark(0@0), elements );
    
    # Now compute the final scores: multiply by the background score
    res := [*](res, (1.0 - lambda) * prod_background);

    if ( scoreBase = 0 ) {
        # Add the scores to the context set (this should have scores 0, so adding is OK)
        res := [+](ctx, res);
    } else {
        # Add the scores to the context set (this should have scores 1, so multiplying is OK)
        res := [*](ctx, res);
    }
    if ( trace ) tj_trace( "END   p_containing_t_LMs_COARSE" );
    return res;
}

##
# Returns the collection frequency table (should be precomputed, but is calculated for now)
##
PROC col_freq() : bat[oid,dbl] :=
{
    var start_time := time();
    var allterms := bat("tj_globalTerms").sort().mark(0@0).reverse();
    var alltermpos := indexfetchjoin(allterms, bat("tj_"+collName+"_TermIndex"), bat("tj_"+collName+"_Terms"));
    var col_freqs := [dbl]({count}(alltermpos));

    if (DEBUG) printf( "col_freq: \t\t%d ms\n", time() - start_time );
    return col_freqs;
}

##
# Returns the collection frequency of the term with the indicated tid
##
PROC col_freq(oid tid) : dbl :=
{
    var start_time := time();
    var alltermpos := indexfetchjoin(new(int,oid).insert(0,tid), bat("tj_"+collName+"_TermIndex"), bat("tj_"+collName+"_Terms"));
    var col_freqs := {count}(alltermpos);
    var result := dbl(col_freqs.fetch(0));
    if (DEBUG) printf( "col_freq: \t\t%d ms\n", time() - start_time );
    return result;
}

##
# For each region in left, count the number of regions in right it contains.
##
PROC reg_freq(bat[oid,dbl] left, bat[oid,dbl] right, int size_type) : bat[oid,dbl]    :=    
{
    var start_time := time();
    
    var reg_size;
    
    var ctx_tmp2 := new( oid, int, ENTITY_NUM );
   
    ctx_tmp2 := anc_desc( left, right );
    
    # Containment count: for each region from left, count how many regions from right it contains
    var num_terms := {count}(ctx_tmp2);
    var prob_tmp  := [dbl](num_terms);
    
    # Region size: Determine the entity or term size of all regions from left that have descendants in right
    if (size_type = SIZE_ENTITY)
        reg_size := size_entity(prob_tmp);
    else if (size_type = SIZE_TERM)
        reg_size := size_term(prob_tmp);
    
    # prob_tmp := [/](prob_tmp,prob_tmp.mirror().join(reg_size));

    # Divide the containment count (left) by the region size (left)
    prob_tmp := [/](prob_tmp,reg_size);

    # Set all to zero regions from left that do not contain regions from right
	prob_tmp := prob_tmp.kunion( left.project(dbl(0)) );

    var end_time := time();
    if (DEBUG) printf( "reg_freq: \t\t%d ms\n", end_time - start_time );
    return prob_tmp;
}


# Calculate the term size of the region: how many terms does it contain?
PROC size_term( bat[oid,any] region ) : bat[oid,dbl] := 
{
    if ( trace ) tj_trace( "BEGIN size_term" );
    # For now, we use size_term = size_entity
    if ( trace ) tj_trace( "END   size_term" );
    return size_entity( region );
    var start_time := time();
    
    # all terms:
    var pre_tid   := bat("tj_" + collName + "_tid1");
    var pre_pfpre := bat("tj_" + collName + "_pfpre");
    var terms     := pre_tid.mirror().kdiff( pre_pfpre.mirror() );
    
    var items      := region.mirror().mark(0@0).reverse();
    var candidates := terms.mirror().mark(0@0).reverse();
    
    # Alternative:
    #var candidates      := bat("tj_" + collName + "_Terms" ).reverse().sort().mark(0@0).reverse();
    
    var pre_size := load( "tj_" + collName + "_size1");
   
    # Check the order of the items:
    items.chk_order();
    
    var res := ll_descendant(items, items, pre_size, candidates, false, false, min(items), max(items), false, chr(nil));
    
    var result := [dbl]({count}(res));
   
    var end_time := time();
    if (DEBUG) printf( "size_term: \t\t%d ms\n", end_time - start_time );
    if ( trace ) tj_trace( "END   size_term" );
    return result;
}

# Calculate the entity size of the region: how many entities (tags and terms) does it contain?
PROC size_entity( bat[oid,any] region ) : bat[oid,dbl] :=
{
    var start_time := time();
    
    
    # Entity sizes:
    var pre_size := load( "tj_" + collName + "_size1");
    
    var result := [dbl](region.mirror().join( pre_size ));

    var end_time := time();
    if (DEBUG) printf( "size_entity: \t\t%d ms\n", end_time - start_time );
    return result;
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

PROC p_contained_by_sum(bat[oid,dbl] region) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_contained_by_sum_1" );
    # Candidates: all nodes
    var candidates := select_node();

    var ctx_res := anc_desc( region, candidates );

    var ctx := ctx_res.reverse().mirror();

    var reg_size := [dbl](size_term(ctx));

    reg_size:= reg_size.select(dbl(0),dbl(nil),false,true);

    ctx := reg_size.mirror();

    # calculating the score for each region
    var reg_score := {sum}(ctx_res.reverse().join(region));

    var res_reg := ctx.join(reg_score);
    
    if ( trace ) tj_trace( "END   p_contained_by_sum_1" );
    return res_reg;
}


PROC p_contained_by_sum(bat[oid,dbl] left, bat[oid,dbl] right) : bat[oid,dbl] := 
{
    if ( trace ) tj_trace( "BEGIN p_contained_by_sum_2" );
    var ctx_res := anc_desc( right, left );
    
    var reg_score;
    var res_reg;
    #var ctx := left.project(dbl(0));

    # calculating the score for each region
    reg_score := {sum}(ctx_res.reverse().join(right));
    #reg_score := kunion(reg_score, ctx);

	if (scoreBase = 0)
		res_reg := [+](reg_score, left);
	else if (scoreBase = 1)
		res_reg := [*](left, reg_score);
    
    if ( trace ) tj_trace( "END   p_contained_by_sum_2" );
	return res_reg;
}


PROC p_containing_wsumd(bat[oid,dbl] left, bat[oid,dbl] right, int size_type) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_wsumd" );
    var ctx := left.project(dbl(0));
    var size_reg;
    var reg_score;
    var norm_reg;
    var res_reg;
    
    if (size_type = SIZE_ENTITY) {
        size_reg := size_entity(right);
    }
    else if (size_type = SIZE_TERM) {
        size_reg := size_term(right);
    }

    # Call the descendant algorithm: it returns [ancestor, descendant] pairs!
    var ctx_res := anc_desc( left, right );

    # calculating the score for each region
    # ERROR LINE BATkey must be dense
    reg_score := {sum}(ctx_res.join([*](size_reg,right)).sort());
    norm_reg := [dbl]({sum}(ctx_res.join(size_reg).sort()));

    # Select all values > 0
    norm_reg := norm_reg.select(dbl(0),dbl(nil),false,true);

    reg_score := norm_reg.mirror().join(reg_score);

    reg_score := [/](reg_score,norm_reg);

    reg_score := kunion(reg_score,ctx);

    if (scoreBase = 0)
        res_reg := [+](left, reg_score);
    else if (scoreBase = 1)
        res_reg := [*](left, reg_score);

    if ( trace ) tj_trace( "END   p_containing_wsumd" );
    return res_reg;
}

################################################################################
# SET OPERATORS
################################################################################

### UNION
PROC union(bat left, bat right) : bat :=
{

	return left.kunion(right).sort();

}

### INTERSECTION
PROC intersect(bat left, bat right) : bat := 
{

	return left.kintersect(right).sort();

}


################################################################################
# SCALING
################################################################################

PROC scale(bat region, flt importance) : bat := 
{

	var res_reg := new(oid,dbl,ENTITY_NUM);
	res_reg := [*](dbl(importance),region);
	return res_reg;

}


################################################################################
# PROBABILISTIC SET OPERATORS
################################################################################

PROC or_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC or_max(bat left, bat right) : bat :=
{

	return [max](left,right);

}

PROC or_prob(bat left, bat right) : bat :=
{

	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

}

PROC or_exp(bat left, bat right, int A) : bat := 
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC or_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC or_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC and_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC and_exp(bat left, bat right, int A) : bat :=
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC and_max(bat left, bat right) : bat :=
{

	return [max](left,right);

}

PROC and_prob(bat left, bat right) : bat :=
{

	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

}

################################################################################
# VALUE SELECTION
################################################################################

PROC near_val(bat region, int command, str value) : bat :=
{
    print( "Sorry, near_val is not yet supported" );
    return region;

    var r_value;
    var reg_res := new(oid,dbl,ENTITY_NUM);
    var reg_tmp := new(oid,oid,ENTITY_NUM);

    var entity_pre := new(oid,oid,WORD_NUM);
    entity_pre := load(col_name+"entity_pre");

    # region:               [region-id, score]
    # region.mirror():      [region-id, region-id]
    # entity_pre:           [region-id, region pre-id]
    # reg_tmp:              [region-id, region pre-id]
    reg_tmp := region.mirror().join(entity_pre);

    entity_pre := nil;

    r_value := int(value);

    if (command = GREATER)
        reg_tmp := gt(reg_tmp, r_value);
    else if (command = LESS)
        reg_tmp := lt(reg_tmp, r_value);
    else if (command = EQUAL)
        reg_tmp := eq(reg_tmp, r_value);
    else if (command = GEQ)
        reg_tmp := gte(reg_tmp, r_value);
    else if (command = LEQ)
        reg_tmp := lte(reg_tmp, r_value);

    reg_res := reg_tmp.mirror().join(region);

    return reg_res;
}
#ADDHELP("near_val", "vojkan", "March 16, 2005",
#"Selects regions that satisfy the inequality (integer) test.",
#"TIJAH");

########################################################################################################
# Procudures for executing value comparison:
#       - eq            selects the regions with equal text content
#       - lt            selects the regions with less than text content
#       - gt            selects the regions with greater then text content
#       - lte           selects the regions with less than or equal text content
#       - gte           selects the regions with greater than or equal text content
#########################################################################################################

PROC gt(bat ctx, int comp) : bat :=
{

        var entity_pre := new(oid,oid,ENTITY_NUM);
        entity_pre := load(col_name+"entity_pre");
        var entity_type := new(oid,oid,ENTITY_NUM);
        entity_type := load(col_name+"entity_type");

        var word_pre := new(oid,oid,ENTITY_NUM);
        word_pre := load(col_name+"word_pre");
        var word_name := new(oid,oid,ENTITY_NUM);
        word_name := load(col_name+"word_name");
        var enum_word := new(str,int,ENTITY_NUM);
        enum_word := load(col_name+"enum_word");

        var cur_tmp := new(oid,oid,ENTITY_NUM);
        var ctx_tmp := new(oid,oid,TERM_NUM);
        var ctx_reg := new(oid,oid,ENTITY_NUM);

        cur_tmp:= ctx.child().mirror().join(entity_type).uselect('t').mirror().join(entity_pre);

        entity_type := nil;

        ctx_reg := [int]([str](word_pre.join(cur_tmp.reverse()).mirror().join(word_name).join(enum_word.reverse())));

        word_name := nil;
        enum_word := nil;

        var low := comp + 1;
        ctx_tmp := ctx_reg.select(comp,int(nil),false,false).mirror().join(word_pre);
        cur_tmp := entity_pre.join(ctx_tmp.reverse().mirror()).parent().mirror().join(ctx);

        word_pre := nil;
        entity_pre := nil;

        ctx := cur_tmp;

        return ctx;

}
#ADDHELP("gt", "vojkan", "Nov 14, 2003",
#"Performing greater than comparison between element content and integer.",
#"TIJAH");



################################################################################
# PRIOR
################################################################################

PROC prior_ls(bat region, int size_type) : bat := 
{

	var ctx_size := new(oid,dbl,ENTITY_NUM);
	var res_reg := new(oid,dbl,ENTITY_NUM);

	if (size_type = SIZE_ENTITY) {
		ctx_size := size_entity(region);
        # Make sure sizes are not zero      
        ctx_size := [+](ctx_size, dbl(0.5));
	} else if (size_type = SIZE_TERM) {
		ctx_size := size_term(region);
        # Make sure sizes are not zero      
        ctx_size := [+](ctx_size, dbl(0.5));
    }      
    

	res_reg := [+]([log](region.select(dbl(0),dbl(nil),false,false)),[log](ctx_size));
	res_reg := [-](region.select(dbl(0)).project(min(res_reg)),dbl(1)).kunion(res_reg);

	# res_reg := [+]([log](region),[*](dbl(3.0),[log](ctx_size)));

	# var ref_reg := new(oid,dbl,ENTITY_NUM);
	# var ref_size := new(oid,dbl,ENTITY_NUM);

	# var entity_name := load(collName+"entity_name");

	# var ref_name := entity_name.join(region.mirror().join(entity_name).reverse().mirror());
	# ref_reg := ref_name.project(dbl(1));

	# if (size_type = SIZE_ENTITY) {
	#	ctx_size := size_entity(region);
	#	ref_size := size_entity(ref_reg);
	# }
	# else if (size_type = SIZE_TERM) {
	#	ctx_size := size_term(region);
	#	ref_size := size_term(ref_reg);
	# }

	# ref_size := region.mirror().join(entity_name).join({sum}(ref_size.reverse().join(ref_name).reverse()));

	# res_reg := [*](region,[/](ctx_size,ref_size));

	return res_reg;

}
#ADDHELP("prior_ls", "vojkan", "March 16, 2005",
#"Adds element prior based on element length to the region score.",
#"TIJAH");



################################################################################
# ORDER
################################################################################

PROC order_regions(bat region) : bat :=
{

	region := region.reverse().sort_rev().reverse();

	return region;

}
#ADDHELP("order_regions", "vojkan", "March 29, 2005",
#"Order regions in descending order based on their score values.",
#"TIJAH");



PROC tj_global_init() : void 
{
	if (DEBUG) printf("# Initializing Pathfinder-Tijah integration package.\n");
	new(oid,str).persists(true).bbpname("tj_globalTerms");
	new(oid,str).persists(true).bbpname("tj_globalTags");
	new(oid,str).persists(true).bbpname("tj_collName");
	commit();
}

##########################################
# Collection Management Functions
#
##########################################

PROC tj_coll_init(str collName, str stemmer) : void
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (bat("tj_collName").reverse().exist(collName)) {
		ERROR("tj_coll_init, pftijah collection already exists: %s\n",collName);
	}
	new(void,str).seqbase(0@0).persists(true).bbpname("tj_" + collName + "_doc_name");
	new(void,int).seqbase(0@0).persists(true).bbpname("tj_" + collName + "_doc_firstpre");
	new(str,str).persists(true).bbpname("tj_" + collName + "_param");

	new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_tid1");
	new(void,int).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_size1");
	# bat contains the start oid of every tid/size frag. Head is postfix
	# string to _tid/_size. Normally "", "2", "3"
	new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_fragments");
	bat("tj_" + collName + "_fragments").append(1@0);
	new(oid,oid).persists(true).bbpname("tj_" + collName + "_pfpre");
    
	var coll_oid;
	if (bat("tj_collName").count() = 0) { coll_oid := 0@0; }
     	else { coll_oid := oid(int(bat("tj_collName").reverse().max()) + 1); }
	bat("tj_collName").insert(coll_oid, collName);
	#
	# now set the parameters for this collection
	#
	bat("tj_" + collName + "_param").insert("_version","1.01");
	bat("tj_" + collName + "_param").insert("name",collName);
	bat("tj_" + collName + "_param").insert("height","0");
	if (stemmer = "") bat("tj_" + collName + "_param").insert("stemmer","nostemming");
	else bat("tj_" + collName + "_param").insert("stemmer",stemmer);
	bat("tj_" + collName + "_param").insert("preExpansion","4");
	bat("tj_" + collName + "_param").insert("status","building");
	bat("tj_" + collName + "_param").insert("_last_tijahPre","1");
	#
	commit();
}

PROC tj_global_remove() : void
{
	bat("tj_collName")@batloop(){
		tj_coll_remove($t);
	}
	bat("tj_globalTerms").persists(false);
	bat("tj_globalTags").persists(false);
	bat("tj_collName").persists(false);
	commit();
}

PROC tj_coll_remove() : void
{
	tj_coll_remove(collName);
}

PROC tj_set_parameter(str collName, str par, str val) : void
{
	var parbat := bat("tj_" + collName + "_param");

	if ( parbat.exist(par) ) {
	    parbat.replace(par,val);
	} else {
	    parbat.insert(par,val);
	}
}

PROC tj_coll_remove(str collName) : void
{
	bat("tj_" + collName + "_doc_name").persists(false);
	bat("tj_" + collName + "_doc_firstpre").persists(false);
	bat("tj_" + collName + "_param").persists(false);
	bat("tj_" + collName + "_pfpre").persists(false);
	bat("tj_" + collName + "_fragments")@batloop() {
	    var fpfx := str(int($h));
	    bat("tj_" + collName + "_tid"+fpfx).persists(false);
	    bat("tj_" + collName + "_size"+fpfx).persists(false);
	}
	bat("tj_" + collName + "_fragments").persists(false);
	if (view_bbp_name().reverse().exist("tj_" + collName + "_TermIndex")) {
		bat("tj_" + collName + "_TermIndex").persists(false);
		bat("tj_" + collName + "_Terms").persists(false);
		bat("tj_" + collName + "_TagIndex").persists(false);
		bat("tj_" + collName + "_Tags").persists(false);
	}
        
	var coll_oid := bat("tj_collName").reverse().find(collName);
	bat("tj_collName").delete(coll_oid);
	commit();
}

PROC tj_collection() : BAT[void,bat]
{
	return tj_collection(collName);
}

PROC tj_collection(str collName) : BAT[void,bat]
{
	var tjCollBat := new(void,bat).seqbase(0@0);

	var parbat := bat("tj_" + collName + "_param");
	var curversion;
	if ( parbat.exist("_version") ) {
	    curversion := parbat.find("_version");
	} else {
	    curversion := "0.0";
	}
	if ( curversion < "1.0" ) {
	     ERROR("tj_collection(): pftijah index structure changed, reindex collection!!");
	}
	tjCollBat.append(bat("tj_globalTerms"));
	tjCollBat.append(bat("tj_globalTags"));
	tjCollBat.append(bat("tj_" + collName + "_doc_name"));
	tjCollBat.append(bat("tj_" + collName + "_doc_firstpre"));
	tjCollBat.append(parbat);
	# only load the top [pre|term|size] fragments
	var fpfx := str(bat("tj_" + collName + "_fragments").count());
	tjCollBat.append(bat("tj_" + collName + "_tid"+fpfx));
	tjCollBat.append(bat("tj_" + collName + "_size"+fpfx));
	tjCollBat.append(bat("tj_" + collName + "_pfpre"));
	tjCollBat.append(bat("tj_" + collName + "_fragments"));
	return tjCollBat;
}

PROC tj_createCollection(str doc, str url, str stemmer) : BAT[void,bat]
{
	return tj_createCollection(collName, doc, url, stemmer);
}

PROC tj_createCollection(str collName, str doc, str url, str stemmer) : void
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(collName))) {
		tj_coll_init(stemmer);
	}
	
	tj_url2Collection(collName, doc, url, "");
	tj_finalize(collName);
}

PROC tj_url2Collection(str doc, str url, str selTagList) : void
{
	tj_url2Collection(collName, doc, url, selTagList);
}

PROC tj_url2Collection(str collName, str doc, str url, str selTagList) : void
{ 
        var debug := false;
	var ws := ws_create();
	if (not(bat("doc_name").reverse().exist(doc))) {
		shred_doc(url,doc);
	}
	ws_opendoc(ws, bat(void,str,1).append(doc));
        
	bat("tj_globalTerms").access(BAT_WRITE);
	bat("tj_globalTags").access(BAT_WRITE);
        
	var newfrags := tj_add2collection(tj_collection(collName),ws,doc,selTagList);
	if ( newfrags.count() > 0 ) {
	    # new fragment pre-term and pre-size() added
	    var fpfx := str(bat("tj_" + collName + "_fragments").count());
	    newfrags.fetch(0@0).persists(true).bbpname("tj_" + collName + "_tid"+fpfx);
	    newfrags.fetch(1@0).persists(true).bbpname("tj_" + collName + "_size"+fpfx);
	}
	ws_destroy(ws);
	# var height1 := bat("doc_height").fetch(bat("doc_name").reverse().find(doc));
	var height1 := 999; # REMOVE
        
        var coll_oid := bat("tj_collName").reverse().find(collName);
	var height2 := bat("tj_" + collName + "_param").find("height").int();
	bat("tj_" + collName + "_param").replace("height", max(height1,height2).str());
	bat("tj_" + collName + "_param").replace("status","building");
        commit();	
}

PROC tj_url2Collection_index(str collName, str url, str selTagList) : void
{
	bat("tj_globalTerms").access(BAT_WRITE);
	bat("tj_globalTags").access(BAT_WRITE);
        
	var newfrags := tj_add2collection_index(tj_collection(collName),url);
	if ( newfrags.count() > 0 ) {
	    # new fragment pre-term and pre-size() added
	    var fpfx := str(bat("tj_" + collName + "_fragments").count());
	    newfrags.fetch(0@0).persists(true).bbpname("tj_" + collName + "_tid"+fpfx);
	    newfrags.fetch(1@0).persists(true).bbpname("tj_" + collName + "_size"+fpfx);
	}

	bat("tj_" + collName + "_param").replace("status","building");
        commit();	
}

PROC tj_finalize() : void
{
	tj_finalize(collName);
}

PROC tj_finalize(str collName) : void
{
	# Finalize one collection. No documents should be added after this
	bat("tj_" + collName + "_tid1").access(BAT_READ);
	bat("tj_" + collName + "_size1").access(BAT_READ);
	bat("tj_" + collName + "_pfpre").access(BAT_READ);
	bat("tj_" + collName + "_fragments").access(BAT_READ);
	# incomplete, batloop here
	bat("tj_" + collName + "_tid1").mmap(1);
	bat("tj_" + collName + "_size1").mmap(1);
	bat("tj_" + collName + "_pfpre").mmap(1);
	commit();
	tj_buildIRindex(collName);
	#
	bat("tj_" + collName + "_param").replace("status","finalized");
	#
	var gterm_sort := bat("tj_globalTerms").reverse().sort().reverse();
	bat("tj_globalTerms").persists(false);
	var gtag_sort := bat("tj_globalTags").reverse().sort().reverse();
	bat("tj_globalTags").persists(false);
	commit();
	gterm_sort.persists(true);
	gterm_sort.bbpname("tj_globalTerms");
	gtag_sort.persists(true);
	gtag_sort.bbpname("tj_globalTags");
	if ( false ) {
	  # Monet error, server crashes on .acces(BAT_WRITE) when a new 
	  # collection is created on a fresh Mserver.
	  bat("tj_globalTerms").access(BAT_READ);
	  bat("tj_globalTags").access(BAT_READ);
	}
	bat("tj_globalTerms").mmap(1);
	if ( false ) {
	  # Monet error, server crashes on .acces(BAT_WRITE) when a new 
	  # collection is created on a fresh Mserver.
	  bat("tj_globalTags").mmap(1);
	}
	commit(); 
}

PROC tj_dump() : void
{
	tj_dump(collName);
}

PROC tj_dump(str collName) : void
{
	bat("tj_" + collName + "_param").print();
	bat("tj_" + collName + "_doc_name").print();
	bat("tj_" + collName + "_doc_firstpre").print();
	# print(bat("tj_" + collName + "_doc_name"),bat("tj_" + collName + "_doc_firstpre"));
	bat("tj_globalTerms").print();
	bat("tj_globalTags").print();
	print(bat("tj_" + collName + "_tid1"));
	print(bat("tj_" + collName + "_size1"));
	print(bat("tj_" + collName + "_pfpre"));
	print(bat("tj_" + collName + "_fragments"));
	# print(bat("tj_" + collName + "_height"));
}

# mil-code to build faster IR indices
PROC tj_buildIRindex() : void :=
{
	tj_buildIRindex(collName);
}

PROC tj_buildIRindex(str collName) : void :=
{
	if (view_bbp_name().reverse().exist("tj_" + collName + "_TermIndex")) {
		bat("tj_" + collName + "_TermIndex").persists(false);
		bat("tj_" + collName + "_Terms").persists(false);
		bat("tj_" + collName + "_TagIndex").persists(false);
		bat("tj_" + collName + "_Tags").persists(false);
		commit();
	}
	var tmp := bat("tj_" + collName + "_tid1").kdiff(bat("tj_" + collName + "_pfpre"));
        tmp := tmp.reverse().sort();
	var termindex := tmp.mark(0@0).reverse().offsetindex(bat("tj_globalTerms").count() + 1);
	var terms := tmp.reverse().mark(0@0).reverse();
	# create _TermIndex and _Terms here
	termindex.persists(true).bbpname("tj_" + collName + "_TermIndex");
	terms.persists(true).bbpname("tj_" + collName + "_Terms");
	tmp := nil;
	termindex.access(BAT_READ);
	termindex.mmap(1);
	terms.access(BAT_READ);
	terms.mmap(1);
	termindex := nil;
	terms := nil;
	commit();
	
	# incomplete, use fragmentation here, merge union ??
	tmp := bat("tj_" + collName + "_tid1").semijoin(bat("tj_" + collName + "_pfpre"));
        tmp := tmp.reverse().sort();
	var tagindex := tmp.mark(0@0).reverse().offsetindex(bat("tj_globalTags").count() + 1);
	var tags := tmp.reverse().mark(0@0).reverse();
	# create _Tags and _Tagindex here
	tagindex.persists(true).bbpname("tj_" + collName + "_TagIndex");
	tags.persists(true).bbpname("tj_" + collName + "_Tags");
	tmp := nil;
	tagindex.access(BAT_READ);
	#tagindex.mmap(1);
	tags.access(BAT_READ);
	tags.mmap(1);
	tagindex := nil;
	tags := nil;
	commit();
}

######################################
# PF interface functions
#
######################################

PROC tijah2pf(BAT[oid,dbl] pre_score) : BAT :=
{
	var docpre := bat("tj_" + collName + "_doc_firstpre").[oid]();
	var pfpre :=  bat("tj_" + collName + "_pfpre");
	
	var item := pre_score.hmark(0@0);
	var score := pre_score.tmark(0@0);
	var iter := item.mirror();
	var frag := [find_lower](const docpre.reverse().mark(0@0), item);
	item := item.join(pfpre).sort().tmark(0@0);
	
	var res := new(void,bat);
	res.append(iter);
	res.append(item);
	res.append(frag);
	res.append(score);
	return res;
}

# align_frag assumes the following variable to be global to its scope:
# frag, kind, ipik, ws
# StM: 
# Is this a dead PROC? 
# At least I could not find any place where it is called or referred to.
# If so, it should be removed from the code base!
PROC align_frag() : void :=
{
	var needed_docs := bat("tj_" + collName + "_doc_name").semijoin(frag.tunique());
	var loaded_docs := ws.fetch(DOC_LOADED).reverse();
	var docs_to_load := kdiff(needed_docs.reverse(),loaded_docs).hmark(0@0);
	ws_opendoc(ws, docs_to_load);
	var fid_pffid := needed_docs.join(ws.fetch(DOC_LOADED).reverse());
	frag := frag.join(fid_pffid).sort().tmark(0@0);
	kind := set_kind(frag, ELEM);
	ipik := iter;
}

@h

#define ENABLE_TDEBUG

#ifdef ENABLE_TDEBUG
extern int pftijah_debug;
#define SET_TDEBUG(V) pftijah_debug = V
#define TDEBUG(V) (pftijah_debug && (((V<=pftijah_debug)&&(pftijah_debug<100)) || ((V==pftijah_debug)&&(pftijah_debug>=100))) )
#else
#define SET_TDEBUG(V)
#define TDEBUG(V) 0
#endif

@c
#include <pf_config.h>

#include <monet.h>
#include <gdk.h>

#include <pathfinder.h>

#include "pftijah.h"

#ifdef ENABLE_TDEBUG
/* 
 * The main pftijah variable, settable from the command line by the
 * <TijahOptions debug=number ..... from the query env.
 * Current strategy is not to reset the debug variable after the query
 * finished and to make it a global for ease of use.
 * The number has three possiblilities:
 * 0             : no debug
 * 1   - 99      : leveled debug
 * 100 - INT_MAX : debug a specific event 
 *
 * usage: if (TDEBUG ) expression
 */
int pftijah_debug = 0;
#endif

int executeMIL(char* str) {
    return monet_exec(str);
}

int CMDtijah_command(bit* res, str command) {
	if ( 0 ) stream_printf(GDKout,"# tijah_command(%s)\n",(char*)command);
	*res = executeMIL(command); /* OK */
	return GDK_SUCCEED;
}

extern char* tijahParse(BAT* optbat, char* startNodes_name, char* query, char** errBUFF);

static int nexiTmpCounter = 0;

int CMDtijah_query(BAT** res, BAT* optbat, BAT* startNodes, str query) {
	char* err;
	char* mil;
	char  nameBUFF[32], *startNodes_name;
	int   use_startNodes;

	if (TDEBUG(1)) stream_printf(GDKout,"# CMDtijah_query: start, query=\"%s\".\n",query);
	use_startNodes = BATcount(optbat); /* INCOMPLETE, redesign this */
	if ( use_startNodes ) {
	    BATmode(startNodes,PERSISTENT);
	    sprintf(&nameBUFF[0],"%s%d","nexi_start",nexiTmpCounter++);
	    /* make persistent, the generated script should undo this again */
	    if ( BBPrename(startNodes->batCacheid,(str)&nameBUFF[0]) != 0) {
                GDKerror("CMDtijah_query: fail to name startNode bat: \"%s\".\n", &nameBUFF[0]);
	        return GDK_FAIL;
	    }
	    startNodes_name = &nameBUFF[0];
	} else {
	    startNodes_name = NULL;
	}

	if ( !optbat ) {
            GDKerror("CMDtijah_query: missing option bat.\n");
	    return GDK_FAIL;
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: call tijahParse.\n");
	if ( !(mil=tijahParse(optbat,startNodes_name,query,&err)) ) {
            GDKerror("CMDtijah_query: %s.\n", err);
	    return GDK_FAIL;
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: finish tijahParse.\n");
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: start MIL script.\n");
	if (TDEBUG(9)) {
		stream_printf(GDKout,"# CMDtijah_query: generated MIL script:\n");
		stream_printf(GDKout,"%s",mil);
		stream_printf(GDKout,"# CMDtijah_query: end of MIL script:\n");
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: start executing MIL script.\n");
        if ( executeMIL(mil)<0 ) {
            GDKerror("CMDtijah_query: execute MIL failed.\n");
	    return GDK_FAIL;
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: finish MIL script.\n");
	BAT* scoreBAT = BATdescriptor( BBPindex("nexi_result") );

	if (TDEBUG(3)) stream_printf(GDKout,"# CMDtijah_query: sizeof scoreBAT = %d.\n",BATcount(scoreBAT));
	if (TDEBUG(9)) {
	    stream_printf(GDKout,"# CMDtijah_query: scoreBAT:\n");
	    BATprintf(GDKout,scoreBAT);
	}

	if ( ! scoreBAT ) {
            GDKerror("CMDtijah_query: fail to load score bat: \"%s\".\n", "nexi_result");
	    return GDK_FAIL;
        }
	sprintf(&nameBUFF[0],"%s_del%d","nexi_result",nexiTmpCounter++);
	if ( BATrename(scoreBAT,(str)&nameBUFF[0]) == str_nil ) {
            GDKerror("CMDtijah_query: fail to rename score bat: \"%s\".\n", &nameBUFF[0]);
	    return GDK_FAIL;
	}
	BATmode(scoreBAT,TRANSIENT);

	*res = scoreBAT;

	if (TDEBUG(1)) stream_printf(GDKout,"# CMDtijah_query: finish.\n");
        return GDK_SUCCEED;
}

char* tijah_tokenize_string(char* buf, int len, char* outbuf);

int CMDtijah_tokenize (str* res, str arg)
{
	int sz    = strlen(arg);
	char* buf = GDKmalloc(sz + 1);

	buf[0] = 0;
	*res = tijah_tokenize_string(arg,sz,buf);

	return GDK_SUCCEED;
}

int CMDpf2tijah_node(BAT** res, BAT* doc_name, BAT* doc_firstpre, BAT* doc_pfpre, BAT* item, BAT* kind, BAT* doc_loaded ) {
        int debug = 0;

	int nDocs = BATcount(doc_loaded);
	BAT **rangeBAT = (BAT**)GDKmalloc(nDocs*sizeof(BAT*));
	for(int i=0; i<nDocs; i++) {
	    rangeBAT[i] = NULL;
        }

	*res = BATnew(TYPE_void, TYPE_oid, BATcount(item));

        if ( debug ) stream_printf(GDKout,"* Start of CMDpf2tijah_node():\n");
	if ( 1 && debug ) {
	    BATprintf(GDKout,item);
	    BATprintf(GDKout,kind);
	    BATprintf(GDKout,doc_loaded);
	}
	if ( 0 && debug ) {
	    BATprintf(GDKout,doc_name);
	    BATprintf(GDKout,doc_firstpre);
	    BATprintf(GDKout,doc_pfpre);
	}

	int x;
	BUN p,q;
	BATloopFast(item, p, q, x) {
	    oid idx      = *(oid*) BUNhead(item, p);
	    ptr itemTAIL = BUNtail(item, p);
	    oid pfpre    = *(oid*) itemTAIL;

	    BUN kindBUN = BUNfnd(kind,&idx);
	    if ( !kindBUN ) {
	        stream_printf(GDKout,"READ KIND failed\n");
		return GDK_FAIL;
	    }
	    ptr kindTAIL = BUNtail(kind, kindBUN);
	    int kval = *(int*)kindTAIL;
	    if ( XTRACT_KIND(kval) != ELEM ) {
	        stream_printf(GDKout,"CMDpf2tijah_node: startNodes: no node\n");
		return GDK_FAIL;
            }
	    oid container = (oid)XTRACT_CONT(kval);

	    int myindex = container - 1;
	    /* make it a switch */
	    if ( rangeBAT[myindex] == NULL ) {
	        oid doc_start;
		oid doc_end;

	        BUN xbun = BUNfnd(doc_loaded,&container);
		if ( ! xbun ) {
	    	    stream_printf(GDKout,"Cannot find cont %d.\n",container);
		    return GDK_FAIL;
		}
		str docname = (str)BUNtail(doc_loaded,xbun);
		BAT* b = BATmirror(doc_name);
	        BUN yy = BUNfnd(b,docname);
		if ( yy ) {
		    oid tj_docIndex = *(oid*)BUNtail(b,yy);

		    BUN r;
		    r = BUNfnd(doc_firstpre,&tj_docIndex);
		    if ( ! r ) {
	    	        stream_printf(GDKout,"Cannot find tijah-firstpre @  %d.\n",tj_docIndex);
		        return GDK_FAIL;
		    }

	            doc_start = *(oid*)BUNtail(doc_firstpre,r);
		    oid tj_nextIndex = tj_docIndex +  1;
		    if ( BATcount(doc_firstpre) > tj_nextIndex ) {
		        r = BUNfnd(doc_firstpre,&tj_nextIndex);
			if ( !r ) {
	    	            stream_printf(GDKout,"Cannot do range for tijah-firstpre @  %d.\n",tj_docIndex);
			    return GDK_FAIL;
			}
	                doc_end = *(oid*)BUNtail(doc_firstpre,r) - 1;
		    } else {
	                doc_end = oid_nil;
		    }
		    rangeBAT[myindex] = BATselect(BATmirror(doc_pfpre),(ptr)&doc_start,(ptr)&doc_end);
		    if ( 0 && debug ) BATprintf(GDKout,rangeBAT[myindex]);
		} {
		    /* else skip */
		} }
	        if ( rangeBAT[myindex] ) {
		    BUN range_bun = BUNfnd(rangeBAT[myindex],&pfpre);
		    if ( range_bun ) {
			/* found the tijah index value */
		        oid tj_index = *(oid*)BUNtail(rangeBAT[myindex],range_bun);
			BUNappend(*res,&tj_index,1);
			if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = tijah(%d@0).\n", pfpre, container,tj_index);
		    } else {
		        if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = NOT INDEXED.\n", pfpre, container);
		    }
		    
		} else {
			if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = NOT INDEXED.\n", pfpre, container);
		}
	}
	/* cleanup BAT's */
	for(int i=0; i<nDocs; i++) {
	    if ( rangeBAT[i] ) {
	        BBPunfix(BBPcacheid(rangeBAT[i]));
		rangeBAT[i] = NULL;
	    }
        }
	GDKfree(rangeBAT);

	*res = BATmirror(BATmark(BATmirror(*res), 0));

	/* */
	if ( debug ) 
	    BATprintf(GDKout,*res);
	/* */
        return GDK_SUCCEED;
}

int CMDoffsetindex ( BAT** result, BAT* tid, int* res_size )
{
	char *name = "TJoffsetindex";
	BAT *res = NULL;
        BUN p, q, dst = NULL;
	oid t, s;
	int bs_res, x;

	/* --------------------------- checks ---------------------------------- */

	BATcheck(tid, name);
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: index-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}
	if (!(BAThdense(tid)))
    	{
        	GDKerror("%s: index-bat must have a dense head.\n", name);
    		return GDK_FAIL;
	}
		
	res = BATnew(TYPE_void, TYPE_oid, *res_size);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, *res_size);
            	return(GDK_FAIL);
        }
	bs_res = BUNsize(res);
	dst = BUNlast(res);
    
	t = (oid)0;
	*(oid*)dst = (oid)0;
	dst += bs_res;
	
	BATloopFast(tid, p, q, x)
	{
		s = *(oid*) BUNtail(tid, p);
		if (t != s)
		{
			for(; t < s; t++)
			{
				*(oid*)dst = BUNindex(tid, p);
				dst += bs_res; 
			}
		}
	}

	s = (oid) (*res_size - 1);
	for(; t < s; t++)
	{
		*(oid*)dst = BUNindex(tid, p);
		dst += bs_res; 
	}
	
	res->batBuns->free = dst - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
    	res->batDirty = TRUE;
        res->tsorted = GDK_SORTED;
        BATkey (res, TRUE);
	BATset(res, TRUE);
	BATseqbase(res, 0);
	
	*result = res;
	return GDK_SUCCEED;
}	
	
int CMDindexfetchjoin ( BAT** result, BAT* tid, BAT* index, BAT* pre )
{
	char *name = "TJindexfetchjoin";
	BAT *res = NULL;
        BUN dst = NULL;
	int bs_pre = BUNsize(pre);
	int bs_res;

	int ressize = 0;
	oid t, *ind;
	BUN p, q;
        int x, j, i = 0;
	/* bit one_tid = FALSE; */
    
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tid, name);
	BATcheck(index, name);
	BATcheck(pre, name);
	
        /* if (BATcount(tid) <= 1) one_tid = TRUE; */
	
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	ind = GDKmalloc(sizeof(oid) * BATcount(tid) * 3);
	
	BATloopFast(tid, p, q, x) {
		t = *(oid*) BUNtail(tid, p);
		ind[i++] = t;
		ind[i++] = *(oid*) BUNtloc(index, BUNptr(index, (int)t));
		ind[i++] = *(oid*) BUNtloc(index, BUNptr(index, (int)t + 1));
		ressize += (ind[i - 1] - ind[i - 2]);
	}
	
	res = BATnew(TYPE_oid, TYPE_oid, ressize);
	bs_res = BUNsize(res);
	dst = BUNlast(res);
	
	j = 0;
	while (j < i) {
        	t = ind[j++];
		p = BUNptr(pre, ind[j++]);
		q = BUNptr(pre, ind[j++]);
		for (; p < q; p += bs_pre) {
			*(oid*)dst = t;
			*(oid*)(dst + SIZEOF_OID) = *(oid*)p;
			dst += bs_res;
		}
	}

	GDKfree(ind);
	res->batBuns->free = dst - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
    	res->batDirty = TRUE;
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
        BATkey (BATmirror(res), TRUE);
	BATset(res, TRUE);
	
	*result = res;
	return GDK_SUCCEED;
}

bat* pftijah_prelude() {
    /* stream_printf(GDKout,"# execute pftijah_prelude().\n"); */
    BAT* b = BATnew(TYPE_void,TYPE_bat,0);
    /* tj_termDB, tj_termDBconf, tj_termDBtree, tj_termDBbats, tj_termDBbatN */
    /* ? max tree size , max frag size ? */
    if ( (!b) || (BBPrename(BBPcacheid(b),"tj_termDB")!=0) ) {
      stream_printf(GDKout,"# pftijah_prelude(): env bat creation failed.\n");
    }
    BBPfix(BBPcacheid(b));
    return NULL;
}

void pftijah_epilogue() {
}
@

/* vim:set shiftwidth=4 expandtab: */
