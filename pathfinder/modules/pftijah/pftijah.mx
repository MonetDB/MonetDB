@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the PfTijah Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://dbappl.cs.utwente.nl/Legal/PfTijah-1.1.html
@' 
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@' 
@' The Original Code is the PfTijah system.
@' 
@' The Initial Developer of the Original Code is the "University of Twente".
@' Portions created by the "University of Twente" are 
@' Copyright (C) 2006-2007 "University of Twente".
@' All Rights Reserved.
@'

@f pftijah
@a Jan Flokstra
@a Henning Rode
@t pftijah

@m
.MODULE pftijah;

.COMMAND _run_tijah_query(BAT[str,str] opt, bit use_startnodes, BAT[void,oid] nodes) : BAT[oid,dbl] = CMDtijah_query;
 "INCOMPLETE"

.COMMAND tj_normalizeTerm(str, str) : str = CMDtj_normalizeTerm;
 "INCOMPLETE"

.COMMAND _tj_throw2collection(BAT[str,bat],BAT[oid,bat],str) : void = CMDtj_throw2collection;
 "INCOMPLETE"

.COMMAND _tj_throw2collection_index(BAT[str,bat],str) : void = CMDtj_throw2collection_index;
 "INCOMPLETE"
 
.COMMAND tijah_tokenize(str) : str = CMDtijah_tokenize;
 "INCOMPLETE"

.COMMAND tj_chk_dict_hash(BAT[void,str], BAT[void,str]) : void = CMDtj_chk_dict_hash;
"INCOMPLETE"

.COMMAND tj_create_termdb(int, oid) : void = CMDtj_create_termdb;
 "INCOMPLETE"

.COMMAND tj_dispose_termdb() : void = CMDtj_dispose_termdb;
 "INCOMPLETE"

.COMMAND tj_log(str, int) : void = CMDtj_log;
 "DEBUGGING function for difficult IO areas"

.COMMAND tj_setlog(str) : void = CMDtj_setlog;
 "intialize outputfile for tj_log"

.COMMAND left_add(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDleft_add_dbl;
"Fast in-bat implementation of 2 head sorted bat addition with synchronized oid"
.COMMAND left_sub(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDleft_sub_dbl;
"Fast in-bat implementation of 2 head sorted bat subtraction with synchronized oid"
.COMMAND left_mul(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDleft_mul_dbl;
"Fast in-bat implementation of 2 head sorted bat multiplication with synchronized oid"
.COMMAND left_div(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDleft_div_dbl;
"Fast in-bat implementation of 2 head sorted bat division with synchronized oid"
.COMMAND left_div(BAT[oid,dbl] l, BAT[oid,int] r) : BAT[oid,dbl] = CMDleft_div_dbl_int;
"Fast in-bat implementation of 2 head sorted bat division, right type int with synchronized oid"
.COMMAND left_log(BAT[oid,dbl] l) : BAT[oid,dbl] = CMDleft_log_dbl;
"Fast in-bat implementation of in bat log() with synchronized oid"

.COMMAND union_add(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDunion_add_dbl;
"Fast union implementation of 2 head sorted bat addition with synchronized oid"
.COMMAND union_sub(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDunion_sub_dbl;
"Fast union implementation of 2 head sorted bat addition with synchronized oid"
.COMMAND union_mul(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDunion_mul_dbl;
"Fast union implementation of 2 head sorted bat addition with synchronized oid"
.COMMAND union_div(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDunion_div_dbl;
"Fast union implementation of 2 head sorted bat addition with synchronized oid"


.COMMAND serialize_tijah_opt(
                      BAT[void,bat] ws,
                      int	    niters,
                      BAT[void,oid] loop,
                      BAT[void,oid] iter,
                      BAT[void,oid] item,
		      BAT[void,int] kind,
                      BAT[void,lng] int_values,
		      BAT[void,dbl] dbl_values,
		      BAT[void,str] str_values)
		       : BAT[str,str] = serialize_pftijah_options_DRIVER;
 "C interface to pftijah option serialize"

.COMMAND pf2tijah_node(
                      BAT[oid,str] doc_name,
                      BAT[oid,oid] doc_firstpre,
                      BAT[oid,oid] pfpre,
                      BAT[oid,oid] item,
		      BAT[oid,int] kind,
                      BAT[oid,str]  doc_loaded)
		       : BAT[void,oid] = CMDpf2tijah_node;
 "Translate Pathfinder node sequence to tijah node sequence"

.COMMAND offsetindex( BAT[void,oid] offset_tid, int res_size)
		: BAT[void,oid] = CMDoffsetindex;

"PARAMETERS:
BAT[void,oid] - the offset index 
ressize       - the result size, equals number of different tids + 1
DESCRIPTION:
creates an offset index.
"

.COMMAND mergeindex( BAT[oid,oid] tid_pre, BAT[void,oid] index, BAT[void, oid] pre, int indsize)
		: BAT[void,bat] = CMDmergeindex;
"PARAMETERS:
BAT[oid,oid] - new tid_pre to merge with the old index
BAT[void,oid] - old index bat with value-offset
BAT[void,oid] - old posting lists (pre order lists)
int - size of new (dense) offset index.
DESCRIPTION:
the operation merges a new sorted tid_pre with an existing offset index.
"

.COMMAND mergeindex2( BAT[oid,oid] tid_pre, BAT[oid,int] tid_size, BAT[void,oid] index, BAT[void, oid] pre, BAT[void, int] size, int indsize)
		: BAT[void,bat] = CMDmergeindex2;
"PARAMETERS:
BAT[oid,oid] - new tid_pre to merge with the old index
BAT[oid,int] - sizes of new elements to merge with the old index (synched with tid_pre)
BAT[void,oid] - old index bat with value-offset
BAT[void,oid] - old posting lists (pre order lists)
BAT[void,int] - corresponding size lists (pre order lists)
int - size of new (dense) offset index.
DESCRIPTION:
the operation merges a new sorted tid_pre with an existing offset index.
"

.COMMAND indexfetchjoin( BAT[any,oid] tid, BAT[void,oid] index, BAT[void, oid] pre)
		: BAT[void,oid] = CMDindexfetchjoin;
"PARAMETERS:
BAT[any,oid] - bat with tail values which have to be joined (e.g. tid values)
BAT[void,oid] - join index bat with value-offset
BAT[void,oid] - bat with indexed offset and tail values to be returned
DESCRIPTION:
the join algorithm comes down to a repeated slice and insert operation.
"

.COMMAND treemergejoin_sort(BAT[oid,oid],BAT[void,int],BAT[oid,oid]) : BAT[oid,oid] = CMDtreemergejoin_sort; 
"Stack tree merge join descendant"

.COMMAND treemergejoin_sort_unnested(BAT[oid,oid],BAT[void,int],BAT[oid,oid]) : BAT[oid,oid] = CMDtreemergejoin_sort_unnested; 
"Stack tree merge join descendant"

.PRELUDE = pftijah_prelude;
.EPILOGUE = pftijah_epilogue;

.END pftijah;
@mil
###
# This file contains implementations of some of the SRA operators 
# to run on the TIJAH Light index.
#
# Based on code by the TIJAH team (Vojkan, Thijs)
#
# Additional retrieval models by Henning Rode and Djoerd Hiemstra
#
# Authors: Roel van Os <roel.van.os@glacimonto.nl>
#          Henning Rode <h.rode@cs.utwente.nl>
#
###

const DEBUG := false;

# locks
var tj_adm_lock     := lock_create(); # tijah top administration lock
var tj_dep_lock     := lock_create(); # tijah top dependency adm lock
var tj_coll_lockbat := new(str,lock); # locks for all active collections

# Comparisons
# const GREATER := 10;
# const LESS := 11;
# const EQUAL := 12;
# const GEQ := 13;
# const LEQ := 14;

# Modifiers
# const NORMAL := 71;
# const PLUS := 72;
# const MINUS := 73;
# const MUST := 74;
# const MUST_NOT := 75;

const ENTITY_NUM := 10000;

#var collHeight := 10;
#var retNum := 100;

var trace := false;
var timing := false;

##
# For retrieval models: 
#   true:  return all elements from the context set
#   false: return only elements from the context set that contain one or more query terms
#
# Setting this variable to false has the advantage of smaller intermediate region sets.
# In theory, true has the advantage of better results, since it is possible that
# elements that don't match any term at the beginning of a query, contain descendants
# that do match terms.
##
var returnAllElements := true;

if (isnil(CATCH(bat("tj_collName").count()))) {
	if (bat("tj_collName").count() > 0) {
		var name := bat("tj_collName").fetch(0);
		# tj_setCollName(name);
	}
}

const QENV_FTINAME        := 0@0;
const QENV_FTIBGNAME      := 1@0;
const QENV_SCOREBASE      := 2@0;
const QENV_C_LAMBDA       := 3@0;
const QENV_TERM_PROXIMITY := 4@0;
const QENV_FEEDBACK_DOCS  := 5@0;
const QENV_RECURSIVE_TAGS := 6@0;
const QENV_OKAPI_K1       := 7@0;
const QENV_OKAPI_B        := 8@0;

# create a query environment bat
PROC create_qenv() : BAT[oid,str]
{
    var res := new(oid,str);
    return res;
}

PROC modify_qenv(BAT[oid,str] qenv, oid key, str val) : void
{
    if (qenv.exist(key)) {
       qenv.replace(key, val);
    } else {
       qenv.insert(key, val);
    }
}

#####################################################################
#                                                                   #
# Start of the information functions                                #
#                                                                   #
#####################################################################

# tijah:ft-index-info(), get all ft-index-information
PROC ws_ft_index_info(BAT[void,BAT] ws, bit consistent) : BAT[void,oid]
{
    return ws_ft_index_info_base(ws,new(void,str),true);
}

# tijah:ft-index-info(str), get all ft-index-information
PROC ws_ft_index_info(BAT[void,BAT] ws, BAT[any,str] ftiNames, bit consistent) : BAT[void,oid]
{
    return ws_ft_index_info_base(ws,ftiNames,false);
}

# tijah:ft-index-info(str), get all ft-index-information
PROC ws_ft_index_info_base(BAT[void,BAT] ws, BAT[any,str] ftiNames, bit all) : BAT[void,oid]
{
    var chkbat;

    var tjc;

    if (isnil(CATCH(bat("tj_collName").count()))) {
        tjc := bat("tj_collName");
    } else {
        tjc := new(oid,str);
    }

    if ( all )
        chkbat := tjc;
    else 
        chkbat := ftiNames;

    var res := new(void,str).seqbase(0@0);
    var stm := new(void,str).seqbase(0@0);
    var tok := new(void,str).seqbase(0@0);
    var col := new(void,str).seqbase(0@0);
    chkbat@batloop() {
	if ( or(all,tjc.reverse().exist($t)) ) {
          res.append($t);
          stm.append(bat("tj_" + $t + "_param").find("stemmer"));
          tok.append(bat("tj_" + $t + "_param").find("tokenizer"));
	  var as := "";
	  bat("tj_pfc_fti_dep").reverse().select($t)@batloop() {
	      if ( as = "" )
	          as := $h;
	      else 
	          as := as + "," + $h;
	  }
          col.append(as);
    	}
    }
    return xmltab4(ws, "ftindex", res, "stemmer", stm, "tokenizer", tok, "collections", col);
}

#####################################################################
#                                                                   #
# Start of the new implementation of the interfaces                 #
#                                                                   #
#####################################################################

var verbose      := false;

const dflt_ft_index   := "DFLT_FT_INDEX";
const dflt_bg_index   := "DFLT_FT_INDEX";
const dflt_score_base := "0";

# var GQENV := create_qenv(dflt_ft_index,dflt_bg_index,dflt_score_base);

PROC tj_get_ft_index(BAT[str,str] tj_options, bit chk_exists) : str :=
{
    var res := dflt_ft_index;
    if ( tj_options.exist("ft-index") ) {
        res := tj_options.find("ft-index");
    }
    if ( chk_exists ) {
      if ( not(bat("tj_collName").reverse().exist(res)) ) {
    	ERROR("tj_get_ft_index, ft-index \"%s\" does not exist\n",res);
      }
    }
    if ( verbose ) printf("#TJ:tj_get_ft_index() = %s.\n",res);
    return res;
}

ADDHELP("tj_ping", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- none.\n\
DESCRIPTION:\n\
debugging, when this help is removed Mtest/Mapi fails ",
"pftijah");
PROC tj_ping() : void :=
{
  lock_set(tj_adm_lock);
  var err := CATCH({printf("# *** ping *****\n");} );
  lock_unset(tj_adm_lock);
  if (not(isnil(err))) ERROR(err);
}

ADDHELP("tj_init_global", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- optional BAT[str,str] param: initialization parameter for global pftijah.\n\
  settings.\n\
DESCRIPTION:\n\
Initialize the global pftijah environment.",
"pftijah");
PROC tj_init_global(BAT[str,str] param) : void :=
{
    tj_init_global(param,true);
}

const GLOBAL_TTBAT := false;
const VOID_TTBAT   := true;

PROC _tj_TermBat(str ftiName) : str :=
{
    if ( GLOBAL_TTBAT )
        return "tj_globalTerms";
    else
    	return "tj_" + ftiName + "_termdict";
}

PROC _tj_TagBat(str ftiName) : str :=
{
    if ( GLOBAL_TTBAT )
        return "tj_globalTags";
    else
    	return "tj_" + ftiName + "_tagdict";
}

PROC _tj_RTagBat(str ftiName) : str :=
{
    if ( GLOBAL_TTBAT )
        return "tj_globalRTags";
    else
    	return "tj_" + ftiName + "_rtags";
}

PROC tj_init_global(BAT[str,str] param, bit doLock) : void :=
{
    if (doLock) lock_set(tj_adm_lock);
    var err := CATCH({
      if ( verbose ) printf("#TJ:tj_init_global() called.\n");
      param@batloop() {
	if ( verbose ) printf("#TJ:tj_init_global():param[%s]=\"%s\"\n",$h,$t);
	if ( $h = "term_frag" ) {
	    # incomplete, handle term frag
	} else if ( $h = "term_frag_size" ) {
	    # incomplete, handle term frag
	} else {
	    ERROR("# tj_init_global() unkonwn parameter [%s].\n",$h);
	}
      }
      if ( GLOBAL_TTBAT ) {
          new(oid,str).persists(true).bbpname(_tj_TermBat(""));
          new(oid,str).persists(true).bbpname(_tj_TagBat(""));
          new(oid,oid).persists(true).bbpname(_tj_RTagBat(""));
      }
      new(oid,str).persists(true).bbpname("tj_collName");
      new(str,str).persists(true).bbpname("tj_pfc_fti_dep");
      new(str,str).persists(true).bbpname("tj_pfc_fti_dep_star");
      var globals := new(void,str).seqbase(0@0);
      if ( GLOBAL_TTBAT ) {
          globals.append(_tj_TermBat(""));
          globals.append(_tj_TagBat(""));
          globals.append(_tj_RTagBat(""));
      }
      globals.append("tj_collName");
      globals.append("tj_pfc_fti_dep");
      globals.append("tj_pfc_fti_dep_star");
      subcommit(globals);
    });
    if (doLock) lock_unset(tj_adm_lock);
    if (not(isnil(err))) ERROR(err);
}

PROC tj_init_global() : void :=
{
     tj_init_global(new(str,str));
}

ADDHELP("tj_delete_global", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
DESCRIPTION:\n\
Delete all pftijah collections and remove the global pftijah settings.",
"pftijah");
PROC tj_delete_global() : void :=
{
    lock_set(tj_adm_lock);
    var err := CATCH({
      if ( verbose ) printf("#TJ:tj_delete_global() called.\n");
      #
      bat("tj_collName")@batloop(){
  	  tj_delete_collection($t,false);
      }
      if ( GLOBAL_TTBAT ) {
          bat(_tj_TermBat("")).persists(false);
          bat(_tj_TagBat("")).persists(false);
          bat(_tj_RTagBat("")).persists(false);
      }
      bat("tj_collName").persists(false);
      bat("tj_pfc_fti_dep").persists(false);
      bat("tj_pfc_fti_dep_star").persists(false);
      var globals := new(void,str).seqbase(0@0);
      if ( GLOBAL_TTBAT ) {
          globals.append(_tj_TermBat(""));
          globals.append(_tj_TagBat(""));
          globals.append(_tj_RTagBat(""));
      }
      globals.append("tj_collName");
      globals.append("tj_pfc_fti_dep");
      globals.append("tj_pfc_fti_dep_star");
      subcommit(globals);
    });
    lock_unset(tj_adm_lock);
    if (not(isnil(err))) ERROR(err);
}

# protext the lookup/insert of the per-collection-locks

var tj_coll_mutex := lock_create();

PROC tj_get_collection_lock(str colname) : lock
{
    var collection_lock;

    lock_set(tj_coll_mutex);
    var err := CATCH({
      if (tj_coll_lockbat.exist(colname))
        collection_lock := tj_coll_lockbat.find(colname);
      else {
        collection_lock := lock_create();
	tj_coll_lockbat.insert(colname,collection_lock);
      }
    });
    lock_unset(tj_coll_mutex);
    if (not(isnil(err))) ERROR(err);
    return collection_lock;
}

ADDHELP("tj_init_collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str ftiName: the name of the collection
- BAT[str,str] param: initialization parameter for collection.\n\
  possible values are:\n\
  tokenizer = { flex, fast }\n\
  stemmer = { nostemming, snowball-english, snowball-porter, snowball-dutch }\n\
  fragmentSize = [number] == the maximum size of a [pre|item] fragment\n\
  tagFilter = [comma seperated list of tags to be indexed]\n\
  etc.\n\
- BAT[void,str] v_pfc, list of pathfinder collection to index 
DESCRIPTION:\n\
Create a new tijah collection.",
"pftijah");
PROC tj_init_collection(str ftiName, BAT[str,str] param, BAT[void,str] v_pfc) : void :=
{
    _tj_init_collection(ftiName,param,v_pfc,FALSE);
}

PROC tj_init_collection(str ftiName, BAT[str,str] param) : void :=
{
    _tj_init_collection(ftiName,param,new(void,str),FALSE);
}

PROC tj_rebuild_collection(str ftiName) : void  
{
    # WARNING: not thoroughly tested yet
    _tj_init_collection(ftiName,new(str,str),new(void,str),TRUE);
}

PROC _tj_init_collection(str ftiName, BAT[str,str] param, BAT[void,str] v_pfc, bit rebuild) : void :=
{
    var coll_lock;

    #
    # first handle the global administration stuff
    #
    lock_set(tj_adm_lock);
    var err := CATCH({
      if ( verbose ) printf("#TJ tj_init_collection(\"%s\") called.\n",ftiName);

      if (not(isnil(CATCH(bat("tj_collName").count())))) {
    	tj_init_global(new(str,str),false); # just in case 
      }
      if (bat("tj_collName").reverse().exist(ftiName)) {
    	if ( not(rebuild) )
	  ERROR("tj_init_collection, pftijah collection already exists: %s\n",ftiName);
      } else {
        if (rebuild) {
	  ERROR("tj_rebuild_collection, pftijah collection \"%s\" does not exists\n",ftiName);
	}
      }
      #
      if ( not(rebuild) ) {
          var coll_oid;
          if (bat("tj_collName").count() = 0) { 
            coll_oid := 0@0;
          } else {
            coll_oid := oid(int(bat("tj_collName").reverse().max()) + 1);
          }
          bat("tj_collName").insert(coll_oid, ftiName);
          #
      }
      coll_lock := tj_get_collection_lock(ftiName);
    });
    lock_unset(tj_adm_lock);
    if (not(isnil(err))) ERROR(err);
    #
    # now the collection stuff 
    #
    var extra_del_bat;
    lock_set(coll_lock);
    var err := CATCH({
      if ( not(GLOBAL_TTBAT) ) {
	  if ( rebuild ) {
	      # INCOMPLETE, not throwing them away is much faster!!!
              bat(_tj_TermBat(ftiName)).delete();
              bat(_tj_TagBat(ftiName)).delete();
              bat(_tj_RTagBat(ftiName)).delete();
	  } else {
	      if ( VOID_TTBAT) {
                  new(void,str).seqbase(0@0).persists(true).bbpname(_tj_TermBat(ftiName));
                  new(void,str).seqbase(0@0).persists(true).bbpname(_tj_TagBat(ftiName));
	      } else {
                  new(oid,str).persists(true).bbpname(_tj_TermBat(ftiName));
                  new(oid,str).persists(true).bbpname(_tj_TagBat(ftiName));
	      }
              new(oid,oid).persists(true).bbpname(_tj_RTagBat(ftiName));
	  }
      }
      extra_del_bat := new(void,str).seqbase(0@0);
      if ( rebuild ) {
          bat("tj_" + ftiName + "_doc_name").delete();
          bat("tj_" + ftiName + "_doc_firstpre").delete();
	  # do not delete the param bat
	  var frag_offset := int(2); # we delete all buns in existing 1 frag
	  var frag_last := bat("tj_" + ftiName + "_fragments").count();
	  while (frag_offset < frag_last)
	  {
		var bn := "tj_" + ftiName + "_tid" + str(frag_offset);
		bat(bn).persists(FALSE);
                extra_del_bat.append(bn);
		bn := "tj_" + ftiName + "_size" + str(frag_offset);
		bat(bn).persists(FALSE);
                extra_del_bat.append(bn);
		frag_offset :+= 1;
	  }
          bat("tj_" + ftiName + "_tid1").delete();
          bat("tj_" + ftiName + "_size1").delete();
          bat("tj_" + ftiName + "_fragments").delete();
          bat("tj_" + ftiName + "_fragments").append(1@0);
          bat("tj_" + ftiName + "_pfpre").delete();
      } else {
          new(void,str).seqbase(0@0).persists(true).bbpname("tj_" + ftiName + "_doc_name");
          new(void,oid).seqbase(0@0).persists(true).bbpname("tj_" + ftiName + "_doc_firstpre");
          new(str,str).persists(true).bbpname("tj_" + ftiName + "_param");
          
          new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + ftiName + "_tid1");
          new(void,int).seqbase(1@0).persists(true).bbpname("tj_" + ftiName + "_size1");
          # bat contains the start oid of every tid/size frag. Head is postfix
          # string to _tid/_size. Normally "", "2", "3"
          new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + ftiName + "_fragments");
          bat("tj_" + ftiName + "_fragments").append(1@0);
          new(oid,oid).persists(true).bbpname("tj_" + ftiName + "_pfpre");
      }
         
      var parambat := bat("tj_" + ftiName + "_param");
      if ( rebuild ) {
	parambat.replace("status","building");
	parambat.replace("_last_tijahPre","1");
	parambat.replace("_last_finalizedPre","0");
      } else {
        #
        # now read the param file
        #
        var stemmer        := "nostemming";
        var tokenizer      := "flex";
        var tagfilter      := "";
	var whitelist      := "";
	var blacklist      := "";
        var fragsize       := "0";
        var delay_finalize := "0";
  
        param@batloop() {
	  if ( verbose ) printf("#TJ:tj_init_collection():param[%s]=\"%s\"\n",$h,$t);
	  if ( $h = "stemmer" ) {
	      stemmer := $t;
	  } else if ( $h = "tokenizer" ) {
	      tokenizer := $t;
	  } else if ( $h = "pf_collection" ) {
              bat("tj_" + ftiName + "_param").insert($h,$t);
	  } else if ( $h = "fragmentSize" ) {
	      fragsize := $t;
	  } else if ( $h = "whitelist" ) {
              whitelist := $t;
	  } else if ( $h = "blacklist" ) {
              blacklist := $t;
	  } else if ( $h = "ft-index" ) {
	      # ignore this one here
	  } else if ( $h = "delay-finalize" ) {
	      # the number of pre nodes to delay a finalize
	      delay_finalize := $t;
	  } else {
	      ERROR("# tj_init_collection() unknown parameter [%s].\n",$h);
	  }
        }
        #
        # now set the parameters for this collection
        #
        parambat.insert("_version","1.01");
        parambat.insert("name",ftiName);
        parambat.insert("tokenizer",tokenizer);
        parambat.insert("stemmer",stemmer);
        parambat.insert("fragmentSize",fragsize);
        parambat.insert("preExpansion","4");
        parambat.insert("lastStopWord","0");
        parambat.insert("status","building");
        parambat.insert("_last_tijahPre","1");
        parambat.insert("_last_finalizedPre","0");
        parambat.insert("delay_finalize",delay_finalize);
	if( not(whitelist = "") )
            parambat.insert("whitelist",whitelist);
	if( not(blacklist = "") )
            parambat.insert("blacklist",blacklist);
      }
      if ( rebuild  ) {
        # reconstruct the original v_pfc
	v_pfc := bat("tj_pfc_fti_dep").reverse().select(ftiName).reverse();
      } else {
        #
        # now modify the global fti pfc dependency administration. We may ignore
        # the return value because all dependencies for this collection are new.
        modify_pfc_fti(ftiName,v_pfc);
      }
      if ( rebuild ) {
	if (isnil(CATCH(bat("tj_" + ftiName + "_TermIndex").count()))) {
		bat("tj_" + ftiName + "_TermIndex").persists(false);
		bat("tj_" + ftiName + "_Terms").persists(false);
		bat("tj_" + ftiName + "_TagIndex").persists(false);
		bat("tj_" + ftiName + "_Tags").persists(false);
	}
      }
    });
    if ( rebuild ) {
        subcommit(extra_del_bat);
    }
    subcommit(_tj_collection_str(ftiName));
    lock_unset(coll_lock);
    #
    if (not(isnil(err))) ERROR(err);
    #
    if ( true ) {
      #
      # Now compute the list of existing docs which need to be added to the 
      # ft-index because of the associations.
      # WARNING: this piece of code is not yet very safe but is requires
      # a very close cooperation with Pathfinder locks to make it safe.
      #
      if ( verbose ) printf("#TJ:tj_init_collection(\"%s\") checking collection to index.\n",ftiName);
      if ( v_pfc.count() > 0 ) {
        var doclist;
        if ( v_pfc.uselect("*").count() > 0 ) {
           doclist := bat("doc_name").reverse().project(str(nil)).reverse();
	} else {
           doclist := bat("doc_name").reverse().join(bat("doc_collection").join(bat("collection_name").join(v_pfc.reverse())));
           doclist := doclist.project(str(nil)).reverse();
	}
        if ( doclist.count() > 0 ) {

            if ( verbose ) printf("#TJ:tj_init_collection(\"%s\") indexing existing collections.\n",ftiName);
	    tj_add2collection(ftiName,doclist,true);
            if ( verbose ) printf("#TJ:tj_init_collection(\"%s\") finish indexing existing collections.\n",ftiName);
        }
      }
    }
    if ( verbose ) printf("#TJ:tj_init_collection(\"%s\") finished.\n",ftiName);
}

#
# The tj_extend_collection() adds new pf collection dependencies to an existing
# collection.
#
PROC tj_extend_collection(str ftiName, BAT[void,str] v_pfc) : void :=
{
    if ( verbose ) printf("#TJ:tj_extend_collection(\"%s\") start.\n",ftiName);
    var newdep := modify_pfc_fti(ftiName,v_pfc);

    var doclist := bat("doc_name").reverse().join(bat("doc_collection").join(bat("collection_name").join(newdep.reverse())));
    doclist := doclist.project(str(nil)).reverse();
    if ( doclist.count() > 0 ) {
        if ( verbose ) printf("#TJ:tj_extend_collection(\"%s\") indexing existing collections.\n",ftiName);
        if ( verbose ) doclist.print();
	tj_add2collection(ftiName,doclist,true);
        if ( verbose ) printf("#TJ:tj_extend_collection(\"%s\") finish indexing existing collections.\n",ftiName);
    }
    if ( verbose ) printf("#TJ:tj_extend_collection(\"%s\") finished.\n",ftiName);
}


#
# Start of ft-index / pf-collection dependency module
#

PROC modify_pfc_fti(str fti_name, BAT[void,str]  v_pfc) : BAT[str,str] :=
{
    var result;

    lock_set(tj_dep_lock);
    var err := CATCH({
	var glb_fti_pfc     := bat("tj_pfc_fti_dep");
	var fti_dep := glb_fti_pfc.reverse().select(fti_name).reverse();
	if ( fti_dep.select("*").count() > 0 ) {
	    ERROR("# pfc_fti_dep: unable to extend ft-index when created with *\n");
	}
	var new_fti_pfc := v_pfc.tunique().project(fti_name).reverse().sunique().tdiff(fti_dep);
	if ( verbose ) {
	    printf("#TJ:modify_pfc_fti: ***** added dep ***\n");
	    new_fti_pfc.print();
	}
	var sz := new_fti_pfc.count();
	if ( sz > 0 ) {
	    if ( sz = 1 ) {
		glb_fti_pfc.insert(new_fti_pfc);
		if ( new_fti_pfc.uselect("*").count() > 0 ) {
		    bat("tj_pfc_fti_dep_star").insert(new_fti_pfc);
	        }
	    } else {
	    	if ( new_fti_pfc.uselect("*").count() > 0 ) {
		    ERROR("# pfc_fti_dep: when using * it must be the only collection dependency.\n");
		}
		glb_fti_pfc.insert(new_fti_pfc);
	    }
	}
	result := new_fti_pfc;
    });
    if ( verbose ) {
    	printf("\n# LOG modify_pfc_fti(\"%s\") START, v_pfc =\n", fti_name);
	v_pfc.print();
    	printf("# Dependence BATs are [STAR|ALL]:\n");
	bat("tj_pfc_fti_dep_star").print();
	bat("tj_pfc_fti_dep").print();
    	printf("# LOG modify_pfc_fti(\"%s\") END.\n", fti_name);
    }
    lock_unset(tj_dep_lock);
    if (not(isnil(err))) ERROR(err);
    #
    return result;
}

PROC delete_pfc_fti(str fti_name) :void :=
{
    lock_set(tj_dep_lock);
    var err := CATCH({
	bat("tj_pfc_fti_dep").delete(fti_name);
	bat("tj_pfc_fti_dep_star").delete(fti_name);
    });
    lock_unset(tj_dep_lock);
    if (not(isnil(err))) ERROR(err);
}

#
# End of ft-index / pf-collection dependency module
#

ADDHELP("tj_delete_collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str ftiName: the name of the collection to be deleted.\n
DESCRIPTION:\n\
Delete the collection with name \"ftiName\".",
"pftijah");
PROC tj_delete_collection(str ftiName) : void
{
    tj_delete_collection(ftiName,true);
}

PROC tj_delete_collection(str ftiName, bit doAdmLock) : void
{
    var coll_lock;

    #
    # first handle the global administration stuff
    #
    if ( doAdmLock ) lock_set(tj_adm_lock);
    var err := CATCH({
      if ( verbose ) printf("#TJ:tj_delete_collection(\"%s\") called.\n",ftiName);

      if (not(isnil(CATCH(bat("tj_collName").count())))) {
    	ERROR("tj_delete_collection: pftijah not initialized.\n");
      }
      if (not(bat("tj_collName").reverse().exist(ftiName))) {
    	ERROR("tj_delete_collection, pftijah collection does not exist: %s\n",ftiName);
      }
      #
      var coll_oid := bat("tj_collName").reverse().find(ftiName);
      bat("tj_collName").delete(coll_oid);
      #
      coll_lock := tj_get_collection_lock(ftiName);
    });
    if ( doAdmLock ) lock_unset(tj_adm_lock);
    if (not(isnil(err))) ERROR(err);
    #
    # now remove the collection stuff 
    #
    lock_set(coll_lock);
    var err := CATCH({
        if ( not(GLOBAL_TTBAT) ) {
          bat(_tj_TermBat(ftiName)).persists(false);
          bat(_tj_TagBat(ftiName)).persists(false);
          bat(_tj_RTagBat(ftiName)).persists(false);
        }
	bat("tj_" + ftiName + "_doc_name").persists(false);
	bat("tj_" + ftiName + "_doc_firstpre").persists(false);
	bat("tj_" + ftiName + "_param").persists(false);
	bat("tj_" + ftiName + "_pfpre").persists(false);
	bat("tj_" + ftiName + "_fragments")@batloop() {
	    var fpfx := str(int($h));
	    bat("tj_" + ftiName + "_tid"+fpfx).persists(false);
	    bat("tj_" + ftiName + "_size"+fpfx).persists(false);
	}
	bat("tj_" + ftiName + "_fragments").persists(false);
	if (isnil(CATCH(bat("tj_" + ftiName + "_TermIndex").count()))) {
		bat("tj_" + ftiName + "_TermIndex").persists(false);
		bat("tj_" + ftiName + "_Terms").persists(false);
		bat("tj_" + ftiName + "_TagIndex").persists(false);
		bat("tj_" + ftiName + "_TagSize").persists(false);
		bat("tj_" + ftiName + "_Tags").persists(false);
	}
        delete_pfc_fti(ftiName);
        subcommit(_tj_collection_str(ftiName));
    });
    lock_unset(coll_lock);
    if (not(isnil(err))) ERROR(err);
}

# internal method which return all batnames of a collection in a
# a [void,str] bat
PROC _tj_collection_str(str ftiName) : BAT[void,bat]
{
        var tjCollBat := new(void,str).seqbase(0@0);

        tjCollBat.append(_tj_TermBat(ftiName));
        tjCollBat.append(_tj_TagBat(ftiName));
        tjCollBat.append(_tj_RTagBat(ftiName));
        tjCollBat.append("tj_pfc_fti_dep");
        tjCollBat.append("tj_pfc_fti_dep_star");
        tjCollBat.append("tj_collName");
        tjCollBat.append("tj_" + ftiName + "_param");
        tjCollBat.append("tj_" + ftiName + "_doc_name");
        tjCollBat.append("tj_" + ftiName + "_doc_firstpre");
        tjCollBat.append("tj_" + ftiName + "_pfpre");
        tjCollBat.append("tj_" + ftiName + "_fragments");
	bat("tj_" + ftiName + "_fragments")@batloop()
        {       
            tjCollBat.append("tj_" + ftiName + "_tid" + str(int($t)));
            tjCollBat.append("tj_" + ftiName + "_size"+ str(int($t)));
        }       
        if (isnil(CATCH(bat("tj_" + ftiName + "_TermIndex").count()))) {
            tjCollBat.append("tj_" + ftiName + "_Terms");
            tjCollBat.append("tj_" + ftiName + "_Tags");
            tjCollBat.append("tj_" + ftiName + "_TermIndex");
            tjCollBat.append("tj_" + ftiName + "_TagIndex");
            tjCollBat.append("tj_" + ftiName + "_TagSize");
        }      
        return tjCollBat;
}

# internal method which return all relevant data about a collection in a
# a single [void,bat] bat
PROC _tj_collection(str ftiName) : BAT[str, bat]
{
        if (not(isnil(CATCH(bat("tj_" + ftiName + "_param").count())))) {
	     ERROR("_tj_collection(): collection(\""+ftiName+"\") does not exist!\n");
	}
	var tjCollBat := new(str,bat);

	var parbat := bat("tj_" + ftiName + "_param");
	var curversion;
	if ( parbat.exist("_version") ) {
	    curversion := parbat.find("_version");
	} else {
	    curversion := "0.0";
	}
	if ( curversion < "1.0" ) {
	     ERROR("_tj_collection():%s: pftijah index structure changed, reindex collection!!",curversion);
	}
	tjCollBat.insert("_globalTerms", bat(_tj_TermBat(ftiName)));
	tjCollBat.insert("_globalTags", bat(_tj_TagBat(ftiName)));
	tjCollBat.insert("_globalRTags", bat(_tj_RTagBat(ftiName)));
	tjCollBat.insert("_doc_name", bat("tj_" + ftiName + "_doc_name"));
	tjCollBat.insert("_doc_firstpre", bat("tj_" + ftiName + "_doc_firstpre"));
	tjCollBat.insert("_param", parbat);
	# only load the top [pre|term|size] fragments
	var fpfx := str(bat("tj_" + ftiName + "_fragments").count());
	tjCollBat.insert("_tid", bat("tj_" + ftiName + "_tid"+fpfx));
	tjCollBat.insert("_size", bat("tj_" + ftiName + "_size"+fpfx));
	tjCollBat.insert("_pfpre", bat("tj_" + ftiName + "_pfpre"));
	tjCollBat.insert("_fragments", bat("tj_" + ftiName + "_fragments"));
	
	if (isnil(CATCH(bat("tj_" + ftiName + "_TermIndex").count()))) {
            tjCollBat.insert("_Terms", bat("tj_" + ftiName + "_Terms"));
	    tjCollBat.insert("_Tags", bat("tj_" + ftiName + "_Tags"));
	    tjCollBat.insert("_TermIndex", bat("tj_" + ftiName + "_TermIndex"));
	    tjCollBat.insert("_TagIndex", bat("tj_" + ftiName + "_TagIndex"));
	    tjCollBat.insert("_TagSize", bat("tj_" + ftiName + "_TagSize"));
	}
	tjCollBat.insert("submitBats", new(void,str).seqbase(0@0));
	tjCollBat.insert("replaceBats", new(str,str));
	
	return tjCollBat;
}

PROC _tj_commit(BAT[str,bat] collBat) : void
{
      var replaceBats := collBat.find("replaceBats");
      replaceBats@batloop() {
      	 bat($t).persists(false).rename("del_" + $t);
	 collBat.find($h).persists(true).bbpname($t);
      }
    
      var submitBats := collBat.find("submitBats");
      submitBats.append([+](const "del_", replaceBats.tmark(0@0)));
     
      subcommit(submitBats);
}

ADDHELP("tj_add2collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str ftiName: the name of the collection.\n
- str uri_loc: the location of the xml document.\n
- str uri_name: the name of the xml document (optional).\n
- bit store: when true the doc is stored in pathfinder.\n\
DESCRIPTION:\n\
Add a document to a pftijah collection. The document is indexed and if the \n\
store parameter is true it is also stored in Pathfinder. When a document is\n\
not stored in Pathfinder it will be shredded on the fly when nodes from the\n\
document are returned by the XQUERY pftijah-node() function.\n\
The index is automatically finalized at the end of the method.",
"pftijah");
PROC tj_add2collection(str ftiName, str uri_loc, str uri_name, bit store) : void
{
    if ( verbose ) printf("#TJ:tj_add2collection(\"%s\",\"%s\",\"%s\") start.\n",ftiName,uri_loc,uri_name);
    var coll_lock := tj_get_collection_lock(ftiName);
    lock_set(coll_lock);
    var err := CATCH({
      var t_start := usec();
      bat(_tj_TermBat(ftiName)).access(BAT_APPEND);
      bat(_tj_TagBat(ftiName)).access(BAT_APPEND);
      bat(_tj_RTagBat(ftiName)).access(BAT_APPEND);
      var collBat := _tj_collection(ftiName);
      _tj_add2collection(ftiName, collBat, uri_loc, uri_name, store);
      _tj_finalize_collection(ftiName, collBat, FALSE);
      _tj_commit(collBat); 
      if ( timing ) {
         var ms := (usec()-t_start)/1000;
         printf("#C[%s]:tj_add2collection(): + aggregate time = %lld.%03llds.\n",ftiName,/(ms,1000),%(ms,1000));
       }
    });
    lock_unset(coll_lock);
    if (not(isnil(err))) ERROR(err);
}

ADDHELP("tj_add2collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str ftiName: the name of the collection.\n
- BAT[str,str]: the bat containing the [location,name] pairs of the xml docs.\n\
- bit store: when true the documents are stored in Pathfinder.\n\
DESCRIPTION:\n\
The multidocument version of tj_add2collection. The main difference with the\n\
other method is the [str,str] bat which contains the location of the document\n\
in the head and the name in the tail.\n\
The advantage of this method is that the collection is finalized after all\n\
xml documents in the bat are added to the collection.",
"pftijah");
PROC tj_add2collection(str ftiName, BAT[str,str] uri, bit store) : void
{
    var coll_lock := tj_get_collection_lock(ftiName);
    lock_set(coll_lock);
    var err := CATCH({
      var t_start := usec();
      bat(_tj_TermBat(ftiName)).access(BAT_APPEND);
      bat(_tj_TagBat(ftiName)).access(BAT_APPEND);
      bat(_tj_RTagBat(ftiName)).access(BAT_APPEND);
      var collBat;
      collBat := _tj_collection(ftiName);
      uri@batloop() {
        _tj_add2collection(ftiName, collBat, $h, $t, store);
      }
      _tj_finalize_collection(ftiName, collBat, FALSE);
      if ( timing ) {
         var ms := (usec()-t_start)/1000;
         printf("#C[%s]:tj_add2collection(BAT): + aggregate time = %lld.%03llds.\n",ftiName,/(ms,1000),%(ms,1000));
       }
      _tj_commit(collBat); 
    });
    lock_unset(coll_lock);
    if (not(isnil(err))) ERROR(err);
}

PROC _timestr(lng v) : str
{
    return str(v/1000000) + "." + str(v/1000) + "xs";
}

# main internal add2collection() function.
PROC _tj_add2collection(str ftiName, BAT[str,bat] collBat, str uri_loc, str uri_name, bit store) : void
{ 
    var ms;
    var t_start := usec();
    if ( verbose ) printf("#TJ:_tj_add2collection(\"%s\",\"%s\",\"%s\") start.\n",ftiName,uri_loc,uri_name);

    var i_start;
    if ( store ) {
	var pf_collection := _tj_get_parameter(collBat,"pf_collection");
	if ( isnil(uri_loc) and isnil(uri_name) ) {
	    ERROR("_tj_add2collection: should specify doc_name or doc_uri.");
	}
        if ( isnil(uri_name) ) {
	  uri_name := uri_loc;
	} else if ( uri_name = "" ) {
	  uri_name := uri_loc;
	}
        var ws := ws_create();
        if (not(bat("doc_name").reverse().exist(uri_name))) {
            var s_start := usec();
	    if ( isnil(pf_collection) ) {
    	        shred_doc(uri_loc,uri_name);
	    } else {
    	        shred_doc(uri_loc,uri_name,pf_collection,0LL);
	    }
            if ( timing ) {
	      ms := (usec()-s_start)/1000;
              printf("#C[%s]:add2coll(\"%s\"): shred time = %lld.%03llds.\n",ftiName,uri_name,/(ms,1000),%(ms,1000));
            }
        } else {
            if ( verbose ) printf("#TJ:_tj_add2collection(%s,..) doc(\"%s\") already shredded.\n",ftiName,uri_name);
	}
        ws_opendoc(ws, bat(void,str,1).append(uri_name));
	i_start := usec();
        if ( verbose ) printf("#TJ:_tj_throw2collection(cb(%s),ws,\"%s\") call next.\n",ftiName,uri_name);
        _tj_throw2collection(collBat,ws,uri_name);
        ws_destroy(ws);
    } else {
	i_start := usec();
        _tj_throw2collection_index(collBat,uri_loc);
    }
    if ( timing ) {
	ms := (usec()-i_start)/1000;
        printf("#C[%s]:add2coll(\"%s\"): index time = %lld.%03llds.\n",ftiName,uri_name,/(ms,1000),%(ms,1000));
    }
           
    _tj_set_parameter(collBat, "status", "building");
    if ( verbose ) printf("#TJ:_tj_add2collection(\"%s\") finish.\n",ftiName);
    if ( timing ) {
	ms := (usec()-t_start)/1000;
        printf("#C[%s]:add2coll(\"%s\"): total time = %lld.%03llds.\n",ftiName,uri_name,/(ms,1000),%(ms,1000));
    }
}

# internal finalize function
PROC _tj_finalize_collection(str ftiName, BAT[str,bat] collBat, bit fforce) : void
{
    var t_start := usec();
    if ( verbose ) printf("#TJ:_tj_finalize_collection(\"%s\") called.\n",ftiName);
    var parambat := bat("tj_" + ftiName + "_param");
    if ( not(fforce) ) {
        var delfin   := lng(parambat.find("delay_finalize"));
        if ( delfin > lng(0) ) {
            var finlast  := lng(parambat.find("_last_finalizedPre"));
            var prelast  := lng(parambat.find("_last_tijahPre"));
            var fdelta   := prelast - finlast;
	    if ( (prelast - finlast) < delfin ) {
                  if ( verbose ) printf("#TJ:_tj_finalize_collection(\"%s\") delaying finalization (%d < %d).\n",ftiName,int(fdelta),int(delfin));
		  return;
	    } else {
                  if ( verbose ) printf("#TJ:_tj_finalize_collection(\"%s\") finalization treshhold reached (%d > %d).\n",ftiName,int(fdelta),int(delfin));
	    }
        }
    }
    #
    var mod_frags := _tj_chk_modified_fragments(ftiName, collBat); 
    # set all fragments except the last one to BAT_READ
    mod_frags@batloop()
    {
        bat($t).access(BAT_READ);
	bat($t).mmap(1);
	collBat.find("submitBats").append($t);
    }
    collBat.find("_size").access(BAT_APPEND).mmap(1);
    collBat.find("_tid").access(BAT_APPEND).mmap(1);
    collBat.find("_pfpre").access(BAT_APPEND).mmap(1);
    var fpfx := str(collBat.find("_fragments").count());
    collBat.find("submitBats").append("tj_" + ftiName + "_size" + fpfx);
    collBat.find("submitBats").append("tj_" + ftiName + "_tid" + fpfx);
    collBat.find("submitBats").append("tj_" + ftiName + "_pfpre");
    collBat.find("submitBats").append("tj_" + ftiName + "_fragments");
    collBat.find("submitBats").append("tj_" + ftiName + "_doc_name");
    collBat.find("submitBats").append("tj_" + ftiName + "_doc_firstpre");
    collBat.find("submitBats").append("tj_" + ftiName + "_param");
    
    _buildIRindex(ftiName, collBat);
    #
    _tj_set_parameter(collBat, "status", "finalized");
    var lst_fpre := parambat.find("_last_tijahPre");
    _tj_set_parameter(collBat, "_last_finalizedPre", lst_fpre);
    #
    if ( false ) {
    	# we now do hash lookups and always ensure there's a hash table on the
	# dictionarys when querying
        var gterm_sort := bat(_tj_TermBat(ftiName)).reverse().sort().reverse();
        gterm_sort.access(BAT_APPEND);
        gterm_sort.mmap(1);
        var gtag_sort := bat(_tj_TagBat(ftiName)).reverse().sort().reverse();
        gtag_sort.access(BAT_APPEND);
        gtag_sort.mmap(1);

        collBat.replace("_globalTerms", gterm_sort);
        collBat.replace("_globalTags", gtag_sort);
        var replaceBats := collBat.find("replaceBats");
        replaceBats.insert("_globalTerms", _tj_TermBat(ftiName));
        replaceBats.insert("_globalTags", _tj_TagBat(ftiName));
        replaceBats.insert("_globalTags", _tj_RTagBat(ftiName));
    
    }
    collBat.find("submitBats").append(_tj_TermBat(ftiName));
    collBat.find("submitBats").append(_tj_TagBat(ftiName));
    collBat.find("submitBats").append(_tj_RTagBat(ftiName));
    
    if ( timing ) {
        var ms := (usec()-t_start)/1000;
        printf("#C[%s]:finalize(): total time = %lld.%03llds.\n",ftiName,/(ms,1000),%(ms,1000));
    }
}

# set a collection parameter
PROC _tj_set_parameter(BAT[str,bat] collBat, str par, str val) : void
{
	var parbat := collBat.find("_param");

	if ( parbat.exist(par) ) {
	    parbat.replace(par,val);
	} else {
	    parbat.insert(par,val);
	}
}

# set a collection parameter
PROC tj_set_parameter(str ftiName, str par, str val) : void
{
    if ( verbose ) printf("#TJ:tj_set_parameterl(%s,%s,%s) called.\n",ftiName,par,val);
    var coll_lock := tj_get_collection_lock(ftiName);
    lock_set(coll_lock);
    var err := CATCH({
	var parbat := bat("tj_" + ftiName + "_param");

	if ( parbat.exist(par) ) {
	    parbat.replace(par,val);
	} else {
	    parbat.insert(par,val);
	}
    });
    lock_unset(coll_lock);
    if (not(isnil(err))) ERROR(err);
}

# get a collection parameter
PROC _tj_get_parameter(BAT[str,bat] collBat, str par) : str
{
	var parbat := collBat.find("_param");

	if ( parbat.exist(par) ) {
	    return parbat.find(par);
	} else {
	    return str(nil);
	}
}

PROC tj_dump_collection(str ftiName) : void
{
    var coll_lock := tj_get_collection_lock(ftiName);
    lock_set(coll_lock);
    var err := CATCH({
	bat("tj_" + ftiName + "_param").print();
	bat("tj_" + ftiName + "_doc_name").print();
	bat("tj_" + ftiName + "_doc_firstpre").print();
	# print(bat("tj_" + ftiName + "_doc_name"),bat("tj_" + ftiName + "_doc_firstpre"));
	bat(_tj_TermBat(ftiName)).print();
	bat(_tj_TagBat(ftiName)).print();
	print(bat("tj_" + ftiName + "_tid1"));
	print(bat("tj_" + ftiName + "_size1"));
	print(bat("tj_" + ftiName + "_pfpre"));
	print(bat("tj_" + ftiName + "_fragments"));
	# print(bat("tj_" + ftiName + "_height"));
    });
    lock_unset(coll_lock);
    if (not(isnil(err))) ERROR(err);
}

PROC tj_size_collection(str ftiName) : void
{
    var sum := batdsksize(bat("tj_" + ftiName + "_tagdict"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_termdict"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_Tags"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_Terms"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_TagIndex"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_TermIndex"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_TagSize"));
    print(sum);
}

PROC tj_size_collection2(str ftiName) : void
{
    var sum := batdsksize(bat("tj_" + ftiName + "_tagdict"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_termdict"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_Tags"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_Terms"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_TagIndex"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_TermIndex"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_size1"));
    print(sum);
}

#####################################################################
#                                                                   #
# The query section				                    #
#                                                                   #
#####################################################################

# tijah function to 'package' a pathfinder [iter|item|kind|pos] operand
PROC tj_pfop(	BAT[void,oid] iter,
		BAT[void,any] item,
		BAT[void,int] kind,
		BAT[void,oid] pos) : BAT[void,bat] :=
{
	var res := new(void,bat).seqbase(0@0);

	res.append(iter);
	res.append(item);
	res.append(kind);
	res.append(pos);

	return res;
}

# universal tijah query function handler. Sould work in the milprint_summer
# and in the algebra context.
PROC tj_query_handler(
	bit par_storeScore,
	BAT[void,bat] pfop_sn,
	BAT[void,bat] pfop_query,
	BAT[void,bat] pfop_opt,
	BAT[oid,any]  par_loop,
	BAT[oid,bat]  par_ws,
	BAT[void,lng] par_int_values,
	BAT[void,dbl] par_dbl_values,
        BAT[void,str] par_str_values,
	BAT[void,bat] par_scoreDB
	) : BAT[void,bat] :=
{
     var result_id;
     var result_iter;
     var result_item;
     var result_pos;
     var result_frag;

     if ( par_storeScore ) {
      result_id   := new(void,lng).seqbase(0@0);
     } else {
      result_iter := new(void,oid).seqbase(0@0);
      result_item := new(void,oid).seqbase(0@0);
      result_pos  := new(void,oid).seqbase(0@0);
      result_frag := new(void,oid).seqbase(0@0);
     }

     var has_sn      := (pfop_sn.count() > 0);
     var has_options := (pfop_opt.count() > 0);

     par_loop@batloop() { # begin batloop over queries
      var optbat;
      if ( has_options ) {
       iter := pfop_opt.fetch(0@0).select($t);
       item := pfop_opt.fetch(1@0).semijoin(iter);
       kind := pfop_opt.fetch(2@0).semijoin(iter);
       iter := iter.tmark(0@0);
       item := item.tmark(0@0);
       kind := kind.tmark(0@0);
       optbat := serialize_tijah_opt(par_ws,1,iter,iter,item,kind,par_int_values,par_dbl_values,par_str_values);
      } else {
       optbat := new(str,str,32);
      }
      var ftindex := tj_get_ft_index(optbat,true);
      tijah_lock := tj_get_collection_lock(ftindex);
      lock_set(tijah_lock);
      var startNodes;
      if ( has_sn ) {
       iter := pfop_sn.fetch(0@0);
       var iteration := pfop_query.fetch(0@0).fetch(int($h));
       iter := iter.select(iteration);
       item := pfop_sn.fetch(1@0).semijoin(iter);
       kind := pfop_sn.fetch(2@0).semijoin(iter);
       item := item.tmark(0@0);
       kind := kind.tmark(0@0);
       var xdoc_name := bat("tj_" + ftindex + "_doc_name");
       var xdoc_firstpre := bat("tj_" + ftindex + "_doc_firstpre");
       var xpfpre := bat("tj_" + ftindex + "_pfpre");
       var doc_loaded := reverse(par_ws.fetch(OPEN_CONT)).leftfetchjoin(par_ws.fetch(OPEN_NAME));
       startNodes := pf2tijah_node(xdoc_name,xdoc_firstpre,xpfpre,item,kind,doc_loaded);
      } else {
       startNodes := new(void,oid);
      }
      optbat.access(BAT_WRITE);
      optbat.insert("_query",pfop_query.fetch(1@0).fetch(int($h)));
      var nexi_allscores := run_tijah_query(ftindex,optbat,has_sn,startNodes);
      var nexi_score;
      if ( optbat.exist("returnNumber") ) {
       var retNum := int(optbat.find("returnNumber"));
       nexi_score := nexi_allscores.slice(0, retNum - 1);
      } else {
       nexi_score := nexi_allscores;
      }
      var docpre := bat("tj_" + ftindex + "_doc_firstpre").[oid]();
      var pfpre :=  bat("tj_" + ftindex + "_pfpre");
      item  := nexi_score.hmark(0@0);
      var frag := [find_lower](const docpre.reverse().mark(0@0), item);
      item := item.join(pfpre).sort().tmark();
      var needed_docs := bat("tj_" + ftindex + "_doc_name").semijoin(frag.tunique());
      lock_unset(tijah_lock);
      tijah_lock := lock_nil;
      var loaded_docs := par_ws.fetch(OPEN_NAME).reverse();
      var docs_to_load := kdiff(needed_docs.reverse(),loaded_docs).hmark(0@0);
      ws_opendoc(par_ws, docs_to_load);
      var doc_loaded := reverse(par_ws.fetch(OPEN_CONT)).leftfetchjoin(par_ws.fetch(OPEN_NAME));
      var fid_pffid := needed_docs.join(doc_loaded.reverse());
      frag := frag.join(fid_pffid).sort().tmark();
      if ( par_storeScore ) {
       var tID := oid(par_scoreDB.fetch(0@0).count() + 10000);
       par_scoreDB.fetch(4@0).insert(lng(tID),lng(nexi_allscores.count()));
       par_scoreDB.fetch(0@0).append(item.project(tID));
       par_scoreDB.fetch(1@0).append(frag);
       par_scoreDB.fetch(2@0).append(item);
       par_scoreDB.fetch(3@0).append(nexi_score.tmark());
       result_id.append(lng(tID));
      } else {
       result_iter.append(item.project($t));
       result_pos.append(item.mark(1@0));
       result_frag.append(frag);
       result_item.append(item);
      }
     } # end batloop over queries
     if ( par_storeScore ) {
      item := int_values.addValues(result_id).tmark(0@0);
      iter := par_loop.tmark(oid(0));
      ipik := iter;
      pos  := oid(1);
      kind := INT;
     } else {
      iter := result_iter;
      pos := result_pos;
      kind := set_kind(result_frag, ELEM);
      item := result_item;
      ipik := iter;
     }
     var res := tj_pfop(iter.materialize(ipik),item.materialize(ipik),kind.materialize(ipik),pos.materialize(ipik));
     #
     return res;
}

PROC run_tijah_query(str ftiName, BAT[str,str] opt, bit use_startnodes, BAT[void,oid] nodes) : BAT[oid,dbl] :=
{
	if ( verbose ) printf("#TJ:run_tijah_query(\"%s\",..) called.\n",ftiName);
	var parambat := bat("tj_" + ftiName + "_param");
	var delfin   := lng(parambat.find("delay_finalize"));
        if ( delfin > lng(0) ) {
	    if ( verbose ) printf("#TJ:run_tijah_query(\"%s\",..) checking delayed finalize.\n",ftiName);
            var finlast  := lng(parambat.find("_last_finalizedPre"));
            var prelast  := lng(parambat.find("_last_tijahPre"));
	    if ( not(prelast=finlast) ) {
	        if ( verbose ) printf("#TJ:run_tijah_query(\"%s\",..) performing delayed finalize (%d != %d).\n",ftiName,int(finlast),int(prelast));
                var collBat := _tj_collection(ftiName);
                _tj_finalize_collection(ftiName, collBat, TRUE);
                _tj_commit(collBat); 
	    }
	}
	return _run_tijah_query(opt,use_startnodes,nodes);
}

#####################################################################
#								    #
#								    #
# Experimental algebra section					    #
#								    #
#								    #
#####################################################################

# tijah function to 'package' an algebra [iter|item|kind|pos] operand
PROC ALG_tj_pfop(
		BAT[oid,oid] iter,
		BAT[oid,any] item,
		int          noKind,
		BAT[oid,oid] pos) : BAT[void,bat] :=
{
	var res := new(void,bat).seqbase(0@0);

	res.append(iter);
	res.append(item);
	res.append(item.project(0));
	res.append(pos);

	return res;
}

PROC ALG_tj_pfop(
		BAT[oid,oid] iter,
		BAT[oid,any] item,
		BAT[oid,oid] frag,
		BAT[oid,oid] pos) : BAT[void,bat] :=
{
	var res := new(void,bat).seqbase(0@0);

	res.append(iter);
	res.append(item);
	res.append(frag);
	res.append(pos);

	return res;
}

PROC ALG_tj_ft_index_info(
	BAT[oid,bat]  par_ws,
	BAT[void,any] par_loop,
	BAT[oid,bat]  pfop_names
	) : BAT[void,bat] :=
{
        var ret;

	if ( pfop_names.count() > 0 ) {
	    ret := ws_ft_index_info(ws, pfop_names.fetch(1@0),false);

	} else {
	    ret := reverse(par_loop).cross(ws_ft_index_info(ws,false));
	}
	var iter := ret.hmark(0@0);
	var item := ret.tmark(0@0);
	var ipik := item;
	var frag := WS;
	frag     := frag.materialize(ipik);
	var pos  := tmark_grp_unique(iter,ipik);

        var res := ALG_tj_pfop(iter,item,frag,pos);
        if ( verbose ) printf("# ALG_tj_ft_index_info: FINISH.\n");
        return res;
}

PROC ALG_tj_query_nodes(
	BAT[void,any] par_loop,
	BAT[oid,bat]  pfop_id,
	BAT[oid,bat]  tijah_scoreDB
	) : BAT[void,bat] :=
{
        if ( verbose ) printf("# ALG_tj_query_nodes: START.\n");
	var item := new(void,oid).seqbase(0@0);
	var iter := new(void,oid).seqbase(0@0);
	var pos  := new(void,oid).seqbase(0@0);
	var frag := new(void,oid).seqbase(0@0);
	par_loop@batloop() { # begin of query batloop
	    var qid := oid(pfop_id.fetch(1).fetch(int($h)));
	    var tmp := tijah_scoreDB.fetch(0@0).ord_uselect(qid);
	    item.append(tmp.mirror().leftfetchjoin(tijah_scoreDB.fetch(2@0)));
	    iter.append(tmp.project(par_loop.fetch(int($h))));
	    frag.append(tmp.mirror().leftfetchjoin(tijah_scoreDB.fetch(1@0)));
	    pos.append(tmp.mark(1@0));
	} # end of query batloop
        var res := ALG_tj_pfop(iter,item,frag,pos);
        if ( verbose ) printf("# ALG_tj_query_nodes: FINISH.\n");
        return res;
}

PROC ALG_tj_query_score(
	BAT[void,any] par_loop,
	BAT[oid,bat]  pfop_id,
	BAT[oid,bat]  pfop_nodes,
	BAT[oid,bat]  tijah_scoreDB
	) : BAT[void,bat] :=
{
	var score := new(oid,dbl);
	var tmp := [<<]([lng](tijah_scoreDB.fetch(1@0)), const 32);
	var tijah_fragpre := [+](tmp, [lng](tijah_scoreDB.fetch(2@0)));
	tmp := nil;
	var item1_unique := pfop_id.fetch(1).tunique();
	var item := pfop_nodes.fetch(1);
	var kind := pfop_nodes.fetch(2);
	item1_unique@batloop() {
	    var item_part := item.semijoin(pfop_id.fetch(1).uselect($h));
	    var frag_part := kind.semijoin(item_part);
	    frag_part := [<<]([lng](frag_part), const 32);
	    var fragpre_part := [+](frag_part, [lng](item_part));

	    item_part := nil;
	    frag_part := nil;
	    tmp := tijah_scoreDB.fetch(0@0).uselect(oid($h));
	    tmp := tmp.mirror().leftfetchjoin(tijah_fragpre);
	    tmp := tmp.join(fragpre_part.reverse());
	    score.insert(tmp.reverse().leftfetchjoin(tijah_scoreDB.fetch(3@0)));
	}
	var xitem := kdiff(item,score).project(dbl(0));
	score.insert(xitem);
	xitem := nil;
	score := score.sort().tmark(0@0);

        var iter := par_loop.tmark(0@0);
	var ipik := iter;
	var pos  := 1@0;
        var res := ALG_tj_pfop(iter,score,0,pos.materialize(ipik));
        if ( verbose ) printf("# ALG_tj_query_nodes: FINISH.\n");
        return res;
}

# temporary algebra query handler
PROC ALG_tj_query_handler(
	bit par_storeScore,
	BAT[oid,bat] pfop_sn,
	BAT[oid,bat] pfop_query,
	BAT[oid,bat] pfop_opt,
	BAT[void,any]  par_loop,
	BAT[oid,bat]  par_ws,
	BAT[oid,bat] par_scoreDB
	) : BAT[void,bat] :=
{
     var result_id;
     var result_iter;
     var result_item;
     var result_pos;
     var result_frag;

    if ( verbose ) printf("# ALG_tj_query_handler: START.\n");
     if ( par_storeScore ) {
      if ( verbose ) printf("# ALG_tj_query_handler: storeScore=TRUE.\n");
      result_id   := new(void,lng).seqbase(0@0);
     } else {
      if ( verbose ) printf("# ALG_tj_query_handler: storeScore=FALSE.\n");
      result_iter := new(void,oid).seqbase(0@0);
      result_item := new(void,oid).seqbase(0@0);
      result_pos  := new(void,oid).seqbase(0@0);
      result_frag := new(void,oid).seqbase(0@0);
     }

     var has_sn      := (pfop_sn.count() > 0);
     var has_options := (pfop_opt.count() > 0);

     par_loop@batloop() {
      var optbat;
      if ( verbose ) printf("# ALG_tj_query_handler: loop start, id=%d.\n",$t);
      if ( has_options ) {
       if ( verbose ) printf("# ALG_tj_query_handler: running option handler.\n");
       var opt_iter := pfop_opt.fetch(0@0).select($t);
       var opt_item := pfop_opt.fetch(1@0).semijoin(opt_iter);
       var opt_kind := pfop_opt.fetch(2@0).semijoin(opt_iter);
       opt_iter := opt_iter.tmark(0@0);
       opt_item := opt_item.tmark(0@0);
       opt_kind := opt_kind.tmark(0@0);
       optbat := serialize_tijah_opt(par_ws,1,opt_iter,opt_iter,opt_item,set_kind(opt_kind,ELEM),new(void,lng),new(void,dbl),new(void,str));
       if ( verbose ) optbat.print();
      } else {
       optbat := new(str,str,32);
      }
      if ( verbose ) printf("# ALG_tj_query_handler: handle startNodes.\n");
      var ftindex := tj_get_ft_index(optbat,true);
      var tijah_lock := tj_get_collection_lock(ftindex);
      lock_set(tijah_lock);
      var startNodes;
      if ( has_sn ) {
       var sn_iter := pfop_sn.fetch(0@0);
       var sn_iteration := pfop_query.fetch(0@0).fetch(int($h));
       sn_iter := sn_iter.select(sn_iteration);
       var sn_item := pfop_sn.fetch(1@0).semijoin(sn_iter);
       var sn_kind := pfop_sn.fetch(2@0).semijoin(sn_iter);
       sn_item := sn_item.tmark(0@0);
       sn_kind := sn_kind.tmark(0@0);

       var xdoc_name := bat("tj_" + ftindex + "_doc_name");
       var xdoc_firstpre := bat("tj_" + ftindex + "_doc_firstpre");
       var xpfpre := bat("tj_" + ftindex + "_pfpre");
       var doc_loaded := reverse(par_ws.fetch(OPEN_CONT)).leftfetchjoin(par_ws.fetch(OPEN_NAME));
       if ( verbose ) printf("# ALG_tj_query_handler: compute startnodes\n");
       startNodes := pf2tijah_node(xdoc_name,xdoc_firstpre,xpfpre,sn_item,[int](sn_kind),doc_loaded);
      } else {
       startNodes := new(void,oid);
      }
      optbat.access(BAT_WRITE);
      optbat.insert("_query",pfop_query.fetch(1@0).fetch(int($h)));
      if ( verbose ) printf("# ALG_tj_query_handler: run tijah query.\n");
      var nexi_allscores := run_tijah_query(ftindex,optbat,has_sn,startNodes);
      var nexi_score;
      if ( verbose ) printf("# ALG_tj_query_handler: handling scores.\n");
      if ( optbat.exist("returnNumber") ) {
       var retNum := int(optbat.find("returnNumber"));
       nexi_score := nexi_allscores.slice(0, retNum - 1);
      } else {
       nexi_score := nexi_allscores;
      }
      var docpre := bat("tj_" + ftindex + "_doc_firstpre").[oid]();
      var pfpre  :=  bat("tj_" + ftindex + "_pfpre");
      var item   := nexi_score.hmark(0@0);
      var frag := [find_lower](const docpre.reverse().mark(0@0), item);
      item := item.join(pfpre).sort().tmark();
      var needed_docs := bat("tj_" + ftindex + "_doc_name").semijoin(frag.tunique());
      lock_unset(tijah_lock);
      if ( verbose ) printf("# ALG_tj_query_handler: released lock.\n");
      tijah_lock := lock_nil;
      var loaded_docs := par_ws.fetch(OPEN_NAME).reverse();
      var docs_to_load := kdiff(needed_docs.reverse(),loaded_docs).hmark(0@0);
      ws_opendoc(par_ws, docs_to_load);
      var doc_loaded := reverse(par_ws.fetch(OPEN_CONT)).leftfetchjoin(par_ws.fetch(OPEN_NAME));
      var fid_pffid := needed_docs.join(doc_loaded.reverse());
      frag := frag.join(fid_pffid).sort().tmark();
      if ( verbose ) printf("# ALG_tj_query_handler: handled new frags/documents.\n");
      if ( par_storeScore ) {
       var tID := oid(par_scoreDB.fetch(0@0).count() + 8888);
       par_scoreDB.fetch(4@0).insert(lng(tID),lng(nexi_allscores.count()));
       par_scoreDB.fetch(0@0).append(item.project(tID));
       par_scoreDB.fetch(1@0).append(frag);
       par_scoreDB.fetch(2@0).append(item);
       par_scoreDB.fetch(3@0).append(nexi_score.tmark());
       result_id.append(lng(tID));
       if ( verbose ) printf("# ALG_tj_query_handler: stored loop score.\n");
      } else {
       result_iter.append(item.project($t));
       result_pos.append(item.mark(1@0));
       result_frag.append(frag);
       result_item.append(item);
       if ( verbose ) printf("# ALG_tj_query_handler: stored loop nodes in result.\n");
      }
      if ( verbose ) printf("# ALG_tj_query_handler: loop finish, id=%d.\n",$t);
     } # end batloop over queries
     if ( verbose ) printf("# ALG_tj_query_handler: batloop finished.\n");
     var iter;
     var item;
     var ipik;
     var kind;
     var pos;
     if ( par_storeScore ) {
      if ( verbose ) printf("# ALG_tj_query_handler: create int return.\n");
      item := result_id;
      iter := par_loop.tmark(oid(0));
      ipik := iter;
      pos  := oid(1);
      kind := new(oid,oid);
     } else {
      if ( verbose ) printf("# ALG_tj_query_handler: create node return.\n");
      iter := result_iter;
      pos  := result_pos;
      kind := result_frag;
      item := result_item;
      ipik := iter;
     }
      if ( verbose ) {
	 printf("# ALG_tj_query_handler: iter/item/kind/pos result start\n");
         iter.print();
         item.print();
	 kind.print();
	 pos.print();
	 printf("# ALG_tj_query_handler: iter/item/kind/pos result finish\n");
      }
     var res := ALG_tj_pfop(iter,item,kind,pos.materialize(ipik));
     #
     if ( verbose ) printf("# ALG_tj_query_handler: FINISH.\n");
     return res;
}

PROC ALG_tj_add_fti_tape(
	str           op,
	BAT[oid,bat]  pfop_coll,
	BAT[oid,bat]  pfop_opt,
	BAT[void,any] par_loop,
	BAT[oid,bat]  par_ws,
	BAT[str,bat]  tape
	) : BAT[str,bat] :=
{
        if ( verbose ) printf("# ALG_tj_add_fti_tape: START.\n");
        var has_coll := (pfop_coll.count() > 0);
        var has_opt  := (pfop_opt.count() > 0);
        par_loop@batloop() {
            if ( verbose ) printf("# ALG_tj_query_handler: loop start, id=%d.\n",$t);

	    var collbat;
	    if ( has_coll ) {
       	        if ( verbose ) printf("# ALG_tj_add_fti_tape: start collection handler.\n");
       		var iter := pfop_coll.fetch(0@0).select($t);
       		collbat := pfop_coll.fetch(1@0).semijoin(iter);

		if ( collbat.select("*").count() > 0 ) {
			ERROR("not possible to use wildcards for pfcollections.");
		}
	    } else {
       	        if ( verbose ) printf("# ALG_tj_add_fti_tape: no collection.\n");
	        collbat := new(void,str).seqbase(0@0);
		collbat.append("*");
	    }

	    var optbat;
            if ( has_opt ) {
       	        if ( verbose ) printf("# ALG_tj_add_fti_tape: running option handler.\n");
       		var opt_iter := pfop_opt.fetch(0@0).select($t);
       		var opt_item := pfop_opt.fetch(1@0).semijoin(opt_iter);
       		var opt_kind := pfop_opt.fetch(2@0).semijoin(opt_iter);
       		opt_iter := opt_iter.tmark(0@0);
       		opt_item := opt_item.tmark(0@0);
       		opt_kind := opt_kind.tmark(0@0);
       		optbat := serialize_tijah_opt(par_ws,1,opt_iter,opt_iter,opt_item,set_kind(opt_kind,ELEM),new(void,lng),new(void,dbl),new(void,str));
       		if ( verbose ) optbat.print();
            } else {
       	        if ( verbose ) printf("# ALG_tj_add_fti_tape: no options.\n");
                optbat := new(str,str,32);
            } 

            if ( verbose ) printf("# ALG_tj_query_handler: writing tape.\n");
	    var bb := new(void,bat).seqbase(0@0);
	    bb.append(collbat);
	    bb.append(optbat);
	    tape.insert(op,bb);
	    if ( verbose ) tape.print();
            if ( verbose ) printf("# ALG_tj_query_handler: end loop start, id=%d.\n",$t);
	}
        if ( verbose ) printf("# ALG_tj_add_fti_tape: FINISH.\n");
	return tape;
}

#PROC DocmgmTape(BAT[void,BAT] ws,
#                BAT[void,str] location,
#                BAT[void,str] docname,
#                BAT[void,str] colname,
#                BAT[void,lng] percentage) : void
#{
#    var del_doc := percentage.ord_uselect(-1LL).hmark(0@0);
#    var add_doc := percentage.ord_uselect(0LL,lng_nil).hmark(0@0);
#
#    shred_doc_base(del_doc(bit_nil, del_doc.leftfetchjoin(docname), true),
#                   add_doc.leftfetchjoin(location),
#                   add_doc.leftfetchjoin(docname),
#                   add_doc.leftfetchjoin(colname),
#                   add_doc.leftfetchjoin(percentage),
#                   stream_nil, ws_id(ws));
#}

PROC ALG_tj_docmgmt_tape(BAT[str,bat] tape,
		      	 BAT[void,BAT] ws,
                	 BAT[void,str] location,
                	 BAT[void,str] docnames,
                	 BAT[void,str] colnames,
                	 BAT[void,lng] percentages) : bit :=
{
        if ( verbose ) printf("# ALG_tj_docmgmt_tape: START.\n");
	#
	# INCOMPLETE, CHECK IF THIS REALLY STILL WORKS
	#
        if (isnil(CATCH(bat("tj_collName").count()))) {
	    # pftijah is active
            if ( verbose ) printf("# ALG_tj_docmgmt_tape: running document management.\n");
            var del_doc    := percentages.ord_uselect(-1LL).hmark(0@0); 
            var add_doc    := percentages.ord_uselect(0LL,lng_nil).hmark(0@0); 
	    if ( verbose ) {
	        printf("# ALG_tj_docmgmt_tape: deleted docs are:\n");
	        del_doc.print();
	        printf("# ALG_tj_docmgmt_tape: added docs are:\n");
	        add_doc.print();
	    }
            #
            var pfc_name   := docnames.reverse().leftfetchjoin(colnames);
            var pfdep      := bat("tj_pfc_fti_dep");
            var pfdep_star := bat("tj_pfc_fti_dep_star");
            var fti_dname  := pfdep.join(pfc_name.reverse());
            if ( pfdep_star.count() > 0 ) {
                fti_dname.insert(pfdep_star.cross(pfc_name.reverse()));
            }

            var fti_cluster := new(str,bat);
            fti_dname@batloop() {
                var cb;
                if ( fti_cluster.exist($h) ) {
                  cb := fti_cluster.find($h);
                } else {
                  cb := new(str,str);
                  fti_cluster.insert($h,cb);
                }
                cb.insert(str(nil),$t);
            }
            fti_cluster@batloop() {
                if ( verbose ) { printf("#TJ:tj_play_doc_tape() doing ft-index \"%s\".\n",$h); $t.print(); }
                tj_add2collection($h,$t,true);
            }
	} else {
	    # pftijah is not active
	    if ( verbose ) printf("# ALG_tj_docmgmt_tape: skipping doc managemnt.\n");
	}

        if ( verbose ) printf("# ALG_tj_docmgmt_tape: running collection management.\n");
        tape@batloop() {
	    var op       := $h;
	    var collbat  := $t.fetch(0@0);
	    var optbat   := $t.fetch(1@0);
	    var fti_name := tj_get_ft_index(optbat,(op!="create"));

	    if ( op = "create" ) {
                if ( verbose ) printf("# ALG_tj_docmgmt_tape: tj_init_collection(%s).\n",fti_name);
	        tj_init_collection(fti_name,optbat,collbat);
	    } else if ( op = "extend" ) {
                if ( verbose ) printf("# ALG_tj_docmgmt_tape: tj_extend_collection(%s).\n",fti_name);
	        tj_extend_collection(fti_name,collbat);
	    } else if ( op = "remove" ) {
                if ( verbose ) printf("# ALG_tj_docmgmt_tape: tj_delete_collection(%s).\n",fti_name);
	        tj_delete_collection(fti_name);
	    } else {
	    	ERROR("ALG_tj_docmgmt_tape: unknown op");
	    }
	}
        if ( verbose ) printf("# ALG_tj_docmgmt_tape: FINISH.\n");
	return true;
}

# INCOMPLETE: henning, what should I do about this (no locking impl).
PROC tj_setBackgroundCollName(str name, BAT[oid,str] qenv) : BAT[void,str] := 
{
	if (not(isnil(CATCH(bat("tj_collName").count())))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(name))) {
		ERROR("background collection \"%s\"does not exist",name);
	}
	return create_qenv(qenv.find(QENV_FTINAME),name,qenv.find(QENV_SCOREBASE));
}

# INCOMPLETE: henning, what should I do about this.
var equivalences := new(str,str);
PROC tj_initEquivalences() : void := 
{
    equivalences := new(str,str);
}

# INCOMPLETE: henning, what should I do about this.
PROC tj_addEquivalenceClass( bat elements ) : void := 
{
    # Create cross product of class elements
    var class := eqclass.reverse().cross( eqclass );
    # Append to equivalences table
    equivalences := equivalences.insert( class );
}

var tracefile_handle := nil;
PROC tj_trace( str s ) : void := 
{
    if ( not( tracefile = "" ) ) {
        if ( isnil( tracefile_handle ) )
            tracefile_handle := open_wastream(tracefile);
        
        tracefile_handle.stream_write( sprintf( "%d %s\n", int(msec()/1000), s ) );
        tracefile_handle.stream_flush();
    }
}

#
#
#

PROC tj_is_indexed(str collName) : bit :=
{
    if (isnil(CATCH(bat("tj_pfc_fti_dep").count()))) {
	if ( bat("tj_pfc_fti_dep_star").count() > 0 ) {
	    # eg. all collections are indexed
            return TRUE;
	} else {
	    return bat("tj_pfc_fti_dep").reverse().exist(collName);
	}
    } else {
        return FALSE;
    }
}

PROC tj_play_doc_tape(BAT[void,BAT] ws,
                      BAT[void,oid] item, 
                      BAT[void,int] kind, 
                      BAT[void,lng] int_values, 
                      BAT[void,str] str_values) : void
{
    if (isnil(CATCH(bat("tj_pfc_fti_dep").count()))) {
      if ( bat("tj_pfc_fti_dep").count() > 0 ) {
        if ( verbose ) printf("#TJ:tj_play_doc_tape() start.\n");
        var IDoid       := [and]([lng](item.mirror()), 3LL).ord_uselect(0LL).hmark(0@0);
        var IDlng       := IDoid.[lng]();
        var locations   := IDoid.leftfetchjoin(item).leftfetchjoin(str_values);
        var names       := [+](IDlng, 1).[oid]().leftfetchjoin(item).leftfetchjoin(str_values);
        var colnames    := [+](IDlng, 2).[oid]().leftfetchjoin(item).leftfetchjoin(str_values);
        var percentages := [+](IDlng, 3).[oid]().leftfetchjoin(item).leftfetchjoin(int_values);
        var del_doc     := percentages.ord_uselect(-1LL).hmark(0@0); 
        var add_doc     := percentages.ord_uselect(0LL,lng_nil).hmark(0@0); 
        #
        var pfc_name   := names.reverse().leftfetchjoin(colnames);
        var pfdep      := bat("tj_pfc_fti_dep");
        var pfdep_star := bat("tj_pfc_fti_dep_star");
        var fti_dname  := pfdep.join(pfc_name.reverse());
        if ( pfdep_star.count() > 0 ) {
            fti_dname.insert(pfdep_star.cross(pfc_name.reverse()));
        }

        var fti_cluster := new(str,bat);
        fti_dname@batloop() {
            var cb;
            if ( fti_cluster.exist($h) ) {
              cb := fti_cluster.find($h);
            } else {
              cb := new(str,str);
              fti_cluster.insert($h,cb);
            }
            cb.insert(str(nil),$t);
        }
        fti_cluster@batloop() {
            if ( verbose ) { printf("#TJ:tj_play_doc_tape() doing ft-index \"%s\".\n",$h); $t.print(); }
            tj_add2collection($h,$t,true);
        }
        if ( verbose ) printf("#TJ:tj_play_doc_tape() finished.\n");
      }
    }
}

const virtRoot := 0@0;

##
# Compute ancestor-descendant relation. 
#
# Forwards to anc_desc_llscj: see below.
##

PROC tj_nid2pre( bat[oid,any] nid_score, bat[oid,str] qenv ) : bat[oid,any] :=
{
    var cName := qenv.find(QENV_FTINAME);
    var res := nid_score.reverse().leftfetchjoin(bat("tj_" + cName + "_Tags")).reverse();
    return res;
}

PROC anc_desc( bat[oid,any] anc, bat[oid,any] desc, bat[oid,str] qenv ) : bat[oid,oid] :=
{
    var cName := qenv.find(QENV_FTINAME);
    var a_pre;
    var a_size;
    if (isnil(anc.fetch(0))) {
       var offset1 := int(anc.reverse().fetch(0));
       var offset2 := int(anc.reverse().fetch(1));
       a_pre := bat("tj_" + cName + "_Tags").slice(offset1, offset2).tsort();
       a_size := bat("tj_" + cName + "_TagSize").slice(offset1, offset2);
    } else {
       a_pre := bat("tj_" + cName + "_Tags").semijoin(anc).tsort();
       a_size := bat("tj_" + cName + "_TagSize");
    }
    var d_pre;
    if (isnil(desc.fetch(0))) {
       var offset1 := int(desc.reverse().fetch(0));
       var offset2 := int(desc.reverse().fetch(1));
       d_pre := bat("tj_" + cName + "_Tags").slice(offset1, offset2).tsort();
    } else {
       d_pre := bat("tj_" + cName + "_Tags").semijoin(desc).tsort();
    }
   
    var nested := false;
    if (qenv.find(QENV_RECURSIVE_TAGS) = "1") {nested := true;}
    var a_d;
    if (nested) {
       a_d := treemergejoin_sort(a_pre, a_size, d_pre);
    } else {
       a_d := treemergejoin_sort_unnested(a_pre, a_size, d_pre);
    }
    return a_d;
}


##
# Converts a list of query terms to a list of term ids
#
# Stemming on the query terms is performed using the same stemmer
# that was used for the collection.
##
PROC _terms2void_tid( bat[void,str] Qterms, str bg_cName): bat[void,oid] :=
{
    var param    := bat("tj_"+ bg_cName +"_param");
    var stemmer  := param.find("stemmer");
    var firstterm:= oid(param.find("lastStopWord"));
    var stemmed  := [tj_normalizeTerm]( [toLower](Qterms), stemmer );
    var tids := bat(_tj_TermBat(bg_cName)).join( stemmed.reverse() ).sort().hmark(oid(0));
    #var stopwords := tids.uselect(0@0,firstterm,TRUE,FALSE);
    #tids := tids.kdiff(stopwords);
    tids := tids.select(firstterm,oid(nil),TRUE,FALSE);
    return tids;
}


##
# Return only the element nodes from region ctx
##
PROC nodes( bat[oid,any] ctx, BAT[oid,str] qenv ) : bat[oid,any] :=
{
    # The pfpre table only stores element nodes, so we can use it as a filter:
    var pfpre  := bat( "tj_" + qenv.find(QENV_FTINAME) + "_pfpre");
    var result := ctx.semijoin(pfpre);
    return result;
}


##
# Return only the terms from region ctx
##
PROC terms( bat[oid,any] ctx, BAT[oid,str] qenv ) : bat[oid,any] :=
{
    # A term is everything that is not an element node
    var nodes  := nodes( ctx, qenv );
    var result := ctx.kdiff( nodes );
    return result;
}


################################################################################
# SELECTION
################################################################################

##
# Select the root node of the collection
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC select_root(bat[void,oid] par_startNodes, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( not( isnil( par_startNodes ) ) ) {
        # Start from a set of starting nodes if available. 
        # It is assumed that the startNodes are [any, pre]
        if ( count( par_startNodes ) > 0 ) {
            var root_reg := par_startNodes.reverse().sort().project( dbl(qenv.find(QENV_SCOREBASE)) );
            return root_reg;
        } else {
            var root_reg := new(oid,dbl,1);
            
            root_reg.insert( virtRoot, dbl(qenv.find(QENV_SCOREBASE)) );
            return root_reg;
        }
    } else {
        # Because TIJAH expects all documents in a collection to be contained by one 
        # "virtual root" element, this behaviour should be emulated by the light index. 
        # An element with preorder oid(0) will indicate that it is the collection root.
        var root_reg := new(oid,dbl,1);
        
        root_reg.insert( virtRoot, dbl(qenv.find(QENV_SCOREBASE)) );
        return root_reg;
    }
}

PROC select_root(BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var res := new(oid,dbl,1);
    res.insert(virtRoot, dbl(qenv.find(QENV_SCOREBASE)));
    return res;
}

PROC select_startnodes(bat[void,oid] startNodes, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var cName := qenv.find(QENV_FTINAME);
    var res := startNodes.join(bat("tj_" + cName + "_Tags").reverse()).reverse();
    res := res.project(dbl(qenv.find(QENV_SCOREBASE))).sort();
    if (res.count() = 0) tj_trace(sprintf("WARNING: start nodeset is empty")); 
    return res;
}

##
# Select all element nodes in the collection
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC select_node(BAT[oid,str] qenv) : bat[oid,dbl] := 
{
     if ( trace ) tj_trace( sprintf("BEGIN select_node('*')") );
     
     var cName := qenv.find(QENV_FTINAME);
     var index := bat("tj_" + cName + "_TagIndex");
     var offset1 := index.fetch(1);
     var offset2 := oid(int(index.fetch(index.count() - 1)) - 1);
     var res := new(void,oid).seqbase(0@0);
     res.append(offset1);
     res.append(offset2);
     res := res.reverse().project(dbl(nil)); 

     # set the recursive tag flag on "true" because all tags are selected
     modify_qenv(qenv,QENV_RECURSIVE_TAGS,"1");

     if ( trace ) tj_trace( sprintf("END select_node('*')") );
    
    return res;
}

##
# Select all element nodes in the collection with the given name
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC _getTagPositions(oid tid, str cName) : bat[void,oid] := {
     var index := bat("tj_" + cName + "_TagIndex");
     var offset1 := index.fetch(int(tid));
     var offset2 := oid(int(index.fetch(int(tid) + 1)) - 1);
     var res := new(void,oid).seqbase(0@0);
     res.append(offset1);
     res.append(offset2);
     return res;
}

PROC select_node(str name, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( sprintf("BEGIN select_node('%s')", name) );

    var tids := bat(_tj_TagBat(qenv.find(QENV_FTINAME))).select(name);
    if (tids.count() = 0) return new(oid,dbl);
    var tid := tids.reverse().fetch(0);

    var cName := qenv.find(QENV_FTINAME);
    # set the recursive tag flag on "true" because all tags are selected
    if ( bat(_tj_RTagBat(cName)).exist(tid) ) {
        modify_qenv(qenv,QENV_RECURSIVE_TAGS,"1");
    }
    # Henning changes
    var result := _getTagPositions(tid, cName); 
    result := result.reverse().project(dbl(nil)); 

    if ( trace ) tj_trace( sprintf("END   select_node('%s')", name) );
    return result;
}

PROC select_node(str name, bit e_class, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( e_class ) {
        printf("error occurred in select node. not supported class def feature.\n");
	return new(oid,dbl);
    } else {
        return select_node(name,qenv);
    }
}

PROC split2frag(bat[oid,any] nodes, bat[void,oid] frags) : bat[oid,bat] :=
{
    var res := new(oid,bat);
    
    var lst_frag := frags.reverse().fetch(frags.count() - 1);
    var i := 0;
    var j := nodes.count();
    while( i < j)
    {
    	var frag := find_lower(frags.reverse(), nodes.reverse().fetch(i));
        if (frag < lst_frag)
	{
	    var frag_limit := oid(int(frags.fetch(int(frag))) -1); #only correct if frag numbering starts at 1
	    var nodes_limit := int(find_lower(nodes.mark(0@0), frag_limit));
	    res.insert(frag, nodes.slice(i, nodes_limit));
            i := nodes_limit + 1;
	}
	if (frag = lst_frag)
	{
	    res.insert(frag, nodes.slice(i, j - 1));
            i := j;
	}
    }

    return res;
}

##
# Select all terms with the given value
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC select_term(str name, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( sprintf("BEGIN select_term('%s')", name) );
    # 
    var stemmer := bat("tj_"+ qenv.find(QENV_FTINAME) +"_param").find("stemmer");
    var term    := tj_normalizeTerm( toLower(name), stemmer );
    
    # Select the term positions from the global term dictionary.
    var tids := bat(tj_TermBat(qenv.find(QENV_FTINAME))).uselect(term).mark(0@0).sort().reverse();
    
    var result := indexfetchjoin( tids,
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_TermIndex"),
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_Terms") );
    result := result.reverse().sort().project(dbl(qenv.find(QENV_SCOREBASE))); 
    

    if ( trace ) tj_trace( sprintf("END   select_term('%s')", name) );
    return result;
}

##
# Select all terms with the given value, possibly performing stemming on the argument.
#
# This variant of the select_term function is present for compatibility reasons:
# at the moment, stemming is always performed using the same stemmer that was
# used to index the collection.
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC select_term(str name, int stemming, BAT[oid,str] qenv) : bat[oid,dbl] := 
{
    return select_term( name,qenv );
}


##
# Select a number of terms by their term-id.
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC select_phrase(bat[void,oid] terms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN select_phrase" );
    # Select the term positions from the global term dictionary. 
   
    var tid := terms.fetch(0);
    var tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_TermIndex"),
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_Terms") );
    var res := tmp.reverse();
    var j := terms.count();
    var i := 1; 
    while (i < j)
    {
        tid := terms.fetch(i);
        tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_TermIndex"),
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_Terms") );
        res := res.semijoin(tmp.[int]().[-](i).[oid]().reverse());   
	i :+= 1;
    }	
    
    res := res.sort().project(dbl(qenv.find(QENV_SCOREBASE))); 
    
    if ( trace ) tj_trace( "END   select_phrase" );
    return res;
}


################################################################################
# CONTAINMENT
################################################################################


#####################################
# left CONTAINED_BY right:
#
#   +--------------------+
#   |       right        |
#   | +---------------+  |
#   | |      left     |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it is contained a region in right
#
#####################################

PROC contained_by(bat[oid,dbl] left, bat[oid,dbl] right, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN contained_by" );
   
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(right) = 0 ) return new(oid,dbl);
    
    # Check for the virtual root
    if ( count(left) = 1 )
       if ( left.reverse().fetch(0) = virtRoot ) 
          return new(oid,dbl);
    if ( count( right ) = 1 )
       if ( right.reverse().fetch(0) = virtRoot ) 
          return left;
    
    var anc_desc := anc_desc( right, left, qenv );

    # Attach the scores to the resulting nodes again:
    var result;
    if (isnil(left.fetch(0))) {
       result := anc_desc.reverse().kunique().project(dbl(qenv.find(QENV_SCOREBASE)));
    } else {
       result := left.semijoin(anc_desc.reverse());
    }
    
    if ( trace ) tj_trace( "END contained_by" );
    return result.sort();
}

##
# Returns all regions in the collection that are contained by the argument. 
# Equivalent with a descendant step in XPath.
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##

PROC contained_by(bat[oid,dbl] region, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN contained_by" );

    var all_nodes := select_node(qenv);
    var result := contained_by(all_nodes, region, qenv);
    
    if ( trace ) tj_trace( "END  contained_by" );
    return result;
}


#####################################
# left CONTAINING right:
#
#   +--------------------+
#   |       left         |
#   | +---------------+  |
#   | |      right    |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it contains a region in right
#
#####################################

PROC containing(bat[oid,dbl] left, bat[oid,dbl] right, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN containing_" );
    
    # Check for the virtual root
    if ( count(left) = 1 )
       if ( left.reverse().fetch(0) = virtRoot ) 
          return right;
    if ( count( right ) = 1 )
       if ( right.reverse().fetch(0) = virtRoot ) 
          return new(oid,dbl);
    
    var anc_desc := anc_desc( left, right, qenv );
    
    # Attach the scores to the resulting nodes again:
    var result;
    if (isnil(left.fetch(0))) {
       result := anc_desc.project(dbl(qenv.find(QENV_SCOREBASE)));
    } else {
       result := left.semijoin(anc_desc);
    }
    
    if ( trace ) tj_trace( "END   containing_" );
    return result.sort();
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

# returns the pre-order positions of the term t 
# in the collection of the documents
PROC _getTermPositions(oid tid, BAT[oid,str] qenv) : bat[void,oid] := {
     var cName := qenv.find(QENV_FTINAME);
     var index := bat("tj_" + cName + "_TermIndex");
     var offset1 := int(index.fetch(int(tid)));
     var offset2 := int(index.fetch(int(tid) + 1));
     var res := bat("tj_" + cName + "_Terms").slice(offset1, offset2 - 1);
     res := res.seqbase(0@0).chk_order();
     return res;
}

# returns the collection count cCnt(t) of term t
# in the background collection
# (the background collection can be different from collection
# the documents are coming from) 
PROC _getTermColCnt(oid tid, BAT[oid,str] qenv) : int := {
     var bg_cName := qenv.find(QENV_FTIBGNAME);
     var index := bat("tj_" + bg_cName + "_TermIndex");
     var offset1 := int(index.fetch(int(tid)));
     var offset2 := int(index.fetch(int(tid) + 1));
     return (offset2 - offset1);
}

# returns the collection count cCnt(t) of term t
# in the background collection
# (the background collection can be different from collection
# the documents are coming from) 
PROC _getTermDocCnt(oid tid, BAT[oid,oid] e_pre, BAT[void,int] e_size, BAT[oid,str] qenv) : BAT[oid,int] := {
     
        # get term positions in the entire collection
        var t_pre := _getTermPositions(tid, qenv);
	
	# get doc - term relation
        var e_tPre;
        if (nested) {
           e_tPre := treemergejoin_sort(e_pre, e_size, t_pre);
        } else {
           e_tPre := treemergejoin_sort_unnested(e_pre, e_size, t_pre);
        }
	t_pre := nil;
        return e_tPre.reverse().histogram().sort();
}


#             ___          qCnt(t) 
# LM(d|q) =   | |    dLH(t) 
#            t in q           
#
# where qCnt(t) = count of term t in query q
# where dLH(t) = likelihood of term t in doc d
#
# NOTE by Djoerd: The current implementation of LM might retrieve
# documents if one or more terms have zero frequency in background-col
# which should not happen

PROC _score_LM(int q_tCnt, int qSize, int c_tCnt, int cSize, BAT[oid,int] e_tCnt, BAT[void,int] e_size, dbl cLambda) : bat[oid,dbl] := {
    var e_tScores := e_tCnt.[dbl]().access(BAT_WRITE);
    e_tScores.left_div(e_size);
    var tmp := e_tScores;
    while (q_tCnt > 1) {
        e_tScores := e_tScores.[*](tmp);
	q_tCnt :-= 1;
    }
    return e_tScores;
}


#              ___                                         qCnt(t)      
# LMs(d|q) =   | |    ( (1-lambda) dLH(t) + lambda cLH(t) ) 
#             t in q           
#
# where qCnt(t) = count of term t in query q
# where dLH(t) = likelihood of term t in doc d
# where cLH(t) = likelihood of term t in (background) collection c
#

PROC _score_LMs(int q_tCnt, int qSize, int c_tCnt, int cSize, BAT[oid,int] e_tCnt, BAT[void,int] e_size, dbl cLambda) : bat[oid,dbl] := {
    var tmp1 := cLambda * c_tCnt / dbl(cSize);
    var tmp2 := dbl(1) - cLambda;
    var e_tScores := e_tCnt.[dbl]().access(BAT_WRITE);
    e_tScores.left_div(e_size);
    e_tScores := e_tScores.[*](tmp2);
    e_tScores := e_tScores.[+](tmp1);
    tmp1 := e_tScores;
    while (q_tCnt > 1) {
        e_tScores := e_tScores.[*](tmp1);
	q_tCnt :-= 1;
    }
    return e_tScores;
}

#               __     qCnt(t)       /  (1 - lambda) * dLH(t)       \  
# NLLR(d|q) =   >_     ------- * log |  ----------------------  + 1 |  
#              t in q   qSize        \      lambda * cLH(t)         /  
#
# where qCnt(t) = count of term t in query q
# where qSize = number of terms in query q
# where dLH(t) = likelihood of term t in doc d
# where cLH(t) = likelihood of term t in (background) collection c
#

PROC _score_NLLR(int q_tCnt, int qSize, int c_tCnt, int cSize, BAT[oid,int] e_tCnt, BAT[void,int] e_size, dbl cLambda) : bat[oid,dbl] := {
    var collFac := ((dbl(1) - cLambda) / cLambda) * cSize / dbl(c_tCnt);
    var q_tLH := dbl(q_tCnt) / dbl(qSize);
    var e_tScores := e_tCnt.[dbl]().access(BAT_WRITE);
    e_tScores.left_div(e_size);
    e_tScores := e_tScores.[*](collFac);
    e_tScores := e_tScores.[+](dbl(1));
    e_tScores := [log](e_tScores);
    e_tScores := e_tScores.[*](q_tLH);
    return e_tScores;
}

#             __                /  cNdoc  \            (cK1 + 1) tf(t)
# OKAPI(q) =  >_  qCnt(t) * log | ------- | * -------------------------------------
#            t in q             \  DF(t)  /   cK1*((1-cB) + cB*(DL / cAvgDL)) + tf(t)
#
# where cNdoc    = number of elements that is scored
# where cAvgDL   = average element length
# where DL       = element length
# where cIDF(t)  = idf instead of the Robertson/Sparck-Jones weight (variation on idf)
# where tf(t)    = term frequency (number of occurences of term t in element)
# where cK1      = tuning parameter k1
# where cB       = tuning parameter b
#

PROC _score_OKAPI(int q_tCnt, BAT[oid,int] e_tCnt, BAT[void,int] e_size, int cNdoc, dbl cAvgDL, dbl cK1, dbl cB) : bat[oid,dbl] := {
    
    # cIDF contains Robertson/Sparck-Jones relevance weight
    var cIDF := e_tCnt.count(); # df
    cIDF  := log((cNdoc + 0.5) / (cIDF + 0.5));

    # cK contains length normalization 
    var cK := e_size.semijoin(e_tCnt); # document lengths
    cK := [/](cK, cAvgDL / cB);
    cK := [+](cK, 1 - cB);
    cK := [*](cK, cK1);
    cK := [+](cK, e_tCnt);
    var tmp := [*](e_tCnt, cK1 + 1);
    tmp := [/](tmp, cK);
    
    var e_tScores := [*](tmp, cIDF * q_tCnt); 
    return e_tScores;
}

@= init_scoring
    var cName := qenv.find(QENV_FTINAME);
    var bg_cName := qenv.find(QENV_FTIBGNAME);
    
    # get term ids and drop all terms with zero frq in background-col and calculate query LM
    var terms := _terms2void_tid( Qterms, bg_cName );
    var qSize := terms.count();
    var t_qCnt := terms.histogram();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( qSize = 0 ) { if (returnAllElements) return left; else return new(oid,dbl); }
    
    # init further variables
    var nested := false;
    if (qenv.find(QENV_RECURSIVE_TAGS) = "1") {nested := true;}
    var cSize := bat("tj_" + bg_cName + "_Terms").count();
    var cLambda := dbl(qenv.find(QENV_C_LAMBDA));
    
    var e_pre;
    var e_size;
    if (isnil(left.fetch(0))) {
       var offset1 := int(left.reverse().fetch(0));
       var offset2 := int(left.reverse().fetch(1));
       e_pre := bat("tj_" + cName + "_Tags").slice(offset1, offset2).tsort();
       e_size := bat("tj_" + cName + "_TagSize").slice(offset1, offset2);
    } else {
       e_pre := bat("tj_" + cName + "_Tags").semijoin(left).tsort();
       e_size := bat("tj_" + cName + "_TagSize");
    }
@

@= end_scoring_addmodel
    var res;
    # score combination with prior scores
    if (isnil(left.fetch(0))) {
        if (returnAllElements) {
            left := e_pre.project(dbl(qenv.find(QENV_SCOREBASE)));
	    res := left_add(left,eScores);
        } else {
            res := eScores;
        }
    } else {
        if (returnAllElements) {
            res := left_add(left,eScores);
        } else {
            res := left_add(eScores,left);
        }
    }
@

@= end_scoring_mulmodel
    var res;
    # score combination with prior scores
    if (returnAllElements) {
        res := eScores;
    } else {
        var unchanged := eScores.uselect(score_base);
        res := eScores.kdiff(unchanged);
    }
    if (not(isnil(left.fetch(0)))) {
        res := [*](left,res);
    }
@mil

PROC p_containing_q_NLLR(bat[oid,dbl] left, bat[void,str] Qterms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_NLLR" );
    var t_total := 0;
    t_total :-= time();
  
@:init_scoring@

    var eScores := new(oid,dbl);
    
    # loop over query terms
    t_qCnt@batloop()
    {
        # get collection count of term
        var c_tCnt := _getTermColCnt($h, qenv); 
        # get element count of term
	var e_tCnt := _getTermDocCnt($h, e_pre, e_size, qenv);
	# score elements by this term
        var e_tScores := _score_NLLR($t, qSize, c_tCnt, cSize, e_tCnt, e_size, cLambda);
        e_tCnt := nil;
        
	# aggregate term scores
        eScores := eScores.union_add(e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
@:end_scoring_addmodel@

    t_total :+= time();
    if (timing) printf("# NLLR timing: total: %d\n", t_total);
    if ( trace ) tj_trace( "END p_containing_q_NLLR" );
    return res;
}

PROC p_containing_q_LMs(bat[oid,dbl] left, bat[void,str] Qterms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_LMs" );
    var t_total := 0;
    t_total :-= time();
    
@:init_scoring@

    var eScores := e_pre.project(dbl(1));
    var score_base := dbl(1);

    # loop over query terms
    t_qCnt@batloop()
    {
        # get collection count of term
        var c_tCnt := _getTermColCnt($h, qenv); 
        # get element count of term
	var e_tCnt := _getTermDocCnt($h, e_pre, e_size, qenv);
	# score elements by this term
        var e_tScores := _score_LMs($t, qSize, c_tCnt, cSize, e_tCnt, e_size, cLambda);
        e_tCnt := nil;
        var base := cLambda * c_tCnt / dbl(cSize);
        score_base :*= base;
        e_tScores := e_tScores.union(eScores.kdiff(e_tScores).project(base));

	# aggregate term scores
        eScores := eScores.[*](e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
@:end_scoring_mulmodel@

    t_total :+= time();
    if (timing) printf("# LMs timing: total: %d\n", t_total);
    if ( trace ) tj_trace( "END p_containing_q_LMs" );
    return res;
}

PROC p_containing_q_LM(bat[oid,dbl] left, bat[void,str] Qterms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_LMs" );
    var t_total := 0;
    t_total :-= time();
    
@:init_scoring@

    var eScores := e_pre.project(dbl(1));
    var score_base := dbl(1);

    # loop over query terms
    t_qCnt@batloop()
    {
        # get collection count of term
        var c_tCnt := _getTermColCnt($h, qenv); 
        # get element count of term
	var e_tCnt := _getTermDocCnt($h, e_pre, e_size, qenv);
	# score elements by this term
        var e_tScores := _score_LMs($t, qSize, c_tCnt, cSize, e_tCnt, e_size, cLambda);
        e_tCnt := nil;
        var base := dbl(0);
        score_base :*= base;
        e_tScores := e_tScores.union(eScores.kdiff(e_tScores).project(base));

	# aggregate term scores
        eScores := eScores.[*](e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
@:end_scoring_mulmodel@

    t_total :+= time();
    if (timing) printf("# LM timing: total: %d\n", t_total);
    if ( trace ) tj_trace( "END p_containing_q_LM" );
    return res;
}

PROC p_containing_q_OKAPI(bat[oid,dbl] left, bat[void,str] Qterms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_OKAPI" );
    var t_total := 0;
    t_total :-= time();

@:init_scoring@

    var cNdoc := e_pre.count();
    var cAvgDL := e_size.semijoin(e_pre).[dbl]().avg();
    var cK1 := dbl(qenv.find(QENV_OKAPI_K1));
    var cB := dbl(qenv.find(QENV_OKAPI_B));
    var eScores := new(oid,dbl);
    
    # loop over query terms
    t_qCnt@batloop()
    {
        # get element count of term
	var e_tCnt := _getTermDocCnt($h, e_pre, e_size, qenv);
	# score elements by this term
        var e_tScores := _score_OKAPI($t, e_tCnt, e_size, cNdoc, cAvgDL, cK1, cB);
        e_tCnt := nil;
        
	# aggregate term scores
        eScores := eScores.union_add(e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
@:end_scoring_addmodel@

    t_total :+= time();
    if (timing) printf("# OKAPI timing: total: %d\n", t_total);
    if ( trace ) tj_trace( "END p_containing_q_OKAPI" );
    return res;
}

################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

# down propagation 
@:p_contained_by(max)@
@:p_contained_by(sum)@

@= p_contained_by
PROC p_contained_by_@1(bat[oid,dbl] region, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var candidates := select_node(qenv);
    return p_contained_by_@1(candidates, region, qenv);    
}

PROC p_contained_by_@1(bat[oid,dbl] left, bat[oid,dbl] right, BAT[oid,str] qenv) : bat[oid,dbl] := 
{
    if ( trace ) tj_trace( "BEGIN p_contained_by_@1" );
    var t := 0 - time();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(right) = 0 ) return new(oid,dbl);

    var a_d := anc_desc(right, left, qenv);
    var tmp := a_d.reverse().kunique();

    if (isnil(right.fetch(0))) { printf(" error in p_contained_by_@1 \n");}
    # if "right" is unnested, aggregation is not necessary"
    var reg_score;
    if (qenv.find(QENV_RECURSIVE_TAGS) = "0") {
    	reg_score := a_d.reverse().join(right);
    } else {
        reg_score := {@1}(right, a_d, tmp);
    }
    
    reg_score := reg_score.sort();
   
    if (not(isnil(left.fetch(0)))) {
        if (int(qenv.find(QENV_SCOREBASE)) = 0)
            reg_score := [+](left, reg_score);
        if (int(qenv.find(QENV_SCOREBASE)) = 1)
            reg_score := [*](left, reg_score);
    }

    t :+= time();
    if (timing) printf("# contained_by_@1 timing: %d\n", t);
    if (trace) tj_trace( "END p_contained_by_@1" );
    return reg_score.sort();
}
@mil

# up propagation 
@:p_containing(max)@
@:p_containing(sum)@

@= p_containing
PROC p_containing_@1(bat[oid,dbl] left, bat[oid,dbl] right, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_@1" );
    var t := 0 - time();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(right) = 0 ) return new(oid,dbl);

    var a_d := anc_desc( left, right, qenv );
   
    if (isnil(right.fetch(0))) { printf(" error in p_containing_@1 \n");}
    var tmp := a_d.kunique();
    var reg_score := {@1}(right, a_d.reverse(), tmp); 
    
    reg_score := reg_score.sort();

    if (not(isnil(left.fetch(0)))) {
        if (int(qenv.find(QENV_SCOREBASE)) = 0)
            reg_score := [+](left, reg_score);
        if (int(qenv.find(QENV_SCOREBASE)) = 1)
            reg_score := [*](left, reg_score);
    }

    t :+= time();
    if (timing) printf("# containing_@1 timing: %d\n", t);
    if (trace) tj_trace( "END p_containing_@1" );
    return reg_score.sort();
}
@mil

################################################################################
# SET OPERATORS
################################################################################

### UNION
PROC set_union(bat left, bat right, BAT[oid,str] qenv) : bat :=
{
    if ( count(left) = 0 ) return right;
    if ( count(right) = 0 ) return left;

    var cName := qenv.find(QENV_FTINAME);
    
    if (isnil(left.fetch(0))) {
       var offset1 := int(left.reverse().fetch(0));
       var offset2 := int(left.reverse().fetch(1));
       left := bat("tj_" + cName + "_Tags").slice(offset1, offset2).project( dbl(qenv.find(QENV_SCOREBASE)));
    }
    if (isnil(right.fetch(0))) {
       var offset1 := int(right.reverse().fetch(0));
       var offset2 := int(right.reverse().fetch(1));
       right := bat("tj_" + cName + "_Tags").slice(offset1, offset2).project( dbl(qenv.find(QENV_SCOREBASE)));
    }

    # set recurse tag flag to TRUE since the union might result in a nested set
    modify_qenv(qenv,QENV_RECURSIVE_TAGS,"1");

    return left.kunion(right).sort();
}

### INTERSECTION
PROC set_intersect(bat left, bat right, BAT[oid,str] qenv) : bat := 
{
    if ( count(left) = 0 ) return right;
    if ( count(right) = 0 ) return left;

    var cName := qenv.find(QENV_FTINAME);
    
    if (isnil(left.fetch(0))) {
       var offset1 := int(left.reverse().fetch(0));
       var offset2 := int(left.reverse().fetch(1));
       left := bat("tj_" + cName + "_Tags").slice(offset1, offset2).project( dbl(qenv.find(QENV_SCOREBASE)));
    }
    if (isnil(right.fetch(0))) {
       var offset1 := int(right.reverse().fetch(0));
       var offset2 := int(right.reverse().fetch(1));
       right := bat("tj_" + cName + "_Tags").slice(offset1, offset2).project( dbl(qenv.find(QENV_SCOREBASE)));
    }

    return left.kintersect(right).sort();
}


################################################################################
# SCALING
################################################################################

PROC scale(bat region, flt importance) : bat := 
{

	var res_reg := new(oid,dbl,ENTITY_NUM);
	res_reg := [*](dbl(importance),region);
	return res_reg;

}


################################################################################
# PROBABILISTIC SET OPERATORS
################################################################################

# Compute symmetric difference between two sets: all element that are not in the intersection
PROC ksymmdiff(bat left, bat right) : bat := 
{
    var onlyleft  := left.kdiff(right);
    var onlyright := right.kdiff(left);
    return onlyleft.kunion(onlyright);
}

PROC or_sum(bat left, bat right) : bat :=
{
    return left.union_add(right);
}

PROC or_max(bat left, bat right) : bat :=
{

    var inters := [max](left,right);

    return inters.kunion(ksymmdiff(left,right)).sort();

}

PROC or_prob(bat left, bat right) : bat :=
{

	var inters := [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

    return inters.kunion(ksymmdiff(left,right)).sort();

}

PROC or_exp(bat left, bat right, int A) : bat := 
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC or_min(bat left, bat right) : bat :=
{

    var inters := [min](left,right);

    return inters.kunion(ksymmdiff(left,right)).sort();

}

PROC or_prod(bat left, bat right) : bat :=
{
    return left.union_mul(right);
}

PROC and_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC and_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC and_exp(bat left, bat right, int A) : bat :=
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC and_max(bat left, bat right) : bat :=
{
	return [max](left,right);
}

PROC and_prob(bat left, bat right) : bat :=
{
	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));
}


################################################################################
# PRIOR
################################################################################

PROC prior_ls(BAT[oid,dbl] region, BAT[oid,str] qenv) : bat := 
{
    var cName := qenv.find(QENV_FTINAME);
    var tag_size := bat("tj_" + cName + "_TagSize");
    return [*](region, tag_size);
}
#ADDHELP("prior_ls", "vojkan", "March 16, 2005",
#"Adds element prior based on element length to the region score.",
#"TIJAH");

################################################################################
# OVERLAP REMOVAL
################################################################################

PROC rm_overlap(bat ctx, BAT[oid,str] qenv) : bat{

 ctx := ctx.sort();
 var AD:=anc_desc(ctx,ctx,qenv);
 var maxD := AD.join(ctx).sort().{max}();
 var maxA := AD.reverse().sort().join(ctx).{max}();

 AD:=nil;

 # candidates are nodes that have no descendents or a higher score
 # than all descendents
 var candidates := ctx.kdiff(maxD).access(BAT_APPEND);
 candidates.insert(ctx.[>](maxD).uselect(true).mirror().join(ctx));

 # keep the candidates without ancestor and w score >= ancestor scores
 var res := candidates.kdiff(maxA).access(BAT_APPEND);
 res.insert(candidates.[>=](maxA).uselect(true).mirror().join(candidates));

 candidates := nil;
 maxA:=nil;maxD:=nil;
 return res;
}
#ADDHELP("rm_overlap","thijs", "August, 2007",
#"Removes overlapping elements from result list.",
#"TIJAH");

################################################################################
# ORDER
################################################################################

PROC order_regions(bat region) : bat :=
{

	region := region.reverse().sort_rev().reverse();

	return region;

}
#ADDHELP("order_regions", "vojkan", "March 29, 2005",
#"Order regions in descending order based on their score values.",
#"TIJAH");

##########################################
# Collection Management Functions
#
##########################################

PROC _tj_chk_modified_fragments(str ftiName, BAT[str,bat] collBat) : BAT[void,str] :=
{
	var offset := oid(int(_tj_get_parameter(collBat, "_last_finalizedPre")) + 1);
        var fragments := collBat.find("_fragments");
	var frag_offset := int(find_lower(fragments.reverse(), offset));
	var frag_last := fragments.count();
	
	var mod_frags := new(void, str).seqbase(0@0);
	while (frag_offset < frag_last)
	{
		mod_frags.append("tj_" + ftiName + "_tid" + str(frag_offset));
		mod_frags.append("tj_" + ftiName + "_size" + str(frag_offset));
		frag_offset :+= 1;
	}
	
	return mod_frags;
}

PROC _buildIRindex(str ftiName, BAT[str,bat] collBat) : void :=
{
	var offset := oid(lng(_tj_get_parameter(collBat, "_last_finalizedPre")) + 1);
        var fragments := collBat.find("_fragments");
	var frag_offset := int(find_lower(fragments.reverse(), offset));
	var frag_last := fragments.count();
	
	var pre_tid := bat("tj_" + ftiName + "_tid" + str(frag_offset));
	var pre_size := bat("tj_" + ftiName + "_size" + str(frag_offset));
	var tids := pre_tid.slice(lng(offset) - lng(pre_tid.seqbase()), lng(pre_tid.count() - 1));
	var sizes := pre_size.slice(lng(offset) - lng(pre_size.seqbase()), lng(pre_size.count() - 1));
	tids.access(BAT_WRITE);
	sizes.access(BAT_WRITE);
	frag_offset :+= 1;
	while (frag_offset <= frag_last)
	{
	    	tids.append(bat("tj_" + ftiName + "_tid" + str(frag_offset)));
	    	sizes.append(bat("tj_" + ftiName + "_size" + str(frag_offset)));
		frag_offset :+= 1;
	}
	tids.access(BAT_READ);
	sizes.access(BAT_READ);
       
	# incremental index merge
	if (isnil(CATCH(bat("tj_" + ftiName + "_TermIndex").count()))) 
        {
    		var replaceBats := collBat.find("replaceBats");
		var tmp := tids.kdiff(collBat.find("_pfpre"));
                tmp := tmp.reverse().ssort();
		var i := mergeindex(tmp, collBat.find("_TermIndex"),
                                         collBat.find("_Terms"),
                                         collBat.find("_globalTerms").count() + 1);       
                collBat.replace("_TermIndex", i.fetch(0));
                collBat.replace("_Terms", i.fetch(1));
	        i := nil;
		tmp := nil;
		replaceBats.insert("_TermIndex", "tj_" + ftiName + "_TermIndex");
                replaceBats.insert("_Terms", "tj_" + ftiName + "_Terms");
	        collBat.find("_TermIndex").access(BAT_READ).mmap(1);
	        collBat.find("_Terms").access(BAT_READ).mmap(1);
		collBat.find("submitBats").append("tj_" + ftiName + "_TermIndex");
		collBat.find("submitBats").append("tj_" + ftiName + "_Terms");
	        
	        tmp := tids.semijoin(bat("tj_" + ftiName + "_pfpre"));
                tmp := tmp.reverse().ssort();
		var tmpsize := tmp.leftfetchjoin(sizes);
                i := mergeindex2(tmp, tmpsize,
		                 collBat.find("_TagIndex"),
                                 collBat.find("_Tags"),
                                 collBat.find("_TagSize"),
                                 collBat.find("_globalTags").count() + 1);
                collBat.replace("_TagIndex", i.fetch(0));
                collBat.replace("_Tags", i.fetch(1));
                collBat.replace("_TagSize", i.fetch(2));
	        i := nil;
		tmp := nil;
		tmpsize := nil;
		replaceBats.insert("_TagIndex", "tj_" + ftiName + "_TagIndex");
                replaceBats.insert("_Tags", "tj_" + ftiName + "_Tags");
                replaceBats.insert("_TagSize", "tj_" + ftiName + "_TagSize");
	        collBat.find("_TagIndex").access(BAT_READ).mmap(1);
	        collBat.find("_Tags").access(BAT_READ).mmap(1);
	        collBat.find("_TagSize").access(BAT_READ).mmap(1);
		collBat.find("submitBats").append("tj_" + ftiName + "_TagIndex");
		collBat.find("submitBats").append("tj_" + ftiName + "_Tags");
		collBat.find("submitBats").append("tj_" + ftiName + "_TagSize");
        }
        else # create new index
        {       
	        var tmp := tids.kdiff(bat("tj_" + ftiName + "_pfpre"));
                tmp := tmp.reverse().ssort();
	        var termindex := tmp.hmark(0@0).offsetindex(bat(_tj_TermBat(ftiName)).count() + 1);
	        var terms := tmp.tmark(0@0);
	        # create _TermIndex and _Terms here
	        termindex.persists(true).bbpname("tj_" + ftiName + "_TermIndex");
	        terms.persists(true).bbpname("tj_" + ftiName + "_Terms");
	        tmp := nil;
	        termindex.access(BAT_READ);
	        termindex.mmap(1);
	        terms.access(BAT_READ);
	        terms.mmap(1);
	        termindex := nil;
		terms := nil;
		collBat.find("submitBats").append("tj_" + ftiName + "_TermIndex");
		collBat.find("submitBats").append("tj_" + ftiName + "_Terms");
	        
	        tmp := tids.semijoin(bat("tj_" + ftiName + "_pfpre"));
                tmp := tmp.reverse().ssort();
	        var tagindex := tmp.hmark(1@0).offsetindex(bat(_tj_TagBat(ftiName)).count() + 1);
	        var tags := tmp.tmark(1@0);
	        # create _Tags and _Tagindex here
	        tagindex.persists(true).bbpname("tj_" + ftiName + "_TagIndex");
	        tags.persists(true).bbpname("tj_" + ftiName + "_Tags");
	        tmp := nil;
	        tagindex.access(BAT_READ);
	        tagindex.mmap(1);
	        tags.access(BAT_READ);
	        tags.mmap(1);
	        tagindex := nil;
		var tagsize := tags.leftfetchjoin(sizes);
		tags := nil;
	        tagsize.persists(true).bbpname("tj_" + ftiName + "_TagSize");
	        tagsize.access(BAT_READ);
	        tagsize.mmap(1);
		tagsize := nil;
		collBat.find("submitBats").append("tj_" + ftiName + "_TagIndex");
		collBat.find("submitBats").append("tj_" + ftiName + "_Tags");
		collBat.find("submitBats").append("tj_" + ftiName + "_TagSize");
        }
}

######################################
# PF interface functions
#
######################################

@h

#define ENABLE_TDEBUG

#ifdef ENABLE_TDEBUG
extern int pftijah_debug;
#define SET_TDEBUG(V) pftijah_debug = V
#define TDEBUG(V) (pftijah_debug && (((V<=pftijah_debug)&&(pftijah_debug<100)) || ((V==pftijah_debug)&&(pftijah_debug>=100))) )
#else
#define SET_TDEBUG(V)
#define TDEBUG(V) 0
#endif

#define TJ_TIMINGS 777

@c
#include <pf_config.h>

#include <monet.h>
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include <math.h>

#include <pathfinder.h>

#include "pftijah.h"

#include "termdb.h"

#ifdef ENABLE_TDEBUG
/* 
 * The main pftijah variable, settable from the command line by the
 * <TijahOptions debug=number ..... from the query env.
 * Current strategy is not to reset the debug variable after the query
 * finished and to make it a global for ease of use.
 * The number has three possiblilities:
 * 0             : no debug
 * 1   - 99      : leveled debug
 * 100 - INT_MAX : debug a specific event 
 *
 * usage: if (TDEBUG ) expression
 */
int pftijah_debug = 0;
#endif

int executeMIL(char* str) {
    return monet_exec(str);
}

/*
 * the CMDtj_log is created to be able to print in very difficult IO areas
 */

static char* tj_log_fileName = NULL; /* set by [CMD]tj_setlog(filename) */

int CMDtj_setlog(str filename) {
	FILE* f;
	
	if ( (f = fopen(filename,"w")) ) {
	    fprintf(f,"# Start TIJAH logger:\n");
	    fclose(f);
	    tj_log_fileName = (char*)strdup(filename);
	}
	return GDK_SUCCEED;
}

int CMDtj_log(str format, int* i) {
	FILE* f;
	
	if ( tj_log_fileName != NULL ) {
	    if ( (f = fopen(tj_log_fileName,"a")) ) {
	        fprintf(f,(const char*)format,*i);
	        fclose(f);
	    }
	}
	return GDK_SUCCEED;
}

int CMDtj_chk_dict_hash(BAT* b_tag, BAT* b_term)
{
	if ( b_tag->T->hash == NULL ) {
	     // stream_printf(GDKout,"C[]: ADD HASHTABLE TO TAG DICTIONARY\n");
#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[]: CREATE NEW HASHTABLE ON TAG DICTIONARY\n");
#endif
	     if ( !BAThash(BATmirror(b_tag),0) ) {
                 GDKerror("CMDtj_chk_dict_hash: adding hashtable to Tag fails\n");
	         return GDK_FAIL;
	     }
	}
	if ( b_term->T->hash == NULL ) {
	     // stream_printf(GDKout,"C[]: ADD HASHTABLE TO TERM DICTIONARY\n");
#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[]: CREATE NEW HASHTABLE ON TERM DICTIONARY\n");
#endif
	     if ( !BAThash(BATmirror(b_term),0) ) {
                 GDKerror("CMDtj_chk_dict_hash: adding hashtable to Term fails\n");
	         return GDK_FAIL;
	     }
	}
	return GDK_SUCCEED;
}

extern char* tijahParse(BAT* optbat, char* startNodes_name, char** errBUFF);

static int nexiTmpCounter = 0;

int CMDtijah_query(BAT** res, BAT* optbat, bit* use_startnodes, BAT* startNodes) {
	char* err;
	char* mil;
	char  nameBUFF[32], *startNodes_name;

	if (TDEBUG(1)) stream_printf(GDKout,"# CMDtijah_query: start.\n");
	if ( *use_startnodes ) {
	    BATmode(startNodes,PERSISTENT);
	    sprintf(&nameBUFF[0],"%s%d","nexi_start",nexiTmpCounter++);
	    /* make persistent, the generated script should undo this again */
	    if ( BBPrename(startNodes->batCacheid,(str)&nameBUFF[0]) != 0) {
                GDKerror("CMDtijah_query: fail to name startNode bat: \"%s\".\n", &nameBUFF[0]);
	        return GDK_FAIL;
	    }
	    startNodes_name = &nameBUFF[0];
	    if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: using startnodes.\n");
	    if (TDEBUG(2)) BATprintf(GDKout,startNodes);
	} else {
	    startNodes_name = NULL;
	}

	if ( !optbat ) {
            GDKerror("CMDtijah_query: missing option bat.\n");
	    return GDK_FAIL;
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: call tijahParse.\n");
	if ( !(mil=tijahParse(optbat,startNodes_name,&err)) ) {
            GDKerror("CMDtijah_query: %s.\n", err);
	    return GDK_FAIL;
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: finish tijahParse.\n");
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: start MIL script.\n");
	if (TDEBUG(9)) {
		stream_printf(GDKout,"# CMDtijah_query: generated MIL script:\n");
		stream_printf(GDKout,"%s",mil);
		stream_printf(GDKout,"# CMDtijah_query: end of MIL script:\n");
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: start executing MIL script.\n");
        if ( executeMIL(mil)<0 ) {
            GDKerror("CMDtijah_query: execute MIL failed.\n");
	    return GDK_FAIL;
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: finish MIL script.\n");
	BAT* scoreBAT = BATdescriptor( BBPindex("nexi_result") );

	if (TDEBUG(3)) stream_printf(GDKout,"# CMDtijah_query: sizeof scoreBAT = %d.\n",BATcount(scoreBAT));
	if (TDEBUG(9)) {
	    stream_printf(GDKout,"# CMDtijah_query: scoreBAT:\n");
	    BATprintf(GDKout,scoreBAT);
	}

	if ( ! scoreBAT ) {
            GDKerror("CMDtijah_query: fail to load score bat: \"%s\".\n", "nexi_result");
	    return GDK_FAIL;
        }
	sprintf(&nameBUFF[0],"%s_del%d","nexi_result",nexiTmpCounter++);
	if ( BATrename(scoreBAT,(str)&nameBUFF[0]) == str_nil ) {
            GDKerror("CMDtijah_query: fail to rename score bat: \"%s\".\n", &nameBUFF[0]);
	    return GDK_FAIL;
	}
	BATmode(scoreBAT,TRANSIENT);

	*res = scoreBAT;

	if (TDEBUG(1)) stream_printf(GDKout,"# CMDtijah_query: finish.\n");
        return GDK_SUCCEED;
}

char* tijah_tokenize_string(char* buf, int len, char* outbuf);

int CMDtijah_tokenize (str* res, str arg)
{
	int sz    = strlen(arg);
	char* buf = GDKmalloc(sz + 1);

	if (!buf) {
            GDKerror("CMDtijah_tokenize: GDKmalloc() failed.\n");
	    return GDK_FAIL;
	}

	buf[0] = 0;
	*res = tijah_tokenize_string(arg,sz,buf);

	return GDK_SUCCEED;
}


/**
 * In-place synchronized oid computation experiment by Henning and Jan
 *
 */

#define FIND_OID(FOID,BBAT,BPTR,BTAIL) \
        /* use peter's poor mans binary search here */ \
        while (BPTR+1048576 < BTAIL && (*(oid*)BUNhead(BBAT,BPTR+1048576)) < FOID) \
            BPTR += 1048576; \
        while (BPTR+32768 < BTAIL && (*(oid*)BUNhead(BBAT,BPTR+32768)) < FOID) \
            BPTR += 32768; \
        while (BPTR+1024 < BTAIL && (*(oid*)BUNhead(BBAT,BPTR+1024)) < FOID) \
            BPTR += 1024; \
        while (BPTR+32 < BTAIL && (*(oid*)BUNhead(BBAT,BPTR+32)) < FOID) \
            BPTR += 32; \
        do { \
                BPTR++; \
        } while ( (BPTR < BTAIL) && ((*(oid*)BUNhead(BBAT,BPTR))<FOID) );
 
#define INPLACE_OID_CALC_HEADER \
        BATiter li = bat_iterator(l);   \
        BATiter ri = bat_iterator(r);   \
        if ( !bat_oid_sort_chck(l) || !bat_oid_sort_chck(r) ) \
            return  GDK_FAIL; \
        *res = BATsetaccess(l,BAT_WRITE); \
        BUN lp = BUNfirst(l), ll = BUNlast(l); \
        BUN rp = BUNfirst(r), rl = BUNlast(r); \
        while ( (lp < ll) && (rp < rl) ) { \
                oid lv = *(oid*)BUNhead(li,lp); \
                oid rv = *(oid*)BUNhead(ri,rp); \
                if ( lv == rv ) { \
                    dbl* dres = (dbl*)Tloc(l,lp);

#define INPLACE_OID_CALC_FOOTER \
                    lp++; rp++; \
                } else if ( lv < rv ) { \
                    FIND_OID(rv,li,lp,ll); \
                } else /* lv > rv */ { \
                    FIND_OID(lv,ri,rp,rl); \
                } \
        } \
        BBPfix(BBPcacheid(*res)); \
        (*res)->batDirty = TRUE; \
        (*res)->tsorted = FALSE; \
        return GDK_SUCCEED;

static int bat_oid_sort_chck(BAT* b) {
	/* incomplete, the head should also be key */
	if ( !b->hsorted ) {
	    GDKerror("bat_oid_sort_chck: BAT should be head sorted.\n");
	    return 0;
	}
	if (BAThtype(b) != TYPE_oid ) {
	    GDKerror("bat_oid_sort_chck: BAT shouled have oid head type.\n");
	    return 0;
	}
	return 1;
}

int CMDleft_add_dbl(BAT** res, BAT*l, BAT*r) {
        INPLACE_OID_CALC_HEADER;
        *dres += *(dbl*)Tloc(r,rp);
        INPLACE_OID_CALC_FOOTER;
}

int CMDleft_sub_dbl(BAT** res, BAT*l, BAT*r) {
        INPLACE_OID_CALC_HEADER;
	*dres -= *(dbl*)Tloc(r,rp);
        INPLACE_OID_CALC_FOOTER;
}

int CMDleft_mul_dbl(BAT** res, BAT*l, BAT*r) {
        INPLACE_OID_CALC_HEADER;
	*dres *= *(dbl*)Tloc(r,rp);
        INPLACE_OID_CALC_FOOTER;
}

int CMDleft_div_dbl(BAT** res, BAT*l, BAT*r) {
        INPLACE_OID_CALC_HEADER;
	*dres /= *(dbl*)Tloc(r,rp);
        INPLACE_OID_CALC_FOOTER;
}

int CMDleft_div_dbl_int(BAT** res, BAT*l, BAT*r) {
        INPLACE_OID_CALC_HEADER;
	*dres = (dbl)(*dres / *(int*)Tloc(r,rp));
        INPLACE_OID_CALC_FOOTER;
}

int CMDleft_log_dbl(BAT** res, BAT*l) {
	if ( !bat_oid_sort_chck(l) )
	    return  GDK_FAIL;
	/* make the left/res bat writable */
	*res = BATsetaccess(l,BAT_WRITE);
	(*res)->batDirty = TRUE;
 
	dbl *lp = (dbl*)Tloc(l, BUNfirst(l)), *lq = (dbl*)Tloc(l, BUNlast(l)); 

	for (; lp < lq; lp++ ) {
		*lp = log(*lp);
	}
	BBPfix(BBPcacheid(*res));
	(*res)->tsorted = FALSE;
	return GDK_SUCCEED;
}

/*
 *
 * And now the union variant for Henning
 *
 */

#define UNION_FIND_OID(FOID,BBAT,BPTR,BTAIL,RESBAT) \
        do { \
		if (!BUNins(RESBAT,(oid*)BUNhead(BBAT,BPTR),(dbl*)BUNtail(BBAT,BPTR), FALSE) ) \
		    return GDK_FAIL; \
                BPTR++; \
        } while ( (BPTR < BTAIL) && ((*(oid*)BUNhead(BBAT,BPTR))<FOID) );

#define UNION_OID_CALC_HEADER \
        BATiter li = bat_iterator(l);   \
        BATiter ri = bat_iterator(r);   \
        if ( !bat_oid_sort_chck(l) || !bat_oid_sort_chck(r) ) \
            return  GDK_FAIL; \
        *res = BATnew(TYPE_oid,TYPE_dbl,0); \
        BUN lp = BUNfirst(l), ll = BUNlast(l); \
        BUN rp = BUNfirst(r), rl = BUNlast(r); \
        while ( (lp < ll) || (rp < rl) ) { \
		oid lv, rv; \
                lv = (lp < ll) ? *(oid*)BUNhead(li,lp) : oid_nil; \
                rv = (rp < rl) ? *(oid*)BUNhead(ri,rp) : oid_nil; \
                if ( lv == rv ) { \
                    dbl* dres = (dbl*)Tloc(l,lp); \
		    dbl  newdbl;

#define UNION_OID_CALC_FOOTER \
		    if ( !BUNins(*res, &lv, &newdbl, FALSE) ) \
		        return GDK_FAIL; \
                    lp++; rp++; \
                } else if ( (rv==oid_nil) || (lv < rv) ) { \
                    UNION_FIND_OID(rv,li,lp,ll,*res); \
                } else /* (lv==oid_nil) || (lv > rv) */ { \
                    UNION_FIND_OID(lv,ri,rp,rl,*res); \
                } \
        } \
        BBPfix(BBPcacheid(*res)); \
        (*res)->batDirty = TRUE; \
        (*res)->tsorted = FALSE; \
        return GDK_SUCCEED;

int CMDunion_add_dbl(BAT** res, BAT*l, BAT*r) {
        UNION_OID_CALC_HEADER;
        newdbl = *dres + *(dbl*)Tloc(r,rp);
        UNION_OID_CALC_FOOTER;
}

int CMDunion_sub_dbl(BAT** res, BAT*l, BAT*r) {
        UNION_OID_CALC_HEADER;
        newdbl = *dres - *(dbl*)Tloc(r,rp);
        UNION_OID_CALC_FOOTER;
}

int CMDunion_mul_dbl(BAT** res, BAT*l, BAT*r) {
        UNION_OID_CALC_HEADER;
        newdbl = *dres * *(dbl*)Tloc(r,rp);
        UNION_OID_CALC_FOOTER;
}
int CMDunion_div_dbl(BAT** res, BAT*l, BAT*r) {
        UNION_OID_CALC_HEADER;
        newdbl = *dres / *(dbl*)Tloc(r,rp);
        UNION_OID_CALC_FOOTER;
}

/*
 *
 * END of experiment
 *
 *
 */

int CMDpf2tijah_node(BAT** res, BAT* doc_name, BAT* doc_firstpre, BAT* doc_pfpre, BAT* item, BAT* kind, BAT* doc_loaded ) {
        int debug = 0;

	int nDocs = BATcount(doc_loaded);
	BAT **rangeBAT = (BAT**)GDKmalloc(nDocs*sizeof(BAT*));
	if (!rangeBAT) {
            GDKerror("CMDpf2tijah_node: GDKmalloc() failed.\n");
	    return GDK_FAIL;
	}
	for(int i=0; i<nDocs; i++) {
	    rangeBAT[i] = NULL;
        }

	*res = BATnew(TYPE_void, TYPE_oid, BATcount(item));

        if ( debug ) stream_printf(GDKout,"* Start of CMDpf2tijah_node():\n");
	if ( 1 && debug ) {
	    BATprintf(GDKout,item);
	    BATprintf(GDKout,kind);
	    BATprintf(GDKout,doc_loaded);
	}
	if ( 1 && debug ) {
	    BATprintf(GDKout,doc_name);
	    BATprintf(GDKout,doc_firstpre);
	    BATprintf(GDKout,doc_pfpre);
	}

	BUN p,q;
        BATiter itemi = bat_iterator(item);
	BATloop(item, p, q) {
	    oid idx      = *(oid*) BUNhead(itemi, p);
	    ptr itemTAIL = BUNtail(itemi, p);
	    oid pfpre    = *(oid*) itemTAIL;

	    BUN kindBUN = BUNfnd(kind,&idx);
	    if ( kindBUN == BUN_NONE ) {
	        stream_printf(GDKout,"READ KIND failed\n");
		return GDK_FAIL;
	    }
	    int kval = *(int*)Tloc(kind, kindBUN);
	    // ALGEBRA NODES ONLY CONTAIN THE FRAG
	    oid container;
	    if ( XTRACT_KIND(kval) != ELEM ) {
	        // stream_printf(GDKout,"CMDpf2tijah_node: startNodes: no node\n");
		// return GDK_FAIL;
		container = (oid)kval;
		if ( debug ) stream_printf(GDKout,"* container = %d.\n",container);
            } else {
	    	container = (oid)XTRACT_CONT(kval);
	    }

	    int myindex = container - 1;
	    /* make it a switch */
	    if ( rangeBAT[myindex] == NULL ) {

	      BAT* docs_in_cont = BATselect(BATmirror(doc_loaded),&container,&container);
              BATiter docs_in_conti = bat_iterator(docs_in_cont);
	      BUN p_dic,q_dic;
	      BATloop(docs_in_cont, p_dic, q_dic) {
	        oid doc_start;
		oid doc_end;

	        str docname = (str) BUNhead(docs_in_conti, p_dic);
		BAT* b = BATmirror(doc_name);
	        BUN yy = BUNfnd(b,docname);
		if ( yy != BUN_NONE ) {
                    BATiter bi = bat_iterator(b);
		    if ( debug ) stream_printf(GDKout,"* pf2tijah_index: preparing doc(%s)[] nodes for translation\n",docname);	
		    oid tj_docIndex = *(oid*)BUNtail(bi,yy);

		    BUN r;
		    r = BUNfnd(doc_firstpre,&tj_docIndex);
		    if ( r == BUN_NONE ) {
	    	        stream_printf(GDKout,"Cannot find tijah-firstpre @  %d.\n",tj_docIndex);
		        return GDK_FAIL;
		    }

                    bi.b = doc_firstpre;
	            doc_start = *(oid*)BUNtail(bi,r);
		    oid tj_nextIndex = tj_docIndex +  1;
		    if ( BATcount(doc_firstpre) > tj_nextIndex ) {
		        r = BUNfnd(doc_firstpre,&tj_nextIndex);
			if ( r == BUN_NONE ) {
	    	            stream_printf(GDKout,"Cannot do range for tijah-firstpre @  %d.\n",tj_docIndex);
			    return GDK_FAIL;
			}
	                doc_end = *(oid*)BUNtail(bi,r) - 1;
		    } else {
	                doc_end = oid_nil;
		    }
		    BAT* ds = BATselect(BATmirror(doc_pfpre),(ptr)&doc_start,(ptr)&doc_end);
		    if ( rangeBAT[myindex] == NULL ) {
		        rangeBAT[myindex] = BATsetaccess(ds, BAT_WRITE);
		    } else {
		        if ( !BATins(rangeBAT[myindex],ds,1) ) {
	    	           stream_printf(GDKout,"CMDpf2tijah_node: BATins in rangeBAT fails.\n");
			   return GDK_FAIL;
		        }
		    }
		} {
		} } }
	        if ( rangeBAT[myindex] ) {
		    BUN range_bun = BUNfnd(rangeBAT[myindex],&pfpre);
		    if ( range_bun != BUN_NONE ) {
			/* found the tijah index value */
                        BATiter bi = bat_iterator(rangeBAT[myindex]);
		        oid tj_index = *(oid*)BUNtail(bi,range_bun);
			BUNappend(*res,&tj_index,1);
			if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = tijah(%d@0).\n", pfpre, container,tj_index);
		    } else {
		        if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = NOT INDEXED.\n", pfpre, container);
		    }
		    
		} else {
			if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = NOT INDEXED.\n", pfpre, container);
		}
	}
	/* cleanup BAT's */
	for(int i=0; i<nDocs; i++) {
	    if ( rangeBAT[i] ) {
	        BBPunfix(BBPcacheid(rangeBAT[i]));
		rangeBAT[i] = NULL;
	    }
        }
	GDKfree(rangeBAT);

	*res = BATmirror(BATmark(BATmirror(*res), 0));

	/* */
	if ( debug ) 
	    BATprintf(GDKout,*res);
	/* */
        return GDK_SUCCEED;
}

int CMDoffsetindex ( BAT** result, BAT* tid, int* res_size)
{
	char *name = "TJoffsetindex";
	BAT *res = NULL;
        BUN p, q;
        oid *dst = NULL, *sdst = NULL;
	oid t, s;

	/* --------------------------- checks ---------------------------------- */

	BATcheck(tid, name);
	if (!(BATtordered(tid) & 1))
	{
		/* BUG#1732596 this test currently fails on Itanium */
        	GDKerror("%s: index-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}
	if (!(BAThdense(tid)))
    	{
        	GDKerror("%s: index-bat must have a dense head.\n", name);
    		return GDK_FAIL;
	}
		
	/* ---------------------------- inits ---------------------------------- */

	res = BATnew(TYPE_void, TYPE_oid, *res_size);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, *res_size);
            	return(GDK_FAIL);
        }
	sdst = dst = (oid*)Tloc(res, BUNlast(res));
    
	t = (oid)0;
	*(oid*)dst = (oid)0;
	dst++;
	
	/* ----------------------------- main ---------------------------------- */

        BATiter tidi = bat_iterator(tid);
	BATloop(tid, p, q)
	{
		s = *(oid*) BUNtail(tidi, p);
		if (t != s)
		{
			for(; t < s; t++, dst++)
			{
				*(oid*)dst = p;
			}
		}
	}

	s = (oid) (*res_size - 1);
	for(; t < s; t++, dst++)
	{
		*dst = p;
	}
	
	/* ---------------------------- tidy up --------------------------------- */
	
	BATsetcount(res, dst - sdst);
    	res->batDirty = TRUE;
        res->tsorted = GDK_SORTED;
        BATkey (res, TRUE);
	BATset(res, TRUE);
	BATseqbase(res, 0);
	
	*result = res;
	return GDK_SUCCEED;
}	

int CMDmergeindex ( BAT** result, BAT* tidpre, BAT* oldindex, BAT* oldpre, int* indsize )
{
        BATiter tidprei, oldindexi, oldprei;
	char *name = "TJmergeindex";
	BAT *res = NULL;
	BAT *newindex = NULL;
	BAT *newpre = NULL;
	int i,j, ressize = 0;
        BUN lst_tidpre, lst_oldindex, lst_copy, lst_res, cur_tidpre, cur_oldindex, cur_oldpre;
        oid *s_newindex, *lst_newindex, *s_newpre, *lst_newpre;
	oid tid;
	
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tidpre, name);
	BATcheck(oldindex, name);
	BATcheck(oldpre, name);
        
	if (!(BAThordered(tidpre) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	/* ---------------------------- inits ---------------------------------- */

	ressize = 2;
	res = BATnew(TYPE_void, TYPE_bat, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	ressize = BATcount(tidpre) + BATcount(oldpre);
	newpre = BATnew(TYPE_void, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	ressize = *indsize;
	newindex = BATnew(TYPE_void, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	lst_tidpre = BUNlast(tidpre);
	lst_oldindex = BUNlast(oldindex) - 1; /* last index is not a real term */
	s_newindex = lst_newindex = (oid*)Tloc(newindex, BUNlast(newindex));
	s_newpre = lst_newpre = (oid*)Tloc(newpre, BUNlast(newpre));
	lst_res = BUNlast(res);
	
	cur_tidpre = BUNfirst(tidpre);
	cur_oldindex = BUNfirst(oldindex);
	cur_oldpre = BUNfirst(oldpre);
	
        tidprei = bat_iterator(tidpre);
        oldindexi = bat_iterator(oldindex);
        oldprei = bat_iterator(oldpre);
	/* ----------------------------- main ---------------------------------- */
	
	j = *indsize - 1;
	for(i = 0; i < j; i++)
        {
	        tid = (oid) i;
		*lst_newindex++ = lst_newpre - s_newpre;
               
                /* copy old nodes to new index */
                if (cur_oldindex < lst_oldindex && tid == *(oid*)BUNhead(oldindexi, cur_oldindex))
                {
		        lst_copy = *(int*) BUNtail(oldindexi, cur_oldindex + 1);
		        while (cur_oldpre < lst_copy)
		        {
			        *lst_newpre++ = *(oid*)BUNtail(oldprei, cur_oldpre);
			        cur_oldpre++;
		        }
                        cur_oldindex++;
                }
                /* merge-in new nodes */
                while(cur_tidpre < lst_tidpre && tid == *(oid*)BUNhead(tidprei, cur_tidpre))
                {
                        *lst_newpre++ = *(oid*)BUNtail(tidprei, cur_tidpre);
	        	cur_tidpre++;
                }
        }

	/* write limit of index as last item to index bat */
	*lst_newindex = lst_newpre - s_newpre;
	lst_newindex++;

	/* ---------------------------- tidy up --------------------------------- */

	BATsetcount(newindex, lst_newindex - s_newindex);
    	newindex->batDirty = TRUE;
        newindex->hsorted = GDK_SORTED;
        newindex->tsorted = GDK_SORTED;
        BATkey(newindex, TRUE);
        BATkey(BATmirror(newindex), FALSE);
	BATseqbase(newindex, (oid)0);

	BATsetcount(newpre, lst_newpre - s_newpre);
    	newpre->batDirty = TRUE;
        newpre->hsorted = GDK_SORTED;
        newpre->tsorted = FALSE;
        BATkey(newpre, TRUE);
        BATkey(BATmirror(newpre), TRUE);
	BATseqbase(newpre, (oid)0);
	
        /* insert bats in result */		
	BATseqbase(res, (oid)0);
	voidfix_bunfastins_nocheck_noinc(res, lst_res, 0, (void*)&newindex->batCacheid);
	BBPunfix(newindex->batCacheid);	
	lst_res++;
	voidfix_bunfastins_nocheck_noinc(res, lst_res, 0, (void*)&newpre->batCacheid); 
	BBPunfix(newpre->batCacheid);	
	lst_res++;
	
	BATsetcount(res, 2);
	res->batDirty = TRUE;
	BATkey(res, TRUE);
	BATkey(BATmirror(res), TRUE);
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
	
	*result = res;
	return GDK_SUCCEED;
}

int CMDmergeindex2 ( BAT** result, BAT* tidpre, BAT* tidsize, BAT* oldindex, BAT* oldpre, BAT* oldsize, int* indsize )
{
	char *name = "TJmergeindex2";
	BAT *res = NULL;
	BAT *newindex = NULL;
	BAT *newpre = NULL;
	BAT *newsize = NULL;
	int i,j, ressize = 0;
        BUN lst_tidpre, lst_oldindex, lst_copy, lst_res, cur_tidpre, cur_tidsize, cur_oldindex, cur_oldpre, cur_oldsize;
        BATiter tidprei, tidsizei, oldindexi, oldprei, oldsizei;
        oid *s_newindex, *lst_newindex, *s_newpre, *lst_newpre;
	int *s_newsize, *lst_newsize;
	oid tid;
	
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tidpre, name);
	BATcheck(tidsize, name);
	BATcheck(oldindex, name);
	BATcheck(oldpre, name);
	BATcheck(oldsize, name);
        
	if (!(BAThordered(tidpre) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	/* ---------------------------- inits ---------------------------------- */

	ressize = 3;
	res = BATnew(TYPE_void, TYPE_bat, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	ressize = BATcount(tidpre) + BATcount(oldpre);
	newpre = BATnew(TYPE_void, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	newsize = BATnew(TYPE_void, TYPE_int, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,int] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	ressize = *indsize;
	newindex = BATnew(TYPE_void, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	lst_tidpre = BUNlast(tidpre);
	lst_oldindex = BUNlast(oldindex) - 1; /* last index is not a real term */
	s_newindex = lst_newindex = (oid*)Tloc(newindex, BUNlast(newindex));
	s_newpre = lst_newpre = (oid*)Tloc(newpre, BUNlast(newpre));
	s_newsize = lst_newsize = (int*)Tloc(newsize, BUNlast(newsize));
	lst_res = BUNlast(res);
	
	cur_tidpre = BUNfirst(tidpre);
	cur_tidsize = BUNfirst(tidsize);
	cur_oldindex = BUNfirst(oldindex);
	cur_oldpre = BUNfirst(oldpre);
	cur_oldsize = BUNfirst(oldsize);
	
        tidprei = bat_iterator(tidpre);
        tidsizei = bat_iterator(tidsize);
        oldindexi = bat_iterator(oldindex);
        oldprei = bat_iterator(oldpre);
        oldsizei = bat_iterator(oldsize);

	/* ----------------------------- main ---------------------------------- */
	
	j = *indsize - 1;
	for(i = 0; i < j; i++)
        {
	        tid = (oid) i;
		*lst_newindex++ = lst_newpre - s_newpre;
               
                /* copy old nodes to new index */
                if (cur_oldindex < lst_oldindex && tid == *(oid*)BUNhead(oldindexi, cur_oldindex))
                {
		        lst_copy = *(int*) BUNtail(oldindexi, cur_oldindex + 1);
		        while (cur_oldpre < lst_copy)
		        {
			        *lst_newpre++ = *(oid*)BUNtail(oldprei, cur_oldpre);
			        *lst_newsize++ = *(int*)BUNtail(oldsizei, cur_oldsize);
			        cur_oldpre++;
			        cur_oldsize++;
		        }
                        cur_oldindex++;
                }
                /* merge-in new nodes */
                while(cur_tidpre < lst_tidpre && tid == *(oid*)BUNhead(tidprei, cur_tidpre))
                {
                        *lst_newpre++ = *(oid*)BUNtail(tidprei, cur_tidpre);
                        *lst_newsize++ = *(int*)BUNtail(tidsizei, cur_tidsize);
	        	cur_tidpre++;
	        	cur_tidsize++;
                }
        }

	/* write limit of index as last item to index bat */
	*lst_newindex = lst_newpre - s_newpre;
	lst_newindex++;

	/* ---------------------------- tidy up --------------------------------- */

	BATsetcount(newindex, lst_newindex - s_newindex);
    	newindex->batDirty = TRUE;
        newindex->hsorted = GDK_SORTED;
        newindex->tsorted = GDK_SORTED;
        BATkey(newindex, TRUE);
        BATkey(BATmirror(newindex), FALSE);
	BATseqbase(newindex, (oid)0);

	BATsetcount(newpre, lst_newpre - s_newpre);
    	newpre->batDirty = TRUE;
        newpre->hsorted = GDK_SORTED;
        newpre->tsorted = FALSE;
        BATkey(newpre, TRUE);
        BATkey(BATmirror(newpre), TRUE);
	BATseqbase(newpre, (oid)0);
	
	BATsetcount(newsize, lst_newsize - s_newsize);
    	newsize->batDirty = TRUE;
        newsize->hsorted = GDK_SORTED;
        newsize->tsorted = FALSE;
        BATkey(newsize, TRUE);
	BATseqbase(newsize, (oid)0);
	
        /* insert bats in result */		
	BATseqbase(res, (oid)0);
	voidfix_bunfastins_nocheck_noinc(res, lst_res, 0, (void*)&newindex->batCacheid);
	BBPunfix(newindex->batCacheid);	
	lst_res++;
	voidfix_bunfastins_nocheck_noinc(res, lst_res, 0, (void*)&newpre->batCacheid); 
	BBPunfix(newpre->batCacheid);	
	lst_res++;
	voidfix_bunfastins_nocheck_noinc(res, lst_res, 0, (void*)&newsize->batCacheid); 
	BBPunfix(newsize->batCacheid);	
	lst_res++;
	
	BATsetcount(res, 3);
	res->batDirty = TRUE;
	BATkey(res, TRUE);
	BATkey(BATmirror(res), TRUE);
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
	
	*result = res;
	return GDK_SUCCEED;
}

int CMDindexfetchjoin ( BAT** result, BAT* tid, BAT* index, BAT* pre )
{
	char *name = "TJindexfetchjoin";
	BAT *res = NULL;
        oid *sdst = NULL, *hdst = NULL, *tdst = NULL;

	int ressize = 0;
	oid t, *ind;
	BUN p, q;
        int j, i = 0;
	/* bit one_tid = FALSE; */
    
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tid, name);
	BATcheck(index, name);
	BATcheck(pre, name);
	
        /* if (BATcount(tid) <= 1) one_tid = TRUE; */
	
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	/* ---------------------------- inits ---------------------------------- */

	ind = (oid*)GDKmalloc(sizeof(oid) * BATcount(tid) * 3);
        if (ind == NULL) 
        { 
            	GDKerror("%s: could not allocate a offset stack of size %d.\n", name, BATcount(tid));
            	return(GDK_FAIL);
        }
	
        BATiter tidi = bat_iterator(tid);
	BATloop(tid, p, q) {
		t = *(oid*) BUNtail(tidi, p);
		ind[i++] = t;
		ind[i++] = *(oid*) Tloc(index, (int)t);
		ind[i++] = *(oid*) Tloc(index, (int)t + 1);
		ressize += (ind[i - 1] - ind[i - 2]);
	}
	
	res = BATnew(TYPE_oid, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[oid,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	sdst = hdst = (oid*)Hloc(res, BUNlast(res));
               tdst = (oid*)Tloc(res, BUNlast(res));
	
	/* ----------------------------- main ---------------------------------- */

	j = 0;
	while (j < i) {
        	t = ind[j++];
		p = ind[j++];
		q = ind[j++];
		for (; p < q; p++) {
			*hdst++ = t;
			*tdst++ = *(oid*)Tloc(pre,p);
		}
	}

	/* ---------------------------- tidy up --------------------------------- */

	GDKfree(ind);
	BATsetcount(res, hdst - sdst);
    	res->batDirty = TRUE;
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
        BATkey (BATmirror(res), TRUE);
	BATset(res, TRUE);
	
	*result = res;
	return GDK_SUCCEED;
}

@= init_result
{
	REGISTER BUN _p = BUNlast(bn);

	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloop(e, p, q) {
		oiddbl_bunfastins_nocheck_noinc(bn, _p, Hloc(e,p), &zero);
		_p++;
	}
	ALGODEBUG THRprintf(GDKout, "#init_result(dbl): BAThordered(e)&1, \n");
	BATsetcount(bn, _p - BUNfirst(bn));
	if ( !BATprepareHash(bn) ) {
	    /* do nothing yet */;	
	}
	if (!bn->batDirty)
		bn->batDirty = TRUE;
}
@

@c
#define max_stack_size 128

typedef struct stack_item si;

struct stack_item {
    oid ctx;            /* ctx */
    oid eocs;           /* end of ctx scope (pre + size) */
};

int CMDtreemergejoin_sort(BAT **result, BAT *Astart, BAT *nid_size, BAT *Dstart) {

    /* ---------------------------- declarations ------------------------------------ */
    char *name = "TJ_treemergejoin_sort";
    BAT *res = *result;
    BUN D_cur, D_last, 
        A_cur, A_last;
    BATiter Ai, Di;
    oid D_cur_pre;

    si *stack; 
    int stack_top = 0, i;
	
    int *size;
    int free;	
    oid *sdst = NULL, *hdst = NULL, *tdst = NULL;
    
    /* ------------------------------- checks ---------------------------------------- */
    if (!(BATtordered(Astart)&1)) { 
        GDKerror("%s: Ancestor pre BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(Dstart)&1)) { 
        GDKerror("%s: Descendant BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (nid_size->ttype != TYPE_int) {
        GDKerror("%s: tail of size BAT must be type INT.\n", name);
        return(GDK_FAIL);
    }
    if (nid_size->htype != TYPE_void) {
        GDKerror("%s: head (oid) of size BAT must NOT be materialized.\n", name);
        return(GDK_FAIL);
    }
    if (BATcount(Astart) == 0 || BATcount(nid_size) == 0 || BATcount(Dstart) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_oid, 0);
        *result = res;    
        return(GDK_SUCCEED);
    }

    /* ----------------------------- initialize -------------------------------------- */
    // The maximum depth of the stack is the depth of the XML tree
    if ((stack = (si*)GDKmalloc(sizeof(si) * max_stack_size)) == NULL) {
        GDKerror("treemergejoin_sort: could not allocate memory for stack.\n"); 
        return(GDK_FAIL);
    }

    // the size of the bat may not be correct (could be more, could be less)
    free = BATcount(Dstart);
    res = BATnew(TYPE_oid, TYPE_oid, free); 
    if (res == NULL) 
    { 
       GDKerror("%s: could not allocate result BAT.\n", name);
       return(GDK_FAIL);
    }
    
    size = ((int*) Tloc(nid_size, BUNfirst(nid_size))) - (int)nid_size->hseqbase;
    D_cur = BUNfirst(Dstart);
    D_last = BUNlast(Dstart);  
    A_cur = BUNfirst(Astart);
    A_last = BUNlast(Astart);
    Ai = bat_iterator(Astart);
    Di = bat_iterator(Dstart);
    sdst = hdst = (oid*)Hloc(res, BUNlast(res));
           tdst = (oid*)Tloc(res, BUNlast(res));

    /* -------------------------------- main ---------------------------------------- */
    
    while(D_cur < D_last) {
      
      D_cur_pre = *(oid*)BUNtail(Di, D_cur);
      /* printf("0. eocs: %d, desc: %d\n", stack[stack_top-1].eocs, *(oid*)BUNtail(Di, D_cur)); */
      
      /* remove ancestor candidates that ended before D_cur */
      while (stack_top && D_cur_pre > stack[stack_top-1].eocs) {
        /* pop */
	stack_top--;
      }	
      
      /* printf("1.stacksize: %d\n", stack_top); */
      
      /* Put ancestors on stack until we reach the current descendent */ 
      while (A_cur < A_last && *(oid*)BUNtail(Ai, A_cur) < D_cur_pre){		
	if (D_cur_pre <= (*(oid*)BUNtail(Ai, A_cur) + size[*(oid*)BUNhead(Ai, A_cur)])) {
           /* push */
	   si new_stack_item;
           new_stack_item.ctx = *(oid*)BUNhead(Ai, A_cur);
           new_stack_item.eocs = *(oid*)BUNtail(Ai, A_cur) + size[*(oid*)BUNhead(Ai, A_cur)];
           stack[stack_top++] = new_stack_item;
	}
	A_cur++;
      }
      
      /* output everything that is on the stack (the ancestors) */
      /* It has started before Dstart and since it's a tree, */
      /* it has to end after Dend. */
      free -= stack_top;
      if (free < 0)
      {
     	BATsetcount(res, hdst - sdst);
	size_t sz = BATgrows(res);
	if (BATextend(res, sz) == NULL)
    	{ 
       	  GDKerror("%s: could not extend result BAT.\n", name);
          return(GDK_FAIL);
    	}
        sdst = (oid*)Hloc(res, BUNfirst(res));
        hdst = (oid*)Hloc(res, BUNlast(res));
        tdst = (oid*)Tloc(res, BUNlast(res));
	free = sz - BATcount(res) - stack_top;
      }
     
      for (i=0;i<stack_top;i++) {
        /* printf("3. anc/desc: (%d/%d)\n", stack[i].ctx, *(oid*)BUNtail(Di, D_cur)); */
        *hdst++ = stack[i].ctx;
        *tdst++ = *(oid*)BUNhead(Di, D_cur);
      }
      D_cur++;
    }
    
    /* ----------------------------- tidy up -------------------------------------- */
     GDKfree(stack); 
	
     BATsetcount(res, hdst - sdst);
     res->batDirty = TRUE;
     res->tsorted = FALSE;
     res->hsorted = FALSE;
     BATset(res, TRUE);
     
     *result = res;    
     /* it is possible there are still ancestor candidates left on the stack, but we are out of descendants, so they starve... */
     return(GDK_SUCCEED);
}

int CMDtreemergejoin_sort_unnested(BAT **result, BAT *Astart, BAT *nid_size, BAT *Dstart) {

    /* ---------------------------- declarations ------------------------------------ */
    char *name = "TJ_treemergejoin_sort_unnested";
    BAT *res = *result;
    BUN D_cur, D_last, 
        A_cur, A_last;
    BATiter Ai, Di;
    oid D_cur_pre;
    int *size;
    int free;	
    oid *sdst = NULL, *hdst = NULL, *tdst = NULL;
    
    /* ------------------------------- checks ---------------------------------------- */
    if (!(BATtordered(Astart)&1)) { 
        GDKerror("%s: Ancestor pre BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(Dstart)&1)) { 
        GDKerror("%s: Descendant BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (nid_size->ttype != TYPE_int) {
        GDKerror("%s: tail of size BAT must be type INT.\n", name);
        return(GDK_FAIL);
    }
    if (nid_size->htype != TYPE_void) {
        GDKerror("%s: head (oid) of size BAT must NOT be materialized.\n", name);
        return(GDK_FAIL);
    }
    if (BATcount(Astart) == 0 || BATcount(nid_size) == 0 || BATcount(Dstart) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_oid, 0);
        *result = res;    
        return(GDK_SUCCEED);
    }

    /* ----------------------------- initialize -------------------------------------- */
    // the size of the bat may not be correct (could be more, could be less)
    free = BATcount(Dstart);
    res = BATnew(TYPE_oid, TYPE_oid, free); 
    if (res == NULL) 
    { 
       GDKerror("%s: could not allocate result BAT.\n", name);
       return(GDK_FAIL);
    }
    
    size = ((int*) Tloc(nid_size, BUNfirst(nid_size))) - (int)nid_size->hseqbase;
    D_cur = BUNfirst(Dstart);
    D_last = BUNlast(Dstart);  
    A_cur = BUNfirst(Astart);
    A_last = BUNlast(Astart);
    Ai = bat_iterator(Astart);
    Di = bat_iterator(Dstart);
    sdst = hdst = (oid*)Hloc(res, BUNlast(res));
           tdst = (oid*)Tloc(res, BUNlast(res));

    /* -------------------------------- main ---------------------------------------- */
    
    /* skip descendant candidates before the next ancestor candidate */
    while(D_cur < D_last && *(oid*)Tloc(Dstart, D_cur) <= *(oid*)Tloc(Astart,A_cur))
      D_cur++; 
      
    while(D_cur < D_last && A_cur < A_last) {
      
      /* skip ancestor candidates before the next descendant candidate */
      D_cur_pre = *(oid*)Tloc(Dstart, D_cur);
      /* poor man's binary search / exploiting forward scan */ 
      while (A_cur+1048576 < A_last && *(oid*)Tloc(Astart, A_cur+1048576) < D_cur_pre)
          A_cur += 1048576; 
      while (A_cur+32768 < A_last && *(oid*)Tloc(Astart, A_cur+32768) < D_cur_pre)
          A_cur += 32768; 
      while (A_cur+1024 < A_last && *(oid*)Tloc(Astart, A_cur+1024) < D_cur_pre)
          A_cur += 1024;  
      while (A_cur+1 < A_last && *(oid*)Tloc(Astart, A_cur+1) < D_cur_pre)
          A_cur++;

      /* write to result */ 
      while (D_cur < D_last && *(oid*)Tloc(Dstart, D_cur) <= (*(oid*)Tloc(Astart, A_cur) + size[*(oid*)BUNhead(Ai, A_cur)])) {
          *hdst++ = *(oid*)BUNhead(Ai, A_cur);
          *tdst++ = *(oid*)BUNhead(Di, D_cur);
          D_cur++;
      }
      /* this ancestor cannot have further results (tree properties) */
      A_cur++;
    
      /* skip descendant candidates before the next ancestor candidate */
      if (A_cur < A_last)
          while(D_cur < D_last && *(oid*)Tloc(Dstart, D_cur) <= *(oid*)Tloc(Astart,A_cur))
              D_cur++; 
    }
    
    /* ----------------------------- tidy up -------------------------------------- */
    BATsetcount(res, hdst - sdst);
    res->batDirty = TRUE;
    if (BAThordered(Astart)&1) res->hsorted = GDK_SORTED;
    if (BAThordered(Dstart)&1) res->tsorted = GDK_SORTED;
    BATset(res, TRUE);
    
    *result = res;    
    return(GDK_SUCCEED);
}

bat *
pftijah_prelude(void)
{
    if (!TBL_module_lookup("pathfinder"))
        GDKerror("pathfinder must be loaded first.");
    termdb_prelude();
    return NULL;
}

void
pftijah_epilogue(void)
{
}

@
/* vim:set shiftwidth=4 expandtab: */
