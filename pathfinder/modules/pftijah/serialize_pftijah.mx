@' -----------------
@'
@' The contents of this file are subject to the PfTijah Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://dbappl.cs.utwente.nl/Legal/PfTijah-1.1.html
@' 
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@' 
@' The Original Code is the PfTijah system.
@' 
@' The Initial Developer of the Original Code is the "University of Twente".
@' Portions created by the "University of Twente" are 
@' Copyright (C) 2006-2007 "University of Twente".
@' All Rights Reserved.
@'

@f serialize_pftijah
@a Jan Flokstra
@a Henning Rode
@t serialize_pftijah

@h
struct tijahContextStruct;

extern int handleTijahTerm(struct tijahContextStruct *ctx, char* term);

extern int tokenize_flex(char* buf, struct tijahContextStruct* tjCtx);
extern int tokenize_fast(char* buf, struct tijahContextStruct* tjCtx);

extern char* flexScanOneTerm(char* buf);

extern char* normalizeTerm(struct tijahContextStruct *ctx, char* term );

extern int CMDtj_normalizeTerm(char** res, char *term, char *stemmer);

@c
#include <pf_config.h>

/* #define TJ_TRACE 1 */

/* #define USE_INEX_PATH 1 */

/*******************************************
 * serialize_pftijah.c : XML serialization
 *
 */

#include "stream.h"
#include "pf_support.h"
#include "serialize.h"
/* contains dummy callback functions */
#include "serialize_null.h"

#include "serialize_pftijah.h"
#include <gdk.h>

#include "pftijah_stem.h"

#include "pftijah_util.h"

#include "termdb.h"

#include "shredder.h"

/************************************************
 *
 * The fast direct BAT interface
 */

typedef struct dbat_struct {
	const char*	name;
	BAT*		bat;
	BUN		raw_max;
	oid		seqbase;
	oid		seq_max;
        union { /* cast to perform direct indexe insert in [void,any] BATs */
            void* voidCAST; /* the basecast */
            chr*  chrCAST;  /* cast for [void,chr] BAT */
            int*  intCAST;  /* cast for [void,int] BAT */
            oid*  oidCAST;  /* cast for [void,oid] BAT */
        } cast;
} dbat;

int dbat_init(const char* name, dbat* dbat, BAT* b) {
	dbat->name = name;
	dbat->bat  = b;
	if ( dbat->bat->htype != TYPE_void ) {
	    stream_printf(GDKerr,"ERROR: dbat_init(%s) non void BAT\n",dbat->name);
	    return 0;
	}
	if ( !((dbat->bat->ttype == TYPE_oid) || (dbat->bat->ttype == TYPE_int)) ) {
	    stream_printf(GDKerr,"ERROR: dbat_init(%s) unknown ttype(%d)\n",dbat->name,dbat->bat->ttype);
	    return 0;
	}
        dbat->seqbase = (oid)b->hseqbase;
	dbat->raw_max = BATcount(dbat->bat);
	dbat->seq_max = (oid) (dbat->raw_max + dbat->seqbase);
        dbat->cast.voidCAST = (void*)Tloc(dbat->bat,BUNfirst(dbat->bat));
	/* */
	return 1;
}


int dbat_finalize(dbat* dbat, oid topidx) {
        BAT* b = dbat->bat;
	
        topidx -= dbat->seqbase;
        BATsetcount(b, topidx);
        b->tsorted  = 0;
	b->batDirty = TRUE; /* VERY important this one */
	/* */
	dbat->name  = NULL;
	dbat->bat   = NULL;
	dbat->raw_max = 0;
	dbat->seqbase = 0;
	/* */
	return 1;
}

#define MINCHUNK 8192
#define MAXCHUNK 67108864

static void
dbat_setcount(dbat *dbat, oid n)
{
    BAT *b = dbat->bat;
    BATsetcount(b, n);
    if (b->ttype) {
        b->tsorted = 0;
        b->tdense = 0;
    }
}

static int
dbat_extend(dbat* dbat, oid min_i /*raw-index*/, BUN forced_size) {
    BUN newsize;
    
    dbat_setcount(dbat, dbat->raw_max);
    if ( forced_size ) {
       newsize = forced_size;
    } else {
       newsize = MAX(MIN(MAX(MINCHUNK,dbat->raw_max*2),(BUN)(dbat->raw_max+MAXCHUNK)),(BUN)min_i);
    }

    /* first check if the number of BUN's < GDK_oid_max. If this was the case
     * and the previous time GDK_oid_max was returned this means the BAT cannot
     * grow any longer.
     */
    if ( newsize > GDK_oid_max ) {
    	newsize = GDK_oid_max;

	if ( dbat->raw_max == GDK_oid_max ) {
        	GDKerror("dbat_extend: BATextend[\"%s\"](size>GDK_oid_max) fails\n","incomplete");
		return -1;
	}
    }
#if 1
    /* copied this form shredder.mx, keep it here ??? */
    if (newsize+newsize > (BUN) REMAP_PAGE_MAXSIZE) { /* try to use mmap() */
        BATmmap(dbat->bat, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP);
    }

#endif

#if 0
    stream_printf(GDKout,"dbat_extend[%s](" BUNFMT " -> " BUNFMT ")\n",dbat->name,dbat->raw_max,newsize);
#endif

    dbat->raw_max = newsize;
    dbat->seq_max = (oid) (dbat->raw_max + dbat->seqbase);
    if ( !(dbat->bat = BATextend(dbat->bat,newsize)) ) {
        GDKerror("dbat_extend: BATextend[\"%s\"](to " BUNFMT ") fails\n","incomplete",newsize);
        return -1;
    }
    dbat->cast.voidCAST = (void*)Tloc(dbat->bat,BUNfirst(dbat->bat));
    return 1;
}

#if 0
static int
dbat_sizeHint(dbat* dbat, int sizeHint_mark) {
        int sizeHint = sizeHint_mark - dbat->seqbase;
	BUN estimate = dbat->raw_max + sizeHint;

	return dbat_extend(dbat, estimate, 0);
}
#endif

#define dbat_set_oid(DBAT,I,V) (DBAT)->cast.oidCAST[I-(DBAT)->seqbase] = V

#define dbat_set_int(DBAT,I,V) (DBAT)->cast.intCAST[I-(DBAT)->seqbase] = V

#if 0
static void
dbat_int_debug(char* t, dbat* dbat) {
	stream_printf(GDKout,"+ DEBUGGING INT DBAT[sz=%d]@=[%s]:\n",dbat->seq_max,t);
	for(int i=0; i<10; i++) {
	     stream_printf(GDKout,"+ dbat[%d] = %d\n",i,dbat->cast.intCAST[i]);
	}
}
#endif

#ifdef USE_INEX_PATH

/* this def is copied from libxml2/parserInternals.h */
#define XML_MAX_NAMELEN 100

/*
 * Start of the implementation of the INEX path generator. During indexing
 * this structure will keep track of the used tags in the current path. The
 * number of times a tagname is used as a child of the current parent is
 * counted and printed in the current path. For every element node the
 * path is stored in the tj_FTINDEX_path bat.
 *
 */


/*
 * The main stackframe bat is a union of two possiblilities.
 * The stack consists of a 'level' frame followed by a number of tags used 
 * at this level. A typical stack may looks like:
 * 
 * tag
 * tag
 * tag
 * level
 * tag
 * tag
 * level
 * tag
 * level[bottom]
 */
typedef union {
	struct {
		int ntags;	/* number of tags at this level */
		int subpath;	/* index of subpath in printbuffer */
		int subpathno;	/* index of subpath in printbuffer */
		int prev_frame;	/* previous level frame, -1 for bottom */
	} level;
	struct {
		char	strVal[XML_MAX_NAMELEN];/* string value of tagname */
		int	cnt;	/* number of times used at this level */
	} tag;
} IpgFrame;

/* The main structure managing the Inex path stack and printbuffer */
typedef struct InexPathGenBase {
	BAT*		b_pre_path;	/* [oid,str] bat where path is stored*/
	BAT*		b_pre_pathno;	/* [oid,str] bat where path sibling numbers are stored*/
	int		top;		/* index of the top of the stack */
	int		max;		/* maximum possible size of stack */
	IpgFrame*	stack;		/* the physical stack */
	char*		pathbuff;	/* the path printing buffer */
	char*		pathnobuff;	/* the path printing buffer */
} IpgBase;

#define IPG_INIT_STACKSZ	256

#define IPG_INIT_PATHSZ		8192


static IpgBase* ipg_init(BAT* b_path, BAT* b_no) {

	IpgBase* res;
	if ( !(res = (IpgBase*)GDKmalloc( sizeof(IpgBase) )) )
		return NULL;
	res->b_pre_path = b_path;
	res->b_pre_pathno = b_no;
	res->top = 0;
	res->max = IPG_INIT_STACKSZ;
	res->stack = (IpgFrame*)GDKmalloc( res->max * sizeof(IpgFrame) );
	if ( !res->stack )
		return NULL;
	res->pathbuff = (char*)GDKmalloc( IPG_INIT_PATHSZ );
	res->pathnobuff = (char*)GDKmalloc( IPG_INIT_PATHSZ );
	if (0) stream_printf(GDKout,"-IPG[ipg_init() called.]\n");
	return res;
}

/* function used for starting a new document */
static int ipg_startdoc(IpgBase* base, str doc) {
	if (0) stream_printf(GDKout,"-IPG[start: doc=%s]\n",doc);
	base->top				= 0;
	base->stack[base->top].level.ntags	= 0;
	base->stack[base->top].level.prev_frame	= -1;
	if ( 1 /* Henning: use docnames in path */ )
		sprintf(base->pathbuff,"%s","");
	else
		sprintf(base->pathbuff,"fn:doc(\"%s\")",doc);
	sprintf(base->pathnobuff,"%s","");
	base->stack[base->top].level.subpath = strlen(base->pathbuff);
	base->stack[base->top].level.subpathno = strlen(base->pathnobuff);
	return 1;
}

/* allocate one new frame element on top of stack */
static INLINE int ipg_frame_alloc(IpgBase* base) {
	int newtop = base->top+base->stack[base->top].level.ntags + 1;

	if ( newtop >= base->max ) {
		if (1) stream_printf(GDKout,"-IPG[ipg_frame_alloc() extending.]\n");
		base->max = 2 * base->max;
		base->stack = (IpgFrame*)GDKrealloc(base->stack, 
				base->max * sizeof(IpgFrame) );
		if ( !base->stack )
			return -1;
	}
	return newtop;
}

static int ipg_pushtag(IpgBase* base, str tag, oid o) {
	IpgFrame* found = NULL;

	for(int i=0; i< base->stack[base->top].level.ntags && !found; i++) {
		IpgFrame* f = & base->stack[base->top+i+1];

		if (strcmp(f->tag.strVal,tag) == 0 ) {  
			found = f;
		}
	}
	if ( !found ) {
		ipg_frame_alloc(base);
		base->stack[base->top].level.ntags++;
		found = & base->stack[base->top+base->stack[base->top].level.ntags];
		strcpy(found->tag.strVal,tag);
		found->tag.cnt = 0;
	}
	found->tag.cnt++;

	/* now push a new frame on stack */
	int newtop = ipg_frame_alloc(base);
	base->stack[newtop].level.ntags = 0;
	base->stack[newtop].level.prev_frame = base->top;
        
	/* Henning */
	if (1) {
	        if (strcmp(tag,"collection") != 0 && strcmp(tag,"docs") != 0) {
	                sprintf(&base->pathbuff[base->stack[base->top].level.subpath],"/%s",tag);
	                sprintf(&base->pathnobuff[base->stack[base->top].level.subpathno],".%d",found->tag.cnt);
                }
	} else {
	        sprintf(&base->pathbuff[base->stack[base->top].level.subpath],"/%s",tag);
	        sprintf(&base->pathnobuff[base->stack[base->top].level.subpathno],".%d",found->tag.cnt);
	}

	base->stack[newtop].level.subpath = strlen(base->pathbuff);
	base->stack[newtop].level.subpathno = strlen(base->pathnobuff);

	base->top = newtop;

	if ( !BUNins(base->b_pre_path, &o,(str)base->pathbuff, 0)) {
	        GDKerror("error writing recursive tagbat");
	        return -1;
	} 
	if ( !BUNins(base->b_pre_pathno, &o,(str)base->pathnobuff, 0)) {
	        GDKerror("error writing recursive tagbat");
	        return -1;
	}

	if (0) stream_printf(GDKout,"-IPG[tijah(" OIDFMT "@0) = %s]\n",o,base->pathbuff);

	return 1;
}

static INLINE int ipg_poptag(IpgBase* base) {
	base->top = base->stack[base->top].level.prev_frame;

	/* stream_printf(GDKout,"-IPG[pop: path=%s]\n",base->pathbuff); */
	return 1;
}

static int ipg_destroy(IpgBase* base) {
	GDKfree(base->stack);
	GDKfree(base->pathbuff);
	GDKfree(base->pathnobuff);
	GDKfree(base);
	if (0) stream_printf(GDKout,"-IPG[ipg_destroy() called.]\n");
	return 1;
}

#endif

/************************************************
 *
 * The Tijah-Pathfinder index creation context
 */

typedef struct tijahContextStruct {
	char* name;		/* name of the collection */
	oid  n_globalTerm;
	BAT* b_globalTerm;	/* global term dictionary*/
	BAT* hm_globalTerm;	/* hashed mirrorred global term dictionary*/
#ifdef USE_TERMDB
	termDbCtx* tdb;
#endif
        oid  level_pre[MAXTAGDEPTH];

	oid  n_globalTag;
	BAT* b_globalTag;	/* global tag dictionary*/
	BAT* hm_globalTag;	/* hashed mirrorred global tag dictionary*/

	int   tagswitch_sz;	/* the size of the next buff */
	char* tagswitch;	/* the recursive tag detector switch */
				/* 0 means: tag is not in use */
				/* 1 means: tag is in use */
				/* 2 means: tag is recursive */
	BAT* b_globalRTag;	/* recursive tag dictionary*/

	BAT* b_docName;		/* BAT to store docnames in collection */
	BAT* b_docFirstPre;	/* First tijah-pre-nr of document */
	BAT* b_collParam;	/* Collection Parameters BAT */
	/* */
	unsigned int  fragmentSize;	/* maximum frament size, new frag if larger */
	oid  tijahPre;		/* Current max tijahpre number */
	/* INCOMPLETE< SHOULD BE FRAGMENTED */
	BAT* b_collPre;		/* Main tijah pre BAT */
	dbat dbat_collPre;	/* Direct access struct for b_collPre */
	/* INCOMPLETE< SHOULD BE FRAGMENTED */
	BAT* b_collSize;	/* Tijah PRE-size BAT */
	dbat dbat_collSize;	/* Direct access struct for b_collSize */
	/* INCOMPLETE< SHOULD BE FRAGMENTED */
#ifdef USE_INEX_PATH
	BAT* b_collPath;	/* Tijah PRE-INEX-PATH BAT */
	BAT* b_collPathNo;	/* Tijah PRE-INEX-PATH (sibling numbers in path) BAT */
#endif
	/* */
	BAT* b_collPfPre;	/* Tijah PRE-PF BAT for Pathinder link */
	/* */
	BAT* b_conceptdict;
	BAT* b_concept_tid;
	BAT* b_concept_elem;
	BAT* b_concept_score;

	str  dict_handler;
	str  dict_id;
	str  dict_score;

	/*
	 */
	int		doc_height;
	int		max_doc_height;
	/* The BAT's for the tag selection and associated counters
	 */
	BAT* b_filtering;	/* [void,str] BAT containing select tags */
	int  filterDepth;	/* */
	int  whitelisting;	/* bool, if not: blacklisting */
	int  emitting;		/* boolean indicating emit */
	/* The tagStartStack[] contains the starting Tijah oid of an element
	 * and is used to compute the size of an element in the Tijah
	 * pre-post-plane.
	 */
	oid  tagStartStack[MAXTAGDEPTH];
	int  tagOidStack[MAXTAGDEPTH];
	int  tagStackPtr;
	/* */
	int preExpansion;	/* estimation for #TijahPre/PfPre */
	int tokenize_fast;	/* boolean to indicate fast tokenizer */
	char* stemmer;	/* name of the stemmer used for this collection */
	tjStemCtx* stemCtx;
	char	checkStopWords;
	oid	lastStopWord;
#ifdef USE_INEX_PATH
	IpgBase* ipg;
#endif
} tjCtx;

#define DOEMIT(TJCTX)	((TJCTX)->emitting)

static INLINE int
tj_pushTag(tjCtx* tjctx, oid start, oid tagoid) {
	if ( tjctx->tagStackPtr > MAXTAGDEPTH ) {
	     GDKerror("tj_pushTag: MAXTAGDEPTH exceeded.\n");
	     return -1;
	}
	if ( tjctx->tagswitch[(int)tagoid] != 2 ) {
	    tjctx->tagswitch[(int)tagoid]++;
	}
	tjctx->tagOidStack[tjctx->tagStackPtr] = (int)tagoid;
	tjctx->tagStartStack[tjctx->tagStackPtr++] = start;
	return 1;
}

INLINE static oid
tj_popTag(tjCtx* tjctx) {
	--tjctx->tagStackPtr;
	if ( tjctx->tagswitch[tjctx->tagOidStack[tjctx->tagStackPtr]] != 2 ) {
	    tjctx->tagswitch[tjctx->tagOidStack[tjctx->tagStackPtr]]--;
	}
	return tjctx->tagStartStack[tjctx->tagStackPtr];
}

/************************************************
 *
 */

INLINE static oid
tj_tagOid(tjCtx* tjctx, str t) {
#ifdef USE_TERMDB
    /* incomplete, also tag check here */
    return tdb_lookupTag(tjctx->tdb,t);
#else
    BUN bun;

    // stream_printf(GDKout,"tj_tagOid(\"%s\"): start\n",t);
    BATiter bi = bat_iterator(tjctx->hm_globalTag);
    HASHfnd_str(bun, bi, (str)t);
    if ( bun != BUN_NONE ) {
        // stream_printf(GDKout,"tj_tagOid(\"%s\"): bun found @ %d\n",t,bun);
        return (oid)bun;
        // return *(oid*)BUNtail(tjctx->hm_globalTag,bun);
    } else {
        // stream_printf(GDKout,"tj_tagOid(\"%s\"): bun not found\n",t);
    	// if ( BUNins(tjctx->b_globalTag, &tjctx->n_globalTag, (str)t, FALSE) ) {
    	if ( BUNappend(tjctx->b_globalTag, (str)t, FALSE) ) {
	    /* check if the recursive tagswitcher still is large enough */
    	    if ( (int)tjctx->n_globalTag >= tjctx->tagswitch_sz ) {
                int old = tjctx->tagswitch_sz;
		tjctx->tagswitch_sz = 2*(int)tjctx->n_globalTag;
		tjctx->tagswitch    = GDKrealloc(tjctx->tagswitch,tjctx->tagswitch_sz );
		for(int i=old; i<tjctx->tagswitch_sz; i++)
	            tjctx->tagswitch[i] = 0;
            }
    	    return tjctx->n_globalTag++;
        } else {
            stream_printf(GDKout,"tj_tagOid(\"%s\"): insert error\n",t);
    	    GDKerror("INSERT OF \"%s\" in globalTag fails.\n");
    	    return oid_nil;
        }
    }
#endif
}

INLINE static oid
tj_checkTerm(tjCtx* tjctx, char *t) {
#ifdef USE_TERMDB
   INCOMPLETE
#endif
   BUN bun;

   BATiter bi = bat_iterator(tjctx->hm_globalTerm);
   HASHfnd_str(bun, bi, (str)t);
   // return ( (bun != BUN_NONE) ? *(oid*)BUNtail(tjctx->hm_globalTerm,bun) : oid_nil );
   oid res = ( (bun != BUN_NONE) ? (oid)bun : oid_nil );
   return (res < tjctx->lastStopWord) ? 0 : res;
}

INLINE static oid
tj_termOid(tjCtx* tjctx, char *t) {
#ifdef USE_TERMDB
    return tdb_lookupTerm(tjctx->tdb,t);
#else
    BUN bun;

    BATiter bi = bat_iterator(tjctx->hm_globalTerm);
    HASHfnd_str(bun, bi, (str)t);
    if ( bun != BUN_NONE ) {
        oid res = (oid)bun;

	if ( 0 && res < tjctx->lastStopWord ) stream_printf(GDKout,"SKIP STOPWORD[\"%s\"]\n",t);
	return (res < tjctx->lastStopWord) ? 0 : res;
    } else {
    	// if ( BUNins(tjctx->b_globalTerm, &tjctx->n_globalTerm, (str)t, FALSE)){
    	if ( BUNappend(tjctx->b_globalTerm, (str)t, FALSE)){
	    if (0) stream_printf(GDKout,"N-WORD[\"%s\"]=%d@0\n",t,tjctx->n_globalTerm);
    	    return tjctx->n_globalTerm++;
        } else { 
    	    GDKerror("INSERT OF \"%s\" in globalTerm fails.\n");
    	    return oid_nil;
        }
    }
#endif
}

INLINE static oid
tj_extend_plane(struct tijahContextStruct *tjctx) {
    oid base = tjctx->tijahPre - tjctx->dbat_collPre.seqbase; 

    if ( base >= tjctx->dbat_collPre.raw_max ) {
	if ( dbat_extend(&tjctx->dbat_collPre,base, 0) < 0 )
	    return oid_nil;
	/* IMPORTANT: the size of the two bats is synchronized by the use
	 * of the forced size (last) parameter of dbat_extend
	 */
	if ( dbat_extend(&tjctx->dbat_collSize,base,tjctx->dbat_collPre.raw_max) < 0 )
	    return oid_nil;
    }
    return tjctx->tijahPre++;
}

#define tj_newPre(TJCTX) \
	(((TJCTX)->tijahPre < (TJCTX)->dbat_collPre.seq_max) \
	? \
	((oid)(TJCTX)->tijahPre++) : tj_extend_plane(TJCTX))

int
handleTijahTerm(struct tijahContextStruct *tjctx, char* term) {
    oid termOid, tjPre;

    if ( DOEMIT(tjctx) ) {
        if ( (termOid = tj_checkTerm(tjctx, term)) == oid_nil ) {
          if ( tjctx->stemCtx->stem) {
    	    if ( !(term = (char*)tjctx->stemCtx->stem(tjctx->stemCtx,(char*)term)) ) {
	        /* must be a stopword */
	        return 1;
	    }
          }
          if ( (termOid = tj_termOid(tjctx, term)) == oid_nil )
    	    return -1;
	}
	if ( termOid ) { /* term is not a stopword */
            if ( (tjPre = tj_newPre(tjctx) ) == oid_nil )
    	        return 0;
            dbat_set_oid(&tjctx->dbat_collPre, tjPre, termOid);
            dbat_set_int(&tjctx->dbat_collSize,tjPre,0);
#ifdef TJ_TRACE
            if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:TERM: \"%s\", termoid=%d, tjPre=%d\n",tjctx->name,term,termOid,tjPre);
#endif
         } else {
#ifdef TJ_TRACE
            if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:STOPWORD: \"%s\"\n",tjctx->name,term);
#endif
	 }
     }
     return 1;
}

/************************************************
 *
 * Now the real output handlers
 */


#if 0
static int
handle_sizeHint(XqueryCtx* ctx, int hinted_size) {
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;

    int estimate = hinted_size * tjctx->preExpansion;

    if ( dbat_sizeHint(&tjctx->dbat_collPre,estimate) < 0 )
    	return 0;
    if ( dbat_sizeHint(&tjctx->dbat_collSize,estimate) < 0 )
    	return 0;
    return 1;
}
#endif

const char* delchars2 = " \t\n\r,";

static int init_tagFiltering(tjCtx* tjctx, char* kind, char *l) {
    char *t;
    int  cnt=0;

    (void)kind;

    /* determine kind of filtering */
    if ( strcmp(kind,"whitelist")==0 )
    	tjctx->whitelisting = 1;
    else 
        tjctx->whitelisting = 0;

    /* read the tags */
    if ( (t = strtok(l,delchars2)) ) do {
	/* not the empty string here */
	if ( cnt++ == 0 ) {
	    tjctx->b_filtering = BATmirror(BAThash(BATmirror(
	     		BATnew(TYPE_void, TYPE_str,32)),0));
	    if ( !tjctx->b_filtering ) {
	    	return 0;
	    }
	}
	str v = (str)t;
	oid my_oid_nil = oid_nil;
	if ( !BUNins(tjctx->b_filtering, &my_oid_nil, v, FALSE) )
	     return 0;
    } while ( (t=strtok(NULL,delchars2)) );

    /* set runtime status variables */
    tjctx->filterDepth = 0;
    tjctx->emitting    = !(tjctx->whitelisting);

    return 1;
}

/* 
 * Read the value of a collection parameter from the collection parameter bat
 */
static str readCollParam(tjCtx* tjctx, str param) {
	BUN bun;
        bun = BUNfnd(tjctx->b_collParam,param);
	if ( bun != BUN_NONE ) {
            BATiter bi = bat_iterator(tjctx->b_collParam);
	    return (str)BUNtail(bi,bun);
	} else
	    return (str)str_nil;
}

/* 
 * Replace the value of a collection parameter int the collection parameter
 * bat
 */
static int replaceCollParam(tjCtx* tjctx, str param, str val) {
	return ( BUNreplace(tjctx->b_collParam,param,val,FALSE) != NULL );
}

static BAT*
getBAT(BAT* batbat, str bname) {
	BUN bun;
	if ( (bun=BUNfnd(batbat,bname)) == BUN_NONE ) {
	    stream_printf(GDKerr,"getBAT:BUNfnd(%s) failed.\n",bname);
	    return NULL;
	}
        BATiter batbati = bat_iterator(batbat);
	BAT* res = BATdescriptor( *(bat*)BUNtail(batbati,bun));
	if ( !res )
	    stream_printf(GDKerr,"getBAT:BATdescriptor() for %s failed.\n",bname);
	return res;
}

static const char* stopwordMarker = "#STOPWORD#";

static oid getPreSize(tjCtx* tjCtx) {
	str str_tijahPre = readCollParam(tjCtx,"_last_tijahPre");
	oid par_tijahPre;
	if ( str_tijahPre != str_nil ) {
		par_tijahPre = (oid)atol(str_tijahPre);
        } else {
		par_tijahPre = 1;
	}
	if ( 0 /* CHECK */ ) {
            oid chk = (oid)BATcount(tjCtx->b_collPre) + 1; 
	    if ( par_tijahPre != chk ) {
		stream_printf(GDKerr,"ERROR: getPreSize: oid out of sync: %d <-> %d.\n",par_tijahPre,chk);
	        return oid_nil;
	    }
	}
	return par_tijahPre;
}

static int setPreSize(tjCtx* tjCtx, oid newSize) {
	char buff[16];

	sprintf(buff,OIDFMT,newSize);
	if ( !replaceCollParam(tjCtx, "_last_tijahPre", (str)buff) )
	    return 0;
	return 1;
} 

static tjCtx*
loadTijahContext(BAT* tjCtx_BAT) {
	tjCtx* res;

#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[]: start loadTijahContext\n");
#endif
	if ( !(res = (tjCtx*)GDKmalloc( sizeof(tjCtx) )) )
		return NULL;
	/*
	 * Set first settings
	 */

	/* set parameter bat first */
	if ( !(res->b_collParam   = getBAT(tjCtx_BAT,"param")) ) return NULL;

	res->preExpansion = 1;
	str str_preExpansion = readCollParam(res,"preExpansion");
	if ( str_preExpansion != str_nil ) {
		int v = atoi(str_preExpansion);

		if ( v < 1 ) {
		} else
			res->preExpansion = v;
	}
	res->fragmentSize = 0;
	/* 
	str str_fragmentSize = readCollParam(res,"fragmentSize");
	if ( str_fragmentSize != str_nil ) {
		int v = atoi(str_fragmentSize);

		if ( v < 1 ) {
		} else
			res->fragmentSize = v;
	}
	*/ 
	str str_name = readCollParam(res,"name");
	res->name = (char*)str_name;

	res->tokenize_fast = 0;
	str str_tokenizer = readCollParam(res,"tokenizer");
	if ( strcmp(str_tokenizer,"fast") == 0 )
		res->tokenize_fast = 1;

	/* */
        res->checkStopWords = 1;
	str str_stopw = readCollParam(res,"stopwords");
	if ( str_stopw ) {
	    if (  (strcmp(str_stopw,"false") == 0) || (strcmp(str_stopw,"off")==0) )
	        res->checkStopWords = 0;
	}
	res->lastStopWord   = 0;
	str str_laststopw = readCollParam(res,"lastStopWord");
	if ( str_laststopw != str_nil ) {
		long v = atol(str_laststopw);

		if ( v < 1 ) {
		} else
			res->lastStopWord = (oid)v;
	}
	str str_stemmer = readCollParam(res,"stemmer");

	if ( str_stemmer != str_nil ) 
		res->stemmer = GDKstrdup((char*)str_stemmer);
	else
		res->stemmer = NULL;
	if ( !(res->stemCtx = getStemmingContext(res->stemmer)) )
		return NULL;
	if ( res->stemCtx->init && !res->stemCtx->init(res->stemCtx,NULL) )
			return NULL;

        res->dict_handler = NULL;
        res->dict_id      = NULL;
        res->dict_score   = NULL;

	res->emitting     = 1;
	res->filterDepth  = 0;
	res->whitelisting = 0;
        res->b_filtering  = NULL;

	str wl = readCollParam(res,"whitelist");
	str bl = readCollParam(res,"blacklist");
	if ( wl != str_nil || bl != str_nil ) {
	    if ( wl != str_nil ) {
	    	if ( bl != str_nil ) {
		    GDKerror("Unable to mix whitelist/blacklist tag filters");
		    return NULL;
		}
		if ( !init_tagFiltering(res,"whitelist",wl) )
			return NULL;
	    } else {
		if ( !init_tagFiltering(res,"blacklist",bl) )
			return NULL;
	    }
	}

#ifdef TJ_TRACE
	if ( TJ_TRACE ) {
	   stream_printf(GDKout,"C[%s]: loadTijahContext() options read\n",res->name);
	   if ( res->fragmentSize )
	       stream_printf(GDKout,"C[%s]: loadTijahContext() fragmentSize = %d\n",res->name, res->fragmentSize);
        }
#endif
	/*
	 * The section where the parameter bats are read
	 */
#ifdef USE_TERMDB
	if ( !(res->tdb = tdb_open("termDB")) )
	    return NULL;
#endif
	if ( !(res->b_globalTerm  = getBAT(tjCtx_BAT,"termdict")) ) return NULL;
	res->n_globalTerm = (oid)BATcount(res->b_globalTerm);
	if ( !(res->b_globalTag   = getBAT(tjCtx_BAT,"tagdict")) ) return NULL;
	res->n_globalTag = (oid)BATcount(res->b_globalTag);
	if ( !(res->b_globalRTag   = getBAT(tjCtx_BAT,"rtags")) ) return NULL;
	res->tagswitch_sz = (int)res->n_globalTag;
	if ( res->tagswitch_sz < 128 )
		res->tagswitch_sz = 128;
	res->tagswitch_sz *= 2;
	res->tagswitch = GDKmalloc( res->tagswitch_sz );
	for(int i=0; i<res->tagswitch_sz; i++)
	    res->tagswitch[i] = 0;
	/*
	 *
	 */
	if ( !(res->b_docName     = getBAT(tjCtx_BAT,"doc_name")) ) return NULL;
	if ( !(res->b_docFirstPre = getBAT(tjCtx_BAT,"doc_firstpre")) ) return NULL;
	if ( !(res->b_collPre     = getBAT(tjCtx_BAT,"tid")) ) return NULL;
	if ( !(res->b_collSize    = getBAT(tjCtx_BAT,"size")) ) return NULL;
#ifdef USE_INEX_PATH
	if ( !(res->b_collPath    = getBAT(tjCtx_BAT,"path")) ) return NULL;
	if ( !(res->b_collPathNo    = getBAT(tjCtx_BAT,"pathno")) ) return NULL;
#endif
	if ( (res->tijahPre = getPreSize(res)) == oid_nil )
	     return NULL;;
	/* check here for new fragmentation */
	if ( res->fragmentSize ) {
	    if ( (BATcount(res->b_collPre) > res->fragmentSize) ) {
#ifdef TJ_TRACE
	        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]: loadTijahContext() [b_collPre|b_collSize] too big(%d), create new fragment\n",res->name,BATcount(res->b_collPre));
#endif
		BAT* fragments;
	        if ( !(fragments = getBAT(tjCtx_BAT,"fragments")) )
		    return NULL;
	        int newFragments  = (int)BATcount(fragments) + 1;
		/* */
		BBPunfix(BBPcacheid(res->b_collPre));
		res->b_collPre     = pftu_create_bat(pftu_batname1("tj_%s_tid%d",res->name,newFragments),TYPE_void,TYPE_oid,1);
		if ( !res->b_collPre ) 
		    return NULL;
		BBPfix(BBPcacheid(res->b_collPre));
	        BATseqbase(res->b_collPre,res->tijahPre);
		BBPunfix(BBPcacheid(res->b_collSize));
	        res->b_collSize    = pftu_create_bat(pftu_batname1("tj_%s_size%d",res->name,newFragments),TYPE_void,TYPE_int,1);
		if ( !res->b_collSize )
		    return NULL;
		BBPfix(BBPcacheid(res->b_collSize));
	        BATseqbase(res->b_collSize,res->tijahPre);
		if ( !BUNappend(fragments,&res->tijahPre,0) )
		    return NULL;
		BBPunfix(BBPcacheid(fragments));
		/* */
		str pretag = "_tid";
		bat prebat = BBPcacheid(res->b_collPre);
		if ( !BUNreplace(tjCtx_BAT,pretag,&prebat,0) ) { return NULL; }
		str sizetag = "_size";
		bat sizebat = BBPcacheid(res->b_collSize);
		if ( !BUNreplace(tjCtx_BAT,sizetag,&sizebat,0) ) { return NULL; }
#ifdef TJ_TRACE
	        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]: loadTijahContext() finished creating new fragments\n",res->name);
#endif
	    }
	}
	if ( dbat_init("b_collPre", &res->dbat_collPre, res->b_collPre) < -1 )
		return NULL;
	if ( dbat_init("b_collSize", &res->dbat_collSize, res->b_collSize) < -1 )
		return NULL;
	if ( !(res->b_collPfPre  = getBAT(tjCtx_BAT,"pfpre")) ) return NULL;
	/* */
	if ( !(res->b_conceptdict       = getBAT(tjCtx_BAT,"conceptdict")) )      return NULL;
	if ( !(res->b_concept_tid   = getBAT(tjCtx_BAT,"concept_tid")) )  return NULL;
	if ( !(res->b_concept_elem  = getBAT(tjCtx_BAT,"concept_elem")) ) return NULL;
	if ( !(res->b_concept_score = getBAT(tjCtx_BAT,"concept_score")) )return NULL;
	/* */
	res->tagStackPtr = 0;

#ifdef USE_TERMDB
	if ( tdb_isEmpty(res->tdb) ) {
	     if ( tdb_lookupTerm(res->tdb,(char*)stopwordMarker) == oid_nil )
	     	     return NULL;
	}
#endif
	/*
	 * Finally ensure there are accellerators on the Term and Tag dictionaries
	 */
	res->hm_globalTerm = BATmirror(res->b_globalTerm);

	if ( res->n_globalTerm == 0 ) {
	     // if ( !BUNins(res->b_globalTerm, &zero, (str)stopwordMarker, FALSE)){
	     
	     if ( !BUNappend(res->b_globalTerm, (str)stopwordMarker, FALSE)){
	             return NULL;
	     }
	     res->n_globalTerm++;

#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:INSERTED STOPWORDMARKER IN GLOBALTERM\n",res->name);
#endif
	     if ( res->checkStopWords ) {
		 for(int i=0; res->stemCtx->stopWords[i]; i++) {
		     str sw = (str)res->stemCtx->stopWords[i];
#ifdef USE_TERMDB
	             if ( !tdb_insertTerm(res->tdb,(char*)sw, zero, 0) ) {
		         return NULL;
		     }
#endif
	             // if ( !BUNins(res->b_globalTerm, &zero, sw, FALSE)){
	             if ( !BUNappend(res->b_globalTerm, sw, FALSE)){
                         GDKerror("loadTijahContext: inserting stopword fails\n");
	                 return NULL;
	             }
	             res->n_globalTerm++;
#ifdef TJ_TRACE
	             if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:ADDED STOPWORD \"%s\" to GLOBALTERM\n",res->name,sw);
#endif
		     }
		 res->lastStopWord = res->n_globalTerm; 
	         char buff[8];

	         sprintf(&buff[0],OIDFMT,res->lastStopWord);
	         if ( ! replaceCollParam(res,"lastStopWord",(str)&buff[0]))
	             return 0;
	     }
	}
	if ( res->b_globalTerm->T->hash == NULL ) {
#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CREATE NEW HASHTABLE ON GLOBALTERM\n",res->name);
#endif
	     if ( !BAThash(BATmirror(res->b_globalTerm),0) ) {
                 GDKerror("loadTijahContext: adding hashtable to globalTerm fails\n");
	         return NULL;
	     }
	}
	res->hm_globalTag = BATmirror(res->b_globalTag);
	if ( res->b_globalTag->T->hash == NULL ) {
#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CREATE NEW HASHTABLE ON GLOBALTAG\n",res->name);
#endif
	     if ( !BAThash(BATmirror(res->b_globalTag),0) ) {
                 GDKerror("loadTijahContext: adding hashtable to globalTag fails\n");
	         return NULL;
	     }
	}

	if ( ! (res->hm_globalTerm->H->hash && res->hm_globalTag->H->hash) )
	   stream_printf(GDKout,"# WARNING: MISSING HASH ON TAG/TERM DICTIONARY\n");
#ifdef USE_INEX_PATH
	if ( !(res->ipg = ipg_init(res->b_collPath, res->b_collPathNo)) )
		return NULL;
#endif
	return res;
}

static int
freeTijahContext(tjCtx* tjctx) {
        if ( !setPreSize(tjctx,tjctx->tijahPre) )
	        return GDK_FAIL;
	/* first store all new detected recursive tag oids */
	for(int i=0; i<tjctx->tagswitch_sz; i++) {
	    if ( tjctx->tagswitch[i] == 2) {
		oid store = (oid)i;
		if ( BUNfnd(tjctx->b_globalRTag,&store) == BUN_NONE ) {
                    str tagname = (str)0;
        	    BUN bun = BUNfnd(tjctx->b_globalTag,&store);
        	    if ( bun != BUN_NONE ) {
               	        BATiter mbi = bat_iterator(tjctx->b_globalTag);
               	        tagname = (str)BUNtail(mbi,bun);
        	    } else {
	    	        GDKerror("error retrieving recursive tagname");
		        return GDK_FAIL;
		    }
		    if ( !BUNins(tjctx->b_globalRTag, &store,tagname, 0)) {
	    	        GDKerror("error writing recursive tagbat");
		        return GDK_FAIL;
		    }
		}
            }
        }
#ifdef USE_TERMDB
	if ( ! tdb_close(tjctx->tdb) )
		return GDK_FAIL;
#endif
	/* BATkey(BATmirror(tjctx->b_globalTerm), TRUE); */
	/* BATkey(BATmirror(tjctx->b_globalTag), TRUE); */
	BATkey(BATmirror(tjctx->b_collPre), FALSE);
	BATkey(BATmirror(tjctx->b_collSize), FALSE);
	PROPDEBUG {
		BATpropcheck(tjctx->b_globalTerm,BATPROPS_ALL);
		BATpropcheck(tjctx->b_globalTag,BATPROPS_ALL);
		BATpropcheck(tjctx->b_docName,BATPROPS_ALL);
		BATpropcheck(tjctx->b_docFirstPre,BATPROPS_ALL);
		BATpropcheck(tjctx->b_collParam,BATPROPS_ALL);
		BATpropcheck(tjctx->b_collPre,BATPROPS_ALL);
		BATpropcheck(tjctx->b_collSize,BATPROPS_ALL);
		BATpropcheck(tjctx->b_collPfPre,BATPROPS_ALL);
		BATpropcheck(tjctx->b_conceptdict,BATPROPS_ALL);
		BATpropcheck(tjctx->b_concept_tid,BATPROPS_ALL);
		BATpropcheck(tjctx->b_concept_elem,BATPROPS_ALL);
		BATpropcheck(tjctx->b_concept_score,BATPROPS_ALL);
	}
	BBPunfix(BBPcacheid(tjctx->b_globalTerm));
	BBPunfix(BBPcacheid(tjctx->b_globalTag));
	BBPunfix(BBPcacheid(tjctx->b_globalRTag));
	BBPunfix(BBPcacheid(tjctx->b_docName));
	BBPunfix(BBPcacheid(tjctx->b_docFirstPre));
	BBPunfix(BBPcacheid(tjctx->b_collParam));
	BBPunfix(BBPcacheid(tjctx->b_collPre));
	BBPunfix(BBPcacheid(tjctx->b_collSize));
	BBPunfix(BBPcacheid(tjctx->b_collPfPre));
	BBPunfix(BBPcacheid(tjctx->b_conceptdict));
	BBPunfix(BBPcacheid(tjctx->b_concept_tid));
	BBPunfix(BBPcacheid(tjctx->b_concept_elem));
	BBPunfix(BBPcacheid(tjctx->b_concept_score));
	if ( tjctx->stemmer )
		GDKfree(tjctx->stemmer);
	GDKfree(tjctx->tagswitch);
	if ( tjctx->stemCtx->clear && !tjctx->stemCtx->clear(tjctx->stemCtx) )
		return GDK_FAIL;
#ifdef USE_INEX_PATH
	if ( !ipg_destroy(tjctx->ipg) )
		return GDK_FAIL;
#endif
	GDKfree(tjctx);
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[{}]:FINISH: add2collection_handler()\n");
#endif
	return GDK_SUCCEED;
}

static oid
tijahDocIndex(tjCtx* ctx, str docName) {
        BAT* mb = BATmirror(ctx->b_docName);

        BUN bun;
        bun = BUNfnd(mb,docName);
        if ( bun != BUN_NONE ) {
               BATiter mbi = bat_iterator(mb);
               return *(oid*)BUNtail(mbi,bun);
        }
	return oid_nil;
}

/*
 *
 *
 *
 */

static tjCtx* GLOBAL_TJCTX; /* INCOMPLETE, CODE NOT REENTRANT */

/**
 * Default driver initialization function
 */
static bool
pftijah_init(XqueryCtx* ctx, char* args, char* restag, char* resprefix) {
    (void) ctx;
    (void) args;
    (void) restag;
    (void) resprefix;

    ctx->driverWs = GLOBAL_TJCTX;
#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:pftijah_init()\n",GLOBAL_TJCTX->name);
#endif
    return 1;
}

#define HANDLE_DOC_ROOT

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static bool
pftijah_handle_startDocument(XqueryCtx* ctx, oid pre) {
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;


    tjctx->doc_height = tjctx->max_doc_height = 0;
#ifdef HANDLE_DOC_ROOT
    oid termOid, tjPre;

    if ( ++tjctx->doc_height > tjctx->max_doc_height )
        tjctx->max_doc_height = tjctx->doc_height;
    if ( (termOid = tj_tagOid(tjctx, "_DOCUMENT_ROOT")) == oid_nil )
        return 0;
    if ( (tjPre = tj_newPre(tjctx) ) == oid_nil )
        return 0;
    dbat_set_oid(&tjctx->dbat_collPre, tjPre, termOid);
    if ( tj_pushTag(tjctx,tjPre,termOid) < 0 ) return 0;
    if ( !BUNins(tjctx->b_collPfPre, &tjPre, &pre, FALSE) ) return 0;
#else
    (void)  pre;
#endif

#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:startDocument()\n",tjctx->name);
#endif
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
static bool
pftijah_handle_endDocument(XqueryCtx* ctx) {
#ifdef HANDLE_DOC_ROOT
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;

    --tjctx->doc_height;
    oid start = tj_popTag(tjctx); /* oid of the first node of the element */
    int size  = tjctx->tijahPre - start - 1; /* the Tijah document size */
    dbat_set_int(&tjctx->dbat_collSize,start,size);
#else
    (void) ctx;
#endif

#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:endDocument()\n",tjctx->name);
#endif
    return 1;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
static bool
pftijah_handle_attribute(XqueryCtx* ctx, str prefix, str loc, str value) {
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;

    (void)prefix;
    if ( tjctx->dict_handler ) {
    	if ( strcmp(loc,"name")==0 ) 
	    tjctx->dict_id = value;
	else if ( strcmp(loc,"score")==0 )
	    tjctx->dict_score = value;
	else if ( strcmp(loc,"tijah")==0 ) {
	    /* ignore xmlns attr */
	} else {
	    GDKerror("pftijah_handle_attribute: unknown pftijah dictionary attr[%s=%s]\n",loc,value);
	    return  0;
	}
    }
    return 1;
}

static int checkFilterTag(tjCtx* tjctx, str t) {
        BAT* mb = BATmirror(tjctx->b_filtering);

        BUN bun;
        bun = BUNfnd(mb,t);
        if ( bun != BUN_NONE ) {
	    /* hit a filter tag */
	    tjctx->emitting = tjctx->whitelisting;
	    tjctx->filterDepth = 1;
    	}
        return 1;
}

#define EMPTY_CHECK 

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static bool
pftijah_handle_startElement(XqueryCtx* ctx, str ns, str name, oid pre) {
    (void)ns;
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;
    oid termOid, tjPre;


    if ( ++tjctx->doc_height > tjctx->max_doc_height )
        tjctx->max_doc_height = tjctx->doc_height;

    if ( tjctx->b_filtering ) {
    	if ( tjctx->filterDepth )
    	    tjctx->filterDepth++;
	else
	    checkFilterTag(tjctx,name);
    }
    /* */
    if ( ns && strcmp(ns,"tijah")==0 ) {
        /* do not index "tijah" nodes, using blacklist to do this */
	tjctx->emitting     = 0; 
	tjctx->filterDepth  = 1;
	tjctx->dict_handler = name;
	tjctx->dict_id      = NULL;
	tjctx->dict_score   = NULL;
    }
    /* */
    if ( DOEMIT(tjctx) ) {
        if ( (termOid = tj_tagOid(tjctx, name)) == oid_nil )
    	    return 0;
        if ( (tjPre = tj_newPre(tjctx) ) == oid_nil )
    	    return 0;
        dbat_set_oid(&tjctx->dbat_collPre, tjPre, termOid);
        if ( tj_pushTag(tjctx,tjPre,termOid) < 0 ) return 0;
        tjctx->level_pre[tjctx->doc_height] = tjPre;
#ifdef TJ_TRACE
        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:startElement: \"%s\", termoid=%d, Tijah pre#=%d, Pathfinder pre#=%d\n",tjctx->name,name,termOid,tjPre,pre);
#endif
        if ( !BUNins(tjctx->b_collPfPre, &tjPre, &pre, FALSE) ) return 0;
#ifdef USE_INEX_PATH
	if ( !ipg_pushtag(tjctx->ipg, name, tjPre) )
		return 0;
#endif
    }
    return 1;
}

static bool
handle_dictionary(tjCtx* tjctx, oid elem) {
	if ( !tjctx->dict_id ) {
	   tjctx->dict_handler = NULL;
	   GDKerror("no id attr specified for \"tijah:%s\" node",tjctx->dict_handler);
	}
	double score;

	if ( tjctx->dict_score ) {
	   score = atof(tjctx->dict_score);
	} else 
	   score = 1.0;
	char b[256];
	sprintf(b,"%s:%s",tjctx->dict_handler,tjctx->dict_id);
	char *key = &b[0];

        BUN bun;
	oid dict_oid;
	
	BAT* mcd = BATmirror(tjctx->b_conceptdict);
        if ( (bun = BUNfnd(mcd,key)) != BUN_NONE ) {
            BATiter ti = bat_iterator(mcd);
            dict_oid = *(oid*)BUNtail(ti,bun);
        } else {
	    dict_oid = (oid)BATcount(tjctx->b_conceptdict);

    	    if ( !BUNins(tjctx->b_conceptdict, &dict_oid,(str)key, FALSE)){
    	        GDKerror("dictbat: insert \"%s\" in tagbat fails.\n",key);
    	        return false;
	    }
        } 
    	/* use dict_oid */
	if ( 
	      !BUNappend(tjctx->b_concept_tid,  &dict_oid, 0) || 
	      !BUNappend(tjctx->b_concept_elem, &elem, 0)  ||
	      !BUNappend(tjctx->b_concept_score, &score, 0) 
	   ) {
		GDKerror("dictbat: writing dict record fails.");
		return false;
	}

#ifdef TJ_TRACE
    	if ( TJ_TRACE ) fprintf(stdout,"!HANDLING DICTIONARY ITEM[%d@0][%s,id=%s,score=%s]\n",(int)dict_oid,tjctx->dict_handler,tjctx->dict_id,tjctx->dict_score);
#endif

	/* */
	tjctx->dict_handler = NULL;
	return true;
}

static bool
pftijah_complete_startElementEmpty(XqueryCtx* ctx) {
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;
    --tjctx->doc_height;
    if ( DOEMIT(tjctx) ) {
        oid start = tj_popTag(tjctx); /* oid of the first node of the element */
        int size  = tjctx->tijahPre - start - 1; /* the Tijah element size */
        dbat_set_int(&tjctx->dbat_collSize,start,size);
    };
#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:empty_endElement: \"%s\"\n", tjctx->name,"");
#endif
    if ( tjctx->filterDepth ) {
        /* a filter is currently 'on' */
        if ( --tjctx->filterDepth == 0 ) {
		/* end of filter */
	        tjctx->emitting = !(tjctx->whitelisting);

	}
    }
    if (tjctx->dict_handler && !handle_dictionary(tjctx,tjctx->level_pre[tjctx->doc_height]))
	return 0;
#ifdef USE_INEX_PATH
	if ( !ipg_poptag(tjctx->ipg) )
		return 0;
#endif
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static bool
pftijah_handle_endElement(XqueryCtx* ctx, str ns, str name) {
    (void)ns;
    (void)name;
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;
    --tjctx->doc_height;
    if ( DOEMIT(tjctx) ) {
        oid start = tj_popTag(tjctx); /* oid of the first node of the element */
        int size  = tjctx->tijahPre - start - 1; /* the Tijah element size */
	dbat_set_int(&tjctx->dbat_collSize,start,size);
#ifdef TJ_TRACE
        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:endElement: \"%s\"\n", tjctx->name,name);
#endif
    }
    if ( tjctx->filterDepth ) {
        /* a filter is currently 'on' */
        if ( --tjctx->filterDepth == 0 ) {
		/* end of filter */
	        tjctx->emitting = !(tjctx->whitelisting);
	}
    }
    if (tjctx->dict_handler && !handle_dictionary(tjctx,tjctx->level_pre[tjctx->doc_height]))
	return 0;
#ifdef USE_INEX_PATH
	if ( !ipg_poptag(tjctx->ipg) )
		return 0;
#endif
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static bool
pftijah_handle_characters(XqueryCtx* ctx, str ch) {
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;

    register char* p = (char*)ch;
    while( *p && isspace(*p) ) p++;
    if ( !*p )
        return 1;
#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:handle_characters(%s) start\n",tjctx->name, p);
#endif

    if ( DOEMIT(tjctx) ) {
	if ( tjctx->tokenize_fast)
            return tokenize_fast(p,tjctx);
	else
            return tokenize_flex(p,tjctx);
    }
    return 1;
}

char* normalizeTerm(struct tijahContextStruct *tjctx, char* term ) {
	char *res;
        res = flexScanOneTerm((char*)term);
        if ( res && tjctx && tjctx->stemCtx->stem) {
    	    if ( !(res = (char*)tjctx->stemCtx->stem(tjctx->stemCtx,(char*)res)) ) {
	        /* must be a stopword */
	        return NULL;
	    }
        }
	return res;
}

int CMDtj_normalizeTerm(char** res, char *term, char *stemmer) {
    tjStemCtx* stemCtx = getStemmingContext( stemmer );

    if ( stemCtx->stem ) {
        if ( !stemCtx->udf && stemCtx->init ) stemCtx->init( stemCtx, NULL );

        char* stemmed = (char *)stemCtx->stem( stemCtx, term );
        if ( !stemmed ) {
            *res = NULL;
        } else {
            //if (*res) GDKfree(*res);
            *res = GDKstrdup( stemmed );
	    if ( !*res ) {
	        stream_printf(GDKout,"CMDtj_normalizeTerm: GDKmalloc() failed.\n");
		return GDK_FAIL;
	    }
        }
        //if ( stemCtx->clear ) stemCtx->clear( stemCtx );
    } else {
        //if (*res) GDKfree(*res);
        *res = GDKstrdup( term );
	if ( !*res ) {
	    stream_printf(GDKout,"CMDtj_normalizeTerm: GDKmalloc() failed.\n");
	    return GDK_FAIL;
	}
    }
    return GDK_SUCCEED;
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static bool
pftijah_handle_ignorableWhitespace(XqueryCtx* ctx, str ch) {
    return pftijah_handle_characters(ctx,ch); /* dispatch */
}

/**
 *
 * Definition of the structure containing the functions
 */
struct serializeFunStruct pftijahSerializeFun = {
    "pftijah",
    pftijah_init,
    null_cleanup,

    null_startSerialize,
    null_endSerialize,

    pftijah_handle_startDocument,
    pftijah_handle_endDocument,
    pftijah_handle_startElement,
    pftijah_handle_endElement,
    pftijah_handle_characters,
    pftijah_handle_ignorableWhitespace,
    null_handle_comment,
    null_handle_processingInstruction,

    null_complete_startElement,
    pftijah_complete_startElementEmpty,
    pftijah_handle_attribute,

    null_seqEmitBool,
    null_seqEmitInt,
    null_seqEmitDbl,
    null_seqEmitStr,
    null_handle_attribute,
    null_handle_characters,

    null_seqStart,
    null_complete_seqStart,
    null_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    null_seqItemSeparator
};

/*
 *
 *
 */

static int
add2collection_handler(int justIndex, BAT* tjCtx_BAT, BAT* ws, str docName) {
	tjCtx* tjctx;

#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[{}]:START: add2collection_handler(%s)\n",docName);
#endif
	if ( !(tjctx = loadTijahContext(tjCtx_BAT)) )
		return GDK_FAIL;

	/* return the main plane, the caller should check if the main plane
	 * has changed and this one should be added.
	 */ 
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:LOADED CONTEXT\n",tjctx->name);
#endif

#ifdef USE_INEX_PATH
	if ( !ipg_startdoc(tjctx->ipg,docName) )
		return GDK_FAIL;
#endif

	if ( tijahDocIndex(tjctx,docName) != oid_nil ) {
	    stream_printf(GDKerr,"add2collection_handler(CTX,%s) already in collection\n",docName);
	    return GDK_FAIL;
	}
	oid start_oid = tjctx->tijahPre;

	if ( !BUNappend(tjctx->b_docName, docName, 0) ||
	     !BUNappend(tjctx->b_docFirstPre, &start_oid, 0) )
	   stream_printf(GDKerr,"Error writing Tijah document record\n");;
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:START INDEXING\n",tjctx->name);
#endif

	GLOBAL_TJCTX = tjctx;
	if ( justIndex ) {
#ifdef TJ_TRACE
	    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CALL INDEXING SHREDDER\n",tjctx->name);
#endif
	    XqueryCtx xqctx;
	    /* StM:
	     * changed the original `EXTshred_and_index_doc(docName, (str)"", &pftijahSerializeFun, &xqctx)` into this;
	     * it compiles and loads, but I have now idea, whether it does work;
	     * especially the last parameter (lock *collLock) should most probably not be NULL
	     * (atleast if we desire any consistent concurrency) ...
	     */
	    if ( shred(BATnew(TYPE_str,TYPE_bat,30), docName, NULL, NULL, 0, &pftijahSerializeFun, &xqctx, NULL) == GDK_FAIL)
	    	 return GDK_FAIL;
	} else {
#ifdef TJ_TRACE
	    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CALL INDEXING SERIALIZER\n",tjctx->name);
#endif
	    if ( xquery_print_doc_DRIVER("",&pftijahSerializeFun,NULL,ws,docName) == GDK_FAIL)
	        return GDK_FAIL;
	}
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:FINISH INDEXING\n",tjctx->name);
#endif
	if ( dbat_finalize(&tjctx->dbat_collPre, tjctx->tijahPre) < 0 )
		return GDK_FAIL;
	if ( dbat_finalize(&tjctx->dbat_collSize, tjctx->tijahPre) < 0 )
		return GDK_FAIL;

        tjctx->b_collPre->batDirty   = TRUE;
        tjctx->b_collSize->batDirty  = TRUE;
        tjctx->b_collPfPre->batDirty = TRUE;
	if ( 1 /* INCOMPLETE */ ) {
            tjctx->b_conceptdict->batDirty       = TRUE;
            tjctx->b_concept_tid->batDirty   = TRUE;
            tjctx->b_concept_elem->batDirty  = TRUE;
            tjctx->b_concept_score->batDirty = TRUE;
	}
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:FINALIZED DIRECT BATS\n",tjctx->name);
#endif
	/* read elapsed time */
#ifdef TJ_TRACE
	if ( TJ_TRACE ) {
		stream_printf(GDKout,"C[%s]:SIZES\n",tjctx->name);
		stream_printf(GDKout,"C[%s]:size( b_globalTerm ) = %d\n",tjctx->name, BATcount(tjctx->b_globalTerm));
		stream_printf(GDKout,"C[%s]:size( b_globalTag )  = %d\n",tjctx->name, BATcount(tjctx->b_globalTag));
		stream_printf(GDKout,"C[%s]:size( b_globalRTag )  = %d\n",tjctx->name, BATcount(tjctx->b_globalRTag));
		stream_printf(GDKout,"C[%s]:size( b_collPre )    = %d\n",tjctx->name, BATcount(tjctx->b_collPre));
		stream_printf(GDKout,"C[%s]:size( b_collSize )   = %d\n",tjctx->name, BATcount(tjctx->b_collSize));
		stream_printf(GDKout,"C[%s]:size( b_collPfPre )  = %d\n",tjctx->name, BATcount(tjctx->b_collPfPre));

	}
#endif
	return freeTijahContext(tjctx);
}

static int
add2collection_bathandler(BAT* tjCtx_BAT, BAT* ws, BAT* docs) {
	tjCtx* tjctx;

	if (0) stream_printf(GDKout,"#! a2c_bat: start.\n");
	if ( !(tjctx = loadTijahContext(tjCtx_BAT)) )
		return GDK_FAIL;

	/* return the main plane, the caller should check if the main plane
	 * has changed and this one should be added.
	 */ 
	 

	BUN p,q;
        BATiter doci = bat_iterator(docs);
	BATloop(docs, p, q) {
	    ptr docsTAIL = BUNtail(doci, p);
	    str docName    = (str) docsTAIL;

	    if (0) stream_printf(GDKout,"#! a2c_bat: indexing doc(%s).\n",docName);
	    if ( tijahDocIndex(tjctx,docName) != oid_nil ) {
	        stream_printf(GDKerr,"add2collection_handler(CTX,%s) already in collection\n",docName);
	        return GDK_FAIL;
	    }
	    oid start_oid = tjctx->tijahPre;

#ifdef USE_INEX_PATH
		if ( !ipg_startdoc(tjctx->ipg,docName) )
			return GDK_FAIL;
#endif
    
	    if ( !BUNappend(tjctx->b_docName, docName, 0) ||
	         !BUNappend(tjctx->b_docFirstPre, &start_oid, 0) )
	       stream_printf(GDKerr,"Error writing Tijah document record\n");;
    
	    GLOBAL_TJCTX = tjctx;
	    if ( xquery_print_doc_DRIVER("",&pftijahSerializeFun,NULL,ws,docName) == GDK_FAIL)
	    	return GDK_FAIL;
        }
        if ( dbat_finalize(&tjctx->dbat_collPre, tjctx->tijahPre) < 0 )
	    return GDK_FAIL;
        if ( dbat_finalize(&tjctx->dbat_collSize, tjctx->tijahPre) < 0 )
	    return GDK_FAIL;
   
        tjctx->b_collPre->batDirty   = TRUE;
        tjctx->b_collSize->batDirty  = TRUE;
        tjctx->b_collPfPre->batDirty = TRUE;
        if ( 1 /* INCOMPLETE */ ) {
           tjctx->b_conceptdict->batDirty       = TRUE;
           tjctx->b_concept_tid->batDirty   = TRUE;
           tjctx->b_concept_elem->batDirty  = TRUE;
           tjctx->b_concept_score->batDirty = TRUE;
        }
	if (0) stream_printf(GDKout,"#! a2c_bat: finish.\n");
        return freeTijahContext(tjctx);
}   

int
CMDtj_throw2collection_bat(BAT* tjCtx_BAT, BAT* ws, BAT* docs) {
    return add2collection_bathandler(tjCtx_BAT,ws,docs);
}

int
CMDtj_throw2collection(BAT* tjCtx_BAT, BAT* ws, str docName, str dummy) {
    (void)dummy;
    return  add2collection_handler(0,tjCtx_BAT,ws,docName);
}

int
CMDtj_throw2collection_index(BAT* tjCtx_BAT, str locName) {
    return  add2collection_handler(1,tjCtx_BAT,NULL,locName);
}

/* vim:set shiftwidth=4 expandtab: */
