@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2007 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'

@f serialize_pftijah_options
@a Jan Flokstra
@a Henning Rode
@t serialize_pftijah_options

@h

extern int serialize_pftijah_options_DRIVER(
	BAT**			res;
        BAT*			ws,
        size_t			niters,
        BAT*			loop,
        BAT*			iter,
        BAT*			item, 
        BAT*			kind,
        BAT*			intVAL,
        BAT*			dblVAL,
        BAT*			strVAL);

@c
#include <pf_config.h>

/*******************************************
 * serialize_pftijah_option.c : Tijah options serialization
 *
 */

#include "pftijah.h"
#include "serialize.h"
/* contains dummy callback functions */
#include "serialize_null.h"

typedef struct PTOS {
    int  cnt;			/* count the number of tags here */
    BAT* bat;			/* [str,str] result BAT */
    const char* errorMessage;	/* error message buffer */
} PTOS;

static struct PTOS* GLOBAL_PTOS = NULL;

/**
 *
 * Definition of the structure containing the functions
 */
static bool
pftijah_options_init(XqueryCtx* ctx, char* args, char *restag, char *resprefix) {
    (void) args;
    (void) restag;
    (void) resprefix;
    ctx->driverWs		= GLOBAL_PTOS;
    GLOBAL_PTOS->errorMessage	= NULL;
#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: pftijah_options_init() called.\n");
#endif
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static bool
pftijah_options_handle_startElement(XqueryCtx* ctx, str ns, str name, oid pre) {
    struct PTOS* ptoctx = (struct PTOS*)ctx->driverWs;
    (void)ns;
    (void)pre;

    if ( strcmp("TijahOptions",name) != 0 ) {
        /* error here */
#ifdef DEBUG
        stream_printf(GDKout,"pft_opt_deb: pftijah_options_handle_startElement(%s) FAILS[badname].\n",name);
#endif
	return 0;
    }
    if ( ++ptoctx->cnt != 1 ) {
        /* error here */
        stream_printf(GDKout,"pft_opt_deb: pftijah_options_handle_startElement(%s) FAILS[badcount].\n",name);
	return 0;
    }
#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: pftijah_options_handle_startElement(%s) SUCCES.\n",name);
#endif
    return 1;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
static bool
pftijah_options_handle_attribute(XqueryCtx* ctx, str prefix, str loc, str value) {
    struct PTOS* ptoctx = (struct PTOS*)ctx->driverWs;
    (void)prefix;
    if ( 1 && strcmp(loc,"debug") == 0 ) {
	int v = atoi(value);
	SET_TDEBUG(v);
	if (TDEBUG(1)) stream_printf(GDKout,"# pftijah_option_handler: setting debug value to %d.\n",v);
    }
    if ( !BUNins(ptoctx->bat, loc, value, FALSE) ) {
        stream_printf(GDKout,"pft_opt_deb: pftijah_options_handle_attribute(%s,%s) FAILS[BUNins].\n",loc,value);
        /* error message here */
	return 0;
    }
#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: pftijah_options_handle_attribute(%s,%s) SUCCES.\n",loc,value);
#endif
    return 1;
}

static struct serializeFunStruct pftijah_optionsSerializeFun = {
    "pftijah_options",
    pftijah_options_init,
    null_cleanup,

    null_startSerialize,
    null_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    pftijah_options_handle_startElement,
    null_handle_endElement,
    null_handle_characters,
    null_handle_ignorableWhitespace,
    null_handle_comment,
    null_handle_processingInstruction,

    null_complete_startElement,
    null_complete_startElementEmpty,
    pftijah_options_handle_attribute,

    null_seqEmitBool,
    null_seqEmitInt,
    null_seqEmitDbl,
    null_seqEmitStr,
    null_handle_attribute,
    null_handle_characters,

    null_seqStart,
    null_complete_seqStart,
    null_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    null_seqItemSeparator
};

int serialize_pftijah_options_DRIVER(
	BAT**			res,
        BAT*			ws,
        size_t			niters,
        BAT*			loop,
        BAT*			iter,
        BAT*			item, 
        BAT*			kind,
        BAT*			intVAL,
        BAT*			dblVAL,
        BAT*			strVAL) {

	(void)niters;
	(void)loop;
	(void)iter;
	struct PTOS ptos;
	if ( GLOBAL_PTOS ) {
	    /* error locked ?? */
	    return GDK_FAIL;
	}
	GLOBAL_PTOS = &ptos;
	ptos.cnt = 0;
	ptos.bat = BATnew(TYPE_str, TYPE_str, 32);
#ifdef DEBUG
	stream_printf(GDKout,"******** NITERS = %d\n",niters);
	BATprintf(GDKout,loop);
	BATprintf(GDKout,iter);
	BATprintf(GDKout,item);
	BATprintf(GDKout,kind);
	BATprintf(GDKout,strVAL);
#endif
	int returnVal = xquery_print_result_DRIVER(
		"",
		&pftijah_optionsSerializeFun,
		"",
        	ws,
        	1,    /* niters, */
        	item, /* loop, */
        	item, /* iter, */
        	item, 
        	kind,
        	intVAL,
        	dblVAL,
        	strVAL);
#ifdef DEBUG
	stream_printf(GDKout,"CALLED xquery_print_result_DRIVER: res=%d\n",returnVal);
	BATprintf(GDKout,ptos.bat);
#endif
	*res = ptos.bat;
	GLOBAL_PTOS = NULL;
	return returnVal;
}

/* vim:set shiftwidth=4 expandtab: */
