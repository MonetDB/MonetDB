@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the PfTijah Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://dbappl.cs.utwente.nl/Legal/PfTijah-1.1.html
@' 
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@' 
@' The Original Code is the PfTijah system.
@' 
@' The Initial Developer of the Original Code is the "University of Twente".
@' Portions created by the "University of Twente" are 
@' Copyright (C) 2006-2007 "University of Twente".
@' All Rights Reserved.
@'

@f termdb
@a Jan Flokstra
@a Henning Rode
@t termdb

@h

/*
 * CHANGES: make all term bats of type [str,oid] because all major operations
 *          use BUNfnd and hashing and these work more easy with the string
 *          in the head
 *
 * BUGS: stopword problem. Multiple stopword collections on one term db is
 *       never goiing to work.
 */

/* #define USE_TERMDB */ /* used by serialize_pftijah */

#define TDB_DEBUG if ( 0 ) stream_printf
#define TDB_OUT   GDKout
/* #define TDB_SHOWLOOKUP */ /* used to debug all term lookups */

#define TERMDBCONF	"tj_termDBconf"
#define TERMDBTAGS	"tj_termDBtags0"
#define TERMDBFRAGMENTS	"tj_termDBfragments"
#define TERMDBBAT	"tj_termDBbat%d"

#define TDB_LOC_NFRAG       0
#define TDB_LOC_MAXFRAGSIZE 1
#define TDB_LOC_CURFRAG     2
#define TDB_LOC_CUROID      3
#define TDB_LOC_TREE(I)     (oid)(I+4)

typedef struct termDbCtx {
	BAT*	frags;
	BAT*	conf;
	oid	nFrag;
	oid	maxFragSize;
	oid	curFrag;
	oid	curOid;
	oid	startOid;
	//
	oid     curTagOid;
	BAT*	tags;
	//
	unsigned int nBuckets;
	//
	int*	buckets;
	BAT**	hashbat;
	size_t* hashbatSize;
} termDbCtx;

extern int termdb_prelude(void);

extern termDbCtx* tdb_open(char* name);
extern int	  tdb_insertTerm(termDbCtx* tdb, char* term, oid o, int check);
extern oid	  tdb_lookupTerm(termDbCtx* tdb, char* term);
extern oid	  tdb_lookupTag(termDbCtx* tdb, char* term);
extern int        tdb_close(termDbCtx* tdb);
extern int        tdb_isEmpty(termDbCtx* tdb);

@c
#include <pf_config.h>

/*******************************************
 * termdb.c : the parallel term database
 *
 */

#include <gdk.h>

#include "pftijah_util.h"

#include "termdb.h"

static int tdb_destroyCnt = 0;

INLINE static BAT *tdb_prepare2destroy(BAT* bat) {
    char buff[32];

    sprintf(buff,"tdb_destroy%d",tdb_destroyCnt++);
    BBPrename(BBPcacheid(bat),(str)buff);
    bat->batPersistence = TRANSIENT;
    return bat;
}

INLINE static int tdb_destroyBAT(str name) {
    bat b = BBPindex(name);

    if ( b == bat_nil ) {
        stream_printf(GDKout,"#termdb:tdb_destroyBAT(\"%s\"): bat deletion failed.\n",name);
        return 0;
    } else {
        BAT* bat = BBPdescriptor(b);

        bat->batPersistence = TRANSIENT;
	BATdelete(bat);
        /* stream_printf(GDKout,"#termdb:tdb_destroyBAT(\"%s\")\n",name); */
        return 1;
    }
}

INLINE static char* hashbatName(char* format, int i) {
    static char buff[32];

    sprintf(buff,format,i);
    return buff;
}


INLINE static oid tdb_findOid(BAT* void_oid_bat, oid idx) {
	BUN bun;

	BUNfndVOID(bun,void_oid_bat,&idx);
	if ( bun ) {
	    return *(oid*)BUNtail(void_oid_bat,bun);
	} else {
	    return oid_nil;
	}
}

INLINE static int tdb_replaceOid(BAT* void_oid_bat, oid idx, oid v) {
	if ( !BUNreplace(void_oid_bat,&idx,&v,0) ) {
            stream_printf(GDKout,"#tdb_replaceOid: BUNreplace failed.\n");
	    return 0;
	} else
	    return 1;
}

BAT* tdb_findBat(BAT* void_bat_bat, oid idx) {
	BUN bun;

	BUNfndVOID(bun,void_bat_bat,&idx);
	if ( bun ) {
	    bat resbat = *(bat*)BUNtail(void_bat_bat,bun);
    	    return BBPdescriptor(resbat);
	} else {
	    return NULL;
	}
}

int termdb_prelude() {
    TDB_DEBUG(TDB_OUT,"#termdb:prelude: start.\n");

    BAT* conf = pftu_lookup_bat(TERMDBCONF);

    if ( conf ) {
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: found conf bat: \"%s\".\n",TERMDBCONF);
        if ( pftu_lookup_bat(TERMDBFRAGMENTS) ) {
            stream_printf(GDKout,"#termdb_prelude: bat \"%s\"already exists.\n",TERMDBFRAGMENTS);
            return GDK_FAIL;
        }
        BAT* rt = pftu_create_bat(TERMDBFRAGMENTS,TYPE_void,TYPE_bat,0);
	if ( !rt )
	    return GDK_FAIL;
        BBPfix(BBPcacheid(rt));
        BATseqbase(rt,(oid)0);

	oid curFrag = tdb_findOid(conf,TDB_LOC_CURFRAG); 
	if ( curFrag == oid_nil ) {
            stream_printf(GDKout,"#termdb_prelude: read nil curFrag.\n");
	    return GDK_FAIL;
	}
	for(int i=0; i<(int)curFrag; i++) {
	    BAT* fb = pftu_lookup_bat(hashbatName(TERMDBBAT,i));

            if ( !fb || !BUNappend(rt, &BBPcacheid(fb), 0) ) {
                stream_printf(GDKout,"#termdb_prelude: fail to add fragbat[%i] to rt bat.\n");
	        return GDK_FAIL;
	    }
	}
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: created runtime bat: \"%s\".\n",TERMDBFRAGMENTS);
	if ( 0 ) BATprintf(GDKout,rt);
    } else {
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: no conf bat: \"%s\".\n",TERMDBCONF);
    }
    return GDK_SUCCEED;
}

int CMDtj_create_termdb(int* p_nFrag, oid* p_maxFragSize) {
    oid nFrag       = *p_nFrag;
    oid maxFragSize = *p_maxFragSize;
    int dynamic     = (maxFragSize != oid_nil);
    oid curFrag     = (dynamic ? (oid)1 :nFrag);
    oid curOid      = (oid)0; /* first oid in termdb */

    TDB_DEBUG(TDB_OUT,"#termdb: CMDtj_create_termdb(" OIDFMT "," OIDFMT ").\n",nFrag, maxFragSize);

    BAT* conf;
    
    if ( pftu_lookup_bat(TERMDBCONF) ) {
        stream_printf(GDKout,"#CMDtj_create_termdb: bat \"%s\"already exists.\n",TERMDBCONF);
        return GDK_FAIL;
    }
    if (!(conf = pftu_create_bat(TERMDBCONF,TYPE_void,TYPE_oid,1/*persistent*/)))
        return GDK_FAIL;
    BATseqbase(conf,(oid)0);
    if ( !BUNappend(conf, &nFrag, 0) ||
         !BUNappend(conf, &maxFragSize, 0) ||
         !BUNappend(conf, &curFrag, 0) ||
         !BUNappend(conf, &curOid, 0) 
    ) {
        stream_printf(GDKout,"#ERROR: CMDtj_create_termdb: error writing conf HEADER.\n");
        return GDK_FAIL;
    }

    if ( ! (pftu_create_bat(TERMDBTAGS,TYPE_str,TYPE_oid,1/*persistent*/)) )
                return GDK_FAIL;

    oid lastbat = 0;
    for(int i=0; i< (int)nFrag; i++) {
        if (  (i==0) || !dynamic ) {
	    lastbat = (oid)i;
            if ( ! pftu_create_bat(hashbatName(TERMDBBAT,i),TYPE_str,TYPE_oid,1/*persistent*/))
                return GDK_FAIL;
	}
    	if ( !BUNappend(conf, &lastbat, 0) ) {
            stream_printf(GDKout,"#ERROR: CMDtj_create_termdb: error writing hash tree HEADER.\n");
	    return GDK_FAIL;
	}
    }
    if ( 0 ) BATprintf(GDKout,conf);
    return termdb_prelude();
}

/*
 *
 */
 
extern BAT* get_fragBAT(termDbCtx* tdb, int idx);

static void dumpTDBtree(termDbCtx* tdb) {
    stream_printf(GDKout,"# TDB TREE=[");
    for(int i=0; i<(int)tdb->nFrag; i++) {
        stream_printf(GDKout,"%d[%d] ",i,tdb->buckets[i]);
    }
    stream_printf(GDKout,"]\n");
}

static void dumpTDB(termDbCtx* tdb,char* p) {
int i;

    stream_printf(GDKout,"########################################\n");
    stream_printf(GDKout,"### dump of termDB: %s. #####\n",p);
    stream_printf(GDKout,"########################################\n");
    dumpTDBtree(tdb);
    stream_printf(GDKout,"FRAGMENT BATS: \n",p);
    for(i=0; i<(int)tdb->curFrag; i++) {
        stream_printf(GDKout,"BAT[frag#=%d]: \n",i);
	BATprintf(GDKout,get_fragBAT(tdb,i));
    }
}

int CMDtj_dispose_termdb() {
    TDB_DEBUG(TDB_OUT,"#termdb: start CMDtj_dispose_termdb().\n");
    termDbCtx *tdb = tdb_open("termDB");

    if ( 0 ) {
	dumpTDB(tdb,"DISPOSED termDB");
    }
    if ( !tdb ) {
        stream_printf(GDKout,"#ERROR: CMDtj_dispose_termdb: fail to open termDB.\n");
	return  GDK_FAIL;
    }
    oid curFrag = tdb->curFrag;
    if ( ! tdb_close(tdb) ) {
        stream_printf(GDKout,"#ERROR: CMDtj_dispose_termdb: fail to close termDB.\n");
	return  GDK_FAIL;
    }
    TDB_DEBUG(TDB_OUT,"#termdb: CMDtj_dispose_termdb() throw away conf bats.\n");
    if ( !tdb_destroyBAT(TERMDBCONF) ||
         !tdb_destroyBAT(TERMDBTAGS) ||
         !tdb_destroyBAT(TERMDBFRAGMENTS)
       ) {
    	return GDK_FAIL;
    }
    for(int i=0; i<(int)curFrag; i++) {
	if ( !tdb_destroyBAT(hashbatName(TERMDBBAT,i)) )
	    return GDK_FAIL;
        TDB_DEBUG(TDB_OUT,"#termdb: CMDtj_dispose_termdb() delete frag[%d].\n",i);
    }
    TDB_DEBUG(TDB_OUT,"#termdb: finish CMDtj_dispose_termdb().\n");
    return GDK_SUCCEED;
}

/*
 *
 */

int tdb_checkHashTable(BAT* b) {
    if ( b->hhash == NULL ) {
         if ( !BAThash(b,0) ) {
                 stream_printf(GDKout,"#termdb:tdb_checkHashTable: fail to creat hashtable on [oid,str] bat.\n");
             return 0;
         } else {
            TDB_DEBUG(TDB_OUT,"#termdb:tdb_checkHashTable(): created hashtable on [oid,str] bat.\n");
	}
    }
    return 1;
}

/*
 *
 *
 */

termDbCtx* tdb_open(char* name) {
    (void)name; // incomplete, termDB's should have a name
    TDB_DEBUG(TDB_OUT,"#termdb: start tdb_open().\n");

    BAT* tdb_frags = pftu_lookup_bat(TERMDBFRAGMENTS);
    if ( !tdb_frags ) {
        stream_printf(GDKout,"#ERROR:tdb_open: no termdb runtime bat found.\n");
    	return NULL;
    }
    termDbCtx* tdb = GDKmalloc(sizeof(termDbCtx));
    if ( !tdb ) {
        stream_printf(GDKout,"#ERROR:tdb_open: out of memory on termDbCtx malloc.\n");
    	return NULL;
    }

    tdb->frags	= tdb_frags;
    BBPfix(BBPcacheid(tdb->frags));
    tdb->conf	= pftu_lookup_bat(TERMDBCONF);
    if ( tdb->conf == NULL ) {
        stream_printf(GDKout,"#ERROR:tdb_open: unable to load conf bat.\n");
    	return NULL;
    }
    BBPfix(BBPcacheid(tdb->conf));
    //
    tdb->tags        = pftu_lookup_bat(TERMDBTAGS);
    if ( tdb->tags == NULL ) {
        stream_printf(GDKout,"#ERROR:tdb_open: unable to load tags bat.\n");
    	return NULL;
    }
    BBPfix(BBPcacheid(tdb->tags));
    if ( !tdb_checkHashTable(tdb->tags) )
        return NULL;
    tdb->curTagOid   = (oid)BATcount(tdb->tags);
    //
    tdb->nFrag       = tdb_findOid(tdb->conf,TDB_LOC_NFRAG);
    tdb->nBuckets    = (unsigned int)tdb->nFrag;
    tdb->curOid      = tdb_findOid(tdb->conf,TDB_LOC_CUROID);
    tdb->startOid    = tdb->curOid;
    tdb->curFrag     = tdb_findOid(tdb->conf,TDB_LOC_CURFRAG);
    tdb->maxFragSize = tdb_findOid(tdb->conf,TDB_LOC_MAXFRAGSIZE);

    TDB_DEBUG(TDB_OUT,"#termdb: loaded conf parameters:\n");
    TDB_DEBUG(TDB_OUT,"#termdb: nFrag       = " OIDFMT "\n",tdb->nFrag);
    TDB_DEBUG(TDB_OUT,"#termdb: maxFragSize = " OIDFMT "\n",tdb->maxFragSize);
    TDB_DEBUG(TDB_OUT,"#termdb: curOid      = " OIDFMT "\n",tdb->curOid);
    TDB_DEBUG(TDB_OUT,"#termdb: curFrag     = " OIDFMT "\n",tdb->curFrag);

    tdb->buckets = GDKmalloc((int)tdb->nFrag  * sizeof(int));
    tdb->hashbat= GDKmalloc((int)tdb->curFrag* sizeof(BAT*));
    if ( !tdb->buckets || !tdb->hashbat ) {
        stream_printf(GDKout,"#ERROR:tdb_open: out of memory on bucket/bats malloc.\n");
    	return NULL;
    }
    if ( tdb->maxFragSize == oid_nil) {
    	tdb->hashbatSize = NULL;
    } else {
    	tdb->hashbatSize = GDKmalloc((int)tdb->curFrag* sizeof(size_t));
	if ( !tdb->hashbatSize ) {
	    stream_printf(GDKout,"#ERROR:tdb_open: out of memory on hashbatSize malloc.\n");
	    return NULL;

	}
        TDB_DEBUG(TDB_OUT,"#termdb: create hashbatSize[%d] array.\n",(int)tdb->curFrag);
    }
    int i;

    for(i=0; i<(int)tdb->nFrag; i++) {
        tdb->buckets[i] = (int)tdb_findOid(tdb->conf,TDB_LOC_TREE(i));
    }
    for(i=0; i<(int)tdb->curFrag; i++) {
        tdb->hashbat[i] = NULL; // demand loading
	if ( tdb->hashbatSize )
		tdb->hashbatSize[i] = 0;
    }
    TDB_DEBUG(TDB_OUT,"#termdb: finish tdb_open().\n");
    return tdb;
}

int tdb_isEmpty(termDbCtx* tdb) {
    return (tdb->curOid == 0);
}

int tdb_close(termDbCtx* tdb) {
    TDB_DEBUG(TDB_OUT,"#termdb: execute tdb_close().\n");
    if ( tdb->startOid != tdb->curOid ) {
        if ( !tdb_replaceOid(tdb->conf,TDB_LOC_CUROID,tdb->curOid) )
	    return 0;
    }
    GDKfree(tdb->buckets);
    TDB_DEBUG(TDB_OUT,"#termdb: active hash-distr =");
    for(int i=0; i<(int)tdb->curFrag; i++) {
        if ( tdb->hashbat[i] ) {
            TDB_DEBUG(TDB_OUT," %d[%d]",i,(int)BATcount(tdb->hashbat[i]));
	    BBPunfix(BBPcacheid(tdb->hashbat[i]));
	} else {
            TDB_DEBUG(TDB_OUT," %d[X]",i);
	}
    }
    TDB_DEBUG(TDB_OUT,".\n");
    GDKfree(tdb->hashbat);
    if ( tdb->hashbatSize ) 
        GDKfree(tdb->hashbatSize);
    BBPunfix(BBPcacheid(tdb->conf));
    BBPunfix(BBPcacheid(tdb->tags));
    BBPunfix(BBPcacheid(tdb->frags));
    GDKfree(tdb);
    TDB_DEBUG(TDB_OUT,"#termdb: finish tdb_close().\n");
    return 1;
}

INLINE static unsigned long hashTerm(char* str) {
    unsigned long res = 0;
    int ch;

    while ( (ch = *str++) )
        res = ch + (res << 6) + (res << 16) - res;

    return res;
}

BAT* get_fragBAT(termDbCtx* tdb, int idx) {
    BAT* res;

    if ( (res = tdb->hashbat[idx]) )
        return res;
    else {
    	res = tdb_findBat(tdb->frags,idx);
	if ( ! res ) {
            stream_printf(GDKout,"#termdb:get_fragBAT: unable to load fragment[%d].\n",idx);
	    return NULL;
	}
	if ( !tdb_checkHashTable(res) )
	    return NULL;
	BBPfix(BBPcacheid(res));
	tdb->hashbat[idx] = res;
	if ( tdb->hashbatSize ) {
	    tdb->hashbatSize[idx] = BATcount(res);
	}
        TDB_DEBUG(TDB_OUT,"#termdb:get_fragBAT(): loaded fragment[%d].\n",idx);
	return res;
    }
}

int tdb_splitBucket(termDbCtx* tdb, int frag) {
    // dumpTDB(tdb,"before split");
    TDB_DEBUG(TDB_OUT,"#termdb:tdb_splitBucket(tdb,%d): called.\n",frag);
    int i, lower = -1, upper = -1;
    for(i=0; i<(int)tdb->nFrag; i++) {
    	if ( tdb->buckets[i] == frag ) {
	    if ( lower == -1 )
	        lower = i;
	     if ( i > upper )
	        upper = i;
	}
    }
    TDB_DEBUG(TDB_OUT,"# tdb_splitBucket(), frag=%d, range=[%d,%d]\n",frag,lower,upper);
    int new_fragIdx = tdb->curFrag;
    int range = ((upper+1)-lower);
    if ( range == 1 ) {
        stream_printf(GDKout,"# WARNING: tdb_splitBucket(), frag=%d, range=[%d,%d], UNABLE to split\n",frag,lower,upper);
	tdb->hashbatSize[frag] = 0; // to be able to continue
        return 1;
    }
    for(i=lower+range/2; i<=upper ; i++) {
        TDB_DEBUG(TDB_OUT,"# tdb_splitBucket(), bucket[%d] = %d\n",i,(int)new_fragIdx);
	tdb->buckets[i] = new_fragIdx;
        if ( !tdb_replaceOid(tdb->conf,TDB_LOC_TREE(i),(oid)new_fragIdx) )
            return 0;
    }
    BAT* old_frag = tdb_prepare2destroy(tdb->hashbat[frag]);
    BAT* new_frag;
    if ( !(tdb->hashbat[frag] = pftu_create_bat(hashbatName(TERMDBBAT,frag),TYPE_str,TYPE_oid,1/*persistent*/)) ||

         !(new_frag = pftu_create_bat(hashbatName(TERMDBBAT,new_fragIdx),TYPE_str,TYPE_oid,1/*persistent*/)) )
        return 0;
    BBPfix(BBPcacheid(new_frag));
    BBPfix(BBPcacheid(tdb->hashbat[frag]));
    //
    oid oid_frag = (oid)frag;
    if ( !BUNappend(tdb->frags, &BBPcacheid(new_frag), 0) ||
	 !BUNreplace(tdb->frags,&oid_frag,&BBPcacheid(tdb->hashbat[frag]),0)
       ) {
	   stream_printf(GDKout,"# ERROR: unable to update frag bat.\n");
           return 0;
    }
    /*
     *
     */
    tdb->hashbat= GDKrealloc(tdb->hashbat,1+(int)tdb->curFrag* sizeof(BAT*));
    assert(tdb->hashbat);
    tdb->hashbat[new_fragIdx] = 0;
    if (tdb->hashbatSize) {
        tdb->hashbatSize = GDKrealloc(tdb->hashbatSize,1+(int)tdb->curFrag* sizeof(size_t));
        assert(tdb->hashbatSize);
        tdb->hashbatSize[frag]        = 0;
        tdb->hashbatSize[new_fragIdx] = 0;
    }
    /*
     *
     */
    BUN p, q;
    BATloop(old_frag, p, q) {
	str h = (str) BUNhead(old_frag, p);
	oid t = *(oid*)BUNtail(old_frag, p);

	if ( !tdb_insertTerm(tdb,h,t,1 /*incomplete, should be 0 */ ) )
	    return 0;
    }
    BBPunfix(BBPcacheid(old_frag));
    if ( !tdb_replaceOid(tdb->conf,TDB_LOC_CURFRAG,++tdb->curFrag) )
        return 0;
    /* oeff, ready */
    return 1;
}


int tdb_insertTerm(termDbCtx* tdb, char* term, oid o, int check) {
    int frag = tdb->buckets[hashTerm(term) % tdb->nBuckets];

    BAT* fragTerm = get_fragBAT(tdb, frag);

    if ( ! fragTerm )
    	return 0;
    if ( check && BUNfnd(fragTerm,term) ) {
        stream_printf(GDKout,"#tdb_insertTerm:frag[%d]: duplicate term \"%s\".\n",frag,term);
        return 0;
    } else {
    	if ( !BUNins(fragTerm, (str)term, &o, FALSE)){
    	    GDKerror("tdb_insertTerm: insert \"%s\" in termbat fails.\n");
    	    return 0;
        } 
	if ( tdb->hashbatSize ) {
	    if ( (size_t)++tdb->hashbatSize[frag] > (size_t)tdb->maxFragSize)
	        if ( !tdb_splitBucket(tdb,frag) )
		    return 0;
	}
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_insertTerm[%d](\"%s\") = " OIDFMT "[new]\n",frag,term,o);
#endif
    }
    return 1;
}

oid tdb_lookupTerm(termDbCtx* tdb, char* term) {
    if (1) TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTerm(\"%s\") start\n",term);
    int frag = tdb->buckets[hashTerm(term) % tdb->nBuckets];

    BAT* fragTerm = get_fragBAT(tdb, frag);

    if ( ! fragTerm )
    	return oid_nil;
    BUN bun;
    if ( (bun = BUNfnd(fragTerm,term)) ) {
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTerm[%d](\"%s\") = " OIDFMT "\n",frag,term,*(oid*)BUNtail(fragTerm,bun));
#endif
        return *(oid*)BUNtail(fragTerm,bun);
    } else {
    	if ( !BUNins(fragTerm, (str)term, &tdb->curOid, FALSE)){
    	    GDKerror("tdb_lookup: insert \"%s\" in termbat fails.\n");
    	    return oid_nil;
        }  
	if ( tdb->hashbatSize ) {
	    if ( (size_t)++tdb->hashbatSize[frag] > (size_t)tdb->maxFragSize)
	        if ( !tdb_splitBucket(tdb,frag) )
	            return oid_nil;
	}
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTerm[%d](\"%s\") = " OIDFMT "[new]\n",frag,term,tdb->curOid);
#endif
    	return tdb->curOid++;
    }
}

oid tdb_lookupTag(termDbCtx* tdb, char* tag) {
    BUN bun;
	
    if ( (bun = BUNfnd(tdb->tags,tag)) ) {
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTag(\"%s\") = " OIDFMT "\n",tag,*(oid*)BUNtail(tdb->tags,bun));
#endif
        return *(oid*)BUNtail(tdb->tags,bun);
    } else {
    	if ( !BUNins(tdb->tags, (str)tag, &tdb->curTagOid, FALSE)){
    	    GDKerror("tdb_lookupTag: insert \"%s\" in tagbat fails.\n");
    	    return oid_nil;
        } else { 
#ifdef TDB_SHOWLOOKUP
            TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTag(\"%s\") = " OIDFMT "[new]\n",tag,tdb->curTagOid);
#endif
    	    return tdb->curTagOid++;
        }
    }
}

/* vim:set shiftwidth=4 expandtab: */
